// This file has been automatically generated by "kdu_hyperdoc"
// Do not edit manually.
// Copyright 2001, David Taubman, The University of New South Wales (UNSW)

#ifndef KDU_MNI_H
using namespace System;
namespace kdu_mni {
  // Managed classes defined here.
  ref class Ckdu_global_funcs;
  ref class Cads_params;
  ref class Catk_params;
  ref class Ccod_params;
  ref class Ccrg_params;
  ref class Cdfs_params;
  ref class Cjp2_channels;
  ref class Cjp2_colour;
  ref class Cjp2_colour_converter;
  ref class Cjp2_data_references;
  ref class Cjp2_dimensions;
  ref class Cjp2_family_src;
  ref class Cjp2_family_tgt;
  ref class Cjp2_input_box;
  ref class Cjp2_locator;
  ref class Cjp2_output_box;
  ref class Cjp2_palette;
  ref class Cjp2_resolution;
  ref class Cjp2_source;
  ref class Cjp2_target;
  ref class Cjpx_codestream_source;
  ref class Cjpx_codestream_target;
  ref class Cjpx_compatibility;
  ref class Cjpx_composition;
  ref class Cjpx_fragment_list;
  ref class Cjpx_frame_expander;
  ref class Cjpx_input_box;
  ref class Cjpx_layer_source;
  ref class Cjpx_layer_target;
  ref class Cjpx_meta_manager;
  ref class Cjpx_metanode;
  ref class Cjpx_roi;
  ref class Cjpx_source;
  ref class Cjpx_target;
  ref class Ckdu_analysis;
  ref class Ckdu_block;
  ref class Ckdu_block_decoder;
  ref class Ckdu_block_encoder;
  ref class Ckdu_cache;
  ref class Ckdu_channel_mapping;
  ref class Ckdu_client;
  ref class Ckdu_client_notifier;
  ref class Ckdu_client_translator;
  ref class Ckdu_clientx;
  ref class Ckdu_codestream;
  ref class Ckdu_codestream_comment;
  ref class Ckdu_compositor_buf;
  ref class Ckdu_compressed_source;
  ref class Ckdu_compressed_source_nonnative;
  ref class Ckdu_compressed_target;
  ref class Ckdu_compressed_target_nonnative;
  ref class Ckdu_compressed_video_source;
  ref class Ckdu_compressed_video_target;
  ref class Ckdu_coords;
  ref class Ckdu_decoder;
  ref class Ckdu_dims;
  ref class Ckdu_encoder;
  ref class Ckdu_line_buf;
  ref class Ckdu_message;
  ref class Ckdu_message_formatter;
  ref class Ckdu_metareq;
  ref class Ckdu_multi_analysis;
  ref class Ckdu_multi_synthesis;
  ref class Ckdu_node;
  ref class Ckdu_output;
  ref class Ckdu_params;
  ref class Ckdu_precinct;
  ref class Ckdu_pull_ifc;
  ref class Ckdu_push_ifc;
  ref class Ckdu_range_set;
  ref class Ckdu_region_compositor;
  ref class Ckdu_region_decompressor;
  ref class Ckdu_resolution;
  ref class Ckdu_roi_image;
  ref class Ckdu_roi_node;
  ref class Ckdu_sample_allocator;
  ref class Ckdu_sampled_range;
  ref class Ckdu_serve;
  ref class Ckdu_serve_target;
  ref class Ckdu_servex;
  ref class Ckdu_simple_file_source;
  ref class Ckdu_simple_file_target;
  ref class Ckdu_simple_video_source;
  ref class Ckdu_simple_video_target;
  ref class Ckdu_stripe_compressor;
  ref class Ckdu_stripe_decompressor;
  ref class Ckdu_subband;
  ref class Ckdu_synthesis;
  ref class Ckdu_thread_entity;
  ref class Ckdu_thread_env;
  ref class Ckdu_thread_safe_message;
  ref class Ckdu_tiffdir;
  ref class Ckdu_tile;
  ref class Ckdu_tile_comp;
  ref class Ckdu_window;
  ref class Ckdu_worker;
  ref class Cmcc_params;
  ref class Cmco_params;
  ref class Cmct_params;
  ref class Cmj2_source;
  ref class Cmj2_target;
  ref class Cmj2_video_source;
  ref class Cmj2_video_target;
  ref class Corg_params;
  ref class Cpoc_params;
  ref class Cqcd_params;
  ref class Crgn_params;
  ref class Csiz_params;

  // Derived versions of unmanaged classes, declared in "kdu_mni.cpp"
  class _mni_delegator__kdu_cache;
  class _mni_delegator__kdu_client_notifier;
  class _mni_delegator__kdu_compressed_source_nonnative;
  class _mni_delegator__kdu_compressed_target_nonnative;
  class _mni_delegator__kdu_message;
  class _mni_delegator__kdu_region_compositor;

  //---------------------------------------------------
  // Managed Class: Ckdu_global_funcs
  public ref class Ckdu_global_funcs {
  public:
    static Int32 ceil_ratio(Int32 num, Int32 den);
    static Int32 floor_ratio(Int32 num, Int32 den);
    static Int64 jp2_4cc_to_int(String ^ string);
    static Boolean jp2_is_superbox(Int64 box_type);
    static void kdu_convert_rgb_to_ycc(Ckdu_line_buf ^c1, Ckdu_line_buf ^c2, Ckdu_line_buf ^c3);
    static void kdu_convert_ycc_to_rgb(Ckdu_line_buf ^c1, Ckdu_line_buf ^c2, Ckdu_line_buf ^c3, Int32 width);
    static void kdu_convert_ycc_to_rgb(Ckdu_line_buf ^c1, Ckdu_line_buf ^c2, Ckdu_line_buf ^c3);
    static void kdu_customize_errors(Ckdu_message ^handler);
    static void kdu_customize_text(String ^ context, Int64 id, String ^ lead_in, String ^ text);
    static void kdu_customize_text(String ^ context, Int64 id, cli::array<Int32> ^lead_in, cli::array<Int32> ^text);
    static void kdu_customize_warnings(Ckdu_message ^handler);
    static Int32 kdu_fseek(IntPtr fp, Int64 offset);
    static Int32 kdu_fseek(IntPtr fp, Int64 offset, Int32 origin);
    static Int64 kdu_ftell(IntPtr fp);
    static String ^ kdu_get_core_version();
    static Int32 kdu_get_num_processors();
    static void kdu_print_error(String ^ message);
    static void kdu_print_warning(String ^ message);
    static Int32 long_ceil_ratio(Int64 num, Int64 den);
    static Int32 long_floor_ratio(Int64 num, Int64 den);
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_channels
  public ref class Cjp2_channels {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    void copy(Cjp2_channels ^src);
    void init(Int32 num_colours);
    void set_colour_mapping(Int32 colour_idx, Int32 codestream_component, Int32 lut_idx, Int32 codestream_idx);
    void set_colour_mapping(Int32 colour_idx, Int32 codestream_component, Int32 lut_idx);
    void set_colour_mapping(Int32 colour_idx, Int32 codestream_component);
    void set_opacity_mapping(Int32 colour_idx, Int32 codestream_component, Int32 lut_idx, Int32 codestream_idx);
    void set_opacity_mapping(Int32 colour_idx, Int32 codestream_component, Int32 lut_idx);
    void set_opacity_mapping(Int32 colour_idx, Int32 codestream_component);
    void set_premult_mapping(Int32 colour_idx, Int32 codestream_component, Int32 lut_idx, Int32 codestream_idx);
    void set_premult_mapping(Int32 colour_idx, Int32 codestream_component, Int32 lut_idx);
    void set_premult_mapping(Int32 colour_idx, Int32 codestream_component);
    void set_chroma_key(Int32 colour_idx, Int32 key_val);
    Int32 get_num_colours();
    Boolean get_colour_mapping(Int32 colour_idx, cli::interior_ptr<Int32> codestream_component, cli::interior_ptr<Int32> lut_idx, cli::interior_ptr<Int32> codestream_idx);
    Boolean get_opacity_mapping(Int32 colour_idx, cli::interior_ptr<Int32> codestream_component, cli::interior_ptr<Int32> lut_idx, cli::interior_ptr<Int32> codestream_idx);
    Boolean get_premult_mapping(Int32 colour_idx, cli::interior_ptr<Int32> codestream_component, cli::interior_ptr<Int32> lut_idx, cli::interior_ptr<Int32> codestream_idx);
    Boolean get_chroma_key(Int32 colour_idx, cli::interior_ptr<Int32> key_val);
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_colour
  public ref class Cjp2_colour {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    void copy(Cjp2_colour ^src);
    void init(Int32 space);
    void init(Int32 space, Int32 Lrange, Int32 Loff, Int32 Lbits, Int32 Arange, Int32 Aoff, Int32 Abits, Int32 Brange, Int32 Boff, Int32 Bbits, Int64 illuminant, Int32 temperature);
    void init(Int32 space, Int32 Lrange, Int32 Loff, Int32 Lbits, Int32 Arange, Int32 Aoff, Int32 Abits, Int32 Brange, Int32 Boff, Int32 Bbits, Int64 illuminant);
    void init(Int32 space, Int32 Lrange, Int32 Loff, Int32 Lbits, Int32 Arange, Int32 Aoff, Int32 Abits, Int32 Brange, Int32 Boff, Int32 Bbits);
    void init(cli::array<Byte> ^icc_profile);
    void init(cli::array<Byte> ^uuid, Int32 data_bytes, cli::array<Byte> ^data);
    void init(Double gamma, Double beta, Int32 num_points);
    void init(Double gamma, Double beta);
    void init(Double gamma);
    void init(cli::array<Double> ^xy_red, cli::array<Double> ^xy_green, cli::array<Double> ^xy_blue, Double gamma, Double beta, Int32 num_points, Boolean reference_is_D50);
    void init(cli::array<Double> ^xy_red, cli::array<Double> ^xy_green, cli::array<Double> ^xy_blue, Double gamma, Double beta, Int32 num_points);
    void init(cli::array<Double> ^xy_red, cli::array<Double> ^xy_green, cli::array<Double> ^xy_blue, Double gamma, Double beta);
    void init(cli::array<Double> ^xy_red, cli::array<Double> ^xy_green, cli::array<Double> ^xy_blue, Double gamma);
    Int32 get_num_colours();
    Int32 get_space();
    Boolean is_opponent_space();
    Int32 get_precedence();
    Byte get_approximation_level();
    IntPtr get_icc_profile(cli::array<Int32> ^num_bytes);
    IntPtr get_icc_profile();
    Boolean get_lab_params(cli::interior_ptr<Int32> Lrange, cli::interior_ptr<Int32> Loff, cli::interior_ptr<Int32> Lbits, cli::interior_ptr<Int32> Arange, cli::interior_ptr<Int32> Aoff, cli::interior_ptr<Int32> Abits, cli::interior_ptr<Int32> Brange, cli::interior_ptr<Int32> Boff, cli::interior_ptr<Int32> Bbits, cli::interior_ptr<Int64> illuminant, cli::interior_ptr<Int32> temperature);
    Boolean get_jab_params(cli::interior_ptr<Int32> Lrange, cli::interior_ptr<Int32> Loff, cli::interior_ptr<Int32> Lbits, cli::interior_ptr<Int32> Arange, cli::interior_ptr<Int32> Aoff, cli::interior_ptr<Int32> Abits, cli::interior_ptr<Int32> Brange, cli::interior_ptr<Int32> Boff, cli::interior_ptr<Int32> Bbits);
    Boolean check_cie_default();
    Boolean get_vendor_uuid(cli::array<Byte> ^uuid);
    IntPtr get_vendor_data(cli::array<Int32> ^num_bytes);
    IntPtr get_vendor_data();
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_colour_converter
  public ref class Cjp2_colour_converter {
  protected:
    jp2_colour_converter * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Cjp2_colour_converter()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    jp2_colour_converter * _get_kref() { return (jp2_colour_converter *) _kref; }
    Cjp2_colour_converter(jp2_colour_converter * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Cjp2_colour_converter() { Do_dispose(false); }
    Cjp2_colour_converter();
    void clear();
    Boolean init(Cjp2_colour ^colour, Boolean use_wide_gamut, Boolean prefer_fast_approximations);
    Boolean init(Cjp2_colour ^colour, Boolean use_wide_gamut);
    Boolean init(Cjp2_colour ^colour);
    Boolean exists();
    Boolean get_wide_gamut();
    Boolean is_approximate();
    Boolean is_non_trivial();
    Boolean convert_lum(Ckdu_line_buf ^line, Int32 width);
    Boolean convert_lum(Ckdu_line_buf ^line);
    Boolean convert_rgb(Ckdu_line_buf ^red, Ckdu_line_buf ^green, Ckdu_line_buf ^blue, Int32 width);
    Boolean convert_rgb(Ckdu_line_buf ^red, Ckdu_line_buf ^green, Ckdu_line_buf ^blue);
    Boolean convert_rgb4(Ckdu_line_buf ^red, Ckdu_line_buf ^green, Ckdu_line_buf ^blue, Ckdu_line_buf ^extra, Int32 width);
    Boolean convert_rgb4(Ckdu_line_buf ^red, Ckdu_line_buf ^green, Ckdu_line_buf ^blue, Ckdu_line_buf ^extra);
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_data_references
  public ref class Cjp2_data_references {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Int32 add_url(String ^ url, Int32 url_idx);
    Int32 add_url(String ^ url);
    Int32 get_num_urls();
    Int32 find_url(String ^ url);
    String ^ get_url(Int32 idx);
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_dimensions
  public ref class Cjp2_dimensions {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    void copy(Cjp2_dimensions ^src);
    void init(Ckdu_coords ^size, Int32 num_components, Boolean unknown_space, Int32 compression_type);
    void init(Ckdu_coords ^size, Int32 num_components, Boolean unknown_space);
    void init(Ckdu_coords ^size, Int32 num_components);
    void init(Csiz_params ^siz, Boolean unknown_space);
    void init(Csiz_params ^siz);
    void finalize_compatibility(Ckdu_params ^root);
    void finalize_compatibility(Cjp2_dimensions ^src);
    void set_precision(Int32 component_idx, Int32 bit_depth, Boolean is_signed);
    void set_precision(Int32 component_idx, Int32 bit_depth);
    void set_ipr_box_available();
    Ckdu_coords ^get_size();
    Int32 get_num_components();
    Boolean colour_space_known();
    Int32 get_bit_depth(Int32 component_idx);
    Boolean get_signed(Int32 component_idx);
    Int32 get_compression_type();
    Boolean is_ipr_box_available();
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_family_src
  public ref class Cjp2_family_src {
  protected:
    jp2_family_src * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Cjp2_family_src()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    jp2_family_src * _get_kref() { return (jp2_family_src *) _kref; }
    Cjp2_family_src(jp2_family_src * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Cjp2_family_src() { Do_dispose(false); }
    Cjp2_family_src();
    Boolean exists();
    void open(String ^ fname, Boolean allow_seeks);
    void open(String ^ fname);
    void open(Ckdu_compressed_source ^indirect);
    void open(Ckdu_cache ^cache);
    void close();
    Boolean uses_cache();
    Boolean is_top_level_complete();
    Int32 get_id();
    String ^ get_filename();
    virtual void acquire_lock();
    virtual void release_lock();
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_family_tgt
  public ref class Cjp2_family_tgt {
  protected:
    jp2_family_tgt * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Cjp2_family_tgt()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    jp2_family_tgt * _get_kref() { return (jp2_family_tgt *) _kref; }
    Cjp2_family_tgt(jp2_family_tgt * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Cjp2_family_tgt() { Do_dispose(false); }
    Cjp2_family_tgt();
    Boolean exists();
    void open(String ^ fname);
    void open(Ckdu_compressed_target ^indirect);
    Int64 get_bytes_written();
    void close();
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_locator
  public ref class Cjp2_locator {
  protected:
    jp2_locator * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Cjp2_locator()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    jp2_locator * _get_kref() { return (jp2_locator *) _kref; }
    Cjp2_locator(jp2_locator * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Cjp2_locator() { Do_dispose(false); }
    Cjp2_locator();
    Boolean is_null();
    Int64 get_file_pos();
    void set_file_pos(Int64 pos);
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_palette
  public ref class Cjp2_palette {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    void copy(Cjp2_palette ^src);
    void init(Int32 num_luts, Int32 num_entries);
    void set_lut(Int32 lut_idx, cli::array<Int32> ^lut, Int32 bit_depth, Boolean is_signed);
    void set_lut(Int32 lut_idx, cli::array<Int32> ^lut, Int32 bit_depth);
    Int32 get_num_entries();
    Int32 get_num_luts();
    Int32 get_bit_depth(Int32 lut_idx);
    Boolean get_signed(Int32 lut_idx);
    void get_lut(Int32 lut_idx, cli::array<Single> ^lut);
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_resolution
  public ref class Cjp2_resolution {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    void copy(Cjp2_resolution ^src);
    void init(Single aspect_ratio);
    void set_different_capture_aspect_ratio(Single aspect_ratio);
    void set_resolution(Single resolution, Boolean for_display);
    void set_resolution(Single resolution);
    Single get_aspect_ratio(Boolean for_display);
    Single get_aspect_ratio();
    Single get_resolution(Boolean for_display);
    Single get_resolution();
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_codestream_source
  public ref class Cjpx_codestream_source {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Int32 get_codestream_id();
    Cjp2_locator ^get_header_loc();
    Cjp2_dimensions ^access_dimensions(Boolean finalize_compatibility);
    Cjp2_dimensions ^access_dimensions();
    Cjp2_palette ^access_palette();
    Cjp2_locator ^get_stream_loc();
    Boolean stream_ready();
    Cjpx_fragment_list ^access_fragment_list();
    Cjpx_input_box ^open_stream(Cjpx_input_box ^my_resource);
    Cjpx_input_box ^open_stream();
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_codestream_target
  public ref class Cjpx_codestream_target {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Int32 get_codestream_id();
    Cjp2_dimensions ^access_dimensions();
    Cjp2_palette ^access_palette();
    Cjpx_fragment_list ^access_fragment_list();
    void add_fragment(String ^ url, Int64 offset, Int64 length);
    void write_fragment_table();
    Cjp2_output_box ^open_stream();
    Ckdu_compressed_target ^access_stream();
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_compatibility
  public ref class Cjpx_compatibility {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Boolean is_jp2();
    Boolean is_jp2_compatible();
    Boolean is_jpxb_compatible();
    Boolean has_reader_requirements_box();
    Boolean check_standard_feature(Int32 feature_id);
    Boolean check_vendor_feature(cli::array<Byte> ^uuid);
    Boolean get_standard_feature(Int32 which, cli::interior_ptr<Int32> feature_id);
    Boolean get_standard_feature(Int32 which, cli::interior_ptr<Int32> feature_id, cli::interior_ptr<Boolean> is_supported);
    Boolean get_vendor_feature(Int32 which, cli::array<Byte> ^uuid);
    Boolean get_vendor_feature(Int32 which, cli::array<Byte> ^uuid, cli::interior_ptr<Boolean> is_supported);
    void set_standard_feature_support(Int32 feature_id, Boolean is_supported);
    void set_vendor_feature_support(cli::array<Byte> ^uuid, Boolean is_supported);
    Boolean test_fully_understand();
    Boolean test_decode_completely();
    void copy(Cjpx_compatibility ^src);
    void set_used_standard_feature(Int32 feature_id, Byte fully_understand_sub_expression, Byte decode_completely_sub_expression);
    void set_used_standard_feature(Int32 feature_id, Byte fully_understand_sub_expression);
    void set_used_standard_feature(Int32 feature_id);
    void set_used_vendor_feature(cli::array<Byte> ^uuid, Byte fully_understand_sub_expression, Byte decode_completely_sub_expression);
    void set_used_vendor_feature(cli::array<Byte> ^uuid, Byte fully_understand_sub_expression);
    void set_used_vendor_feature(cli::array<Byte> ^uuid);
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_composition
  public ref class Cjpx_composition {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    void copy(Cjpx_composition ^src);
    Int32 get_global_info(Ckdu_coords ^size);
    IntPtr get_next_frame(IntPtr last_frame);
    IntPtr get_prev_frame(IntPtr last_frame);
    void get_frame_info(IntPtr frame_ref, cli::interior_ptr<Int32> num_instructions, cli::interior_ptr<Int32> duration, cli::interior_ptr<Int32> repeat_count, cli::interior_ptr<Boolean> is_persistent);
    IntPtr get_last_persistent_frame(IntPtr frame_ref);
    Boolean get_instruction(IntPtr frame_ref, Int32 instruction_idx, cli::interior_ptr<Int32> layer_idx, cli::interior_ptr<Int32> increment, cli::interior_ptr<Boolean> is_reused, Ckdu_dims ^source_dims, Ckdu_dims ^target_dims);
    Boolean get_original_iset(IntPtr frame_ref, Int32 instruction_idx, cli::interior_ptr<Int32> iset_idx, cli::interior_ptr<Int32> inum_idx);
    IntPtr add_frame(Int32 duration, Int32 repeat_count, Boolean is_persistent);
    Int32 add_instruction(IntPtr frame_ref, Int32 layer_idx, Int32 increment, Ckdu_dims ^source_dims, Ckdu_dims ^target_dims);
    void set_loop_count(Int32 count);
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_fragment_list
  public ref class Cjpx_fragment_list {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    void add_fragment(Int32 url_idx, Int64 offset, Int64 length);
    Int64 get_total_length();
    Int32 get_num_fragments();
    Boolean get_fragment(Int32 frag_idx, cli::interior_ptr<Int32> url_idx, cli::interior_ptr<Int64> offset, cli::interior_ptr<Int64> length);
    Int32 locate_fragment(Int64 pos, cli::interior_ptr<Int64> bytes_into_fragment);
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_frame_expander
  public ref class Cjpx_frame_expander {
  protected:
    jpx_frame_expander * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Cjpx_frame_expander()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    jpx_frame_expander * _get_kref() { return (jpx_frame_expander *) _kref; }
    Cjpx_frame_expander(jpx_frame_expander * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Cjpx_frame_expander() { Do_dispose(false); }
    Cjpx_frame_expander();
    void reset();
    Int32 test_codestream_visibility(Cjpx_source ^source, IntPtr frame, Int32 iteration_idx, Boolean follow_persistence, Int32 codestream_idx, Ckdu_dims ^composition_region, Ckdu_dims ^codestream_roi, Boolean ignore_use_in_alpha, Int32 initial_matches_to_skip);
    Int32 test_codestream_visibility(Cjpx_source ^source, IntPtr frame, Int32 iteration_idx, Boolean follow_persistence, Int32 codestream_idx, Ckdu_dims ^composition_region, Ckdu_dims ^codestream_roi, Boolean ignore_use_in_alpha);
    Int32 test_codestream_visibility(Cjpx_source ^source, IntPtr frame, Int32 iteration_idx, Boolean follow_persistence, Int32 codestream_idx, Ckdu_dims ^composition_region, Ckdu_dims ^codestream_roi);
    Int32 test_codestream_visibility(Cjpx_source ^source, IntPtr frame, Int32 iteration_idx, Boolean follow_persistence, Int32 codestream_idx, Ckdu_dims ^composition_region);
    Boolean construct(Cjpx_source ^source, IntPtr frame, Int32 iteration_idx, Boolean follow_persistence, Ckdu_dims ^region_of_interest);
    Boolean construct(Cjpx_source ^source, IntPtr frame, Int32 iteration_idx, Boolean follow_persistence);
    Boolean has_non_covering_members();
    Int32 get_num_members();
    IntPtr get_member(Int32 which, cli::interior_ptr<Int32> instruction_idx, cli::interior_ptr<Int32> layer_idx, cli::interior_ptr<Boolean> covers_composition, Ckdu_dims ^source_dims, Ckdu_dims ^target_dims);
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_layer_source
  public ref class Cjpx_layer_source {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Int32 get_layer_id();
    Cjp2_locator ^get_header_loc();
    Cjp2_channels ^access_channels();
    Cjp2_resolution ^access_resolution();
    Cjp2_colour ^access_colour(Int32 which);
    Int32 get_num_codestreams();
    Int32 get_codestream_id(Int32 which);
    Ckdu_coords ^get_layer_size();
    Boolean have_stream_headers();
    Int32 get_codestream_registration(Int32 which, Ckdu_coords ^alignment, Ckdu_coords ^sampling, Ckdu_coords ^denominator);
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_layer_target
  public ref class Cjpx_layer_target {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Cjp2_channels ^access_channels();
    Cjp2_resolution ^access_resolution();
    Cjp2_colour ^add_colour(Int32 prec, Byte approx);
    Cjp2_colour ^add_colour(Int32 prec);
    Cjp2_colour ^add_colour();
    Cjp2_colour ^access_colour(Int32 which);
    void set_codestream_registration(Int32 codestream_id, Ckdu_coords ^alignment, Ckdu_coords ^sampling, Ckdu_coords ^denominator);
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_meta_manager
  public ref class Cjpx_meta_manager {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    void set_box_filter(Int32 num_box_types, cli::array<Int64> ^box_types);
    Cjpx_metanode ^access_root();
    Cjpx_metanode ^locate_node(Int64 file_pos);
    Cjpx_metanode ^get_touched_nodes();
    Cjpx_metanode ^peek_touched_nodes(Int64 box_type, Cjpx_metanode ^last_peeked);
    Cjpx_metanode ^peek_touched_nodes(Int64 box_type);
    void copy(Cjpx_meta_manager ^src);
    Boolean load_matches(Int32 num_codestreams, cli::array<Int32> ^codestream_indices, Int32 num_compositing_layers, cli::array<Int32> ^layer_indices);
    Cjpx_metanode ^enumerate_matches(Cjpx_metanode ^last_node, Int32 codestream_idx, Int32 compositing_layer_idx, Boolean applies_to_rendered_result, Ckdu_dims ^region, Int32 min_size, Boolean exclude_region_numlists);
    Cjpx_metanode ^enumerate_matches(Cjpx_metanode ^last_node, Int32 codestream_idx, Int32 compositing_layer_idx, Boolean applies_to_rendered_result, Ckdu_dims ^region, Int32 min_size);
    Cjpx_metanode ^insert_node(Int32 num_codestreams, cli::array<Int32> ^codestream_indices, Int32 num_compositing_layers, cli::array<Int32> ^layer_indices, Boolean applies_to_rendered_result, Int32 num_regions, Cjpx_roi ^regions);
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_metanode
  public ref class Cjpx_metanode {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Boolean get_numlist_info(cli::interior_ptr<Int32> num_codestreams, cli::interior_ptr<Int32> num_layers, cli::interior_ptr<Boolean> applies_to_rendered_result);
    IntPtr get_numlist_codestreams();
    IntPtr get_numlist_layers();
    Int32 get_numlist_codestream(Int32 which);
    Int32 get_numlist_layer(Int32 which);
    Boolean test_numlist(Int32 codestream_idx, Int32 compositing_layer_idx, Boolean applies_to_rendered_result);
    Int32 get_num_regions();
    Cjpx_roi ^get_region(Int32 which);
    Ckdu_dims ^get_bounding_box();
    Boolean test_region(Ckdu_dims ^region);
    Int64 get_box_type();
    String ^ get_label();
    Boolean get_uuid(cli::array<Byte> ^uuid);
    Boolean open_existing(Cjp2_input_box ^box);
    Boolean count_descendants(cli::interior_ptr<Int32> count);
    Cjpx_metanode ^get_descendant(Int32 which);
    Cjpx_metanode ^get_parent();
    Boolean change_parent(Cjpx_metanode ^new_parent);
    Cjpx_metanode ^add_numlist(Int32 num_codestreams, cli::array<Int32> ^codestream_indices, Int32 num_compositing_layers, cli::array<Int32> ^layer_indices, Boolean applies_to_rendered_result);
    Cjpx_metanode ^add_regions(Int32 num_regions, Cjpx_roi ^regions);
    Cjpx_metanode ^add_label(String ^ text);
    void change_to_label(String ^ text);
    Cjpx_metanode ^add_copy(Cjpx_metanode ^src, Boolean recursive);
    void delete_node();
    Boolean is_changed();
    Boolean ancestor_changed();
    Boolean is_deleted();
    void touch();
    IntPtr get_state_ref();
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_roi
  public ref class Cjpx_roi {
  protected:
    jpx_roi * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Cjpx_roi()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    jpx_roi * _get_kref() { return (jpx_roi *) _kref; }
    Cjpx_roi(jpx_roi * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Cjpx_roi() { Do_dispose(false); }
    Cjpx_roi();
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_source
  public ref class Cjpx_source {
  protected:
    jpx_source * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Cjpx_source()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    jpx_source * _get_kref() { return (jpx_source *) _kref; }
    Cjpx_source(jpx_source * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Cjpx_source() { Do_dispose(false); }
    Cjpx_source();
    Boolean exists();
    virtual Int32 open(Cjp2_family_src ^src, Boolean return_if_incompatible);
    Cjp2_family_src ^get_ultimate_src();
    Cjpx_compatibility ^access_compatibility();
    Cjp2_data_references ^access_data_references();
    Boolean count_codestreams(cli::interior_ptr<Int32> count);
    Boolean count_compositing_layers(cli::interior_ptr<Int32> count);
    Cjpx_codestream_source ^access_codestream(Int32 which, Boolean need_main_header);
    Cjpx_codestream_source ^access_codestream(Int32 which);
    Cjpx_layer_source ^access_layer(Int32 which, Boolean need_stream_headers);
    Cjpx_layer_source ^access_layer(Int32 which);
    Int32 get_num_layer_codestreams(Int32 which_layer);
    Int32 get_layer_codestream_id(Int32 which_layer, Int32 which_stream);
    Cjpx_composition ^access_composition();
    Cjpx_meta_manager ^access_meta_manager();
    virtual Boolean close();
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_target
  public ref class Cjpx_target {
  protected:
    jpx_target * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Cjpx_target()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    jpx_target * _get_kref() { return (jpx_target *) _kref; }
    Cjpx_target(jpx_target * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Cjpx_target() { Do_dispose(false); }
    Cjpx_target();
    Boolean exists();
    virtual void open(Cjp2_family_tgt ^tgt);
    Cjpx_compatibility ^access_compatibility();
    Cjp2_data_references ^access_data_references();
    Cjpx_codestream_target ^add_codestream();
    Cjpx_layer_target ^add_layer();
    Cjpx_composition ^access_composition();
    Cjpx_meta_manager ^access_meta_manager();
    Cjp2_output_box ^write_headers(cli::array<Int32> ^i_param);
    Cjp2_output_box ^write_headers();
    Cjp2_output_box ^write_metadata(cli::array<Int32> ^i_param);
    Cjp2_output_box ^write_metadata();
    virtual Boolean close();
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_block
  public ref class Ckdu_block {
  protected:
    kdu_block * _kref;
  protected public:
    bool _natively_owned;
  protected public:
    kdu_block * _get_kref() { return (kdu_block *) _kref; }
    Ckdu_block(kdu_block * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    Int32 get_max_passes();
    void set_max_passes(Int32 new_passes, Boolean copy_existing);
    void set_max_passes(Int32 new_passes);
    Int32 get_max_bytes();
    void set_max_bytes(Int32 new_bytes, Boolean copy_existing);
    void set_max_bytes(Int32 new_bytes);
    void __property_set_max_samples(Int32 new_samples);
    void __property_set_max_contexts(Int32 new_contexts);
    Ckdu_coords ^__property_get_size();
    void __property_set_size(Ckdu_coords ^new_size);
    Ckdu_dims ^__property_get_region();
    void __property_set_region(Ckdu_dims ^new_region);
    Boolean __property_get_transpose();
    void __property_set_transpose(Boolean new_transpose);
    Boolean __property_get_vflip();
    void __property_set_vflip(Boolean new_vflip);
    Boolean __property_get_hflip();
    void __property_set_hflip(Boolean new_hflip);
    Int32 __property_get_modes();
    void __property_set_modes(Int32 new_modes);
    Int32 __property_get_orientation();
    void __property_set_orientation(Int32 new_orientation);
    Int32 __property_get_missing_msbs();
    void __property_set_missing_msbs(Int32 new_msbs);
    Int32 __property_get_num_passes();
    void __property_set_num_passes(Int32 new_passes);
    void get_pass_lengths(cli::array<Int32> ^buffer);
    void set_pass_lengths(cli::array<Int32> ^buffer);
    void get_pass_slopes(cli::array<Int32> ^buffer);
    void set_pass_slopes(cli::array<Int32> ^buffer);
    void get_buffered_bytes(cli::array<Byte> ^buffer, Int32 first_idx, Int32 num_bytes);
    void set_buffered_bytes(cli::array<Byte> ^buffer, Int32 first_idx, Int32 num_bytes);
    Int32 start_timing();
    void finish_timing();
    void initialize_timing(Int32 iterations);
    Double get_timing_stats(cli::interior_ptr<Int64> unique_samples, cli::interior_ptr<Double> time_wasted);
    property Ckdu_coords ^size {
        Ckdu_coords ^get() { return __property_get_size(); }
        void set(Ckdu_coords ^size) { __property_set_size(size); }
      }
    property Ckdu_dims ^region {
        Ckdu_dims ^get() { return __property_get_region(); }
        void set(Ckdu_dims ^region) { __property_set_region(region); }
      }
    property Boolean transpose {
        Boolean get() { return __property_get_transpose(); }
        void set(Boolean transpose) { __property_set_transpose(transpose); }
      }
    property Boolean vflip {
        Boolean get() { return __property_get_vflip(); }
        void set(Boolean vflip) { __property_set_vflip(vflip); }
      }
    property Boolean hflip {
        Boolean get() { return __property_get_hflip(); }
        void set(Boolean hflip) { __property_set_hflip(hflip); }
      }
    property Int32 modes {
        Int32 get() { return __property_get_modes(); }
        void set(Int32 modes) { __property_set_modes(modes); }
      }
    property Int32 orientation {
        Int32 get() { return __property_get_orientation(); }
        void set(Int32 orientation) { __property_set_orientation(orientation); }
      }
    property Int32 missing_msbs {
        Int32 get() { return __property_get_missing_msbs(); }
        void set(Int32 missing_msbs) { __property_set_missing_msbs(missing_msbs); }
      }
    property Int32 num_passes {
        Int32 get() { return __property_get_num_passes(); }
        void set(Int32 num_passes) { __property_set_num_passes(num_passes); }
      }
    property Int32 max_samples {
        void set(Int32 max_samples) { __property_set_max_samples(max_samples); }
      }
    property Int32 max_contexts {
        void set(Int32 max_contexts) { __property_set_max_contexts(max_contexts); }
      }
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_block_decoder
  public ref class Ckdu_block_decoder {
  protected:
    kdu_block_decoder * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_block_decoder()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_block_decoder * _get_kref() { return (kdu_block_decoder *) _kref; }
    Ckdu_block_decoder(kdu_block_decoder * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_block_decoder() { Do_dispose(false); }
    Ckdu_block_decoder();
    void decode(Ckdu_block ^block);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_block_encoder
  public ref class Ckdu_block_encoder {
  protected:
    kdu_block_encoder * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_block_encoder()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_block_encoder * _get_kref() { return (kdu_block_encoder *) _kref; }
    Ckdu_block_encoder(kdu_block_encoder * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_block_encoder() { Do_dispose(false); }
    Ckdu_block_encoder();
    void encode(Ckdu_block ^block, Boolean reversible, Double msb_wmse, Int32 estimated_slope_threshold);
    void encode(Ckdu_block ^block, Boolean reversible, Double msb_wmse);
    void encode(Ckdu_block ^block, Boolean reversible);
    void encode(Ckdu_block ^block);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_channel_mapping
  public ref class Ckdu_channel_mapping {
  protected:
    kdu_channel_mapping * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_channel_mapping()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_channel_mapping * _get_kref() { return (kdu_channel_mapping *) _kref; }
    Ckdu_channel_mapping(kdu_channel_mapping * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_channel_mapping() { Do_dispose(false); }
    Ckdu_channel_mapping();
    void clear();
    Boolean configure(Ckdu_codestream ^codestream);
    Boolean configure(Cjp2_colour ^colour, Cjp2_channels ^channels, Int32 codestream_idx, Cjp2_palette ^palette, Cjp2_dimensions ^codestream_dimensions);
    Boolean configure(Cjp2_source ^jp2_in, Boolean ignore_alpha);
    Boolean add_alpha_to_configuration(Cjp2_channels ^channels, Int32 codestream_idx, Cjp2_palette ^palette, Cjp2_dimensions ^codestream_dimensions, Boolean ignore_premultiplied_alpha);
    Boolean add_alpha_to_configuration(Cjp2_channels ^channels, Int32 codestream_idx, Cjp2_palette ^palette, Cjp2_dimensions ^codestream_dimensions);
    Int32 __property_get_num_channels();
    void __property_set_num_channels(Int32 num);
    Int32 __property_get_num_colour_channels();
    Int32 get_source_component(Int32 n);
    Int32 get_default_rendering_precision(Int32 n);
    Boolean get_default_rendering_signed(Int32 n);
    Cjp2_colour_converter ^get_colour_converter();
    property Int32 num_channels {
        Int32 get() { return __property_get_num_channels(); }
        void set(Int32 num_channels) { __property_set_num_channels(num_channels); }
      }
    property Int32 num_colour_channels {
        Int32 get() { return __property_get_num_colour_channels(); }
      }
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_client_notifier
  public ref class Ckdu_client_notifier {
  protected:
    kdu_client_notifier * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_client_notifier()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_client_notifier * _get_kref() { return (kdu_client_notifier *) _kref; }
    Ckdu_client_notifier(kdu_client_notifier * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_client_notifier() { Do_dispose(false); }
    Ckdu_client_notifier();
    virtual void notify();
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_client_translator
  public ref class Ckdu_client_translator {
  protected:
    kdu_client_translator * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_client_translator()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_client_translator * _get_kref() { return (kdu_client_translator *) _kref; }
    Ckdu_client_translator(kdu_client_translator * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_client_translator() { Do_dispose(false); }
    Ckdu_client_translator();
    virtual void init(Ckdu_cache ^main_cache);
    virtual void close();
    virtual Boolean update();
    virtual Int32 get_num_context_members(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids);
    virtual Int32 get_context_codestream(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids, Int32 member_idx);
    virtual IntPtr get_context_components(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids, Int32 member_idx, cli::interior_ptr<Int32> num_components);
    virtual Boolean perform_context_remapping(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids, Int32 member_idx, Ckdu_coords ^resolution, Ckdu_dims ^region);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_codestream
  public ref class Ckdu_codestream {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    void create(Csiz_params ^siz, Ckdu_compressed_target ^target, Ckdu_dims ^fragment_region, Int32 fragment_tiles_generated, Int64 fragment_tile_bytes_generated);
    void create(Csiz_params ^siz, Ckdu_compressed_target ^target, Ckdu_dims ^fragment_region, Int32 fragment_tiles_generated);
    void create(Csiz_params ^siz, Ckdu_compressed_target ^target, Ckdu_dims ^fragment_region);
    void create(Csiz_params ^siz, Ckdu_compressed_target ^target);
    void create(Ckdu_compressed_source ^source, Ckdu_thread_env ^env);
    void create(Ckdu_compressed_source ^source);
    void create(Csiz_params ^siz);
    void restart(Ckdu_compressed_target ^target);
    void restart(Ckdu_compressed_source ^source, Ckdu_thread_env ^env);
    void restart(Ckdu_compressed_source ^source);
    void share_buffering(Ckdu_codestream ^existing);
    void destroy();
    void enable_restart();
    void set_persistent();
    Int64 augment_cache_threshold(Int32 extra_bytes);
    Int32 set_tile_unloading_threshold(Int32 max_tiles_on_list);
    Boolean is_last_fragment();
    Csiz_params ^access_siz();
    Int32 get_num_components(Boolean want_output_comps);
    Int32 get_num_components();
    Int32 get_bit_depth(Int32 comp_idx, Boolean want_output_comps);
    Int32 get_bit_depth(Int32 comp_idx);
    Boolean get_signed(Int32 comp_idx, Boolean want_output_comps);
    Boolean get_signed(Int32 comp_idx);
    void get_subsampling(Int32 comp_idx, Ckdu_coords ^subs, Boolean want_output_comps);
    void get_subsampling(Int32 comp_idx, Ckdu_coords ^subs);
    void get_registration(Int32 comp_idx, Ckdu_coords ^scale, Ckdu_coords ^crg, Boolean want_output_comps);
    void get_registration(Int32 comp_idx, Ckdu_coords ^scale, Ckdu_coords ^crg);
    void get_dims(Int32 comp_idx, Ckdu_dims ^dims, Boolean want_output_comps);
    void get_dims(Int32 comp_idx, Ckdu_dims ^dims);
    void get_tile_partition(Ckdu_dims ^partition);
    void get_valid_tiles(Ckdu_dims ^indices);
    Boolean find_tile(Int32 comp_idx, Ckdu_coords ^loc, Ckdu_coords ^tile_idx, Boolean want_output_comps);
    Boolean find_tile(Int32 comp_idx, Ckdu_coords ^loc, Ckdu_coords ^tile_idx);
    void get_tile_dims(Ckdu_coords ^tile_idx, Int32 comp_idx, Ckdu_dims ^dims, Boolean want_output_comps);
    void get_tile_dims(Ckdu_coords ^tile_idx, Int32 comp_idx, Ckdu_dims ^dims);
    Int32 get_max_tile_layers();
    Int32 get_min_dwt_levels();
    Boolean can_flip(Boolean check_current_appearance_only);
    void map_region(Int32 comp_idx, Ckdu_dims ^comp_region, Ckdu_dims ^hires_region, Boolean want_output_comps);
    void map_region(Int32 comp_idx, Ckdu_dims ^comp_region, Ckdu_dims ^hires_region);
    void set_textualization(Ckdu_message ^output);
    void set_max_bytes(Int64 max_bytes, Boolean simulate_parsing, Boolean allow_periodic_trimming);
    void set_max_bytes(Int64 max_bytes, Boolean simulate_parsing);
    void set_max_bytes(Int64 max_bytes);
    void set_min_slope_threshold(Int32 min_slope);
    void set_resilient(Boolean expect_ubiquitous_sops);
    void set_resilient();
    void set_fussy();
    void set_fast();
    void apply_input_restrictions(Int32 first_component, Int32 max_components, Int32 discard_levels, Int32 max_layers, Ckdu_dims ^region_of_interest, Int32 access_mode);
    void apply_input_restrictions(Int32 first_component, Int32 max_components, Int32 discard_levels, Int32 max_layers, Ckdu_dims ^region_of_interest);
    void apply_input_restrictions(Int32 num_indices, cli::array<Int32> ^component_indices, Int32 discard_levels, Int32 max_layers, Ckdu_dims ^region_of_interest, Int32 access_mode);
    void change_appearance(Boolean transpose, Boolean vflip, Boolean hflip);
    void set_block_truncation(Int32 factor);
    Ckdu_tile ^open_tile(Ckdu_coords ^tile_idx, Ckdu_thread_env ^env);
    Ckdu_tile ^open_tile(Ckdu_coords ^tile_idx);
    Ckdu_codestream_comment ^get_comment(Ckdu_codestream_comment ^prev);
    Ckdu_codestream_comment ^get_comment();
    Ckdu_codestream_comment ^add_comment();
    void flush(cli::array<Int64> ^layer_bytes, Int32 num_layer_specs, cli::array<Int32> ^layer_thresholds, Boolean trim_to_rate, Boolean record_in_comseg, Double tolerance, Ckdu_thread_env ^env);
    void flush(cli::array<Int64> ^layer_bytes, Int32 num_layer_specs, cli::array<Int32> ^layer_thresholds, Boolean trim_to_rate, Boolean record_in_comseg, Double tolerance);
    void flush(cli::array<Int64> ^layer_bytes, Int32 num_layer_specs, cli::array<Int32> ^layer_thresholds, Boolean trim_to_rate, Boolean record_in_comseg);
    void flush(cli::array<Int64> ^layer_bytes, Int32 num_layer_specs, cli::array<Int32> ^layer_thresholds, Boolean trim_to_rate);
    void flush(cli::array<Int64> ^layer_bytes, Int32 num_layer_specs, cli::array<Int32> ^layer_thresholds);
    void flush(cli::array<Int64> ^layer_bytes, Int32 num_layer_specs);
    Int32 trans_out(Int64 max_bytes, cli::array<Int64> ^layer_bytes, Int32 layer_bytes_entries, Boolean record_in_comseg, Ckdu_thread_env ^env);
    Int32 trans_out(Int64 max_bytes, cli::array<Int64> ^layer_bytes, Int32 layer_bytes_entries, Boolean record_in_comseg);
    Int32 trans_out(Int64 max_bytes, cli::array<Int64> ^layer_bytes, Int32 layer_bytes_entries);
    Int32 trans_out(Int64 max_bytes, cli::array<Int64> ^layer_bytes);
    Int32 trans_out(Int64 max_bytes);
    Int32 trans_out();
    Boolean ready_for_flush(Ckdu_thread_env ^env);
    Boolean ready_for_flush();
    Int64 get_total_bytes(Boolean exclude_main_header);
    Int64 get_total_bytes();
    Int32 get_num_tparts();
    void collect_timing_stats(Int32 num_coder_iterations);
    Double get_timing_stats(cli::array<Int64> ^num_samples, Boolean coder_only);
    Double get_timing_stats(cli::array<Int64> ^num_samples);
    Int64 get_compressed_data_memory(Boolean get_peak_allocation);
    Int64 get_compressed_data_memory();
    Int64 get_compressed_state_memory(Boolean get_peak_allocation);
    Int64 get_compressed_state_memory();
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_codestream_comment
  public ref class Ckdu_codestream_comment {
  protected public:
    IntPtr _kval;
  public:
    String ^ get_text();
    Boolean check_readonly();
    Boolean put_text(String ^ string);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_compositor_buf
  public ref class Ckdu_compositor_buf {
  protected:
    kdu_compositor_buf * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_compositor_buf()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_compositor_buf * _get_kref() { return (kdu_compositor_buf *) _kref; }
    Ckdu_compositor_buf(kdu_compositor_buf * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_compositor_buf() { Do_dispose(false); }
    Ckdu_compositor_buf();
    void init(IntPtr buf, Int32 row_gap);
    Boolean is_read_access_allowed();
    virtual Boolean set_read_accessibility(Boolean read_access_required);
    IntPtr get_buf(cli::interior_ptr<Int32> row_gap, Boolean read_write);
    void get_region(Ckdu_dims ^src_region, cli::array<Int32> ^tgt_buf, Int32 tgt_offset, Int32 tgt_row_gap);
    void get_region(Ckdu_dims ^src_region, cli::array<Int32> ^tgt_buf, Int32 tgt_offset);
    void get_region(Ckdu_dims ^src_region, cli::array<Int32> ^tgt_buf);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_compressed_source
  public ref class Ckdu_compressed_source {
  protected:
    kdu_compressed_source * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_compressed_source()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_compressed_source * _get_kref() { return (kdu_compressed_source *) _kref; }
    Ckdu_compressed_source(kdu_compressed_source * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_compressed_source() { Do_dispose(false); }
    virtual Boolean close();
    virtual Int32 get_capabilities();
    virtual Int32 read(cli::array<Byte> ^buf, Int32 num_bytes);
    virtual Boolean seek(Int64 offset);
    virtual Int64 get_pos();
    virtual Boolean set_tileheader_scope(Int32 tnum, Int32 num_tiles);
    virtual Boolean set_precinct_scope(Int64 unique_id);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_compressed_target
  public ref class Ckdu_compressed_target {
  protected:
    kdu_compressed_target * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_compressed_target()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_compressed_target * _get_kref() { return (kdu_compressed_target *) _kref; }
    Ckdu_compressed_target(kdu_compressed_target * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_compressed_target() { Do_dispose(false); }
    virtual Boolean close();
    virtual Boolean start_rewrite(Int64 backtrack);
    virtual Boolean end_rewrite();
    virtual Boolean write(cli::array<Byte> ^buf, Int32 num_bytes);
    virtual void set_target_size(Int64 num_bytes);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_coords
  public ref class Ckdu_coords {
  protected:
    kdu_coords * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_coords()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_coords * _get_kref() { return (kdu_coords *) _kref; }
    Ckdu_coords(kdu_coords * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_coords() { Do_dispose(false); }
    Ckdu_coords();
    Ckdu_coords(Int32 x, Int32 y);
    void assign(Ckdu_coords ^src);
    Int32 __property_get_x();
    Int32 __property_get_y();
    void __property_set_x(Int32 x);
    void __property_set_y(Int32 y);
    void transpose();
    Ckdu_coords ^plus(Ckdu_coords ^rhs);
    Ckdu_coords ^minus(Ckdu_coords ^rhs);
    Ckdu_coords ^add(Ckdu_coords ^rhs);
    Ckdu_coords ^subtract(Ckdu_coords ^rhs);
    Boolean equals(Ckdu_coords ^rhs);
    void from_apparent(Boolean transp, Boolean vflip, Boolean hflip);
    void to_apparent(Boolean transp, Boolean vflip, Boolean hflip);
    property Int32 y {
        Int32 get() { return __property_get_y(); }
        void set(Int32 y) { __property_set_y(y); }
      }
    property Int32 x {
        Int32 get() { return __property_get_x(); }
        void set(Int32 x) { __property_set_x(x); }
      }
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_dims
  public ref class Ckdu_dims {
  protected:
    kdu_dims * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_dims()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_dims * _get_kref() { return (kdu_dims *) _kref; }
    Ckdu_dims(kdu_dims * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_dims() { Do_dispose(false); }
    Ckdu_dims();
    void assign(Ckdu_dims ^src);
    Ckdu_coords ^access_pos();
    Ckdu_coords ^access_size();
    Int64 area();
    void transpose();
    Ckdu_dims ^intersection(Ckdu_dims ^rhs);
    Boolean intersects(Ckdu_dims ^rhs);
    Boolean is_empty();
    Boolean equals(Ckdu_dims ^rhs);
    void from_apparent(Boolean transp, Boolean vflip, Boolean hflip);
    void to_apparent(Boolean transp, Boolean vflip, Boolean hflip);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_line_buf
  public ref class Ckdu_line_buf {
  protected:
    kdu_line_buf * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_line_buf()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_line_buf * _get_kref() { return (kdu_line_buf *) _kref; }
    Ckdu_line_buf(kdu_line_buf * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_line_buf() { Do_dispose(false); }
    Ckdu_line_buf();
    void pre_create(Ckdu_sample_allocator ^allocator, Int32 width, Boolean absolute, Boolean use_shorts, Int32 extend_left, Int32 extend_right);
    void pre_create(Ckdu_sample_allocator ^allocator, Int32 width, Boolean absolute, Boolean use_shorts, Int32 extend_left);
    void pre_create(Ckdu_sample_allocator ^allocator, Int32 width, Boolean absolute, Boolean use_shorts);
    void create();
    void destroy();
    Boolean get_floats(cli::array<Single> ^buffer, Int32 first_idx, Int32 num_samples);
    Boolean set_floats(cli::array<Single> ^buffer, Int32 first_idx, Int32 num_samples);
    Boolean get_ints(cli::array<Int32> ^buffer, Int32 first_idx, Int32 num_samples);
    Boolean set_ints(cli::array<Int32> ^buffer, Int32 first_idx, Int32 num_samples);
    Boolean get_ints(cli::array<Int16> ^buffer, Int32 first_idx, Int32 num_samples);
    Boolean set_ints(cli::array<Int16> ^buffer, Int32 first_idx, Int32 num_samples);
    Int32 get_width();
    Boolean is_absolute();
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_message
  public ref class Ckdu_message {
  protected:
    kdu_message * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_message()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_message * _get_kref() { return (kdu_message *) _kref; }
    Ckdu_message(kdu_message * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_message() { Do_dispose(false); }
    Ckdu_message();
    virtual void put_text(String ^ string);
    virtual void put_text(cli::array<Int32> ^string);
    virtual void flush(Boolean end_of_message);
    void flush();
    virtual void start_message();
    Boolean set_hex_mode(Boolean new_mode);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_metareq
  public ref class Ckdu_metareq {
  protected:
    kdu_metareq * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_metareq()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_metareq * _get_kref() { return (kdu_metareq *) _kref; }
    Ckdu_metareq(kdu_metareq * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_metareq() { Do_dispose(false); }
    Boolean equals(Ckdu_metareq ^rhs);
    Int64 __property_get_box_type();
    Int32 __property_get_qualifier();
    Boolean __property_get_priority();
    Int32 __property_get_byte_limit();
    Boolean __property_get_recurse();
    Int64 __property_get_root_bin_id();
    Int32 __property_get_max_depth();
    Ckdu_metareq ^get_next();
    property Int64 box_type {
        Int64 get() { return __property_get_box_type(); }
      }
    property Int32 qualifier {
        Int32 get() { return __property_get_qualifier(); }
      }
    property Boolean priority {
        Boolean get() { return __property_get_priority(); }
      }
    property Int32 byte_limit {
        Int32 get() { return __property_get_byte_limit(); }
      }
    property Boolean recurse {
        Boolean get() { return __property_get_recurse(); }
      }
    property Int64 root_bin_id {
        Int64 get() { return __property_get_root_bin_id(); }
      }
    property Int32 max_depth {
        Int32 get() { return __property_get_max_depth(); }
      }
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_multi_analysis
  public ref class Ckdu_multi_analysis {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise, Ckdu_roi_image ^roi, Boolean want_fastest, Int32 processing_stripe_height, Ckdu_thread_env ^env, IntPtr env_queue, Boolean double_buffering);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise, Ckdu_roi_image ^roi, Boolean want_fastest, Int32 processing_stripe_height, Ckdu_thread_env ^env, IntPtr env_queue);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise, Ckdu_roi_image ^roi, Boolean want_fastest, Int32 processing_stripe_height, Ckdu_thread_env ^env);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise, Ckdu_roi_image ^roi, Boolean want_fastest, Int32 processing_stripe_height);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise, Ckdu_roi_image ^roi, Boolean want_fastest);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise, Ckdu_roi_image ^roi);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile);
    void destroy(Ckdu_thread_env ^env);
    void destroy();
    Ckdu_coords ^get_size(Int32 comp_idx);
    Ckdu_line_buf ^exchange_line(Int32 comp_idx, Ckdu_line_buf ^written, Ckdu_thread_env ^env);
    Ckdu_line_buf ^exchange_line(Int32 comp_idx, Ckdu_line_buf ^written);
    Boolean is_line_precise(Int32 comp_idx);
    Boolean is_line_absolute(Int32 comp_idx);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_multi_synthesis
  public ref class Ckdu_multi_synthesis {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise, Boolean skip_ycc, Boolean want_fastest, Int32 processing_stripe_height, Ckdu_thread_env ^env, IntPtr env_queue, Boolean double_buffering);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise, Boolean skip_ycc, Boolean want_fastest, Int32 processing_stripe_height, Ckdu_thread_env ^env, IntPtr env_queue);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise, Boolean skip_ycc, Boolean want_fastest, Int32 processing_stripe_height, Ckdu_thread_env ^env);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise, Boolean skip_ycc, Boolean want_fastest, Int32 processing_stripe_height);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise, Boolean skip_ycc, Boolean want_fastest);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise, Boolean skip_ycc);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile, Boolean force_precise);
    Int64 create(Ckdu_codestream ^codestream, Ckdu_tile ^tile);
    void destroy(Ckdu_thread_env ^env);
    void destroy();
    Ckdu_coords ^get_size(Int32 comp_idx);
    Ckdu_line_buf ^get_line(Int32 comp_idx, Ckdu_thread_env ^env);
    Ckdu_line_buf ^get_line(Int32 comp_idx);
    Boolean is_line_precise(Int32 comp_idx);
    Boolean is_line_absolute(Int32 comp_idx);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_node
  public ref class Ckdu_node {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Boolean compare(Ckdu_node ^src);
    Ckdu_node ^access_child(Int32 child_idx);
    Int32 get_num_descendants(cli::interior_ptr<Int32> num_leaf_descendants);
    Ckdu_subband ^access_subband();
    Ckdu_resolution ^access_resolution();
    void get_dims(Ckdu_dims ^dims);
    Int32 get_kernel_id();
    IntPtr get_kernel_coefficients(Boolean vertical);
    IntPtr get_bibo_gains(cli::interior_ptr<Int32> num_steps, Boolean vertical);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_output
  public ref class Ckdu_output {
  protected:
    kdu_output * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_output()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_output * _get_kref() { return (kdu_output *) _kref; }
    Ckdu_output(kdu_output * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_output() { Do_dispose(false); }
    Int32 put(Byte byte);
    Int32 put(Int32 word);
    Int32 put(Int64 word);
    Int32 put(Single val);
    void write(cli::array<Byte> ^buf, Int32 count);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_params
  public ref class Ckdu_params {
  protected:
    kdu_params * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_params()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_params * _get_kref() { return (kdu_params *) _kref; }
    Ckdu_params(kdu_params * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_params() { Do_dispose(false); }
    virtual Ckdu_params ^new_object();
    Ckdu_params ^link(Ckdu_params ^existing, Int32 tile_idx, Int32 comp_idx, Int32 num_tiles, Int32 num_comps);
    Ckdu_params ^new_instance();
    void copy_from(Ckdu_params ^source, Int32 source_tile, Int32 target_tile, Int32 instance, Int32 skip_components, Int32 discard_levels, Boolean transpose, Boolean vflip, Boolean hflip);
    void copy_from(Ckdu_params ^source, Int32 source_tile, Int32 target_tile, Int32 instance, Int32 skip_components, Int32 discard_levels, Boolean transpose, Boolean vflip);
    void copy_from(Ckdu_params ^source, Int32 source_tile, Int32 target_tile, Int32 instance, Int32 skip_components, Int32 discard_levels, Boolean transpose);
    void copy_from(Ckdu_params ^source, Int32 source_tile, Int32 target_tile, Int32 instance, Int32 skip_components, Int32 discard_levels);
    void copy_from(Ckdu_params ^source, Int32 source_tile, Int32 target_tile, Int32 instance, Int32 skip_components);
    void copy_from(Ckdu_params ^source, Int32 source_tile, Int32 target_tile, Int32 instance);
    void copy_from(Ckdu_params ^source, Int32 source_tile, Int32 target_tile);
    void copy_all(Ckdu_params ^source, Int32 skip_components, Int32 discard_levels, Boolean transpose, Boolean vflip, Boolean hflip);
    void copy_all(Ckdu_params ^source, Int32 skip_components, Int32 discard_levels, Boolean transpose, Boolean vflip);
    void copy_all(Ckdu_params ^source, Int32 skip_components, Int32 discard_levels, Boolean transpose);
    void copy_all(Ckdu_params ^source, Int32 skip_components, Int32 discard_levels);
    void copy_all(Ckdu_params ^source, Int32 skip_components);
    void copy_all(Ckdu_params ^source);
    String ^ identify_cluster();
    Ckdu_params ^access_cluster(String ^ cluster_name);
    Ckdu_params ^access_cluster(Int32 sequence_idx);
    Int32 get_instance();
    Int32 get_num_comps();
    Int32 get_num_tiles();
    Ckdu_params ^access_relation(Int32 tile_idx, Int32 comp_idx, Int32 inst_idx, Boolean read_only);
    Ckdu_params ^access_relation(Int32 tile_idx, Int32 comp_idx, Int32 inst_idx);
    Ckdu_params ^access_relation(Int32 tile_idx, Int32 comp_idx);
    Ckdu_params ^access_unique(Int32 tile_idx, Int32 comp_idx, Int32 inst_idx);
    Ckdu_params ^access_unique(Int32 tile_idx, Int32 comp_idx);
    Ckdu_params ^access_next_inst();
    void clear_marks();
    Boolean any_changes();
    Boolean check_typical_tile(Int32 tile_idx, String ^ excluded_clusters);
    Boolean check_typical_tile(Int32 tile_idx);
    Boolean translate_marker_segment(Int32 code, Int32 num_bytes, cli::array<Byte> ^bytes, Int32 which_tile, Int32 tpart_idx);
    Int32 generate_marker_segments(Ckdu_output ^out, Int32 which_tile, Int32 tpart_idx);
    Boolean get(String ^ name, Int32 record_idx, Int32 field_idx, cli::interior_ptr<Int32> value, Boolean allow_inherit, Boolean allow_extend, Boolean allow_derived);
    Boolean get(String ^ name, Int32 record_idx, Int32 field_idx, cli::interior_ptr<Int32> value, Boolean allow_inherit, Boolean allow_extend);
    Boolean get(String ^ name, Int32 record_idx, Int32 field_idx, cli::interior_ptr<Int32> value, Boolean allow_inherit);
    Boolean get(String ^ name, Int32 record_idx, Int32 field_idx, cli::interior_ptr<Int32> value);
    Boolean get(String ^ name, Int32 record_idx, Int32 field_idx, cli::interior_ptr<Boolean> value, Boolean allow_inherit, Boolean allow_extend, Boolean allow_derived);
    Boolean get(String ^ name, Int32 record_idx, Int32 field_idx, cli::interior_ptr<Boolean> value, Boolean allow_inherit, Boolean allow_extend);
    Boolean get(String ^ name, Int32 record_idx, Int32 field_idx, cli::interior_ptr<Boolean> value, Boolean allow_inherit);
    Boolean get(String ^ name, Int32 record_idx, Int32 field_idx, cli::interior_ptr<Boolean> value);
    Boolean get(String ^ name, Int32 record_idx, Int32 field_idx, cli::interior_ptr<Single> value, Boolean allow_inherit, Boolean allow_extend, Boolean allow_derived);
    Boolean get(String ^ name, Int32 record_idx, Int32 field_idx, cli::interior_ptr<Single> value, Boolean allow_inherit, Boolean allow_extend);
    Boolean get(String ^ name, Int32 record_idx, Int32 field_idx, cli::interior_ptr<Single> value, Boolean allow_inherit);
    Boolean get(String ^ name, Int32 record_idx, Int32 field_idx, cli::interior_ptr<Single> value);
    Boolean compare(String ^ name, Int32 record_idx, Int32 field_idx, Int32 value);
    Boolean compare(String ^ name, Int32 record_idx, Int32 field_idx, Boolean value);
    Boolean compare(String ^ name, Int32 record_idx, Int32 field_idx, Single value);
    void set(String ^ name, Int32 record_idx, Int32 field_idx, Int32 value);
    void set(String ^ name, Int32 record_idx, Int32 field_idx, Boolean value);
    void set(String ^ name, Int32 record_idx, Int32 field_idx, Double value);
    void set_derived(String ^ name);
    Boolean parse_string(String ^ string);
    Boolean parse_string(String ^ string, Int32 tile_idx);
    void textualize_attributes(Ckdu_message ^output, Boolean skip_derived);
    void textualize_attributes(Ckdu_message ^output);
    void textualize_attributes(Ckdu_message ^output, Int32 min_tile, Int32 max_tile, Boolean skip_derived);
    void textualize_attributes(Ckdu_message ^output, Int32 min_tile, Int32 max_tile);
    void describe_attributes(Ckdu_message ^output, Boolean include_comments);
    void describe_attributes(Ckdu_message ^output);
    void describe_attribute(String ^ name, Ckdu_message ^output, Boolean include_comments);
    void describe_attribute(String ^ name, Ckdu_message ^output);
    void delete_unparsed_attribute(String ^ name);
    virtual Int32 custom_parse_field(String ^ string, String ^ name, Int32 field_idx, cli::interior_ptr<Int32> val);
    virtual void custom_textualize_field(Ckdu_message ^output, String ^ name, Int32 field_idx, Int32 val);
    virtual void finalize(Boolean after_reading);
    void finalize();
    void finalize_all(Boolean after_reading);
    void finalize_all();
    void finalize_all(Int32 tile_idx, Boolean after_reading);
    void finalize_all(Int32 tile_idx);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_precinct
  public ref class Ckdu_precinct {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Boolean check_loaded();
    Int64 get_unique_id();
    Boolean get_valid_blocks(Int32 band_idx, Ckdu_dims ^indices);
    Ckdu_block ^open_block(Int32 band_idx, Ckdu_coords ^block_idx, Ckdu_thread_env ^env);
    Ckdu_block ^open_block(Int32 band_idx, Ckdu_coords ^block_idx);
    void close_block(Ckdu_block ^block, Ckdu_thread_env ^env);
    void close_block(Ckdu_block ^block);
    Boolean size_packets(cli::interior_ptr<Int32> cumulative_packets, cli::interior_ptr<Int32> cumulative_bytes, cli::interior_ptr<Boolean> is_significant);
    Boolean get_packets(Int32 leading_skip_packets, Int32 leading_skip_bytes, cli::interior_ptr<Int32> cumulative_packets, cli::interior_ptr<Int32> cumulative_bytes, Ckdu_output ^out);
    void restart();
    void close();
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_pull_ifc
  public ref class Ckdu_pull_ifc {
  protected:
    kdu_pull_ifc * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_pull_ifc()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_pull_ifc * _get_kref() { return (kdu_pull_ifc *) _kref; }
    Ckdu_pull_ifc(kdu_pull_ifc * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_pull_ifc() { Do_dispose(false); }
    Ckdu_pull_ifc();
    void destroy();
    void start(Ckdu_thread_env ^env);
    Boolean exists();
    void pull(Ckdu_line_buf ^line, Ckdu_thread_env ^env);
    void pull(Ckdu_line_buf ^line);
    void pull(Ckdu_line_buf ^line, Boolean allow_exchange);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_push_ifc
  public ref class Ckdu_push_ifc {
  protected:
    kdu_push_ifc * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_push_ifc()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_push_ifc * _get_kref() { return (kdu_push_ifc *) _kref; }
    Ckdu_push_ifc(kdu_push_ifc * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_push_ifc() { Do_dispose(false); }
    Ckdu_push_ifc();
    void destroy();
    Boolean exists();
    void push(Ckdu_line_buf ^line, Ckdu_thread_env ^env);
    void push(Ckdu_line_buf ^line);
    void push(Ckdu_line_buf ^line, Boolean allow_exchange);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_range_set
  public ref class Ckdu_range_set {
  protected:
    kdu_range_set * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_range_set()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_range_set * _get_kref() { return (kdu_range_set *) _kref; }
    Ckdu_range_set(kdu_range_set * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_range_set() { Do_dispose(false); }
    Ckdu_range_set();
    void copy_from(Ckdu_range_set ^src);
    Boolean is_empty();
    Boolean contains(Ckdu_range_set ^rhs);
    Boolean equals(Ckdu_range_set ^rhs);
    void init();
    void add(Ckdu_sampled_range ^range, Boolean allow_merging);
    void add(Ckdu_sampled_range ^range);
    void add(Int32 val);
    void add(Int32 from, Int32 to);
    Int32 get_num_ranges();
    Ckdu_sampled_range ^get_range(Int32 n);
    Ckdu_sampled_range ^access_range(Int32 n);
    Boolean test(Int32 index);
    Int32 expand(cli::array<Int32> ^buf, Int32 accept_min, Int32 accept_max);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_region_compositor
  public ref class Ckdu_region_compositor {
  protected:
    kdu_region_compositor * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_region_compositor()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_region_compositor * _get_kref() { return (kdu_region_compositor *) _kref; }
    Ckdu_region_compositor(kdu_region_compositor * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_region_compositor() { Do_dispose(false); }
    Ckdu_region_compositor(Ckdu_thread_env ^env, IntPtr env_queue);
    Ckdu_region_compositor(Ckdu_thread_env ^env);
    Ckdu_region_compositor();
    Ckdu_region_compositor(Ckdu_compressed_source ^source, Int32 persistent_cache_threshold);
    Ckdu_region_compositor(Ckdu_compressed_source ^source);
    Ckdu_region_compositor(Cjpx_source ^source, Int32 persistent_cache_threshold);
    Ckdu_region_compositor(Cjpx_source ^source);
    Ckdu_region_compositor(Cmj2_source ^source, Int32 persistent_cache_threshold);
    Ckdu_region_compositor(Cmj2_source ^source);
    virtual void pre_destroy();
    void create(Ckdu_compressed_source ^source, Int32 persistent_cache_threshold);
    void create(Ckdu_compressed_source ^source);
    void create(Cjpx_source ^source, Int32 persistent_cache_threshold);
    void create(Cjpx_source ^source);
    void create(Cmj2_source ^source, Int32 persistent_cache_threshold);
    void create(Cmj2_source ^source);
    void set_error_level(Int32 error_level);
    void set_surface_initialization_mode(Boolean pre_initialize);
    Boolean add_compositing_layer(Int32 layer_idx, Ckdu_dims ^full_source_dims, Ckdu_dims ^full_target_dims, Boolean transpose, Boolean vflip, Boolean hflip, Int32 frame_idx, Int32 field_handling);
    Boolean add_compositing_layer(Int32 layer_idx, Ckdu_dims ^full_source_dims, Ckdu_dims ^full_target_dims, Boolean transpose, Boolean vflip, Boolean hflip, Int32 frame_idx);
    Boolean add_compositing_layer(Int32 layer_idx, Ckdu_dims ^full_source_dims, Ckdu_dims ^full_target_dims, Boolean transpose, Boolean vflip, Boolean hflip);
    Boolean add_compositing_layer(Int32 layer_idx, Ckdu_dims ^full_source_dims, Ckdu_dims ^full_target_dims, Boolean transpose, Boolean vflip);
    Boolean add_compositing_layer(Int32 layer_idx, Ckdu_dims ^full_source_dims, Ckdu_dims ^full_target_dims, Boolean transpose);
    Boolean add_compositing_layer(Int32 layer_idx, Ckdu_dims ^full_source_dims, Ckdu_dims ^full_target_dims);
    Boolean change_compositing_layer_frame(Int32 layer_idx, Int32 frame_idx);
    void remove_compositing_layer(Int32 layer_idx, Boolean permanent);
    Int32 set_single_component(Int32 stream_idx, Int32 component_idx, Int32 access_mode);
    Int32 set_single_component(Int32 stream_idx, Int32 component_idx);
    void cull_inactive_layers(Int32 max_inactive);
    void set_frame(Cjpx_frame_expander ^expander);
    void set_scale(Boolean transpose, Boolean vflip, Boolean hflip, Single scale);
    Single find_optimal_scale(Ckdu_dims ^region, Single scale_anchor, Single min_scale, Single max_scale, cli::array<Int32> ^compositing_layer_idx, cli::array<Int32> ^codestream_idx, cli::array<Int32> ^component_idx);
    Single find_optimal_scale(Ckdu_dims ^region, Single scale_anchor, Single min_scale, Single max_scale, cli::array<Int32> ^compositing_layer_idx, cli::array<Int32> ^codestream_idx);
    Single find_optimal_scale(Ckdu_dims ^region, Single scale_anchor, Single min_scale, Single max_scale, cli::array<Int32> ^compositing_layer_idx);
    Single find_optimal_scale(Ckdu_dims ^region, Single scale_anchor, Single min_scale, Single max_scale);
    void set_buffer_surface(Ckdu_dims ^region, Int32 background);
    void set_buffer_surface(Ckdu_dims ^region);
    Int32 check_invalid_scale_code();
    Boolean get_total_composition_dims(Ckdu_dims ^dims);
    Ckdu_compositor_buf ^get_composition_buffer(Ckdu_dims ^region);
    Boolean push_composition_buffer(Int64 stamp, Int32 id);
    Boolean pop_composition_buffer();
    Boolean inspect_composition_queue(Int32 elt, cli::array<Int64> ^stamp, cli::array<Int32> ^id);
    Boolean inspect_composition_queue(Int32 elt, cli::array<Int64> ^stamp);
    Boolean inspect_composition_queue(Int32 elt);
    void flush_composition_queue();
    void set_max_quality_layers(Int32 quality_layers);
    Int32 get_max_available_quality_layers();
    virtual Ckdu_thread_env ^set_thread_env(Ckdu_thread_env ^env, IntPtr env_queue);
    virtual Boolean process(Int32 suggested_increment, Ckdu_dims ^new_region);
    Boolean is_processing_complete();
    Boolean refresh();
    void halt_processing();
    Boolean find_point(Ckdu_coords ^point, cli::interior_ptr<Int32> layer_idx, cli::interior_ptr<Int32> codestream_idx);
    Boolean map_region(cli::interior_ptr<Int32> codestream_idx, Ckdu_dims ^region);
    Ckdu_dims ^inverse_map_region(Ckdu_dims ^region, Int32 codestream_idx, Int32 layer_idx);
    Ckdu_dims ^inverse_map_region(Ckdu_dims ^region, Int32 codestream_idx);
    Ckdu_dims ^find_layer_region(Int32 layer_idx, Int32 instance, Boolean apply_cropping);
    Ckdu_dims ^find_codestream_region(Int32 codestream_idx, Int32 instance, Boolean apply_cropping);
    IntPtr get_next_codestream(IntPtr last_stream_ref, Boolean only_active_codestreams, Boolean no_duplicates);
    IntPtr get_next_visible_codestream(IntPtr last_stream_ref, Ckdu_dims ^region, Boolean include_alpha);
    Ckdu_codestream ^access_codestream(IntPtr stream_ref);
    Boolean get_codestream_info(IntPtr stream_ref, cli::interior_ptr<Int32> codestream_idx, cli::interior_ptr<Int32> compositing_layer_idx, cli::array<Int32> ^components_in_use, cli::array<Int32> ^principle_component_idx, cli::array<Single> ^principle_component_scale_x, cli::array<Single> ^principle_component_scale_y);
    Boolean get_codestream_info(IntPtr stream_ref, cli::interior_ptr<Int32> codestream_idx, cli::interior_ptr<Int32> compositing_layer_idx, cli::array<Int32> ^components_in_use, cli::array<Int32> ^principle_component_idx, cli::array<Single> ^principle_component_scale_x);
    Boolean get_codestream_info(IntPtr stream_ref, cli::interior_ptr<Int32> codestream_idx, cli::interior_ptr<Int32> compositing_layer_idx, cli::array<Int32> ^components_in_use, cli::array<Int32> ^principle_component_idx);
    Boolean get_codestream_info(IntPtr stream_ref, cli::interior_ptr<Int32> codestream_idx, cli::interior_ptr<Int32> compositing_layer_idx, cli::array<Int32> ^components_in_use);
    Boolean get_codestream_info(IntPtr stream_ref, cli::interior_ptr<Int32> codestream_idx, cli::interior_ptr<Int32> compositing_layer_idx);
    Boolean get_codestream_packets(IntPtr stream_ref, Ckdu_dims ^region, cli::interior_ptr<Int64> visible_precinct_samples, cli::interior_ptr<Int64> visible_packet_samples, cli::interior_ptr<Int64> max_visible_packet_samples);
    void configure_overlays(Boolean enable, Int32 min_display_size, Int32 painting_param);
    void update_overlays(Boolean start_from_scratch);
    Cjpx_metanode ^search_overlays(Ckdu_coords ^point, cli::interior_ptr<Int32> codestream_idx);
    virtual Boolean custom_paint_overlay(Ckdu_compositor_buf ^buffer, Ckdu_dims ^buffer_region, Ckdu_dims ^bounding_region, Int32 codestream_idx, Cjpx_metanode ^node, Int32 painting_param, Ckdu_coords ^image_offset, Ckdu_coords ^subsampling, Boolean transpose, Boolean vflip, Boolean hflip, Ckdu_coords ^expansion_numerator, Ckdu_coords ^expansion_denominator, Ckdu_coords ^compositing_offset);
    virtual Ckdu_compositor_buf ^allocate_buffer(Ckdu_coords ^min_size, Ckdu_coords ^actual_size, Boolean read_access_required);
    virtual void delete_buffer(Ckdu_compositor_buf ^buf);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_region_decompressor
  public ref class Ckdu_region_decompressor {
  protected:
    kdu_region_decompressor * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_region_decompressor()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_region_decompressor * _get_kref() { return (kdu_region_decompressor *) _kref; }
    Ckdu_region_decompressor(kdu_region_decompressor * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_region_decompressor() { Do_dispose(false); }
    Ckdu_region_decompressor();
    Ckdu_dims ^get_rendered_image_dims(Ckdu_codestream ^codestream, Ckdu_channel_mapping ^mapping, Int32 single_component, Int32 discard_levels, Ckdu_coords ^expand_numerator, Ckdu_coords ^expand_denominator, Int32 access_mode);
    Ckdu_dims ^get_rendered_image_dims(Ckdu_codestream ^codestream, Ckdu_channel_mapping ^mapping, Int32 single_component, Int32 discard_levels, Ckdu_coords ^expand_numerator, Ckdu_coords ^expand_denominator);
    Ckdu_dims ^get_rendered_image_dims(Ckdu_codestream ^codestream, Ckdu_channel_mapping ^mapping, Int32 single_component, Int32 discard_levels, Ckdu_coords ^expand_numerator);
    Ckdu_dims ^get_rendered_image_dims();
    void set_white_stretch(Int32 white_stretch_precision);
    Boolean start(Ckdu_codestream ^codestream, Ckdu_channel_mapping ^mapping, Int32 single_component, Int32 discard_levels, Int32 max_layers, Ckdu_dims ^region, Ckdu_coords ^expand_numerator, Ckdu_coords ^expand_denominator, Boolean precise, Int32 access_mode, Boolean fastest, Ckdu_thread_env ^env, IntPtr env_queue);
    Boolean start(Ckdu_codestream ^codestream, Ckdu_channel_mapping ^mapping, Int32 single_component, Int32 discard_levels, Int32 max_layers, Ckdu_dims ^region, Ckdu_coords ^expand_numerator, Ckdu_coords ^expand_denominator, Boolean precise, Int32 access_mode, Boolean fastest, Ckdu_thread_env ^env);
    Boolean start(Ckdu_codestream ^codestream, Ckdu_channel_mapping ^mapping, Int32 single_component, Int32 discard_levels, Int32 max_layers, Ckdu_dims ^region, Ckdu_coords ^expand_numerator, Ckdu_coords ^expand_denominator, Boolean precise, Int32 access_mode, Boolean fastest);
    Boolean start(Ckdu_codestream ^codestream, Ckdu_channel_mapping ^mapping, Int32 single_component, Int32 discard_levels, Int32 max_layers, Ckdu_dims ^region, Ckdu_coords ^expand_numerator, Ckdu_coords ^expand_denominator, Boolean precise, Int32 access_mode);
    Boolean start(Ckdu_codestream ^codestream, Ckdu_channel_mapping ^mapping, Int32 single_component, Int32 discard_levels, Int32 max_layers, Ckdu_dims ^region, Ckdu_coords ^expand_numerator, Ckdu_coords ^expand_denominator, Boolean precise);
    Boolean start(Ckdu_codestream ^codestream, Ckdu_channel_mapping ^mapping, Int32 single_component, Int32 discard_levels, Int32 max_layers, Ckdu_dims ^region, Ckdu_coords ^expand_numerator, Ckdu_coords ^expand_denominator);
    Boolean start(Ckdu_codestream ^codestream, Ckdu_channel_mapping ^mapping, Int32 single_component, Int32 discard_levels, Int32 max_layers, Ckdu_dims ^region, Ckdu_coords ^expand_numerator);
    Boolean process(cli::array<Int32> ^buffer, Ckdu_coords ^buffer_origin, Int32 row_gap, Int32 suggested_increment, Int32 max_region_pixels, Ckdu_dims ^incomplete_region, Ckdu_dims ^new_region);
    Boolean process(cli::array<Byte> ^buffer, cli::array<Int32> ^channel_offsets, Int32 pixel_gap, Ckdu_coords ^buffer_origin, Int32 row_gap, Int32 suggested_increment, Int32 max_region_pixels, Ckdu_dims ^incomplete_region, Ckdu_dims ^new_region, Int32 precision_bits, Boolean measure_row_gap_in_pixels);
    Boolean process(cli::array<Byte> ^buffer, cli::array<Int32> ^channel_offsets, Int32 pixel_gap, Ckdu_coords ^buffer_origin, Int32 row_gap, Int32 suggested_increment, Int32 max_region_pixels, Ckdu_dims ^incomplete_region, Ckdu_dims ^new_region, Int32 precision_bits);
    Boolean process(cli::array<Byte> ^buffer, cli::array<Int32> ^channel_offsets, Int32 pixel_gap, Ckdu_coords ^buffer_origin, Int32 row_gap, Int32 suggested_increment, Int32 max_region_pixels, Ckdu_dims ^incomplete_region, Ckdu_dims ^new_region);
    Boolean process(cli::array<Int32> ^buffer, cli::array<Int32> ^channel_offsets, Int32 pixel_gap, Ckdu_coords ^buffer_origin, Int32 row_gap, Int32 suggested_increment, Int32 max_region_pixels, Ckdu_dims ^incomplete_region, Ckdu_dims ^new_region, Int32 precision_bits, Boolean measure_row_gap_in_pixels);
    Boolean process(cli::array<Int32> ^buffer, cli::array<Int32> ^channel_offsets, Int32 pixel_gap, Ckdu_coords ^buffer_origin, Int32 row_gap, Int32 suggested_increment, Int32 max_region_pixels, Ckdu_dims ^incomplete_region, Ckdu_dims ^new_region, Int32 precision_bits);
    Boolean process(cli::array<Int32> ^buffer, cli::array<Int32> ^channel_offsets, Int32 pixel_gap, Ckdu_coords ^buffer_origin, Int32 row_gap, Int32 suggested_increment, Int32 max_region_pixels, Ckdu_dims ^incomplete_region, Ckdu_dims ^new_region);
    Boolean finish();
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_resolution
  public ref class Ckdu_resolution {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Ckdu_resolution ^access_next();
    Int32 which();
    Int32 get_dwt_level();
    Int32 get_comp_idx();
    void get_dims(Ckdu_dims ^dims);
    void get_valid_precincts(Ckdu_dims ^indices);
    Ckdu_precinct ^open_precinct(Ckdu_coords ^precinct_idx);
    Int64 get_precinct_id(Ckdu_coords ^precinct_idx);
    Double get_precinct_relevance(Ckdu_coords ^precinct_idx);
    Int32 get_precinct_packets(Ckdu_coords ^precinct_idx, Ckdu_thread_env ^env, Boolean parse_if_necessary);
    Int32 get_precinct_packets(Ckdu_coords ^precinct_idx, Ckdu_thread_env ^env);
    Int32 get_precinct_packets(Ckdu_coords ^precinct_idx);
    Int64 get_precinct_samples(Ckdu_coords ^precinct_idx);
    Ckdu_node ^access_node();
    Int32 get_valid_band_indices(cli::interior_ptr<Int32> min_idx);
    Ckdu_subband ^access_subband(Int32 band_idx);
    Boolean get_reversible();
    Boolean propagate_roi();
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_roi_image
  public ref class Ckdu_roi_image {
  protected:
    kdu_roi_image * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_roi_image()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_roi_image * _get_kref() { return (kdu_roi_image *) _kref; }
    Ckdu_roi_image(kdu_roi_image * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_roi_image() { Do_dispose(false); }
    virtual Ckdu_roi_node ^acquire_node(Int32 component, Ckdu_dims ^tile_region);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_roi_node
  public ref class Ckdu_roi_node {
  protected:
    kdu_roi_node * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_roi_node()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_roi_node * _get_kref() { return (kdu_roi_node *) _kref; }
    Ckdu_roi_node(kdu_roi_node * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_roi_node() { Do_dispose(false); }
    virtual void release();
    virtual void pull(cli::array<Byte> ^buf, Int32 width);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_sample_allocator
  public ref class Ckdu_sample_allocator {
  protected:
    kdu_sample_allocator * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_sample_allocator()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_sample_allocator * _get_kref() { return (kdu_sample_allocator *) _kref; }
    Ckdu_sample_allocator(kdu_sample_allocator * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_sample_allocator() { Do_dispose(false); }
    Ckdu_sample_allocator();
    void restart();
    void pre_alloc(Boolean use_shorts, Int32 before, Int32 after, Int32 num_requests);
    void finalize();
    Int32 get_size();
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_sampled_range
  public ref class Ckdu_sampled_range {
  protected:
    kdu_sampled_range * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_sampled_range()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_sampled_range * _get_kref() { return (kdu_sampled_range *) _kref; }
    Ckdu_sampled_range(kdu_sampled_range * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_sampled_range() { Do_dispose(false); }
    Ckdu_sampled_range();
    Ckdu_sampled_range(Int32 val);
    Ckdu_sampled_range(Int32 from, Int32 to);
    Ckdu_sampled_range(Int32 from, Int32 to, Int32 step);
    Boolean is_empty();
    Int32 __property_get_from();
    Int32 __property_get_to();
    Int32 __property_get_step();
    Int32 get_remapping_id(Int32 which);
    Int32 __property_get_context_type();
    Ckdu_range_set ^get_context_expansion();
    void __property_set_from(Int32 from);
    void __property_set_to(Int32 to);
    void __property_set_step(Int32 step);
    void set_remapping_id(Int32 which, Int32 id_val);
    void __property_set_context_type(Int32 ctp);
    property Int32 from {
        Int32 get() { return __property_get_from(); }
        void set(Int32 from) { __property_set_from(from); }
      }
    property Int32 to {
        Int32 get() { return __property_get_to(); }
        void set(Int32 to) { __property_set_to(to); }
      }
    property Int32 step {
        Int32 get() { return __property_get_step(); }
        void set(Int32 step) { __property_set_step(step); }
      }
    property Int32 context_type {
        Int32 get() { return __property_get_context_type(); }
        void set(Int32 context_type) { __property_set_context_type(context_type); }
      }
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_serve
  public ref class Ckdu_serve {
  protected:
    kdu_serve * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_serve()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_serve * _get_kref() { return (kdu_serve *) _kref; }
    Ckdu_serve(kdu_serve * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_serve() { Do_dispose(false); }
    Ckdu_serve();
    void initialize(Ckdu_serve_target ^target, Int32 max_chunk_size, Int32 chunk_prefix_bytes, Boolean ignore_relevance_info);
    void initialize(Ckdu_serve_target ^target, Int32 max_chunk_size, Int32 chunk_prefix_bytes);
    void destroy();
    void set_window(Ckdu_window ^window);
    Boolean get_window(Ckdu_window ^window);
    void augment_cache_model(Int32 databin_class, Int32 stream_min, Int32 stream_max, Int64 bin_id, Int32 available_bytes, Int32 available_packets);
    void augment_cache_model(Int32 databin_class, Int32 stream_min, Int32 stream_max, Int64 bin_id, Int32 available_bytes);
    void truncate_cache_model(Int32 databin_class, Int32 stream_min, Int32 stream_max, Int64 bin_id, Int32 available_bytes, Int32 available_packets);
    void truncate_cache_model(Int32 databin_class, Int32 stream_min, Int32 stream_max, Int64 bin_id, Int32 available_bytes);
    void augment_cache_model(Int32 stream_min, Int32 stream_max, Int32 tmin, Int32 tmax, Int32 cmin, Int32 cmax, Int32 rmin, Int32 rmax, Int32 pmin, Int32 pmax, Int32 available_bytes, Int32 available_packets);
    void truncate_cache_model(Int32 stream_min, Int32 stream_max, Int32 tmin, Int32 tmax, Int32 cmin, Int32 cmax, Int32 rmin, Int32 rmax, Int32 pmin, Int32 pmax, Int32 available_bytes, Int32 available_packets);
    Boolean get_image_done();
    Int32 push_extra_data(cli::array<Byte> ^data, Int32 num_bytes);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_serve_target
  public ref class Ckdu_serve_target {
  protected:
    kdu_serve_target * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_serve_target()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_serve_target * _get_kref() { return (kdu_serve_target *) _kref; }
    Ckdu_serve_target(kdu_serve_target * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_serve_target() { Do_dispose(false); }
    virtual IntPtr get_codestream_ranges(cli::interior_ptr<Int32> num_ranges, Int32 compositing_layer_idx);
    IntPtr get_codestream_ranges(cli::interior_ptr<Int32> num_ranges);
    virtual Ckdu_codestream ^attach_to_codestream(Int32 codestream_id, IntPtr thread_handle);
    virtual void detach_from_codestream(Int32 codestream_id, IntPtr thread_handle);
    virtual void lock_codestreams(Int32 num_codestreams, cli::array<Int32> ^codestream_indices, IntPtr thread_handle);
    virtual void release_codestreams(Int32 num_codestreams, cli::array<Int32> ^codestream_indices, IntPtr thread_handle);
    virtual Int32 get_num_context_members(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids);
    virtual Int32 get_context_codestream(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids, Int32 member_idx);
    virtual IntPtr get_context_components(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids, Int32 member_idx, cli::interior_ptr<Int32> num_components);
    virtual Boolean perform_context_remapping(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids, Int32 member_idx, Ckdu_coords ^resolution, Ckdu_dims ^region);
    virtual Int32 find_roi(Int32 stream_id, String ^ roi_name);
    Int32 find_roi(Int32 stream_id);
    virtual String ^ get_roi_details(Int32 index, Ckdu_coords ^resolution, Ckdu_dims ^region);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_stripe_compressor
  public ref class Ckdu_stripe_compressor {
  protected:
    kdu_stripe_compressor * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_stripe_compressor()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_stripe_compressor * _get_kref() { return (kdu_stripe_compressor *) _kref; }
    Ckdu_stripe_compressor(kdu_stripe_compressor * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_stripe_compressor() { Do_dispose(false); }
    Ckdu_stripe_compressor();
    void start(Ckdu_codestream ^codestream, Int32 num_layer_specs, cli::array<Int64> ^layer_sizes, cli::array<Int32> ^layer_slopes, Int32 min_slope_threshold, Boolean no_prediction, Boolean force_precise, Boolean record_layer_info_in_comment, Double size_tolerance, Int32 num_components, Boolean want_fastest, Ckdu_thread_env ^env, IntPtr env_queue, Int32 env_dbuf_height);
    void start(Ckdu_codestream ^codestream, Int32 num_layer_specs, cli::array<Int64> ^layer_sizes, cli::array<Int32> ^layer_slopes, Int32 min_slope_threshold, Boolean no_prediction, Boolean force_precise, Boolean record_layer_info_in_comment, Double size_tolerance, Int32 num_components, Boolean want_fastest, Ckdu_thread_env ^env, IntPtr env_queue);
    void start(Ckdu_codestream ^codestream, Int32 num_layer_specs, cli::array<Int64> ^layer_sizes, cli::array<Int32> ^layer_slopes, Int32 min_slope_threshold, Boolean no_prediction, Boolean force_precise, Boolean record_layer_info_in_comment, Double size_tolerance, Int32 num_components, Boolean want_fastest, Ckdu_thread_env ^env);
    void start(Ckdu_codestream ^codestream, Int32 num_layer_specs, cli::array<Int64> ^layer_sizes, cli::array<Int32> ^layer_slopes, Int32 min_slope_threshold, Boolean no_prediction, Boolean force_precise, Boolean record_layer_info_in_comment, Double size_tolerance, Int32 num_components, Boolean want_fastest);
    void start(Ckdu_codestream ^codestream, Int32 num_layer_specs, cli::array<Int64> ^layer_sizes, cli::array<Int32> ^layer_slopes, Int32 min_slope_threshold, Boolean no_prediction, Boolean force_precise, Boolean record_layer_info_in_comment, Double size_tolerance, Int32 num_components);
    void start(Ckdu_codestream ^codestream, Int32 num_layer_specs, cli::array<Int64> ^layer_sizes, cli::array<Int32> ^layer_slopes, Int32 min_slope_threshold, Boolean no_prediction, Boolean force_precise, Boolean record_layer_info_in_comment, Double size_tolerance);
    void start(Ckdu_codestream ^codestream, Int32 num_layer_specs, cli::array<Int64> ^layer_sizes, cli::array<Int32> ^layer_slopes, Int32 min_slope_threshold, Boolean no_prediction, Boolean force_precise, Boolean record_layer_info_in_comment);
    void start(Ckdu_codestream ^codestream, Int32 num_layer_specs, cli::array<Int64> ^layer_sizes, cli::array<Int32> ^layer_slopes, Int32 min_slope_threshold, Boolean no_prediction, Boolean force_precise);
    void start(Ckdu_codestream ^codestream, Int32 num_layer_specs, cli::array<Int64> ^layer_sizes, cli::array<Int32> ^layer_slopes, Int32 min_slope_threshold, Boolean no_prediction);
    void start(Ckdu_codestream ^codestream, Int32 num_layer_specs, cli::array<Int64> ^layer_sizes, cli::array<Int32> ^layer_slopes, Int32 min_slope_threshold);
    void start(Ckdu_codestream ^codestream, Int32 num_layer_specs, cli::array<Int64> ^layer_sizes, cli::array<Int32> ^layer_slopes);
    void start(Ckdu_codestream ^codestream, Int32 num_layer_specs, cli::array<Int64> ^layer_sizes);
    void start(Ckdu_codestream ^codestream, Int32 num_layer_specs);
    void start(Ckdu_codestream ^codestream);
    Boolean finish(Int32 num_layer_specs, cli::array<Int64> ^layer_sizes, cli::array<Int32> ^layer_slopes);
    Boolean finish(Int32 num_layer_specs, cli::array<Int64> ^layer_sizes);
    Boolean finish(Int32 num_layer_specs);
    Boolean finish();
    Boolean get_recommended_stripe_heights(Int32 preferred_min_height, Int32 absolute_max_height, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^max_stripe_heights);
    Boolean push_stripe(cli::array<Byte> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions, Int32 flush_period);
    Boolean push_stripe(cli::array<Byte> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions);
    Boolean push_stripe(cli::array<Byte> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps);
    Boolean push_stripe(cli::array<Byte> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps);
    Boolean push_stripe(cli::array<Byte> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets);
    Boolean push_stripe(cli::array<Byte> ^buffer, cli::array<Int32> ^stripe_heights);
    Boolean push_stripe(cli::array<Int16> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions, cli::array<Boolean> ^is_signed, Int32 flush_period);
    Boolean push_stripe(cli::array<Int16> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions, cli::array<Boolean> ^is_signed);
    Boolean push_stripe(cli::array<Int16> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions);
    Boolean push_stripe(cli::array<Int16> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps);
    Boolean push_stripe(cli::array<Int16> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps);
    Boolean push_stripe(cli::array<Int16> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets);
    Boolean push_stripe(cli::array<Int16> ^buffer, cli::array<Int32> ^stripe_heights);
    Boolean push_stripe(cli::array<Int32> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions, cli::array<Boolean> ^is_signed, Int32 flush_period);
    Boolean push_stripe(cli::array<Int32> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions, cli::array<Boolean> ^is_signed);
    Boolean push_stripe(cli::array<Int32> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions);
    Boolean push_stripe(cli::array<Int32> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps);
    Boolean push_stripe(cli::array<Int32> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps);
    Boolean push_stripe(cli::array<Int32> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets);
    Boolean push_stripe(cli::array<Int32> ^buffer, cli::array<Int32> ^stripe_heights);
    Boolean push_stripe(cli::array<Single> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions, cli::array<Boolean> ^is_signed, Int32 flush_period);
    Boolean push_stripe(cli::array<Single> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions, cli::array<Boolean> ^is_signed);
    Boolean push_stripe(cli::array<Single> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions);
    Boolean push_stripe(cli::array<Single> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps);
    Boolean push_stripe(cli::array<Single> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps);
    Boolean push_stripe(cli::array<Single> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets);
    Boolean push_stripe(cli::array<Single> ^buffer, cli::array<Int32> ^stripe_heights);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_stripe_decompressor
  public ref class Ckdu_stripe_decompressor {
  protected:
    kdu_stripe_decompressor * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_stripe_decompressor()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_stripe_decompressor * _get_kref() { return (kdu_stripe_decompressor *) _kref; }
    Ckdu_stripe_decompressor(kdu_stripe_decompressor * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_stripe_decompressor() { Do_dispose(false); }
    Ckdu_stripe_decompressor();
    void start(Ckdu_codestream ^codestream, Boolean force_precise, Boolean want_fastest, Ckdu_thread_env ^env, IntPtr env_queue, Int32 env_dbuf_height);
    void start(Ckdu_codestream ^codestream, Boolean force_precise, Boolean want_fastest, Ckdu_thread_env ^env, IntPtr env_queue);
    void start(Ckdu_codestream ^codestream, Boolean force_precise, Boolean want_fastest, Ckdu_thread_env ^env);
    void start(Ckdu_codestream ^codestream, Boolean force_precise, Boolean want_fastest);
    void start(Ckdu_codestream ^codestream, Boolean force_precise);
    void start(Ckdu_codestream ^codestream);
    Boolean finish();
    Boolean get_recommended_stripe_heights(Int32 preferred_min_height, Int32 absolute_max_height, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^max_stripe_heights);
    Boolean pull_stripe(cli::array<Byte> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions);
    Boolean pull_stripe(cli::array<Byte> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps);
    Boolean pull_stripe(cli::array<Byte> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps);
    Boolean pull_stripe(cli::array<Byte> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets);
    Boolean pull_stripe(cli::array<Byte> ^buffer, cli::array<Int32> ^stripe_heights);
    Boolean pull_stripe(cli::array<Int16> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions, cli::array<Boolean> ^is_signed);
    Boolean pull_stripe(cli::array<Int16> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions);
    Boolean pull_stripe(cli::array<Int16> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps);
    Boolean pull_stripe(cli::array<Int16> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps);
    Boolean pull_stripe(cli::array<Int16> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets);
    Boolean pull_stripe(cli::array<Int16> ^buffer, cli::array<Int32> ^stripe_heights);
    Boolean pull_stripe(cli::array<Int32> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions, cli::array<Boolean> ^is_signed);
    Boolean pull_stripe(cli::array<Int32> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions);
    Boolean pull_stripe(cli::array<Int32> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps);
    Boolean pull_stripe(cli::array<Int32> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps);
    Boolean pull_stripe(cli::array<Int32> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets);
    Boolean pull_stripe(cli::array<Int32> ^buffer, cli::array<Int32> ^stripe_heights);
    Boolean pull_stripe(cli::array<Single> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions, cli::array<Boolean> ^is_signed);
    Boolean pull_stripe(cli::array<Single> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps, cli::array<Int32> ^precisions);
    Boolean pull_stripe(cli::array<Single> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps, cli::array<Int32> ^row_gaps);
    Boolean pull_stripe(cli::array<Single> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets, cli::array<Int32> ^sample_gaps);
    Boolean pull_stripe(cli::array<Single> ^buffer, cli::array<Int32> ^stripe_heights, cli::array<Int32> ^sample_offsets);
    Boolean pull_stripe(cli::array<Single> ^buffer, cli::array<Int32> ^stripe_heights);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_subband
  public ref class Ckdu_subband {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Int32 get_band_idx();
    Ckdu_resolution ^access_resolution();
    Int32 get_K_max();
    Int32 get_K_max_prime();
    Boolean get_reversible();
    Single get_delta();
    Single get_msb_wmse();
    Boolean get_roi_weight(cli::interior_ptr<Single> energy_weight);
    void get_dims(Ckdu_dims ^dims);
    void get_valid_blocks(Ckdu_dims ^indices);
    void get_block_size(Ckdu_coords ^nominal_size, Ckdu_coords ^first_size);
    Ckdu_block ^open_block(Ckdu_coords ^block_idx, cli::array<Int32> ^return_tpart, Ckdu_thread_env ^env);
    Ckdu_block ^open_block(Ckdu_coords ^block_idx, cli::array<Int32> ^return_tpart);
    Ckdu_block ^open_block(Ckdu_coords ^block_idx);
    void close_block(Ckdu_block ^block, Ckdu_thread_env ^env);
    void close_block(Ckdu_block ^block);
    Int32 get_conservative_slope_threshold();
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_thread_entity
  public ref class Ckdu_thread_entity {
  protected:
    kdu_thread_entity * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_thread_entity()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_thread_entity * _get_kref() { return (kdu_thread_entity *) _kref; }
    Ckdu_thread_entity(kdu_thread_entity * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_thread_entity() { Do_dispose(false); }
    Ckdu_thread_entity();
    void pre_destroy();
    virtual Ckdu_thread_entity ^new_instance();
    Boolean exists();
    Boolean is_group_owner();
    Ckdu_thread_entity ^get_current_thread_entity();
    virtual Int32 get_num_locks();
    void create(Int64 cpu_affinity);
    void create();
    Boolean destroy();
    Int32 get_num_threads();
    Boolean add_thread(Int32 thread_concurrency);
    Boolean add_thread();
    IntPtr add_queue(Ckdu_worker ^worker, IntPtr super_queue, String ^ name, Int64 queue_bank_idx);
    IntPtr add_queue(Ckdu_worker ^worker, IntPtr super_queue, String ^ name);
    IntPtr add_queue(Ckdu_worker ^worker, IntPtr super_queue);
    void add_jobs(IntPtr queue, Int32 num_jobs, Boolean finalize_queue, Int64 secondary_seq);
    void add_jobs(IntPtr queue, Int32 num_jobs, Boolean finalize_queue);
    Boolean synchronize(IntPtr root_queue, Boolean finalize_descendants_when_synchronized, Boolean finalize_root_when_synchronized);
    Boolean synchronize(IntPtr root_queue, Boolean finalize_descendants_when_synchronized);
    Boolean synchronize(IntPtr root_queue);
    Boolean terminate(IntPtr root_queue, Boolean leave_root, cli::array<Int32> ^exc_code);
    Boolean terminate(IntPtr root_queue, Boolean leave_root);
    void register_synchronized_job(Ckdu_worker ^worker, IntPtr queue, Boolean run_deferred);
    Boolean process_jobs(IntPtr wait_queue, Boolean waiting_for_sync, Boolean throw_group_failure);
    Boolean process_jobs(IntPtr wait_queue, Boolean waiting_for_sync);
    Boolean process_jobs(IntPtr wait_queue);
    virtual void handle_exception(Int32 exc_code);
    void acquire_lock(Int32 lock_id, Boolean allow_exceptions);
    void acquire_lock(Int32 lock_id);
    Boolean try_lock(Int32 lock_id, Boolean allow_exceptions);
    Boolean try_lock(Int32 lock_id);
    void release_lock(Int32 lock_id);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_tiffdir
  public ref class Ckdu_tiffdir {
  protected:
    kdu_tiffdir * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_tiffdir()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_tiffdir * _get_kref() { return (kdu_tiffdir *) _kref; }
    Ckdu_tiffdir(kdu_tiffdir * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_tiffdir() { Do_dispose(false); }
    Ckdu_tiffdir();
    Boolean exists();
    void init(Boolean littlendian);
    Boolean opendir(Ckdu_compressed_source ^src);
    Int32 write_header(Ckdu_compressed_target ^tgt, Int64 dir_offset);
    Boolean writedir(Ckdu_compressed_target ^tgt, Int64 dir_offset);
    Boolean is_littlendian();
    Boolean is_native_littlendian();
    void close();
    Int64 get_dirlength();
    Int64 get_taglength(Int64 tag_type);
    Int32 get_fieldlength(Int64 tag_type);
    Boolean delete_tag(Int64 tag_type);
    Int64 open_tag(Int64 tag_type);
    Int32 read_tag(Int64 tag_type, Int32 length, cli::array<Byte> ^data);
    Int32 read_tag(Int64 tag_type, Int32 length, cli::array<Int32> ^data);
    Int32 read_tag(Int64 tag_type, Int32 length, cli::array<Int64> ^data);
    Int32 read_tag(Int64 tag_type, Int32 length, cli::array<Double> ^data);
    void create_tag(Int64 tag_type);
    void write_tag(Int64 tag_type, Int32 length, cli::array<Byte> ^data);
    void write_tag(Int64 tag_type, Int32 length, cli::array<Int32> ^data);
    void write_tag(Int64 tag_type, Int32 length, cli::array<Int64> ^data);
    void write_tag(Int64 tag_type, Int32 length, cli::array<Double> ^data);
    void write_tag(Int64 tag_type, Int32 val16);
    void write_tag(Int64 tag_type, Int64 val32);
    void write_tag(Int64 tag_type, Double valdbl);
    void copy_tag(Ckdu_tiffdir ^src, Int64 tag_type);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_tile
  public ref class Ckdu_tile {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    void close(Ckdu_thread_env ^env);
    void close();
    Int32 get_tnum();
    Ckdu_coords ^get_tile_idx();
    Boolean get_ycc();
    void set_components_of_interest(Int32 num_components_of_interest, cli::array<Int32> ^components_of_interest);
    void set_components_of_interest(Int32 num_components_of_interest);
    void set_components_of_interest();
    Boolean get_mct_block_info(Int32 stage_idx, Int32 block_idx, cli::interior_ptr<Int32> num_stage_inputs, cli::interior_ptr<Int32> num_stage_outputs, cli::interior_ptr<Int32> num_block_inputs, cli::interior_ptr<Int32> num_block_outputs, cli::array<Int32> ^block_input_indices, cli::array<Int32> ^block_output_indices, cli::array<Single> ^irrev_block_offsets, cli::array<Int32> ^rev_block_offsets, cli::array<Int32> ^stage_input_indices);
    Boolean get_mct_block_info(Int32 stage_idx, Int32 block_idx, cli::interior_ptr<Int32> num_stage_inputs, cli::interior_ptr<Int32> num_stage_outputs, cli::interior_ptr<Int32> num_block_inputs, cli::interior_ptr<Int32> num_block_outputs, cli::array<Int32> ^block_input_indices, cli::array<Int32> ^block_output_indices, cli::array<Single> ^irrev_block_offsets, cli::array<Int32> ^rev_block_offsets);
    Boolean get_mct_block_info(Int32 stage_idx, Int32 block_idx, cli::interior_ptr<Int32> num_stage_inputs, cli::interior_ptr<Int32> num_stage_outputs, cli::interior_ptr<Int32> num_block_inputs, cli::interior_ptr<Int32> num_block_outputs, cli::array<Int32> ^block_input_indices, cli::array<Int32> ^block_output_indices, cli::array<Single> ^irrev_block_offsets);
    Boolean get_mct_block_info(Int32 stage_idx, Int32 block_idx, cli::interior_ptr<Int32> num_stage_inputs, cli::interior_ptr<Int32> num_stage_outputs, cli::interior_ptr<Int32> num_block_inputs, cli::interior_ptr<Int32> num_block_outputs, cli::array<Int32> ^block_input_indices, cli::array<Int32> ^block_output_indices);
    Boolean get_mct_block_info(Int32 stage_idx, Int32 block_idx, cli::interior_ptr<Int32> num_stage_inputs, cli::interior_ptr<Int32> num_stage_outputs, cli::interior_ptr<Int32> num_block_inputs, cli::interior_ptr<Int32> num_block_outputs, cli::array<Int32> ^block_input_indices);
    Boolean get_mct_block_info(Int32 stage_idx, Int32 block_idx, cli::interior_ptr<Int32> num_stage_inputs, cli::interior_ptr<Int32> num_stage_outputs, cli::interior_ptr<Int32> num_block_inputs, cli::interior_ptr<Int32> num_block_outputs);
    Boolean get_mct_matrix_info(Int32 stage_idx, Int32 block_idx, cli::array<Single> ^coefficients);
    Boolean get_mct_matrix_info(Int32 stage_idx, Int32 block_idx);
    Boolean get_mct_rxform_info(Int32 stage_idx, Int32 block_idx, cli::array<Int32> ^coefficients, cli::array<Int32> ^active_outputs);
    Boolean get_mct_rxform_info(Int32 stage_idx, Int32 block_idx, cli::array<Int32> ^coefficients);
    Boolean get_mct_rxform_info(Int32 stage_idx, Int32 block_idx);
    Boolean get_mct_dependency_info(Int32 stage_idx, Int32 block_idx, cli::interior_ptr<Boolean> is_reversible, cli::array<Single> ^irrev_coefficients, cli::array<Single> ^irrev_offsets, cli::array<Int32> ^rev_coefficients, cli::array<Int32> ^rev_offsets, cli::array<Int32> ^active_outputs);
    Boolean get_mct_dependency_info(Int32 stage_idx, Int32 block_idx, cli::interior_ptr<Boolean> is_reversible, cli::array<Single> ^irrev_coefficients, cli::array<Single> ^irrev_offsets, cli::array<Int32> ^rev_coefficients, cli::array<Int32> ^rev_offsets);
    Boolean get_mct_dependency_info(Int32 stage_idx, Int32 block_idx, cli::interior_ptr<Boolean> is_reversible, cli::array<Single> ^irrev_coefficients, cli::array<Single> ^irrev_offsets, cli::array<Int32> ^rev_coefficients);
    Boolean get_mct_dependency_info(Int32 stage_idx, Int32 block_idx, cli::interior_ptr<Boolean> is_reversible, cli::array<Single> ^irrev_coefficients, cli::array<Single> ^irrev_offsets);
    Boolean get_mct_dependency_info(Int32 stage_idx, Int32 block_idx, cli::interior_ptr<Boolean> is_reversible, cli::array<Single> ^irrev_coefficients);
    Boolean get_mct_dependency_info(Int32 stage_idx, Int32 block_idx, cli::interior_ptr<Boolean> is_reversible);
    Int32 get_num_components();
    Int32 get_num_layers();
    Boolean parse_all_relevant_packets(Boolean start_from_scratch_if_possible, Ckdu_thread_env ^env);
    Int64 get_parsed_packet_stats(Int32 component_idx, Int32 discard_levels, Int32 num_layers, cli::array<Int64> ^layer_bytes, cli::array<Int64> ^layer_packets);
    Int64 get_parsed_packet_stats(Int32 component_idx, Int32 discard_levels, Int32 num_layers, cli::array<Int64> ^layer_bytes);
    Ckdu_tile_comp ^access_component(Int32 component_idx);
    Single find_component_gain_info(Int32 comp_idx, Boolean restrict_to_interest);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_tile_comp
  public ref class Ckdu_tile_comp {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    Boolean get_reversible();
    void get_subsampling(Ckdu_coords ^factors);
    Int32 get_bit_depth(Boolean internal);
    Int32 get_bit_depth();
    Boolean get_signed();
    Int32 get_num_resolutions();
    Ckdu_resolution ^access_resolution(Int32 res_level);
    Ckdu_resolution ^access_resolution();
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_window
  public ref class Ckdu_window {
  protected:
    kdu_window * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_window()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_window * _get_kref() { return (kdu_window *) _kref; }
    Ckdu_window(kdu_window * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_window() { Do_dispose(false); }
    Ckdu_window();
    void init();
    void copy_from(Ckdu_window ^src, Boolean copy_expansions);
    void copy_from(Ckdu_window ^src);
    Boolean equals(Ckdu_window ^rhs);
    Boolean contains(Ckdu_window ^rhs);
    Ckdu_coords ^__property_get_resolution();
    void __property_set_resolution(Ckdu_coords ^resolution);
    Int32 __property_get_round_direction();
    void __property_set_round_direction(Int32 direction);
    Ckdu_dims ^__property_get_region();
    void __property_set_region(Ckdu_dims ^region);
    Ckdu_range_set ^access_components();
    Ckdu_range_set ^access_codestreams();
    Ckdu_range_set ^access_contexts();
    Ckdu_range_set ^create_context_expansion(Int32 which);
    String ^ parse_context(String ^ string);
    Int32 __property_get_max_layers();
    void __property_set_max_layers(Int32 val);
    Boolean __property_get_metadata_only();
    void __property_set_metadata_only(Boolean val);
    Ckdu_metareq ^get_metareq(Int32 index);
    void init_metareq();
    void add_metareq(Int64 box_type, Int32 qualifier, Boolean priority, Int32 byte_limit, Boolean recurse, Int64 root_bin_id, Int32 max_depth);
    void add_metareq(Int64 box_type, Int32 qualifier, Boolean priority, Int32 byte_limit, Boolean recurse, Int64 root_bin_id);
    void add_metareq(Int64 box_type, Int32 qualifier, Boolean priority, Int32 byte_limit, Boolean recurse);
    void add_metareq(Int64 box_type, Int32 qualifier, Boolean priority, Int32 byte_limit);
    void add_metareq(Int64 box_type, Int32 qualifier, Boolean priority);
    void add_metareq(Int64 box_type, Int32 qualifier);
    void add_metareq(Int64 box_type);
    String ^ parse_metareq(String ^ string);
    property Ckdu_coords ^resolution {
        Ckdu_coords ^get() { return __property_get_resolution(); }
        void set(Ckdu_coords ^resolution) { __property_set_resolution(resolution); }
      }
    property Int32 round_direction {
        Int32 get() { return __property_get_round_direction(); }
        void set(Int32 round_direction) { __property_set_round_direction(round_direction); }
      }
    property Ckdu_dims ^region {
        Ckdu_dims ^get() { return __property_get_region(); }
        void set(Ckdu_dims ^region) { __property_set_region(region); }
      }
    property Int32 max_layers {
        Int32 get() { return __property_get_max_layers(); }
        void set(Int32 max_layers) { __property_set_max_layers(max_layers); }
      }
    property Boolean metadata_only {
        Boolean get() { return __property_get_metadata_only(); }
        void set(Boolean metadata_only) { __property_set_metadata_only(metadata_only); }
      }
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_worker
  public ref class Ckdu_worker {
  protected:
    kdu_worker * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Ckdu_worker()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    kdu_worker * _get_kref() { return (kdu_worker *) _kref; }
    Ckdu_worker(kdu_worker * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Ckdu_worker() { Do_dispose(false); }
    virtual void do_job(Ckdu_thread_entity ^ent, Int32 job_idx);
  };
  //---------------------------------------------------
  // Managed Class: Cmj2_source
  public ref class Cmj2_source {
  protected:
    mj2_source * _kref;
  protected public:
    bool _natively_owned;
  public:
    ~Cmj2_source()
      {
        Do_dispose(true);
        // GC::SuppressFinalize implicit call here
      }
  protected:
    virtual void Do_dispose(bool in_dispose);
  protected public:
    mj2_source * _get_kref() { return (mj2_source *) _kref; }
    Cmj2_source(mj2_source * _existing_kref)
      {
        this->_kref=_existing_kref;
        _natively_owned=true;
      }
  public:
    !Cmj2_source() { Do_dispose(false); }
    Cmj2_source();
    Cmj2_source(IntPtr state);
    Boolean exists();
    Int32 open(Cjp2_family_src ^src, Boolean return_if_incompatible);
    Int32 open(Cjp2_family_src ^src);
    void close();
    Cjp2_family_src ^get_ultimate_src();
    Ckdu_dims ^get_movie_dims();
    Int64 get_next_track(Int64 prev_track_idx);
    Int32 get_track_type(Int64 track_idx);
    Cmj2_video_source ^access_video_track(Int64 track_idx);
    Boolean find_stream(Int32 stream_idx, cli::interior_ptr<Int64> track_idx, cli::interior_ptr<Int32> frame_idx, cli::interior_ptr<Int32> field_idx);
    Boolean count_codestreams(cli::interior_ptr<Int32> count);
  };
  //---------------------------------------------------
  // Managed Class: Cmj2_target
  public ref class Cmj2_target {
  protected public:
    IntPtr _kval;
  public:
    Boolean exists();
    void open(Cjp2_family_tgt ^tgt);
    void close();
    Cmj2_video_target ^add_video_track();
  };
  //---------------------------------------------------
  // Managed Class: Cads_params
  public ref class Cads_params : public Ckdu_params {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    ads_params * _get_kref() { return (ads_params *) _kref; }
    Cads_params(ads_params * _existing_kref)
        : Ckdu_params(_existing_kref)
      { return; }
  public:
    Cads_params();
  };
  //---------------------------------------------------
  // Managed Class: Catk_params
  public ref class Catk_params : public Ckdu_params {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    atk_params * _get_kref() { return (atk_params *) _kref; }
    Catk_params(atk_params * _existing_kref)
        : Ckdu_params(_existing_kref)
      { return; }
  public:
    Catk_params();
  };
  //---------------------------------------------------
  // Managed Class: Ccod_params
  public ref class Ccod_params : public Ckdu_params {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    cod_params * _get_kref() { return (cod_params *) _kref; }
    Ccod_params(cod_params * _existing_kref)
        : Ckdu_params(_existing_kref)
      { return; }
  public:
    Ccod_params();
    Boolean is_valid_decomp_terminator(Int32 val);
    Int32 transpose_decomp(Int32 val);
    Int32 expand_decomp_bands(Int32 decomp_val, cli::array<Int16> ^band_descriptors);
    void get_max_decomp_levels(Int32 decomp_val, cli::interior_ptr<Int32> max_horizontal_levels, cli::interior_ptr<Int32> max_vertical_levels);
  };
  //---------------------------------------------------
  // Managed Class: Ccrg_params
  public ref class Ccrg_params : public Ckdu_params {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    crg_params * _get_kref() { return (crg_params *) _kref; }
    Ccrg_params(crg_params * _existing_kref)
        : Ckdu_params(_existing_kref)
      { return; }
  public:
    Ccrg_params();
  };
  //---------------------------------------------------
  // Managed Class: Cdfs_params
  public ref class Cdfs_params : public Ckdu_params {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    dfs_params * _get_kref() { return (dfs_params *) _kref; }
    Cdfs_params(dfs_params * _existing_kref)
        : Ckdu_params(_existing_kref)
      { return; }
  public:
    Cdfs_params();
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_input_box
  public ref class Cjp2_input_box : public Ckdu_compressed_source {
  protected public:
    jp2_input_box * _get_kref() { return (jp2_input_box *) _kref; }
    Cjp2_input_box(jp2_input_box * _existing_kref)
        : Ckdu_compressed_source(_existing_kref)
      { return; }
  public:
    Cjp2_input_box();
    Boolean exists();
    virtual Boolean open(Cjp2_family_src ^src, Cjp2_locator ^locator);
    Boolean open(Cjp2_family_src ^src);
    virtual Boolean open(Cjp2_input_box ^super_box);
    virtual Boolean open_next();
    virtual Boolean close() override;
    virtual void transplant(Cjp2_input_box ^src);
    Boolean has_caching_source();
    Int64 get_box_type();
    Cjp2_locator ^get_locator();
    Int32 get_box_header_length();
    virtual Int32 get_capabilities() override;
    Int64 get_remaining_bytes();
    Int64 get_box_bytes();
    Boolean is_complete();
    virtual Boolean seek(Int64 offset) override;
    virtual Int64 get_pos() override;
    virtual Boolean load_in_memory(Int32 max_bytes);
    virtual Int32 read(cli::array<Byte> ^buf, Int32 num_bytes) override;
    Boolean read(cli::interior_ptr<Int64> dword);
    Boolean read(cli::interior_ptr<Int32> dword);
    Boolean read(cli::interior_ptr<Int16> word);
    Boolean read(cli::interior_ptr<Byte> byte);
    virtual Boolean set_tileheader_scope(Int32 tnum, Int32 num_tiles) override;
    virtual Boolean set_precinct_scope(Int64 unique_id) override;
    virtual Boolean set_codestream_scope(Int64 codestream_id, Boolean need_main_header);
    Boolean set_codestream_scope(Int64 codestream_id);
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_output_box
  public ref class Cjp2_output_box : public Ckdu_compressed_target {
  protected public:
    jp2_output_box * _get_kref() { return (jp2_output_box *) _kref; }
    Cjp2_output_box(jp2_output_box * _existing_kref)
        : Ckdu_compressed_target(_existing_kref)
      { return; }
  public:
    Cjp2_output_box();
    Boolean exists();
    virtual void open(Cjp2_family_tgt ^tgt, Int64 box_type, Boolean rubber_length);
    void open(Cjp2_family_tgt ^tgt, Int64 box_type);
    virtual void open(Cjp2_output_box ^super_box, Int64 box_type, Boolean rubber_length);
    void open(Cjp2_output_box ^super_box, Int64 box_type);
    virtual void open(Int64 box_type);
    virtual void open_next(Int64 box_type, Boolean rubber_length);
    void open_next(Int64 box_type);
    Int64 get_box_type();
    IntPtr get_contents(cli::interior_ptr<Int64> length);
    void set_rubber_length();
    virtual void set_target_size(Int64 num_bytes) override;
    virtual void write_header_last();
    virtual Boolean close() override;
    virtual Boolean start_rewrite(Int64 backtrack) override;
    virtual Boolean end_rewrite() override;
    virtual Boolean write(cli::array<Byte> ^buf, Int32 num_bytes) override;
    Boolean write(Int64 dword);
    Boolean write(Int32 dword);
    Boolean write(Int16 word);
    Boolean write(Byte byte);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_analysis
  public ref class Ckdu_analysis : public Ckdu_push_ifc {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    kdu_analysis * _get_kref() { return (kdu_analysis *) _kref; }
    Ckdu_analysis(kdu_analysis * _existing_kref)
        : Ckdu_push_ifc(_existing_kref)
      { return; }
  public:
    Ckdu_analysis(Ckdu_node ^node, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Ckdu_roi_node ^roi, Ckdu_thread_env ^env, IntPtr env_queue);
    Ckdu_analysis(Ckdu_node ^node, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Ckdu_roi_node ^roi, Ckdu_thread_env ^env);
    Ckdu_analysis(Ckdu_node ^node, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Ckdu_roi_node ^roi);
    Ckdu_analysis(Ckdu_node ^node, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization);
    Ckdu_analysis(Ckdu_node ^node, Ckdu_sample_allocator ^allocator, Boolean use_shorts);
    Ckdu_analysis(Ckdu_resolution ^resolution, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Ckdu_roi_node ^roi, Ckdu_thread_env ^env, IntPtr env_queue);
    Ckdu_analysis(Ckdu_resolution ^resolution, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Ckdu_roi_node ^roi, Ckdu_thread_env ^env);
    Ckdu_analysis(Ckdu_resolution ^resolution, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Ckdu_roi_node ^roi);
    Ckdu_analysis(Ckdu_resolution ^resolution, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization);
    Ckdu_analysis(Ckdu_resolution ^resolution, Ckdu_sample_allocator ^allocator, Boolean use_shorts);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_cache
  public ref class Ckdu_cache : public Ckdu_compressed_source {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    kdu_cache * _get_kref() { return (kdu_cache *) _kref; }
    Ckdu_cache(kdu_cache * _existing_kref)
        : Ckdu_compressed_source(_existing_kref)
      { return; }
  public:
    Ckdu_cache();
    void attach_to(Ckdu_cache ^existing);
    virtual Boolean close() override;
    virtual void add_to_databin(Int32 databin_class, Int64 codestream_id, Int64 databin_id, cli::array<Byte> ^data, Int32 offset, Int32 num_bytes, Boolean is_final, Boolean add_as_most_recent, Boolean mark_if_augmented);
    void add_to_databin(Int32 databin_class, Int64 codestream_id, Int64 databin_id, cli::array<Byte> ^data, Int32 offset, Int32 num_bytes, Boolean is_final, Boolean add_as_most_recent);
    void add_to_databin(Int32 databin_class, Int64 codestream_id, Int64 databin_id, cli::array<Byte> ^data, Int32 offset, Int32 num_bytes, Boolean is_final);
    virtual Int32 get_databin_length(Int32 databin_class, Int64 codestream_id, Int64 databin_id, cli::array<Boolean> ^is_complete);
    Int32 get_databin_length(Int32 databin_class, Int64 codestream_id, Int64 databin_id);
    virtual void promote_databin(Int32 databin_class, Int64 codestream_id, Int64 databin_id);
    virtual void demote_databin(Int32 databin_class, Int64 codestream_id, Int64 databin_id);
    virtual Int64 get_next_codestream(Int64 stream_id);
    virtual Int64 get_next_lru_databin(Int32 databin_class, Int64 codestream_id, Int64 databin_id, Boolean only_if_marked);
    Int64 get_next_lru_databin(Int32 databin_class, Int64 codestream_id, Int64 databin_id);
    virtual Int64 get_next_mru_databin(Int32 databin_class, Int64 codestream_id, Int64 databin_id, Boolean only_if_marked);
    Int64 get_next_mru_databin(Int32 databin_class, Int64 codestream_id, Int64 databin_id);
    virtual Boolean mark_databin(Int32 databin_class, Int64 codestream_id, Int64 databin_id, Boolean mark_state);
    virtual void clear_all_marks();
    virtual void set_all_marks();
    virtual Int32 get_databin_prefix(Int32 databin_class, Int64 codestream_id, Int64 databin_id, cli::array<Byte> ^buf, Int32 max_bytes);
    virtual void set_read_scope(Int32 databin_class, Int64 codestream_id, Int64 databin_id);
    virtual Boolean set_tileheader_scope(Int32 tnum, Int32 num_tiles) override;
    virtual Boolean set_precinct_scope(Int64 unique_id) override;
    virtual Int32 read(cli::array<Byte> ^buf, Int32 num_bytes) override;
    virtual Int32 get_capabilities() override;
    virtual Boolean seek(Int64 offset) override;
    virtual Int64 get_pos() override;
    virtual void acquire_lock();
    virtual void release_lock();
    Int64 get_peak_cache_memory();
    Int64 get_transferred_bytes(Int32 databin_class);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_clientx
  public ref class Ckdu_clientx : public Ckdu_client_translator {
  protected public:
    kdu_clientx * _get_kref() { return (kdu_clientx *) _kref; }
    Ckdu_clientx(kdu_clientx * _existing_kref)
        : Ckdu_client_translator(_existing_kref)
      { return; }
  public:
    Ckdu_clientx();
    virtual void close() override;
    virtual Boolean update() override;
    virtual Int32 get_num_context_members(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids) override;
    virtual Int32 get_context_codestream(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids, Int32 member_idx) override;
    virtual IntPtr get_context_components(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids, Int32 member_idx, cli::interior_ptr<Int32> num_components) override;
    virtual Boolean perform_context_remapping(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids, Int32 member_idx, Ckdu_coords ^resolution, Ckdu_dims ^region) override;
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_compressed_source_nonnative
  public ref class Ckdu_compressed_source_nonnative : public Ckdu_compressed_source {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    kdu_compressed_source_nonnative * _get_kref() { return (kdu_compressed_source_nonnative *) _kref; }
    Ckdu_compressed_source_nonnative(kdu_compressed_source_nonnative * _existing_kref)
        : Ckdu_compressed_source(_existing_kref)
      { return; }
  public:
    Ckdu_compressed_source_nonnative();
    virtual Int32 get_capabilities() override;
    virtual Boolean seek(Int64 offset) override;
    virtual Int64 get_pos() override;
    virtual Boolean set_tileheader_scope(Int32 tnum, Int32 num_tiles) override;
    virtual Boolean set_precinct_scope(Int64 unique_id) override;
    virtual Int32 post_read(Int32 num_bytes);
    void push_data(cli::array<Byte> ^data, Int32 first_byte_pos, Int32 num_bytes);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_compressed_target_nonnative
  public ref class Ckdu_compressed_target_nonnative : public Ckdu_compressed_target {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    kdu_compressed_target_nonnative * _get_kref() { return (kdu_compressed_target_nonnative *) _kref; }
    Ckdu_compressed_target_nonnative(kdu_compressed_target_nonnative * _existing_kref)
        : Ckdu_compressed_target(_existing_kref)
      { return; }
  public:
    Ckdu_compressed_target_nonnative();
    virtual Boolean start_rewrite(Int64 backtrack) override;
    virtual Boolean end_rewrite() override;
    virtual void set_target_size(Int64 num_bytes) override;
    virtual Boolean post_write(Int32 num_bytes);
    Int32 pull_data(cli::array<Byte> ^data, Int32 first_byte_pos, Int32 num_bytes);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_compressed_video_source
  public ref class Ckdu_compressed_video_source : public Ckdu_compressed_source {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    kdu_compressed_video_source * _get_kref() { return (kdu_compressed_video_source *) _kref; }
    Ckdu_compressed_video_source(kdu_compressed_video_source * _existing_kref)
        : Ckdu_compressed_source(_existing_kref)
      { return; }
  public:
    virtual Int64 get_timescale();
    virtual Int32 get_field_order();
    virtual void set_field_mode(Int32 which);
    virtual Int32 get_num_frames();
    virtual Boolean seek_to_frame(Int32 frame_idx);
    virtual Int64 get_duration();
    virtual Int32 time_to_frame(Int64 time_instant);
    virtual Int64 get_frame_instant();
    virtual Int64 get_frame_period();
    virtual Int32 open_image();
    virtual void close_image();
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_compressed_video_target
  public ref class Ckdu_compressed_video_target : public Ckdu_compressed_target {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    kdu_compressed_video_target * _get_kref() { return (kdu_compressed_video_target *) _kref; }
    Ckdu_compressed_video_target(kdu_compressed_video_target * _existing_kref)
        : Ckdu_compressed_target(_existing_kref)
      { return; }
  public:
    virtual void open_image();
    virtual void close_image(Ckdu_codestream ^codestream);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_decoder
  public ref class Ckdu_decoder : public Ckdu_pull_ifc {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    kdu_decoder * _get_kref() { return (kdu_decoder *) _kref; }
    Ckdu_decoder(kdu_decoder * _existing_kref)
        : Ckdu_pull_ifc(_existing_kref)
      { return; }
  public:
    Ckdu_decoder(Ckdu_subband ^subband, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Int32 pull_offset, Ckdu_thread_env ^env, IntPtr env_queue);
    Ckdu_decoder(Ckdu_subband ^subband, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Int32 pull_offset, Ckdu_thread_env ^env);
    Ckdu_decoder(Ckdu_subband ^subband, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Int32 pull_offset);
    Ckdu_decoder(Ckdu_subband ^subband, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization);
    Ckdu_decoder(Ckdu_subband ^subband, Ckdu_sample_allocator ^allocator, Boolean use_shorts);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_encoder
  public ref class Ckdu_encoder : public Ckdu_push_ifc {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    kdu_encoder * _get_kref() { return (kdu_encoder *) _kref; }
    Ckdu_encoder(kdu_encoder * _existing_kref)
        : Ckdu_push_ifc(_existing_kref)
      { return; }
  public:
    Ckdu_encoder(Ckdu_subband ^subband, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Ckdu_roi_node ^roi, Ckdu_thread_env ^env, IntPtr env_queue);
    Ckdu_encoder(Ckdu_subband ^subband, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Ckdu_roi_node ^roi, Ckdu_thread_env ^env);
    Ckdu_encoder(Ckdu_subband ^subband, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Ckdu_roi_node ^roi);
    Ckdu_encoder(Ckdu_subband ^subband, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization);
    Ckdu_encoder(Ckdu_subband ^subband, Ckdu_sample_allocator ^allocator, Boolean use_shorts);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_message_formatter
  public ref class Ckdu_message_formatter : public Ckdu_message {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    kdu_message_formatter * _get_kref() { return (kdu_message_formatter *) _kref; }
    Ckdu_message_formatter(kdu_message_formatter * _existing_kref)
        : Ckdu_message(_existing_kref)
      { return; }
  public:
    Ckdu_message_formatter(Ckdu_message ^output, Int32 max_line);
    Ckdu_message_formatter(Ckdu_message ^output);
    void set_master_indent(Int32 val);
    virtual void put_text(String ^ string) override;
    virtual void put_text(cli::array<Int32> ^string) override;
    virtual void flush(Boolean end_of_message) override;
    void flush();
    virtual void start_message() override;
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_servex
  public ref class Ckdu_servex : public Ckdu_serve_target {
  protected public:
    kdu_servex * _get_kref() { return (kdu_servex *) _kref; }
    Ckdu_servex(kdu_servex * _existing_kref)
        : Ckdu_serve_target(_existing_kref)
      { return; }
  public:
    void open(String ^ filename, Int32 phld_threshold, Int32 per_client_cache, IntPtr cache_fp, Boolean cache_exists, Int64 sub_start, Int64 sub_lim);
    void open(String ^ filename, Int32 phld_threshold, Int32 per_client_cache, IntPtr cache_fp, Boolean cache_exists, Int64 sub_start);
    void open(String ^ filename, Int32 phld_threshold, Int32 per_client_cache, IntPtr cache_fp, Boolean cache_exists);
    void close();
    virtual IntPtr get_codestream_ranges(cli::interior_ptr<Int32> num_ranges, Int32 compositing_layer_idx) override;
    virtual Ckdu_codestream ^attach_to_codestream(Int32 codestream_id, IntPtr thread_handle) override;
    virtual void detach_from_codestream(Int32 codestream_id, IntPtr thread_handle) override;
    virtual void lock_codestreams(Int32 num_codestreams, cli::array<Int32> ^codestream_indices, IntPtr thread_handle) override;
    virtual void release_codestreams(Int32 num_codestreams, cli::array<Int32> ^codestream_indices, IntPtr thread_handle) override;
    virtual Int32 get_num_context_members(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids) override;
    virtual Int32 get_context_codestream(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids, Int32 member_idx) override;
    virtual IntPtr get_context_components(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids, Int32 member_idx, cli::interior_ptr<Int32> num_components) override;
    virtual Boolean perform_context_remapping(Int32 context_type, Int32 context_idx, cli::array<Int32> ^remapping_ids, Int32 member_idx, Ckdu_coords ^resolution, Ckdu_dims ^region) override;
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_simple_file_source
  public ref class Ckdu_simple_file_source : public Ckdu_compressed_source {
  protected public:
    kdu_simple_file_source * _get_kref() { return (kdu_simple_file_source *) _kref; }
    Ckdu_simple_file_source(kdu_simple_file_source * _existing_kref)
        : Ckdu_compressed_source(_existing_kref)
      { return; }
  public:
    Ckdu_simple_file_source();
    Ckdu_simple_file_source(String ^ fname, Boolean allow_seeks);
    Ckdu_simple_file_source(String ^ fname);
    Boolean exists();
    Boolean open(String ^ fname, Boolean allow_seeks, Boolean return_on_failure);
    Boolean open(String ^ fname, Boolean allow_seeks);
    Boolean open(String ^ fname);
    virtual Int32 get_capabilities() override;
    virtual Boolean seek(Int64 offset) override;
    virtual Int64 get_pos() override;
    virtual Int32 read(cli::array<Byte> ^buf, Int32 num_bytes) override;
    virtual Boolean close() override;
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_simple_file_target
  public ref class Ckdu_simple_file_target : public Ckdu_compressed_target {
  protected public:
    kdu_simple_file_target * _get_kref() { return (kdu_simple_file_target *) _kref; }
    Ckdu_simple_file_target(kdu_simple_file_target * _existing_kref)
        : Ckdu_compressed_target(_existing_kref)
      { return; }
  public:
    Ckdu_simple_file_target();
    Ckdu_simple_file_target(String ^ fname, Boolean append_to_existing);
    Ckdu_simple_file_target(String ^ fname);
    Boolean exists();
    Boolean open(String ^ fname, Boolean append_to_existing, Boolean return_on_failure);
    Boolean open(String ^ fname, Boolean append_to_existing);
    Boolean open(String ^ fname);
    Boolean strip_tail(cli::array<Byte> ^buf, Int32 num_bytes);
    virtual Boolean write(cli::array<Byte> ^buf, Int32 num_bytes) override;
    virtual Boolean close() override;
    virtual Boolean start_rewrite(Int64 backtrack) override;
    virtual Boolean end_rewrite() override;
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_synthesis
  public ref class Ckdu_synthesis : public Ckdu_pull_ifc {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    kdu_synthesis * _get_kref() { return (kdu_synthesis *) _kref; }
    Ckdu_synthesis(kdu_synthesis * _existing_kref)
        : Ckdu_pull_ifc(_existing_kref)
      { return; }
  public:
    Ckdu_synthesis(Ckdu_node ^node, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Int32 pull_offset, Ckdu_thread_env ^env, IntPtr env_queue);
    Ckdu_synthesis(Ckdu_node ^node, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Int32 pull_offset, Ckdu_thread_env ^env);
    Ckdu_synthesis(Ckdu_node ^node, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Int32 pull_offset);
    Ckdu_synthesis(Ckdu_node ^node, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization);
    Ckdu_synthesis(Ckdu_node ^node, Ckdu_sample_allocator ^allocator, Boolean use_shorts);
    Ckdu_synthesis(Ckdu_resolution ^resolution, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Ckdu_thread_env ^env, IntPtr env_queue);
    Ckdu_synthesis(Ckdu_resolution ^resolution, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization, Ckdu_thread_env ^env);
    Ckdu_synthesis(Ckdu_resolution ^resolution, Ckdu_sample_allocator ^allocator, Boolean use_shorts, Single normalization);
    Ckdu_synthesis(Ckdu_resolution ^resolution, Ckdu_sample_allocator ^allocator, Boolean use_shorts);
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_thread_env
  public ref class Ckdu_thread_env : public Ckdu_thread_entity {
  protected public:
    kdu_thread_env * _get_kref() { return (kdu_thread_env *) _kref; }
    Ckdu_thread_env(kdu_thread_env * _existing_kref)
        : Ckdu_thread_entity(_existing_kref)
      { return; }
  public:
    Ckdu_thread_env();
    virtual Ckdu_thread_entity ^new_instance() override;
    virtual Int32 get_num_locks() override;
    IntPtr get_state();
    Ckdu_thread_env ^get_current_thread_env();
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_thread_safe_message
  public ref class Ckdu_thread_safe_message : public Ckdu_message {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    kdu_thread_safe_message * _get_kref() { return (kdu_thread_safe_message *) _kref; }
    Ckdu_thread_safe_message(kdu_thread_safe_message * _existing_kref)
        : Ckdu_message(_existing_kref)
      { return; }
  public:
    Ckdu_thread_safe_message();
    virtual void flush(Boolean end_of_message) override;
    void flush();
    virtual void start_message() override;
  };
  //---------------------------------------------------
  // Managed Class: Cmcc_params
  public ref class Cmcc_params : public Ckdu_params {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    mcc_params * _get_kref() { return (mcc_params *) _kref; }
    Cmcc_params(mcc_params * _existing_kref)
        : Ckdu_params(_existing_kref)
      { return; }
  public:
    Cmcc_params();
  };
  //---------------------------------------------------
  // Managed Class: Cmco_params
  public ref class Cmco_params : public Ckdu_params {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    mco_params * _get_kref() { return (mco_params *) _kref; }
    Cmco_params(mco_params * _existing_kref)
        : Ckdu_params(_existing_kref)
      { return; }
  public:
    Cmco_params();
  };
  //---------------------------------------------------
  // Managed Class: Cmct_params
  public ref class Cmct_params : public Ckdu_params {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    mct_params * _get_kref() { return (mct_params *) _kref; }
    Cmct_params(mct_params * _existing_kref)
        : Ckdu_params(_existing_kref)
      { return; }
  public:
    Cmct_params();
  };
  //---------------------------------------------------
  // Managed Class: Corg_params
  public ref class Corg_params : public Ckdu_params {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    org_params * _get_kref() { return (org_params *) _kref; }
    Corg_params(org_params * _existing_kref)
        : Ckdu_params(_existing_kref)
      { return; }
  public:
    Corg_params();
  };
  //---------------------------------------------------
  // Managed Class: Cpoc_params
  public ref class Cpoc_params : public Ckdu_params {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    poc_params * _get_kref() { return (poc_params *) _kref; }
    Cpoc_params(poc_params * _existing_kref)
        : Ckdu_params(_existing_kref)
      { return; }
  public:
    Cpoc_params();
  };
  //---------------------------------------------------
  // Managed Class: Cqcd_params
  public ref class Cqcd_params : public Ckdu_params {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    qcd_params * _get_kref() { return (qcd_params *) _kref; }
    Cqcd_params(qcd_params * _existing_kref)
        : Ckdu_params(_existing_kref)
      { return; }
  public:
    Cqcd_params();
  };
  //---------------------------------------------------
  // Managed Class: Crgn_params
  public ref class Crgn_params : public Ckdu_params {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    rgn_params * _get_kref() { return (rgn_params *) _kref; }
    Crgn_params(rgn_params * _existing_kref)
        : Ckdu_params(_existing_kref)
      { return; }
  public:
    Crgn_params();
  };
  //---------------------------------------------------
  // Managed Class: Csiz_params
  public ref class Csiz_params : public Ckdu_params {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    siz_params * _get_kref() { return (siz_params *) _kref; }
    Csiz_params(siz_params * _existing_kref)
        : Ckdu_params(_existing_kref)
      { return; }
  public:
    Csiz_params();
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_source
  public ref class Cjp2_source : public Cjp2_input_box {
  protected public:
    jp2_source * _get_kref() { return (jp2_source *) _kref; }
    Cjp2_source(jp2_source * _existing_kref)
        : Cjp2_input_box(_existing_kref)
      { return; }
  public:
    Cjp2_source();
    virtual Boolean open(Cjp2_family_src ^src, Cjp2_locator ^loc) override;
    Boolean open(Cjp2_family_src ^src);
    virtual Boolean open(Cjp2_input_box ^super_box) override;
    Boolean read_header();
    Int64 get_header_bytes();
    Cjp2_dimensions ^access_dimensions();
    Cjp2_palette ^access_palette();
    Cjp2_channels ^access_channels();
    Cjp2_colour ^access_colour();
    Cjp2_resolution ^access_resolution();
  };
  //---------------------------------------------------
  // Managed Class: Cjp2_target
  public ref class Cjp2_target : public Cjp2_output_box {
  protected public:
    jp2_target * _get_kref() { return (jp2_target *) _kref; }
    Cjp2_target(jp2_target * _existing_kref)
        : Cjp2_output_box(_existing_kref)
      { return; }
  public:
    Cjp2_target();
    virtual void open(Cjp2_family_tgt ^tgt);
    virtual void open(Cjp2_family_tgt ^tgt, Int64 box_type, Boolean rubber_length) override;
    void open(Cjp2_family_tgt ^tgt, Int64 box_type);
    virtual void open(Cjp2_output_box ^super_box, Int64 box_type, Boolean rubber_length) override;
    void open(Cjp2_output_box ^super_box, Int64 box_type);
    virtual void open(Int64 box_type) override;
    void write_header();
    void open_codestream(Boolean rubber_length);
    void open_codestream();
    Cjp2_dimensions ^access_dimensions();
    Cjp2_colour ^access_colour();
    Cjp2_palette ^access_palette();
    Cjp2_channels ^access_channels();
    Cjp2_resolution ^access_resolution();
  };
  //---------------------------------------------------
  // Managed Class: Cjpx_input_box
  public ref class Cjpx_input_box : public Cjp2_input_box {
  protected public:
    jpx_input_box * _get_kref() { return (jpx_input_box *) _kref; }
    Cjpx_input_box(jpx_input_box * _existing_kref)
        : Cjp2_input_box(_existing_kref)
      { return; }
  public:
    Cjpx_input_box();
    Boolean exists();
    virtual Boolean open_as(Cjpx_fragment_list ^frag_list, Cjp2_data_references ^data_refs, Cjp2_family_src ^ultimate_src, Int64 box_type);
    virtual Boolean open_next() override;
    virtual Boolean close() override;
    virtual Boolean seek(Int64 offset) override;
    virtual Int32 read(cli::array<Byte> ^buf, Int32 num_bytes) override;
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_client
  public ref class Ckdu_client : public Ckdu_cache {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    kdu_client * _get_kref() { return (kdu_client *) _kref; }
    Ckdu_client(kdu_client * _existing_kref)
        : Ckdu_cache(_existing_kref)
      { return; }
  public:
    Ckdu_client();
    void install_context_translator(Ckdu_client_translator ^translator);
    virtual void connect(String ^ server, String ^ proxy, String ^ request, String ^ channel_transport, String ^ cache_dir);
    Boolean is_active();
    Boolean is_one_time_request();
    Boolean is_alive();
    Boolean is_idle();
    virtual void disconnect(Boolean keep_transport_open, Int32 timeout_milliseconds);
    void disconnect(Boolean keep_transport_open);
    void disconnect();
    virtual Boolean close() override;
    void install_notifier(Ckdu_client_notifier ^notifier);
    virtual String ^ get_status();
    virtual Boolean post_window(Ckdu_window ^window);
    virtual Boolean get_window_in_progress(Ckdu_window ^window);
    Int32 get_received_bytes();
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_simple_video_source
  public ref class Ckdu_simple_video_source : public Ckdu_compressed_video_source {
  protected public:
    kdu_simple_video_source * _get_kref() { return (kdu_simple_video_source *) _kref; }
    Ckdu_simple_video_source(kdu_simple_video_source * _existing_kref)
        : Ckdu_compressed_video_source(_existing_kref)
      { return; }
  public:
    Ckdu_simple_video_source();
    Ckdu_simple_video_source(String ^ fname, cli::interior_ptr<Int64> flags);
    Boolean exists();
    void open(String ^ fname, cli::interior_ptr<Int64> flags);
    virtual Boolean close() override;
    virtual Int64 get_timescale() override;
    virtual Int64 get_frame_instant() override;
    virtual Int32 open_image() override;
    virtual void close_image() override;
    virtual Int64 get_frame_period() override;
    virtual Int32 get_capabilities() override;
    virtual Boolean seek(Int64 offset) override;
    virtual Int64 get_pos() override;
    virtual Int32 read(cli::array<Byte> ^buf, Int32 num_bytes) override;
  };
  //---------------------------------------------------
  // Managed Class: Ckdu_simple_video_target
  public ref class Ckdu_simple_video_target : public Ckdu_compressed_video_target {
  protected public:
    kdu_simple_video_target * _get_kref() { return (kdu_simple_video_target *) _kref; }
    Ckdu_simple_video_target(kdu_simple_video_target * _existing_kref)
        : Ckdu_compressed_video_target(_existing_kref)
      { return; }
  public:
    Ckdu_simple_video_target();
    Ckdu_simple_video_target(String ^ fname, Int64 timescale, Int64 frame_period, Int64 flags);
    Boolean exists();
    void open(String ^ fname, Int64 timescale, Int64 frame_period, Int64 flags);
    virtual Boolean close() override;
    virtual void open_image() override;
    virtual Boolean write(cli::array<Byte> ^buf, Int32 num_bytes) override;
    virtual void close_image(Ckdu_codestream ^codestream) override;
  };
  //---------------------------------------------------
  // Managed Class: Cmj2_video_source
  public ref class Cmj2_video_source : public Ckdu_compressed_video_source {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    mj2_video_source * _get_kref() { return (mj2_video_source *) _kref; }
    Cmj2_video_source(mj2_video_source * _existing_kref)
        : Ckdu_compressed_video_source(_existing_kref)
      { return; }
  public:
    Int64 get_track_idx();
    Int16 get_compositing_order();
    Int16 get_graphics_mode(cli::interior_ptr<Int16> op_red, cli::interior_ptr<Int16> op_green, cli::interior_ptr<Int16> op_blue);
    Int16 get_graphics_mode();
    void get_geometry(cli::interior_ptr<Double> presentation_width, cli::interior_ptr<Double> presentation_height, cli::array<Double> ^matrix, Boolean for_movie);
    void get_geometry(cli::interior_ptr<Double> presentation_width, cli::interior_ptr<Double> presentation_height, cli::array<Double> ^matrix);
    void get_cardinal_geometry(Ckdu_dims ^pre_dims, cli::interior_ptr<Boolean> transpose, cli::interior_ptr<Boolean> vflip, cli::interior_ptr<Boolean> hflip, Boolean for_movie);
    void get_cardinal_geometry(Ckdu_dims ^pre_dims, cli::interior_ptr<Boolean> transpose, cli::interior_ptr<Boolean> vflip, cli::interior_ptr<Boolean> hflip);
    Cjp2_dimensions ^access_dimensions();
    Cjp2_resolution ^access_resolution();
    Cjp2_palette ^access_palette();
    Cjp2_channels ^access_channels();
    Cjp2_colour ^access_colour();
    Int32 get_stream_idx(Int32 field_idx);
    virtual Cjp2_input_box ^access_image_box();
    virtual Int32 open_stream(Int32 field_idx, Cjp2_input_box ^input_box, Ckdu_thread_env ^env);
    Int32 open_stream(Int32 field_idx, Cjp2_input_box ^input_box);
    Boolean can_open_stream(Int32 field_idx, Boolean need_main_header);
    Boolean can_open_stream(Int32 field_idx);
    virtual Int64 get_timescale() override;
    virtual Int32 get_field_order() override;
    virtual void set_field_mode(Int32 which) override;
    virtual Int32 get_num_frames() override;
    virtual Boolean seek_to_frame(Int32 frame_idx) override;
    virtual Int64 get_duration() override;
    virtual Int32 time_to_frame(Int64 time_instant) override;
    virtual Int64 get_frame_instant() override;
    virtual Int32 open_image() override;
    virtual void close_image() override;
    virtual Int64 get_frame_period() override;
    virtual Int32 read(cli::array<Byte> ^buf, Int32 num_bytes) override;
    virtual Int32 get_capabilities() override;
    virtual Boolean seek(Int64 offset) override;
    virtual Int64 get_pos() override;
  };
  //---------------------------------------------------
  // Managed Class: Cmj2_video_target
  public ref class Cmj2_video_target : public Ckdu_compressed_video_target {
  protected:
    virtual void Do_dispose(bool in_dispose) override;
  protected public:
    mj2_video_target * _get_kref() { return (mj2_video_target *) _kref; }
    Cmj2_video_target(mj2_video_target * _existing_kref)
        : Ckdu_compressed_video_target(_existing_kref)
      { return; }
  public:
    Int64 get_track_idx();
    void set_compositing_order(Int16 layer_idx);
    void set_graphics_mode(Int16 graphics_mode, Int16 op_red, Int16 op_green, Int16 op_blue);
    void set_graphics_mode(Int16 graphics_mode, Int16 op_red, Int16 op_green);
    void set_graphics_mode(Int16 graphics_mode, Int16 op_red);
    void set_graphics_mode(Int16 graphics_mode);
    Cjp2_colour ^access_colour();
    Cjp2_palette ^access_palette();
    Cjp2_channels ^access_channels();
    Cjp2_resolution ^access_resolution();
    void set_timescale(Int64 ticks_per_second);
    void set_field_order(Int32 order);
    void set_max_frames_per_chunk(Int64 max_frames);
    void set_frame_period(Int64 num_ticks);
    virtual void open_image() override;
    virtual void close_image(Ckdu_codestream ^codestream) override;
    virtual Boolean write(cli::array<Byte> ^buf, Int32 num_bytes) override;
  };
} // End of namespace "kdu_mni"
#endif // KDU_MNI_H
