<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (jpx_meta_manager) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#FFF491">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#FuncS"> functions </A>|</P>
<H1><A NAME="ToP">jpx_meta_manager</A></H1>
<DIR><DIR><H3><U>Java:</U> class Jpx_meta_manager</H3></DIR></DIR>
<DIR><DIR><H3><U>C#:</U> class Cjpx_meta_manager</H3></DIR></DIR>
<DIR><DIR><H3><U>VB:</U> class Cjpx_meta_manager</H3></DIR></DIR>

<P>[Declared in <A HREF="++++apps+c$essed_io+jpx+h.html">"../apps/compressed_io/jpx.h"</A>]</P><P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
This object provides access to the metadata tree managed
by the 
<A HREF="jpx$anode.html">jpx_metanode</A> interface. For a thorough discussion of the structure
and contents of metadata trees, refer to the extensive
comments appearing with 
<A HREF="jpx$anode.html">jpx_metanode</A>. You should review these concepts before trying to
understand the ensuing text. For more information on
the exact box types which are represented by the metadata
tree, see the 
<A HREF="jpx$nager__set$ox_filter.html">set_box_filter</A> function.
</P><P>
 In addition to granting access to the metadata tree,
the present object adds an additional layer of organization
on the metadata, providing efficient access to boxes
of interest and facilitating the creation of files
whose metadata organization is amenable to efficient
access in remote client-server applications.
</P><P>
 This additional layer of organization consists of
a number of linked lists. Each node in the metadata
tree may reside on at most one of these lists, although
some nodes might not reside on any list. These lists
are not apparent to the application, but it is worth
offering some explanation here so that you can appreciate
what is going on. The lists may be divided into three
types, as described below.
</P><P>
 A first type of list serves to link metadata nodes
which are represented by an ROI description box. This
includes leaf nodes which contain an ROI description
box, as well as intermediate nodes whose association
box's first sub-box is an ROI description box. The
common feature of all these nodes is that the corresponding
<A HREF="jpx$anode__get$m_regions.html">jpx_metanode::get_num_regions</A> function returns a non-zero number of image regions.
</P><P>
 There may be many lists of this first type, which
are managed using a scale-space structure. The multi-scale
aspects of the structure are generated by dividing
the relevant nodes, i, on the basis of a dimension
D_i. D_i is the largest dimension of the smallest bounding
box which contains all regions in the ROI description
box.
</P><UL><LI>
The multi-scale structure is based on a collection
of thresholds, T0=0 &lt; T1 &lt; T2 &lt; ... If D_i
lies in the range T(k-1) &lt; D_i &lt;= Tk, then node
i is associated with scale k. The value of T1 is currently
fixed at 8, but there is no need for the application
ever to know what this value is and it might easily
change in the future.
</LI><LI>
Associated with each scale k, is a spatial partition
whose dimensions are proportional to the scale threshold,
Tk. Each element in the partition has its own list,
into which the nodes whose upper left hand corner lies
within that partition are inserted.
</LI><LI>
To further improve access efficiency, the lists within
each scale are further arranged into an hierarchical
structure.
</LI></UL><P>
 The second type of list serves to link all metadata
nodes which are represented by a number list. This
includes leaf nodes which contain a number list box,
intermediate nodes corresponding to association boxes
whose first sub-box is a number list box, and intermediate
nodes which serve to collect metadata found inside
codestream or compositing layer header boxes. The common
feature of all these nodes is that the corresponding
<A HREF="jpx$anode__get$list_info.html">jpx_metanode::get_numlist_info</A> function returns true. There is currently exactly
one of these lists.
</P><P>
 A third type of list manages all nodes are not linked
into or descended from any node which is linked into
either of the list types mentioned above. These nodes
represent metadata which is not associated with any
specific image entity or image region. Such metadata
may be considered to describe properties of the file
itself, rather than its imagery. We do not expect to
encounter too much of this type of metadata, so only
one list is used.
</P><P>
 Note that any node which is associated with a number
list and/or an ROI description box, but which is not
itself a number list or ROI description, will not be
linked into any of the lists.
</P><P>
 The lists described above have no impact on the way
the metadata tree actually appears. They serve only
to improve the efficiency with which searches are made
for metadata associated with a specific image region
or image entity. The relevant searches are facilitated
by the 
<A HREF="jpx$nager__enu$e_matches.html">enumerate_matches</A> function.
</P><P>
 The lists are also used when writing metadata to a
JPX file. The idea is that if the lists tend to improve
the efficiency with which a file's metadata tree can
be searched, then organizing the metadata within each
list into a separate top level group of boxes in the
file will also be beneficial. In particular, this will
help reduce the number of top level boxes whose contents
need to be expanded by a JPIP server when delivering
metadata to a client &mdash; each such box will typically
be represented by a JPIP placeholder box.
</P><P>
 It is worth knowing that Kakadu's JPX file writer
builds these top level groupings by creating association
boxes whose first sub-box is a free box. Since the
contents of a placeholder are associated only with
the first sub-box, and that box has no semantics, this
mechanism serves to create groups without any unintended
semantic overtones.
</P><P>
 It is also worth knowing that some nodes in the metadata
tree may have descendants which reside on different
lists and hence are included in different top level
groups by the Kakadu JPX file writer. Where this happens,
the common boxes must be duplicated, either explicitly
or by reference, which may create some redundancy in
the file.
</P><P>
 Note carefully that objects of the 
<A HREF="jpx$nager.html">jpx_meta_manager</A> class are merely interfaces to an internal object,
which cannot be directly created by an application.
Use 
<A HREF="jpx_target__acc$_manager.html">jpx_target::access_meta_manager</A> or 
<A HREF="jpx_source__acc$_manager.html">jpx_source::access_meta_manager</A> to obtain a non-empty interface.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="FuncS">Public Functions</A></H2><DIV CLASS="indented-text">
<P><A HREF="jpx$nager__jpx$a_manager__1.html">jpx_meta_manager</A> <EM>(2 forms)</EM></P>
<P><A HREF="jpx$nager__exists.html">exists</A> {<U>Java:</U> Exists}
 {<U>C#:</U> exists}
 {<U>VB:</U> exists}
</P>
<P><A HREF="jpx$nager__operator!.html">operator!</A></P>
<P><A HREF="jpx$nager__set$ox_filter.html">set_box_filter</A> {<U>Java:</U> Set_box_filter}
 {<U>C#:</U> set_box_filter}
 {<U>VB:</U> set_box_filter}
</P>
<P><A HREF="jpx$nager__access_root.html">access_root</A> {<U>Java:</U> Access_root}
 {<U>C#:</U> access_root}
 {<U>VB:</U> access_root}
</P>
<P><A HREF="jpx$nager__locate_node.html">locate_node</A> {<U>Java:</U> Locate_node}
 {<U>C#:</U> locate_node}
 {<U>VB:</U> locate_node}
</P>
<P><A HREF="jpx$nager__get$hed_nodes.html">get_touched_nodes</A> {<U>Java:</U> Get_touched_nodes}
 {<U>C#:</U> get_touched_nodes}
 {<U>VB:</U> get_touched_nodes}
</P>
<P><A HREF="jpx$nager__pee$hed_nodes.html">peek_touched_nodes</A> {<U>Java:</U> Peek_touched_nodes}
 {<U>C#:</U> peek_touched_nodes}
 {<U>VB:</U> peek_touched_nodes}
</P>
<P><A HREF="jpx$nager__copy.html">copy</A> {<U>Java:</U> Copy}
 {<U>C#:</U> copy}
 {<U>VB:</U> copy}
</P>
<P><A HREF="jpx$nager__load_matches.html">load_matches</A> {<U>Java:</U> Load_matches}
 {<U>C#:</U> load_matches}
 {<U>VB:</U> load_matches}
</P>
<P><A HREF="jpx$nager__enu$e_matches.html">enumerate_matches</A> {<U>Java:</U> Enumerate_matches}
 {<U>C#:</U> enumerate_matches}
 {<U>VB:</U> enumerate_matches}
</P>
<P><A HREF="jpx$nager__insert_node.html">insert_node</A> {<U>Java:</U> Insert_node}
 {<U>C#:</U> insert_node}
 {<U>VB:</U> insert_node}
</P>
</DIV>
<P ALIGN="CENTER"><HR></P>
<P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#FuncS"> functions </A>|</P>
</BODY>
</HTML>
