<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_serve::generate_increments) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu_serve__pus$xtra_data.html"> prev </A>||<A HREF="kdu_serve__rel$se_chunks.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_serve::generate_increments</A></H1>
<P CLASS="function-text"><A HREF ="kds_chunk.html">kds_chunk</A>&nbsp;* generate_increments(
<B>int</B>&nbsp;suggested_data_bytes,
<B>int</B>&nbsp;&amp;&nbsp;max_data_bytes,
<B>bool</B>&nbsp;align=false,
<B>bool</B>&nbsp;use_extended_message_headers=false,
<B>bool</B>&nbsp;decouple_chunks=true,
<A HREF ="kds$coder.html">kds_id_encoder</A>&nbsp;*&nbsp;id_encoder=NULL)</P>
<P>[Declared in <A HREF="++++apps+k$er+kdu_serve+h.html">"../apps/kdu_server/kdu_serve.h"</A>]</P><P><A HREF="kdu_serve.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
This function returns a linked list of 
<A HREF="kds_chunk.html">kds_chunk</A> objects, representing new elements of the JPEG2000
compressed imagery or metadata which is relevant to
the window most recently passed to 
<A HREF="kdu_serve__set_window.html">set_window</A>. The chunks contain one or more whole JPIP messages,
each of which represents a byte range from one such
element. Possible elements are metadata-bins, precinct
data-bins, code-stream main header data-bins and tile
header data-bins. The object does not currently support
delivery of tile data-bins, which offer substantially
less flexibility. It is possible that some messages
which have previously been generated by this function
will overlap with the new messages, resulting in redundant
transmission by the server application. This may happen
if the 
<A HREF="kdu_serve__tru$che_model__1.html">truncate_cache_model</A> function is used to clear the server's memory of information
it may previously have generated.
</P><P>
 Server applications typically call this function repeatedly,
indicating the total number of data bytes which they
would like to be contained in the returned chunks.
Note carefully, that the 
<A HREF="kdu_serve__gen$ncrements.html#suggested_data_bytes">suggested_data_bytes</A> limit includes only the bodies of the messages contained
in the returned list of 
<A HREF="kds_chunk.html">kds_chunk</A> objects. Messages and their headers are described
by the JPIP standard (currently committee draft, but
will become IS 15444-9).
</P><P>
 Applications will ideally select 
<A HREF="kdu_serve__gen$ncrements.html#suggested_data_bytes">suggested_data_bytes</A> on the basis of their current estimates regarding
the communication bandwidth. If the application attempts
to transfer too much data from the current window to
a remote client, the client's window of interest may
change before the data can be transmitted. On the other
hand, each call to this function can be quite expensive,
so servers will not want to call 
<A HREF="kdu_serve__gen$ncrements.html">generate_increments</A> more frequently than necessary. Ideally, the function
is called only once, between changes in the client's
window of interest, but changes in the client's interests
are not generally predictable in an interactive application.
</P><P>
 Prior to return, the 
<A HREF="kdu_serve.html">kdu_serve</A> object updates its internal cache model, based on
the assumption that all of the chunks will be successfully
transmitted to a client which inserts all relevant
data into its cache. In some cases, the application
may opt not to send some or all of the chunks to a
client. For example, if a remote user changes his/her
window of interest dramatically before all outstanding
chunks have been transmitted, the server application
may choose to abandon some of the chunks. This is acceptable,
so long as the application informs the 
<A HREF="kdu_serve.html">kdu_serve</A> object that it has abandoned these chunks. This may
be done by asserting 
<B>check_abandoned</B>=true in the call to 
<A HREF="kdu_serve__rel$se_chunks.html">release_chunks</A>. In this case, the application is expected to have
marked all of the chunks which were reliably transmitted
by setting their 
<B>abandoned</B> fields to false.
</P><P>
 If the application has used the 
<A HREF="kdu_serve__pus$xtra_data.html">push_extra_data</A> function to push extra data onto the internal extra
data queue (as opposed to pushing it onto the end of
a list of chunks returned by this function), the extra
data will be included in the first chunk returned by
this function, until there is no extra data left. In
this case, it is possible that the present function
will return no compressed image or metadata elements
at all, since the byte limit may be exhausted by the
extra data.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><H2><A NAME="ReturnS">Return Value</A></H2><DIV CLASS="indented-text">
<P>
The function will NEVER return a NULL pointer. If there
is no data available, the function may return a single
chunk, whose 
<B>num_bytes</B> field is set to 0. This ensures that there is always
a non-empty list of data chunks which can be passed
to the 
<A HREF="kdu_serve__pus$xtra_data.html">push_extra_data</A> function, if required.
</P>
</DIV>
<H2><A NAME="ArgS">Arguments</A></H2><DIV CLASS="indented-text">
<H4><A NAME="suggested_data_bytes">suggested_data_bytes</A> [<B>int</B>]</H4><DIV CLASS="indented-text">
<P>
Suggested number of bytes in the bodies of the messages
from which the returned chunks are composed. Each chunk
is a concatenated list of messages, each containing
a header, followed by a body, which consists of a byte
range from a single data-bin (precinct, code-stream
header or metadata-bin). The message headers are not
included in the limit represented by 
<A HREF="kdu_serve__gen$ncrements.html#suggested_data_bytes">suggested_data_bytes</A> or 
<A HREF="kdu_serve__gen$ncrements.html#max_data_bytes">max_data_bytes</A>. The 
<A HREF="kdu_serve__gen$ncrements.html#suggested_data_bytes">suggested_data_bytes</A> limit is not interpreted strictly; instead, the function
tries to include whole packets from as many relevant
precinct data-bins as possible, until the suggested
limit is exceeded. It may thus be exceeded by a considerable
margin if packets are very large.
</P>
</DIV>
<H4><A NAME="max_data_bytes">max_data_bytes</A> [<B>int</B>&nbsp;&amp;]</H4><DIV CLASS="indented-text">
<P>
This argument provides a strict limit on the number
of data bytes which can be included in the bodies of
messages in the returned chunk list. The limit will
not be exceeded unless it is impossible to avoid. This
means that partial packets may be included from the
final precinct data-bin which contributes to the chunk
list. Upon return, the value of this variable is decremented
by the actual number of message body bytes, allowing
the caller to keep track of the number of bytes which
can be generated in a subsequent call to the function,
unless the limit has changed. The only event in which
the limit may be exceeded is if the limit is greater
than 0 but not sufficiently large to allow the inclusion
of a single message.
</P>
</DIV>
<H4><A NAME="align">align</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, each message generated by this function which
crosses a precinct packet boundary will finish at a
subsequent packet boundary. The option has no effect
on messages which correspond to data-bins other than
precinct data-bins.
</P>
</DIV>
<H4><A NAME="use_extended_message_headers">use_extended_message_headers</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true, each message which corresponds to a precinct
data-bin will use the extended header format, which
includes an indication of the number of complete quality
layers represented by the message together with all
bytes from the precinct which precede those in the
message.
</P>
</DIV>
<H4><A NAME="decouple_chunks">decouple_chunks</A> [<B>bool</B>]</H4><DIV CLASS="indented-text">
<P>
If true (this is a reasonable default), the first message
written to each chunk will have its header coded in
a manner which does not rely on successful delivery
of messages in other chunks. Specifically, in this
case the 
<A HREF="kds$coder__decouple.html">id_encoder&rarr;decouple</A> function will be called prior to writing each new
chunk. For applications in which the messages are delivered
over a reliable stream oriented connection, it may
be sufficient to decouple the message header coding
only at the commencement of each response stream sent
by the server (or even once per channel). In such cases,
the application may choose to realize some small efficiency
improvements by setting this argument to false. However,
the application is then responsible for explicitly
invoking the 
<A HREF="kds$coder__decouple.html">id_encoder&rarr;decouple</A> function at appropriate junctures.
</P>
</DIV>
<H4><A NAME="id_encoder">id_encoder</A> [<A HREF ="kds$coder.html">kds_id_encoder</A>&nbsp;*]</H4><DIV CLASS="indented-text">
<P>
Used to supply a custom function for encoding unique
data-bin identifiers. If this argument is NULL, the
default id encoding implementation will be used, as
described in the initial comments appearing with the
<A HREF="kds$coder.html">kds_id_encoder</A> class.
</P>
</DIV>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="#ReturnS"> return value </A>||<A HREF="#ArgS"> arguments </A>||<A HREF="kdu_serve__pus$xtra_data.html"> prev </A>||<A HREF="kdu_serve__rel$se_chunks.html"> next </A>|</P>
</BODY>
</HTML>
