<HTML>
<HEAD>
<TITLE> Kakadu Hyper-Doc (kdu_codestream::destroy) </TITLE>
<STYLE TYPE="text/css">
<!--
.indented-text { padding-left: 20pt; }
.function-text { padding-left: 80pt;
                 text-indent: -60pt; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#B4DCB4">
<P ALIGN="RIGHT">|<A HREF="#SynopsiS"> synopsis </A>||<A HREF="kdu$tream__sha$buffering.html"> prev </A>||<A HREF="kdu$tream__ena$e_restart.html"> next </A>|</P>
<H1><A NAME="ToP">kdu_codestream::destroy</A></H1>
<DIR><DIR><H3><EM><U>Java:</U> Kdu_codestream.Destroy</EM></H3></DIR></DIR>
<DIR><DIR><H3><EM><U>C#:</U> Ckdu_codestream.destroy</EM></H3></DIR></DIR>
<DIR><DIR><H3><EM><U>VB:</U> Ckdu_codestream.destroy</EM></H3></DIR></DIR>
<P CLASS="function-text"><B>void</B> destroy(
)</P>
<DIR><DIR><P CLASS="function-text"><EM><U>Java:</U> public native void Destroy(
)</EM></P></DIR></DIR>
<DIR><DIR><P CLASS="function-text"><EM><U>C#:</U> public void destroy(
)</EM></P></DIR></DIR>
<DIR><DIR><P CLASS="function-text"><EM><U>VB:</U> Public Sub destroy(
) </EM></P></DIR></DIR>
<P>[Declared in <A HREF="++++coresy$u_compressed+h.html">"../coresys/common/kdu_compressed.h"</A>]</P><P><A HREF="kdu$tream.html">Go to class description.</A></P>

<P ALIGN="CENTER"><HR></P><H2><A NAME="SynopsiS">Synopsis</A></H2>
<DIV CLASS="indented-text">
<P>
Providing an explicit destructor for 
<A HREF="kdu$tream.html">kdu_codestream</A> is dangerous, since it is merely a container for a
hidden reference to the internal code-stream mangement
machinery. The interpretation of copying should be
(and is) that of generating another reference, so the
underlying object should not be destroyed when the
copy goes out of scope. Reference counting would be
an elegant, though tedious and less explicit way of
avoiding this difficulty.
</P><P>
 Destroys the internal code-stream management machinery,
along with all tiles, tile-components and other subordinate
state information for which interfaces are described
in this header.
</P><P>
 When you invoke this function within a multi-threaded
environment, based around 
<A HREF="kdu$d_env.html">kdu_thread_env</A>, you need to be careful that no processing is taking
place within the codestream on other threads. To this
end, you will normally invoke 
<B>kdu_thread_env::terminate</B> to terminate any processing on thread queues which
are associated with the codestream in question. An
agressive way to do this is to completely close down
(i.e., destroy) a 
<A HREF="kdu$d_env.html">kdu_thread_env</A> environment before destroying codestreams, but this
is not necessary. In fact, from version 6.0 on, it
should be perfectly safe to have ongoing multi-threaded
processing progressing in the background on other codestreams,
while you destroy one for which processing has terminated.
</P><P>
 You do, however, need to make sure that if any thread
queue remains unterminated when you call this function,
the thread from which the function is called must belong
to the same 
<A HREF="kdu$d_env.html">kdu_thread_env</A> environment (the same thread group created by calls
to 
<A HREF="kdu$ntity__create.html">kdu_thread_entity::create</A> and 
<A HREF="kdu$ntity__add_thread.html">kdu_thread_entity::add_thread</A>). This should not present any difficulty in practice,
since it is normally thread group owners who destroy
codestreams.
</P>
</DIV>

<P ALIGN="CENTER"><HR></P><P ALIGN="RIGHT">|<A HREF="#ToP"> top </A>||<A HREF="#SynopsiS"> synopsis </A>||<A HREF="kdu$tream__sha$buffering.html"> prev </A>||<A HREF="kdu$tream__ena$e_restart.html"> next </A>|</P>
</BODY>
</HTML>
