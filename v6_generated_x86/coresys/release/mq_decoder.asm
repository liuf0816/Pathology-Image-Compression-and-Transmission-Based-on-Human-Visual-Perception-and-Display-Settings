; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\coding\mq_decoder.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?p_bar_table@mq_decoder@@2PAHA			; mq_decoder::p_bar_table
PUBLIC	?transition_table@mq_decoder@@2PAUmqd_transition@@A ; mq_decoder::transition_table
_BSS	SEGMENT
?transition_table@mq_decoder@@2PAUmqd_transition@@A DB 05e0H DUP (?) ; mq_decoder::transition_table
_BSS	ENDS
_DATA	SEGMENT
?p_bar_table@mq_decoder@@2PAHA DD 05601H		; mq_decoder::p_bar_table
	DD	03401H
	DD	01801H
	DD	0ac1H
	DD	0521H
	DD	0221H
	DD	05601H
	DD	05401H
	DD	04801H
	DD	03801H
	DD	03001H
	DD	02401H
	DD	01c01H
	DD	01601H
	DD	05601H
	DD	05401H
	DD	05101H
	DD	04801H
	DD	03801H
	DD	03401H
	DD	03001H
	DD	02801H
	DD	02401H
	DD	02201H
	DD	01c01H
	DD	01801H
	DD	01601H
	DD	01401H
	DD	01201H
	DD	01101H
	DD	0ac1H
	DD	09c1H
	DD	08a1H
	DD	0521H
	DD	0441H
	DD	02a1H
	DD	0221H
	DD	0141H
	DD	0111H
	DD	085H
	DD	049H
	DD	025H
	DD	015H
	DD	09H
	DD	05H
	DD	01H
	DD	05601H
_DATA	ENDS
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	?start@mq_decoder@@QAEXPAEH_N@Z			; mq_decoder::start
PUBLIC	?finish@mq_decoder@@QAE_N_N@Z			; mq_decoder::finish
PUBLIC	?mq_decode@mq_decoder@@QAEXAAHAAUmqd_state@@@Z	; mq_decoder::mq_decode
PUBLIC	?mq_decode_run@mq_decoder@@QAEXAAH@Z		; mq_decoder::mq_decode_run
PUBLIC	?raw_decode@mq_decoder@@QAEXAAH@Z		; mq_decoder::raw_decode
PUBLIC	?fill_lsbs@mq_decoder@@AAEXXZ			; mq_decoder::fill_lsbs
PUBLIC	__xmm@00000003000000020000000100000000
PUBLIC	__xmm@00000004000000030000000200000001
PUBLIC	__xmm@00000008000000070000002600000005
PUBLIC	__xmm@0000000c000000090000000600000001
PUBLIC	__xmm@0000000c0000000b0000000a00000009
PUBLIC	__xmm@0000000e00000006000000210000001d
PUBLIC	__xmm@0000000e0000000e0000001500000014
PUBLIC	__xmm@0000000f0000000f0000000f0000000f
PUBLIC	__xmm@00000012000000110000000e0000000e
PUBLIC	__xmm@0000001200000011000000100000000f
PUBLIC	__xmm@00000013000000130000001300000013
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?_do_it@@3Vmq_decoder_local_init@@A DB 01H DUP (?)	; _do_it
_BSS	ENDS
CRT$XCU	SEGMENT
?_do_it$initializer$@@3P6AXXZA DD FLAT:??__E_do_it@@YAXXZ ; _do_it$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@00000013000000130000001300000013
CONST	SEGMENT
__xmm@00000013000000130000001300000013 DB 013H, 00H, 00H, 00H, 013H, 00H, 00H
	DB	00H, 013H, 00H, 00H, 00H, 013H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000001200000011000000100000000f
CONST	SEGMENT
__xmm@0000001200000011000000100000000f DB 0fH, 00H, 00H, 00H, 010H, 00H, 00H
	DB	00H, 011H, 00H, 00H, 00H, 012H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000012000000110000000e0000000e
CONST	SEGMENT
__xmm@00000012000000110000000e0000000e DB 0eH, 00H, 00H, 00H, 0eH, 00H, 00H
	DB	00H, 011H, 00H, 00H, 00H, 012H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000f0000000f0000000f0000000f
CONST	SEGMENT
__xmm@0000000f0000000f0000000f0000000f DB 0fH, 00H, 00H, 00H, 0fH, 00H, 00H
	DB	00H, 0fH, 00H, 00H, 00H, 0fH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000e0000000e0000001500000014
CONST	SEGMENT
__xmm@0000000e0000000e0000001500000014 DB 014H, 00H, 00H, 00H, 015H, 00H, 00H
	DB	00H, 0eH, 00H, 00H, 00H, 0eH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000e00000006000000210000001d
CONST	SEGMENT
__xmm@0000000e00000006000000210000001d DB 01dH, 00H, 00H, 00H, '!', 00H, 00H
	DB	00H, 06H, 00H, 00H, 00H, 0eH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000c0000000b0000000a00000009
CONST	SEGMENT
__xmm@0000000c0000000b0000000a00000009 DB 09H, 00H, 00H, 00H, 0aH, 00H, 00H
	DB	00H, 0bH, 00H, 00H, 00H, 0cH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000c000000090000000600000001
CONST	SEGMENT
__xmm@0000000c000000090000000600000001 DB 01H, 00H, 00H, 00H, 06H, 00H, 00H
	DB	00H, 09H, 00H, 00H, 00H, 0cH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000008000000070000002600000005
CONST	SEGMENT
__xmm@00000008000000070000002600000005 DB 05H, 00H, 00H, 00H, '&', 00H, 00H
	DB	00H, 07H, 00H, 00H, 00H, 08H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000004000000030000000200000001
CONST	SEGMENT
__xmm@00000004000000030000000200000001 DB 01H, 00H, 00H, 00H, 02H, 00H, 00H
	DB	00H, 03H, 00H, 00H, 00H, 04H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000003000000020000000100000000
CONST	SEGMENT
__xmm@00000003000000020000000100000000 DB 00H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 02H, 00H, 00H, 00H, 03H, 00H, 00H, 00H
CONST	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
;	COMDAT ??__E_do_it@@YAXXZ
text$di	SEGMENT
??__E_do_it@@YAXXZ PROC					; `dynamic initializer for '_do_it'', COMDAT

; 68   :               { initialize_transition_table(); }

	jmp	?initialize_transition_table@@YAXXZ	; initialize_transition_table
??__E_do_it@@YAXXZ ENDP					; `dynamic initializer for '_do_it''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
;	COMDAT ??0mq_decoder_local_init@@QAE@XZ
_TEXT	SEGMENT
??0mq_decoder_local_init@@QAE@XZ PROC			; mq_decoder_local_init::mq_decoder_local_init, COMDAT
; _this$ = ecx

; 67   :     public: mq_decoder_local_init()

	push	esi
	mov	esi, ecx

; 68   :               { initialize_transition_table(); }

	call	?initialize_transition_table@@YAXXZ	; initialize_transition_table
	mov	eax, esi
	pop	esi
	ret	0
??0mq_decoder_local_init@@QAE@XZ ENDP			; mq_decoder_local_init::mq_decoder_local_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
;	COMDAT ?initialize_transition_table@@YAXXZ
_TEXT	SEGMENT
_Sigma_lps$ = -380					; size = 188
_Sigma_mps$ = -192					; size = 188
__$ArrayPad$ = -4					; size = 4
?initialize_transition_table@@YAXXZ PROC		; initialize_transition_table, COMDAT

; 77   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 380				; 0000017cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000030000000200000001

; 78   :   int Sigma_mps[47] =
; 79   :     { 1, 2, 3, 4, 5,38, 7, 8, 9,10,11,12,13,29,15,16,17,18,19,20,21,22,23,24,

	lea	edx, DWORD PTR _Sigma_mps$[ebp+72]
	movaps	xmm1, XMMWORD PTR __xmm@00000003000000020000000100000000
	xor	ecx, ecx
	movaps	xmm2, XMMWORD PTR __xmm@0000000f0000000f0000000f0000000f
	movups	XMMWORD PTR _Sigma_mps$[ebp], xmm0
	mov	DWORD PTR _Sigma_mps$[ebp+48], 13	; 0000000dH
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000070000002600000005
	movups	XMMWORD PTR _Sigma_mps$[ebp+16], xmm0
	mov	DWORD PTR _Sigma_mps$[ebp+52], 29	; 0000001dH
	movaps	xmm0, XMMWORD PTR __xmm@0000000c0000000b0000000a00000009
	movups	XMMWORD PTR _Sigma_mps$[ebp+32], xmm0
$LL13@initialize:
	movd	xmm0, ecx
	lea	eax, DWORD PTR [ecx+4]
	pshufd	xmm0, xmm0, 0
	lea	edx, DWORD PTR [edx+32]
	paddd	xmm0, xmm1
	add	ecx, 8
	paddd	xmm0, xmm2
	movups	XMMWORD PTR [edx-48], xmm0
	movd	xmm0, eax
	pshufd	xmm0, xmm0, 0
	paddd	xmm0, xmm1
	paddd	xmm0, xmm2
	movups	XMMWORD PTR [edx-32], xmm0
	cmp	ecx, 24					; 00000018H
	jl	SHORT $LL13@initialize
	cmp	ecx, 31					; 0000001fH
	jge	SHORT $LN14@initialize
	lea	eax, DWORD PTR [ecx+15]
	lea	ecx, DWORD PTR _Sigma_mps$[ebp+ecx*4+56]
	npad	5
$LL20@initialize:
	mov	DWORD PTR [ecx], eax
	lea	ecx, DWORD PTR [ecx+4]
	inc	eax
	cmp	eax, 46					; 0000002eH
	jl	SHORT $LL20@initialize
$LN14@initialize:
	movaps	xmm0, XMMWORD PTR __xmm@0000000c000000090000000600000001

; 80   :      25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,45,46};

	lea	edx, DWORD PTR _Sigma_lps$[ebp+100]
	movaps	xmm2, XMMWORD PTR __xmm@00000013000000130000001300000013

; 81   :   int Sigma_lps[47] =
; 82   :     { 1, 6, 9,12,29,33, 6,14,14,14,17,18,20,21,14,14,15,16,17,18,19,19,20,21,

	xor	ecx, ecx
	movups	XMMWORD PTR _Sigma_lps$[ebp], xmm0
	mov	DWORD PTR _Sigma_mps$[ebp+180], 45	; 0000002dH
	movaps	xmm0, XMMWORD PTR __xmm@0000000e00000006000000210000001d
	movups	XMMWORD PTR _Sigma_lps$[ebp+16], xmm0
	mov	DWORD PTR _Sigma_mps$[ebp+184], 46	; 0000002eH
	movaps	xmm0, XMMWORD PTR __xmm@00000012000000110000000e0000000e
	movups	XMMWORD PTR _Sigma_lps$[ebp+32], xmm0
	mov	DWORD PTR _Sigma_lps$[ebp+80], 19	; 00000013H
	movaps	xmm0, XMMWORD PTR __xmm@0000000e0000000e0000001500000014
	movups	XMMWORD PTR _Sigma_lps$[ebp+48], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@0000001200000011000000100000000f
	movups	XMMWORD PTR _Sigma_lps$[ebp+64], xmm0
	npad	8
$LL15@initialize:
	movd	xmm0, ecx
	lea	eax, DWORD PTR [ecx+4]
	pshufd	xmm0, xmm0, 0
	lea	edx, DWORD PTR [edx+32]
	paddd	xmm0, xmm1
	add	ecx, 8
	paddd	xmm0, xmm2
	movups	XMMWORD PTR [edx-48], xmm0
	movd	xmm0, eax
	pshufd	xmm0, xmm0, 0
	paddd	xmm0, xmm1
	paddd	xmm0, xmm2
	movups	XMMWORD PTR [edx-32], xmm0
	cmp	ecx, 24					; 00000018H
	jl	SHORT $LL15@initialize
	cmp	ecx, 25					; 00000019H
	jge	SHORT $LN16@initialize
	lea	eax, DWORD PTR [ecx+19]
	lea	ecx, DWORD PTR _Sigma_lps$[ebp+ecx*4+84]
$LL22@initialize:
	mov	DWORD PTR [ecx], eax
	lea	ecx, DWORD PTR [ecx+4]
	inc	eax
	cmp	eax, 44					; 0000002cH
	jl	SHORT $LL22@initialize
$LN16@initialize:
	push	ebx
	push	esi
	push	edi

; 83   :      22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,46};

	mov	DWORD PTR _Sigma_lps$[ebp+184], 46	; 0000002eH

; 85   :   for (kdu_int32 n=0; n < 94; n++)

	xor	edi, edi
	mov	edx, OFFSET ?transition_table@mq_decoder@@2PAUmqd_transition@@A+12
$LL4@initialize:

; 86   :     {
; 87   :       kdu_int32 s, new_s;
; 88   :       int Sigma, new_Sigma;
; 89   : 
; 90   :       s = n & 1;
; 91   :       Sigma = n >> 1;

	mov	ebx, edi
	mov	esi, edi
	sar	ebx, 1
	and	esi, 1

; 92   : 
; 93   :       // Build MPS transition state first.
; 94   :       new_Sigma = Sigma_mps[Sigma];

	mov	ecx, DWORD PTR _Sigma_mps$[ebp+ebx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 201  :   p_bar_mps = (mq_decoder::p_bar_table[Sigma] << 8) + s;

	mov	eax, DWORD PTR ?p_bar_table@mq_decoder@@2PAHA[ecx*4]
	shl	eax, 8
	add	eax, esi
	mov	DWORD PTR [edx-12], eax

; 202  :   transition = mq_decoder::transition_table + ((Sigma<<1) + s);

	lea	eax, DWORD PTR [esi+ecx*2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp

; 98   :       new_Sigma = Sigma_lps[Sigma];

	mov	ecx, DWORD PTR _Sigma_lps$[ebp+ebx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 202  :   transition = mq_decoder::transition_table + ((Sigma<<1) + s);

	shl	eax, 4
	add	eax, OFFSET ?transition_table@mq_decoder@@2PAUmqd_transition@@A
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp

; 100  :       if ((mq_decoder::p_bar_table[Sigma] == 0x5601) && (Sigma != 46))

	cmp	DWORD PTR ?p_bar_table@mq_decoder@@2PAHA[ebx*4], 22017 ; 00005601H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 202  :   transition = mq_decoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR [edx-8], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp

; 100  :       if ((mq_decoder::p_bar_table[Sigma] == 0x5601) && (Sigma != 46))

	jne	SHORT $LN5@initialize
	cmp	ebx, 46					; 0000002eH
	je	SHORT $LN5@initialize

; 101  :         new_s = 1-s;

	mov	eax, 1
	sub	eax, esi
	mov	esi, eax
$LN5@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 201  :   p_bar_mps = (mq_decoder::p_bar_table[Sigma] << 8) + s;

	mov	eax, DWORD PTR ?p_bar_table@mq_decoder@@2PAHA[ecx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp

; 85   :   for (kdu_int32 n=0; n < 94; n++)

	inc	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 201  :   p_bar_mps = (mq_decoder::p_bar_table[Sigma] << 8) + s;

	shl	eax, 8
	add	eax, esi
	mov	DWORD PTR [edx-4], eax

; 202  :   transition = mq_decoder::transition_table + ((Sigma<<1) + s);

	lea	eax, DWORD PTR [esi+ecx*2]
	shl	eax, 4
	add	eax, OFFSET ?transition_table@mq_decoder@@2PAUmqd_transition@@A
	mov	DWORD PTR [edx], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp

; 85   :   for (kdu_int32 n=0; n < 94; n++)

	add	edx, 16					; 00000010H
	cmp	edx, OFFSET ?transition_table@mq_decoder@@2PAUmqd_transition@@A+1516
	jl	SHORT $LL4@initialize

; 102  :       mq_decoder::transition_table[n].lps.init(new_Sigma,new_s);
; 103  :     }
; 104  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?initialize_transition_table@@YAXXZ ENDP		; initialize_transition_table
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
;	COMDAT ?fill_lsbs@mq_decoder@@AAEXXZ
_TEXT	SEGMENT
?fill_lsbs@mq_decoder@@AAEXXZ PROC			; mq_decoder::fill_lsbs, COMDAT
; _this$ = ecx

; 191  : {

	push	esi
	mov	esi, ecx

; 192  :   if (temp == 0xFF)

	cmp	DWORD PTR [esi+12], 255			; 000000ffH
	jne	SHORT $LN2@fill_lsbs

; 193  :     { // Need to check for termination
; 194  :       temp = *(buf_next++);

	mov	edx, DWORD PTR [esi+20]
	movzx	eax, BYTE PTR [edx]
	inc	edx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+20], edx

; 195  :       if (temp > 0x8F)

	cmp	eax, 143				; 0000008fH
	jle	SHORT $LN4@fill_lsbs

; 196  :         { // Termination marker found.
; 197  :           temp = 0xFF;
; 198  :           buf_next--;
; 199  :           t = 8;
; 200  :           S++; // Increment S for each synthesized FF after 1'st byte of marker

	inc	DWORD PTR [esi+24]
	lea	eax, DWORD PTR [edx-1]
	mov	DWORD PTR [esi+12], 255			; 000000ffH

; 206  :         }
; 207  :     }
; 208  :   else
; 209  :     {
; 210  :       temp = *(buf_next++);

	mov	DWORD PTR [esi+20], eax

; 211  :       t = 8;
; 212  :     }
; 213  :   C += temp;

	mov	eax, DWORD PTR [esi+12]
	add	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], 8
	pop	esi

; 214  : }

	ret	0
$LN4@fill_lsbs:

; 201  :         }
; 202  :       else
; 203  :         { // Bit stuff found
; 204  :           temp <<= 1;

	add	eax, eax

; 205  :           t = 7;

	mov	DWORD PTR [esi+8], 7

; 211  :       t = 8;
; 212  :     }
; 213  :   C += temp;

	add	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 214  : }

	ret	0
$LN2@fill_lsbs:

; 206  :         }
; 207  :     }
; 208  :   else
; 209  :     {
; 210  :       temp = *(buf_next++);

	mov	ecx, DWORD PTR [esi+20]
	movzx	eax, BYTE PTR [ecx]
	mov	DWORD PTR [esi+12], eax
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+20], eax

; 211  :       t = 8;
; 212  :     }
; 213  :   C += temp;

	mov	eax, DWORD PTR [esi+12]
	add	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], 8
	pop	esi

; 214  : }

	ret	0
?fill_lsbs@mq_decoder@@AAEXXZ ENDP			; mq_decoder::fill_lsbs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
;	COMDAT ?raw_decode@mq_decoder@@QAEXAAH@Z
_TEXT	SEGMENT
_symbol$ = 8						; size = 4
?raw_decode@mq_decoder@@QAEXAAH@Z PROC			; mq_decoder::raw_decode, COMDAT
; _this$ = ecx

; 295  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 296  :   assert((!MQ_segment) && active && !checked_out);
; 297  : 
; 298  :   if (t == 0)

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN4@raw_decode

; 299  :     {
; 300  :       if (temp == 0xFF)
; 301  :         { // Need to check for terminating marker.
; 302  :           temp = *(buf_next++);

	mov	ecx, DWORD PTR [esi+20]
	cmp	DWORD PTR [esi+12], 255			; 000000ffH
	movzx	eax, BYTE PTR [ecx]
	mov	DWORD PTR [esi+12], eax
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+20], eax
	jne	SHORT $LN3@raw_decode

; 303  :           if (temp > 0x8F)

	cmp	DWORD PTR [esi+12], 143			; 0000008fH
	jle	SHORT $LN5@raw_decode

; 304  :             { temp = 0xFF; buf_next--; t = 8; }

	dec	eax
	mov	DWORD PTR [esi+12], 255			; 000000ffH
	mov	DWORD PTR [esi+20], eax
$LN3@raw_decode:

; 309  :         { temp = *(buf_next++); t = 8; }

	mov	DWORD PTR [esi+8], 8
$LN4@raw_decode:

; 310  :     }
; 311  :   t--;

	dec	DWORD PTR [esi+8]

; 312  :   symbol = (temp>>t)&1;

	mov	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _symbol$[ebp]
	sar	edx, cl
	and	edx, 1
	pop	esi
	mov	DWORD PTR [eax], edx

; 313  : }

	pop	ebp
	ret	4
$LN5@raw_decode:

; 305  :           else
; 306  :             t = 7;

	mov	DWORD PTR [esi+8], 7

; 307  :         }
; 308  :       else

	jmp	SHORT $LN4@raw_decode
?raw_decode@mq_decoder@@QAEXAAH@Z ENDP			; mq_decoder::raw_decode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
;	COMDAT ?mq_decode_run@mq_decoder@@QAEXAAH@Z
_TEXT	SEGMENT
_state$ = -12						; size = 8
_symbol$ = -4						; size = 4
_run$ = 8						; size = 4
?mq_decode_run@mq_decoder@@QAEXAAH@Z PROC		; mq_decoder::mq_decode_run, COMDAT
; _this$ = ecx

; 279  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 201  :   p_bar_mps = (mq_decoder::p_bar_table[Sigma] << 8) + s;

	mov	eax, DWORD PTR ?p_bar_table@mq_decoder@@2PAHA+184
	shl	eax, 8
	push	esi
	push	edi
	mov	DWORD PTR _state$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp

; 279  : {

	mov	edi, ecx

; 283  :   mq_decode(symbol,state);

	lea	eax, DWORD PTR _state$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 202  :   transition = mq_decoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR _state$[ebp+4], OFFSET ?transition_table@mq_decoder@@2PAUmqd_transition@@A+1472
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp

; 283  :   mq_decode(symbol,state);

	push	eax
	lea	eax, DWORD PTR _symbol$[ebp]
	push	eax
	call	?mq_decode@mq_decoder@@QAEXAAHAAUmqd_state@@@Z ; mq_decoder::mq_decode

; 284  :   run = symbol + symbol;

	mov	eax, DWORD PTR _symbol$[ebp]

; 285  :   mq_decode(symbol,state);

	mov	ecx, edi
	mov	esi, DWORD PTR _run$[ebp]
	add	eax, eax
	mov	DWORD PTR [esi], eax
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	lea	eax, DWORD PTR _symbol$[ebp]
	push	eax
	call	?mq_decode@mq_decoder@@QAEXAAHAAUmqd_state@@@Z ; mq_decoder::mq_decode

; 286  :   run += symbol;

	mov	eax, DWORD PTR _symbol$[ebp]
	add	DWORD PTR [esi], eax
	pop	edi
	pop	esi

; 287  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?mq_decode_run@mq_decoder@@QAEXAAH@Z ENDP		; mq_decoder::mq_decode_run
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
;	COMDAT ?mq_decode@mq_decoder@@QAEXAAHAAUmqd_state@@@Z
_TEXT	SEGMENT
_symbol$ = 8						; size = 4
_state$ = 12						; size = 4
?mq_decode@mq_decoder@@QAEXAAHAAUmqd_state@@@Z PROC	; mq_decoder::mq_decode, COMDAT
; _this$ = ecx

; 226  : {

	push	ebp
	mov	ebp, esp

; 227  :   assert(MQ_segment && active && !checked_out);
; 228  : 
; 229  :   symbol = state.p_bar_mps & 1; // Set to MPS for now.

	mov	edx, DWORD PTR _state$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _symbol$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 1
	push	edi
	mov	DWORD PTR [ecx], eax

; 230  :   kdu_int32 shifted_p_bar = state.p_bar_mps - symbol;

	mov	edi, DWORD PTR [edx]

; 231  :   A -= shifted_p_bar;
; 232  :   if (C >= shifted_p_bar)

	mov	ebx, DWORD PTR [esi+4]
	sub	edi, eax
	mov	eax, DWORD PTR [esi]
	sub	eax, edi
	mov	DWORD PTR [esi], eax
	cmp	ebx, edi
	jl	SHORT $LN8@mq_decode

; 233  :     { // Upper sub-interval selected
; 234  :       C -= shifted_p_bar;

	sub	ebx, edi
	mov	DWORD PTR [esi+4], ebx

; 235  :       if (A < MQD_A_MIN)

	cmp	eax, 8388608				; 00800000H
	jge	$LN6@mq_decode

; 236  :         { // Need renormalization and perhaps conditional exchange
; 237  :           if (A < shifted_p_bar)

	cmp	eax, edi
	jge	SHORT $LN11@mq_decode

; 238  :             { // Conditional exchange; LPS decoded
; 239  :               symbol = 1-symbol;

	mov	eax, 1
	sub	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], eax

; 240  :               state = state.transition->lps;

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+12]

; 241  :             }
; 242  :           else

	jmp	SHORT $LN30@mq_decode
$LN11@mq_decode:

; 243  :             { // MPS decoded
; 244  :               state = state.transition->mps;

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
$LN30@mq_decode:
	mov	DWORD PTR [edx+4], eax
	npad	3
$LL4@mq_decode:

; 245  :             }
; 246  :           do {
; 247  :               if (t == 0)

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN13@mq_decode

; 248  :                 fill_lsbs();

	mov	ecx, esi
	call	?fill_lsbs@mq_decoder@@AAEXXZ		; mq_decoder::fill_lsbs
$LN13@mq_decode:

; 249  :               A += A; C += C; t--;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	add	ecx, ecx
	dec	DWORD PTR [esi+8]
	add	eax, eax
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], eax

; 250  :             } while (A < MQD_A_MIN);

	cmp	ecx, 8388608				; 00800000H
	jl	SHORT $LL4@mq_decode
	pop	edi
	pop	esi
	pop	ebx

; 270  :     }
; 271  : }

	pop	ebp
	ret	8
$LN8@mq_decode:

; 251  :         }
; 252  :     }
; 253  :   else
; 254  :     { // Lower sub-interval selected; renormalization is inevitable
; 255  :       if (A < shifted_p_bar)

	cmp	eax, edi
	jge	SHORT $LN14@mq_decode

; 256  :         { // Conditional exchange; MPS decoded
; 257  :           state = state.transition->mps;

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]

; 258  :         }
; 259  :       else

	jmp	SHORT $LN31@mq_decode
$LN14@mq_decode:

; 260  :         { // LPS decoded
; 261  :           symbol = 1-symbol;

	mov	eax, 1
	sub	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], eax

; 262  :           state = state.transition->lps;

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+12]
$LN31@mq_decode:
	mov	DWORD PTR [edx+4], eax

; 263  :         }
; 264  :       A = shifted_p_bar;

	mov	DWORD PTR [esi], edi
$LL7@mq_decode:

; 265  :       do {
; 266  :           if (t == 0)

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN16@mq_decode

; 267  :             fill_lsbs();

	mov	ecx, esi
	call	?fill_lsbs@mq_decoder@@AAEXXZ		; mq_decoder::fill_lsbs
$LN16@mq_decode:

; 268  :           A += A; C += C; t--;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	add	ecx, ecx
	dec	DWORD PTR [esi+8]
	add	eax, eax
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], eax

; 269  :         } while (A < MQD_A_MIN);

	cmp	ecx, 8388608				; 00800000H
	jl	SHORT $LL7@mq_decode
$LN6@mq_decode:
	pop	edi
	pop	esi
	pop	ebx

; 270  :     }
; 271  : }

	pop	ebp
	ret	8
?mq_decode@mq_decoder@@QAEXAAHAAUmqd_state@@@Z ENDP	; mq_decoder::mq_decode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
;	COMDAT ?finish@mq_decoder@@QAE_N_N@Z
_TEXT	SEGMENT
_check_erterm$ = 8					; size = 1
?finish@mq_decoder@@QAE_N_N@Z PROC			; mq_decoder::finish, COMDAT
; _this$ = ecx

; 147  : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 148  :   bool failure = false;

	xor	bl, bl
	push	esi
	mov	esi, ecx

; 149  : 
; 150  :   assert(active && !checked_out);
; 151  :   if (check_erterm && MQ_segment)

	cmp	BYTE PTR _check_erterm$[ebp], bl
	je	$LN11@finish
	cmp	BYTE PTR [esi+29], bl
	je	SHORT $LN2@finish

; 152  :     { // Check correct termination of MQ segment.
; 153  :       if (buf_next <= (buf_start+segment_length))

	mov	eax, DWORD PTR [esi+32]
	add	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [esi+20], eax
	jbe	SHORT $LN8@finish

; 154  :         failure = true; // We never read the terminating marker code
; 155  :       else
; 156  :         {
; 157  :           assert(buf_next == (buf_start+segment_length+1));
; 158  :           S++; // Include first FF of marker code as a synthesized FF.

	inc	DWORD PTR [esi+24]

; 159  :           if (t == 0)

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN6@finish

; 160  :             { S++; t = 8; }

	inc	DWORD PTR [esi+24]
	mov	DWORD PTR [esi+8], 8
$LN6@finish:

; 161  :           if ((S < 2) || (S > 3) || ((C>>(24-t)) != 0))

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, 2
	jl	SHORT $LN8@finish
	cmp	eax, 3
	jg	SHORT $LN8@finish
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, 24					; 00000018H
	sub	ecx, DWORD PTR [esi+8]
	sar	eax, cl
	test	eax, eax
	je	SHORT $LN11@finish
$LN8@finish:

; 162  :             failure = true;

	mov	bl, 1

; 163  :         }

	jmp	SHORT $LN11@finish
$LN2@finish:

; 164  :     }
; 165  :   else if (check_erterm)
; 166  :     { // Check correct termination of raw segment.
; 167  :       kdu_int32 x = 0x55;
; 168  :       if ((buf_next < (buf_start+segment_length)) &&
; 169  :           (temp == 0xFF) && (t == 0))

	mov	edx, DWORD PTR [esi+32]
	add	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+20]
	push	edi
	mov	edi, 85					; 00000055H
	cmp	ecx, edx
	jae	SHORT $LN10@finish
	cmp	DWORD PTR [esi+12], 255			; 000000ffH
	jne	SHORT $LN10@finish
	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN10@finish

; 170  :         { // Last byte may have been created by bit stuff.
; 171  :           temp = *(buf_next++); t = 8; x = 0x2A;

	movzx	eax, BYTE PTR [ecx]
	mov	edi, 42					; 0000002aH
	mov	DWORD PTR [esi+12], eax
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+8], 8
$LN10@finish:

; 172  :         }
; 173  :       if ((buf_next != (buf_start+segment_length)) ||

	cmp	DWORD PTR [esi+20], edx
	jne	SHORT $LN12@finish
	mov	ecx, DWORD PTR [esi+8]
	or	edx, -1
	shl	edx, cl
	mov	ecx, 8
	sub	ecx, DWORD PTR [esi+8]
	not	edx
	and	edx, DWORD PTR [esi+12]
	sar	edi, cl
	cmp	edx, edi
	je	SHORT $LN14@finish
$LN12@finish:

; 174  :           ((temp & ~((-1)<<t)) != (x>>(8-t))))
; 175  :         failure = true;

	mov	bl, 1
$LN14@finish:
	pop	edi
$LN11@finish:

; 176  :     }
; 177  : 
; 178  :   buf_start[segment_length] = overwritten_bytes[0];

	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+32]
	movzx	eax, BYTE PTR [esi+36]
	mov	BYTE PTR [edx+ecx], al

; 179  :   buf_start[segment_length+1] = overwritten_bytes[1];

	mov	edx, DWORD PTR [esi+16]
	movzx	eax, BYTE PTR [esi+37]
	mov	ecx, DWORD PTR [esi+32]
	mov	BYTE PTR [edx+ecx+1], al

; 180  :   active = false;
; 181  :   buf_start = buf_next = NULL;
; 182  :   return !failure;

	xor	eax, eax
	test	bl, bl
	mov	BYTE PTR [esi+30], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+16], 0
	sete	al
	pop	esi
	pop	ebx

; 183  : }

	pop	ebp
	ret	4
?finish@mq_decoder@@QAE_N_N@Z ENDP			; mq_decoder::finish
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.cpp
;	COMDAT ?start@mq_decoder@@QAEXPAEH_N@Z
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_segment_length$ = 12					; size = 4
_MQ_segment$ = 16					; size = 1
?start@mq_decoder@@QAEXPAEH_N@Z PROC			; mq_decoder::start, COMDAT
; _this$ = ecx

; 112  : {

	push	ebp
	mov	ebp, esp

; 113  :   assert(!active);
; 114  :   assert(buf_start == NULL);
; 115  :   assert((buffer != NULL) && (segment_length >= 0));
; 116  :   active = true;
; 117  :   this->MQ_segment = MQ_segment;
; 118  :   buf_start = buf_next = buffer;

	mov	edx, DWORD PTR _buffer$[ebp]

; 119  :   this->segment_length = segment_length;

	mov	eax, DWORD PTR _segment_length$[ebp]
	push	ebx
	mov	bl, BYTE PTR _MQ_segment$[ebp]
	push	esi
	mov	esi, ecx

; 120  :   overwritten_bytes[0] = buffer[segment_length];

	lea	ecx, DWORD PTR [edx+eax]
	mov	BYTE PTR [esi+30], 1
	mov	BYTE PTR [esi+29], bl
	mov	DWORD PTR [esi+20], edx
	mov	DWORD PTR [esi+16], edx
	mov	DWORD PTR [esi+32], eax
	movzx	eax, BYTE PTR [ecx]
	mov	BYTE PTR [esi+36], al

; 121  :   overwritten_bytes[1] = buffer[segment_length+1];

	movzx	eax, BYTE PTR [ecx+1]
	mov	BYTE PTR [esi+37], al

; 122  :   buffer[segment_length] = buffer[segment_length+1] = 0xFF; // Force termination

	mov	WORD PTR [ecx], 65535			; 0000ffffH

; 123  :   checked_out = false;

	mov	BYTE PTR [esi+28], 0

; 124  :   if (MQ_segment)
; 125  :     {
; 126  :       S = 0;
; 127  :       temp = 0; C = 0; t = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+8], 0
	test	bl, bl
	je	SHORT $LN3@start

; 128  :       fill_lsbs();

	mov	ecx, esi
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+4], 0
	call	?fill_lsbs@mq_decoder@@AAEXXZ		; mq_decoder::fill_lsbs

; 129  :       C <<= t;

	mov	ecx, DWORD PTR [esi+8]
	shl	DWORD PTR [esi+4], cl

; 130  :       fill_lsbs();

	mov	ecx, esi
	call	?fill_lsbs@mq_decoder@@AAEXXZ		; mq_decoder::fill_lsbs

; 131  :       C <<= 7;

	shl	DWORD PTR [esi+4], 7

; 132  :       t -= 7;

	add	DWORD PTR [esi+8], -7			; fffffff9H

; 133  :       A = MQD_A_MIN;

	mov	DWORD PTR [esi], 8388608		; 00800000H
$LN3@start:
	pop	esi
	pop	ebx

; 134  :     }
; 135  :   else
; 136  :     {
; 137  :       t=0; temp = 0;
; 138  :     }
; 139  : }

	pop	ebp
	ret	12					; 0000000cH
?start@mq_decoder@@QAEXPAEH_N@Z ENDP			; mq_decoder::start
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
;	COMDAT ?init@mqd_state@@QAEXHH@Z
_TEXT	SEGMENT
_Sigma$ = 8						; size = 4
_s$ = 12						; size = 4
?init@mqd_state@@QAEXHH@Z PROC				; mqd_state::init, COMDAT
; _this$ = ecx

; 199  : {

	push	ebp
	mov	ebp, esp

; 200  :   assert((Sigma >= 0) && (Sigma <= 46) && (s == (s&1)));
; 201  :   p_bar_mps = (mq_decoder::p_bar_table[Sigma] << 8) + s;

	mov	eax, DWORD PTR _s$[ebp]
	push	esi
	mov	esi, DWORD PTR _Sigma$[ebp]
	mov	edx, DWORD PTR ?p_bar_table@mq_decoder@@2PAHA[esi*4]
	shl	edx, 8
	add	edx, eax

; 202  :   transition = mq_decoder::transition_table + ((Sigma<<1) + s);

	lea	eax, DWORD PTR [eax+esi*2]
	shl	eax, 4
	add	eax, OFFSET ?transition_table@mq_decoder@@2PAUmqd_transition@@A ; mq_decoder::transition_table
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	pop	esi

; 203  : }

	pop	ebp
	ret	8
?init@mqd_state@@QAEXHH@Z ENDP				; mqd_state::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
END
