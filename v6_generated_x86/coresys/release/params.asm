; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\parameters\params.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?MULTI_RECORD@kdu_params@@1HB			; kdu_params::MULTI_RECORD
PUBLIC	?CAN_EXTRAPOLATE@kdu_params@@1HB		; kdu_params::CAN_EXTRAPOLATE
PUBLIC	?ALL_COMPONENTS@kdu_params@@1HB			; kdu_params::ALL_COMPONENTS
CONST	SEGMENT
?MULTI_RECORD@kdu_params@@1HB DD 01H			; kdu_params::MULTI_RECORD
?CAN_EXTRAPOLATE@kdu_params@@1HB DD 02H			; kdu_params::CAN_EXTRAPOLATE
?ALL_COMPONENTS@kdu_params@@1HB DD 04H			; kdu_params::ALL_COMPONENTS
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	??6kdu_message@@QAEAAV0@H@Z			; kdu_message::operator<<
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	?put@kdu_output@@QAEHE@Z			; kdu_output::put
PUBLIC	?put@kdu_output@@QAEHG@Z			; kdu_output::put
PUBLIC	?put@kdu_output@@QAEHI@Z			; kdu_output::put
PUBLIC	??0kdu_params@@QAE@PBD_N1111@Z			; kdu_params::kdu_params
PUBLIC	?add_dependency@kdu_params@@IAEXPBD@Z		; kdu_params::add_dependency
PUBLIC	??1kdu_params@@UAE@XZ				; kdu_params::~kdu_params
PUBLIC	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z		; kdu_params::link
PUBLIC	?new_instance@kdu_params@@QAEPAV1@XZ		; kdu_params::new_instance
PUBLIC	?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z	; kdu_params::copy_from
PUBLIC	?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z		; kdu_params::copy_all
PUBLIC	?access_cluster@kdu_params@@QAEPAV1@PBD@Z	; kdu_params::access_cluster
PUBLIC	?access_cluster@kdu_params@@QAEPAV1@H@Z		; kdu_params::access_cluster
PUBLIC	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z	; kdu_params::access_relation
PUBLIC	?access_unique@kdu_params@@QAEPAV1@HHH@Z	; kdu_params::access_unique
PUBLIC	?define_attribute@kdu_params@@IAEXPBD00H@Z	; kdu_params::define_attribute
PUBLIC	?clear_marks@kdu_params@@QAEXXZ			; kdu_params::clear_marks
PUBLIC	?any_changes@kdu_params@@QAE_NXZ		; kdu_params::any_changes
PUBLIC	?check_typical_tile@kdu_params@@QAE_NHPBD@Z	; kdu_params::check_typical_tile
PUBLIC	?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z ; kdu_params::translate_marker_segment
PUBLIC	?generate_marker_segments@kdu_params@@QAEHPAVkdu_output@@HH@Z ; kdu_params::generate_marker_segments
PUBLIC	?write_marker_segment@kdu_params@@MAEHPAVkdu_output@@PAV1@H@Z ; kdu_params::write_marker_segment
PUBLIC	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z		; kdu_params::get
PUBLIC	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z		; kdu_params::get
PUBLIC	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z		; kdu_params::get
PUBLIC	?compare@kdu_params@@QAE_NPBDHHH@Z		; kdu_params::compare
PUBLIC	?compare@kdu_params@@QAE_NPBDHH_N@Z		; kdu_params::compare
PUBLIC	?compare@kdu_params@@QAE_NPBDHHM@Z		; kdu_params::compare
PUBLIC	?set@kdu_params@@QAEXPBDHHH@Z			; kdu_params::set
PUBLIC	?set@kdu_params@@QAEXPBDHH_N@Z			; kdu_params::set
PUBLIC	?set@kdu_params@@QAEXPBDHHN@Z			; kdu_params::set
PUBLIC	?set_derived@kdu_params@@QAEXPBD@Z		; kdu_params::set_derived
PUBLIC	?parse_string@kdu_params@@QAE_NPBD@Z		; kdu_params::parse_string
PUBLIC	?parse_string@kdu_params@@QAE_NPBDH@Z		; kdu_params::parse_string
PUBLIC	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ; kdu_params::textualize_attributes
PUBLIC	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@HH_N@Z ; kdu_params::textualize_attributes
PUBLIC	?describe_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ; kdu_params::describe_attributes
PUBLIC	?describe_attribute@kdu_params@@QAEXPBDAAVkdu_message@@_N@Z ; kdu_params::describe_attribute
PUBLIC	?find_string@kdu_params@@QAEPAV1@PADAAPBD@Z	; kdu_params::find_string
PUBLIC	?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z ; kdu_params::delete_unparsed_attribute
PUBLIC	?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z	; kdu_params::custom_parse_field
PUBLIC	?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z ; kdu_params::custom_textualize_field
PUBLIC	?finalize@kdu_params@@UAEX_N@Z			; kdu_params::finalize
PUBLIC	?finalize_all@kdu_params@@QAEX_N@Z		; kdu_params::finalize_all
PUBLIC	?finalize_all@kdu_params@@QAEXH_N@Z		; kdu_params::finalize_all
PUBLIC	??_Ekdu_params@@UAEPAXI@Z			; kdu_params::`vector deleting destructor'
PUBLIC	??0siz_params@@QAE@XZ				; siz_params::siz_params
PUBLIC	?new_object@siz_params@@MAEPAVkdu_params@@XZ	; siz_params::new_object
PUBLIC	?finalize@siz_params@@MAEX_N@Z			; siz_params::finalize
PUBLIC	?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z ; siz_params::copy_with_xforms
PUBLIC	?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ; siz_params::write_marker_segment
PUBLIC	?check_marker_segment@siz_params@@MAE_NGHQAEAAH@Z ; siz_params::check_marker_segment
PUBLIC	?read_marker_segment@siz_params@@MAE_NGHQAEH@Z	; siz_params::read_marker_segment
PUBLIC	??_Gsiz_params@@UAEPAXI@Z			; siz_params::`scalar deleting destructor'
PUBLIC	??0mct_params@@QAE@XZ				; mct_params::mct_params
PUBLIC	?new_object@mct_params@@MAEPAVkdu_params@@XZ	; mct_params::new_object
PUBLIC	?finalize@mct_params@@MAEX_N@Z			; mct_params::finalize
PUBLIC	?copy_with_xforms@mct_params@@MAEXPAVkdu_params@@HH_N11@Z ; mct_params::copy_with_xforms
PUBLIC	?write_marker_segment@mct_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ; mct_params::write_marker_segment
PUBLIC	?check_marker_segment@mct_params@@MAE_NGHQAEAAH@Z ; mct_params::check_marker_segment
PUBLIC	?read_marker_segment@mct_params@@MAE_NGHQAEH@Z	; mct_params::read_marker_segment
PUBLIC	??_Gmct_params@@UAEPAXI@Z			; mct_params::`scalar deleting destructor'
PUBLIC	??0mcc_params@@QAE@XZ				; mcc_params::mcc_params
PUBLIC	?new_object@mcc_params@@MAEPAVkdu_params@@XZ	; mcc_params::new_object
PUBLIC	?finalize@mcc_params@@MAEX_N@Z			; mcc_params::finalize
PUBLIC	?copy_with_xforms@mcc_params@@MAEXPAVkdu_params@@HH_N11@Z ; mcc_params::copy_with_xforms
PUBLIC	?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ; mcc_params::write_marker_segment
PUBLIC	?check_marker_segment@mcc_params@@MAE_NGHQAEAAH@Z ; mcc_params::check_marker_segment
PUBLIC	?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z	; mcc_params::read_marker_segment
PUBLIC	??_Gmcc_params@@UAEPAXI@Z			; mcc_params::`scalar deleting destructor'
PUBLIC	??0mco_params@@QAE@XZ				; mco_params::mco_params
PUBLIC	?new_object@mco_params@@MAEPAVkdu_params@@XZ	; mco_params::new_object
PUBLIC	?finalize@mco_params@@MAEX_N@Z			; mco_params::finalize
PUBLIC	?copy_with_xforms@mco_params@@MAEXPAVkdu_params@@HH_N11@Z ; mco_params::copy_with_xforms
PUBLIC	?write_marker_segment@mco_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ; mco_params::write_marker_segment
PUBLIC	?check_marker_segment@mco_params@@MAE_NGHQAEAAH@Z ; mco_params::check_marker_segment
PUBLIC	?read_marker_segment@mco_params@@MAE_NGHQAEH@Z	; mco_params::read_marker_segment
PUBLIC	??_Gmco_params@@UAEPAXI@Z			; mco_params::`scalar deleting destructor'
PUBLIC	??0atk_params@@QAE@XZ				; atk_params::atk_params
PUBLIC	?new_object@atk_params@@MAEPAVkdu_params@@XZ	; atk_params::new_object
PUBLIC	?finalize@atk_params@@MAEX_N@Z			; atk_params::finalize
PUBLIC	?copy_with_xforms@atk_params@@MAEXPAVkdu_params@@HH_N11@Z ; atk_params::copy_with_xforms
PUBLIC	?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ; atk_params::write_marker_segment
PUBLIC	?check_marker_segment@atk_params@@MAE_NGHQAEAAH@Z ; atk_params::check_marker_segment
PUBLIC	?read_marker_segment@atk_params@@MAE_NGHQAEH@Z	; atk_params::read_marker_segment
PUBLIC	??_Gatk_params@@UAEPAXI@Z			; atk_params::`scalar deleting destructor'
PUBLIC	??0cod_params@@QAE@XZ				; cod_params::cod_params
PUBLIC	?new_object@cod_params@@MAEPAVkdu_params@@XZ	; cod_params::new_object
PUBLIC	?finalize@cod_params@@MAEX_N@Z			; cod_params::finalize
PUBLIC	?copy_with_xforms@cod_params@@MAEXPAVkdu_params@@HH_N11@Z ; cod_params::copy_with_xforms
PUBLIC	?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ; cod_params::write_marker_segment
PUBLIC	?check_marker_segment@cod_params@@MAE_NGHQAEAAH@Z ; cod_params::check_marker_segment
PUBLIC	?read_marker_segment@cod_params@@MAE_NGHQAEH@Z	; cod_params::read_marker_segment
PUBLIC	?custom_parse_field@cod_params@@MAEHPBD0HAAH@Z	; cod_params::custom_parse_field
PUBLIC	?custom_textualize_field@cod_params@@MAEXAAVkdu_message@@PBDHH@Z ; cod_params::custom_textualize_field
PUBLIC	?is_valid_decomp_terminator@cod_params@@SA_NH@Z	; cod_params::is_valid_decomp_terminator
PUBLIC	?textualize_decomp@cod_params@@SAXQADH@Z	; cod_params::textualize_decomp
PUBLIC	?transpose_decomp@cod_params@@SAHH@Z		; cod_params::transpose_decomp
PUBLIC	?expand_decomp_bands@cod_params@@SAHHQAF@Z	; cod_params::expand_decomp_bands
PUBLIC	?get_max_decomp_levels@cod_params@@SAXHAAH0@Z	; cod_params::get_max_decomp_levels
PUBLIC	?find_suitable_ads_idx@cod_params@@AAEHXZ	; cod_params::find_suitable_ads_idx
PUBLIC	?find_suitable_dfs_idx@cod_params@@AAEHXZ	; cod_params::find_suitable_dfs_idx
PUBLIC	?derive_decomposition_structure@cod_params@@AAEXPAVkdu_params@@0@Z ; cod_params::derive_decomposition_structure
PUBLIC	?validate_ads_data@cod_params@@AAEXH@Z		; cod_params::validate_ads_data
PUBLIC	?validate_dfs_data@cod_params@@AAEXH@Z		; cod_params::validate_dfs_data
PUBLIC	??_Gcod_params@@UAEPAXI@Z			; cod_params::`scalar deleting destructor'
PUBLIC	??0ads_params@@QAE@XZ				; ads_params::ads_params
PUBLIC	?new_object@ads_params@@MAEPAVkdu_params@@XZ	; ads_params::new_object
PUBLIC	?finalize@ads_params@@MAEX_N@Z			; ads_params::finalize
PUBLIC	?copy_with_xforms@ads_params@@MAEXPAVkdu_params@@HH_N11@Z ; ads_params::copy_with_xforms
PUBLIC	?write_marker_segment@ads_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ; ads_params::write_marker_segment
PUBLIC	?check_marker_segment@ads_params@@MAE_NGHQAEAAH@Z ; ads_params::check_marker_segment
PUBLIC	?read_marker_segment@ads_params@@MAE_NGHQAEH@Z	; ads_params::read_marker_segment
PUBLIC	?custom_textualize_field@ads_params@@MAEXAAVkdu_message@@PBDHH@Z ; ads_params::custom_textualize_field
PUBLIC	??_Gads_params@@UAEPAXI@Z			; ads_params::`scalar deleting destructor'
PUBLIC	??0dfs_params@@QAE@XZ				; dfs_params::dfs_params
PUBLIC	?new_object@dfs_params@@MAEPAVkdu_params@@XZ	; dfs_params::new_object
PUBLIC	?finalize@dfs_params@@MAEX_N@Z			; dfs_params::finalize
PUBLIC	?copy_with_xforms@dfs_params@@MAEXPAVkdu_params@@HH_N11@Z ; dfs_params::copy_with_xforms
PUBLIC	?write_marker_segment@dfs_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ; dfs_params::write_marker_segment
PUBLIC	?check_marker_segment@dfs_params@@MAE_NGHQAEAAH@Z ; dfs_params::check_marker_segment
PUBLIC	?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z	; dfs_params::read_marker_segment
PUBLIC	??_Gdfs_params@@UAEPAXI@Z			; dfs_params::`scalar deleting destructor'
PUBLIC	??0qcd_params@@QAE@XZ				; qcd_params::qcd_params
PUBLIC	?new_object@qcd_params@@MAEPAVkdu_params@@XZ	; qcd_params::new_object
PUBLIC	?finalize@qcd_params@@MAEX_N@Z			; qcd_params::finalize
PUBLIC	?copy_with_xforms@qcd_params@@MAEXPAVkdu_params@@HH_N11@Z ; qcd_params::copy_with_xforms
PUBLIC	?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ; qcd_params::write_marker_segment
PUBLIC	?check_marker_segment@qcd_params@@MAE_NGHQAEAAH@Z ; qcd_params::check_marker_segment
PUBLIC	?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z	; qcd_params::read_marker_segment
PUBLIC	??_Gqcd_params@@UAEPAXI@Z			; qcd_params::`scalar deleting destructor'
PUBLIC	??0rgn_params@@QAE@XZ				; rgn_params::rgn_params
PUBLIC	?finalize@rgn_params@@MAEX_N@Z			; rgn_params::finalize
PUBLIC	?new_object@rgn_params@@MAEPAVkdu_params@@XZ	; rgn_params::new_object
PUBLIC	?copy_with_xforms@rgn_params@@MAEXPAVkdu_params@@HH_N11@Z ; rgn_params::copy_with_xforms
PUBLIC	?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ; rgn_params::write_marker_segment
PUBLIC	?check_marker_segment@rgn_params@@MAE_NGHQAEAAH@Z ; rgn_params::check_marker_segment
PUBLIC	?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z	; rgn_params::read_marker_segment
PUBLIC	??_Grgn_params@@UAEPAXI@Z			; rgn_params::`scalar deleting destructor'
PUBLIC	??0poc_params@@QAE@XZ				; poc_params::poc_params
PUBLIC	?new_object@poc_params@@MAEPAVkdu_params@@XZ	; poc_params::new_object
PUBLIC	?copy_with_xforms@poc_params@@MAEXPAVkdu_params@@HH_N11@Z ; poc_params::copy_with_xforms
PUBLIC	?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ; poc_params::write_marker_segment
PUBLIC	?check_marker_segment@poc_params@@MAE_NGHQAEAAH@Z ; poc_params::check_marker_segment
PUBLIC	?read_marker_segment@poc_params@@MAE_NGHQAEH@Z	; poc_params::read_marker_segment
PUBLIC	??_Gpoc_params@@UAEPAXI@Z			; poc_params::`scalar deleting destructor'
PUBLIC	??0crg_params@@QAE@XZ				; crg_params::crg_params
PUBLIC	?new_object@crg_params@@MAEPAVkdu_params@@XZ	; crg_params::new_object
PUBLIC	?copy_with_xforms@crg_params@@MAEXPAVkdu_params@@HH_N11@Z ; crg_params::copy_with_xforms
PUBLIC	?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ; crg_params::write_marker_segment
PUBLIC	?check_marker_segment@crg_params@@MAE_NGHQAEAAH@Z ; crg_params::check_marker_segment
PUBLIC	?read_marker_segment@crg_params@@MAE_NGHQAEH@Z	; crg_params::read_marker_segment
PUBLIC	??_Gcrg_params@@UAEPAXI@Z			; crg_params::`scalar deleting destructor'
PUBLIC	??0org_params@@QAE@XZ				; org_params::org_params
PUBLIC	?new_object@org_params@@MAEPAVkdu_params@@XZ	; org_params::new_object
PUBLIC	?copy_with_xforms@org_params@@MAEXPAVkdu_params@@HH_N11@Z ; org_params::copy_with_xforms
PUBLIC	?check_marker_segment@org_params@@MAE_NGHQAEAAH@Z ; org_params::check_marker_segment
PUBLIC	?read_marker_segment@org_params@@MAE_NGHQAEH@Z	; org_params::read_marker_segment
PUBLIC	??_Gorg_params@@UAEPAXI@Z			; org_params::`scalar deleting destructor'
PUBLIC	??0kdu_kernel_step_info@@QAE@XZ			; kdu_kernel_step_info::kdu_kernel_step_info
PUBLIC	??1kdu_kernels@@QAE@XZ				; kdu_kernels::~kdu_kernels
PUBLIC	??0att_val@@QAE@XZ				; att_val::att_val
PUBLIC	??0kd_attribute@@QAE@PBD0H0@Z			; kd_attribute::kd_attribute
PUBLIC	?augment_records@kd_attribute@@QAEXH@Z		; kd_attribute::augment_records
PUBLIC	?describe@kd_attribute@@QAEXAAVkdu_message@@_N111@Z ; kd_attribute::describe
PUBLIC	?match_attribute@@YAPAUkd_attribute@@PAU1@PBD@Z	; match_attribute
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf?$AA@			; `string'
PUBLIC	__TI2PAE
PUBLIC	__CTA2PAE
PUBLIC	??_R0PAE@8					; unsigned char * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAE@84
PUBLIC	??_R0PAX@8					; void * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAX@84
PUBLIC	??_7kdu_params@@6B@				; kdu_params::`vftable'
PUBLIC	??_7siz_params@@6B@				; siz_params::`vftable'
PUBLIC	??_7mct_params@@6B@				; mct_params::`vftable'
PUBLIC	??_7mcc_params@@6B@				; mcc_params::`vftable'
PUBLIC	??_7mco_params@@6B@				; mco_params::`vftable'
PUBLIC	??_7atk_params@@6B@				; atk_params::`vftable'
PUBLIC	??_7cod_params@@6B@				; cod_params::`vftable'
PUBLIC	??_7ads_params@@6B@				; ads_params::`vftable'
PUBLIC	??_7dfs_params@@6B@				; dfs_params::`vftable'
PUBLIC	??_7qcd_params@@6B@				; qcd_params::`vftable'
PUBLIC	??_7rgn_params@@6B@				; rgn_params::`vftable'
PUBLIC	??_7poc_params@@6B@				; poc_params::`vftable'
PUBLIC	??_7crg_params@@6B@				; crg_params::`vftable'
PUBLIC	??_7org_params@@6B@				; org_params::`vftable'
PUBLIC	??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@	; `string'
PUBLIC	??_C@_0DM@BIIABMGK@Absolute?5quantization?5step?5sizes@ ; `string'
PUBLIC	??_C@_0GM@JHCOHHHI@String?5translators?5in?5code?9strea@ ; `string'
PUBLIC	??_C@_03NONCDIOG@?3?5?$CC?$AA@			; `string'
PUBLIC	??_C@_02DAHALNEP@?$CC?4?$AA@			; `string'
PUBLIC	??_C@_0EL@BICNPJDD@String?5translators?5in?5code?9strea@ ; `string'
PUBLIC	??_C@_0CO@KGDOBALG@?5characters?5in?5length?$CB?5Problem?5e@ ; `string'
PUBLIC	??_C@_0IM@FCIPKKGG@String?5translators?5in?5code?9strea@ ; `string'
PUBLIC	??_C@_0CC@LLCJBDHK@Expected?5one?5of?5the?5identifiers?0@ ; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	??_C@_04FJKIFICP@?5or?5?$AA@			; `string'
PUBLIC	??_C@_0CK@HEDJDDBK@Expected?5one?5or?5more?5of?5the?5iden@ ; `string'
PUBLIC	??_C@_0BN@BJKINHLE@?$CC?0?5separated?5by?5?$GA?$HM?8?5symbols?4?$AA@ ; `string'
PUBLIC	??_C@_08IDCJHBJK@Ckernels?$AA@			; `string'
PUBLIC	??_C@_06PJGAHNDG@Ksteps?$AA@			; `string'
PUBLIC	??_C@_07KKABNIJP@Kcoeffs?$AA@			; `string'
PUBLIC	??_C@_07MIOINIMK@Cdecomp?$AA@			; `string'
PUBLIC	??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@		; `string'
PUBLIC	??_C@_0L@ELEFPJIC@Qabs_steps?$AA@		; `string'
PUBLIC	__TI2CPAD
PUBLIC	__CTA2PAD
PUBLIC	??_R0PAD@8					; char * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAD@84
PUBLIC	??_C@_0EA@NIBLGMMC@Attempting?5to?5write?5multiple?5rec@ ; `string'
PUBLIC	??_C@_03KLKADAKF@?0?5?$CC?$AA@			; `string'
PUBLIC	??_C@_0CM@EMGKNDJI@?$CC?0?5which?5can?5accept?5only?5single?5@ ; `string'
PUBLIC	??_C@_02OAMGPABD@?$DN?$HL?$AA@			; `string'
PUBLIC	??_C@_03JILILBPJ@?$FL?3?$DM?$AA@		; `string'
PUBLIC	??_C@_04PONDAPIE@?$DO?$FN?$DN?$HL?$AA@		; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	??_C@_05GAGDNHHH@?$DMint?$DO?$AA@		; `string'
PUBLIC	??_C@_08KMPCOBIE@?$DMyes?1no?$DO?$AA@		; `string'
PUBLIC	??_C@_07FFCKHLFB@?$DMfloat?$DO?$AA@		; `string'
PUBLIC	??_C@_0N@LECANFFL@?$DMcustom?5int?$DO?$AA@	; `string'
PUBLIC	??_C@_05BAJLLFH@ENUM?$DM?$AA@			; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO?$AA@			; `string'
PUBLIC	??_C@_06EDILFCLO@FLAGS?$DM?$AA@			; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN?$AA@			; `string'
PUBLIC	??_C@_05MIHDFBBJ@?0?4?4?4?6?$AA@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_01GPOEFGEJ@?7?$AA@			; `string'
PUBLIC	??_C@_0OO@BFNLONCD@Illegal?5tile?5or?5component?5indice@ ; `string'
PUBLIC	??_C@_0KB@EJFHGKHN@Call?5to?5?$GAkdu_params?3?3link?8?5speci@ ; `string'
PUBLIC	??_C@_0KA@FKBGPIEK@Call?5to?5?$GAkdu_params?3?3link?8?5speci@ ; `string'
PUBLIC	??_C@_0GD@HANNBBLP@Trying?5to?5use?5?$GAkdu_params?3?3copy_@ ; `string'
PUBLIC	??_C@_0JI@GAIBBJLH@Trying?5to?5use?5?$GAkdu_params?3?3copy_@ ; `string'
PUBLIC	??_C@_0EP@FFHPHGIF@Illegal?5attempt?5to?5modify?5a?5?$GAkdu@ ; `string'
PUBLIC	??_C@_0GC@FAEHIHF@Trying?5to?5use?5?$GAkdu_params?3?3copy_@ ; `string'
PUBLIC	??_C@_0JH@PHOILHHH@Trying?5to?5use?5?$GAkdu_params?3?3copy_@ ; `string'
PUBLIC	??_C@_0EB@KNIJAOBN@Invalid?5?$GAtile_idx?8?5supplied?5to?5?$GA@ ; `string'
PUBLIC	??_C@_0EB@JLDBDJJO@Attempt?5to?5access?5a?5code?9stream?5@ ; `string'
PUBLIC	??_C@_02LHOIKBIA@?$CC?$CB?$AA@			; `string'
PUBLIC	??_C@_0FO@BDPPHOIA@Attempt?5to?5access?5a?5code?9stream?5@ ; `string'
PUBLIC	??_C@_02JPEBCGCN@?5?$CC?$AA@			; `string'
PUBLIC	??_C@_03BMLMMEDG@?$CC?4?6?$AA@			; `string'
PUBLIC	??_C@_0BE@NMPECGEH@The?5field?5index?5is?5?$AA@	; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0HI@GBKDDDEC@Attempting?5to?5access?5a?5floating?5@ ; `string'
PUBLIC	??_C@_0HF@JLGEHIN@Attempting?5to?5access?5a?5non?9boole@ ; `string'
PUBLIC	??_C@_0ID@NIKNNMAJ@Attempting?5to?5access?5an?5integer?5@ ; `string'
PUBLIC	??_C@_0DO@JOGJAIGA@Attempt?5to?5set?5a?5code?9stream?5att@ ; `string'
PUBLIC	??_C@_0GI@PNBMMBJE@Attempt?5to?5set?5a?5non?9tile?9specif@ ; `string'
PUBLIC	??_C@_0FL@DIDANAGC@Attempt?5to?5set?5a?5code?9stream?5att@ ; `string'
PUBLIC	??_C@_0HP@BOHKEADG@Attempting?5to?5set?5a?5floating?5poi@ ; `string'
PUBLIC	??_C@_0HN@MGKBDNAF@Attempting?5to?5set?5a?5boolean?5code@ ; `string'
PUBLIC	??_C@_0KH@JEELPMNH@Attempting?5to?5set?5a?5code?9stream?5@ ; `string'
PUBLIC	??_C@_0JJ@BKCJHECD@Attempting?5to?5set?5a?5code?9stream?5@ ; `string'
PUBLIC	??_C@_0HM@KMNJIEPO@Attempting?5to?5set?5a?5non?9boolean?5@ ; `string'
PUBLIC	??_C@_0IA@DFMOHAGA@Attempting?5to?5set?5an?5integer?5cod@ ; `string'
PUBLIC	??_C@_0BH@HIFAHFHM@Invalid?5attribute?5name?$AA@ ; `string'
PUBLIC	??_C@_03HAFDNMHA@?$CC?0?5?$AA@			; `string'
PUBLIC	??_C@_0DE@NFMHJCHA@supplied?5to?5the?5?$GAkdu_params?3?3set@ ; `string'
PUBLIC	??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@ ; `string'
PUBLIC	??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@		; `string'
PUBLIC	??_C@_0CE@NNLGGFEF@White?5space?5characters?5are?5illeg@ ; `string'
PUBLIC	??_C@_09EIDFECNJ@Attribute?$AA@			; `string'
PUBLIC	??_C@_02KOPDJAMB@?$CC?5?$AA@			; `string'
PUBLIC	??_C@_0BK@DEPOJPCI@is?5missing?5parameters?3?6?6?7?$AA@ ; `string'
PUBLIC	??_C@_0GO@DPHCDBCK@?6Parameter?5values?5must?5be?5separa@ ; `string'
PUBLIC	??_C@_0DN@JMPBALKA@Malformed?5location?5specifier?5enc@ ; `string'
PUBLIC	??_C@_0NA@FLKOAPNM@Tile?5specifiers?5following?5the?5th@ ; `string'
PUBLIC	??_C@_0FE@PMHLCCDF@You?5must?5supply?5an?5index?5specifi@ ; `string'
PUBLIC	??_C@_0GI@IAODNOI@This?5type?5of?5parameter?5cannot?5be@ ; `string'
PUBLIC	??_C@_0BB@FCCGFNIO@Attribute?5string?$AA@	; `string'
PUBLIC	??_C@_0CJ@BPCCBEIL@refers?5to?5a?5non?9existent?5tile?9co@ ; `string'
PUBLIC	??_C@_0IG@JNAPNKGG@Attempt?5to?5set?5a?5non?9tile?9specif@ ; `string'
PUBLIC	??_C@_0GM@BCPIKDJF@Parameter?5values?5must?5be?5separat@ ; `string'
PUBLIC	??_C@_0BO@NIAMPCJJ@The?5supplied?5attribute?5string?$AA@ ; `string'
PUBLIC	??_C@_0JM@LMPOLJGM@refers?5to?5code?9stream?5parameters@ ; `string'
PUBLIC	??_C@_0BH@DPGABFPI@Problem?5encountered?5at?$AA@ ; `string'
PUBLIC	??_C@_0CF@KHIJHBHP@Records?5must?5be?5separated?5by?5com@ ; `string'
PUBLIC	??_C@_0DH@MBMGHEML@Attribute?5does?5not?5support?5multi@ ; `string'
PUBLIC	??_C@_0DN@ONBLBBIB@Records?5must?5be?5enclosed?5by?5curl@ ; `string'
PUBLIC	??_C@_0CE@EELOEALG@Fields?5must?5be?5separated?5by?5comm@ ; `string'
PUBLIC	??_C@_0CB@KHDANEEK@Expected?5a?5floating?5point?5field?4@ ; `string'
PUBLIC	??_C@_0BL@KODNALJB@Expected?5an?5integer?5field?4?$AA@ ; `string'
PUBLIC	??_C@_0FJ@PANFLKHK@Attempt?5to?5parse?5custom?5string?5r@ ; `string'
PUBLIC	??_C@_03ICICOMAL@yes?$AA@			; `string'
PUBLIC	??_C@_02KAJCLHKP@no?$AA@			; `string'
PUBLIC	??_C@_0EB@EHIGLBBC@Expected?5a?5boolean?5field?5identif@ ; `string'
PUBLIC	??_C@_0DM@ODMOHKAB@Opening?5brace?5for?5record?5is?5not?5@ ; `string'
PUBLIC	??_C@_01GAPBHFFA@T?$AA@				; `string'
PUBLIC	??_C@_01GFHCPBMG@C?$AA@				; `string'
PUBLIC	??_C@_01JPJNBJEM@I?$AA@				; `string'
PUBLIC	??_C@_0HL@JPCGMMAG@Attempting?5to?5textualize?5a?5code?9@ ; `string'
PUBLIC	??_C@_09GBLFFAMG@in?5field?5?$AA@		; `string'
PUBLIC	??_C@_0M@LIKKDBIM@?5of?5record?5?$AA@		; `string'
PUBLIC	??_C@_0EO@MMDBDEFI@?$CCkdu_params?3?3describe_attribute?$CC@ ; `string'
PUBLIC	??_C@_0FM@CALBKEL@Attempting?5to?5delete?5a?5non?9exist@ ; `string'
PUBLIC	??_C@_0HA@MENEFAMH@Codestream?5contains?5a?5parameter?5@ ; `string'
PUBLIC	??_C@_03GJDKGJIF@?$CC?$DL?5?$AA@		; `string'
PUBLIC	??_C@_0P@DOHDMGMJ@tile?5number?5is?$AA@		; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_0BA@MNKEPDKJ@?5?$FLi?4e?4?0?5global?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BD@MMGLAGCF@?5?$CIstarting?5from?50?$CJ?$AA@ ; `string'
PUBLIC	??_C@_02LNAEAIDO@?$DL?5?$AA@			; `string'
PUBLIC	??_C@_0BD@PIKIAENG@component?5index?5is?$AA@	; `string'
PUBLIC	??_C@_03DIBMIDDO@SIZ?$AA@			; `string'
PUBLIC	??_C@_0EB@MCBBIPAI@?$CIPROFILE0?$DN0?0PROFILE1?$DN1?0PROFILE2?$DN@ ; `string'
PUBLIC	??_C@_0GIB@OAPGMEGC@Restricted?5profile?5to?5which?5the?5@ ; `string'
PUBLIC	??_C@_08HFDHOMDN@Sprofile?$AA@			; `string'
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
PUBLIC	??_C@_0ML@FCKJPFCA@Flag?5indicating?5whether?5or?5not?5c@ ; `string'
PUBLIC	??_C@_04JNHDNPF@Scap?$AA@			; `string'
PUBLIC	??_C@_0GI@IJELGHMP@?$FLDC?$DN1?$HMVARQ?$DN2?$HMTCQ?$DN4?$HMPRECQ?$DN2048?$HMVI@ ; `string'
PUBLIC	??_C@_0DFB@NHCICMJL@Logical?5OR?5of?5any?5combination?5of@ ; `string'
PUBLIC	??_C@_0M@NJJFAENN@Sextensions?$AA@		; `string'
PUBLIC	??_C@_02FOEOGEOO@II?$AA@			; `string'
PUBLIC	??_C@_0BDP@GFLEIBAO@Canvas?5dimensions?3?5vertical?5dime@ ; `string'
PUBLIC	??_C@_05HNJHHEPH@Ssize?$AA@			; `string'
PUBLIC	??_C@_0GN@LGNONLIP@Image?5origin?5on?5canvas?3?5vertical@ ; `string'
PUBLIC	??_C@_07PEMLCIHF@Sorigin?$AA@			; `string'
PUBLIC	??_C@_0EF@BCOJOGJB@Tile?5partition?5size?3?5vertical?5di@ ; `string'
PUBLIC	??_C@_06EPMBOCAF@Stiles?$AA@			; `string'
PUBLIC	??_C@_0EM@GFLJDJGF@Tile?5origin?5on?5the?5canvas?3?5verti@ ; `string'
PUBLIC	??_C@_0N@KMIIMNEN@Stile_origin?$AA@		; `string'
PUBLIC	??_C@_0CDM@NAGNLIBN@Number?5of?5codestream?5image?5compo@ ; `string'
PUBLIC	??_C@_0M@LFKICJFJ@Scomponents?$AA@		; `string'
PUBLIC	??_C@_0DAJ@MODEBBAE@Indicates?5whether?5each?5codestrea@ ; `string'
PUBLIC	??_C@_07MGJMMJC@Ssigned?$AA@			; `string'
PUBLIC	??_C@_0CLK@EPFPBPLL@Indicates?5the?5bit?9depth?5of?5each?5@ ; `string'
PUBLIC	??_C@_0L@BADPNFGK@Sprecision?$AA@		; `string'
PUBLIC	??_C@_0BIA@NFIIFPMP@Indicates?5the?5sub?9sampling?5facto@ ; `string'
PUBLIC	??_C@_09IGDOMJM@Ssampling?$AA@			; `string'
PUBLIC	??_C@_0BGE@DJOJEOK@Indicates?5the?5dimensions?5?$CIvertic@ ; `string'
PUBLIC	??_C@_05KKKGDPEH@Sdims?$AA@			; `string'
PUBLIC	??_C@_0FFB@NCBJOMEF@Number?5of?5image?5components?5produ@ ; `string'
PUBLIC	??_C@_0M@FAIBBHLL@Mcomponents?$AA@		; `string'
PUBLIC	??_C@_0BHF@DJPMMPEM@Indicates?5whether?5each?5MCT?5outpu@ ; `string'
PUBLIC	??_C@_07GFFIOPIL@Msigned?$AA@			; `string'
PUBLIC	??_C@_0BFE@NNIAEAJM@Indicates?5the?5bit?9depth?5of?5each?5@ ; `string'
PUBLIC	??_C@_0L@OMLPDKKH@Mprecision?$AA@		; `string'
PUBLIC	??_C@_0IK@CCHOHMJN@Unable?5to?5copy?5SIZ?5parameters?0?5u@ ; `string'
PUBLIC	??_C@_0EK@BLNJMGGP@Attempting?5to?5discard?5all?5of?5the@ ; `string'
PUBLIC	??_C@_03LIMJJHMM@COD?$AA@			; `string'
PUBLIC	??_C@_0OO@EELGDABM@Cannot?5apply?5requested?5resolutio@ ; `string'
PUBLIC	??_C@_0CI@CMGIGAHL@Unable?5to?5write?5SIZ?5marker?5segme@ ; `string'
PUBLIC	??_C@_0EF@JGBMKHNL@Illegal?5number?5of?5image?5componen@ ; `string'
PUBLIC	??_C@_0FJ@POPHKFAB@Illegal?5number?5of?5MCT?5output?5com@ ; `string'
PUBLIC	??_C@_07BGFFFHMP@Clevels?$AA@			; `string'
PUBLIC	??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@		; `string'
PUBLIC	??_C@_0NO@JDICNLBH@Attempting?5to?5write?5geometricall@ ; `string'
PUBLIC	??_C@_0L@KGBLICHL@Cprecincts?$AA@		; `string'
PUBLIC	??_C@_0OI@OALKHBMD@Error?5attempting?5to?5convert?5geom@ ; `string'
PUBLIC	??_C@_0JL@PMLPBNBK@Cannot?5write?5SIZ?5marker?5with?5ill@ ; `string'
PUBLIC	??_C@_0HF@BDHEFLHF@Illegal?5profile?5index?4?5?5?$CCSprofil@ ; `string'
PUBLIC	??_C@_0GO@MOMFJPHA@Unable?5to?5write?5SIZ?5marker?5segme@ ; `string'
PUBLIC	??_C@_0CB@NEMDCGAB@Illegal?5image?5sample?5bit?9depth?0?5@ ; `string'
PUBLIC	??_C@_0CP@NJAPNNOL@?4?5Legal?5range?5is?5from?51?5to?538?5bi@ ; `string'
PUBLIC	??_C@_0CK@FCLHCLL@Illegal?5component?5sub?9sampling?5f@ ; `string'
PUBLIC	??_C@_0CB@HBCCFDNA@?$HN?4?5Legal?5range?5is?5from?51?5to?5255?4@ ; `string'
PUBLIC	??_C@_0HM@MMCEOMEI@Unable?5to?5write?5CBD?5marker?5segme@ ; `string'
PUBLIC	??_C@_0CN@JHCHBCDJ@Illegal?5precision?5for?5MCT?5output@ ; `string'
PUBLIC	??_C@_0CI@CLEFFBLP@Invalid?5SIZ?5marker?5segment?5encou@ ; `string'
PUBLIC	??_C@_0DF@MIHNMLL@Malformed?5SIZ?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@ ; `string'
PUBLIC	??_C@_0EH@PJEAPICM@Malformed?5SIZ?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0DF@PNFFNEFI@Malformed?5CBD?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0EH@FOFCLFAN@Malformed?5CBD?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0JL@PLHBNPBC@Problem?5trying?5to?5finalize?5SIZ?5i@ ; `string'
PUBLIC	??_C@_0FP@HBBHOMDC@Problem?5trying?5to?5finalize?5SIZ?5i@ ; `string'
PUBLIC	??_C@_0GI@PICGKKPJ@Problem?5trying?5to?5finalize?5SIZ?5i@ ; `string'
PUBLIC	??_C@_0EA@FCCPDFNF@Image?5component?5sub?9sampling?5fac@ ; `string'
PUBLIC	??_C@_0II@DHNDEJOJ@Problem?5trying?5to?5finalize?5SIZ?5i@ ; `string'
PUBLIC	??_C@_0JH@NJJGGCNE@Problem?5trying?5to?5finalize?5SIZ?5i@ ; `string'
PUBLIC	??_C@_0KE@JLIAOLIC@Problem?5trying?5to?5finalize?5SIZ?5i@ ; `string'
PUBLIC	??_C@_0JJ@NPLIAPKO@Problem?5trying?5to?5finalize?5SIZ?5i@ ; `string'
PUBLIC	??_C@_0JH@IIBMOHD@Problem?5trying?5to?5finalize?5SIZ?5i@ ; `string'
PUBLIC	??_C@_0JO@OKOEKKHK@Problem?5trying?5to?5finalize?5SIZ?5i@ ; `string'
PUBLIC	??_C@_0JM@LALDBFDG@Problem?5trying?5to?5finalize?5SIZ?5i@ ; `string'
PUBLIC	??_C@_0HB@GIGMGNIM@Problem?5trying?5to?5finalize?5SIZ?5i@ ; `string'
PUBLIC	??_C@_0MN@GGGLGLFK@Problems?5trying?5to?5finalize?5SIZ?5@ ; `string'
PUBLIC	??_C@_0BFE@FLEIONEE@Illegal?5profile?5index?4?5?5?$CCSprofil@ ; `string'
PUBLIC	??_C@_04OONIPDNE@Cads?$AA@			; `string'
PUBLIC	??_C@_04NKICNHII@Cdfs?$AA@			; `string'
PUBLIC	??_C@_04HAOFMIPN@Catk?$AA@			; `string'
PUBLIC	??_C@_03IFCLAPBJ@ATK?$AA@			; `string'
PUBLIC	??_C@_0L@BNGLHLNI@Ksymmetric?$AA@		; `string'
PUBLIC	??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@		; `string'
PUBLIC	??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@ ; `string'
PUBLIC	??_C@_0IJ@LMINEOIM@Code?9stream?5profile?5had?5to?5be?5ch@ ; `string'
PUBLIC	??_C@_0NP@LDCOLEKI@Profile?5violation?5detected?4?5?5Cod@ ; `string'
PUBLIC	??_C@_0KG@LAENILL@Profile?5violation?5detected?4?5?5Cod@ ; `string'
PUBLIC	??_C@_0HP@KEPFIMCP@Profile?5violation?5detected?4?5?5Cod@ ; `string'
PUBLIC	??_C@_0JJ@ELMILGL@Profile?5violation?5detected?4?5?5Cod@ ; `string'
PUBLIC	??_C@_0JJ@DLDOMHMJ@Profile?5violation?5detected?4?5?5Cod@ ; `string'
PUBLIC	??_C@_03MNMMELJE@ORG?$AA@			; `string'
PUBLIC	??_C@_0L@CIAEHHDE@ORGgen_tlm?$AA@		; `string'
PUBLIC	??_C@_09CNLDEMAK@ORGtparts?$AA@			; `string'
PUBLIC	??_C@_0BAO@JPIFODPP@Profile?5violation?5detected?4?5?5Cod@ ; `string'
PUBLIC	??_C@_03LFCEPJHK@POC?$AA@			; `string'
PUBLIC	??_C@_06NMKHLFPN@Porder?$AA@			; `string'
PUBLIC	??_C@_0BAE@JMBBANBI@Profile?5violation?5detected?4?5?5You@ ; `string'
PUBLIC	??_C@_03BLMOALMK@MCT?$AA@			; `string'
PUBLIC	??_C@_0DPN@GBDINPGJ@Identifies?5the?5number?5of?5matrix?5@ ; `string'
PUBLIC	??_C@_0N@FIDBGNAL@Mmatrix_size?$AA@		; `string'
PUBLIC	??_C@_01BIAFAFID@F?$AA@				; `string'
PUBLIC	??_C@_0BGK@IHFIBLIK@Coefficients?5of?5the?5matrix?0?5if?5t@ ; `string'
PUBLIC	??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@		; `string'
PUBLIC	??_C@_0DNI@IDMIDCPL@Identifies?5the?5number?5of?5vector?5@ ; `string'
PUBLIC	??_C@_0N@EBBFOCKJ@Mvector_size?$AA@		; `string'
PUBLIC	??_C@_0BEO@GFEMDFDK@Coefficients?5of?5the?5vector?0?5if?5t@ ; `string'
PUBLIC	??_C@_0P@DIALIICI@Mvector_coeffs?$AA@		; `string'
PUBLIC	??_C@_0EBK@HDHPILKI@Identifies?5the?5total?5number?5of?5s@ ; `string'
PUBLIC	??_C@_0N@CCNKIJHO@Mtriang_size?$AA@		; `string'
PUBLIC	??_C@_0CAB@FHBPNALP@Coefficients?5of?5the?5sub?9triangul@ ; `string'
PUBLIC	??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@		; `string'
PUBLIC	??_C@_0KN@OBNKNPAB@Failed?5to?5read?5all?5MCT?5marker?5se@ ; `string'
PUBLIC	??_C@_0JE@JFBAAJII@Illegal?5value?5?$CIanything?5?$DM?$DN?50?$CJ?5fo@ ; `string'
PUBLIC	??_C@_0OJ@PDOPGBL@It?5is?5illegal?5to?5supply?5?$GAMvector@ ; `string'
PUBLIC	??_C@_0NI@PEHFOKHE@The?5number?5of?5?$GAMmatrix_coeffs?8?0?5@ ; `string'
PUBLIC	??_C@_0BBF@IPOKLLIB@Encountered?5repeat?5or?5out?9of?9ran@ ; `string'
PUBLIC	??_C@_0BCP@HHOAMAFM@Encountered?5out?9of?9order?5?$GAZmct?8?5@ ; `string'
PUBLIC	??_C@_0EI@NNANLLPB@Malformed?5MCT?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0DF@BKIIOFOO@Malformed?5MCT?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_03BOENIPFM@MCC?$AA@			; `string'
PUBLIC	??_C@_0DAF@JDFCJPDD@This?5attribute?5is?5used?5to?5descri@ ; `string'
PUBLIC	??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@		; `string'
PUBLIC	??_C@_0DLG@NNDEDDPH@This?5attribute?5is?5used?5to?5descri@ ; `string'
PUBLIC	??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@		; `string'
PUBLIC	??_C@_0CLK@PPHGAGLD@This?5attribute?5provides?5the?5valu@ ; `string'
PUBLIC	??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@	; `string'
PUBLIC	??_C@_0CE@JIOANCKI@?$CIDEP?$DN0?0MATRIX?$DN9?0DWT?$DN3?0MAT?$DN1000?$CJI@ ; `string'
PUBLIC	??_C@_0IIP@CHGEJKJG@This?5attribute?5provides?5one?5reco@ ; `string'
PUBLIC	??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@		; `string'
PUBLIC	??_C@_0MP@KPAJGLC@Illegal?5parameters?5supplied?5for?5@ ; `string'
PUBLIC	??_C@_0NA@EPMHNEKF@Illegal?5parameters?5supplied?5for?5@ ; `string'
PUBLIC	??_C@_0KN@DKKKLGFN@Malformed?5?$GAMstage_blocks?8?5attrib@ ; `string'
PUBLIC	??_C@_0BBC@MHOANFBM@Malformed?5?$GAMstage_blocks?8?5attrib@ ; `string'
PUBLIC	??_C@_0KK@DLAOAECJ@Malformed?5?$GAMstage_xforms?8?5attrib@ ; `string'
PUBLIC	??_C@_0KH@KFJPFAEH@Malformed?5?$GAMstage_xforms?8?5attrib@ ; `string'
PUBLIC	??_C@_0NL@PJCAENA@Malformed?5?$GAMstage_xforms?8?5attrib@ ; `string'
PUBLIC	??_C@_0LD@CNACCFCO@Malformed?5?$GAMstage_xforms?8?5attrib@ ; `string'
PUBLIC	??_C@_0BEB@BKBLPOMO@Encountered?5MCC?5?$CIMulti?9component@ ; `string'
PUBLIC	??_C@_0HM@HFEFAMNA@Malformed?5MCC?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0EI@NPIHMIKE@Malformed?5MCC?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0DF@LFIMCEFC@Malformed?5MCC?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0BIP@MNLLGAPJ@Unable?5to?5write?5MCC?5?$CIMulti?9compo@ ; `string'
PUBLIC	??_C@_0DJM@PGFFJOFI@You?5can?5no?5longer?5generate?5a?5cod@ ; `string'
PUBLIC	??_C@_03LCPIMAFA@MCO?$AA@			; `string'
PUBLIC	??_C@_0FCK@KEJNIDFA@Identifies?5the?5number?5of?5stages?5@ ; `string'
PUBLIC	??_C@_0M@BMJAMMCN@Mnum_stages?$AA@		; `string'
PUBLIC	??_C@_0BKE@DNMMMJKF@Provides?5?$GAMnum_stages?8?5records?0?5@ ; `string'
PUBLIC	??_C@_07CNNLMAHC@Mstages?$AA@			; `string'
PUBLIC	??_C@_0BCA@FMBIIPEN@Unable?5to?5modify?5the?5existing?5mu@ ; `string'
PUBLIC	??_C@_0JP@JHGJOPNH@You?5may?5not?5provide?5a?5value?5for?5@ ; `string'
PUBLIC	??_C@_0GN@BOBKGGGG@The?5number?5of?5records?5supplied?5f@ ; `string'
PUBLIC	??_C@_0DF@IOEIPGFI@Malformed?5MCO?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0EH@FMIBNLCC@Malformed?5MCO?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0EP@OLCFAFPF@Cannot?5write?5MCO?5marker?5segment?$DL@ ; `string'
PUBLIC	??_C@_0CGL@OFBGPMKE@This?5attribute?5determines?5how?5th@ ; `string'
PUBLIC	??_C@_0M@OFOCCDJH@Kreversible?$AA@		; `string'
PUBLIC	??_C@_0COP@MOCEJKKL@If?5true?0?5the?5transform?5kernel?5be@ ; `string'
PUBLIC	??_C@_0O@PBGDLPEF@?$CICON?$DN0?0SYM?$DN1?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CNF@DACPPFDL@Identifies?5the?5boundary?5extensio@ ; `string'
PUBLIC	??_C@_0L@JOGHAEOB@Kextension?$AA@		; `string'
PUBLIC	??_C@_04NENCGHGO@IIII?$AA@			; `string'
PUBLIC	??_C@_0DMN@NFEELAKF@Array?5with?5one?5entry?5for?5each?5li@ ; `string'
PUBLIC	??_C@_0CIE@OIBNHEMA@Holds?5the?5lifting?5coefficients?0?5@ ; `string'
PUBLIC	??_C@_0BIA@GBIBAJFK@Cannot?5transpose?5ATK?5marker?5segm@ ; `string'
PUBLIC	??_C@_0IK@HMACHLFE@You?5cannot?5provide?5custom?5transf@ ; `string'
PUBLIC	??_C@_0GB@HNGPDMEK@Incomplete?5?$GAKsteps?8?5record?5?$CIneed@ ; `string'
PUBLIC	??_C@_0IB@GILFGDAI@Invalid?5downshifting?5value?5?$CI3?8rd@ ; `string'
PUBLIC	??_C@_0IK@EBAJKINC@For?5irreversible?5transforms?5?$CI?$GAKr@ ; `string'
PUBLIC	??_C@_0LL@ICCFCJEB@Insufficient?5?$GAKcoeffs?8?5records?5f@ ; `string'
PUBLIC	??_C@_0LH@KFFJGFML@Too?5many?5?$GAKcoeffs?8?5records?5found@ ; `string'
PUBLIC	??_C@_0HP@IHFGAOCO@Reversible?5lifting?5steps?5defined@ ; `string'
PUBLIC	??_C@_0OH@MFIHEDLO@Invalid?5?$GAKsymmetric?8?5value?5found@ ; `string'
PUBLIC	??_C@_0GL@MACCMDJG@Cannot?5process?5ATK?5marker?5segmen@ ; `string'
PUBLIC	??_C@_0JJ@EJINJNCB@Malformed?5ATK?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0HD@HJBDDKNG@Cannot?5process?5ATK?5marker?5segmen@ ; `string'
PUBLIC	??_C@_0EI@CBNJBHNF@Malformed?5ATK?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0DF@MILOCDIO@Malformed?5ATK?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0DL@COILGNIP@Unable?5to?5write?5ATK?5marker?5segme@ ; `string'
PUBLIC	??_C@_0EC@DFOKDDOA@Cannot?5write?5ATK?5?$CIarbitrary?5tran@ ; `string'
PUBLIC	??_C@_0DI@KAHDNOFP@lifting?5steps?4?5?5Maximum?5number?5o@ ; `string'
PUBLIC	??_C@_0JK@FJJJODFB@Cannot?5write?5ATK?5?$CIarbitrary?5tran@ ; `string'
PUBLIC	??_C@_0JA@OGLNENPI@Cannot?5write?5ATK?5?$CIarbitrary?5tran@ ; `string'
PUBLIC	??_C@_03ELMDPBLM@QCD?$AA@			; `string'
PUBLIC	??_C@_0KP@IBLLLJAN@RGB?5to?5Luminance?9Chrominance?5con@ ; `string'
PUBLIC	??_C@_04DEPIIIHA@Cycc?$AA@			; `string'
PUBLIC	??_C@_0BA@NBBPEJNG@?$FLARRAY?$DN2?$HMDWT?$DN4?$FN?$AA@ ; `string'
PUBLIC	??_C@_0FCM@DHPAPCJF@This?5parameter?5should?5be?50?5unles@ ; `string'
PUBLIC	??_C@_04OOAAMMCO@Cmct?$AA@			; `string'
PUBLIC	??_C@_0EB@BJCCPLJM@Number?5of?5quality?5layers?4?5May?5no@ ; `string'
PUBLIC	??_C@_07BJCMAMHC@Clayers?$AA@			; `string'
PUBLIC	??_C@_0EK@NKHIFEB@Include?5SOP?5markers?5?$CIi?4e?4?0?5resyn@ ; `string'
PUBLIC	??_C@_08DAJNLNLL@Cuse_sop?$AA@			; `string'
PUBLIC	??_C@_0FG@HPJEBCAG@Include?5EPH?5markers?5?$CImarker?5end?5@ ; `string'
PUBLIC	??_C@_08NAIOMJOM@Cuse_eph?$AA@			; `string'
PUBLIC	??_C@_0CF@FILGKLGM@?$CILRCP?$DN0?0RLCP?$DN1?0RPCL?$DN2?0PCRL?$DN3?0CPR@ ; `string'
PUBLIC	??_C@_0BFK@PBIMDDLA@Default?5progression?5order?5?$CImay?5b@ ; `string'
PUBLIC	??_C@_06IKJBDDKO@Corder?$AA@			; `string'
PUBLIC	??_C@_02LBOPFCME@BB?$AA@			; `string'
PUBLIC	??_C@_0CAO@IFLBKBBI@If?5?$CCyes?$CC?0?5the?5code?9block?5partiti@ ; `string'
PUBLIC	??_C@_0FI@ILBHKDEJ@Number?5of?5wavelet?5decomposition?5@ ; `string'
PUBLIC	??_C@_0DCE@BCLFNHJE@Index?5of?5the?5ADS?5marker?5segment?5@ ; `string'
PUBLIC	??_C@_0DIF@JIOHBMHM@Index?5of?5the?5DFS?5marker?5segment?5@ ; `string'
PUBLIC	??_C@_0MDH@GKKAPHJL@Manages?5the?5information?5associat@ ; `string'
PUBLIC	??_C@_0JI@BJEOBCA@Reversible?5compression?$DP?6?7?7?$FLDefau@ ; `string'
PUBLIC	??_C@_0M@ODOOFFGJ@Creversible?$AA@		; `string'
PUBLIC	??_C@_0BH@OGDGPMGJ@?$CIW9X7?$DN0?0W5X3?$DN1?0ATK?$DN?91?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BDE@IGHHDMOK@Wavelet?5kernels?5to?5use?4?5?5The?5spe@ ; `string'
PUBLIC	??_C@_0CNA@EFIGBGL@A?5value?5of?50?5means?5that?5the?5DWT?5@ ; `string'
PUBLIC	??_C@_0HE@LHMCCMEI@Explicitly?5specify?5whether?5or?5no@ ; `string'
PUBLIC	??_C@_0BEJ@DFLAPAFH@Precinct?5dimensions?5?$CImust?5be?5pow@ ; `string'
PUBLIC	??_C@_0PA@DKDAIDMK@Nominal?5code?9block?5dimensions?5?$CIm@ ; `string'
PUBLIC	??_C@_04HAGFJFNL@Cblk?$AA@			; `string'
PUBLIC	??_C@_0DL@FGLGNEBO@?$FLBYPASS?$DN1?$HMRESET?$DN2?$HMRESTART?$DN4?$HMCAUS@ ; `string'
PUBLIC	??_C@_0GG@LCCKLEAC@Block?5coder?5mode?5switches?4?5Any?5c@ ; `string'
PUBLIC	??_C@_06EGDCPANH@Cmodes?$AA@			; `string'
PUBLIC	??_C@_0BHM@MPDDOEC@Multiplier?5for?5subband?5weighting@ ; `string'
PUBLIC	??_C@_07HDHNGJDI@Cweight?$AA@			; `string'
PUBLIC	??_C@_0CEE@FMHLHNCK@Weighting?5factors?5for?5each?5succe@ ; `string'
PUBLIC	??_C@_0N@HICBBPMC@Clev_weights?$AA@		; `string'
PUBLIC	??_C@_0FOI@OMMBBAAN@Weighting?5factors?5for?5each?5succe@ ; `string'
PUBLIC	??_C@_0O@GLALLHKC@Cband_weights?$AA@		; `string'
PUBLIC	??_C@_0HEO@NJIJCAOA@Maximum?5number?5of?5compressed?5byt@ ; `string'
PUBLIC	??_C@_0M@HKNEBDCB@Creslengths?$AA@		; `string'
PUBLIC	??_C@_0HE@NKGALBNL@Attempting?5to?5discard?5too?5many?5r@ ; `string'
PUBLIC	??_C@_0HD@OCHJAHPC@Unable?5to?5write?5COD?5marker?5segme@ ; `string'
PUBLIC	??_C@_0BLH@FGHKBOHC@Illegal?5combination?5of?5?$GAClevels?8@ ; `string'
PUBLIC	??_C@_0BEM@DMPFDMNO@Illegal?5combination?5of?5?$GAClevels?8@ ; `string'
PUBLIC	??_C@_0CD@EICILEGK@Illegal?5number?5of?5quality?5layers@ ; `string'
PUBLIC	??_C@_0BP@JIANFEOP@Illegal?5number?5of?5DWT?5levels?0?5?$AA@ ; `string'
PUBLIC	??_C@_0BK@GFANLIDL@?4?5Legal?5range?5is?50?5to?532?$CB?$AA@ ; `string'
PUBLIC	??_C@_0HM@DEKELPAG@You?5cannot?5use?5a?5Part?91?5colour?5t@ ; `string'
PUBLIC	??_C@_0JD@JKCKBNOF@You?5cannot?5use?5a?5colour?5transfor@ ; `string'
PUBLIC	??_C@_0NK@HPJJFAAC@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0LA@PCHBPKGD@Profile?5violation?5detected?4?5?5COD@ ; `string'
PUBLIC	??_C@_0BAB@INJJPFGA@About?5to?5write?5a?5component?9speci@ ; `string'
PUBLIC	??_C@_0BBG@KCPOGFOJ@Illegal?5?$GACkernels?8?5value?5found?5w@ ; `string'
PUBLIC	??_C@_0HN@HPMPNOPC@Illegal?5ATK?5instance?5index?5found@ ; `string'
PUBLIC	??_C@_0DD@IFOGDLHK@Maximum?5code?9block?5dimensions?5mu@ ; `string'
PUBLIC	??_C@_0HD@OIMMHFN@Maximum?5code?9block?5dimensions?5mu@ ; `string'
PUBLIC	??_C@_0CN@PBFFALNG@No?5precinct?5dimensions?5supplied?5@ ; `string'
PUBLIC	??_C@_0CP@INIGLHJN@Precinct?5dimensions?5must?5be?5exac@ ; `string'
PUBLIC	??_C@_0CJ@EGMBEELA@Precinct?5dimensions?5may?5not?5exce@ ; `string'
PUBLIC	??_C@_0EA@CJECMJPA@Malformed?5COD?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0EH@OJAEGGAB@Malformed?5COD?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0DE@LDDJFDOP@Malformed?5COC?5marker?5segment?4?5In@ ; `string'
PUBLIC	??_C@_0EH@CMJBHJJH@Malformed?5COC?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0DJ@BKGFKCIK@Malformed?5COD?1COC?5marker?5segment@ ; `string'
PUBLIC	??_C@_0EL@MEODJCKN@Malformed?5COD?1COC?5marker?5segment@ ; `string'
PUBLIC	??_C@_0GK@BLGJFPGL@?0?5detected?5by?5coding?5parameter?5s@ ; `string'
PUBLIC	??_C@_0HP@FAEJKEME@?0?5detected?5by?5coding?5parameter?5s@ ; `string'
PUBLIC	??_C@_03BLBGDEDA@ADS?$AA@			; `string'
PUBLIC	??_C@_0JP@NFJAKPFP@ADS?5table?5index?5encountered?5whil@ ; `string'
PUBLIC	??_C@_03CPEMBAGM@DFS?$AA@			; `string'
PUBLIC	??_C@_0JL@PNHEEPLI@DFS?5table?5index?5encountered?5whil@ ; `string'
PUBLIC	??_C@_0KB@HDNIPBLH@Unable?5to?5access?5the?5?$GAKreversibl@ ; `string'
PUBLIC	??_C@_0BAO@ECCKKNFO@Illegal?5?$GACkernels?8?5value?5found?5w@ ; `string'
PUBLIC	??_C@_0HE@FAOENAIF@Illegal?5ATK?5instance?5index?5found@ ; `string'
PUBLIC	??_C@_0BBC@GFMDHLNB@Profile?5violation?5detected?4?5?5The@ ; `string'
PUBLIC	??_C@_0KF@NKKOHPBE@Profile?5violation?5detected?4?5?5The@ ; `string'
PUBLIC	??_C@_0IK@BEGMJOLL@Profile?5violation?5detected?4?5?5Req@ ; `string'
PUBLIC	??_C@_0OO@FGOLANDB@Profile?5violation?5detected?4?5?5Req@ ; `string'
PUBLIC	??_C@_0DGO@NKGPBPEP@Profile?5violation?5may?5occur?5with@ ; `string'
PUBLIC	??_C@_0HC@OGIJFNLO@Profile?5violation?5detected?4?5?5The@ ; `string'
PUBLIC	??_C@_0BB@NIPBGPHB@?5levels?0?5though?4?$AA@	; `string'
PUBLIC	??_C@_0FM@FEAHACJA@Profile?5violation?5detected?4?5?5The@ ; `string'
PUBLIC	??_C@_0HC@MIEFLBEH@Profile?5violation?5detected?4?5?5The@ ; `string'
PUBLIC	??_C@_0BDN@MGKCOKBG@You?5are?5attempting?5to?5define?5a?5d@ ; `string'
PUBLIC	??_C@_07MCCNNBND@Ddecomp?$AA@			; `string'
PUBLIC	??_C@_05MIABAABB@DOads?$AA@			; `string'
PUBLIC	??_C@_05GNBBHKJC@DSads?$AA@			; `string'
PUBLIC	??_C@_05FJELFOMO@DSdfs?$AA@			; `string'
PUBLIC	??_C@_0BHK@LADFPGOB@Unacceptable?5interaction?5between@ ; `string'
PUBLIC	??_C@_0DH@CDDAMBJI@Encountered?5invalid?5terminal?5?$GACd@ ; `string'
PUBLIC	??_C@_04GPPIMOMJ@?$CC?4?5?5?$AA@		; `string'
PUBLIC	??_C@_0CKE@KBAACNPK@Terminal?5splitting?5styles?5must?5h@ ; `string'
PUBLIC	??_C@_0FO@DKHKMNAI@Incompatible?5?$GADSdfs?8?5and?5?$GACdecom@ ; `string'
PUBLIC	??_C@_0BHE@CMGODJOA@This?5attribute?5is?5ultimately?5set@ ; `string'
PUBLIC	??_C@_0BIG@MKJOPHKN@Number?5of?5sub?9levels?5in?5each?5suc@ ; `string'
PUBLIC	??_C@_0BC@GOBGDILI@?$CIX?$DN0?0H?$DN1?0V?$DN2?0B?$DN3?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CII@LBPCLNH@Array?5of?5splitting?5instructions?0@ ; `string'
PUBLIC	??_C@_0KK@HLPJKNOJ@The?5?$GADdecomp?8?5attribute?5may?5be?5d@ ; `string'
PUBLIC	??_C@_0CO@MBLLCAAI@Encountered?5invalid?5?$GADdecomp?8?5at@ ; `string'
PUBLIC	??_C@_04FOFDHDLH@?0?50x?$AA@			; `string'
PUBLIC	??_C@_0EH@JBFCFNFB@Malformed?5ADS?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0DF@KMABOOPE@Malformed?5ADS?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0DBH@IBFFCHEI@Describes?5the?5primary?5subband?5de@ ; `string'
PUBLIC	??_C@_0KI@NOLDCDIM@The?5?$GADSdfs?8?5attribute?5may?5be?5def@ ; `string'
PUBLIC	??_C@_0FI@CMPAFODD@Illegal?5?$GADSdfs?8?5attribute?5value?5@ ; `string'
PUBLIC	??_C@_0EH@IOANDJIM@Malformed?5DFS?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0DF@LFCOMKDP@Malformed?5DFS?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0IA@OLHAIOBI@Number?5of?5guard?5bits?5to?5prevent?5@ ; `string'
PUBLIC	??_C@_06BGIMBACE@Qguard?$AA@			; `string'
PUBLIC	??_C@_0BIH@EIAIGKMJ@Quantization?5steps?5derived?5from?5@ ; `string'
PUBLIC	??_C@_08CCOBJCLJ@Qderived?$AA@			; `string'
PUBLIC	??_C@_0KK@JJMLLFOI@Base?5step?5size?5to?5be?5used?5in?5der@ ; `string'
PUBLIC	??_C@_05LCODFIOH@Qstep?$AA@			; `string'
PUBLIC	??_C@_0DLI@DECHONMD@Absolute?5quantization?5step?5sizes@ ; `string'
PUBLIC	??_C@_0DGG@FMKFADLL@Number?5of?5range?5bits?5used?5to?5cod@ ; `string'
PUBLIC	??_C@_0FL@MPLKHCGE@Cannot?5write?5QCD?1QCC?5marker?5segm@ ; `string'
PUBLIC	??_C@_0EA@FNJKHCGL@Cannot?5write?5QCD?1QCC?5marker?5segm@ ; `string'
PUBLIC	??_C@_0HA@COCFLGOG@Cannot?5write?5QCD?1QCC?5marker?5segm@ ; `string'
PUBLIC	??_C@_0FP@CMAJFDH@Cannot?5write?5QCD?1QCC?5marker?5segm@ ; `string'
PUBLIC	??_C@_0GB@PFKIFKOG@Cannot?5write?5QCD?1QCC?5marker?5segm@ ; `string'
PUBLIC	??_C@_0FI@LONAPNHG@Cannot?5write?5QCD?1QCC?5marker?5segm@ ; `string'
PUBLIC	??_C@_0BP@OIAJENOM@Illegal?5number?5of?5guard?5bits?0?5?$AA@ ; `string'
PUBLIC	??_C@_0BO@CHOCCCME@?4?5Legal?5range?5is?5from?50?5to?57?4?$AA@ ; `string'
PUBLIC	??_C@_0NK@HGFFBJED@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0LA@JJEBFCFM@Profile?5violation?5detected?4?5?5QCD@ ; `string'
PUBLIC	??_C@_0FG@JFODLLGA@Insufficient?5absolute?5ranging?5pa@ ; `string'
PUBLIC	??_C@_0GI@PNGCMGM@Absolute?5ranging?5parameters?5for?5@ ; `string'
PUBLIC	??_C@_0GG@CKIKGBGG@Insufficient?5absolute?5quantizati@ ; `string'
PUBLIC	??_C@_0DG@NCOMABPP@Undefined?5style?5byte?5found?5in?5QC@ ; `string'
PUBLIC	??_C@_0EL@LJBJPKLN@Malformed?5QCD?1QCC?5marker?5segment@ ; `string'
PUBLIC	??_C@_0DJ@EBJLBPEO@Malformed?5QCD?1QCC?5marker?5segment@ ; `string'
PUBLIC	??_C@_0JH@IGLAJBAL@Trying?5to?5finalize?5quantization?5@ ; `string'
PUBLIC	??_C@_0BBO@GCINCGGG@Some?5absolute?5step?5sizes?5which?5y@ ; `string'
PUBLIC	??_C@_03KEJABOAE@RGN?$AA@			; `string'
PUBLIC	??_C@_0CHI@HKJBINKE@Region?5of?5interest?5up?9shift?5valu@ ; `string'
PUBLIC	??_C@_06LDAKCIBF@Rshift?$AA@			; `string'
PUBLIC	??_C@_0BBM@FGPIIKPE@Number?5of?5initial?5?$CIhighest?5frequ@ ; `string'
PUBLIC	??_C@_07KGEEGGHK@Rlevels?$AA@			; `string'
PUBLIC	??_C@_0DBK@IHBAFPAL@Region?5of?5interest?5significance?5@ ; `string'
PUBLIC	??_C@_07MDGMFIIN@Rweight?$AA@			; `string'
PUBLIC	??_C@_0BH@MGDBKNNO@Illegal?5ROI?5up?9shift?0?5?$AA@ ; `string'
PUBLIC	??_C@_0CA@JLDBBJDK@?4?5Legal?5range?5is?5from?50?5to?5255?$CB?$AA@ ; `string'
PUBLIC	??_C@_0JH@FLFHNCLL@Profile?5violation?5detected?4?5?5RGN@ ; `string'
PUBLIC	??_C@_0CK@MFEGEGLF@Encountered?5non?9Part1?5RGN?5marker@ ; `string'
PUBLIC	??_C@_0DF@HODFHOAP@Malformed?5RGN?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0EH@OLOKKCBP@Malformed?5RGN?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0HN@DAMJBHKE@Up?9shift?5values?5in?5the?5RGN?5marke@ ; `string'
PUBLIC	??_C@_0CD@DOBDENMB@?5in?5this?5case?0?5may?5cause?5problem@ ; `string'
PUBLIC	??_C@_0CK@KBNJDDCF@IIIII?$CILRCP?$DN0?0RLCP?$DN1?0RPCL?$DN2?0PCRL?$DN@ ; `string'
PUBLIC	??_C@_0EPM@KNAANCKO@Progression?5order?5change?5informa@ ; `string'
PUBLIC	??_C@_0EM@NECPBKCJ@Information?5required?5to?5write?5PO@ ; `string'
PUBLIC	??_C@_0MI@GKHFMGFB@Profile?5violation?5detected?4?5?5POC@ ; `string'
PUBLIC	??_C@_0PF@DBCFCBGN@Profile?5violation?5detected?4?5?5POC@ ; `string'
PUBLIC	??_C@_0BG@CGBIAPKK@Illegal?5lower?5bound?0?5?$AA@ ; `string'
PUBLIC	??_C@_0GE@OHOJBMOK@?0?5for?5resolution?5level?5indices?5i@ ; `string'
PUBLIC	??_C@_0CC@GBMHHECB@Illegal?5upper?5bound?5?$CIexclusive?$CJ?0@ ; `string'
PUBLIC	??_C@_0HG@EBOPONFH@?0?5for?5resolution?5level?5indices?5i@ ; `string'
PUBLIC	??_C@_0FK@PKCGAEDD@?0?5for?5component?5indices?5in?5progr@ ; `string'
PUBLIC	??_C@_0GM@ILNCJPIC@?0?5for?5component?5indices?5in?5progr@ ; `string'
PUBLIC	??_C@_0FG@HKJPGEGC@?0?5for?5layer?5indices?5in?5progressi@ ; `string'
PUBLIC	??_C@_0DF@CKFKOFOF@Malformed?5POC?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0EH@BLNGGECC@Malformed?5POC?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_03IHBKPECM@CRG?$AA@			; `string'
PUBLIC	??_C@_02NCIKDPBM@FF?$AA@			; `string'
PUBLIC	??_C@_0CHB@BGCOENBE@Provides?5additional?5component?5re@ ; `string'
PUBLIC	??_C@_09NPOAGBMD@CRGoffset?$AA@			; `string'
PUBLIC	??_C@_0CP@EMDHCGDH@Component?5registration?5informati@ ; `string'
PUBLIC	??_C@_0CK@GJEKKMBC@Illegal?5component?5registration?5o@ ; `string'
PUBLIC	??_C@_0DA@KDCPJNDM@?$HN?4?5?5Legal?5range?5is?5from?50?40?5to?51@ ; `string'
PUBLIC	??_C@_0DF@NCKAKJE@Malformed?5CRG?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0EH@POKFGLCF@Malformed?5CRG?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0O@PEKBJBJM@?$FLR?$DN1?$HML?$DN2?$HMC?$DN4?$FN?$AA@ ; `string'
PUBLIC	??_C@_0DHD@FDALIENE@Controls?5the?5division?5of?5each?5ti@ ; `string'
PUBLIC	??_C@_0CLF@KMEJMICF@Requests?5the?5insertion?5of?5packet@ ; `string'
PUBLIC	??_C@_0L@DMGGEJHL@ORGgen_plt?$AA@		; `string'
PUBLIC	??_C@_0FAH@DOOOICPM@Requests?5the?5insertion?5of?5TLM?5?$CIt@ ; `string'
PUBLIC	??_R4kdu_params@@6B@				; kdu_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_params@@@8				; kdu_params `RTTI Type Descriptor'
PUBLIC	??_R3kdu_params@@8				; kdu_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_params@@8				; kdu_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_params@@8			; kdu_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4siz_params@@6B@				; siz_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVsiz_params@@@8				; siz_params `RTTI Type Descriptor'
PUBLIC	??_R3siz_params@@8				; siz_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2siz_params@@8				; siz_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@siz_params@@8			; siz_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4mct_params@@6B@				; mct_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVmct_params@@@8				; mct_params `RTTI Type Descriptor'
PUBLIC	??_R3mct_params@@8				; mct_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2mct_params@@8				; mct_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@mct_params@@8			; mct_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4mcc_params@@6B@				; mcc_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVmcc_params@@@8				; mcc_params `RTTI Type Descriptor'
PUBLIC	??_R3mcc_params@@8				; mcc_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2mcc_params@@8				; mcc_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@mcc_params@@8			; mcc_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4mco_params@@6B@				; mco_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVmco_params@@@8				; mco_params `RTTI Type Descriptor'
PUBLIC	??_R3mco_params@@8				; mco_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2mco_params@@8				; mco_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@mco_params@@8			; mco_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4atk_params@@6B@				; atk_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVatk_params@@@8				; atk_params `RTTI Type Descriptor'
PUBLIC	??_R3atk_params@@8				; atk_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2atk_params@@8				; atk_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@atk_params@@8			; atk_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4cod_params@@6B@				; cod_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVcod_params@@@8				; cod_params `RTTI Type Descriptor'
PUBLIC	??_R3cod_params@@8				; cod_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2cod_params@@8				; cod_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@cod_params@@8			; cod_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ads_params@@6B@				; ads_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVads_params@@@8				; ads_params `RTTI Type Descriptor'
PUBLIC	??_R3ads_params@@8				; ads_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ads_params@@8				; ads_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ads_params@@8			; ads_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4dfs_params@@6B@				; dfs_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVdfs_params@@@8				; dfs_params `RTTI Type Descriptor'
PUBLIC	??_R3dfs_params@@8				; dfs_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2dfs_params@@8				; dfs_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@dfs_params@@8			; dfs_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4qcd_params@@6B@				; qcd_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVqcd_params@@@8				; qcd_params `RTTI Type Descriptor'
PUBLIC	??_R3qcd_params@@8				; qcd_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2qcd_params@@8				; qcd_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@qcd_params@@8			; qcd_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4rgn_params@@6B@				; rgn_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVrgn_params@@@8				; rgn_params `RTTI Type Descriptor'
PUBLIC	??_R3rgn_params@@8				; rgn_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2rgn_params@@8				; rgn_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@rgn_params@@8			; rgn_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4poc_params@@6B@				; poc_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVpoc_params@@@8				; poc_params `RTTI Type Descriptor'
PUBLIC	??_R3poc_params@@8				; poc_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2poc_params@@8				; poc_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@poc_params@@8			; poc_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4crg_params@@6B@				; crg_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVcrg_params@@@8				; crg_params `RTTI Type Descriptor'
PUBLIC	??_R3crg_params@@8				; crg_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2crg_params@@8				; crg_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@crg_params@@8			; crg_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4org_params@@6B@				; org_params::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVorg_params@@@8				; org_params `RTTI Type Descriptor'
PUBLIC	??_R3org_params@@8				; org_params::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2org_params@@8				; org_params::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@org_params@@8			; org_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	___isa_available_default
PUBLIC	__real@37800000
PUBLIC	__real@38d1b717
PUBLIC	__real@3a000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f70000000000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fecccccc0000000
PUBLIC	__real@3feff7ced916872b
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff004189374bc6a
PUBLIC	__real@40000000
PUBLIC	__real@45000000
PUBLIC	__real@47800000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	___report_rangecheckfailure:PROC
EXTRN	___std_terminate:PROC
EXTRN	__imp__strtod:PROC
EXTRN	__imp__strtol:PROC
EXTRN	__imp__strchr:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	??0kdu_error@@QAE@PBD@Z:PROC			; kdu_error::kdu_error
EXTRN	??1kdu_error@@UAE@XZ:PROC			; kdu_error::~kdu_error
EXTRN	??0kdu_warning@@QAE@PBD@Z:PROC			; kdu_warning::kdu_warning
EXTRN	??1kdu_warning@@UAE@XZ:PROC			; kdu_warning::~kdu_warning
EXTRN	??_Esiz_params@@UAEPAXI@Z:PROC			; siz_params::`vector deleting destructor'
EXTRN	??_Emct_params@@UAEPAXI@Z:PROC			; mct_params::`vector deleting destructor'
EXTRN	??_Emcc_params@@UAEPAXI@Z:PROC			; mcc_params::`vector deleting destructor'
EXTRN	??_Emco_params@@UAEPAXI@Z:PROC			; mco_params::`vector deleting destructor'
EXTRN	??_Eatk_params@@UAEPAXI@Z:PROC			; atk_params::`vector deleting destructor'
EXTRN	??_Ecod_params@@UAEPAXI@Z:PROC			; cod_params::`vector deleting destructor'
EXTRN	??_Eads_params@@UAEPAXI@Z:PROC			; ads_params::`vector deleting destructor'
EXTRN	??_Edfs_params@@UAEPAXI@Z:PROC			; dfs_params::`vector deleting destructor'
EXTRN	??_Eqcd_params@@UAEPAXI@Z:PROC			; qcd_params::`vector deleting destructor'
EXTRN	??_Ergn_params@@UAEPAXI@Z:PROC			; rgn_params::`vector deleting destructor'
EXTRN	??_Epoc_params@@UAEPAXI@Z:PROC			; poc_params::`vector deleting destructor'
EXTRN	??_Ecrg_params@@UAEPAXI@Z:PROC			; crg_params::`vector deleting destructor'
EXTRN	??_Eorg_params@@UAEPAXI@Z:PROC			; org_params::`vector deleting destructor'
EXTRN	?init@kdu_kernels@@QAEXH_N@Z:PROC		; kdu_kernels::init
EXTRN	?init@kdu_kernels@@QAEXHPBUkdu_kernel_step_info@@PBM_N22@Z:PROC ; kdu_kernels::init
EXTRN	?get_energy_gain@kdu_kernels@@QAENHHQA_N@Z:PROC	; kdu_kernels::get_energy_gain
EXTRN	?get_bibo_gain@kdu_kernels@@QAENHHQA_N@Z:PROC	; kdu_kernels::get_bibo_gain
EXTRN	?clear@kdu_kernels@@AAEXXZ:PROC			; kdu_kernels::clear
EXTRN	?reset@kdu_kernels@@AAEXXZ:PROC			; kdu_kernels::reset
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	_floor:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___isa_available:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ___isa_available_default
_BSS	SEGMENT
___isa_available_default DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@47800000
CONST	SEGMENT
__real@47800000 DD 047800000r			; 65536
CONST	ENDS
;	COMDAT __real@45000000
CONST	SEGMENT
__real@45000000 DD 045000000r			; 2048
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff004189374bc6a
CONST	SEGMENT
__real@3ff004189374bc6a DQ 03ff004189374bc6ar	; 1.001
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3feff7ced916872b
CONST	SEGMENT
__real@3feff7ced916872b DQ 03feff7ced916872br	; 0.999
CONST	ENDS
;	COMDAT __real@3fecccccc0000000
CONST	SEGMENT
__real@3fecccccc0000000 DQ 03fecccccc0000000r	; 0.9
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f70000000000000
CONST	SEGMENT
__real@3f70000000000000 DQ 03f70000000000000r	; 0.00390625
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3a000000
CONST	SEGMENT
__real@3a000000 DD 03a000000r			; 0.000488281
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@37800000
CONST	SEGMENT
__real@37800000 DD 037800000r			; 1.52588e-05
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@org_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@org_params@@8 DD FLAT:??_R0?AVorg_params@@@8 ; org_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3org_params@@8
rdata$r	ENDS
;	COMDAT ??_R2org_params@@8
rdata$r	SEGMENT
??_R2org_params@@8 DD FLAT:??_R1A@?0A@EA@org_params@@8	; org_params::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R3org_params@@8
rdata$r	SEGMENT
??_R3org_params@@8 DD 00H				; org_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2org_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVorg_params@@@8
data$r	SEGMENT
??_R0?AVorg_params@@@8 DD FLAT:??_7type_info@@6B@	; org_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVorg_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4org_params@@6B@
rdata$r	SEGMENT
??_R4org_params@@6B@ DD 00H				; org_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVorg_params@@@8
	DD	FLAT:??_R3org_params@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@crg_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@crg_params@@8 DD FLAT:??_R0?AVcrg_params@@@8 ; crg_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3crg_params@@8
rdata$r	ENDS
;	COMDAT ??_R2crg_params@@8
rdata$r	SEGMENT
??_R2crg_params@@8 DD FLAT:??_R1A@?0A@EA@crg_params@@8	; crg_params::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R3crg_params@@8
rdata$r	SEGMENT
??_R3crg_params@@8 DD 00H				; crg_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2crg_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcrg_params@@@8
data$r	SEGMENT
??_R0?AVcrg_params@@@8 DD FLAT:??_7type_info@@6B@	; crg_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcrg_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4crg_params@@6B@
rdata$r	SEGMENT
??_R4crg_params@@6B@ DD 00H				; crg_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcrg_params@@@8
	DD	FLAT:??_R3crg_params@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@poc_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@poc_params@@8 DD FLAT:??_R0?AVpoc_params@@@8 ; poc_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3poc_params@@8
rdata$r	ENDS
;	COMDAT ??_R2poc_params@@8
rdata$r	SEGMENT
??_R2poc_params@@8 DD FLAT:??_R1A@?0A@EA@poc_params@@8	; poc_params::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R3poc_params@@8
rdata$r	SEGMENT
??_R3poc_params@@8 DD 00H				; poc_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2poc_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVpoc_params@@@8
data$r	SEGMENT
??_R0?AVpoc_params@@@8 DD FLAT:??_7type_info@@6B@	; poc_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVpoc_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4poc_params@@6B@
rdata$r	SEGMENT
??_R4poc_params@@6B@ DD 00H				; poc_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVpoc_params@@@8
	DD	FLAT:??_R3poc_params@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@rgn_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@rgn_params@@8 DD FLAT:??_R0?AVrgn_params@@@8 ; rgn_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3rgn_params@@8
rdata$r	ENDS
;	COMDAT ??_R2rgn_params@@8
rdata$r	SEGMENT
??_R2rgn_params@@8 DD FLAT:??_R1A@?0A@EA@rgn_params@@8	; rgn_params::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R3rgn_params@@8
rdata$r	SEGMENT
??_R3rgn_params@@8 DD 00H				; rgn_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2rgn_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVrgn_params@@@8
data$r	SEGMENT
??_R0?AVrgn_params@@@8 DD FLAT:??_7type_info@@6B@	; rgn_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVrgn_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4rgn_params@@6B@
rdata$r	SEGMENT
??_R4rgn_params@@6B@ DD 00H				; rgn_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVrgn_params@@@8
	DD	FLAT:??_R3rgn_params@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@qcd_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@qcd_params@@8 DD FLAT:??_R0?AVqcd_params@@@8 ; qcd_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3qcd_params@@8
rdata$r	ENDS
;	COMDAT ??_R2qcd_params@@8
rdata$r	SEGMENT
??_R2qcd_params@@8 DD FLAT:??_R1A@?0A@EA@qcd_params@@8	; qcd_params::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R3qcd_params@@8
rdata$r	SEGMENT
??_R3qcd_params@@8 DD 00H				; qcd_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2qcd_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVqcd_params@@@8
data$r	SEGMENT
??_R0?AVqcd_params@@@8 DD FLAT:??_7type_info@@6B@	; qcd_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVqcd_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4qcd_params@@6B@
rdata$r	SEGMENT
??_R4qcd_params@@6B@ DD 00H				; qcd_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVqcd_params@@@8
	DD	FLAT:??_R3qcd_params@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@dfs_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@dfs_params@@8 DD FLAT:??_R0?AVdfs_params@@@8 ; dfs_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3dfs_params@@8
rdata$r	ENDS
;	COMDAT ??_R2dfs_params@@8
rdata$r	SEGMENT
??_R2dfs_params@@8 DD FLAT:??_R1A@?0A@EA@dfs_params@@8	; dfs_params::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R3dfs_params@@8
rdata$r	SEGMENT
??_R3dfs_params@@8 DD 00H				; dfs_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2dfs_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVdfs_params@@@8
data$r	SEGMENT
??_R0?AVdfs_params@@@8 DD FLAT:??_7type_info@@6B@	; dfs_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVdfs_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4dfs_params@@6B@
rdata$r	SEGMENT
??_R4dfs_params@@6B@ DD 00H				; dfs_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVdfs_params@@@8
	DD	FLAT:??_R3dfs_params@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ads_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ads_params@@8 DD FLAT:??_R0?AVads_params@@@8 ; ads_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ads_params@@8
rdata$r	ENDS
;	COMDAT ??_R2ads_params@@8
rdata$r	SEGMENT
??_R2ads_params@@8 DD FLAT:??_R1A@?0A@EA@ads_params@@8	; ads_params::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R3ads_params@@8
rdata$r	SEGMENT
??_R3ads_params@@8 DD 00H				; ads_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ads_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVads_params@@@8
data$r	SEGMENT
??_R0?AVads_params@@@8 DD FLAT:??_7type_info@@6B@	; ads_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVads_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4ads_params@@6B@
rdata$r	SEGMENT
??_R4ads_params@@6B@ DD 00H				; ads_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVads_params@@@8
	DD	FLAT:??_R3ads_params@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@cod_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@cod_params@@8 DD FLAT:??_R0?AVcod_params@@@8 ; cod_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3cod_params@@8
rdata$r	ENDS
;	COMDAT ??_R2cod_params@@8
rdata$r	SEGMENT
??_R2cod_params@@8 DD FLAT:??_R1A@?0A@EA@cod_params@@8	; cod_params::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R3cod_params@@8
rdata$r	SEGMENT
??_R3cod_params@@8 DD 00H				; cod_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2cod_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcod_params@@@8
data$r	SEGMENT
??_R0?AVcod_params@@@8 DD FLAT:??_7type_info@@6B@	; cod_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcod_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4cod_params@@6B@
rdata$r	SEGMENT
??_R4cod_params@@6B@ DD 00H				; cod_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcod_params@@@8
	DD	FLAT:??_R3cod_params@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@atk_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@atk_params@@8 DD FLAT:??_R0?AVatk_params@@@8 ; atk_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3atk_params@@8
rdata$r	ENDS
;	COMDAT ??_R2atk_params@@8
rdata$r	SEGMENT
??_R2atk_params@@8 DD FLAT:??_R1A@?0A@EA@atk_params@@8	; atk_params::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R3atk_params@@8
rdata$r	SEGMENT
??_R3atk_params@@8 DD 00H				; atk_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2atk_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVatk_params@@@8
data$r	SEGMENT
??_R0?AVatk_params@@@8 DD FLAT:??_7type_info@@6B@	; atk_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVatk_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4atk_params@@6B@
rdata$r	SEGMENT
??_R4atk_params@@6B@ DD 00H				; atk_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVatk_params@@@8
	DD	FLAT:??_R3atk_params@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@mco_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@mco_params@@8 DD FLAT:??_R0?AVmco_params@@@8 ; mco_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3mco_params@@8
rdata$r	ENDS
;	COMDAT ??_R2mco_params@@8
rdata$r	SEGMENT
??_R2mco_params@@8 DD FLAT:??_R1A@?0A@EA@mco_params@@8	; mco_params::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R3mco_params@@8
rdata$r	SEGMENT
??_R3mco_params@@8 DD 00H				; mco_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2mco_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVmco_params@@@8
data$r	SEGMENT
??_R0?AVmco_params@@@8 DD FLAT:??_7type_info@@6B@	; mco_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVmco_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4mco_params@@6B@
rdata$r	SEGMENT
??_R4mco_params@@6B@ DD 00H				; mco_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVmco_params@@@8
	DD	FLAT:??_R3mco_params@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@mcc_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@mcc_params@@8 DD FLAT:??_R0?AVmcc_params@@@8 ; mcc_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3mcc_params@@8
rdata$r	ENDS
;	COMDAT ??_R2mcc_params@@8
rdata$r	SEGMENT
??_R2mcc_params@@8 DD FLAT:??_R1A@?0A@EA@mcc_params@@8	; mcc_params::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R3mcc_params@@8
rdata$r	SEGMENT
??_R3mcc_params@@8 DD 00H				; mcc_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2mcc_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVmcc_params@@@8
data$r	SEGMENT
??_R0?AVmcc_params@@@8 DD FLAT:??_7type_info@@6B@	; mcc_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVmcc_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4mcc_params@@6B@
rdata$r	SEGMENT
??_R4mcc_params@@6B@ DD 00H				; mcc_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVmcc_params@@@8
	DD	FLAT:??_R3mcc_params@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@mct_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@mct_params@@8 DD FLAT:??_R0?AVmct_params@@@8 ; mct_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3mct_params@@8
rdata$r	ENDS
;	COMDAT ??_R2mct_params@@8
rdata$r	SEGMENT
??_R2mct_params@@8 DD FLAT:??_R1A@?0A@EA@mct_params@@8	; mct_params::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R3mct_params@@8
rdata$r	SEGMENT
??_R3mct_params@@8 DD 00H				; mct_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2mct_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVmct_params@@@8
data$r	SEGMENT
??_R0?AVmct_params@@@8 DD FLAT:??_7type_info@@6B@	; mct_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVmct_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4mct_params@@6B@
rdata$r	SEGMENT
??_R4mct_params@@6B@ DD 00H				; mct_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVmct_params@@@8
	DD	FLAT:??_R3mct_params@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@siz_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@siz_params@@8 DD FLAT:??_R0?AVsiz_params@@@8 ; siz_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3siz_params@@8
rdata$r	ENDS
;	COMDAT ??_R2siz_params@@8
rdata$r	SEGMENT
??_R2siz_params@@8 DD FLAT:??_R1A@?0A@EA@siz_params@@8	; siz_params::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R3siz_params@@8
rdata$r	SEGMENT
??_R3siz_params@@8 DD 00H				; siz_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2siz_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVsiz_params@@@8
data$r	SEGMENT
??_R0?AVsiz_params@@@8 DD FLAT:??_7type_info@@6B@	; siz_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsiz_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4siz_params@@6B@
rdata$r	SEGMENT
??_R4siz_params@@6B@ DD 00H				; siz_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsiz_params@@@8
	DD	FLAT:??_R3siz_params@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_params@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_params@@8 DD FLAT:??_R0?AVkdu_params@@@8 ; kdu_params::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_params@@8
rdata$r	SEGMENT
??_R2kdu_params@@8 DD FLAT:??_R1A@?0A@EA@kdu_params@@8	; kdu_params::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_params@@8
rdata$r	SEGMENT
??_R3kdu_params@@8 DD 00H				; kdu_params::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_params@@@8
data$r	SEGMENT
??_R0?AVkdu_params@@@8 DD FLAT:??_7type_info@@6B@	; kdu_params `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_params@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_params@@6B@
rdata$r	SEGMENT
??_R4kdu_params@@6B@ DD 00H				; kdu_params::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_params@@@8
	DD	FLAT:??_R3kdu_params@@8
rdata$r	ENDS
;	COMDAT ??_C@_0FAH@DOOOICPM@Requests?5the?5insertion?5of?5TLM?5?$CIt@
CONST	SEGMENT
??_C@_0FAH@DOOOICPM@Requests?5the?5insertion?5of?5TLM?5?$CIt@ DB 'Request'
	DB	's the insertion of TLM (tile-part-length) marker segments in '
	DB	'the main header, to facilitate random access to the code-stre'
	DB	'am.  This attribute takes a single integer-valued parameter, '
	DB	'which identifies the maximum number of tile-parts which will '
	DB	'be written to the code-stream for each tile.  The reason for '
	DB	'including this parameter is that space for the TLM informatio'
	DB	'n must be reserved ahead of time; once the entire code-stream'
	DB	' has been written the generation machinery goes back and over'
	DB	'writes this reserved space with actual TLM data.  If the actu'
	DB	'al number of tile-parts which are generate is less than the v'
	DB	'alue supplied here, empty tile-parts will be inserted into th'
	DB	'e code-stream so as to use up all of the reserved TLM space. '
	DB	' For this reason, you should try to estimate the maximum numb'
	DB	'er of tile-parts you will need as accurately as possible, not'
	DB	'ing that the actual value may be hard to determine ahead of t'
	DB	'ime if incremental flushing features are to be employed.  In '
	DB	'any event, no JPEG2000 code-stream may have more than 255 til'
	DB	'e-parts.  An error will be generated at run-time if the decla'
	DB	'red maximum number of tile-parts turns out to be insufficient'
	DB	'.  You should note that this attribute may be ignored if the '
	DB	'target device does not support repositioning functionality.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMGGEJHL@ORGgen_plt?$AA@
CONST	SEGMENT
??_C@_0L@DMGGEJHL@ORGgen_plt?$AA@ DB 'ORGgen_plt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CLF@KMEJMICF@Requests?5the?5insertion?5of?5packet@
CONST	SEGMENT
??_C@_0CLF@KMEJMICF@Requests?5the?5insertion?5of?5packet@ DB 'Requests th'
	DB	'e insertion of packet length information in the header of all'
	DB	' tile-parts associated with tiles for which this attribute is'
	DB	' turned on (has a value of "yes").  The PLT marker segments w'
	DB	'ritten into the relevant tile-part headers will hold the leng'
	DB	'ths of those packets which belong to the same tile-part.  Not'
	DB	'e that the cost of any PLT marker segments generated as a res'
	DB	'ult of this attribute being enabled will not be taken into ac'
	DB	'count during rate allocation.  This means that the resulting '
	DB	'code-streams will generally be a little larger than one might'
	DB	' expect; however, this is probably a reasonable policy, since'
	DB	' the PLT marker segments may be removed without losing any in'
	DB	'formation.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DHD@FDALIENE@Controls?5the?5division?5of?5each?5ti@
CONST	SEGMENT
??_C@_0DHD@FDALIENE@Controls?5the?5division?5of?5each?5ti@ DB 'Controls t'
	DB	'he division of each tile''s packets into tile-parts.  The att'
	DB	'ribute consists of one or more of the flags, `R'', `L'' and `'
	DB	'C'', separated by the vertical bar character, `|''.  If the `'
	DB	'R'' flag is supplied, tile-parts will be introduced as necess'
	DB	'ary to ensure that each tile-part consists of packets from on'
	DB	'ly one resolution level.  If `L'' is supplied, tile-parts are'
	DB	' introduced as necessary to ensure that each tile-part consis'
	DB	'ts of packets from only one quality layer.  Similarly, if the'
	DB	' `C'' flag is supplied, each tile-part will consist of packet'
	DB	's from only one component.  Note that the cost of extra tile-'
	DB	'part headers will not be taken into account during rate contr'
	DB	'ol, so that the code-stream may end up being a little larger '
	DB	'than you expect.', 0aH, 09H, 09H, '[By default, tile-part bou'
	DB	'ndaries are introduced only as required by the presence of mu'
	DB	'ltiple "Porder" attribute specifications.]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PEKBJBJM@?$FLR?$DN1?$HML?$DN2?$HMC?$DN4?$FN?$AA@
CONST	SEGMENT
??_C@_0O@PEKBJBJM@?$FLR?$DN1?$HML?$DN2?$HMC?$DN4?$FN?$AA@ DB '[R=1|L=2|C='
	DB	'4]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@POKFGLCF@Malformed?5CRG?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EH@POKFGLCF@Malformed?5CRG?5marker?5segment?5enc@ DB 'Malformed CR'
	DB	'G marker segment encountered. Marker segment is too small.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NCKAKJE@Malformed?5CRG?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0DF@NCKAKJE@Malformed?5CRG?5marker?5segment?5enc@ DB 'Malformed CRG'
	DB	' marker segment encountered. The final ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KDCPJNDM@?$HN?4?5?5Legal?5range?5is?5from?50?40?5to?51@
CONST	SEGMENT
??_C@_0DA@KDCPJNDM@?$HN?4?5?5Legal?5range?5is?5from?50?40?5to?51@ DB '}. '
	DB	' Legal range is from 0.0 to 1.0 (exclusive).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GJEKKMBC@Illegal?5component?5registration?5o@
CONST	SEGMENT
??_C@_0CK@GJEKKMBC@Illegal?5component?5registration?5o@ DB 'Illegal compo'
	DB	'nent registration offsets, {', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@EMDHCGDH@Component?5registration?5informati@
CONST	SEGMENT
??_C@_0CP@EMDHCGDH@Component?5registration?5informati@ DB 'Component regi'
	DB	'stration information incomplete!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NPOAGBMD@CRGoffset?$AA@
CONST	SEGMENT
??_C@_09NPOAGBMD@CRGoffset?$AA@ DB 'CRGoffset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CHB@BGCOENBE@Provides?5additional?5component?5re@
CONST	SEGMENT
??_C@_0CHB@BGCOENBE@Provides?5additional?5component?5re@ DB 'Provides add'
	DB	'itional component registration offsets. The offsets add to th'
	DB	'ose implied by the canvas coordinate system and should only b'
	DB	'e used when canvas coordinates (notably `Ssize'', `Soffset'' '
	DB	'and `Ssampling'') cannot be found, which adequately reflect t'
	DB	'he relative displacement of the components. Each record speci'
	DB	'fies offsets for one component, with the vertical offset appe'
	DB	'aring first. Offsets must be in the range 0 (inclusive) to 1 '
	DB	'(exclusive) and represent a fraction of the relevant componen'
	DB	't sub-sampling factor (see `Ssampling''). The last supplied r'
	DB	'ecord is repeated as needed to recover offsets for all compon'
	DB	'ents. ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02NCIKDPBM@FF?$AA@
CONST	SEGMENT
??_C@_02NCIKDPBM@FF?$AA@ DB 'FF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IHBKPECM@CRG?$AA@
CONST	SEGMENT
??_C@_03IHBKPECM@CRG?$AA@ DB 'CRG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@BLNGGECC@Malformed?5POC?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EH@BLNGGECC@Malformed?5POC?5marker?5segment?5enc@ DB 'Malformed PO'
	DB	'C marker segment encountered. Marker segment is too small.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CKFKOFOF@Malformed?5POC?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0DF@CKFKOFOF@Malformed?5POC?5marker?5segment?5enc@ DB 'Malformed PO'
	DB	'C marker segment encountered. The final ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@HKJPGEGC@?0?5for?5layer?5indices?5in?5progressi@
CONST	SEGMENT
??_C@_0FG@HKJPGEGC@?0?5for?5layer?5indices?5in?5progressi@ DB ', for laye'
	DB	'r indices in progression order change attribute.  Legal range'
	DB	' is from 0 to ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@ILNCJPIC@?0?5for?5component?5indices?5in?5progr@
CONST	SEGMENT
??_C@_0GM@ILNCJPIC@?0?5for?5component?5indices?5in?5progr@ DB ', for comp'
	DB	'onent indices in progression order change attribute.  Legal r'
	DB	'ange is from the lower bound + 1 to ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@PKCGAEDD@?0?5for?5component?5indices?5in?5progr@
CONST	SEGMENT
??_C@_0FK@PKCGAEDD@?0?5for?5component?5indices?5in?5progr@ DB ', for comp'
	DB	'onent indices in progression order change attribute.  Legal r'
	DB	'ange is from 0 to ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HG@EBOPONFH@?0?5for?5resolution?5level?5indices?5i@
CONST	SEGMENT
??_C@_0HG@EBOPONFH@?0?5for?5resolution?5level?5indices?5i@ DB ', for reso'
	DB	'lution level indices in progression order change attribute.  '
	DB	'Legal range is from the lower bound + 1 to 33.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GBMHHECB@Illegal?5upper?5bound?5?$CIexclusive?$CJ?0@
CONST	SEGMENT
??_C@_0CC@GBMHHECB@Illegal?5upper?5bound?5?$CIexclusive?$CJ?0@ DB 'Illega'
	DB	'l upper bound (exclusive), ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@OHOJBMOK@?0?5for?5resolution?5level?5indices?5i@
CONST	SEGMENT
??_C@_0GE@OHOJBMOK@?0?5for?5resolution?5level?5indices?5i@ DB ', for reso'
	DB	'lution level indices in progression order change attribute.  '
	DB	'Legal range is from 0 to 32.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CGBIAPKK@Illegal?5lower?5bound?0?5?$AA@
CONST	SEGMENT
??_C@_0BG@CGBIAPKK@Illegal?5lower?5bound?0?5?$AA@ DB 'Illegal lower bound'
	DB	', ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0PF@DBCFCBGN@Profile?5violation?5detected?4?5?5POC@
CONST	SEGMENT
??_C@_0PF@DBCFCBGN@Profile?5violation?5detected?4?5?5POC@ DB 'Profile vio'
	DB	'lation detected.  POC marker segments may not be included in '
	DB	'tile-part headers of Digital Cinema (CINEMA2K or CINEMA4K) co'
	DB	'de-streams.  You should either remove the `Sprofile'' attribu'
	DB	'te, or remove the tile-specific `Porder'' attribute.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0MI@GKHFMGFB@Profile?5violation?5detected?4?5?5POC@
CONST	SEGMENT
??_C@_0MI@GKHFMGFB@Profile?5violation?5detected?4?5?5POC@ DB 'Profile vio'
	DB	'lation detected.  POC marker segments may not be included in '
	DB	'2K Digital Cinema (CINEMA2K) code-streams.  You should either'
	DB	' remove the `Sprofile'' attribute or remove the `Porder'' att'
	DB	'ribute.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@NECPBKCJ@Information?5required?5to?5write?5PO@
CONST	SEGMENT
??_C@_0EM@NECPBKCJ@Information?5required?5to?5write?5PO@ DB 'Information '
	DB	'required to write POC marker segment is not currently complet'
	DB	'e!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EPM@KNAANCKO@Progression?5order?5change?5informa@
CONST	SEGMENT
??_C@_0EPM@KNAANCKO@Progression?5order?5change?5informa@ DB 'Progression '
	DB	'order change information.  The attribute may be applied globa'
	DB	'lly (main header), or in a tile-specific manner (tile-part he'
	DB	'ader).  In this latter case, multiple instances of the attrib'
	DB	'ute may be supplied for any given tile, which will force the '
	DB	'generation of multiple tile-parts for the tile (one for each '
	DB	'instance of the `Porder'' attribute).  As with all attributes'
	DB	', tile specific forms are specified by appending a suffix of '
	DB	'the form ":T<tnum>" to the attribute name, where <tnum> stand'
	DB	's for the tile number, starting from 0.  Each instance of the'
	DB	' attribute may contain one or more progression records, each '
	DB	'of which defines the order for a collection of packets. Each '
	DB	'record contains 6 fields. The first two fields identify inclu'
	DB	'sive lower bounds for the resolution level and image componen'
	DB	't indices, respectively. The next three fields identify exclu'
	DB	'sive upper bounds for the quality layer, resolution level and'
	DB	' image component indices, respectively. All indices are zero-'
	DB	'based, with resolution level 0 corresponding to the LL_D subb'
	DB	'and. The final field in each record identifies the progressio'
	DB	'n order to be applied within the indicated bounds. This order'
	DB	' is applied only to those packets which have not already been'
	DB	' sequenced by previous records or instances.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KBNJDDCF@IIIII?$CILRCP?$DN0?0RLCP?$DN1?0RPCL?$DN2?0PCRL?$DN@
CONST	SEGMENT
??_C@_0CK@KBNJDDCF@IIIII?$CILRCP?$DN0?0RLCP?$DN1?0RPCL?$DN2?0PCRL?$DN@ DB 'I'
	DB	'IIII(LRCP=0,RLCP=1,RPCL=2,PCRL=3,CPRL=4)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DOBDENMB@?5in?5this?5case?0?5may?5cause?5problem@
CONST	SEGMENT
??_C@_0CD@DOBDENMB@?5in?5this?5case?0?5may?5cause?5problem@ DB ' in this '
	DB	'case, may cause problems.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HN@DAMJBHKE@Up?9shift?5values?5in?5the?5RGN?5marke@
CONST	SEGMENT
??_C@_0HN@DAMJBHKE@Up?9shift?5values?5in?5the?5RGN?5marke@ DB 'Up-shift v'
	DB	'alues in the RGN marker segment should not need to exceed 37 '
	DB	'under any circumstances.  The use of a larger value, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@OLOKKCBP@Malformed?5RGN?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EH@OLOKKCBP@Malformed?5RGN?5marker?5segment?5enc@ DB 'Malformed RG'
	DB	'N marker segment encountered. Marker segment is too small.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HODFHOAP@Malformed?5RGN?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0DF@HODFHOAP@Malformed?5RGN?5marker?5segment?5enc@ DB 'Malformed RG'
	DB	'N marker segment encountered. The final ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MFEGEGLF@Encountered?5non?9Part1?5RGN?5marker@
CONST	SEGMENT
??_C@_0CK@MFEGEGLF@Encountered?5non?9Part1?5RGN?5marker@ DB 'Encountered '
	DB	'non-Part1 RGN marker segment!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0JH@FLFHNCLL@Profile?5violation?5detected?4?5?5RGN@
CONST	SEGMENT
??_C@_0JH@FLFHNCLL@Profile?5violation?5detected?4?5?5RGN@ DB 'Profile vio'
	DB	'lation detected.  RGN marker segments are disallowed in code-'
	DB	'streams marked with one of the Digital Cinema profiles (CINEM'
	DB	'A2K or CINEMA4K).', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JLDBBJDK@?4?5Legal?5range?5is?5from?50?5to?5255?$CB?$AA@
CONST	SEGMENT
??_C@_0CA@JLDBBJDK@?4?5Legal?5range?5is?5from?50?5to?5255?$CB?$AA@ DB '. '
	DB	'Legal range is from 0 to 255!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MGDBKNNO@Illegal?5ROI?5up?9shift?0?5?$AA@
CONST	SEGMENT
??_C@_0BH@MGDBKNNO@Illegal?5ROI?5up?9shift?0?5?$AA@ DB 'Illegal ROI up-sh'
	DB	'ift, ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07MDGMFIIN@Rweight?$AA@
CONST	SEGMENT
??_C@_07MDGMFIIN@Rweight?$AA@ DB 'Rweight', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DBK@IHBAFPAL@Region?5of?5interest?5significance?5@
CONST	SEGMENT
??_C@_0DBK@IHBAFPAL@Region?5of?5interest?5significance?5@ DB 'Region of i'
	DB	'nterest significance weight.  Although this attribute may be '
	DB	'used together with `Rshift'', it is common to use only one or'
	DB	' the other.  All code-blocks whose samples contribute in any '
	DB	'way to the reconstruction of the foreground region of an ROI '
	DB	'mask will have their distortion metrics scaled by the square '
	DB	'of the supplied weighting factor, for the purpose of rate all'
	DB	'ocation.  This renders such blocks more important and assigns'
	DB	' to them relatively more bits, in a manner which is closely r'
	DB	'elated to the effect of the `Clevel_weights'' and `Cband_weig'
	DB	'hts'' attributes on the importance of whole subbands.  Note t'
	DB	'hat this region weighting strategy is most effective when wor'
	DB	'king with large images and relatively small code-blocks (or p'
	DB	'recincts).', 0aH, 09H, 09H, '[Default is 1, i.e., no extra we'
	DB	'ighting]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07KGEEGGHK@Rlevels?$AA@
CONST	SEGMENT
??_C@_07KGEEGGHK@Rlevels?$AA@ DB 'Rlevels', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBM@FGPIIKPE@Number?5of?5initial?5?$CIhighest?5frequ@
CONST	SEGMENT
??_C@_0BBM@FGPIIKPE@Number?5of?5initial?5?$CIhighest?5frequ@ DB 'Number o'
	DB	'f initial (highest frequency) DWT levels through which to pro'
	DB	'pagate geometric information concerning the foreground region'
	DB	' for ROI processing.  Additional levels (i.e., lower frequenc'
	DB	'y subbands) will be treated as belonging entirely to the fore'
	DB	'ground region.', 0aH, 09H, 09H, '[Default is 4]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LDAKCIBF@Rshift?$AA@
CONST	SEGMENT
??_C@_06LDAKCIBF@Rshift?$AA@ DB 'Rshift', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CHI@HKJBINKE@Region?5of?5interest?5up?9shift?5valu@
CONST	SEGMENT
??_C@_0CHI@HKJBINKE@Region?5of?5interest?5up?9shift?5valu@ DB 'Region of '
	DB	'interest up-shift value.  All subband samples which are invol'
	DB	'ved in the synthesis of any image sample which belongs to the'
	DB	' foreground region of an ROI mask will be effectively shifted'
	DB	' up (scaled by two the power of this shift value) prior to qu'
	DB	'antization.  The region geometry is specified independently a'
	DB	'nd is not explicitly signalled through the code-stream; inste'
	DB	'ad, this shift must be sufficiently large to enable the decod'
	DB	'er to separate the foreground and background on the basis of '
	DB	'the shifted sample amplitudes alone.  You will receive an app'
	DB	'ropriate error message if the shift value is too small.', 0aH
	DB	09H, 09H, '[Default is 0]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KEJABOAE@RGN?$AA@
CONST	SEGMENT
??_C@_03KEJABOAE@RGN?$AA@ DB 'RGN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBO@GCINCGGG@Some?5absolute?5step?5sizes?5which?5y@
CONST	SEGMENT
??_C@_0BBO@GCINCGGG@Some?5absolute?5step?5sizes?5which?5y@ DB 'Some absol'
	DB	'ute step sizes which you have supplied will be ignored, since'
	DB	' `Qstep'' has been used or a default value for `Qstep'' has b'
	DB	'een forced.  If you want to specify explicit absolute step si'
	DB	'zes, you must not use `Qstep'' anywhere in the inheritance pa'
	DB	'th of the relevant tile-component.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0JH@IGLAJBAL@Trying?5to?5finalize?5quantization?5@
CONST	SEGMENT
??_C@_0JH@IGLAJBAL@Trying?5to?5finalize?5quantization?5@ DB 'Trying to fi'
	DB	'nalize quantization parameter attributes without first provid'
	DB	'ing any information about the image component bit-depths (i.e'
	DB	'. "Sprecision").', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@EBJLBPEO@Malformed?5QCD?1QCC?5marker?5segment@
CONST	SEGMENT
??_C@_0DJ@EBJLBPEO@Malformed?5QCD?1QCC?5marker?5segment@ DB 'Malformed QC'
	DB	'D/QCC marker segment encountered. The final ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@LJBJPKLN@Malformed?5QCD?1QCC?5marker?5segment@
CONST	SEGMENT
??_C@_0EL@LJBJPKLN@Malformed?5QCD?1QCC?5marker?5segment@ DB 'Malformed QC'
	DB	'D/QCC marker segment encountered. Marker segment is too small'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@NCOMABPP@Undefined?5style?5byte?5found?5in?5QC@
CONST	SEGMENT
??_C@_0DG@NCOMABPP@Undefined?5style?5byte?5found?5in?5QC@ DB 'Undefined s'
	DB	'tyle byte found in QCD/QCC marker segment!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@CKIKGBGG@Insufficient?5absolute?5quantizati@
CONST	SEGMENT
??_C@_0GG@CKIKGBGG@Insufficient?5absolute?5quantizati@ DB 'Insufficient a'
	DB	'bsolute quantization step size parameters available for writi'
	DB	'ng QCD/QCC marker segment.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@PNGCMGM@Absolute?5ranging?5parameters?5for?5@
CONST	SEGMENT
??_C@_0GI@PNGCMGM@Absolute?5ranging?5parameters?5for?5@ DB 'Absolute rang'
	DB	'ing parameters for reversibly compressed subbands must be non'
	DB	'-negative, no larger than 31!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@JFODLLGA@Insufficient?5absolute?5ranging?5pa@
CONST	SEGMENT
??_C@_0FG@JFODLLGA@Insufficient?5absolute?5ranging?5pa@ DB 'Insufficient '
	DB	'absolute ranging parameters available for writing QCD/QCC mar'
	DB	'ker segment', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0LA@JJEBFCFM@Profile?5violation?5detected?4?5?5QCD@
CONST	SEGMENT
??_C@_0LA@JJEBFCFM@Profile?5violation?5detected?4?5?5QCD@ DB 'Profile vio'
	DB	'lation detected.  QCD/QCC marker segments may only appear in '
	DB	'the main header of a code-stream marked with one of the Digit'
	DB	'al Cinema profiles (CINEMA2K or CINEMA4K).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0NK@HGFFBJED@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0NK@HGFFBJED@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vi'
	DB	'olation detected (code-stream is technically illegal).  QCD/Q'
	DB	'CC marker segments may only appear in the main header of a Pr'
	DB	'ofile-0 code-stream.  You should set "Sprofile" to 1 or 2.  P'
	DB	'roblem detected in tile ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CHOCCCME@?4?5Legal?5range?5is?5from?50?5to?57?4?$AA@
CONST	SEGMENT
??_C@_0BO@CHOCCCME@?4?5Legal?5range?5is?5from?50?5to?57?4?$AA@ DB '. Lega'
	DB	'l range is from 0 to 7.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OIAJENOM@Illegal?5number?5of?5guard?5bits?0?5?$AA@
CONST	SEGMENT
??_C@_0BP@OIAJENOM@Illegal?5number?5of?5guard?5bits?0?5?$AA@ DB 'Illegal '
	DB	'number of guard bits, ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@LONAPNHG@Cannot?5write?5QCD?1QCC?5marker?5segm@
CONST	SEGMENT
??_C@_0FI@LONAPNHG@Cannot?5write?5QCD?1QCC?5marker?5segm@ DB 'Cannot writ'
	DB	'e QCD/QCC marker segment yet!  Absolute step size information'
	DB	' not available.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@PFKIFKOG@Cannot?5write?5QCD?1QCC?5marker?5segm@
CONST	SEGMENT
??_C@_0GB@PFKIFKOG@Cannot?5write?5QCD?1QCC?5marker?5segm@ DB 'Cannot writ'
	DB	'e QCD/QCC marker segment yet!  Absolute reversible ranging in'
	DB	'formation not available.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@CMAJFDH@Cannot?5write?5QCD?1QCC?5marker?5segm@
CONST	SEGMENT
??_C@_0FP@CMAJFDH@Cannot?5write?5QCD?1QCC?5marker?5segm@ DB 'Cannot write'
	DB	' QCD/QCC marker segment without first completing all relevant'
	DB	' COD/COC information!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HA@COCFLGOG@Cannot?5write?5QCD?1QCC?5marker?5segm@
CONST	SEGMENT
??_C@_0HA@COCFLGOG@Cannot?5write?5QCD?1QCC?5marker?5segm@ DB 'Cannot writ'
	DB	'e QCD/QCC marker segment yet!  Not clear whether quant steps '
	DB	'are derived from the LL band step size.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@FNJKHCGL@Cannot?5write?5QCD?1QCC?5marker?5segm@
CONST	SEGMENT
??_C@_0EA@FNJKHCGL@Cannot?5write?5QCD?1QCC?5marker?5segm@ DB 'Cannot writ'
	DB	'e QCD/QCC marker segment yet! No info on guard bits.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@MPLKHCGE@Cannot?5write?5QCD?1QCC?5marker?5segm@
CONST	SEGMENT
??_C@_0FL@MPLKHCGE@Cannot?5write?5QCD?1QCC?5marker?5segm@ DB 'Cannot writ'
	DB	'e QCD/QCC marker segment without first completing relevant CO'
	DB	'D/COC information!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DGG@FMKFADLL@Number?5of?5range?5bits?5used?5to?5cod@
CONST	SEGMENT
??_C@_0DGG@FMKFADLL@Number?5of?5range?5bits?5used?5to?5cod@ DB 'Number of'
	DB	' range bits used to code each subband during reversible compr'
	DB	'ession.  Subbands appear in the sequence, LL_D, HL_D, LH_D, .'
	DB	'.., HL_1, LH_1, HH_1, where D denotes the number of DWT level'
	DB	's.  Note that the actual set of subbands for which values are'
	DB	' provided depends upon the decomposition structure, identifie'
	DB	'd via `Cdecomp''.  The number of range bits for a reversibly '
	DB	'compressed subband, plus the number of guard bits (see `Qguar'
	DB	'd''), is equal to 1 plus the number of magnitude bit-planes w'
	DB	'hich are used for coding its samples.', 0aH, 09H, 09H, '[For '
	DB	'compressors, most users will accept the default policy, which'
	DB	' sets the number of range bits to the smallest value which is'
	DB	' guaranteed to avoid overflow or underflow in the bit-plane r'
	DB	'epresentation, assuming that the RCT (colour transform) is us'
	DB	'ed.  If explicit values are supplied, they must be given for '
	DB	'each and every subband.]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DLI@DECHONMD@Absolute?5quantization?5step?5sizes@
CONST	SEGMENT
??_C@_0DLI@DECHONMD@Absolute?5quantization?5step?5sizes@ DB 'Absolute qua'
	DB	'ntization step sizes for each subband, expressed as a fractio'
	DB	'n of the nominal dynamic range for that subband. The nominal '
	DB	'range is equal to 2^B (B is the image sample bit-depth) multi'
	DB	'plied by the DC gain of each low-pass subband analysis filter'
	DB	' and the AC gain of each high-pass subband analysis filter, i'
	DB	'nvolved in the construction of the relevant subband. The band'
	DB	's are described one by one, in the following sequence: LL_D, '
	DB	'HL_D, LH_D, ..., HL_1, LH_1, HH_1.  Here, D denotes the numbe'
	DB	'r of DWT levels.  Also, note that the actual set of subbands '
	DB	'for which values are provided depends upon the decomposition '
	DB	'structure identified via `Cdecomp''.  A single step size must'
	DB	' be supplied for every subband (there is no extrapolation), e'
	DB	'xcept in the event that `Qderived'' is set to "yes" -- then, '
	DB	'only one parameter is allowed, corresponding to the LL_D subb'
	DB	'and.', 0aH, 09H, 09H, '[For compressors, the absolute step si'
	DB	'zes are ignored if `Qstep'' has been used.]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LCODFIOH@Qstep?$AA@
CONST	SEGMENT
??_C@_05LCODFIOH@Qstep?$AA@ DB 'Qstep', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0KK@JJMLLFOI@Base?5step?5size?5to?5be?5used?5in?5der@
CONST	SEGMENT
??_C@_0KK@JJMLLFOI@Base?5step?5size?5to?5be?5used?5in?5der@ DB 'Base step'
	DB	' size to be used in deriving irreversible quantization step s'
	DB	'izes for every subband. The base step parameter should be in '
	DB	'the range 0 to 2.', 0aH, 09H, 09H, '[Default is 1/256]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CCOBJCLJ@Qderived?$AA@
CONST	SEGMENT
??_C@_08CCOBJCLJ@Qderived?$AA@ DB 'Qderived', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BIH@EIAIGKMJ@Quantization?5steps?5derived?5from?5@
CONST	SEGMENT
??_C@_0BIH@EIAIGKMJ@Quantization?5steps?5derived?5from?5@ DB 'Quantizatio'
	DB	'n steps derived from LL band parameters? If "yes", all quanti'
	DB	'zation step sizes will be related to the LL subband''s step s'
	DB	'izes through appropriate powers of 2 and only the LL band ste'
	DB	'p size will be written in code-stream markers. Otherwise, a s'
	DB	'eparate step size will be recorded for every subband. You can'
	DB	'not use this option with reversible compression.', 0aH, 09H, 09H
	DB	'[Default is not derived]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BGIMBACE@Qguard?$AA@
CONST	SEGMENT
??_C@_06BGIMBACE@Qguard?$AA@ DB 'Qguard', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IA@OLHAIOBI@Number?5of?5guard?5bits?5to?5prevent?5@
CONST	SEGMENT
??_C@_0IA@OLHAIOBI@Number?5of?5guard?5bits?5to?5prevent?5@ DB 'Number of '
	DB	'guard bits to prevent overflow in the magnitude bit-plane rep'
	DB	'resentation. Typical values are 1 or 2.', 0aH, 09H, 09H, '[De'
	DB	'fault is 1]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LFCOMKDP@Malformed?5DFS?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0DF@LFCOMKDP@Malformed?5DFS?5marker?5segment?5enc@ DB 'Malformed DF'
	DB	'S marker segment encountered. The final ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@IOANDJIM@Malformed?5DFS?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EH@IOANDJIM@Malformed?5DFS?5marker?5segment?5enc@ DB 'Malformed DF'
	DB	'S marker segment encountered. Marker segment is too small.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@CMPAFODD@Illegal?5?$GADSdfs?8?5attribute?5value?5@
CONST	SEGMENT
??_C@_0FI@CMPAFODD@Illegal?5?$GADSdfs?8?5attribute?5value?5@ DB 'Illegal '
	DB	'`DSdfs'' attribute value encountered.  Legal values must be i'
	DB	'n the range 0 to 3.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0KI@NOLDCDIM@The?5?$GADSdfs?8?5attribute?5may?5be?5def@
CONST	SEGMENT
??_C@_0KI@NOLDCDIM@The?5?$GADSdfs?8?5attribute?5may?5be?5def@ DB 'The `DS'
	DB	'dfs'' attribute may be defined only for index values in the r'
	DB	'ange 1 to 127.  Perhaps your decomposition structure requires'
	DB	' too many distinct DFS marker segments.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DBH@IBFFCHEI@Describes?5the?5primary?5subband?5de@
CONST	SEGMENT
??_C@_0DBH@IBFFCHEI@Describes?5the?5primary?5subband?5de@ DB 'Describes t'
	DB	'he primary subband decomposition type associated with each DW'
	DB	'T level, starting from the highest resolution (1''st level). '
	DB	' The value may be one of `B'' (split in both directions), `H'''
	DB	' (split horizontally), `V'' (split vertically) or `X'' (don'''
	DB	't split at all).  The last case is degenerate, since it means'
	DB	' that the DWT level in question produces no detail subbands w'
	DB	'hatsoever, simply passing its input image through to the next'
	DB	' DWT level.  However, this can be useful in some circumstance'
	DB	's.  The primary subband decomposition determines the downsamp'
	DB	'ling factors between each successive resolution level.  If th'
	DB	'ere are more DWT levels than `DSdfs'' values, the last availa'
	DB	'ble value is replicated, as required.', 0aH, 09H, 09H, '[You '
	DB	'would not normally set values for this parameter attribute yo'
	DB	'urself.]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KMABOOPE@Malformed?5ADS?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0DF@KMABOOPE@Malformed?5ADS?5marker?5segment?5enc@ DB 'Malformed AD'
	DB	'S marker segment encountered. The final ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@JBFCFNFB@Malformed?5ADS?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EH@JBFCFNFB@Malformed?5ADS?5marker?5segment?5enc@ DB 'Malformed AD'
	DB	'S marker segment encountered. Marker segment is too small.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FOFDHDLH@?0?50x?$AA@
CONST	SEGMENT
??_C@_04FOFDHDLH@?0?50x?$AA@ DB ', 0x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MBLLCAAI@Encountered?5invalid?5?$GADdecomp?8?5at@
CONST	SEGMENT
??_C@_0CO@MBLLCAAI@Encountered?5invalid?5?$GADdecomp?8?5at@ DB 'Encounter'
	DB	'ed invalid `Ddecomp'' attribute value', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0KK@HLPJKNOJ@The?5?$GADdecomp?8?5attribute?5may?5be?5d@
CONST	SEGMENT
??_C@_0KK@HLPJKNOJ@The?5?$GADdecomp?8?5attribute?5may?5be?5d@ DB 'The `Dd'
	DB	'ecomp'' attribute may be defined only for index values in the'
	DB	' range 1 to 127.  Perhaps your decomposition structure requir'
	DB	'es too many distinct ADS marker segments.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CII@LBPCLNH@Array?5of?5splitting?5instructions?0@
CONST	SEGMENT
??_C@_0CII@LBPCLNH@Array?5of?5splitting?5instructions?0@ DB 'Array of spl'
	DB	'itting instructions, whose interpretation generally depends u'
	DB	'pon the way in which ADS and DFS tables are jointly reference'
	DB	'd from COD/COC marker segments, as identified by the `Cads'' '
	DB	'and `Cdfs'' attributes.  Each splitting instruction must take'
	DB	' one of the values: 3 (split horizontally and vertically); 2 '
	DB	'(split vertically); 1 (split horizontally); or 0 (do not spli'
	DB	't).  The last value is repeated as necessary, if accesses are'
	DB	' made beyond the end of the array.  For the meaning of these '
	DB	'splitting instructions, the reader is referred to Annex F of '
	DB	'IS 15444-2.', 0aH, 09H, 09H, '[You would not normally set val'
	DB	'ues for this parameter attribute yourself.]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GOBGDILI@?$CIX?$DN0?0H?$DN1?0V?$DN2?0B?$DN3?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@GOBGDILI@?$CIX?$DN0?0H?$DN1?0V?$DN2?0B?$DN3?$CJ?$AA@ DB '(X=0,H'
	DB	'=1,V=2,B=3)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BIG@MKJOPHKN@Number?5of?5sub?9levels?5in?5each?5suc@
CONST	SEGMENT
??_C@_0BIG@MKJOPHKN@Number?5of?5sub?9levels?5in?5each?5suc@ DB 'Number of'
	DB	' sub-levels in each successive DWT level, starting from the h'
	DB	'ighest level.  Accesses to non-existent values are supported '
	DB	'by repeating the last available value.  All entries must lie '
	DB	'in the range 1 to 3.  For the meaning of sub-levels in JPEG20'
	DB	'00 Part-2, the reader is referred to Annex F of IS 15444-2.', 0aH
	DB	09H, 09H, '[You would not normally set values for this paramet'
	DB	'er attribute yourself.]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BHE@CMGODJOA@This?5attribute?5is?5ultimately?5set@
CONST	SEGMENT
??_C@_0BHE@CMGODJOA@This?5attribute?5is?5ultimately?5set@ DB 'This attrib'
	DB	'ute is ultimately set so as to hold the same information as t'
	DB	'he `Cdecomp'' attribute of the COD/COC marker segment whose `'
	DB	'Cads'' holds our instance index.  Thus, for example, if `Cads'
	DB	'''=3 then `Cdecomp'' must be identical to `Ddecomp:I3''.  Thi'
	DB	's identification is created by the internal machinery, howeve'
	DB	'r.  You should not explicitly set `Ddecomp'' values yourself.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@DKHKMNAI@Incompatible?5?$GADSdfs?8?5and?5?$GACdecom@
CONST	SEGMENT
??_C@_0FO@DKHKMNAI@Incompatible?5?$GADSdfs?8?5and?5?$GACdecom@ DB 'Incomp'
	DB	'atible `DSdfs'' and `Cdecomp'' values seem to have been creat'
	DB	'ed.  Should not be possible.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CKE@KBAACNPK@Terminal?5splitting?5styles?5must?5h@
CONST	SEGMENT
??_C@_0CKE@KBAACNPK@Terminal?5splitting?5styles?5must?5h@ DB 'Terminal sp'
	DB	'litting styles must have identical splitting instructions for'
	DB	' all primary detail subbands (i.e., identical colon-separated'
	DB	' sub-strings), in each of which all 2-bit splitting codes mus'
	DB	't be identical (i.e., sub-strings must consist of identical c'
	DB	'haracters from the set, `-'', `H'', `V'' and `B''.  The only '
	DB	'exception to this rule is that where each primary subband is '
	DB	'split only once, in which case it is sufficient for all prima'
	DB	'ry subbands to be split once in the same direction (i.e., all'
	DB	' `-'', all `H--'', all `V--'' or all `B----'').  These rules '
	DB	'derive from the way in which Part-2 of the JPEG2000 standard '
	DB	'extrapolates information found in ADS and DFS marker segments'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04GPPIMOMJ@?$CC?4?5?5?$AA@
CONST	SEGMENT
??_C@_04GPPIMOMJ@?$CC?4?5?5?$AA@ DB '".  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@CDDAMBJI@Encountered?5invalid?5terminal?5?$GACd@
CONST	SEGMENT
??_C@_0DH@CDDAMBJI@Encountered?5invalid?5terminal?5?$GACd@ DB 'Encountere'
	DB	'd invalid terminal `Cdecomp'' attribute value', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BHK@LADFPGOB@Unacceptable?5interaction?5between@
CONST	SEGMENT
??_C@_0BHK@LADFPGOB@Unacceptable?5interaction?5between@ DB 'Unacceptable '
	DB	'interaction between ADS (Arbitrary Decomposition Style) and D'
	DB	'FS (Downsampling Factor Styles) information in Part-2 codestr'
	DB	'eam.  It makes no sense to use the same ADS table for two til'
	DB	'e-components which have different downsampling factor styles,'
	DB	' since downsampling styles have a strong effect on the interp'
	DB	'retation of information recorded in the ADS marker segment.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FJELFOMO@DSdfs?$AA@
CONST	SEGMENT
??_C@_05FJELFOMO@DSdfs?$AA@ DB 'DSdfs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GNBBHKJC@DSads?$AA@
CONST	SEGMENT
??_C@_05GNBBHKJC@DSads?$AA@ DB 'DSads', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIABAABB@DOads?$AA@
CONST	SEGMENT
??_C@_05MIABAABB@DOads?$AA@ DB 'DOads', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MCCNNBND@Ddecomp?$AA@
CONST	SEGMENT
??_C@_07MCCNNBND@Ddecomp?$AA@ DB 'Ddecomp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BDN@MGKCOKBG@You?5are?5attempting?5to?5define?5a?5d@
CONST	SEGMENT
??_C@_0BDN@MGKCOKBG@You?5are?5attempting?5to?5define?5a?5d@ DB 'You are a'
	DB	'ttempting to define a decomposition structure within a tile, '
	DB	'which involves a different downsampling structure (different '
	DB	'primary subband decomposition -- first character code of each'
	DB	' record in `Cdecomp'' attribute) to that defined (implicitly '
	DB	'or explicitly) for the main codestream header.  This is illeg'
	DB	'al.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@MIEFLBEH@Profile?5violation?5detected?4?5?5The@
CONST	SEGMENT
??_C@_0HC@MIEFLBEH@Profile?5violation?5detected?4?5?5The@ DB 'Profile vio'
	DB	'lation detected.  The CINEMA4K profile allows at most 6 DWT d'
	DB	'ecomposition levels.  You have requested ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@FEAHACJA@Profile?5violation?5detected?4?5?5The@
CONST	SEGMENT
??_C@_0FM@FEAHACJA@Profile?5violation?5detected?4?5?5The@ DB 'Profile vio'
	DB	'lation detected.  The CINEMA2K profile requires a CPRL packet'
	DB	' progression order.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NIPBGPHB@?5levels?0?5though?4?$AA@
CONST	SEGMENT
??_C@_0BB@NIPBGPHB@?5levels?0?5though?4?$AA@ DB ' levels, though.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@OGIJFNLO@Profile?5violation?5detected?4?5?5The@
CONST	SEGMENT
??_C@_0HC@OGIJFNLO@Profile?5violation?5detected?4?5?5The@ DB 'Profile vio'
	DB	'lation detected.  The CINEMA2K profile allows at most 5 DWT d'
	DB	'ecomposition levels.  You have requested ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DGO@NKGPBPEP@Profile?5violation?5may?5occur?5with@
CONST	SEGMENT
??_C@_0DGO@NKGPBPEP@Profile?5violation?5may?5occur?5with@ DB 'Profile vio'
	DB	'lation may occur without noticing, since you have requested a'
	DB	' Digital Cinema profile (CINEMA2K or CINEMA4K) without provid'
	DB	'ing a `Creslengths'' attribute.  The latter is generally requ'
	DB	'ired to be sure that the compressed lengths of resolution/com'
	DB	'ponent subsets conform to the tight Digital Cinema prescripti'
	DB	'on.  The actual allowed sizes depend upon the projected frame'
	DB	' rate, so are not enforced internally.  By way of example, yo'
	DB	'u can generate a legal CINEMA2K codestream for 24 fps by supp'
	DB	'lying "Creslengths=1302083" together with "Creslengths:C0=104'
	DB	'1666" "Creslengths:C1=104166" and "Creslengths:C2=1041666".  '
	DB	'For 48 fps, use 651041 and 520833 instead.  For a 4K codestre'
	DB	'am at 24 fps, use "Creslengths=1302083", together with "Cresl'
	DB	'enths:C0=1302083,1041666", "Creslengths:C1=1302083,1041666" a'
	DB	'nd "Creslengths:C2=1302083,104166", with the same replacement'
	DB	's for 48 fps.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0OO@FGOLANDB@Profile?5violation?5detected?4?5?5Req@
CONST	SEGMENT
??_C@_0OO@FGOLANDB@Profile?5violation?5detected?4?5?5Req@ DB 'Profile vio'
	DB	'lation detected.  Requested precinct dimensions are incompati'
	DB	'ble with the use of a Digital Cinema profile (CINEMA2K or CIN'
	DB	'EMA4K).  All precincts need to be of size 256x256 except the '
	DB	'lowest resolution level which needs 128x128', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IK@BEGMJOLL@Profile?5violation?5detected?4?5?5Req@
CONST	SEGMENT
??_C@_0IK@BEGMJOLL@Profile?5violation?5detected?4?5?5Req@ DB 'Profile vio'
	DB	'lation detected.  Requested block coding mode is incompatible'
	DB	' with the use of a Digital Cinema profile (CINEMA2K or CINEMA'
	DB	'4K).', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0KF@NKKOHPBE@Profile?5violation?5detected?4?5?5The@
CONST	SEGMENT
??_C@_0KF@NKKOHPBE@Profile?5violation?5detected?4?5?5The@ DB 'Profile vio'
	DB	'lation detected.  The Digital Cinema profiles (CINEMA2K or CI'
	DB	'NEMA4K) require a code-block size of exactly 32x32.  You have'
	DB	' specified something different.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBC@GFMDHLNB@Profile?5violation?5detected?4?5?5The@
CONST	SEGMENT
??_C@_0BBC@GFMDHLNB@Profile?5violation?5detected?4?5?5The@ DB 'Profile vi'
	DB	'olation detected.  The Digital Cinema profiles (CINEMA2K or C'
	DB	'INEMA4K), do not strictly allow the use of multiple quality l'
	DB	'ayers (i.e., Clayers should strictly be 1).  Letting it go fo'
	DB	'r now, since you could strip the extra quality layers later o'
	DB	'n to make it legal.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HE@FAOENAIF@Illegal?5ATK?5instance?5index?5found@
CONST	SEGMENT
??_C@_0HE@FAOENAIF@Illegal?5ATK?5instance?5index?5found@ DB 'Illegal ATK '
	DB	'instance index found when finalizing a COD/COC marker segment'
	DB	'.  Legal values are in the range 2 to 255.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAO@ECCKKNFO@Illegal?5?$GACkernels?8?5value?5found?5w@
CONST	SEGMENT
??_C@_0BAO@ECCKKNFO@Illegal?5?$GACkernels?8?5value?5found?5w@ DB 'Illegal'
	DB	' `Ckernels'' value found while finalizing a COD/COC marker se'
	DB	'gment.  Reversible processes must use the W5X3 kernel, while '
	DB	'irreversible processes must use the W9X7 kernel, unless you h'
	DB	'ave explicitly identified a different (Part-2) kernel, via th'
	DB	'e `Catk'' attribute.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0KB@HDNIPBLH@Unable?5to?5access?5the?5?$GAKreversibl@
CONST	SEGMENT
??_C@_0KB@HDNIPBLH@Unable?5to?5access?5the?5?$GAKreversibl@ DB 'Unable to'
	DB	' access the `Kreversible'' attribute associated with the `Cat'
	DB	'k'' index found while finalizing a COD/COC marker segment.  T'
	DB	'he value of the `Catk'' index is', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0JL@PNHEEPLI@DFS?5table?5index?5encountered?5whil@
CONST	SEGMENT
??_C@_0JL@PNHEEPLI@DFS?5table?5index?5encountered?5whil@ DB 'DFS table in'
	DB	'dex encountered while finalizing COD/COD marker segment infor'
	DB	'mation does not refer to accessible DFS (Downsampling Factor '
	DB	'Styles) information.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CPEMBAGM@DFS?$AA@
CONST	SEGMENT
??_C@_03CPEMBAGM@DFS?$AA@ DB 'DFS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0JP@NFJAKPFP@ADS?5table?5index?5encountered?5whil@
CONST	SEGMENT
??_C@_0JP@NFJAKPFP@ADS?5table?5index?5encountered?5whil@ DB 'ADS table in'
	DB	'dex encountered while finalizing COD/COD marker segment infor'
	DB	'mation does not refer to accessible ADS (Arbitrary Decomposit'
	DB	'ion Styles) information.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLBGDEDA@ADS?$AA@
CONST	SEGMENT
??_C@_03BLBGDEDA@ADS?$AA@ DB 'ADS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@FAEJKEME@?0?5detected?5by?5coding?5parameter?5s@
CONST	SEGMENT
??_C@_0HP@FAEJKEME@?0?5detected?5by?5coding?5parameter?5s@ DB ', detected'
	DB	' by coding parameter sub-system; legal code-streams may have '
	DB	'no more than 32 DWT levels in any given tile-component.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@BLGJFPGL@?0?5detected?5by?5coding?5parameter?5s@
CONST	SEGMENT
??_C@_0GK@BLGJFPGL@?0?5detected?5by?5coding?5parameter?5s@ DB ', detected'
	DB	' by coding parameter sub-system; legal code-streams may have '
	DB	'no more than 16384 quality layers.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@MEODJCKN@Malformed?5COD?1COC?5marker?5segment@
CONST	SEGMENT
??_C@_0EL@MEODJCKN@Malformed?5COD?1COC?5marker?5segment@ DB 'Malformed CO'
	DB	'D/COC marker segment encountered. Marker segment is too small'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BKGFKCIK@Malformed?5COD?1COC?5marker?5segment@
CONST	SEGMENT
??_C@_0DJ@BKGFKCIK@Malformed?5COD?1COC?5marker?5segment@ DB 'Malformed CO'
	DB	'D/COC marker segment encountered. The final ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@CMJBHJJH@Malformed?5COC?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EH@CMJBHJJH@Malformed?5COC?5marker?5segment?5enc@ DB 'Malformed CO'
	DB	'C marker segment encountered. Marker segment is too small.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@LDDJFDOP@Malformed?5COC?5marker?5segment?4?5In@
CONST	SEGMENT
??_C@_0DE@LDDJFDOP@Malformed?5COC?5marker?5segment?4?5In@ DB 'Malformed C'
	DB	'OC marker segment. Invalid "Scoc" value!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@OJAEGGAB@Malformed?5COD?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EH@OJAEGGAB@Malformed?5COD?5marker?5segment?5enc@ DB 'Malformed CO'
	DB	'D marker segment encountered. Marker segment is too small.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@CJECMJPA@Malformed?5COD?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EA@CJECMJPA@Malformed?5COD?5marker?5segment?5enc@ DB 'Malformed CO'
	DB	'D marker segment encountered. Invalid "Scod" value!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EGMBEELA@Precinct?5dimensions?5may?5not?5exce@
CONST	SEGMENT
??_C@_0CJ@EGMBEELA@Precinct?5dimensions?5may?5not?5exce@ DB 'Precinct dim'
	DB	'ensions may not exceed 2^15!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@INIGLHJN@Precinct?5dimensions?5must?5be?5exac@
CONST	SEGMENT
??_C@_0CP@INIGLHJN@Precinct?5dimensions?5must?5be?5exac@ DB 'Precinct dim'
	DB	'ensions must be exact powers of 2!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PBFFALNG@No?5precinct?5dimensions?5supplied?5@
CONST	SEGMENT
??_C@_0CN@PBFFALNG@No?5precinct?5dimensions?5supplied?5@ DB 'No precinct '
	DB	'dimensions supplied for COD/COC!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0HD@OIMMHFN@Maximum?5code?9block?5dimensions?5mu@
CONST	SEGMENT
??_C@_0HD@OIMMHFN@Maximum?5code?9block?5dimensions?5mu@ DB 'Maximum code-'
	DB	'block dimensions must be no less than 4 and the maximum code-'
	DB	'block area must not exceed 4096 samples!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IFOGDLHK@Maximum?5code?9block?5dimensions?5mu@
CONST	SEGMENT
??_C@_0DD@IFOGDLHK@Maximum?5code?9block?5dimensions?5mu@ DB 'Maximum code'
	DB	'-block dimensions must be powers of 2!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HN@HPMPNOPC@Illegal?5ATK?5instance?5index?5found@
CONST	SEGMENT
??_C@_0HN@HPMPNOPC@Illegal?5ATK?5instance?5index?5found@ DB 'Illegal ATK '
	DB	'instance index found when preparing to generate COD/COC marke'
	DB	'r segment.  Legal values are in the range 2 to 255.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBG@KCPOGFOJ@Illegal?5?$GACkernels?8?5value?5found?5w@
CONST	SEGMENT
??_C@_0BBG@KCPOGFOJ@Illegal?5?$GACkernels?8?5value?5found?5w@ DB 'Illegal'
	DB	' `Ckernels'' value found when preparing to generate COD/COC m'
	DB	'arker segment.  Reversible processes must use the W5X3 kernel'
	DB	', while irreversible processes must use the W9X7 kernel, unle'
	DB	'ss you have explicitly identified a different (Part-2) kernel'
	DB	', via the `Catk'' attribute.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAB@INJJPFGA@About?5to?5write?5a?5component?9speci@
CONST	SEGMENT
??_C@_0BAB@INJJPFGA@About?5to?5write?5a?5component?9speci@ DB 'About to w'
	DB	'rite a component-specific COD/COC marker segment, which ident'
	DB	'ifies a different number of DWT decomposition levels (Clevels'
	DB	') to that identified in the main COD marker segmen.  This is '
	DB	'not legal for the Digital Cinema profiles CINEMA2K or CINEMA4'
	DB	'K)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0LA@PCHBPKGD@Profile?5violation?5detected?4?5?5COD@
CONST	SEGMENT
??_C@_0LA@PCHBPKGD@Profile?5violation?5detected?4?5?5COD@ DB 'Profile vio'
	DB	'lation detected.  COD/COC marker segments may only appear in '
	DB	'the main header of a code-stream marked with one of the Digit'
	DB	'al Cinema profiles (CINEMA2K or CINEMA4K).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0NK@HPJJFAAC@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0NK@HPJJFAAC@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vi'
	DB	'olation detected (code-stream is technically illegal).  COD/C'
	DB	'OC marker segments may only appear in the main header of a Pr'
	DB	'ofile-0 code-stream.  You should set "Sprofile" to 1 or 2.  P'
	DB	'roblem detected in tile ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0JD@JKCKBNOF@You?5cannot?5use?5a?5colour?5transfor@
CONST	SEGMENT
??_C@_0JD@JKCKBNOF@You?5cannot?5use?5a?5colour?5transfor@ DB 'You cannot '
	DB	'use a colour transform unless the first 3 image components ha'
	DB	've identical bit-depths and are either all reversible or all '
	DB	'irreversible.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0HM@DEKELPAG@You?5cannot?5use?5a?5Part?91?5colour?5t@
CONST	SEGMENT
??_C@_0HM@DEKELPAG@You?5cannot?5use?5a?5Part?91?5colour?5t@ DB 'You canno'
	DB	't use a Part-1 colour transform (`Cycc=yes'') at the same tim'
	DB	'e as a Part-2 multi-component transform (`Cmct != 0'').', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GFANLIDL@?4?5Legal?5range?5is?50?5to?532?$CB?$AA@
CONST	SEGMENT
??_C@_0BK@GFANLIDL@?4?5Legal?5range?5is?50?5to?532?$CB?$AA@ DB '. Legal r'
	DB	'ange is 0 to 32!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JIANFEOP@Illegal?5number?5of?5DWT?5levels?0?5?$AA@
CONST	SEGMENT
??_C@_0BP@JIANFEOP@Illegal?5number?5of?5DWT?5levels?0?5?$AA@ DB 'Illegal '
	DB	'number of DWT levels, ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EICILEGK@Illegal?5number?5of?5quality?5layers@
CONST	SEGMENT
??_C@_0CD@EICILEGK@Illegal?5number?5of?5quality?5layers@ DB 'Illegal numb'
	DB	'er of quality layers, ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BEM@DMPFDMNO@Illegal?5combination?5of?5?$GAClevels?8@
CONST	SEGMENT
??_C@_0BEM@DMPFDMNO@Illegal?5combination?5of?5?$GAClevels?8@ DB 'Illegal '
	DB	'combination of `Clevels'' and `Cdfs'' values detected.  JPEG2'
	DB	'000 Part-2 codestreams record the DFS table index associated '
	DB	'with the `Cdfs'' parameter in a main header COC marker segmen'
	DB	't in place of the `Clevels'' value.  Thus, you cannot use a a'
	DB	'rbitrary downsampling factor styles while also providing a ne'
	DB	'w value for `Clevels''.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BLH@FGHKBOHC@Illegal?5combination?5of?5?$GAClevels?8@
CONST	SEGMENT
??_C@_0BLH@FGHKBOHC@Illegal?5combination?5of?5?$GAClevels?8@ DB 'Illegal '
	DB	'combination of `Clevels'' and `Cads'' values detected.  JPEG2'
	DB	'000 Part-2 codestreams record the ADS table index associated '
	DB	'with the `Cads'' parameter in a tile-specific COD or COC mark'
	DB	'er segment in place of the `Clevels'' value.  Thus, you canno'
	DB	't use a different `Clevels'' value to the default inherited f'
	DB	'rom a COD/COC marker segment with broader scope, while also s'
	DB	'pecifying arbitrary decomposition styles via `Cads'' and/or `'
	DB	'Cdecomp''.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0HD@OCHJAHPC@Unable?5to?5write?5COD?5marker?5segme@
CONST	SEGMENT
??_C@_0HD@OCHJAHPC@Unable?5to?5write?5COD?5marker?5segme@ DB 'Unable to w'
	DB	'rite COD marker segment yet! Some info missing.  Perhaps you '
	DB	'forgot to call `kdu_params::finalize_all''.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HE@NKGALBNL@Attempting?5to?5discard?5too?5many?5r@
CONST	SEGMENT
??_C@_0HE@NKGALBNL@Attempting?5to?5discard?5too?5many?5r@ DB 'Attempting '
	DB	'to discard too many resolution levels!  Cannot discard more r'
	DB	'esolution levels than there are DWT levels.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HKNEBDCB@Creslengths?$AA@
CONST	SEGMENT
??_C@_0M@HKNEBDCB@Creslengths?$AA@ DB 'Creslengths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HEO@NJIJCAOA@Maximum?5number?5of?5compressed?5byt@
CONST	SEGMENT
??_C@_0HEO@NJIJCAOA@Maximum?5number?5of?5compressed?5byt@ DB 'Maximum num'
	DB	'ber of compressed bytes (packet headers plus packet bodies) t'
	DB	'hat can be produced for each successive image resolution, sta'
	DB	'rting from the highest resolution and working down to the low'
	DB	'est.  The limit applies to the cumulative number of bytes gen'
	DB	'erated for the resolution in question and all lower resolutio'
	DB	'ns.  If the attribute is global to the entire codestream (no '
	DB	'T or C specifier), the limit for each resolution applies to t'
	DB	'he cumulative number of bytes up to that resolution in all ti'
	DB	'les and all image components.  If the attribute is tile-speci'
	DB	'fic but not component-specific, the limit for each resolution'
	DB	' applies to the cumulative number of bytes up to that resolut'
	DB	'ion for all image components within the tile.  If the attribu'
	DB	'te is component-specific, the limit applies to the cumulative'
	DB	' number of bytes up to the resolution in question across all '
	DB	'tiles, but only in that image component.  Finally, if the att'
	DB	'ribute is component-specific and tile-specific, the limit app'
	DB	'lies to the cumulative number of bytes up to the resolution i'
	DB	'n question, within just that tile-component.  You can provide'
	DB	' limits of all four types.  Moreover, you need not provide li'
	DB	'mits for all resolutions. The initial set of byte limits appl'
	DB	'ies only to the first quality layer to be generated during co'
	DB	'mpression.  Limits for additional quality layers may be suppl'
	DB	'ied by inserting zero or negative values into the list; these'
	DB	' are treated as layer delimiters.  So, for example, the param'
	DB	'eter string "1000,700,0,3000,2000,0,10000" provides limits of'
	DB	' 1000 and 700 bytes for the highest and second highest resolu'
	DB	'tions in the first quality layer, 3000 and 2000 bytes for the'
	DB	' same resolutions in the second quality layer, and a limit of'
	DB	' 10000 bytes only to the highest resolution in the third qual'
	DB	'ity layer.  Any subsequent quality layers are not restricted '
	DB	'by this parameter attribute.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GLALLHKC@Cband_weights?$AA@
CONST	SEGMENT
??_C@_0O@GLALLHKC@Cband_weights?$AA@ DB 'Cband_weights', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FOI@OMMBBAAN@Weighting?5factors?5for?5each?5succe@
CONST	SEGMENT
??_C@_0FOI@OMMBBAAN@Weighting?5factors?5for?5each?5succe@ DB 'Weighting f'
	DB	'actors for each successive subband, starting from the highest'
	DB	' frequency subbands and working down (i.e., HH1, LH1, HL1, HH'
	DB	'2, ...). The last supplied weight is repeated as necessary fo'
	DB	'r all remaining subbands (except the LL band). If `Clev_weigh'
	DB	'ts'' is also supplied, both sets of weighting factors are com'
	DB	'bined (multiplied).  Weight values are squared to obtain ener'
	DB	'gy weights for weighted MSE calculations.  The LL subband alw'
	DB	'ays has a weight of 1.0, which avoids problems which may occu'
	DB	'r when image components or tiles have different numbers of re'
	DB	'solution levels.  To modify the relative weighting of compone'
	DB	'nts or tile-components, including their LL subbands, use the '
	DB	'`Cweight'' option; its weighting factors are multiplied by th'
	DB	'ose specified using `Cband_weights'' and `Clev_weights''.  If'
	DB	' the `Cdecomp'' attribute is used to describe more general pa'
	DB	'cket wavelet transforms, all subbands obtained by splitting a'
	DB	'n HL, LH or HH subband will be assigned the same weight.  No '
	DB	'mechanism is provided for specifying their weights separately'
	DB	'.  Moreover, all three weights (HL, LH and HH) are present fo'
	DB	'r each resolution level, even if that level only involves hor'
	DB	'izontal or vertical splitting, and even in the degenerate cas'
	DB	'e of no splitting at all.  For horizontal splitting only, sub'
	DB	'bands derived from HX use the corresponding HL weight; HH and'
	DB	' LH weights are then ignored.  Similarly for vertical splitti'
	DB	'ng only, subbands derived from XH use the corresponding LH we'
	DB	'ight; HH and HL weights are then ignored.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HICBBPMC@Clev_weights?$AA@
CONST	SEGMENT
??_C@_0N@HICBBPMC@Clev_weights?$AA@ DB 'Clev_weights', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CEE@FMHLHNCK@Weighting?5factors?5for?5each?5succe@
CONST	SEGMENT
??_C@_0CEE@FMHLHNCK@Weighting?5factors?5for?5each?5succe@ DB 'Weighting f'
	DB	'actors for each successive resolution level, starting from th'
	DB	'e highest resolution and working down to the lowest (but not '
	DB	'including the LL band!!). The last supplied weight is repeate'
	DB	'd as necessary.  Weight values are squared to obtain energy w'
	DB	'eights for weighted MSE calculations.  The LL subband always '
	DB	'has a weight of 1.0, regardless of the number of resolution l'
	DB	'evels.  However, the weights associated with all subbands, in'
	DB	'cluding the LL band, are multiplied by the value supplied by '
	DB	'`Cweight'', which may be specialized to individual components'
	DB	' or tile-components.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07HDHNGJDI@Cweight?$AA@
CONST	SEGMENT
??_C@_07HDHNGJDI@Cweight?$AA@ DB 'Cweight', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BHM@MPDDOEC@Multiplier?5for?5subband?5weighting@
CONST	SEGMENT
??_C@_0BHM@MPDDOEC@Multiplier?5for?5subband?5weighting@ DB 'Multiplier fo'
	DB	'r subband weighting factors (see `Clev_weights'' and `Cband_w'
	DB	'eights'' below).  Scaling all the weights by a single quantit'
	DB	'y has no impact on their relative significance.  However, you'
	DB	' may supply a separate weight for each component, or even eac'
	DB	'h tile-component, allowing you to control the relative signic'
	DB	'ance of image components or tile-components in a simple manne'
	DB	'r.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06EGDCPANH@Cmodes?$AA@
CONST	SEGMENT
??_C@_06EGDCPANH@Cmodes?$AA@ DB 'Cmodes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@LCCKLEAC@Block?5coder?5mode?5switches?4?5Any?5c@
CONST	SEGMENT
??_C@_0GG@LCCKLEAC@Block?5coder?5mode?5switches?4?5Any?5c@ DB 'Block code'
	DB	'r mode switches. Any combination is legal.', 0aH, 09H, 09H, '['
	DB	'By default, all mode switches are turned off]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@FGLGNEBO@?$FLBYPASS?$DN1?$HMRESET?$DN2?$HMRESTART?$DN4?$HMCAUS@
CONST	SEGMENT
??_C@_0DL@FGLGNEBO@?$FLBYPASS?$DN1?$HMRESET?$DN2?$HMRESTART?$DN4?$HMCAUS@ DB '['
	DB	'BYPASS=1|RESET=2|RESTART=4|CAUSAL=8|ERTERM=16|SEGMARK=32]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HAGFJFNL@Cblk?$AA@
CONST	SEGMENT
??_C@_04HAGFJFNL@Cblk?$AA@ DB 'Cblk', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0PA@DKDAIDMK@Nominal?5code?9block?5dimensions?5?$CIm@
CONST	SEGMENT
??_C@_0PA@DKDAIDMK@Nominal?5code?9block?5dimensions?5?$CIm@ DB 'Nominal c'
	DB	'ode-block dimensions (must be powers of 2, no less than 4 and'
	DB	' no greater than 1024). Actual dimensions are subject to prec'
	DB	'inct, tile and image dimensions. Vertical coordinates appear '
	DB	'first.', 0aH, 09H, 09H, '[Default block dimensions are {64,64'
	DB	'}]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BEJ@DFLAPAFH@Precinct?5dimensions?5?$CImust?5be?5pow@
CONST	SEGMENT
??_C@_0BEJ@DFLAPAFH@Precinct?5dimensions?5?$CImust?5be?5pow@ DB 'Precinct'
	DB	' dimensions (must be powers of 2). Multiple records may be su'
	DB	'pplied, in which case the first record refers to the highest '
	DB	'resolution level and subsequent records to lower resolution l'
	DB	'evels. The last specified record is used for any remaining lo'
	DB	'wer resolution levels.Inside each record, vertical coordinate'
	DB	's appear first.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HE@LHMCCMEI@Explicitly?5specify?5whether?5or?5no@
CONST	SEGMENT
??_C@_0HE@LHMCCMEI@Explicitly?5specify?5whether?5or?5no@ DB 'Explicitly s'
	DB	'pecify whether or not precinct dimensions are supplied.', 0aH
	DB	09H, 09H, '[Default is "no" unless `Cprecincts'' is used]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CNA@EFIGBGL@A?5value?5of?50?5means?5that?5the?5DWT?5@
CONST	SEGMENT
??_C@_0CNA@EFIGBGL@A?5value?5of?50?5means?5that?5the?5DWT?5@ DB 'A value '
	DB	'of 0 means that the DWT kernel is one of W5X3 or W9X7, as spe'
	DB	'cified by the `Ckernels'' attribute.  Otherwise, this attribu'
	DB	'te holds the index of the ATK marker segment which defines th'
	DB	'e transform kernel.  The index must lie in the range 2 to 255'
	DB	' and corresponding `Kreversible'', `Krev_steps'' or `Kirv_ste'
	DB	'ps'' attributes must exist, which have the same index (instan'
	DB	'ce) value.  Thus, for example, if `Catk=3'', you must also su'
	DB	'pply a value for `Kreversible:I3'' and/or `Krev_steps:I3'' or'
	DB	' `Kirv_steps:I3'', as appropriate.  This information allows t'
	DB	'he internal machinery to deduce whether the transform is reve'
	DB	'rsible or not.  The ATK information in these parameter attrib'
	DB	'utes can also be tile-specific.', 0aH, 09H, 09H, '[Default is'
	DB	' 0]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BDE@IGHHDMOK@Wavelet?5kernels?5to?5use?4?5?5The?5spe@
CONST	SEGMENT
??_C@_0BDE@IGHHDMOK@Wavelet?5kernels?5to?5use?4?5?5The?5spe@ DB 'Wavelet '
	DB	'kernels to use.  The special value, `ATK'' means that an ATK '
	DB	'(Arbitrary Transform Kernel) marker segment is used to store '
	DB	'the DWT kernel.  In this case, the `Catk'' attribute must be '
	DB	'non-zero.', 0aH, 09H, 09H, '[Default is W5X3 if `Creversible'''
	DB	' is true, W9X7 if `Creversible'' is false, and ATK if `Catk'''
	DB	' is non-zero.]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OGDGPMGJ@?$CIW9X7?$DN0?0W5X3?$DN1?0ATK?$DN?91?$CJ?$AA@
CONST	SEGMENT
??_C@_0BH@OGDGPMGJ@?$CIW9X7?$DN0?0W5X3?$DN1?0ATK?$DN?91?$CJ?$AA@ DB '(W9X'
	DB	'7=0,W5X3=1,ATK=-1)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ODOOFFGJ@Creversible?$AA@
CONST	SEGMENT
??_C@_0M@ODOOFFGJ@Creversible?$AA@ DB 'Creversible', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JI@BJEOBCA@Reversible?5compression?$DP?6?7?7?$FLDefau@
CONST	SEGMENT
??_C@_0JI@BJEOBCA@Reversible?5compression?$DP?6?7?7?$FLDefau@ DB 'Reversi'
	DB	'ble compression?', 0aH, 09H, 09H, '[Default is irreversible, '
	DB	'if `Ckernels'' and `Catk'' are not used.  Otherwise, the reve'
	DB	'rsibility is derived from those values.]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0MDH@GKKAPHJL@Manages?5the?5information?5associat@
CONST	SEGMENT
??_C@_0MDH@GKKAPHJL@Manages?5the?5information?5associat@ DB 'Manages the '
	DB	'information associated with the JPEG2000 Part-2 `ADS'' and `D'
	DB	'FS'' marker segments, if any, as referenced by the `Cads'' an'
	DB	'd `Cdfs'' attributes.  If neither of these is present, the de'
	DB	'fault value of 3 is used, which yields the conventional Malla'
	DB	't decomposition structure.  Each record describes the subband'
	DB	' splitting processes for one entire DWT level, starting from '
	DB	'the first (highest frequency) level.  The textual form of eac'
	DB	'h record commences with a primary splitting code, which is on'
	DB	'e of the characters: `B'' (split both ways a la Mallat); `H'''
	DB	' (split only horizontally); `V'' (split only vertically); or '
	DB	'`-'' (do not split at all -- degenerate case).  The first opt'
	DB	'ion produces three primary detail subbands, denoted HL, LH an'
	DB	'd HH.  The second and third options produce only one primary '
	DB	'detail subband (HX or XH), while the last option produces no '
	DB	'detail subbands at all.  The primary splitting code is follow'
	DB	'ed by parentheses, containing 0, 1 or 3 colon-separated sub-s'
	DB	'trings, each of which describes the additional splitting oper'
	DB	'ations to be applied to each primary detail subband.  Each su'
	DB	'b-string consists of 1, 3 or 5 characters, drawn from `-'' (m'
	DB	'eaning no-split), `H'' (meaning a horizontal split), `V'' (me'
	DB	'aning a vertical split) and `B'' (meaning a bi-directional sp'
	DB	'lit).  If the sub-string commences with `H'' or `V'', two add'
	DB	'itional characters may be provided to describe further splitt'
	DB	'ing of the low- and high-pass subbands produced by the first '
	DB	'split.  If the sub-string commences with `B'', four additiona'
	DB	'l characters may be provided to describe further splitting of'
	DB	' the LL, HL, LH and HH subbands produced by the primary split'
	DB	'.  Alternatively, the sub-string may consist only of the init'
	DB	'ial character, in which case no further splitting is involved'
	DB	'.  Thus, "B" and "B----" are equivalent sub-strings, as are "'
	DB	'H" and "H--".', 0aH, 09H, '   If insufficient parameters are '
	DB	'supplied to accommodate the number of desired DWT levels, the'
	DB	' final value is simply replicated.  Note, however, that the l'
	DB	'ast value must conform to some specific rules, which derive f'
	DB	'rom the way in which JPEG2000 Part-2 defines extrapolation fo'
	DB	'r information found in the ADS and DFS marker segments.  In p'
	DB	'articular, the terminal parameter must have identical splitti'
	DB	'ng descriptors for all primary detail subbands (remember ther'
	DB	'e are 0, 1 or 3 of these).  Moreover, within each of these de'
	DB	'scriptors, all splitting codes (`-'', `H'', ''V'' and ''B'') '
	DB	'must be identical.  The only exception to this occurs where a'
	DB	'll primary detail subbands are split only once, in which case'
	DB	' all primary detail subbands must have identical sub-strings '
	DB	'holding one of the patterns, "B----", "H--", "V--" or "-".  T'
	DB	'hus, "B(-:-:-)", "H(BBBBB)", "B(HHH:HHH:HHH)", "V(H--)" and "'
	DB	'B(V--:V--:V--)" are all legal terminal values, while "B(B:B:-'
	DB	')" and "V(VV-)" are not legal.', 0aH, 09H, 09H, '[If `Cdecomp'
	DB	''' is not specified, a value is determined from the ADS and/o'
	DB	'r DFS information referenced by `Cads'' and `Cdfs''.  If ther'
	DB	'e is no such information, the default `Cdecomp'' value is "B('
	DB	'-,-,-)", which translates to the integer value, 3.  All Part-'
	DB	'1 codestreams must use this Mallat decomposition style.]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DIF@JIOHBMHM@Index?5of?5the?5DFS?5marker?5segment?5@
CONST	SEGMENT
??_C@_0DIF@JIOHBMHM@Index?5of?5the?5DFS?5marker?5segment?5@ DB 'Index of '
	DB	'the DFS marker segment used to hold Downsampling Factor Style'
	DB	' information.  If DFS information is involved, the value of t'
	DB	'he `Cdfs'' index must be in the range 1 to 127.  A value of 0'
	DB	' means that no DFS marker segment is referenced.  This attrib'
	DB	'ute is ignored outside of the main header (i.e., for non-nega'
	DB	'tive tile indices).  You will not normally set this parameter'
	DB	' yourself.  Rather, it is preferable to allow the internal ma'
	DB	'chinery to find a suitable index for you.  In any event, the '
	DB	'DFS instructions recorded in the `DSdfs'' attribute will be g'
	DB	'enerated automatically from information contained in `Cdecomp'
	DB	'''.  During marker segment reading, the DFS instructions will'
	DB	' be read, along with any ADS information (see `Cads'') in ord'
	DB	'er to reconstruct the `Cdecomp'' attribute.', 0aH, 09H, 09H, '['
	DB	'Best not to set this yourself.  An index is selected automati'
	DB	'cally if `Cdecomp'' defines a non-trivial decomposition.]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DCE@BCLFNHJE@Index?5of?5the?5ADS?5marker?5segment?5@
CONST	SEGMENT
??_C@_0DCE@BCLFNHJE@Index?5of?5the?5ADS?5marker?5segment?5@ DB 'Index of '
	DB	'the ADS marker segment used to hold Arbitrary Downsampling St'
	DB	'yle information.  If ADS information is involved, the value o'
	DB	'f the `Cads'' index must lie in the range 1 to 127.  A value '
	DB	'of 0 means that no ADS marker segment is referenced.  You wil'
	DB	'l not normally set this parameter yourself.  It is preferable'
	DB	' to allow the internal machinery to find a suitable index.  I'
	DB	'n any event, the ADS information recorded in the `DOads'' and'
	DB	' `DSads'' attributes will be generated automatically from inf'
	DB	'ormation contained in `Cdecomp''.  During marker segment read'
	DB	'ing, the ADS information is used together with any DFS inform'
	DB	'ation (see `Cdfs'') in order to reconstruct the `Cdecomp'' at'
	DB	'tribute.', 0aH, 09H, 09H, '[Best not to set this yourself.  A'
	DB	'n index is selected automatically if `Cdecomp'' defines a non'
	DB	'-trivial decomposition.]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@ILBHKDEJ@Number?5of?5wavelet?5decomposition?5@
CONST	SEGMENT
??_C@_0FI@ILBHKDEJ@Number?5of?5wavelet?5decomposition?5@ DB 'Number of wa'
	DB	'velet decomposition levels, or stages.  May not exceed 32.', 0aH
	DB	09H, 09H, '[Default is 5]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CAO@IFLBKBBI@If?5?$CCyes?$CC?0?5the?5code?9block?5partiti@
CONST	SEGMENT
??_C@_0CAO@IFLBKBBI@If?5?$CCyes?$CC?0?5the?5code?9block?5partiti@ DB 'If '
	DB	'"yes", the code-block partition is aligned so that the last s'
	DB	'ample in each nominal block (ignoring the effect of boundarie'
	DB	's) is aligned at a multiple of the block dimension (a power o'
	DB	'f 2).  Equivalently, the first sample in each nominal block l'
	DB	'ies at a location which is a multiple of the block dimension,'
	DB	' plus 1. By default (i.e., "no"), the first sample of each bl'
	DB	'ock is aligned at a multiple of the block dimension. The alig'
	DB	'nment is specified separately for both dimensions, with the v'
	DB	'ertical dimension specified first.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LBOPFCME@BB?$AA@
CONST	SEGMENT
??_C@_02LBOPFCME@BB?$AA@ DB 'BB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKJBDDKO@Corder?$AA@
CONST	SEGMENT
??_C@_06IKJBDDKO@Corder?$AA@ DB 'Corder', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BFK@PBIMDDLA@Default?5progression?5order?5?$CImay?5b@
CONST	SEGMENT
??_C@_0BFK@PBIMDDLA@Default?5progression?5order?5?$CImay?5b@ DB 'Default '
	DB	'progression order (may be overridden by Porder).  The four ch'
	DB	'aracter identifiers have the following interpretation: L=laye'
	DB	'r; R=resolution; C=component; P=position. The first character'
	DB	' in the identifier refers to the index which progresses most '
	DB	'slowly, while the last refers to the index which progresses m'
	DB	'ost quickly.', 0aH, 09H, 09H, '[Default is LRCP]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FILGKLGM@?$CILRCP?$DN0?0RLCP?$DN1?0RPCL?$DN2?0PCRL?$DN3?0CPR@
CONST	SEGMENT
??_C@_0CF@FILGKLGM@?$CILRCP?$DN0?0RLCP?$DN1?0RPCL?$DN2?0PCRL?$DN3?0CPR@ DB '('
	DB	'LRCP=0,RLCP=1,RPCL=2,PCRL=3,CPRL=4)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NAIOMJOM@Cuse_eph?$AA@
CONST	SEGMENT
??_C@_08NAIOMJOM@Cuse_eph?$AA@ DB 'Cuse_eph', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@HPJEBCAG@Include?5EPH?5markers?5?$CImarker?5end?5@
CONST	SEGMENT
??_C@_0FG@HPJEBCAG@Include?5EPH?5markers?5?$CImarker?5end?5@ DB 'Include '
	DB	'EPH markers (marker end of each packet header)?', 0aH, 09H, 09H
	DB	'[Default is no EPH markers]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DAJNLNLL@Cuse_sop?$AA@
CONST	SEGMENT
??_C@_08DAJNLNLL@Cuse_sop?$AA@ DB 'Cuse_sop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@NKHIFEB@Include?5SOP?5markers?5?$CIi?4e?4?0?5resyn@
CONST	SEGMENT
??_C@_0EK@NKHIFEB@Include?5SOP?5markers?5?$CIi?4e?4?0?5resyn@ DB 'Include'
	DB	' SOP markers (i.e., resync markers)?', 0aH, 09H, 09H, '[Defau'
	DB	'lt is no SOP markers]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07BJCMAMHC@Clayers?$AA@
CONST	SEGMENT
??_C@_07BJCMAMHC@Clayers?$AA@ DB 'Clayers', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BJCCPLJM@Number?5of?5quality?5layers?4?5May?5no@
CONST	SEGMENT
??_C@_0EB@BJCCPLJM@Number?5of?5quality?5layers?4?5May?5no@ DB 'Number of '
	DB	'quality layers. May not exceed 16384.', 0aH, 09H, 09H, '[Defa'
	DB	'ult is 1]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04OOAAMMCO@Cmct?$AA@
CONST	SEGMENT
??_C@_04OOAAMMCO@Cmct?$AA@ DB 'Cmct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FCM@DHPAPCJF@This?5parameter?5should?5be?50?5unles@
CONST	SEGMENT
??_C@_0FCM@DHPAPCJF@This?5parameter?5should?5be?50?5unles@ DB 'This param'
	DB	'eter should be 0 unless a Part 2 multi-component transform is'
	DB	' being used, in which case it contains one or both of the `AR'
	DB	'RAY'' and `DWT'' options -- if both options are present, they'
	DB	' are separated by a `|''.  The `ARRAY'' option will be presen'
	DB	't if and only if an array-based multi-component transform blo'
	DB	'ck is associated with the image, or the relevant tile (for ti'
	DB	'le-specific instances of the attribute).  The `DWT'' option w'
	DB	'ill be present if and only if a DWT-based multi-component tra'
	DB	'nsform block is associated with the image, or the relevant ti'
	DB	'le (for tile-specific instances of the COD marker segment).  '
	DB	'Both flags will be present if both types of multi-component t'
	DB	'ransform block are employed for the image or tile, as appropr'
	DB	'iate.  During codestream generation, the information in this '
	DB	'parameter is generated automatically to conform with the info'
	DB	'rmation provided via the `Mstages'' and `Mstage_xforms'' attr'
	DB	'ibutes.  When reading an existing codestream, the information'
	DB	' in this parameter should either be correct or 0.  In the lat'
	DB	'ter case, the internal machinery interprets the codestream as'
	DB	' one generated by versions of Kakadu prior to v6.0, wherein t'
	DB	'he transform coefficients for reversible matrix-based transfo'
	DB	'rms were accidentally transposed -- the transposition error i'
	DB	's corrected automatically in this case.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NBBPEJNG@?$FLARRAY?$DN2?$HMDWT?$DN4?$FN?$AA@
CONST	SEGMENT
??_C@_0BA@NBBPEJNG@?$FLARRAY?$DN2?$HMDWT?$DN4?$FN?$AA@ DB '[ARRAY=2|DWT=4'
	DB	']', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04DEPIIIHA@Cycc?$AA@
CONST	SEGMENT
??_C@_04DEPIIIHA@Cycc?$AA@ DB 'Cycc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0KP@IBLLLJAN@RGB?5to?5Luminance?9Chrominance?5con@
CONST	SEGMENT
??_C@_0KP@IBLLLJAN@RGB?5to?5Luminance?9Chrominance?5con@ DB 'RGB to Lumin'
	DB	'ance-Chrominance conversion?', 0aH, 09H, 09H, '[Default is to'
	DB	' convert images with 3 or more components, unless a Part 2 mu'
	DB	'lti-component transform is defined -- `Mcomponents'' > 0]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMDPBLM@QCD?$AA@
CONST	SEGMENT
??_C@_03ELMDPBLM@QCD?$AA@ DB 'QCD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0JA@OGLNENPI@Cannot?5write?5ATK?5?$CIarbitrary?5tran@
CONST	SEGMENT
??_C@_0JA@OGLNENPI@Cannot?5write?5ATK?5?$CIarbitrary?5tran@ DB 'Cannot wr'
	DB	'ite ATK (arbitrary transform kernel) marker segment with a sy'
	DB	'mmetric wavelet kernel whose Ls value (see `Ksteps'') is grea'
	DB	'ter than 510.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0JK@FJJJODFB@Cannot?5write?5ATK?5?$CIarbitrary?5tran@
CONST	SEGMENT
??_C@_0JK@FJJJODFB@Cannot?5write?5ATK?5?$CIarbitrary?5tran@ DB 'Cannot wr'
	DB	'ite ATK (arbitrary transform kernel) marker segment with a no'
	DB	'n-symmetric wavelet kernel whose Ns or Ls value (see `Ksteps'''
	DB	') is greater than 255.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@KAHDNOFP@lifting?5steps?4?5?5Maximum?5number?5o@
CONST	SEGMENT
??_C@_0DI@KAHDNOFP@lifting?5steps?4?5?5Maximum?5number?5o@ DB 'lifting st'
	DB	'eps.  Maximum number of lifting steps is 255.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@DFOKDDOA@Cannot?5write?5ATK?5?$CIarbitrary?5tran@
CONST	SEGMENT
??_C@_0EC@DFOKDDOA@Cannot?5write?5ATK?5?$CIarbitrary?5tran@ DB 'Cannot wr'
	DB	'ite ATK (arbitrary transform kernel) marker segment with', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@COILGNIP@Unable?5to?5write?5ATK?5marker?5segme@
CONST	SEGMENT
??_C@_0DL@COILGNIP@Unable?5to?5write?5ATK?5marker?5segme@ DB 'Unable to w'
	DB	'rite ATK marker segment yet! Some info missing.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@MILOCDIO@Malformed?5ATK?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0DF@MILOCDIO@Malformed?5ATK?5marker?5segment?5enc@ DB 'Malformed AT'
	DB	'K marker segment encountered. The final ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@CBNJBHNF@Malformed?5ATK?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EI@CBNJBHNF@Malformed?5ATK?5marker?5segment?5enc@ DB 'Malformed AT'
	DB	'K marker segment encountered.  Marker segment is too small.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HD@HJBDDKNG@Cannot?5process?5ATK?5marker?5segmen@
CONST	SEGMENT
??_C@_0HD@HJBDDKNG@Cannot?5process?5ATK?5marker?5segmen@ DB 'Cannot proce'
	DB	'ss ATK marker segment describing a reversible transform kerne'
	DB	'l with floating-point coefficient values.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JJ@EJINJNCB@Malformed?5ATK?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0JJ@EJINJNCB@Malformed?5ATK?5marker?5segment?5enc@ DB 'Malformed AT'
	DB	'K marker segment encountered.  Transform kernels identified a'
	DB	's whole-sample symmetric must also use the symmetric boundary'
	DB	' extension method.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@MACCMDJG@Cannot?5process?5ATK?5marker?5segmen@
CONST	SEGMENT
??_C@_0GL@MACCMDJG@Cannot?5process?5ATK?5marker?5segmen@ DB 'Cannot proce'
	DB	'ss ATK marker segment which uses more than 8 bytes to represe'
	DB	'nt each lifting step coefficient.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0OH@MFIHEDLO@Invalid?5?$GAKsymmetric?8?5value?5found@
CONST	SEGMENT
??_C@_0OH@MFIHEDLO@Invalid?5?$GAKsymmetric?8?5value?5found@ DB 'Invalid `'
	DB	'Ksymmetric'' value found while in `atk_params::finalize''.  T'
	DB	'he lifting step alignment and coefficients are not compatible'
	DB	' with the whole-sample symmetric class of wavelet kernels def'
	DB	'ined by Part-2 of the JPEG2000 standard.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@IHFGAOCO@Reversible?5lifting?5steps?5defined@
CONST	SEGMENT
??_C@_0HP@IHFGAOCO@Reversible?5lifting?5steps?5defined@ DB 'Reversible li'
	DB	'fting steps defined by `Ksteps'' and `Kcoeffs'' produce a low'
	DB	'-pass analysis filter whose DC gain is not equal to 1.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LH@KFFJGFML@Too?5many?5?$GAKcoeffs?8?5records?5found@
CONST	SEGMENT
??_C@_0LH@KFFJGFML@Too?5many?5?$GAKcoeffs?8?5records?5found@ DB 'Too many'
	DB	' `Kcoeffs'' records found while in `atk_params::finalize''.  '
	DB	'The number of coefficients must be equal to the sum of the li'
	DB	'fting step lengths recorded in the `Ksteps'' attribute.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LL@ICCFCJEB@Insufficient?5?$GAKcoeffs?8?5records?5f@
CONST	SEGMENT
??_C@_0LL@ICCFCJEB@Insufficient?5?$GAKcoeffs?8?5records?5f@ DB 'Insuffici'
	DB	'ent `Kcoeffs'' records found while in `atk_params::finalize'''
	DB	'.  The number of coefficients must be equal to the sum of the'
	DB	' lifting step lengths recorded in the `Ksteps'' attribute.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IK@EBAJKINC@For?5irreversible?5transforms?5?$CI?$GAKr@
CONST	SEGMENT
??_C@_0IK@EBAJKINC@For?5irreversible?5transforms?5?$CI?$GAKr@ DB 'For irr'
	DB	'eversible transforms (`Kreversible'' = false), the third and '
	DB	'fourth fields in each record of the `Ksteps'' attribute must '
	DB	'both be 0.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0IB@GILFGDAI@Invalid?5downshifting?5value?5?$CI3?8rd@
CONST	SEGMENT
??_C@_0IB@GILFGDAI@Invalid?5downshifting?5value?5?$CI3?8rd@ DB 'Invalid d'
	DB	'ownshifting value (3''rd field) found while checking supplied'
	DB	' `Ksteps'' attributes.  Values must be in the range 0 to 24.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@HNGPDMEK@Incomplete?5?$GAKsteps?8?5record?5?$CIneed@
CONST	SEGMENT
??_C@_0GB@HNGPDMEK@Incomplete?5?$GAKsteps?8?5record?5?$CIneed@ DB 'Incomp'
	DB	'lete `Ksteps'' record (need 4 fields in each record) found wh'
	DB	'ile in `atk_params::finalize''.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0IK@HMACHLFE@You?5cannot?5provide?5custom?5transf@
CONST	SEGMENT
??_C@_0IK@HMACHLFE@You?5cannot?5provide?5custom?5transf@ DB 'You cannot p'
	DB	'rovide custom transform kernel data via `Ksteps'' or `Kcoeffs'
	DB	''' without also providing a value for the `Kreversible'' attr'
	DB	'ibute.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BIA@GBIBAJFK@Cannot?5transpose?5ATK?5marker?5segm@
CONST	SEGMENT
??_C@_0BIA@GBIBAJFK@Cannot?5transpose?5ATK?5marker?5segm@ DB 'Cannot tran'
	DB	'spose ATK marker segment information to a new codestream whic'
	DB	'h has flippped geometry unless the transform filters are whol'
	DB	'e-sample symmetric, or flipping is to be applied in both the '
	DB	'vertical and horizontal directions.  The reason for this is t'
	DB	'hat the same transform kernels must be used in both direction'
	DB	's, only one of which requires reversal of the lifting coeffic'
	DB	'ients.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CIE@OIBNHEMA@Holds?5the?5lifting?5coefficients?0?5@
CONST	SEGMENT
??_C@_0CIE@OIBNHEMA@Holds?5the?5lifting?5coefficients?0?5@ DB 'Holds the '
	DB	'lifting coefficients, Cs[n].  The first L0 records describe t'
	DB	'he coefficients of the first lifting step.  These are followe'
	DB	'd by the L1 coefficients of the second lifting step, and so f'
	DB	'orth.  The Ls values are identified by the first field in eac'
	DB	'h `Ksteps'' record.  Lifting step s may be described by X_s[2'
	DB	'k+1-p] += TRUNC(sum_{Ns<=n<Ns+Ls} Cs[n]*X_{s-1}[2k+p+2n]).  I'
	DB	'n the case of an irreversible transform, the TRUNC operator d'
	DB	'oes nothing and all arithmetic is performed (at least notiona'
	DB	'lly) in floating point.  For reversible transforms, TRUNC(a) '
	DB	'= floor(a + Rs*2^{-Ds}) and Cs[n] is guaranteed to be an inte'
	DB	'ger multiple of 2^{-Ds}.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DMN@NFEELAKF@Array?5with?5one?5entry?5for?5each?5li@
CONST	SEGMENT
??_C@_0DMN@NFEELAKF@Array?5with?5one?5entry?5for?5each?5li@ DB 'Array wit'
	DB	'h one entry for each lifting step.  The first entry corrspond'
	DB	's to lifting step s=0, which updates odd indexed samples, bas'
	DB	'ed on even indexed samples; the second entry corresponds to l'
	DB	'ifting step s=1, which updates even indexed samples, based on'
	DB	' odd indexed samples; and so forth.  The first field in each '
	DB	'record holds the length, Ls, of the coefficient array Cs[n], '
	DB	'for the relevant step s.  The second field is the location of'
	DB	' the first entry, Ns, where Cs[n] is defined for n=Ns to Ns+L'
	DB	's-1.  The value of Ns is typically negative, but need not be.'
	DB	'  For symmetric kernels, Ls must be even and Ns must satisfy '
	DB	'Ns=-floor((Ls+p-1)/2), where p is the lifting step parity (0 '
	DB	'if s is even, 1 if s is odd).  The third and fourth fields mu'
	DB	'st both be 0 if `Kreversible'' is false.  For reversible tran'
	DB	'sform kernels, however, the third field holds the downshift v'
	DB	'alue, Ds, while the fourth field holds the rounding offset, R'
	DB	's, to be added immediately prior to downshifting.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04NENCGHGO@IIII?$AA@
CONST	SEGMENT
??_C@_04NENCGHGO@IIII?$AA@ DB 'IIII', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JOGHAEOB@Kextension?$AA@
CONST	SEGMENT
??_C@_0L@JOGHAEOB@Kextension?$AA@ DB 'Kextension', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CNF@DACPPFDL@Identifies?5the?5boundary?5extensio@
CONST	SEGMENT
??_C@_0CNF@DACPPFDL@Identifies?5the?5boundary?5extensio@ DB 'Identifies t'
	DB	'he boundary extension method to be applied in each lifting st'
	DB	'ep.  If `CON'', boundary samples are simply replicated.  The '
	DB	'other possible value, `SYM'', means that boundary samples are'
	DB	' symmetrically extended.  The centre of symmetry in this case'
	DB	' is the boundary sample location within an interleaved repres'
	DB	'entation in which low-pass samples occupy the even indexed lo'
	DB	'cations and high-pass samples occupy the odd indexed location'
	DB	's.  The `SYM'' method must be used if `Ksymmetric'' is true. '
	DB	' Conversely, for filters which do not have the whole-sample s'
	DB	'ymmetric property, you are strongly recommended to use the `C'
	DB	'ON'' extension method.', 0aH, 09H, 09H, '[Defaults to `SYM'' '
	DB	'if the filters are whole-sample symmetric and `CON'' otherwis'
	DB	'e.]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PBGDLPEF@?$CICON?$DN0?0SYM?$DN1?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@PBGDLPEF@?$CICON?$DN0?0SYM?$DN1?$CJ?$AA@ DB '(CON=0,SYM=1)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0COP@MOCEJKKL@If?5true?0?5the?5transform?5kernel?5be@
CONST	SEGMENT
??_C@_0COP@MOCEJKKL@If?5true?0?5the?5transform?5kernel?5be@ DB 'If true, '
	DB	'the transform kernel belongs to the whole-sample symmetric cl'
	DB	'ass, which is treated specially by JPEG2000 Part-2.  The tran'
	DB	'slated impulse responses of these kernels are all symmetric a'
	DB	'bout 0 -- see the Taubman & Marcellin book, Chapter 6, for a '
	DB	'definition of translated impulse responses.  Equivalently, al'
	DB	'l lifting steps involve even-length symmetric lifting coeffic'
	DB	'ients, Cs[n], where the coefficients associated with steps s='
	DB	'0, 2, 4, ... are symmetric about n = 1/2 and the coefficients'
	DB	' associated with steps s=1, 3, 5, ... are symmetric about n ='
	DB	' -1/2.', 0aH, 09H, 09H, '[If you do not explicitly specify th'
	DB	'is attribute, it will be determined automatically from the li'
	DB	'fting coefficient values supplied via `Krev_coeffs'' or `Kirv'
	DB	'_coeffs'', as appropriate.]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OFOCCDJH@Kreversible?$AA@
CONST	SEGMENT
??_C@_0M@OFOCCDJH@Kreversible?$AA@ DB 'Kreversible', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CGL@OFBGPMKE@This?5attribute?5determines?5how?5th@
CONST	SEGMENT
??_C@_0CGL@OFBGPMKE@This?5attribute?5determines?5how?5th@ DB 'This attrib'
	DB	'ute determines how the `Ksteps'' and `Kcoeffs'' attributes sh'
	DB	'ould be treated.  In the end, this parameter attribute must a'
	DB	'gree with the value of the `Creversible'' attribute, for any '
	DB	'tile-component which uses this transformation kernel.  Howeve'
	DB	'r this consistency may be created by specifying `Kreversible'''
	DB	' and leaving `Creversible'' unspecified, so that an appropria'
	DB	'te default value will be selected.', 0aH, 09H, 09H, '[A defau'
	DB	'lt value cannot be created automatically, so you must explici'
	DB	'tly specify a value if you want ATK information to become ava'
	DB	'ilable for any particular instance index in the main header o'
	DB	'r a tile header.]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@OLCFAFPF@Cannot?5write?5MCO?5marker?5segment?$DL@
CONST	SEGMENT
??_C@_0EP@OLCFAFPF@Cannot?5write?5MCO?5marker?5segment?$DL@ DB 'Cannot wr'
	DB	'ite MCO marker segment; `Mnum_stages'' value exceeds the limi'
	DB	't of 255.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@FMIBNLCC@Malformed?5MCO?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EH@FMIBNLCC@Malformed?5MCO?5marker?5segment?5enc@ DB 'Malformed MC'
	DB	'O marker segment encountered. Marker segment is too small.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@IOEIPGFI@Malformed?5MCO?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0DF@IOEIPGFI@Malformed?5MCO?5marker?5segment?5enc@ DB 'Malformed MC'
	DB	'O marker segment encountered. The final ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GN@BOBKGGGG@The?5number?5of?5records?5supplied?5f@
CONST	SEGMENT
??_C@_0GN@BOBKGGGG@The?5number?5of?5records?5supplied?5f@ DB 'The number '
	DB	'of records supplied for the `Mstages'' attribute must match t'
	DB	'he value identified by `Mnum_stages''.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JP@JHGJOPNH@You?5may?5not?5provide?5a?5value?5for?5@
CONST	SEGMENT
??_C@_0JP@JHGJOPNH@You?5may?5not?5provide?5a?5value?5for?5@ DB 'You may n'
	DB	'ot provide a value for the `Mnum_stages'' attribute without a'
	DB	'lso supplying a non-zero number of MCT output components via '
	DB	'the `Mcomponents'' attribute.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BCA@FMBIIPEN@Unable?5to?5modify?5the?5existing?5mu@
CONST	SEGMENT
??_C@_0BCA@FMBIIPEN@Unable?5to?5modify?5the?5existing?5mu@ DB 'Unable to '
	DB	'modify the existing multi-component transform to work with a '
	DB	'reduced number of codestream image components during transcod'
	DB	'ing.  Cannot create a taylored null transform to interface th'
	DB	'e components, since all allowed MCC marker segment instance i'
	DB	'ndices have been used up already.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNNLMAHC@Mstages?$AA@
CONST	SEGMENT
??_C@_07CNNLMAHC@Mstages?$AA@ DB 'Mstages', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BKE@DNMMMJKF@Provides?5?$GAMnum_stages?8?5records?0?5@
CONST	SEGMENT
??_C@_0BKE@DNMMMJKF@Provides?5?$GAMnum_stages?8?5records?0?5@ DB 'Provide'
	DB	's `Mnum_stages'' records, each of which holds the instance in'
	DB	'dex (in the range 0 to 255) associated with the `Mstage_input'
	DB	's'', `Mstage_outputs'', `Mstage_blocks'' and `Mstage_xforms'''
	DB	' attributes which describe the corresponding stage in the inv'
	DB	'erse multi-component transform procedure.  The last stage is '
	DB	'the one which produces the final decompressed components desc'
	DB	'ribed by `Mcomponents'', `Msigned'' and `Mprecision''.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BMJAMMCN@Mnum_stages?$AA@
CONST	SEGMENT
??_C@_0M@BMJAMMCN@Mnum_stages?$AA@ DB 'Mnum_stages', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FCK@KEJNIDFA@Identifies?5the?5number?5of?5stages?5@
CONST	SEGMENT
??_C@_0FCK@KEJNIDFA@Identifies?5the?5number?5of?5stages?5@ DB 'Identifies'
	DB	' the number of stages in the multi-component transform to be '
	DB	'applied to this tile, or (for main header attributes) as a de'
	DB	'fault for tiles which do not specify the `Mnum_stages'' attri'
	DB	'bute.  If this value is 0, the spatially transformed codestre'
	DB	'am components associated with the relevant tile are mapped di'
	DB	'rectly to the output components specified via the global `Mco'
	DB	'mponents'', `Msigned'' and `Mprecision'' attributes.  If `Mco'
	DB	'mponents'' is larger than `Scomponents'', some final componen'
	DB	'ts are automatically set to 0.  Where the number of stages is'
	DB	' 0, codestream components which are identified as unsigned by'
	DB	' the `Ssigned'' attribute are first offset (at least nominall'
	DB	'y) by half their dynamic range, in the usual fashion.  If, on'
	DB	' the other hand, `Mnum_stages'' specifies a non-zero number o'
	DB	'f transform stages, component offsets must be provided by the'
	DB	' multi-component transform stages themselves.', 0aH, 09H, 09H
	DB	'   It is worth noting that the above description applies to i'
	DB	'nverse transformation (synthesis) during decompression.  For '
	DB	'a discussion of the conditions under which an appropriate for'
	DB	'ward transform can be performed during compression, see the d'
	DB	'escription of the `Mcomponents'' attribute.', 0aH, 09H, 09H, '['
	DB	'This attribute defaults to 0 if a non-zero `Mcomponents'' val'
	DB	'ue exists, indicating the presence of a multi-component trans'
	DB	'form.]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03LCPIMAFA@MCO?$AA@
CONST	SEGMENT
??_C@_03LCPIMAFA@MCO?$AA@ DB 'MCO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJM@PGFFJOFI@You?5can?5no?5longer?5generate?5a?5cod@
CONST	SEGMENT
??_C@_0DJM@PGFFJOFI@You?5can?5no?5longer?5generate?5a?5cod@ DB 'You can n'
	DB	'o longer generate a codestream which uses the `MAT'' (`Mxform'
	DB	'_MAT'' in source code) option for the `Mstage_xforms'' parame'
	DB	'ter attribute.  From Kakadu v6.0, matrix-based multi-componen'
	DB	't transform blocks should use the `MATRIX'' (`Mxform_MATRIX'''
	DB	' in source code) identifier.  This change is designed to forc'
	DB	'e awareness of the fact that the organization of matrix coeff'
	DB	'icients for reversible matrix decorrelation transforms has be'
	DB	'en altered, in order to comply with IS15444-2.  In particular'
	DB	', versions prior to v6.0 considered the coefficients for reve'
	DB	'rsible (SERM) matrix transforms to have a transposed order, r'
	DB	'elative to that specified in the standard.  If you are trying'
	DB	' to generate a codestream which employs only irreversible mat'
	DB	'rix transforms, you have simply to substitute `MATRIX'' for `'
	DB	'MAT''.  If you are working with reversible matrix multi-compo'
	DB	'nent transforms, you should first transpose the coefficient m'
	DB	'atrix.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BIP@MNLLGAPJ@Unable?5to?5write?5MCC?5?$CIMulti?9compo@
CONST	SEGMENT
??_C@_0BIP@MNLLGAPJ@Unable?5to?5write?5MCC?5?$CIMulti?9compo@ DB 'Unable '
	DB	'to write MCC (Multi-component transform Component Collection)'
	DB	' marker segment, since the amount of information is too large'
	DB	' to fit within a single marker segment.  The codestream synta'
	DB	'x for this Part-2 marker segment allows the information to be'
	DB	' split across multiple marker segments, but this feature is n'
	DB	'ot yet implemented in Kakadu -- it is a rare application inde'
	DB	'ed that should need this.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LFIMCEFC@Malformed?5MCC?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0DF@LFIMCEFC@Malformed?5MCC?5marker?5segment?5enc@ DB 'Malformed MC'
	DB	'C marker segment encountered. The final ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@NPIHMIKE@Malformed?5MCC?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EI@NPIHMIKE@Malformed?5MCC?5marker?5segment?5enc@ DB 'Malformed MC'
	DB	'C marker segment encountered.  Marker segment is too small.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HM@HFEFAMNA@Malformed?5MCC?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0HM@HFEFAMNA@Malformed?5MCC?5marker?5segment?5enc@ DB 'Malformed MC'
	DB	'C marker segment encountered.  Invalid component collection d'
	DB	'imensions, transform type or number of DWT levels.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BEB@BKBLPOMO@Encountered?5MCC?5?$CIMulti?9component@
CONST	SEGMENT
??_C@_0BEB@BKBLPOMO@Encountered?5MCC?5?$CIMulti?9component@ DB 'Encounter'
	DB	'ed MCC (Multi-component transform Component Collection) infor'
	DB	'mation which has been split across multiple marker segments. '
	DB	' While this is not illegal, Kakadu does not currently support'
	DB	' such massive multi-component transform descriptions.  It is '
	DB	'a rare application indeed that would need multiple marker seg'
	DB	'ments.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0LD@CNACCFCO@Malformed?5?$GAMstage_xforms?8?5attrib@
CONST	SEGMENT
??_C@_0LD@CNACCFCO@Malformed?5?$GAMstage_xforms?8?5attrib@ DB 'Malformed '
	DB	'`Mstage_xforms'' attribute encountered in `mcc_params::finali'
	DB	'ze''.  The number of records in this attribute must be identi'
	DB	'cal to the number of records in `Mstage_blocks''.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0NL@PJCAENA@Malformed?5?$GAMstage_xforms?8?5attrib@
CONST	SEGMENT
??_C@_0NL@PJCAENA@Malformed?5?$GAMstage_xforms?8?5attrib@ DB 'Malformed `'
	DB	'Mstage_xforms'' attribute encountered in `mcc_params::finaliz'
	DB	'e''.  The fourth field in a DEP or MATRIX record must hold on'
	DB	'e of the values 0 (irreversible) or 1 (reversible), with the '
	DB	'fifth field equal to zero.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0KH@KFJPFAEH@Malformed?5?$GAMstage_xforms?8?5attrib@
CONST	SEGMENT
??_C@_0KH@KFJPFAEH@Malformed?5?$GAMstage_xforms?8?5attrib@ DB 'Malformed '
	DB	'`Mstage_xforms'' attribute encountered in `mcc_params::finali'
	DB	'ze''.  The fourth field in a DWT record must contain a number'
	DB	' of DWT levels in the range 0 to 32.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0KK@DLAOAECJ@Malformed?5?$GAMstage_xforms?8?5attrib@
CONST	SEGMENT
??_C@_0KK@DLAOAECJ@Malformed?5?$GAMstage_xforms?8?5attrib@ DB 'Malformed '
	DB	'`Mstage_xforms'' attribute encountered in `mcc_params::finali'
	DB	'ze''.  Each record must have 5 fields, the second and third o'
	DB	'f which must lie in the range 0 to 255.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBC@MHOANFBM@Malformed?5?$GAMstage_blocks?8?5attrib@
CONST	SEGMENT
??_C@_0BBC@MHOANFBM@Malformed?5?$GAMstage_blocks?8?5attrib@ DB 'Malformed'
	DB	' `Mstage_blocks'' attribute encountered in `mcc_params::final'
	DB	'ize''.  The transform blocks must together consume all input '
	DB	'components defined by `Mstage_inputs'' (no more and no less) '
	DB	'and produce all output components defined by `Mstage_outputs'''
	DB	' (no more and no less).', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0KN@DKKKLGFN@Malformed?5?$GAMstage_blocks?8?5attrib@
CONST	SEGMENT
??_C@_0KN@DKKKLGFN@Malformed?5?$GAMstage_blocks?8?5attrib@ DB 'Malformed '
	DB	'`Mstage_blocks'' attribute encountered in `mcc_params::finali'
	DB	'ze''.  Each transform block must be assigned a strictly posit'
	DB	'ive number of input and output components.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0NA@EPMHNEKF@Illegal?5parameters?5supplied?5for?5@
CONST	SEGMENT
??_C@_0NA@EPMHNEKF@Illegal?5parameters?5supplied?5for?5@ DB 'Illegal para'
	DB	'meters supplied for `Mstage_outputs'' attribute.  Component i'
	DB	'ndex ranges must have lower bounds which do not exceed their '
	DB	'corresponding upper bounds, both of which must be in the rang'
	DB	'e 0 to 16383.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0MP@KPAJGLC@Illegal?5parameters?5supplied?5for?5@
CONST	SEGMENT
??_C@_0MP@KPAJGLC@Illegal?5parameters?5supplied?5for?5@ DB 'Illegal param'
	DB	'eters supplied for `Mstage_inputs'' attribute.  Component ind'
	DB	'ex ranges must have lower bounds which do not exceed their co'
	DB	'rresponding upper bounds, both of which must be in the range '
	DB	'0 to 16383.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
CONST	SEGMENT
??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@ DB 'Mstage_xforms', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IIP@CHGEJKJG@This?5attribute?5provides?5one?5reco@
CONST	SEGMENT
??_C@_0IIP@CHGEJKJG@This?5attribute?5provides?5one?5reco@ DB 'This attrib'
	DB	'ute provides one record for each transform block, which descr'
	DB	'ibes the type of transform to be implemented in that block an'
	DB	'd the parameters of the transform.  The first field identifie'
	DB	's the transform as one of "dependency transform" (`DEP''), "d'
	DB	'ecorrelation matrix transform" (`MATRIX''), or "discrete wave'
	DB	'let transform" (`DWT'').  Do not use the `MAT'' option; that '
	DB	'option is provided to catch backward compatibility problems w'
	DB	'ith Kakadu versions prior to v6.0, in which reversible decorr'
	DB	'elation matrix transforms used a non-compliant organization f'
	DB	'or the coefficient values.  Kakadu will refuse to generate co'
	DB	'destreams which use the `MAT'' option, although it should be '
	DB	'able to correctly recover and render codestreams generated wi'
	DB	'th this option prior to v6.0.  It does this by recognizing th'
	DB	'e absence of the `Cmct'' parameter attribute (another oversig'
	DB	'ht prior to v6.0) as an indication that the non-compliant org'
	DB	'anization is being used.', 0aH, 09H, 09H, '   The 2''nd field'
	DB	' of each record holds the instance index of the `Mtriang_coef'
	DB	'fs'' (for dependency transforms) or `Mmatrix_coeffs'' (for de'
	DB	'correlation matrix transforms) attributes, which provide the '
	DB	'actual transform coefficients, unless the transform is a DWT;'
	DB	' in this last case the 2''nd field holds 0 for the 9/7 DWT, 1'
	DB	' for the 5/3 DWT, or the instance index (in the range 2 to 25'
	DB	'5) of an `ATK'' marker segment whose `Kreversible'', `Ksymmet'
	DB	'ric'', `Kextension'', `Ksteps'' and `Kcoeffs'' attributes des'
	DB	'cribe the DWT kernel.', 0aH, 09H, 09H, '   The 3''rd field of'
	DB	' each record holds the instance index of the `Mvector_coeffs'''
	DB	' attribute which describes any offsets to be applied after in'
	DB	'verse transformation of the input components to the block.  A'
	DB	' value of 0 for this field means that there is no offset; oth'
	DB	'erwise, the value must be in the range 1 to 255.', 0aH, 09H, 09H
	DB	'   For DWT transforms, the 4''th field in the record identifi'
	DB	'es the number of DWT levels to be used, in the range 0 to 32,'
	DB	' while the final field holds the transform origin, which play'
	DB	's the same role as `Sorigin'', but along the component axis. '
	DB	' For dependency and decorrelation transforms, the 4''th field'
	DB	' must hold 0 if the transform is irreversible, or 1 if it is '
	DB	'reversible, while the 5''th field must hold 0.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JIOANCKI@?$CIDEP?$DN0?0MATRIX?$DN9?0DWT?$DN3?0MAT?$DN1000?$CJI@
CONST	SEGMENT
??_C@_0CE@JIOANCKI@?$CIDEP?$DN0?0MATRIX?$DN9?0DWT?$DN3?0MAT?$DN1000?$CJI@ DB '('
	DB	'DEP=0,MATRIX=9,DWT=3,MAT=1000)IIII', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
CONST	SEGMENT
??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@ DB 'Mstage_collections', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CLK@PPHGAGLD@This?5attribute?5provides?5the?5valu@
CONST	SEGMENT
??_C@_0CLK@PPHGAGLD@This?5attribute?5provides?5the?5valu@ DB 'This attrib'
	DB	'ute provides the values Nc and Mc which appear in the descrip'
	DB	'tions of `Mstage_inputs'' and `Mstage_outputs'', for each tra'
	DB	'nsform block (equivalently, each component collection), c.  T'
	DB	'he `Mstage_blocks'' parameter attribute should contain one re'
	DB	'cord for each transform.  Each record contains two strictly p'
	DB	'ositive integers, identifying the number of input components '
	DB	'Nk, and the number of output components, Mk, produced by the '
	DB	'k''th transform.  No transform may consume or produce 0 compo'
	DB	'nents.  Between them, the various transform blocks must consu'
	DB	'me all components in the input list described by `Mstage_inpu'
	DB	'ts'' and produce all components in the output list described '
	DB	'by `Mstage_outputs''.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
CONST	SEGMENT
??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@ DB 'Mstage_outputs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DLG@NNDEDDPH@This?5attribute?5is?5used?5to?5descri@
CONST	SEGMENT
??_C@_0DLG@NNDEDDPH@This?5attribute?5is?5used?5to?5descri@ DB 'This attri'
	DB	'bute is used to describe a list of output component indices w'
	DB	'hich are produced by this stage.  This list  of component ind'
	DB	'ices is a concatenation of the index ranges <A1>-<B1>, <A2>-<'
	DB	'B2>, ..., where An <= Bn are the first and second fields in t'
	DB	'he n''th record of the `Mstage_outputs'' attribute.  The list'
	DB	' of output component indices may not contain any repeated com'
	DB	'ponent indices, but it may contain "holes".  The transform st'
	DB	'age is considered to generate components with indices from 0 '
	DB	'to the largest index in the output list; any components in th'
	DB	'is range which are not listed (these are the holes) are taken'
	DB	' to be identically equal to 0.  The first transform block in '
	DB	'the stage processes the first N1 components in the list to pr'
	DB	'oduces the first M1 components in the output list; the second'
	DB	' transform block in the stage processes the next N1 component'
	DB	's in the input list, producing the next M2 components in the '
	DB	'output list; and so forth.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
CONST	SEGMENT
??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@ DB 'Mstage_inputs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DAF@JDFCJPDD@This?5attribute?5is?5used?5to?5descri@
CONST	SEGMENT
??_C@_0DAF@JDFCJPDD@This?5attribute?5is?5used?5to?5descri@ DB 'This attri'
	DB	'bute is used to describe a list of input component indices wh'
	DB	'ich are used by all transform blocks in a single stage of the'
	DB	' multi-component transform.  This list of component indices i'
	DB	's a concatenation of the index ranges <A1>-<B1>, <A2>-<B2>, .'
	DB	'.., where An <= Bn are the first and second fields in the n'''
	DB	'th record of the `Mstage_inputs'' attribute.   The list of in'
	DB	'put component indices may contain repeated values, but must c'
	DB	'over all components produced by the previous stage (or all co'
	DB	'destream component indices, if this is the first stage).  In '
	DB	'particular, it must always include 0.  The first transform bl'
	DB	'ock operates on the first N1 components identified by this li'
	DB	'st; the second transform block operates on the next N2 compon'
	DB	'ents in this list; and so forth.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03BOENIPFM@MCC?$AA@
CONST	SEGMENT
??_C@_03BOENIPFM@MCC?$AA@ DB 'MCC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BKIIOFOO@Malformed?5MCT?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0DF@BKIIOFOO@Malformed?5MCT?5marker?5segment?5enc@ DB 'Malformed MC'
	DB	'T marker segment encountered. The final ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@NNANLLPB@Malformed?5MCT?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EI@NNANLLPB@Malformed?5MCT?5marker?5segment?5enc@ DB 'Malformed MC'
	DB	'T marker segment encountered.  Marker segment is too small.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BCP@HHOAMAFM@Encountered?5out?9of?9order?5?$GAZmct?8?5@
CONST	SEGMENT
??_C@_0BCP@HHOAMAFM@Encountered?5out?9of?9order?5?$GAZmct?8?5@ DB 'Encoun'
	DB	'tered out-of-order `Zmct'' field while parsing MCT marker seg'
	DB	'ments belonging to a series.  While this is not strictly ille'
	DB	'gal, it makes no sense for a content creator to write MCT mar'
	DB	'ker segments out of order.  Kakadu does not currently support'
	DB	' reordering of these optional Part-2 marker segments.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBF@IPOKLLIB@Encountered?5repeat?5or?5out?9of?9ran@
CONST	SEGMENT
??_C@_0BBF@IPOKLLIB@Encountered?5repeat?5or?5out?9of?9ran@ DB 'Encountere'
	DB	'd repeat or out-of-range `Zmct'' field while parsing an MCT m'
	DB	'arker segment.  The `Zmct'' field is used to enumerate marker'
	DB	' segments which belong to a common series, but the value enco'
	DB	'untered is inconsistent with the rest of the series.  This is'
	DB	' a malformed codestream.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0NI@PEHFOKHE@The?5number?5of?5?$GAMmatrix_coeffs?8?0?5@
CONST	SEGMENT
??_C@_0NI@PEHFOKHE@The?5number?5of?5?$GAMmatrix_coeffs?8?0?5@ DB 'The num'
	DB	'ber of `Mmatrix_coeffs'', `Mvector_coeffs'' or `Mtriang_coeff'
	DB	's'' entries found while finalizing MCT transform coefficients'
	DB	' does not match the corresponding `Mmatrix_size'', `Mvector_s'
	DB	'ize'' or `Mtriang_size'' value.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0OJ@PDOPGBL@It?5is?5illegal?5to?5supply?5?$GAMvector@
CONST	SEGMENT
??_C@_0OJ@PDOPGBL@It?5is?5illegal?5to?5supply?5?$GAMvector@ DB 'It is ill'
	DB	'egal to supply `Mvector_size'', `Mtriang_size'' or `Mvector_s'
	DB	'ize'' attributes with zero-valued instance indices (equivalen'
	DB	'tly, with missing instance indices).  Use the ":I=..." suffix'
	DB	' when providing MCT transform coefficients.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JE@JFBAAJII@Illegal?5value?5?$CIanything?5?$DM?$DN?50?$CJ?5fo@
CONST	SEGMENT
??_C@_0JE@JFBAAJII@Illegal?5value?5?$CIanything?5?$DM?$DN?50?$CJ?5fo@ DB 'I'
	DB	'llegal value (anything <= 0) found for `Mmatrix_size'', `Mvec'
	DB	'tor_size'' or `Mtriang_size'' attribute while finalizing the '
	DB	'MCT transform coefficients.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0KN@OBNKNPAB@Failed?5to?5read?5all?5MCT?5marker?5se@
CONST	SEGMENT
??_C@_0KN@OBNKNPAB@Failed?5to?5read?5all?5MCT?5marker?5se@ DB 'Failed to '
	DB	'read all MCT marker segments in a series associated with a gi'
	DB	'ven `Imct'' index within a main or initial tile-part header. '
	DB	' Codestream is not correctly constructed.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@
CONST	SEGMENT
??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@ DB 'Mtriang_coeffs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CAB@FHBPNALP@Coefficients?5of?5the?5sub?9triangul@
CONST	SEGMENT
??_C@_0CAB@FHBPNALP@Coefficients?5of?5the?5sub?9triangul@ DB 'Coefficient'
	DB	's of the sub-triangular matrix, if any, whose number of eleme'
	DB	'nts is represented by the `Mtriang_size'' attribute.  The coe'
	DB	'fficients are arranged in row-major order.  Thus, for a depen'
	DB	'dency transform with M inputs and outputs, the first coeffici'
	DB	'ent (first two for reversible transforms) comes from the seco'
	DB	'nd row of the matrix, the next two (three for reversible tran'
	DB	'sforms) comes from the third row of the matrix, and so forth.'
	DB	'  For reversible transforms, the coefficients must all have i'
	DB	'nteger values.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CCNKIJHO@Mtriang_size?$AA@
CONST	SEGMENT
??_C@_0N@CCNKIJHO@Mtriang_size?$AA@ DB 'Mtriang_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EBK@HDHPILKI@Identifies?5the?5total?5number?5of?5s@
CONST	SEGMENT
??_C@_0EBK@HDHPILKI@Identifies?5the?5total?5number?5of?5s@ DB 'Identifies'
	DB	' the total number of sub-triangular matrix elements, if any, '
	DB	'represented by this object.  A sub-triangular matrix is squar'
	DB	'e, with no coefficients above the diagonal and at least one c'
	DB	'oefficient missing from the diagonal.  A strictly sub-triangu'
	DB	'lar M x M matrix will have M*(M-1)/2 coefficients, all below '
	DB	'the diagonal.  Matrices of this form are used to describe irr'
	DB	'eversible multicomponent dependency transforms.  Reversible d'
	DB	'ependency transforms, however, include all but the upper left'
	DB	' diagonal entry, for a total of M*(M+1)/2-1 coefficients.  De'
	DB	'pendency transforms are described by referencing the current '
	DB	'attribute''s instance index from the second field in each rec'
	DB	'ord of the `Mstage_xforms'' attribute used to describe a mult'
	DB	'i-component transform stage.  Thus, for example, "Mstage_xfor'
	DB	'ms:I1={DEP,5,0,0,0}" declares that a given multi-component tr'
	DB	'ansform stage, having instance index 1, and one component col'
	DB	'lection, employs a dependency transform, whose coefficients a'
	DB	're counted by `Mtriang_size:I5'' and found in `Mtriang_coeffs'
	DB	':I5''.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DIALIICI@Mvector_coeffs?$AA@
CONST	SEGMENT
??_C@_0P@DIALIICI@Mvector_coeffs?$AA@ DB 'Mvector_coeffs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BEO@GFEMDFDK@Coefficients?5of?5the?5vector?0?5if?5t@
CONST	SEGMENT
??_C@_0BEO@GFEMDFDK@Coefficients?5of?5the?5vector?0?5if?5t@ DB 'Coefficie'
	DB	'nts of the vector, if there is one, whose number of elements '
	DB	'is given by `Mvector_size''.  Unlike `Mmatrix_coeffs'' and `M'
	DB	'triang_coeffs'', this attribute is extrapolated if insufficie'
	DB	'nt parameters are supplied -- that is, the last supplied valu'
	DB	'e is replicated as required in order to provide all `Mvector_'
	DB	'size'' vector elements.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EBBFOCKJ@Mvector_size?$AA@
CONST	SEGMENT
??_C@_0N@EBBFOCKJ@Mvector_size?$AA@ DB 'Mvector_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DNI@IDMIDCPL@Identifies?5the?5number?5of?5vector?5@
CONST	SEGMENT
??_C@_0DNI@IDMIDCPL@Identifies?5the?5number?5of?5vector?5@ DB 'Identifies'
	DB	' the number of vector elements, if any, represented by this o'
	DB	'bject.  The actual vector coefficients are represented by the'
	DB	' `Mvector_coeffs'' attribute.  Vectors are used to describe o'
	DB	'ffsets to be applied to the component sample values after inv'
	DB	'erse transformation.  This is done by referencing the current'
	DB	' attribute''s instance index from the third field in each rec'
	DB	'ord of the `Mstage_xforms'' attribute used to describe a mult'
	DB	'i-component transform stage.  Thus, for example, "Mstage_xfor'
	DB	'ms:I1={MATRIX,1,4,0,0},{MATRIX,3,0,1,0}" declares that a give'
	DB	'n multi-component transform stage, having instance index 1, a'
	DB	'nd two component collections, employs matrix transforms for b'
	DB	'oth collections.  The first collection also involves offsets,'
	DB	' described via `Mvector_size:I4'' and `Mvector_coeffs:I4'', w'
	DB	'hile the second collection does not use offsets.  to understa'
	DB	'nd the remaining fields in each record of the `Mstage_xforms'''
	DB	' attribute, consult the separate description of that attribut'
	DB	'e.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
CONST	SEGMENT
??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@ DB 'Mmatrix_coeffs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BGK@IHFIBLIK@Coefficients?5of?5the?5matrix?0?5if?5t@
CONST	SEGMENT
??_C@_0BGK@IHFIBLIK@Coefficients?5of?5the?5matrix?0?5if?5t@ DB 'Coefficie'
	DB	'nts of the matrix, if there is one, whose number of elements '
	DB	'is given by `Mmatrix_size''.  The coefficients appear in row-'
	DB	'major order (first row, then second row, etc.).  The height a'
	DB	'nd width of the matrix are not recorded here, but matrices ar'
	DB	'e not required to be square.  For reversible transforms, the '
	DB	'matrix coefficients are required to be integers.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01BIAFAFID@F?$AA@
CONST	SEGMENT
??_C@_01BIAFAFID@F?$AA@ DB 'F', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FIDBGNAL@Mmatrix_size?$AA@
CONST	SEGMENT
??_C@_0N@FIDBGNAL@Mmatrix_size?$AA@ DB 'Mmatrix_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DPN@GBDINPGJ@Identifies?5the?5number?5of?5matrix?5@
CONST	SEGMENT
??_C@_0DPN@GBDINPGJ@Identifies?5the?5number?5of?5matrix?5@ DB 'Identifies'
	DB	' the number of matrix elements, if any, represented by this o'
	DB	'bject.  The actual matrix coefficients are represented by the'
	DB	' `Mmatrix_coeffs'' attribute.  Matrices are used to describe '
	DB	'reversible and irreversible inverse component decorrelation t'
	DB	'ransforms.  This is done by referencing the current attribute'
	DB	'''s instance index from the second field in each record of th'
	DB	'e `Mstage_xforms'' attribute used to describe a multi-compone'
	DB	'nt transformation stage.  Thus, for example, "Mstage_xforms:I'
	DB	'1={MATRIX,1,4,0,0},{MATRIX,3,0,1,0}" declares that a given mu'
	DB	'lti-component transform stage, having instance index 1, and t'
	DB	'wo component collections, employs matrix transforms for both '
	DB	'collections.  The first collection''s matrix is described by '
	DB	'`Mmatrix_size:I1'' and `Mmatrix_coeffs:I1'', while the second'
	DB	' collection''s matrix is described by `Mmatrix_size:I3'' and '
	DB	'`Mmatrix_coeffs:I3''.  To understand the last two fields in e'
	DB	'ach record of the `Mstage_xforms'' attribute, please refer to'
	DB	' the separate description of that attribute.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLMOALMK@MCT?$AA@
CONST	SEGMENT
??_C@_03BLMOALMK@MCT?$AA@ DB 'MCT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAE@JMBBANBI@Profile?5violation?5detected?4?5?5You@
CONST	SEGMENT
??_C@_0BAE@JMBBANBI@Profile?5violation?5detected?4?5?5You@ DB 'Profile vi'
	DB	'olation detected.  You have supplied `Porder'' attributes whi'
	DB	'ch are not consistent with the 4K Digital Cinema profile (CIN'
	DB	'EMA4K).  You should let the parameter management system set t'
	DB	'hese for you, to ensure compliance with the Digital Cinema pr'
	DB	'ofile.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06NMKHLFPN@Porder?$AA@
CONST	SEGMENT
??_C@_06NMKHLFPN@Porder?$AA@ DB 'Porder', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LFCEPJHK@POC?$AA@
CONST	SEGMENT
??_C@_03LFCEPJHK@POC?$AA@ DB 'POC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAO@JPIFODPP@Profile?5violation?5detected?4?5?5Cod@
CONST	SEGMENT
??_C@_0BAO@JPIFODPP@Profile?5violation?5detected?4?5?5Cod@ DB 'Profile vi'
	DB	'olation detected.  Code-streams marked with a Digital Cinema '
	DB	'profile (CINEMA2K or CINEMA4K) must have tile-parts generated'
	DB	' according to the "ORGtparts=C" flavour.  Letting this go for'
	DB	' now, since you may be intending to reorganize tile-parts you'
	DB	'rself later on.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09CNLDEMAK@ORGtparts?$AA@
CONST	SEGMENT
??_C@_09CNLDEMAK@ORGtparts?$AA@ DB 'ORGtparts', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CIAEHHDE@ORGgen_tlm?$AA@
CONST	SEGMENT
??_C@_0L@CIAEHHDE@ORGgen_tlm?$AA@ DB 'ORGgen_tlm', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MNMMELJE@ORG?$AA@
CONST	SEGMENT
??_C@_03MNMMELJE@ORG?$AA@ DB 'ORG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0JJ@DLDOMHMJ@Profile?5violation?5detected?4?5?5Cod@
CONST	SEGMENT
??_C@_0JJ@DLDOMHMJ@Profile?5violation?5detected?4?5?5Cod@ DB 'Profile vio'
	DB	'lation detected.  Code-streams marked with the CINEMA4K Digit'
	DB	'al Cinema profile may have a maximum width of 4096 and a maxi'
	DB	'mum height of 2160.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0JJ@ELMILGL@Profile?5violation?5detected?4?5?5Cod@
CONST	SEGMENT
??_C@_0JJ@ELMILGL@Profile?5violation?5detected?4?5?5Cod@ DB 'Profile viol'
	DB	'ation detected.  Code-streams marked with the CINEMA2K Digita'
	DB	'l Cinema profile may have a maximum width of 2048 and a maxim'
	DB	'um height of 1080.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@KEPFIMCP@Profile?5violation?5detected?4?5?5Cod@
CONST	SEGMENT
??_C@_0HP@KEPFIMCP@Profile?5violation?5detected?4?5?5Cod@ DB 'Profile vio'
	DB	'lation detected.  Code-streams marked with a Digital Cinema p'
	DB	'rofile (CINEMA2K or CINEMA4K) must have only one tile.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0KG@LAENILL@Profile?5violation?5detected?4?5?5Cod@
CONST	SEGMENT
??_C@_0KG@LAENILL@Profile?5violation?5detected?4?5?5Cod@ DB 'Profile viol'
	DB	'ation detected.  Code-streams marked with a Digital Cinema pr'
	DB	'ofile (CINEMA2K or CINEMA4K) must have their image and tile p'
	DB	'artition anchored a the origin.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0NP@LDCOLEKI@Profile?5violation?5detected?4?5?5Cod@
CONST	SEGMENT
??_C@_0NP@LDCOLEKI@Profile?5violation?5detected?4?5?5Cod@ DB 'Profile vio'
	DB	'lation detected.  Code-streams marked with a Digital Cinema p'
	DB	'rofile (CINEMA2K or CINEMA4K) must have exactly 3 image compo'
	DB	'nents, each unsigned with a precision of 12 bits and all sub-'
	DB	'sampling factors equal to 1.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IJ@LMINEOIM@Code?9stream?5profile?5had?5to?5be?5ch@
CONST	SEGMENT
??_C@_0IJ@LMINEOIM@Code?9stream?5profile?5had?5to?5be?5ch@ DB 'Code-strea'
	DB	'm profile had to be changed from a digital cinema profile to '
	DB	'a PART2 profile, since one or more PART2 features have been u'
	DB	'sed.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
CONST	SEGMENT
??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@ DB 'Kakadu Core Warning'
	DB	':', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
CONST	SEGMENT
??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@ DB 'Calign_blk_last', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BNGLHLNI@Ksymmetric?$AA@
CONST	SEGMENT
??_C@_0L@BNGLHLNI@Ksymmetric?$AA@ DB 'Ksymmetric', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03IFCLAPBJ@ATK?$AA@
CONST	SEGMENT
??_C@_03IFCLAPBJ@ATK?$AA@ DB 'ATK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HAOFMIPN@Catk?$AA@
CONST	SEGMENT
??_C@_04HAOFMIPN@Catk?$AA@ DB 'Catk', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NKICNHII@Cdfs?$AA@
CONST	SEGMENT
??_C@_04NKICNHII@Cdfs?$AA@ DB 'Cdfs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OONIPDNE@Cads?$AA@
CONST	SEGMENT
??_C@_04OONIPDNE@Cads?$AA@ DB 'Cads', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BFE@FLEIONEE@Illegal?5profile?5index?4?5?5?$CCSprofil@
CONST	SEGMENT
??_C@_0BFE@FLEIONEE@Illegal?5profile?5index?4?5?5?$CCSprofil@ DB 'Illegal'
	DB	' profile index.  "Sprofile" must be in the range 0 to 5: Prof'
	DB	'ile-0 is the most restrictive original Part-1 profile; Profil'
	DB	'e-2 is the unrestricted Part-1 profile; 3 means that the code'
	DB	'stream conforms to Part-2 of the standard; 4 and 5 are for th'
	DB	'e restrictive Digital Cinema profiles, added by an ammendment'
	DB	' to Part-1 of the standard.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0MN@GGGLGLFK@Problems?5trying?5to?5finalize?5SIZ?5@
CONST	SEGMENT
??_C@_0MN@GGGLGLFK@Problems?5trying?5to?5finalize?5SIZ?5@ DB 'Problems tr'
	DB	'ying to finalize SIZ information. Illegal tile origin coordin'
	DB	'ates.  The first tile must have a non-empty intersection with'
	DB	' the image region on the canvas. Available information is as '
	DB	'follows:', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HB@GIGMGNIM@Problem?5trying?5to?5finalize?5SIZ?5i@
CONST	SEGMENT
??_C@_0HB@GIGMGNIM@Problem?5trying?5to?5finalize?5SIZ?5i@ DB 'Problem try'
	DB	'ing to finalize SIZ information. Dimensions are inconsistent.'
	DB	'  Available information is as follows:', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JM@LALDBFDG@Problem?5trying?5to?5finalize?5SIZ?5i@
CONST	SEGMENT
??_C@_0JM@LALDBFDG@Problem?5trying?5to?5finalize?5SIZ?5i@ DB 'Problem try'
	DB	'ing to finalize SIZ information. Vertical component dimension'
	DB	's and sub-sampling factors are incompatible. Available inform'
	DB	'ation is as follows:', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0JO@OKOEKKHK@Problem?5trying?5to?5finalize?5SIZ?5i@
CONST	SEGMENT
??_C@_0JO@OKOEKKHK@Problem?5trying?5to?5finalize?5SIZ?5i@ DB 'Problem try'
	DB	'ing to finalize SIZ information. Horizontal component dimensi'
	DB	'ons and sub-sampling factors are incompatible. Available info'
	DB	'rmation is as follows:', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0JH@IIBMOHD@Problem?5trying?5to?5finalize?5SIZ?5i@
CONST	SEGMENT
??_C@_0JH@IIBMOHD@Problem?5trying?5to?5finalize?5SIZ?5i@ DB 'Problem tryi'
	DB	'ng to finalize SIZ information. Vertical canvas and image com'
	DB	'ponent dimensions are not compatible.  Available information '
	DB	'is as follows:', 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0JJ@NPLIAPKO@Problem?5trying?5to?5finalize?5SIZ?5i@
CONST	SEGMENT
??_C@_0JJ@NPLIAPKO@Problem?5trying?5to?5finalize?5SIZ?5i@ DB 'Problem try'
	DB	'ing to finalize SIZ information. Horizontal canvas and image '
	DB	'component dimensions are not compatible.  Available informati'
	DB	'on is as follows:', 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0KE@JLIAOLIC@Problem?5trying?5to?5finalize?5SIZ?5i@
CONST	SEGMENT
??_C@_0KE@JLIAOLIC@Problem?5trying?5to?5finalize?5SIZ?5i@ DB 'Problem try'
	DB	'ing to finalize SIZ information Component dimensions are not '
	DB	'consistent with a legal set of sub-sampling factors. Availabl'
	DB	'e information is as follows:', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JH@NJJGGCNE@Problem?5trying?5to?5finalize?5SIZ?5i@
CONST	SEGMENT
??_C@_0JH@NJJGGCNE@Problem?5trying?5to?5finalize?5SIZ?5i@ DB 'Problem try'
	DB	'ing to finalize SIZ information. Must have either the image c'
	DB	'omponent dimensions or the canvas size! Available information'
	DB	' is as follows:', 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0II@DHNDEJOJ@Problem?5trying?5to?5finalize?5SIZ?5i@
CONST	SEGMENT
??_C@_0II@DHNDEJOJ@Problem?5trying?5to?5finalize?5SIZ?5i@ DB 'Problem try'
	DB	'ing to finalize SIZ information. Must have either the individ'
	DB	'ual component dimensions or the component sub-sampling factor'
	DB	's.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@FCCPDFNF@Image?5component?5sub?9sampling?5fac@
CONST	SEGMENT
??_C@_0EA@FCCPDFNF@Image?5component?5sub?9sampling?5fac@ DB 'Image compon'
	DB	'ent sub-sampling factors must be strictly positive!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@PICGKKPJ@Problem?5trying?5to?5finalize?5SIZ?5i@
CONST	SEGMENT
??_C@_0GI@PICGKKPJ@Problem?5trying?5to?5finalize?5SIZ?5i@ DB 'Problem try'
	DB	'ing to finalize SIZ information Component sub-sampling factor'
	DB	's are only partially available!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@HBBHOMDC@Problem?5trying?5to?5finalize?5SIZ?5i@
CONST	SEGMENT
??_C@_0FP@HBBHOMDC@Problem?5trying?5to?5finalize?5SIZ?5i@ DB 'Problem try'
	DB	'ing to finalize SIZ information. Component dimensions are onl'
	DB	'y partially available!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0JL@PLHBNPBC@Problem?5trying?5to?5finalize?5SIZ?5i@
CONST	SEGMENT
??_C@_0JL@PLHBNPBC@Problem?5trying?5to?5finalize?5SIZ?5i@ DB 'Problem try'
	DB	'ing to finalize SIZ information. Insufficient data supplied t'
	DB	'o determine the number of image components! Available informa'
	DB	'tion is as follows:', 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@FOFCLFAN@Malformed?5CBD?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EH@FOFCLFAN@Malformed?5CBD?5marker?5segment?5enc@ DB 'Malformed CB'
	DB	'D marker segment encountered. Marker segment is too small.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PNFFNEFI@Malformed?5CBD?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0DF@PNFFNEFI@Malformed?5CBD?5marker?5segment?5enc@ DB 'Malformed CB'
	DB	'D marker segment encountered. The final ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@PJEAPICM@Malformed?5SIZ?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0EH@PJEAPICM@Malformed?5SIZ?5marker?5segment?5enc@ DB 'Malformed SI'
	DB	'Z marker segment encountered. Marker segment is too small.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@
CONST	SEGMENT
??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@ DB ' bytes were '
	DB	'not consumed!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@MIHNMLL@Malformed?5SIZ?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0DF@MIHNMLL@Malformed?5SIZ?5marker?5segment?5enc@ DB 'Malformed SIZ'
	DB	' marker segment encountered. The final ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CLEFFBLP@Invalid?5SIZ?5marker?5segment?5encou@
CONST	SEGMENT
??_C@_0CI@CLEFFBLP@Invalid?5SIZ?5marker?5segment?5encou@ DB 'Invalid SIZ '
	DB	'marker segment encountered!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JHCHBCDJ@Illegal?5precision?5for?5MCT?5output@
CONST	SEGMENT
??_C@_0CN@JHCHBCDJ@Illegal?5precision?5for?5MCT?5output@ DB 'Illegal prec'
	DB	'ision for MCT output component, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0HM@MMCEOMEI@Unable?5to?5write?5CBD?5marker?5segme@
CONST	SEGMENT
??_C@_0HM@MMCEOMEI@Unable?5to?5write?5CBD?5marker?5segme@ DB 'Unable to w'
	DB	'rite CBD marker segment! Precision or signed/unsigned informa'
	DB	'tion missing for at least one MCT output component.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HBCCFDNA@?$HN?4?5Legal?5range?5is?5from?51?5to?5255?4@
CONST	SEGMENT
??_C@_0CB@HBCCFDNA@?$HN?4?5Legal?5range?5is?5from?51?5to?5255?4@ DB '}. L'
	DB	'egal range is from 1 to 255.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FCLHCLL@Illegal?5component?5sub?9sampling?5f@
CONST	SEGMENT
??_C@_0CK@FCLHCLL@Illegal?5component?5sub?9sampling?5f@ DB 'Illegal compo'
	DB	'nent sub-sampling factors, {', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NJAPNNOL@?4?5Legal?5range?5is?5from?51?5to?538?5bi@
CONST	SEGMENT
??_C@_0CP@NJAPNNOL@?4?5Legal?5range?5is?5from?51?5to?538?5bi@ DB '. Legal'
	DB	' range is from 1 to 38 bits per sample.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NEMDCGAB@Illegal?5image?5sample?5bit?9depth?0?5@
CONST	SEGMENT
??_C@_0CB@NEMDCGAB@Illegal?5image?5sample?5bit?9depth?0?5@ DB 'Illegal im'
	DB	'age sample bit-depth, ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GO@MOMFJPHA@Unable?5to?5write?5SIZ?5marker?5segme@
CONST	SEGMENT
??_C@_0GO@MOMFJPHA@Unable?5to?5write?5SIZ?5marker?5segme@ DB 'Unable to w'
	DB	'rite SIZ marker segment! Precision or sub-sampling informatio'
	DB	'n missing for at least one component.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@BDHEFLHF@Illegal?5profile?5index?4?5?5?$CCSprofil@
CONST	SEGMENT
??_C@_0HF@BDHEFLHF@Illegal?5profile?5index?4?5?5?$CCSprofil@ DB 'Illegal '
	DB	'profile index.  "Sprofile" must be set in the range 0 to 5; 3'
	DB	' is required if Part 2 features are to be used.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JL@PMLPBNBK@Cannot?5write?5SIZ?5marker?5with?5ill@
CONST	SEGMENT
??_C@_0JL@PMLPBNBK@Cannot?5write?5SIZ?5marker?5with?5ill@ DB 'Cannot writ'
	DB	'e SIZ marker with illegal canvas coordinates.  The first tile'
	DB	' is required to have a non-empty intersection with the image '
	DB	'region on the canvas.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0OI@OALKHBMD@Error?5attempting?5to?5convert?5geom@
CONST	SEGMENT
??_C@_0OI@OALKHBMD@Error?5attempting?5to?5convert?5geom@ DB 'Error attemp'
	DB	'ting to convert geometrically transformed canvas coordinates '
	DB	'to legal marker ranges.  Try using a smaller precinct size (y'
	DB	'ou can use the transcoding utility to achieve this at the sam'
	DB	'e time as geometric transformations.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KGBLICHL@Cprecincts?$AA@
CONST	SEGMENT
??_C@_0L@KGBLICHL@Cprecincts?$AA@ DB 'Cprecincts', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0NO@JDICNLBH@Attempting?5to?5write?5geometricall@
CONST	SEGMENT
??_C@_0NO@JDICNLBH@Attempting?5to?5write?5geometricall@ DB 'Attempting to'
	DB	' write geometrically transformed SIZ marker information witho'
	DB	'ut attaching and finalizing all tile-component COD marker inf'
	DB	'ormation.  This is essential to establish canvas coordinate e'
	DB	'quivalence relationships.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
CONST	SEGMENT
??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@ DB 'Cuse_precincts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BGFFFHMP@Clevels?$AA@
CONST	SEGMENT
??_C@_07BGFFFHMP@Clevels?$AA@ DB 'Clevels', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@POPHKFAB@Illegal?5number?5of?5MCT?5output?5com@
CONST	SEGMENT
??_C@_0FJ@POPHKFAB@Illegal?5number?5of?5MCT?5output?5com@ DB 'Illegal num'
	DB	'ber of MCT output components, `Mcomponents''! Must be in the '
	DB	'range 0 to 16384.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@JGBMKHNL@Illegal?5number?5of?5image?5componen@
CONST	SEGMENT
??_C@_0EF@JGBMKHNL@Illegal?5number?5of?5image?5componen@ DB 'Illegal numb'
	DB	'er of image components! Must be in the range 1 to 16384.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CMGIGAHL@Unable?5to?5write?5SIZ?5marker?5segme@
CONST	SEGMENT
??_C@_0CI@CMGIGAHL@Unable?5to?5write?5SIZ?5marker?5segme@ DB 'Unable to w'
	DB	'rite SIZ marker segment yet!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0OO@EELGDABM@Cannot?5apply?5requested?5resolutio@
CONST	SEGMENT
??_C@_0OO@EELGDABM@Cannot?5apply?5requested?5resolutio@ DB 'Cannot apply '
	DB	'requested resolution reduction without creating a SIZ marker '
	DB	'segment with illegal component sub-sampling factors.  For the'
	DB	' current code-stream, sub-sampling factors would be required '
	DB	'which exceed the legal range of 1 to 255.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LIMJJHMM@COD?$AA@
CONST	SEGMENT
??_C@_03LIMJJHMM@COD?$AA@ DB 'COD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@BLNJMGGP@Attempting?5to?5discard?5all?5of?5the@
CONST	SEGMENT
??_C@_0EK@BLNJMGGP@Attempting?5to?5discard?5all?5of?5the@ DB 'Attempting '
	DB	'to discard all of the components from an existing code-stream'
	DB	'!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0IK@CCHOHMJN@Unable?5to?5copy?5SIZ?5parameters?0?5u@
CONST	SEGMENT
??_C@_0IK@CCHOHMJN@Unable?5to?5copy?5SIZ?5parameters?0?5u@ DB 'Unable to '
	DB	'copy SIZ parameters, unless all canvas coordinates are availa'
	DB	'ble.  Try using `siz_params::finalize'' before attempting the'
	DB	' copy.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OMLPDKKH@Mprecision?$AA@
CONST	SEGMENT
??_C@_0L@OMLPDKKH@Mprecision?$AA@ DB 'Mprecision', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BFE@NNIAEAJM@Indicates?5the?5bit?9depth?5of?5each?5@
CONST	SEGMENT
??_C@_0BFE@NNIAEAJM@Indicates?5the?5bit?9depth?5of?5each?5@ DB 'Indicates'
	DB	' the bit-depth of each MCT output component (see `Mcomponents'
	DB	''' for a definition of "MCT output components").  If fewer th'
	DB	'an `Mcomponents'' values are provided, the last supplied iden'
	DB	'tifier is repeated indefinitely for all remaining components.'
	DB	0aH, 09H, 09H, '[Compressors might be able to deduce this info'
	DB	'rmation from the image files supplied.]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GFFIOPIL@Msigned?$AA@
CONST	SEGMENT
??_C@_07GFFIOPIL@Msigned?$AA@ DB 'Msigned', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BHF@DJPMMPEM@Indicates?5whether?5each?5MCT?5outpu@
CONST	SEGMENT
??_C@_0BHF@DJPMMPEM@Indicates?5whether?5each?5MCT?5outpu@ DB 'Indicates w'
	DB	'hether each MCT output component (see `Mcomponents'' for a de'
	DB	'finition of "MCT output components") contains signed or unsig'
	DB	'ned sample values.  If fewer than `Mcomponents'' values are p'
	DB	'rovided, the last supplied identifier is repeated indefinitel'
	DB	'y for all remaining components.', 0aH, 09H, 09H, '[Compressor'
	DB	's might be able to deduce this information from the image fil'
	DB	'es supplied.]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FAIBBHLL@Mcomponents?$AA@
CONST	SEGMENT
??_C@_0M@FAIBBHLL@Mcomponents?$AA@ DB 'Mcomponents', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FFB@NCBJOMEF@Number?5of?5image?5components?5produ@
CONST	SEGMENT
??_C@_0FFB@NCBJOMEF@Number?5of?5image?5components?5produ@ DB 'Number of i'
	DB	'mage components produced at the output of the inverse multi-c'
	DB	'omponent transform -- during compression, you may think of th'
	DB	'ese as original image comonents.  In any event, we refer to t'
	DB	'hem as "MCT output components", taking the perspective of the'
	DB	' decompressor.  The value of `Mcomponents'' may be smaller th'
	DB	'an or larger than the `Scomponents'' value, which refers to t'
	DB	'he number of "codestream image components".  The codestream i'
	DB	'mage components are supplied to the input of the inverse mult'
	DB	'i-component transform.  Note carefully, however, that for Kak'
	DB	'adu to perform a forward multi-component transform on image d'
	DB	'ata supplied to a compressor, the value of `Mcomponents'' mus'
	DB	't be at least as large as `Scomponents'' and the inverse mult'
	DB	'i-component transform must provide sufficient invertible tran'
	DB	'sform blocks to derive the codestream components from the out'
	DB	'put image components.  In the special case where `Mcomponents'
	DB	''' is 0, or not specified, there is no multi-component transf'
	DB	'orm.  In this case, `Scomponents'', `Ssigned'' and `Sprecisio'
	DB	'n'' define the output image components.', 09H, 09H, '[Default'
	DB	's to 0.  You must explicitly set a non-zero value for this at'
	DB	'tribute if you want to use Part-2 multi-component transforms.'
	DB	'  Compressors might be able to deduce this information from t'
	DB	'he input files, if they are aware that you want to perform a '
	DB	'multi-component transform.]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKKGDPEH@Sdims?$AA@
CONST	SEGMENT
??_C@_05KKKGDPEH@Sdims?$AA@ DB 'Sdims', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BGE@DJOJEOK@Indicates?5the?5dimensions?5?$CIvertic@
CONST	SEGMENT
??_C@_0BGE@DJOJEOK@Indicates?5the?5dimensions?5?$CIvertic@ DB 'Indicates '
	DB	'the dimensions (vertical, then horizontal) of each individual'
	DB	' image component. The last supplied record is repeated indefi'
	DB	'nitely for all remaining components.', 0aH, 09H, 09H, '[For c'
	DB	'ompressors, the image component dimensions will normally be d'
	DB	'educed from the image files supplied to the compressor, but m'
	DB	'ay be explicitly set if raw input files are to be used.]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IGDOMJM@Ssampling?$AA@
CONST	SEGMENT
??_C@_09IGDOMJM@Ssampling?$AA@ DB 'Ssampling', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BIA@NFIIFPMP@Indicates?5the?5sub?9sampling?5facto@
CONST	SEGMENT
??_C@_0BIA@NFIIFPMP@Indicates?5the?5sub?9sampling?5facto@ DB 'Indicates t'
	DB	'he sub-sampling factors for each codestream image component. '
	DB	'In each record, the vertical factor appears first, followed b'
	DB	'y the horizontal sub-sampling factor. The last supplied recor'
	DB	'd is repeated indefinitely for all remaining components.', 0aH
	DB	09H, 09H, '[For compressors, a suitable set of sub-sampling fa'
	DB	'ctors will normally be deduced from the individual image comp'
	DB	'onent dimensions.]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BADPNFGK@Sprecision?$AA@
CONST	SEGMENT
??_C@_0L@BADPNFGK@Sprecision?$AA@ DB 'Sprecision', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CLK@EPFPBPLL@Indicates?5the?5bit?9depth?5of?5each?5@
CONST	SEGMENT
??_C@_0CLK@EPFPBPLL@Indicates?5the?5bit?9depth?5of?5each?5@ DB 'Indicates'
	DB	' the bit-depth of each codestream image component.', 0aH, 09H
	DB	09H, '[For compressors, this will normally be deduced from the'
	DB	' image files supplied to the compressor, but may need to be e'
	DB	'xplicitly set if raw input files are to be used.  Also, if yo'
	DB	'u happen to be using the Part-2 multi-component transform cap'
	DB	'abilities, the precision of the original image components sho'
	DB	'uld be expressed by `Mprecision''; in this case, you will nee'
	DB	'd to explicitly set `Sprecision'' to reflect the bit-depth of'
	DB	' the codestream image components produced after subjecting th'
	DB	'e original components to the forward multi-component transfor'
	DB	'm.  Note that the last supplied value is repeated indefinitel'
	DB	'y for all remaining components.]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MGJMMJC@Ssigned?$AA@
CONST	SEGMENT
??_C@_07MGJMMJC@Ssigned?$AA@ DB 'Ssigned', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DAJ@MODEBBAE@Indicates?5whether?5each?5codestrea@
CONST	SEGMENT
??_C@_0DAJ@MODEBBAE@Indicates?5whether?5each?5codestrea@ DB 'Indicates wh'
	DB	'ether each codestream image component contains signed or unsi'
	DB	'gned sample values.', 0aH, 09H, 09H, '[For compressors, this '
	DB	'will normally be deduced from the image files supplied to the'
	DB	' compressor, but may be explicitly set if raw input files are'
	DB	' to be used.  Also, if you happen to be using the Part-2 mult'
	DB	'i-component transform capabilities, the signed/unsigned attri'
	DB	'butes of the original image components should be expressed by'
	DB	' `Msigned''; in this case, you will need to explicitly set `S'
	DB	'signed'' in a manner which reflects the signed/unsigned chara'
	DB	'cteristics of the codestream image components produced after '
	DB	'subjecting the original components to the forward multi-compo'
	DB	'nent transform.  Note that the last supplied identifier is re'
	DB	'peated indefinitely for all remaining components.]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LFKICJFJ@Scomponents?$AA@
CONST	SEGMENT
??_C@_0M@LFKICJFJ@Scomponents?$AA@ DB 'Scomponents', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CDM@NAGNLIBN@Number?5of?5codestream?5image?5compo@
CONST	SEGMENT
??_C@_0CDM@NAGNLIBN@Number?5of?5codestream?5image?5compo@ DB 'Number of c'
	DB	'odestream image components.', 0aH, 09H, 09H, '[For compressor'
	DB	's, this will normally be deduced from the number and type of '
	DB	'image files supplied to the compressor.  Note carefully, howe'
	DB	'ver, that if a multi-component transform is used, the number '
	DB	'of codestream image components might not be equal to the numb'
	DB	'er of `output image components'' given by `Mcomponents''.  In'
	DB	' this case, the value of `Mcomponents'' and the corresponding'
	DB	' `Mprecision'' and `Msigned'' attributes should generally be '
	DB	'associated with the image files being read (for compression) '
	DB	'or written (for decompression).]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
CONST	SEGMENT
??_C@_0N@KMIIMNEN@Stile_origin?$AA@ DB 'Stile_origin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@GFLJDJGF@Tile?5origin?5on?5the?5canvas?3?5verti@
CONST	SEGMENT
??_C@_0EM@GFLJDJGF@Tile?5origin?5on?5the?5canvas?3?5verti@ DB 'Tile origi'
	DB	'n on the canvas: vertical coordinate first.', 0aH, 09H, 09H, '['
	DB	'Defaults to {0,0}]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06EPMBOCAF@Stiles?$AA@
CONST	SEGMENT
??_C@_06EPMBOCAF@Stiles?$AA@ DB 'Stiles', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@BCOJOGJB@Tile?5partition?5size?3?5vertical?5di@
CONST	SEGMENT
??_C@_0EF@BCOJOGJB@Tile?5partition?5size?3?5vertical?5di@ DB 'Tile partit'
	DB	'ion size: vertical dimension first.', 0aH, 09H, 09H, '[Defaul'
	DB	'ts to {0,0}]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07PEMLCIHF@Sorigin?$AA@
CONST	SEGMENT
??_C@_07PEMLCIHF@Sorigin?$AA@ DB 'Sorigin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GN@LGNONLIP@Image?5origin?5on?5canvas?3?5vertical@
CONST	SEGMENT
??_C@_0GN@LGNONLIP@Image?5origin?5on?5canvas?3?5vertical@ DB 'Image origi'
	DB	'n on canvas: vertical coordinate first.', 0aH, 09H, 09H, '[De'
	DB	'faults to {0,0}, or the tile origin if one is given]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05HNJHHEPH@Ssize?$AA@
CONST	SEGMENT
??_C@_05HNJHHEPH@Ssize?$AA@ DB 'Ssize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BDP@GFLEIBAO@Canvas?5dimensions?3?5vertical?5dime@
CONST	SEGMENT
??_C@_0BDP@GFLEIBAO@Canvas?5dimensions?3?5vertical?5dime@ DB 'Canvas dime'
	DB	'nsions: vertical dimension first.', 0aH, 09H, 09H, '[For comp'
	DB	'ressors, this will normally be derived from the dimensions of'
	DB	' the individual image components. Explicitly supplying the ca'
	DB	'nvas dimensions may be desirable if the source image files do'
	DB	' not indicate their dimensions, or if custom sub-sampling fac'
	DB	'tors are desired.]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FOEOGEOO@II?$AA@
CONST	SEGMENT
??_C@_02FOEOGEOO@II?$AA@ DB 'II', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJJFAENN@Sextensions?$AA@
CONST	SEGMENT
??_C@_0M@NJJFAENN@Sextensions?$AA@ DB 'Sextensions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DFB@NHCICMJL@Logical?5OR?5of?5any?5combination?5of@
CONST	SEGMENT
??_C@_0DFB@NHCICMJL@Logical?5OR?5of?5any?5combination?5of@ DB 'Logical OR'
	DB	' of any combination of a number of flags, indicating extended'
	DB	' features from Part 2 of the JPEG2000 standard which may be f'
	DB	'ound in this codestream.  Note that the Kakadu codestream gen'
	DB	'eration machinery will set these flags automatically based on'
	DB	' features which are detected in other parameter objects.  Exp'
	DB	'lanation: DC means arbitrary DC offset; VARQ means variable q'
	DB	'uantization; TCQ means trellis-coded quantization; PRECQ mean'
	DB	's precinct-dependent quantization; VIS means visual masking; '
	DB	'SSO means single-sample-overlap transform; DECOMP means arbit'
	DB	'rary decomposition styles; ANY_KNL means arbitrary transform '
	DB	'kernels; SYM_KNL means arbitrary whole sample symmetric trans'
	DB	'form kernels; MCT means multi-component transform; CURVE mean'
	DB	's arbitrary point-transformation; and ROI means extended regi'
	DB	'on-of-interest signalling.', 0aH, 09H, 09H, '[Defaults to 0.]'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@IJELGHMP@?$FLDC?$DN1?$HMVARQ?$DN2?$HMTCQ?$DN4?$HMPRECQ?$DN2048?$HMVI@
CONST	SEGMENT
??_C@_0GI@IJELGHMP@?$FLDC?$DN1?$HMVARQ?$DN2?$HMTCQ?$DN4?$HMPRECQ?$DN2048?$HMVI@ DB '['
	DB	'DC=1|VARQ=2|TCQ=4|PRECQ=2048|VIS=8|SSO=16|DECOMP=32|ANY_KNL=6'
	DB	'4|SYM_KNL=128|MCT=256|CURVE=512|ROI=1024]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JNHDNPF@Scap?$AA@
CONST	SEGMENT
??_C@_04JNHDNPF@Scap?$AA@ DB 'Scap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0ML@FCKJPFCA@Flag?5indicating?5whether?5or?5not?5c@
CONST	SEGMENT
??_C@_0ML@FCKJPFCA@Flag?5indicating?5whether?5or?5not?5c@ DB 'Flag indica'
	DB	'ting whether or not capabilities from additional parts (beyon'
	DB	'd parts 1 and 2) in the JPEG2000 family of standards are defi'
	DB	'ned in a separate capabilities marker segment.', 0aH, 09H, 09H
	DB	'[Defaults to false.]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08HFDHOMDN@Sprofile?$AA@
CONST	SEGMENT
??_C@_08HFDHOMDN@Sprofile?$AA@ DB 'Sprofile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GIB@OAPGMEGC@Restricted?5profile?5to?5which?5the?5@
CONST	SEGMENT
??_C@_0GIB@OAPGMEGC@Restricted?5profile?5to?5which?5the?5@ DB 'Restricted'
	DB	' profile to which the code-stream conforms.  The value must b'
	DB	'e an integer in the range 0 to 5, corresponding to the identi'
	DB	'fiers `PROFILE0'', `PROFILE1'', `PROFILE2'', `PART2'', `CINEM'
	DB	'A2K'' and `CINEMA4K''.  PROFILE0 is the most restrictive prof'
	DB	'ile for Part 1 conforming codestreams.  PROFILE2 places no re'
	DB	'strictions on the code-stream other than those restrictions d'
	DB	'efined in ISO/IEC 15444-1 (JPEG2000, Part 1).  A value of 3 ('
	DB	'`PART2'') means that the codestream requires support for one '
	DB	'or more features defined in ISO/IEC 15444-2 (JPEG2000, Part 2'
	DB	').  If the system determines that support for Part 2 features'
	DB	' is  required, the profile will be set automatically to 3.  O'
	DB	'therwise, the profile is not adjusted by Kakadu''s codestream'
	DB	' creation machinery.  However, if the profile is found to be '
	DB	'insufficient, the system will generate a warning at the point'
	DB	' where it first encounters an inconsistency; this might not o'
	DB	'ccur until near the end of the processing in certain rare cir'
	DB	'cumstances.  The `CINEMA2K'' (4) and `CINEMA4K'' (5) profiles'
	DB	' were added later via an ammendment to Part 1.  They are in f'
	DB	'act highly restrictive subsets of the Part 1 standard, taylor'
	DB	'ed for the needs of digital cinema projection equipment.  To '
	DB	'be sure that you generate code-stream compatible with one of '
	DB	'the digital cinema profiles, you should use the "Creslengths"'
	DB	' attributes to explicitly constrain the compressed lengths of'
	DB	' resolution/component subsets.  The actual constraints depend'
	DB	' upon the intended frame-rate, as described in the standard. '
	DB	' Some suggestions are provided via a warning message if you f'
	DB	'ail to supply the `Creslengths'' attribute yourself.', 0aH, 09H
	DB	09H, '[Defaults to Profile-2.]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@MCBBIPAI@?$CIPROFILE0?$DN0?0PROFILE1?$DN1?0PROFILE2?$DN@
CONST	SEGMENT
??_C@_0EB@MCBBIPAI@?$CIPROFILE0?$DN0?0PROFILE1?$DN1?0PROFILE2?$DN@ DB '(P'
	DB	'ROFILE0=0,PROFILE1=1,PROFILE2=2,PART2=3,CINEMA2K=4,CINEMA4K=5'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03DIBMIDDO@SIZ?$AA@
CONST	SEGMENT
??_C@_03DIBMIDDO@SIZ?$AA@ DB 'SIZ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PIKIAENG@component?5index?5is?$AA@
CONST	SEGMENT
??_C@_0BD@PIKIAENG@component?5index?5is?$AA@ DB 'component index is', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02LNAEAIDO@?$DL?5?$AA@
CONST	SEGMENT
??_C@_02LNAEAIDO@?$DL?5?$AA@ DB '; ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MMGLAGCF@?5?$CIstarting?5from?50?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@MMGLAGCF@?5?$CIstarting?5from?50?$CJ?$AA@ DB ' (starting from 0'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MNKEPDKJ@?5?$FLi?4e?4?0?5global?$FN?$AA@
CONST	SEGMENT
??_C@_0BA@MNKEPDKJ@?5?$FLi?4e?4?0?5global?$FN?$AA@ DB ' [i.e., global]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DOHDMGMJ@tile?5number?5is?$AA@
CONST	SEGMENT
??_C@_0P@DOHDMGMJ@tile?5number?5is?$AA@ DB 'tile number is', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJDKGJIF@?$CC?$DL?5?$AA@
CONST	SEGMENT
??_C@_03GJDKGJIF@?$CC?$DL?5?$AA@ DB '"; ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HA@MENEFAMH@Codestream?5contains?5a?5parameter?5@
CONST	SEGMENT
??_C@_0HA@MENEFAMH@Codestream?5contains?5a?5parameter?5@ DB 'Codestream c'
	DB	'ontains a parameter marker segment with an invalid image comp'
	DB	'onent or tile index: parameter type is', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@CALBKEL@Attempting?5to?5delete?5a?5non?9exist@
CONST	SEGMENT
??_C@_0FM@CALBKEL@Attempting?5to?5delete?5a?5non?9exist@ DB 'Attempting t'
	DB	'o delete a non-existent attribute with "kdu_params::delete_un'
	DB	'parsed_attribute".', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@MMDBDEFI@?$CCkdu_params?3?3describe_attribute?$CC@
CONST	SEGMENT
??_C@_0EO@MMDBDEFI@?$CCkdu_params?3?3describe_attribute?$CC@ DB '"kdu_par'
	DB	'ams::describe_attribute" invoked with an invalid attribute id'
	DB	'entifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LIKKDBIM@?5of?5record?5?$AA@
CONST	SEGMENT
??_C@_0M@LIKKDBIM@?5of?5record?5?$AA@ DB ' of record ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GBLFFAMG@in?5field?5?$AA@
CONST	SEGMENT
??_C@_09GBLFFAMG@in?5field?5?$AA@ DB 'in field ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0HL@JPCGMMAG@Attempting?5to?5textualize?5a?5code?9@
CONST	SEGMENT
??_C@_0HL@JPCGMMAG@Attempting?5to?5textualize?5a?5code?9@ DB 'Attempting '
	DB	'to textualize a code-stream parameter attribute, which has on'
	DB	'ly partially been set!', 0aH, 'Error occurred in attribute', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01JPJNBJEM@I?$AA@
CONST	SEGMENT
??_C@_01JPJNBJEM@I?$AA@ DB 'I', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT
??_C@_01GFHCPBMG@C?$AA@ DB 'C', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GAPBHFFA@T?$AA@
CONST	SEGMENT
??_C@_01GAPBHFFA@T?$AA@ DB 'T', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@ODMOHKAB@Opening?5brace?5for?5record?5is?5not?5@
CONST	SEGMENT
??_C@_0DM@ODMOHKAB@Opening?5brace?5for?5record?5is?5not?5@ DB 'Opening br'
	DB	'ace for record is not matched by a closing brace.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@EHIGLBBC@Expected?5a?5boolean?5field?5identif@
CONST	SEGMENT
??_C@_0EB@EHIGLBBC@Expected?5a?5boolean?5field?5identif@ DB 'Expected a b'
	DB	'oolean field identifier, i.e., one of "yes" or "no".', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAJCLHKP@no?$AA@
CONST	SEGMENT
??_C@_02KAJCLHKP@no?$AA@ DB 'no', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICICOMAL@yes?$AA@
CONST	SEGMENT
??_C@_03ICICOMAL@yes?$AA@ DB 'yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@PANFLKHK@Attempt?5to?5parse?5custom?5string?5r@
CONST	SEGMENT
??_C@_0FJ@PANFLKHK@Attempt?5to?5parse?5custom?5string?5r@ DB 'Attempt to '
	DB	'parse custom string representation failed.  Read usage inform'
	DB	'ation carefully.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KODNALJB@Expected?5an?5integer?5field?4?$AA@
CONST	SEGMENT
??_C@_0BL@KODNALJB@Expected?5an?5integer?5field?4?$AA@ DB 'Expected an in'
	DB	'teger field.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KHDANEEK@Expected?5a?5floating?5point?5field?4@
CONST	SEGMENT
??_C@_0CB@KHDANEEK@Expected?5a?5floating?5point?5field?4@ DB 'Expected a '
	DB	'floating point field.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EELOEALG@Fields?5must?5be?5separated?5by?5comm@
CONST	SEGMENT
??_C@_0CE@EELOEALG@Fields?5must?5be?5separated?5by?5comm@ DB 'Fields must'
	DB	' be separated by commas.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@ONBLBBIB@Records?5must?5be?5enclosed?5by?5curl@
CONST	SEGMENT
??_C@_0DN@ONBLBBIB@Records?5must?5be?5enclosed?5by?5curl@ DB 'Records mus'
	DB	't be enclosed by curly braces, i.e., ''{'' and ''}''.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@MBMGHEML@Attribute?5does?5not?5support?5multi@
CONST	SEGMENT
??_C@_0DH@MBMGHEML@Attribute?5does?5not?5support?5multi@ DB 'Attribute do'
	DB	'es not support multiple parameter records!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KHIJHBHP@Records?5must?5be?5separated?5by?5com@
CONST	SEGMENT
??_C@_0CF@KHIJHBHP@Records?5must?5be?5separated?5by?5com@ DB 'Records mus'
	DB	't be separated by commas.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DPGABFPI@Problem?5encountered?5at?$AA@
CONST	SEGMENT
??_C@_0BH@DPGABFPI@Problem?5encountered?5at?$AA@ DB 'Problem encountered '
	DB	'at', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0JM@LMPOLJGM@refers?5to?5code?9stream?5parameters@
CONST	SEGMENT
??_C@_0JM@LMPOLJGM@refers?5to?5code?9stream?5parameters@ DB 'refers to co'
	DB	'de-stream parameters which have already been parsed out of so'
	DB	'me string.  Moreover, multiple instances of this attribute ar'
	DB	'e not permitted here!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NIAMPCJJ@The?5supplied?5attribute?5string?$AA@
CONST	SEGMENT
??_C@_0BO@NIAMPCJJ@The?5supplied?5attribute?5string?$AA@ DB 'The supplied'
	DB	' attribute string', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@BCPIKDJF@Parameter?5values?5must?5be?5separat@
CONST	SEGMENT
??_C@_0GM@BCPIKDJF@Parameter?5values?5must?5be?5separat@ DB 'Parameter va'
	DB	'lues must be separated from the attribute name and optional l'
	DB	'ocation specifiers by an ''='' sign!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0IG@JNAPNKGG@Attempt?5to?5set?5a?5non?9tile?9specif@
CONST	SEGMENT
??_C@_0IG@JNAPNKGG@Attempt?5to?5set?5a?5non?9tile?9specif@ DB 'Attempt to'
	DB	' set a non-tile-specific code-stream attribute in a specific '
	DB	'component!', 0aH, 'Problem occurred while parsing the attribu'
	DB	'te string', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BPCCBEIL@refers?5to?5a?5non?9existent?5tile?9co@
CONST	SEGMENT
??_C@_0CJ@BPCCBEIL@refers?5to?5a?5non?9existent?5tile?9co@ DB 'refers to '
	DB	'a non-existent tile-component!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCCGFNIO@Attribute?5string?$AA@
CONST	SEGMENT
??_C@_0BB@FCCGFNIO@Attribute?5string?$AA@ DB 'Attribute string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@IAODNOI@This?5type?5of?5parameter?5cannot?5be@
CONST	SEGMENT
??_C@_0GI@IAODNOI@This?5type?5of?5parameter?5cannot?5be@ DB 'This type of'
	DB	' parameter cannot be used with an index specifier (i.e., a sp'
	DB	'ecifier of the form "I<num>").', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@PMHLCCDF@You?5must?5supply?5an?5index?5specifi@
CONST	SEGMENT
??_C@_0FE@PMHLCCDF@You?5must?5supply?5an?5index?5specifi@ DB 'You must su'
	DB	'pply an index specifier of the form "I<num>" for this type of'
	DB	' parameter.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0NA@FLKOAPNM@Tile?5specifiers?5following?5the?5th@
CONST	SEGMENT
??_C@_0NA@FLKOAPNM@Tile?5specifiers?5following?5the?5th@ DB 'Tile specifi'
	DB	'ers following the the colon must have the form "T<num>", whil'
	DB	'e component specifiers must have the form "C<num>" and index '
	DB	'specifiers must have the form "I<num>". There may be at most '
	DB	'one of each!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@JMPBALKA@Malformed?5location?5specifier?5enc@
CONST	SEGMENT
??_C@_0DN@JMPBALKA@Malformed?5location?5specifier?5enc@ DB 'Malformed loc'
	DB	'ation specifier encountered in attribute string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GO@DPHCDBCK@?6Parameter?5values?5must?5be?5separa@
CONST	SEGMENT
??_C@_0GO@DPHCDBCK@?6Parameter?5values?5must?5be?5separa@ DB 0aH, 'Parame'
	DB	'ter values must be separated from the attribute name and opti'
	DB	'onal location specifiers by an ''='' sign!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DEPOJPCI@is?5missing?5parameters?3?6?6?7?$AA@
CONST	SEGMENT
??_C@_0BK@DEPOJPCI@is?5missing?5parameters?3?6?6?7?$AA@ DB 'is missing pa'
	DB	'rameters:', 0aH, 0aH, 09H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KOPDJAMB@?$CC?5?$AA@
CONST	SEGMENT
??_C@_02KOPDJAMB@?$CC?5?$AA@ DB '" ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EIDFECNJ@Attribute?$AA@
CONST	SEGMENT
??_C@_09EIDFECNJ@Attribute?$AA@ DB 'Attribute', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NNLGGFEF@White?5space?5characters?5are?5illeg@
CONST	SEGMENT
??_C@_0CE@NNLGGFEF@White?5space?5characters?5are?5illeg@ DB 'White space '
	DB	'characters are illegal!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
CONST	SEGMENT
??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@ DB '"!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
CONST	SEGMENT
??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@ DB 'Malformed attrib'
	DB	'ute string', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NFMHJCHA@supplied?5to?5the?5?$GAkdu_params?3?3set@
CONST	SEGMENT
??_C@_0DE@NFMHJCHA@supplied?5to?5the?5?$GAkdu_params?3?3set@ DB 'supplied'
	DB	' to the `kdu_params::set_derived'' function.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HAFDNMHA@?$CC?0?5?$AA@
CONST	SEGMENT
??_C@_03HAFDNMHA@?$CC?0?5?$AA@ DB '", ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HIFAHFHM@Invalid?5attribute?5name?$AA@
CONST	SEGMENT
??_C@_0BH@HIFAHFHM@Invalid?5attribute?5name?$AA@ DB 'Invalid attribute na'
	DB	'me', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0IA@DFMOHAGA@Attempting?5to?5set?5an?5integer?5cod@
CONST	SEGMENT
??_C@_0IA@DFMOHAGA@Attempting?5to?5set?5an?5integer?5cod@ DB 'Attempting '
	DB	'to set an integer code-stream parameter attribute field with '
	DB	'the floating point access method!', 0aH, 'The attribute name '
	DB	'is', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HM@KMNJIEPO@Attempting?5to?5set?5a?5non?9boolean?5@
CONST	SEGMENT
??_C@_0HM@KMNJIEPO@Attempting?5to?5set?5a?5non?9boolean?5@ DB 'Attempting'
	DB	' to set a non-boolean code-stream parameter attribute field w'
	DB	'ith the boolean access method!', 0aH, 'The attribute name is', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JJ@BKCJHECD@Attempting?5to?5set?5a?5code?9stream?5@
CONST	SEGMENT
??_C@_0JJ@BKCJHECD@Attempting?5to?5set?5a?5code?9stream?5@ DB 'Attempting'
	DB	' to set a code-stream attribute field using an integer value '
	DB	'which is incompatible with the flags defined for the field!', 0aH
	DB	'The attribute name is', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0KH@JEELPMNH@Attempting?5to?5set?5a?5code?9stream?5@
CONST	SEGMENT
??_C@_0KH@JEELPMNH@Attempting?5to?5set?5a?5code?9stream?5@ DB 'Attempting'
	DB	' to set a code-stream attribute field using an integer value '
	DB	'which does not match any of the defined translation values fo'
	DB	'r the field!', 0aH, 'The attribute name is', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HN@MGKBDNAF@Attempting?5to?5set?5a?5boolean?5code@
CONST	SEGMENT
??_C@_0HN@MGKBDNAF@Attempting?5to?5set?5a?5boolean?5code@ DB 'Attempting '
	DB	'to set a boolean code-stream parameter attribute field with a'
	DB	'n integer not equal to 0 or 1!', 0aH, 'The attribute name is', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@BOHKEADG@Attempting?5to?5set?5a?5floating?5poi@
CONST	SEGMENT
??_C@_0HP@BOHKEADG@Attempting?5to?5set?5a?5floating?5poi@ DB 'Attempting '
	DB	'to set a floating point code-stream parameter attribute field'
	DB	' with the integer access method!', 0aH, 'The attribute name i'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@DIDANAGC@Attempt?5to?5set?5a?5code?9stream?5att@
CONST	SEGMENT
??_C@_0FL@DIDANAGC@Attempt?5to?5set?5a?5code?9stream?5att@ DB 'Attempt to'
	DB	' set a code-stream attribute, with an invalid field index!', 0aH
	DB	'The attribute name is', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@PNBMMBJE@Attempt?5to?5set?5a?5non?9tile?9specif@
CONST	SEGMENT
??_C@_0GI@PNBMMBJE@Attempt?5to?5set?5a?5non?9tile?9specif@ DB 'Attempt to'
	DB	' set a non-tile-specific code-stream attribute in a specific '
	DB	'component!', 0aH, 'The attribute name is', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@JOGJAIGA@Attempt?5to?5set?5a?5code?9stream?5att@
CONST	SEGMENT
??_C@_0DO@JOGJAIGA@Attempt?5to?5set?5a?5code?9stream?5att@ DB 'Attempt to'
	DB	' set a code-stream attribute using the invalid name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ID@NIKNNMAJ@Attempting?5to?5access?5an?5integer?5@
CONST	SEGMENT
??_C@_0ID@NIKNNMAJ@Attempting?5to?5access?5an?5integer?5@ DB 'Attempting '
	DB	'to access an integer code-stream parameter attribute field wi'
	DB	'th the floating point access method!', 0aH, 'The attribute na'
	DB	'me is', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0HF@JLGEHIN@Attempting?5to?5access?5a?5non?9boole@
CONST	SEGMENT
??_C@_0HF@JLGEHIN@Attempting?5to?5access?5a?5non?9boole@ DB 'Attempting t'
	DB	'o access a non-boolean code-stream attribute field with the b'
	DB	'oolean access method!', 0aH, 'The attribute name is', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HI@GBKDDDEC@Attempting?5to?5access?5a?5floating?5@
CONST	SEGMENT
??_C@_0HI@GBKDDDEC@Attempting?5to?5access?5a?5floating?5@ DB 'Attempting '
	DB	'to access a floating point code-stream attribute field with t'
	DB	'he integer access method!', 0aH, 'The attribute name is', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NMPECGEH@The?5field?5index?5is?5?$AA@
CONST	SEGMENT
??_C@_0BE@NMPECGEH@The?5field?5index?5is?5?$AA@ DB 'The field index is ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
CONST	SEGMENT
??_C@_03BMLMMEDG@?$CC?4?6?$AA@ DB '".', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JPEBCGCN@?5?$CC?$AA@
CONST	SEGMENT
??_C@_02JPEBCGCN@?5?$CC?$AA@ DB ' "', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@BDPPHOIA@Attempt?5to?5access?5a?5code?9stream?5@
CONST	SEGMENT
??_C@_0FO@BDPPHOIA@Attempt?5to?5access?5a?5code?9stream?5@ DB 'Attempt to'
	DB	' access a code-stream attribute, with an invalid field index!'
	DB	0aH, 'The attribute name is', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02LHOIKBIA@?$CC?$CB?$AA@
CONST	SEGMENT
??_C@_02LHOIKBIA@?$CC?$CB?$AA@ DB '"!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@JLDBDJJO@Attempt?5to?5access?5a?5code?9stream?5@
CONST	SEGMENT
??_C@_0EB@JLDBDJJO@Attempt?5to?5access?5a?5code?9stream?5@ DB 'Attempt to'
	DB	' access a code-stream attribute using the invalid name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@KNIJAOBN@Invalid?5?$GAtile_idx?8?5supplied?5to?5?$GA@
CONST	SEGMENT
??_C@_0EB@KNIJAOBN@Invalid?5?$GAtile_idx?8?5supplied?5to?5?$GA@ DB 'Inval'
	DB	'id `tile_idx'' supplied to `kdu_params::check_typical_tile''.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0JH@PHOILHHH@Trying?5to?5use?5?$GAkdu_params?3?3copy_@
CONST	SEGMENT
??_C@_0JH@PHOILHHH@Trying?5to?5use?5?$GAkdu_params?3?3copy_@ DB 'Trying t'
	DB	'o use `kdu_params::copy_all'' to copy an object which is not '
	DB	'a cluster head, or to copy to another object which is not the'
	DB	' head of its cluster.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@FAEHIHF@Trying?5to?5use?5?$GAkdu_params?3?3copy_@
CONST	SEGMENT
??_C@_0GC@FAEHIHF@Trying?5to?5use?5?$GAkdu_params?3?3copy_@ DB 'Trying to'
	DB	' use `kdu_params::copy_all'' to copy an object to one which h'
	DB	'as been derived differently.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@FFHPHGIF@Illegal?5attempt?5to?5modify?5a?5?$GAkdu@
CONST	SEGMENT
??_C@_0EP@FFHPHGIF@Illegal?5attempt?5to?5modify?5a?5?$GAkdu@ DB 'Illegal '
	DB	'attempt to modify a `kdu_params'' object which has already be'
	DB	'en marked!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0JI@GAIBBJLH@Trying?5to?5use?5?$GAkdu_params?3?3copy_@
CONST	SEGMENT
??_C@_0JI@GAIBBJLH@Trying?5to?5use?5?$GAkdu_params?3?3copy_@ DB 'Trying t'
	DB	'o use `kdu_params::copy_from'' to copy an object which is not'
	DB	' a cluster head, or to copy to another object which is not th'
	DB	'e head of its cluster.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@HANNBBLP@Trying?5to?5use?5?$GAkdu_params?3?3copy_@
CONST	SEGMENT
??_C@_0GD@HANNBBLP@Trying?5to?5use?5?$GAkdu_params?3?3copy_@ DB 'Trying t'
	DB	'o use `kdu_params::copy_from'' to copy an object to one which'
	DB	' has been derived differently.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0KA@FKBGPIEK@Call?5to?5?$GAkdu_params?3?3link?8?5speci@
CONST	SEGMENT
??_C@_0KA@FKBGPIEK@Call?5to?5?$GAkdu_params?3?3link?8?5speci@ DB 'Call to'
	DB	' `kdu_params::link'' specifies the same cluster name, tile an'
	DB	'd component indices as an existing linked object, which does '
	DB	'not support multiple instances.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0KB@EJFHGKHN@Call?5to?5?$GAkdu_params?3?3link?8?5speci@
CONST	SEGMENT
??_C@_0KB@EJFHGKHN@Call?5to?5?$GAkdu_params?3?3link?8?5speci@ DB 'Call to'
	DB	' `kdu_params::link'' specifies a different number of tiles or'
	DB	' components to the number with which the first parameter obje'
	DB	'ct of the same class was linked.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0OO@BFNLONCD@Illegal?5tile?5or?5component?5indice@
CONST	SEGMENT
??_C@_0OO@BFNLONCD@Illegal?5tile?5or?5component?5indice@ DB 'Illegal tile'
	DB	' or component indices supplied to `kdu_params::link''.  Proba'
	DB	'bly attempting to specialize a parameter object to a specific'
	DB	' tile or component, where the parameter class in questions do'
	DB	'es not support tile or component diversity.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GPOEFGEJ@?7?$AA@
CONST	SEGMENT
??_C@_01GPOEFGEJ@?7?$AA@ DB 09H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIHDFBBJ@?0?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_05MIHDFBBJ@?0?4?4?4?6?$AA@ DB ',...', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN?$AA@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN?$AA@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06EDILFCLO@FLAGS?$DM?$AA@
CONST	SEGMENT
??_C@_06EDILFCLO@FLAGS?$DM?$AA@ DB 'FLAGS<', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO?$AA@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO?$AA@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BAJLLFH@ENUM?$DM?$AA@
CONST	SEGMENT
??_C@_05BAJLLFH@ENUM?$DM?$AA@ DB 'ENUM<', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LECANFFL@?$DMcustom?5int?$DO?$AA@
CONST	SEGMENT
??_C@_0N@LECANFFL@?$DMcustom?5int?$DO?$AA@ DB '<custom int>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FFCKHLFB@?$DMfloat?$DO?$AA@
CONST	SEGMENT
??_C@_07FFCKHLFB@?$DMfloat?$DO?$AA@ DB '<float>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KMPCOBIE@?$DMyes?1no?$DO?$AA@
CONST	SEGMENT
??_C@_08KMPCOBIE@?$DMyes?1no?$DO?$AA@ DB '<yes/no>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05GAGDNHHH@?$DMint?$DO?$AA@
CONST	SEGMENT
??_C@_05GAGDNHHH@?$DMint?$DO?$AA@ DB '<int>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PONDAPIE@?$DO?$FN?$DN?$HL?$AA@
CONST	SEGMENT
??_C@_04PONDAPIE@?$DO?$FN?$DN?$HL?$AA@ DB '>]={', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JILILBPJ@?$FL?3?$DM?$AA@
CONST	SEGMENT
??_C@_03JILILBPJ@?$FL?3?$DM?$AA@ DB '[:<', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02OAMGPABD@?$DN?$HL?$AA@
CONST	SEGMENT
??_C@_02OAMGPABD@?$DN?$HL?$AA@ DB '={', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@EMGKNDJI@?$CC?0?5which?5can?5accept?5only?5single?5@
CONST	SEGMENT
??_C@_0CM@EMGKNDJI@?$CC?0?5which?5can?5accept?5only?5single?5@ DB '", whi'
	DB	'ch can accept only single attributes!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03KLKADAKF@?0?5?$CC?$AA@
CONST	SEGMENT
??_C@_03KLKADAKF@?0?5?$CC?$AA@ DB ', "', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@NIBLGMMC@Attempting?5to?5write?5multiple?5rec@
CONST	SEGMENT
??_C@_0EA@NIBLGMMC@Attempting?5to?5write?5multiple?5rec@ DB 'Attempting t'
	DB	'o write multiple records to a code-stream attribute', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0PAD@84
xdata$x	SEGMENT
__CT??_R0PAD@84 DD 01H
	DD	FLAT:??_R0PAD@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAD@8
data$r	SEGMENT
??_R0PAD@8 DD	FLAT:??_7type_info@@6B@			; char * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAD', 00H
data$r	ENDS
;	COMDAT __CTA2PAD
xdata$x	SEGMENT
__CTA2PAD DD	02H
	DD	FLAT:__CT??_R0PAD@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT __TI2CPAD
xdata$x	SEGMENT
__TI2CPAD DD	01H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2PAD
xdata$x	ENDS
;	COMDAT ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
CONST	SEGMENT
??_C@_0L@ELEFPJIC@Qabs_steps?$AA@ DB 'Qabs_steps', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
CONST	SEGMENT
??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@ DB 'Qabs_ranges', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MIOINIMK@Cdecomp?$AA@
CONST	SEGMENT
??_C@_07MIOINIMK@Cdecomp?$AA@ DB 'Cdecomp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KKABNIJP@Kcoeffs?$AA@
CONST	SEGMENT
??_C@_07KKABNIJP@Kcoeffs?$AA@ DB 'Kcoeffs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PJGAHNDG@Ksteps?$AA@
CONST	SEGMENT
??_C@_06PJGAHNDG@Ksteps?$AA@ DB 'Ksteps', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDCJHBJK@Ckernels?$AA@
CONST	SEGMENT
??_C@_08IDCJHBJK@Ckernels?$AA@ DB 'Ckernels', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BJKINHLE@?$CC?0?5separated?5by?5?$GA?$HM?8?5symbols?4?$AA@
CONST	SEGMENT
??_C@_0BN@BJKINHLE@?$CC?0?5separated?5by?5?$GA?$HM?8?5symbols?4?$AA@ DB '"'
	DB	', separated by `|'' symbols.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HEDJDDBK@Expected?5one?5or?5more?5of?5the?5iden@
CONST	SEGMENT
??_C@_0CK@HEDJDDBK@Expected?5one?5or?5more?5of?5the?5iden@ DB 'Expected o'
	DB	'ne or more of the identifiers, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FJKIFICP@?5or?5?$AA@
CONST	SEGMENT
??_C@_04FJKIFICP@?5or?5?$AA@ DB ' or ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LLCJBDHK@Expected?5one?5of?5the?5identifiers?0@
CONST	SEGMENT
??_C@_0CC@LLCJBDHK@Expected?5one?5of?5the?5identifiers?0@ DB 'Expected on'
	DB	'e of the identifiers, ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IM@FCIPKKGG@String?5translators?5in?5code?9strea@
CONST	SEGMENT
??_C@_0IM@FCIPKKGG@String?5translators?5in?5code?9strea@ DB 'String trans'
	DB	'lators in code-stream attribute specifications must be identi'
	DB	'fied with integers and correctly delimited! Problem encounter'
	DB	'ed at', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KGDOBALG@?5characters?5in?5length?$CB?5Problem?5e@
CONST	SEGMENT
??_C@_0CO@KGDOBALG@?5characters?5in?5length?$CB?5Problem?5e@ DB ' charact'
	DB	'ers in length! Problem encountered at', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@BICNPJDD@String?5translators?5in?5code?9strea@
CONST	SEGMENT
??_C@_0EL@BICNPJDD@String?5translators?5in?5code?9strea@ DB 'String trans'
	DB	'lators in code-stream attribute specifications may not exceed'
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02DAHALNEP@?$CC?4?$AA@
CONST	SEGMENT
??_C@_02DAHALNEP@?$CC?4?$AA@ DB '".', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NONCDIOG@?3?5?$CC?$AA@
CONST	SEGMENT
??_C@_03NONCDIOG@?3?5?$CC?$AA@ DB ': "', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@JHCOHHHI@String?5translators?5in?5code?9strea@
CONST	SEGMENT
??_C@_0GM@JHCOHHHI@String?5translators?5in?5code?9strea@ DB 'String trans'
	DB	'lators in code-stream attribute specifications must contain a'
	DB	'n ''='' sign! Problem encountered at', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BIIABMGK@Absolute?5quantization?5step?5sizes@
CONST	SEGMENT
??_C@_0DM@BIIABMGK@Absolute?5quantization?5step?5sizes@ DB 'Absolute quan'
	DB	'tization step sizes must be strictly positive.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
CONST	SEGMENT
??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@ DB 'Kakadu Core Error:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_7org_params@@6B@
CONST	SEGMENT
??_7org_params@@6B@ DD FLAT:??_R4org_params@@6B@	; org_params::`vftable'
	DD	FLAT:?new_object@org_params@@MAEPAVkdu_params@@XZ
	DD	FLAT:??_Eorg_params@@UAEPAXI@Z
	DD	FLAT:?copy_with_xforms@org_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	FLAT:?write_marker_segment@kdu_params@@MAEHPAVkdu_output@@PAV1@H@Z
	DD	FLAT:?check_marker_segment@org_params@@MAE_NGHQAEAAH@Z
	DD	FLAT:?read_marker_segment@org_params@@MAE_NGHQAEH@Z
	DD	FLAT:?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@kdu_params@@UAEX_N@Z
CONST	ENDS
;	COMDAT ??_7crg_params@@6B@
CONST	SEGMENT
??_7crg_params@@6B@ DD FLAT:??_R4crg_params@@6B@	; crg_params::`vftable'
	DD	FLAT:?new_object@crg_params@@MAEPAVkdu_params@@XZ
	DD	FLAT:??_Ecrg_params@@UAEPAXI@Z
	DD	FLAT:?copy_with_xforms@crg_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	FLAT:?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	FLAT:?check_marker_segment@crg_params@@MAE_NGHQAEAAH@Z
	DD	FLAT:?read_marker_segment@crg_params@@MAE_NGHQAEH@Z
	DD	FLAT:?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@kdu_params@@UAEX_N@Z
CONST	ENDS
;	COMDAT ??_7poc_params@@6B@
CONST	SEGMENT
??_7poc_params@@6B@ DD FLAT:??_R4poc_params@@6B@	; poc_params::`vftable'
	DD	FLAT:?new_object@poc_params@@MAEPAVkdu_params@@XZ
	DD	FLAT:??_Epoc_params@@UAEPAXI@Z
	DD	FLAT:?copy_with_xforms@poc_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	FLAT:?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	FLAT:?check_marker_segment@poc_params@@MAE_NGHQAEAAH@Z
	DD	FLAT:?read_marker_segment@poc_params@@MAE_NGHQAEH@Z
	DD	FLAT:?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@kdu_params@@UAEX_N@Z
CONST	ENDS
;	COMDAT ??_7rgn_params@@6B@
CONST	SEGMENT
??_7rgn_params@@6B@ DD FLAT:??_R4rgn_params@@6B@	; rgn_params::`vftable'
	DD	FLAT:?new_object@rgn_params@@MAEPAVkdu_params@@XZ
	DD	FLAT:??_Ergn_params@@UAEPAXI@Z
	DD	FLAT:?copy_with_xforms@rgn_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	FLAT:?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	FLAT:?check_marker_segment@rgn_params@@MAE_NGHQAEAAH@Z
	DD	FLAT:?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z
	DD	FLAT:?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@rgn_params@@MAEX_N@Z
CONST	ENDS
;	COMDAT ??_7qcd_params@@6B@
CONST	SEGMENT
??_7qcd_params@@6B@ DD FLAT:??_R4qcd_params@@6B@	; qcd_params::`vftable'
	DD	FLAT:?new_object@qcd_params@@MAEPAVkdu_params@@XZ
	DD	FLAT:??_Eqcd_params@@UAEPAXI@Z
	DD	FLAT:?copy_with_xforms@qcd_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	FLAT:?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	FLAT:?check_marker_segment@qcd_params@@MAE_NGHQAEAAH@Z
	DD	FLAT:?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z
	DD	FLAT:?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@qcd_params@@MAEX_N@Z
CONST	ENDS
;	COMDAT ??_7dfs_params@@6B@
CONST	SEGMENT
??_7dfs_params@@6B@ DD FLAT:??_R4dfs_params@@6B@	; dfs_params::`vftable'
	DD	FLAT:?new_object@dfs_params@@MAEPAVkdu_params@@XZ
	DD	FLAT:??_Edfs_params@@UAEPAXI@Z
	DD	FLAT:?copy_with_xforms@dfs_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	FLAT:?write_marker_segment@dfs_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	FLAT:?check_marker_segment@dfs_params@@MAE_NGHQAEAAH@Z
	DD	FLAT:?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z
	DD	FLAT:?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@dfs_params@@MAEX_N@Z
CONST	ENDS
;	COMDAT ??_7ads_params@@6B@
CONST	SEGMENT
??_7ads_params@@6B@ DD FLAT:??_R4ads_params@@6B@	; ads_params::`vftable'
	DD	FLAT:?new_object@ads_params@@MAEPAVkdu_params@@XZ
	DD	FLAT:??_Eads_params@@UAEPAXI@Z
	DD	FLAT:?copy_with_xforms@ads_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	FLAT:?write_marker_segment@ads_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	FLAT:?check_marker_segment@ads_params@@MAE_NGHQAEAAH@Z
	DD	FLAT:?read_marker_segment@ads_params@@MAE_NGHQAEH@Z
	DD	FLAT:?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@ads_params@@MAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@ads_params@@MAEX_N@Z
CONST	ENDS
;	COMDAT ??_7cod_params@@6B@
CONST	SEGMENT
??_7cod_params@@6B@ DD FLAT:??_R4cod_params@@6B@	; cod_params::`vftable'
	DD	FLAT:?new_object@cod_params@@MAEPAVkdu_params@@XZ
	DD	FLAT:??_Ecod_params@@UAEPAXI@Z
	DD	FLAT:?copy_with_xforms@cod_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	FLAT:?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	FLAT:?check_marker_segment@cod_params@@MAE_NGHQAEAAH@Z
	DD	FLAT:?read_marker_segment@cod_params@@MAE_NGHQAEH@Z
	DD	FLAT:?custom_parse_field@cod_params@@MAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@cod_params@@MAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@cod_params@@MAEX_N@Z
CONST	ENDS
;	COMDAT ??_7atk_params@@6B@
CONST	SEGMENT
??_7atk_params@@6B@ DD FLAT:??_R4atk_params@@6B@	; atk_params::`vftable'
	DD	FLAT:?new_object@atk_params@@MAEPAVkdu_params@@XZ
	DD	FLAT:??_Eatk_params@@UAEPAXI@Z
	DD	FLAT:?copy_with_xforms@atk_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	FLAT:?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	FLAT:?check_marker_segment@atk_params@@MAE_NGHQAEAAH@Z
	DD	FLAT:?read_marker_segment@atk_params@@MAE_NGHQAEH@Z
	DD	FLAT:?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@atk_params@@MAEX_N@Z
CONST	ENDS
;	COMDAT ??_7mco_params@@6B@
CONST	SEGMENT
??_7mco_params@@6B@ DD FLAT:??_R4mco_params@@6B@	; mco_params::`vftable'
	DD	FLAT:?new_object@mco_params@@MAEPAVkdu_params@@XZ
	DD	FLAT:??_Emco_params@@UAEPAXI@Z
	DD	FLAT:?copy_with_xforms@mco_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	FLAT:?write_marker_segment@mco_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	FLAT:?check_marker_segment@mco_params@@MAE_NGHQAEAAH@Z
	DD	FLAT:?read_marker_segment@mco_params@@MAE_NGHQAEH@Z
	DD	FLAT:?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@mco_params@@MAEX_N@Z
CONST	ENDS
;	COMDAT ??_7mcc_params@@6B@
CONST	SEGMENT
??_7mcc_params@@6B@ DD FLAT:??_R4mcc_params@@6B@	; mcc_params::`vftable'
	DD	FLAT:?new_object@mcc_params@@MAEPAVkdu_params@@XZ
	DD	FLAT:??_Emcc_params@@UAEPAXI@Z
	DD	FLAT:?copy_with_xforms@mcc_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	FLAT:?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	FLAT:?check_marker_segment@mcc_params@@MAE_NGHQAEAAH@Z
	DD	FLAT:?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z
	DD	FLAT:?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@mcc_params@@MAEX_N@Z
CONST	ENDS
;	COMDAT ??_7mct_params@@6B@
CONST	SEGMENT
??_7mct_params@@6B@ DD FLAT:??_R4mct_params@@6B@	; mct_params::`vftable'
	DD	FLAT:?new_object@mct_params@@MAEPAVkdu_params@@XZ
	DD	FLAT:??_Emct_params@@UAEPAXI@Z
	DD	FLAT:?copy_with_xforms@mct_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	FLAT:?write_marker_segment@mct_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	FLAT:?check_marker_segment@mct_params@@MAE_NGHQAEAAH@Z
	DD	FLAT:?read_marker_segment@mct_params@@MAE_NGHQAEH@Z
	DD	FLAT:?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@mct_params@@MAEX_N@Z
CONST	ENDS
;	COMDAT ??_7siz_params@@6B@
CONST	SEGMENT
??_7siz_params@@6B@ DD FLAT:??_R4siz_params@@6B@	; siz_params::`vftable'
	DD	FLAT:?new_object@siz_params@@MAEPAVkdu_params@@XZ
	DD	FLAT:??_Esiz_params@@UAEPAXI@Z
	DD	FLAT:?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	FLAT:?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	FLAT:?check_marker_segment@siz_params@@MAE_NGHQAEAAH@Z
	DD	FLAT:?read_marker_segment@siz_params@@MAE_NGHQAEH@Z
	DD	FLAT:?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@siz_params@@MAEX_N@Z
CONST	ENDS
;	COMDAT ??_7kdu_params@@6B@
CONST	SEGMENT
??_7kdu_params@@6B@ DD FLAT:??_R4kdu_params@@6B@	; kdu_params::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:??_Ekdu_params@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:?write_marker_segment@kdu_params@@MAEHPAVkdu_output@@PAV1@H@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
	DD	FLAT:?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z
	DD	FLAT:?finalize@kdu_params@@UAEX_N@Z
CONST	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT
__CT??_R0PAX@84 DD 01H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAX@8
data$r	SEGMENT
??_R0PAX@8 DD	FLAT:??_7type_info@@6B@			; void * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAX', 00H
data$r	ENDS
;	COMDAT __CT??_R0PAE@84
xdata$x	SEGMENT
__CT??_R0PAE@84 DD 01H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAE@8
data$r	SEGMENT
??_R0PAE@8 DD	FLAT:??_7type_info@@6B@			; unsigned char * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAE', 00H
data$r	ENDS
;	COMDAT __CTA2PAE
xdata$x	SEGMENT
__CTA2PAE DD	02H
	DD	FLAT:__CT??_R0PAE@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT __TI2PAE
xdata$x	SEGMENT
__TI2PAE DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2PAE
xdata$x	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf?$AA@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf?$AA@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z$2
__ehfuncinfo$?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z$2
__ehfuncinfo$?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?parse_translator_entry@@YAPBDPBDDQADHAAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_translator_entry@@YAPBDPBDDQADHAAH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_translator_entry@@YAPBDPBDDQADHAAH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_translator_entry@@YAPBDPBDDQADHAAH@Z$2
__ehfuncinfo$?parse_translator_entry@@YAPBDPBDDQADHAAH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?parse_translator_entry@@YAPBDPBDDQADHAAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?step_to_eps_mu@@YAXMAAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?step_to_eps_mu@@YAXMAAH0@Z$0
__ehfuncinfo$?step_to_eps_mu@@YAXMAAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?step_to_eps_mu@@YAXMAAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?augment_records@kd_attribute@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?augment_records@kd_attribute@@QAEXH@Z$0
__ehfuncinfo$?augment_records@kd_attribute@@QAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?augment_records@kd_attribute@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kdu_kernels@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_object@org_params@@MAEPAVkdu_params@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_object@org_params@@MAEPAVkdu_params@@XZ$0
__ehfuncinfo$?new_object@org_params@@MAEPAVkdu_params@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_object@org_params@@MAEPAVkdu_params@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0org_params@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0org_params@@QAE@XZ$0
__ehfuncinfo$??0org_params@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0org_params@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z$4 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z$0
__tryblocktable$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z DD 00H
	DD	01H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z$4
__unwindtable$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z$2
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z$3
__ehfuncinfo$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1
__ehfuncinfo$?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_object@crg_params@@MAEPAVkdu_params@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_object@crg_params@@MAEPAVkdu_params@@XZ$0
__ehfuncinfo$?new_object@crg_params@@MAEPAVkdu_params@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_object@crg_params@@MAEPAVkdu_params@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0crg_params@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0crg_params@@QAE@XZ$0
__ehfuncinfo$??0crg_params@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0crg_params@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z$4 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z$0
__tryblocktable$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z DD 00H
	DD	01H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z$4
__unwindtable$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z$2
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z$3
__ehfuncinfo$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_object@poc_params@@MAEPAVkdu_params@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_object@poc_params@@MAEPAVkdu_params@@XZ$0
__ehfuncinfo$?new_object@poc_params@@MAEPAVkdu_params@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_object@poc_params@@MAEPAVkdu_params@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0poc_params@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0poc_params@@QAE@XZ$0
__ehfuncinfo$??0poc_params@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0poc_params@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z$5 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z$0
__tryblocktable$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z DD 00H
	DD	02H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z$5
__ehfuncinfo$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z$3
	DD	0ffffffffH
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1
__ehfuncinfo$?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_object@rgn_params@@MAEPAVkdu_params@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_object@rgn_params@@MAEPAVkdu_params@@XZ$0
__ehfuncinfo$?new_object@rgn_params@@MAEPAVkdu_params@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_object@rgn_params@@MAEPAVkdu_params@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?finalize@rgn_params@@MAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@rgn_params@@MAEX_N@Z$0
__ehfuncinfo$?finalize@rgn_params@@MAEX_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?finalize@rgn_params@@MAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0rgn_params@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0rgn_params@@QAE@XZ$0
__ehfuncinfo$??0rgn_params@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0rgn_params@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z$6 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z$0
__tryblocktable$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z DD 01H
	DD	02H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z$6
__ehfuncinfo$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z$2
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z$3
	DD	0ffffffffH
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$11
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?finalize@qcd_params@@MAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@qcd_params@@MAEX_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@qcd_params@@MAEX_N@Z$1
__ehfuncinfo$?finalize@qcd_params@@MAEX_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?finalize@qcd_params@@MAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_object@qcd_params@@MAEPAVkdu_params@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_object@qcd_params@@MAEPAVkdu_params@@XZ$0
__ehfuncinfo$?new_object@qcd_params@@MAEPAVkdu_params@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_object@qcd_params@@MAEPAVkdu_params@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0qcd_params@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0qcd_params@@QAE@XZ$0
__ehfuncinfo$??0qcd_params@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0qcd_params@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z$4 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z$0
__tryblocktable$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z DD 00H
	DD	00H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z$4
__unwindtable$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z$3
__ehfuncinfo$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?finalize@dfs_params@@MAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@dfs_params@@MAEX_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@dfs_params@@MAEX_N@Z$1
__ehfuncinfo$?finalize@dfs_params@@MAEX_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?finalize@dfs_params@@MAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_object@dfs_params@@MAEPAVkdu_params@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_object@dfs_params@@MAEPAVkdu_params@@XZ$0
__ehfuncinfo$?new_object@dfs_params@@MAEPAVkdu_params@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_object@dfs_params@@MAEPAVkdu_params@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0dfs_params@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0dfs_params@@QAE@XZ$0
__ehfuncinfo$??0dfs_params@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0dfs_params@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z$4 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z$0
__tryblocktable$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z DD 00H
	DD	00H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z$4
__unwindtable$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z$3
__ehfuncinfo$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?finalize@ads_params@@MAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@ads_params@@MAEX_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@ads_params@@MAEX_N@Z$1
__ehfuncinfo$?finalize@ads_params@@MAEX_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?finalize@ads_params@@MAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_object@ads_params@@MAEPAVkdu_params@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_object@ads_params@@MAEPAVkdu_params@@XZ$0
__ehfuncinfo$?new_object@ads_params@@MAEPAVkdu_params@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_object@ads_params@@MAEPAVkdu_params@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ads_params@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ads_params@@QAE@XZ$0
__ehfuncinfo$??0ads_params@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ads_params@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?validate_dfs_data@cod_params@@AAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?validate_dfs_data@cod_params@@AAEXH@Z$0
__ehfuncinfo$?validate_dfs_data@cod_params@@AAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?validate_dfs_data@cod_params@@AAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?validate_ads_data@cod_params@@AAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?validate_ads_data@cod_params@@AAEXH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?validate_ads_data@cod_params@@AAEXH@Z$1
__ehfuncinfo$?validate_ads_data@cod_params@@AAEXH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?validate_ads_data@cod_params@@AAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?find_suitable_dfs_idx@cod_params@@AAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?find_suitable_dfs_idx@cod_params@@AAEHXZ$0
__ehfuncinfo$?find_suitable_dfs_idx@cod_params@@AAEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?find_suitable_dfs_idx@cod_params@@AAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$15 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$4
__catchsym$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$14 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$2
__catchsym$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$13 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$0
__ehfuncinfo$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z
	DD	03H
	DD	FLAT:__tryblocktable$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z DD 00H
	DD	01H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$13
	DD	04H
	DD	05H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$14
	DD	09H
	DD	0aH
	DD	0cH
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$15
__unwindtable$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$6
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$7
	DD	0ffffffffH
	DD	00H
	DD	04H
	DD	FLAT:__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$8
	DD	0ffffffffH
	DD	00H
	DD	06H
	DD	FLAT:__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$10
	DD	0ffffffffH
	DD	00H
	DD	09H
	DD	FLAT:__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$11
	DD	0ffffffffH
	DD	00H
	DD	0bH
	DD	FLAT:__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$12
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 019930522H
	DD	011H
	DD	FLAT:__unwindtable$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?copy_with_xforms@cod_params@@MAEXPAVkdu_params@@HH_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?copy_with_xforms@cod_params@@MAEXPAVkdu_params@@HH_N11@Z$0
__ehfuncinfo$?copy_with_xforms@cod_params@@MAEXPAVkdu_params@@HH_N11@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?copy_with_xforms@cod_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?finalize@cod_params@@MAEX_N@Z DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?finalize@cod_params@@MAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?finalize@cod_params@@MAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$14
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_object@cod_params@@MAEPAVkdu_params@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_object@cod_params@@MAEPAVkdu_params@@XZ$0
__ehfuncinfo$?new_object@cod_params@@MAEPAVkdu_params@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_object@cod_params@@MAEPAVkdu_params@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0cod_params@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0cod_params@@QAE@XZ$0
__ehfuncinfo$??0cod_params@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0cod_params@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$7 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$0
__tryblocktable$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z DD 03H
	DD	03H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$7
__ehfuncinfo$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$4
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	04H
	DD	FLAT:__unwindfunclet$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$3
__ehfuncinfo$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?copy_with_xforms@atk_params@@MAEXPAVkdu_params@@HH_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?copy_with_xforms@atk_params@@MAEXPAVkdu_params@@HH_N11@Z$0
__ehfuncinfo$?copy_with_xforms@atk_params@@MAEXPAVkdu_params@@HH_N11@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?copy_with_xforms@atk_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?finalize@atk_params@@MAEX_N@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?finalize@atk_params@@MAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?finalize@atk_params@@MAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_object@atk_params@@MAEPAVkdu_params@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_object@atk_params@@MAEPAVkdu_params@@XZ$0
__ehfuncinfo$?new_object@atk_params@@MAEPAVkdu_params@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_object@atk_params@@MAEPAVkdu_params@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0atk_params@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0atk_params@@QAE@XZ$0
__ehfuncinfo$??0atk_params@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0atk_params@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z$4 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z$0
__tryblocktable$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z DD 00H
	DD	01H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z$4
__unwindtable$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z$2
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z$3
__ehfuncinfo$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?write_marker_segment@mco_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@mco_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0
__ehfuncinfo$?write_marker_segment@mco_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?write_marker_segment@mco_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?copy_with_xforms@mco_params@@MAEXPAVkdu_params@@HH_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?copy_with_xforms@mco_params@@MAEXPAVkdu_params@@HH_N11@Z$0
__ehfuncinfo$?copy_with_xforms@mco_params@@MAEXPAVkdu_params@@HH_N11@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?copy_with_xforms@mco_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?finalize@mco_params@@MAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mco_params@@MAEX_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mco_params@@MAEX_N@Z$1
__ehfuncinfo$?finalize@mco_params@@MAEX_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?finalize@mco_params@@MAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_object@mco_params@@MAEPAVkdu_params@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_object@mco_params@@MAEPAVkdu_params@@XZ$0
__ehfuncinfo$?new_object@mco_params@@MAEPAVkdu_params@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_object@mco_params@@MAEPAVkdu_params@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0mco_params@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0mco_params@@QAE@XZ$0
__ehfuncinfo$??0mco_params@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0mco_params@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z$6 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z$0
__tryblocktable$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z DD 01H
	DD	02H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z$6
__ehfuncinfo$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z$2
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z$3
	DD	0ffffffffH
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1
__ehfuncinfo$?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?finalize@mcc_params@@MAEX_N@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?finalize@mcc_params@@MAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?finalize@mcc_params@@MAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_object@mcc_params@@MAEPAVkdu_params@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_object@mcc_params@@MAEPAVkdu_params@@XZ$0
__ehfuncinfo$?new_object@mcc_params@@MAEPAVkdu_params@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_object@mcc_params@@MAEPAVkdu_params@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0mcc_params@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0mcc_params@@QAE@XZ$0
__ehfuncinfo$??0mcc_params@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0mcc_params@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z$6 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z$0
__tryblocktable$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z DD 00H
	DD	02H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z$6
__ehfuncinfo$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z$3
	DD	0ffffffffH
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?finalize@mct_params@@MAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mct_params@@MAEX_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mct_params@@MAEX_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mct_params@@MAEX_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@mct_params@@MAEX_N@Z$3
__ehfuncinfo$?finalize@mct_params@@MAEX_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?finalize@mct_params@@MAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_object@mct_params@@MAEPAVkdu_params@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_object@mct_params@@MAEPAVkdu_params@@XZ$0
__ehfuncinfo$?new_object@mct_params@@MAEPAVkdu_params@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_object@mct_params@@MAEPAVkdu_params@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0mct_params@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0mct_params@@QAE@XZ$0
__ehfuncinfo$??0mct_params@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0mct_params@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$10 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$2
__catchsym$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$9 DD 00H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	FLAT:__catch$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$0
__ehfuncinfo$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z
	DD	02H
	DD	FLAT:__tryblocktable$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z DD 00H
	DD	02H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$9
	DD	05H
	DD	06H
	DD	08H
	DD	01H
	DD	FLAT:__catchsym$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$10
__unwindtable$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$5
	DD	0ffffffffH
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$6
	DD	0ffffffffH
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$7
	DD	0ffffffffH
	DD	00H
	DD	07H
	DD	FLAT:__unwindfunclet$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$11
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z$2
__ehfuncinfo$?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?finalize@siz_params@@MAEX_N@Z DD 019930522H
	DD	016H
	DD	FLAT:__unwindtable$?finalize@siz_params@@MAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?finalize@siz_params@@MAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$20
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$21
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0siz_params@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0siz_params@@QAE@XZ$0
__ehfuncinfo$??0siz_params@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0siz_params@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Ekdu_params@@UAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z$0
__ehfuncinfo$?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?describe_attribute@kdu_params@@QAEXPBDAAVkdu_message@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?describe_attribute@kdu_params@@QAEXPBDAAVkdu_message@@_N@Z$0
__ehfuncinfo$?describe_attribute@kdu_params@@QAEXPBDAAVkdu_message@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?describe_attribute@kdu_params@@QAEXPBDAAVkdu_message@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z$0
__ehfuncinfo$?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?parse_string@kdu_params@@QAE_NPBD@Z DD 019930522H
	DD	015H
	DD	FLAT:__unwindtable$?parse_string@kdu_params@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?parse_string@kdu_params@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$20
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?set_derived@kdu_params@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?set_derived@kdu_params@@QAEXPBD@Z$0
__ehfuncinfo$?set_derived@kdu_params@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?set_derived@kdu_params@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?set@kdu_params@@QAEXPBDHHN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHHN@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHHN@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHHN@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHHN@Z$3
__ehfuncinfo$?set@kdu_params@@QAEXPBDHHN@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?set@kdu_params@@QAEXPBDHHN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?set@kdu_params@@QAEXPBDHH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHH_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHH_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHH_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHH_N@Z$3
__ehfuncinfo$?set@kdu_params@@QAEXPBDHH_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?set@kdu_params@@QAEXPBDHH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?set@kdu_params@@QAEXPBDHHH@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?set@kdu_params@@QAEXPBDHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?set@kdu_params@@QAEXPBDHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?get@kdu_params@@QAE_NPBDHHAAM_N22@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAAM_N22@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAAM_N22@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAAM_N22@Z$2
__ehfuncinfo$?get@kdu_params@@QAE_NPBDHHAAM_N22@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?get@kdu_params@@QAE_NPBDHHAAM_N22@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z$2
__ehfuncinfo$?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?get@kdu_params@@QAE_NPBDHHAAH_N22@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAAH_N22@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAAH_N22@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAAH_N22@Z$2
__ehfuncinfo$?get@kdu_params@@QAE_NPBDHHAAH_N22@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?get@kdu_params@@QAE_NPBDHHAAH_N22@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z$0
__ehfuncinfo$?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?check_typical_tile@kdu_params@@QAE_NHPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?check_typical_tile@kdu_params@@QAE_NHPBD@Z$0
__ehfuncinfo$?check_typical_tile@kdu_params@@QAE_NHPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?check_typical_tile@kdu_params@@QAE_NHPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?define_attribute@kdu_params@@IAEXPBD00H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?define_attribute@kdu_params@@IAEXPBD00H@Z$0
__ehfuncinfo$?define_attribute@kdu_params@@IAEXPBD00H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?define_attribute@kdu_params@@IAEXPBD00H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z$2
__ehfuncinfo$?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z$2
__ehfuncinfo$?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z$2
__ehfuncinfo$?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z
_TEXT	SEGMENT
_Ls$2 = -784						; size = 4
_qcd$GSCopy$1$ = -780					; size = 4
_vert_extra_levs$ = -780				; size = 4
_cod$GSCopy$1$ = -776					; size = 4
$T3 = -772						; size = 4
_num_steps$1$ = -768					; size = 4
_s$2$ = -764						; size = 4
_atk$GSCopy$1$ = -760					; size = 4
_decomp$4 = -760					; size = 4
_vert_initial_levs$1$ = -756				; size = 4
_hor_initial_levs$1$ = -752				; size = 4
_band_idx$1$ = -748					; size = 4
tv694 = -744						; size = 4
_vert_extra_high$ = -740				; size = 3
_hor_extra_high$ = -736					; size = 3
_gain$2$ = -732						; size = 8
_n$2$ = -728						; size = 4
_step_coeffs$1$ = -728					; size = 4
_kernel_id$5 = -728					; size = 4
_gain$1$ = -724						; size = 8
_gain$ = -724						; size = 8
tv693 = -720						; size = 4
_desc$ = -720						; size = 2
_kernels$ = -716					; size = 600
_band_descriptors$ = -116				; size = 98
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_qcd$ = 8						; size = 4
_cod$ = 12						; size = 4
_atk$ = 16						; size = 4
_num_dwt_levels$ = 20					; size = 4
_num_bands$ = 24					; size = 4
_ref_step$ = 28						; size = 4
_derived_from_LL$ = 32					; size = 1
?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z PROC ; derive_absolute_steps, COMDAT

; 494  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 772				; 00000304H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _qcd$[ebp]

; 495  :   int n, b;
; 496  :   int level_bands;
; 497  :   kdu_int16 desc, band_descriptors[49];
; 498  :   int hor_initial_levs=0, vert_initial_levs=0;
; 499  :   int hor_extra_levs=0, vert_extra_levs;

	xor	ebx, ebx
	mov	esi, DWORD PTR _atk$[ebp]
	mov	DWORD PTR _qcd$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _cod$[ebp]
	mov	DWORD PTR _cod$GSCopy$1$[ebp], eax
	mov	DWORD PTR _atk$GSCopy$1$[ebp], esi
	mov	DWORD PTR _hor_initial_levs$1$[ebp], 0
	mov	DWORD PTR _vert_initial_levs$1$[ebp], 0

; 500  :   bool hor_extra_high[3], vert_extra_high[3];
; 501  :   double gain;
; 502  :   int band_idx = (derived_from_LL)?0:(num_bands-1);

	cmp	BYTE PTR _derived_from_LL$[ebp], bl
	je	SHORT $LN23@derive_abs
	mov	DWORD PTR _band_idx$1$[ebp], ebx
	jmp	SHORT $LN24@derive_abs
$LN23@derive_abs:
	mov	eax, DWORD PTR _num_bands$[ebp]
	dec	eax
	mov	DWORD PTR _band_idx$1$[ebp], eax
$LN24@derive_abs:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 135  :     kdu_kernels() { clear(); }

	lea	ecx, DWORD PTR _kernels$[ebp]
	call	?clear@kdu_kernels@@AAEXXZ		; kdu_kernels::clear
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 505  :   kdu_kernels kernels;

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 506  :   if (atk == NULL)
; 507  :     {
; 508  :       int kernel_id;  cod->get(Ckernels,0,0,kernel_id);

	push	1
	push	1
	push	1
	test	esi, esi
	jne	SHORT $LN17@derive_abs
	lea	eax, DWORD PTR _kernel_id$5[ebp]
	push	eax
	push	esi
	push	esi
	mov	esi, DWORD PTR _cod$GSCopy$1$[ebp]
	mov	ecx, esi
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 509  :       kernels.init(kernel_id,false);

	push	0
	push	DWORD PTR _kernel_id$5[ebp]
	lea	ecx, DWORD PTR _kernels$[ebp]
	call	?init@kdu_kernels@@QAEXH_N@Z		; kdu_kernels::init

; 510  :     }
; 511  :   else

	jmp	$LN18@derive_abs
$LN17@derive_abs:

; 512  :     {
; 513  :       int c, s, Ls, num_steps=0, num_coeffs=0;
; 514  :       for (s=0; atk->get(Ksteps,s,0,Ls); s++)

	lea	eax, DWORD PTR _Ls$2[ebp]
	xor	edi, edi
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, esi
	mov	DWORD PTR _num_steps$1$[ebp], edi
	xor	ebx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN3@derive_abs
	npad	8
$LL4@derive_abs:

; 515  :         num_coeffs += Ls;

	add	ebx, DWORD PTR _Ls$2[ebp]
	lea	eax, DWORD PTR _Ls$2[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	inc	edi
	mov	ecx, esi
	push	edi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL4@derive_abs
	mov	DWORD PTR _num_steps$1$[ebp], edi
$LN3@derive_abs:

; 517  :       kdu_kernel_step_info *step_info = new kdu_kernel_step_info[num_steps];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	test	eax, eax
	je	SHORT $LN25@derive_abs
	mov	ecx, edi
	test	edi, edi
	je	SHORT $LN26@derive_abs
	add	eax, 12					; 0000000cH
	npad	5
$LL32@derive_abs:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 101  :       { support_length = support_min = 0;  downshift = rounding_offset = 0; }

	mov	DWORD PTR [eax-8], 0
	lea	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [eax-28], 0
	mov	DWORD PTR [eax-16], 0
	mov	DWORD PTR [eax-20], 0
	sub	ecx, 1
	jne	SHORT $LL32@derive_abs
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 517  :       kdu_kernel_step_info *step_info = new kdu_kernel_step_info[num_steps];

	jmp	SHORT $LN26@derive_abs
$LN25@derive_abs:
	mov	DWORD PTR $T3[ebp], 0
$LN26@derive_abs:

; 518  :       float *step_coeffs = new float[num_coeffs];

	xor	ecx, ecx
	mov	eax, ebx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR _step_coeffs$1$[ebp], eax
	add	esp, 4

; 519  :       for (c=s=0; s < num_steps; s++)

	xor	eax, eax
	xor	ebx, ebx
	mov	DWORD PTR _s$2$[ebp], eax
	test	edi, edi
	jle	$LN6@derive_abs

; 518  :       float *step_coeffs = new float[num_coeffs];

	mov	edi, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv694[ebp], edi
	npad	1
$LL7@derive_abs:

; 520  :         {
; 521  :           kdu_kernel_step_info *sp = step_info + s;
; 522  :           if (!(atk->get(Ksteps,s,0,sp->support_length) &&

	push	1
	push	1
	push	1
	push	edi
	push	0
	push	eax
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN20@derive_abs
	push	1
	push	1
	lea	eax, DWORD PTR [edi+8]
	mov	ecx, esi
	mov	edi, DWORD PTR _s$2$[ebp]
	push	1
	mov	DWORD PTR tv693[ebp], eax
	add	eax, -4					; fffffffcH
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN20@derive_abs
	push	1
	push	1
	push	1
	push	DWORD PTR tv693[ebp]
	mov	ecx, esi
	push	2
	push	edi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN20@derive_abs
	mov	eax, DWORD PTR tv693[ebp]
	mov	ecx, esi
	push	1
	push	1
	push	1
	add	eax, 4
	push	eax
	push	3
	push	edi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN20@derive_abs:

; 523  :                 atk->get(Ksteps,s,1,sp->support_min) &&
; 524  :                 atk->get(Ksteps,s,2,sp->downshift) &&
; 525  :                 atk->get(Ksteps,s,3,sp->rounding_offset)))
; 526  :             assert(0);
; 527  :           for (n=0; n < sp->support_length; n++, c++)

	mov	eax, DWORD PTR tv694[ebp]
	xor	edi, edi
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN5@derive_abs
	mov	eax, DWORD PTR _step_coeffs$1$[ebp]
	lea	esi, DWORD PTR [eax+ebx*4]
	npad	7
$LL10@derive_abs:

; 528  :             atk->get(Kcoeffs,c,0,step_coeffs[c]);

	mov	ecx, DWORD PTR _atk$GSCopy$1$[ebp]
	push	1
	push	1
	push	1
	push	esi
	push	0
	push	ebx
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	mov	eax, DWORD PTR tv694[ebp]
	inc	edi
	inc	ebx
	add	esi, 4
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL10@derive_abs
	mov	esi, DWORD PTR _atk$GSCopy$1$[ebp]
$LN5@derive_abs:

; 519  :       for (c=s=0; s < num_steps; s++)

	mov	eax, DWORD PTR _s$2$[ebp]
	mov	edi, DWORD PTR tv694[ebp]
	inc	eax
	add	edi, 16					; 00000010H
	mov	DWORD PTR _s$2$[ebp], eax
	mov	DWORD PTR tv694[ebp], edi
	cmp	eax, DWORD PTR _num_steps$1$[ebp]
	jl	$LL7@derive_abs
	mov	edi, DWORD PTR _num_steps$1$[ebp]
$LN6@derive_abs:

; 529  :         }
; 530  :       kernels.init(num_steps,step_info,step_coeffs,false,false,false);

	mov	esi, DWORD PTR _step_coeffs$1$[ebp]
	lea	ecx, DWORD PTR _kernels$[ebp]
	mov	ebx, DWORD PTR $T3[ebp]
	push	0
	push	0
	push	0
	push	esi
	push	ebx
	push	edi
	call	?init@kdu_kernels@@QAEXHPBUkdu_kernel_step_info@@PBM_N22@Z ; kdu_kernels::init

; 531  :       delete[] step_info;

	push	ebx
	call	??_V@YAXPAX@Z				; operator delete[]

; 532  :       delete[] step_coeffs;

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	esi, DWORD PTR _cod$GSCopy$1$[ebp]
	add	esp, 8
	xor	ebx, ebx
$LN18@derive_abs:

; 533  :     }
; 534  : 
; 535  :   // Now work through the levels
; 536  :   for (n=0; n < num_dwt_levels; n++)

	xor	eax, eax
	mov	DWORD PTR _n$2$[ebp], eax
	cmp	DWORD PTR _num_dwt_levels$[ebp], eax
	jle	$LN12@derive_abs
	mov	edi, DWORD PTR _vert_extra_levs$[ebp]
	npad	5
$LL13@derive_abs:

; 537  :     {
; 538  :       int decomp;
; 539  :       cod->get(Cdecomp,n,0,decomp);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _decomp$4[ebp]
	push	ecx
	push	0
	push	eax
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 540  :       level_bands = cod_params::expand_decomp_bands(decomp,band_descriptors);

	lea	eax, DWORD PTR _band_descriptors$[ebp]
	push	eax
	push	DWORD PTR _decomp$4[ebp]
	call	?expand_decomp_bands@cod_params@@SAHHQAF@Z ; cod_params::expand_decomp_bands
	add	esp, 8

; 541  :       for (b=level_bands-1; b >= 0; b--)

	lea	esi, DWORD PTR [eax-1]
	test	esi, esi
	js	$LN15@derive_abs
	npad	7
$LL16@derive_abs:

; 542  :         {
; 543  :           desc = band_descriptors[b];

	movzx	eax, WORD PTR _band_descriptors$[ebp+esi*2]

; 544  :           hor_extra_levs = (desc & 3);

	mov	dx, ax
	mov	DWORD PTR _desc$[ebp], eax
	movsx	ecx, dx

; 545  :           hor_extra_high[0] = (desc & (1<<2))?true:false;

	mov	eax, ecx

; 546  :           hor_extra_high[1] = (desc & (1<<3))?true:false;
; 547  :           hor_extra_high[2] = (desc & (1<<4))?true:false;
; 548  :           desc >>= 8;

	sar	dx, 8
	shr	eax, 2
	mov	ebx, ecx
	and	al, 1
	and	ebx, 3
	mov	BYTE PTR _hor_extra_high$[ebp], al
	mov	eax, ecx
	shr	eax, 3
	shr	ecx, 4
	and	al, 1
	and	cl, 1
	mov	BYTE PTR _hor_extra_high$[ebp+1], al
	mov	BYTE PTR _hor_extra_high$[ebp+2], cl

; 549  :           vert_extra_levs = (desc & 3);

	movsx	ecx, dx

; 550  :           vert_extra_high[0] = (desc & (1<<2))?true:false;

	mov	eax, ecx
	mov	edi, ecx
	shr	eax, 2
	and	edi, 3
	and	al, 1
	mov	BYTE PTR _vert_extra_high$[ebp], al

; 551  :           vert_extra_high[1] = (desc & (1<<3))?true:false;

	mov	eax, ecx
	shr	eax, 3

; 552  :           vert_extra_high[2] = (desc & (1<<4))?true:false;

	shr	ecx, 4
	and	al, 1
	and	cl, 1
	mov	BYTE PTR _vert_extra_high$[ebp+1], al
	mov	BYTE PTR _vert_extra_high$[ebp+2], cl

; 553  :           if ((b > 0) && !derived_from_LL)

	test	esi, esi
	jle	$LN14@derive_abs
	cmp	BYTE PTR _derived_from_LL$[ebp], 0
	jne	$LN14@derive_abs

; 554  :             {
; 555  :               gain =

	lea	eax, DWORD PTR _hor_extra_high$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _hor_initial_levs$1$[ebp]
	lea	ecx, DWORD PTR _kernels$[ebp]
	call	?get_energy_gain@kdu_kernels@@QAENHHQA_N@Z ; kdu_kernels::get_energy_gain

; 556  :                 kernels.get_energy_gain(hor_initial_levs,hor_extra_levs,
; 557  :                                         hor_extra_high);
; 558  :               gain *=

	lea	eax, DWORD PTR _vert_extra_high$[ebp]
	push	eax
	push	edi
	push	DWORD PTR _vert_initial_levs$1$[ebp]
	fstp	QWORD PTR _gain$1$[ebp]
	lea	ecx, DWORD PTR _kernels$[ebp]
	call	?get_energy_gain@kdu_kernels@@QAENHHQA_N@Z ; kdu_kernels::get_energy_gain
	fmul	QWORD PTR _gain$1$[ebp]
	fstp	QWORD PTR _gain$[ebp]

; 559  :                 kernels.get_energy_gain(vert_initial_levs,vert_extra_levs,
; 560  :                                         vert_extra_high);
; 561  :               assert(band_idx > 0);
; 562  :               qcd->set(Qabs_steps,band_idx--,0,ref_step/(float)sqrt(gain));

	movsd	xmm0, QWORD PTR _gain$[ebp]
	call	__libm_sse2_sqrt_precise
	movss	xmm1, DWORD PTR _ref_step$[ebp]
	sub	esp, 8
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _qcd$GSCopy$1$[ebp]
	divss	xmm1, xmm0
	cvtps2pd xmm0, xmm1
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	DWORD PTR _band_idx$1$[ebp]
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	dec	DWORD PTR _band_idx$1$[ebp]
$LN14@derive_abs:

; 541  :       for (b=level_bands-1; b >= 0; b--)

	sub	esi, 1
	jns	$LL16@derive_abs
$LN15@derive_abs:

; 533  :     }
; 534  : 
; 535  :   // Now work through the levels
; 536  :   for (n=0; n < num_dwt_levels; n++)

	mov	eax, DWORD PTR _n$2$[ebp]

; 563  :             }
; 564  :         }
; 565  :       hor_initial_levs += hor_extra_levs;

	add	DWORD PTR _hor_initial_levs$1$[ebp], ebx
	inc	eax

; 566  :       vert_initial_levs += vert_extra_levs;

	add	DWORD PTR _vert_initial_levs$1$[ebp], edi
	mov	esi, DWORD PTR _cod$GSCopy$1$[ebp]
	mov	DWORD PTR _n$2$[ebp], eax
	cmp	eax, DWORD PTR _num_dwt_levels$[ebp]
	jl	$LL13@derive_abs
$LN12@derive_abs:

; 567  :     }
; 568  :   assert(band_idx == 0);
; 569  :   gain  = kernels.get_energy_gain(hor_initial_levs,0,NULL);

	push	0
	push	0
	push	DWORD PTR _hor_initial_levs$1$[ebp]
	lea	ecx, DWORD PTR _kernels$[ebp]
	call	?get_energy_gain@kdu_kernels@@QAENHHQA_N@Z ; kdu_kernels::get_energy_gain

; 570  :   gain *= kernels.get_energy_gain(vert_initial_levs,0,NULL);

	push	0
	push	0
	push	DWORD PTR _vert_initial_levs$1$[ebp]
	fstp	QWORD PTR _gain$2$[ebp]
	lea	ecx, DWORD PTR _kernels$[ebp]
	call	?get_energy_gain@kdu_kernels@@QAENHHQA_N@Z ; kdu_kernels::get_energy_gain
	fmul	QWORD PTR _gain$2$[ebp]
	fstp	QWORD PTR _gain$[ebp]

; 571  :   qcd->set(Qabs_steps,0,0,ref_step/(float)sqrt(gain));

	movsd	xmm0, QWORD PTR _gain$[ebp]
	call	__libm_sse2_sqrt_precise
	movss	xmm1, DWORD PTR _ref_step$[ebp]
	sub	esp, 8
	cvtsd2ss xmm0, xmm0
	mov	ecx, DWORD PTR _qcd$GSCopy$1$[ebp]
	divss	xmm1, xmm0
	cvtps2pd xmm0, xmm1
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 147  :     ~kdu_kernels() { reset(); }

	lea	ecx, DWORD PTR _kernels$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	call	?reset@kdu_kernels@@AAEXXZ		; kdu_kernels::reset
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 572  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z$0:
	lea	ecx, DWORD PTR _kernels$[ebp]
	jmp	??1kdu_kernels@@QAE@XZ			; kdu_kernels::~kdu_kernels
__unwindfunclet$?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z$2:
	call	___std_terminate
	ret	0
__ehhandler$?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-788]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z ENDP ; derive_absolute_steps
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z
_TEXT	SEGMENT
_qcd$GSCopy$1$ = -780					; size = 4
_atk$GSCopy$1$ = -776					; size = 4
_cod$GSCopy$1$ = -772					; size = 4
_hor_extra_levs$1$ = -768				; size = 4
$T2 = -764						; size = 4
_num_steps$1$ = -760					; size = 4
tv743 = -756						; size = 4
_decomp$3 = -752					; size = 4
_Ls$4 = -752						; size = 4
_vert_initial_levs$1$ = -748				; size = 4
_hor_initial_levs$1$ = -744				; size = 4
_vert_extra_high$ = -740				; size = 3
_hor_extra_high$ = -736					; size = 3
_s$2$ = -732						; size = 4
_gain$2$ = -728						; size = 8
_gain$1$ = -728						; size = 8
_gain$ = -728						; size = 8
_band_idx$1$ = -724					; size = 4
_desc$ = -724						; size = 2
_vert_extra_levs$ = -724				; size = 4
_n$2$ = -720						; size = 4
_step_coeffs$1$ = -720					; size = 4
_kernel_id$5 = -720					; size = 4
_kernels$ = -716					; size = 600
_band_descriptors$ = -116				; size = 98
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_qcd$ = 8						; size = 4
_cod$ = 12						; size = 4
_atk$ = 16						; size = 4
_num_dwt_levels$ = 20					; size = 4
_num_bands$ = 24					; size = 4
_precision$ = 28					; size = 4
_guard_bits$ = 32					; size = 4
?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z PROC ; derive_absolute_ranges, COMDAT

; 395  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 768				; 00000300H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _qcd$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 135  :     kdu_kernels() { clear(); }

	lea	ecx, DWORD PTR _kernels$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 402  :   int band_idx = num_bands-1;

	mov	ebx, DWORD PTR _num_bands$[ebp]
	mov	esi, DWORD PTR _atk$[ebp]
	dec	ebx
	mov	DWORD PTR _qcd$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _cod$[ebp]
	mov	DWORD PTR _cod$GSCopy$1$[ebp], eax
	mov	DWORD PTR _atk$GSCopy$1$[ebp], esi
	mov	DWORD PTR _hor_initial_levs$1$[ebp], 0
	mov	DWORD PTR _vert_initial_levs$1$[ebp], 0
	mov	DWORD PTR _hor_extra_levs$1$[ebp], 0
	mov	DWORD PTR _band_idx$1$[ebp], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 135  :     kdu_kernels() { clear(); }

	call	?clear@kdu_kernels@@AAEXXZ		; kdu_kernels::clear
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 407  :   kdu_kernels kernels;

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 408  :   if (atk == NULL)
; 409  :     {
; 410  :       int kernel_id;  cod->get(Ckernels,0,0,kernel_id);

	push	1
	push	1
	push	1
	test	esi, esi
	jne	SHORT $LN23@derive_abs
	lea	eax, DWORD PTR _kernel_id$5[ebp]
	push	eax
	push	esi
	push	esi
	mov	esi, DWORD PTR _cod$GSCopy$1$[ebp]
	mov	ecx, esi
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 411  :       kernels.init(kernel_id,true);

	push	1
	push	DWORD PTR _kernel_id$5[ebp]
	lea	ecx, DWORD PTR _kernels$[ebp]
	call	?init@kdu_kernels@@QAEXH_N@Z		; kdu_kernels::init

; 412  :     }
; 413  :   else

	jmp	$LN24@derive_abs
$LN23@derive_abs:

; 414  :     {
; 415  :       int c, s, Ls, num_steps=0, num_coeffs=0;
; 416  :       for (s=0; atk->get(Ksteps,s,0,Ls); s++)

	lea	eax, DWORD PTR _Ls$4[ebp]
	xor	edi, edi
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, esi
	mov	DWORD PTR _num_steps$1$[ebp], edi
	xor	ebx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN3@derive_abs
	npad	13
$LL4@derive_abs:

; 417  :         num_coeffs += Ls;

	add	ebx, DWORD PTR _Ls$4[ebp]
	lea	eax, DWORD PTR _Ls$4[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	inc	edi
	mov	ecx, esi
	push	edi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL4@derive_abs
	mov	DWORD PTR _num_steps$1$[ebp], edi
$LN3@derive_abs:

; 419  :       kdu_kernel_step_info *step_info = new kdu_kernel_step_info[num_steps];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	test	eax, eax
	je	SHORT $LN29@derive_abs
	mov	ecx, edi
	test	edi, edi
	je	SHORT $LN30@derive_abs
	add	eax, 12					; 0000000cH
	npad	5
$LL36@derive_abs:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 101  :       { support_length = support_min = 0;  downshift = rounding_offset = 0; }

	mov	DWORD PTR [eax-8], 0
	lea	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [eax-28], 0
	mov	DWORD PTR [eax-16], 0
	mov	DWORD PTR [eax-20], 0
	sub	ecx, 1
	jne	SHORT $LL36@derive_abs
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 419  :       kdu_kernel_step_info *step_info = new kdu_kernel_step_info[num_steps];

	jmp	SHORT $LN30@derive_abs
$LN29@derive_abs:
	mov	DWORD PTR $T2[ebp], 0
$LN30@derive_abs:

; 420  :       float *step_coeffs = new float[num_coeffs];

	xor	ecx, ecx
	mov	eax, ebx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR _step_coeffs$1$[ebp], eax
	add	esp, 4

; 421  :       for (c=s=0; s < num_steps; s++)

	xor	eax, eax
	xor	ebx, ebx
	mov	DWORD PTR _s$2$[ebp], eax
	test	edi, edi
	jle	$LN6@derive_abs

; 420  :       float *step_coeffs = new float[num_coeffs];

	mov	edi, DWORD PTR $T2[ebp]
	mov	DWORD PTR tv743[ebp], edi
	npad	1
$LL7@derive_abs:

; 422  :         {
; 423  :           kdu_kernel_step_info *sp = step_info + s;
; 424  :           if (!(atk->get(Ksteps,s,0,sp->support_length) &&

	push	1
	push	1
	push	1
	push	edi
	push	0
	push	eax
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN26@derive_abs
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR [edi+4]
	mov	ecx, esi
	push	eax
	push	1
	push	DWORD PTR _s$2$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN26@derive_abs
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR [edi+8]
	mov	ecx, esi
	push	eax
	push	2
	push	DWORD PTR _s$2$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN26@derive_abs
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR [edi+12]
	mov	ecx, esi
	push	eax
	push	3
	push	DWORD PTR _s$2$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN26@derive_abs:

; 425  :                 atk->get(Ksteps,s,1,sp->support_min) &&
; 426  :                 atk->get(Ksteps,s,2,sp->downshift) &&
; 427  :                 atk->get(Ksteps,s,3,sp->rounding_offset)))
; 428  :             assert(0);
; 429  :           for (n=0; n < sp->support_length; n++, c++)

	xor	esi, esi
	cmp	DWORD PTR [edi], esi
	jle	SHORT $LN5@derive_abs
	mov	eax, DWORD PTR _step_coeffs$1$[ebp]
	lea	edi, DWORD PTR [eax+ebx*4]
	npad	5
$LL10@derive_abs:

; 430  :             atk->get(Kcoeffs,c,0,step_coeffs[c]);

	mov	ecx, DWORD PTR _atk$GSCopy$1$[ebp]
	push	1
	push	1
	push	1
	push	edi
	push	0
	push	ebx
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	mov	eax, DWORD PTR tv743[ebp]
	inc	esi
	inc	ebx
	add	edi, 4
	cmp	esi, DWORD PTR [eax]
	jl	SHORT $LL10@derive_abs
	mov	edi, eax
$LN5@derive_abs:

; 421  :       for (c=s=0; s < num_steps; s++)

	mov	eax, DWORD PTR _s$2$[ebp]
	add	edi, 16					; 00000010H
	mov	esi, DWORD PTR _atk$GSCopy$1$[ebp]
	inc	eax
	mov	DWORD PTR _s$2$[ebp], eax
	mov	DWORD PTR tv743[ebp], edi
	cmp	eax, DWORD PTR _num_steps$1$[ebp]
	jl	$LL7@derive_abs
	mov	edi, DWORD PTR _num_steps$1$[ebp]
$LN6@derive_abs:

; 431  :         }
; 432  :       kernels.init(num_steps,step_info,step_coeffs,false,false,true);

	mov	esi, DWORD PTR _step_coeffs$1$[ebp]
	lea	ecx, DWORD PTR _kernels$[ebp]
	mov	ebx, DWORD PTR $T2[ebp]
	push	1
	push	0
	push	0
	push	esi
	push	ebx
	push	edi
	call	?init@kdu_kernels@@QAEXHPBUkdu_kernel_step_info@@PBM_N22@Z ; kdu_kernels::init

; 433  :       delete[] step_info;

	push	ebx
	call	??_V@YAXPAX@Z				; operator delete[]

; 434  :       delete[] step_coeffs;

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	ebx, DWORD PTR _band_idx$1$[ebp]
	add	esp, 8
	mov	esi, DWORD PTR _cod$GSCopy$1$[ebp]
$LN24@derive_abs:

; 435  :     }
; 436  : 
; 437  :   // Now work through the levels
; 438  :   for (n=0; n < num_dwt_levels; n++)

	xor	eax, eax
	mov	DWORD PTR _n$2$[ebp], eax
	cmp	DWORD PTR _num_dwt_levels$[ebp], eax
	jle	$LN12@derive_abs
	mov	edi, DWORD PTR _vert_extra_levs$[ebp]
	npad	5
$LL13@derive_abs:

; 439  :     {
; 440  :       int decomp;
; 441  :       cod->get(Cdecomp,n,0,decomp);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _decomp$3[ebp]
	push	ecx
	push	0
	push	eax
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 442  :       level_bands = cod_params::expand_decomp_bands(decomp,band_descriptors);

	lea	eax, DWORD PTR _band_descriptors$[ebp]
	push	eax
	push	DWORD PTR _decomp$3[ebp]
	call	?expand_decomp_bands@cod_params@@SAHHQAF@Z ; cod_params::expand_decomp_bands
	add	esp, 8

; 443  :       for (b=level_bands-1; b >= 0; b--)

	lea	esi, DWORD PTR [eax-1]
	test	esi, esi
	js	$LN15@derive_abs
	npad	7
$LL16@derive_abs:

; 444  :         {
; 445  :           desc = band_descriptors[b];

	movzx	eax, WORD PTR _band_descriptors$[ebp+esi*2]

; 446  :           hor_extra_levs = (desc & 3);

	mov	dx, ax
	mov	DWORD PTR _desc$[ebp], eax
	movsx	ecx, dx
	mov	eax, ecx

; 447  :           hor_extra_high[0] = (desc & (1<<2))?true:false;
; 448  :           hor_extra_high[1] = (desc & (1<<3))?true:false;
; 449  :           hor_extra_high[2] = (desc & (1<<4))?true:false;
; 450  :           desc >>= 8;

	sar	dx, 8
	and	eax, 3
	mov	DWORD PTR _hor_extra_levs$1$[ebp], eax
	mov	eax, ecx
	shr	eax, 2
	and	al, 1
	mov	BYTE PTR _hor_extra_high$[ebp], al
	mov	eax, ecx
	shr	eax, 3
	shr	ecx, 4
	and	al, 1
	and	cl, 1
	mov	BYTE PTR _hor_extra_high$[ebp+1], al
	mov	BYTE PTR _hor_extra_high$[ebp+2], cl

; 451  :           vert_extra_levs = (desc & 3);

	movsx	ecx, dx

; 452  :           vert_extra_high[0] = (desc & (1<<2))?true:false;

	mov	eax, ecx
	mov	edi, ecx
	shr	eax, 2
	and	edi, 3
	and	al, 1
	mov	BYTE PTR _vert_extra_high$[ebp], al

; 453  :           vert_extra_high[1] = (desc & (1<<3))?true:false;

	mov	eax, ecx
	shr	eax, 3

; 454  :           vert_extra_high[2] = (desc & (1<<4))?true:false;

	shr	ecx, 4
	and	al, 1
	and	cl, 1
	mov	BYTE PTR _vert_extra_high$[ebp+1], al
	mov	BYTE PTR _vert_extra_high$[ebp+2], cl

; 455  :           if (b > 0)

	test	esi, esi
	jle	$LN14@derive_abs

; 456  :             {
; 457  :               gain  = kernels.get_bibo_gain(hor_initial_levs,hor_extra_levs,

	lea	eax, DWORD PTR _hor_extra_high$[ebp]
	push	eax
	push	DWORD PTR _hor_extra_levs$1$[ebp]
	lea	ecx, DWORD PTR _kernels$[ebp]
	push	DWORD PTR _hor_initial_levs$1$[ebp]
	call	?get_bibo_gain@kdu_kernels@@QAENHHQA_N@Z ; kdu_kernels::get_bibo_gain

; 458  :                                             hor_extra_high);
; 459  :               gain *= kernels.get_bibo_gain(vert_initial_levs,vert_extra_levs,

	lea	eax, DWORD PTR _vert_extra_high$[ebp]
	push	eax
	push	edi
	push	DWORD PTR _vert_initial_levs$1$[ebp]
	fstp	QWORD PTR _gain$1$[ebp]
	lea	ecx, DWORD PTR _kernels$[ebp]
	call	?get_bibo_gain@kdu_kernels@@QAENHHQA_N@Z ; kdu_kernels::get_bibo_gain
	fmul	QWORD PTR _gain$1$[ebp]

; 460  :                                             vert_extra_high);
; 461  :               for (range=precision-guard_bits; gain > 0.9F; gain*=0.5F)

	mov	eax, DWORD PTR _precision$[ebp]
	movsd	xmm1, QWORD PTR __real@3fecccccc0000000
	sub	eax, DWORD PTR _guard_bits$[ebp]
	fstp	QWORD PTR _gain$[ebp]
	movsd	xmm0, QWORD PTR _gain$[ebp]
	comisd	xmm0, xmm1
	jbe	SHORT $LN18@derive_abs
	movsd	xmm2, QWORD PTR __real@3fe0000000000000
	npad	7
$LL19@derive_abs:
	mulsd	xmm0, xmm2

; 462  :                 range++;

	inc	eax
	comisd	xmm0, xmm1
	ja	SHORT $LL19@derive_abs
$LN18@derive_abs:

; 463  :               assert(band_idx > 0);
; 464  :               qcd->set(Qabs_ranges,band_idx--,0,range);

	mov	ecx, DWORD PTR _qcd$GSCopy$1$[ebp]
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	dec	ebx
$LN14@derive_abs:

; 443  :       for (b=level_bands-1; b >= 0; b--)

	sub	esi, 1
	jns	$LL16@derive_abs
$LN15@derive_abs:

; 465  :             }
; 466  :         }
; 467  :       hor_initial_levs += hor_extra_levs;

	mov	eax, DWORD PTR _hor_initial_levs$1$[ebp]
	add	eax, DWORD PTR _hor_extra_levs$1$[ebp]

; 468  :       vert_initial_levs += vert_extra_levs;

	add	DWORD PTR _vert_initial_levs$1$[ebp], edi
	mov	esi, DWORD PTR _cod$GSCopy$1$[ebp]
	mov	DWORD PTR _hor_initial_levs$1$[ebp], eax
	mov	eax, DWORD PTR _n$2$[ebp]
	inc	eax
	mov	DWORD PTR _n$2$[ebp], eax
	cmp	eax, DWORD PTR _num_dwt_levels$[ebp]
	jl	$LL13@derive_abs
$LN12@derive_abs:

; 469  :     }
; 470  :   assert(band_idx == 0);
; 471  :   gain  = kernels.get_bibo_gain(hor_initial_levs,0,NULL);

	push	0
	push	0
	push	DWORD PTR _hor_initial_levs$1$[ebp]
	lea	ecx, DWORD PTR _kernels$[ebp]
	call	?get_bibo_gain@kdu_kernels@@QAENHHQA_N@Z ; kdu_kernels::get_bibo_gain

; 472  :   gain *= kernels.get_bibo_gain(vert_initial_levs,0,NULL);

	push	0
	push	0
	push	DWORD PTR _vert_initial_levs$1$[ebp]
	fstp	QWORD PTR _gain$2$[ebp]
	lea	ecx, DWORD PTR _kernels$[ebp]
	call	?get_bibo_gain@kdu_kernels@@QAENHHQA_N@Z ; kdu_kernels::get_bibo_gain
	fmul	QWORD PTR _gain$2$[ebp]

; 473  :   for (range=precision-guard_bits; gain > 0.9F; gain*=0.5F)

	mov	eax, DWORD PTR _precision$[ebp]
	movsd	xmm0, QWORD PTR __real@3fecccccc0000000
	sub	eax, DWORD PTR _guard_bits$[ebp]
	fstp	QWORD PTR _gain$[ebp]
	movsd	xmm2, QWORD PTR _gain$[ebp]
	comisd	xmm2, xmm0
	jbe	SHORT $LN21@derive_abs
	movsd	xmm1, QWORD PTR __real@3fe0000000000000
	npad	3
$LL22@derive_abs:
	mulsd	xmm2, xmm1

; 474  :     range++;

	inc	eax
	comisd	xmm2, xmm0
	ja	SHORT $LL22@derive_abs
$LN21@derive_abs:

; 475  :   qcd->set(Qabs_ranges,0,0,range);

	mov	ecx, DWORD PTR _qcd$GSCopy$1$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 147  :     ~kdu_kernels() { reset(); }

	lea	ecx, DWORD PTR _kernels$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	call	?reset@kdu_kernels@@AAEXXZ		; kdu_kernels::reset
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 476  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z$0:
	lea	ecx, DWORD PTR _kernels$[ebp]
	jmp	??1kdu_kernels@@QAE@XZ			; kdu_kernels::~kdu_kernels
__unwindfunclet$?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z$2:
	call	___std_terminate
	ret	0
__ehhandler$?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-784]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z ENDP ; derive_absolute_ranges
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?synthesize_canvas_size@@YA_NHQAHHAAH@Z
_TEXT	SEGMENT
_min_size$1$ = -24					; size = 4
tv537 = -20						; size = 4
_ref_sub$1$ = -16					; size = 4
_ref_dim$1$ = -12					; size = 4
_n$2$ = -8						; size = 4
_max_size$1$ = -4					; size = 4
_components$ = 8					; size = 4
_dims$ = 12						; size = 4
_origin$ = 16						; size = 4
_size$ = 20						; size = 4
?synthesize_canvas_size@@YA_NHQAHHAAH@Z PROC		; synthesize_canvas_size, COMDAT

; 324  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx

; 325  :   int ref_dim, ref_sub, n;
; 326  : 
; 327  :   for (ref_dim=dims[0], n=1; n < components; n++)

	mov	ebx, DWORD PTR _components$[ebp]
	mov	ecx, 1
	push	esi
	mov	esi, DWORD PTR _dims$[ebp]
	push	edi
	lea	eax, DWORD PTR [ebx-1]
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR _ref_dim$1$[ebp], edi
	cmp	ebx, ecx
	jle	$LN3@synthesize
	cmp	eax, 8
	jb	SHORT $LN61@synthesize
	cmp	DWORD PTR ___isa_available, 2
	jl	SHORT $LN61@synthesize
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN93@synthesize
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN93@synthesize:
	movd	xmm0, edi
	mov	edx, ebx
	pshufd	xmm1, xmm0, 0
	sub	edx, eax
	movaps	xmm2, xmm1
	lea	eax, DWORD PTR [esi+4]
$LL4@synthesize:

; 329  :       ref_dim = dims[n];

	movups	xmm0, XMMWORD PTR [eax]
	add	ecx, 8
	lea	eax, DWORD PTR [eax+32]
	pmaxsd	xmm1, xmm0
	movups	xmm0, XMMWORD PTR [eax-16]
	pmaxsd	xmm2, xmm0
	cmp	ecx, edx
	jl	SHORT $LL4@synthesize
	pmaxsd	xmm1, xmm2
	movaps	xmm0, xmm1
	psrldq	xmm0, 8
	pmaxsd	xmm1, xmm0
	movaps	xmm0, xmm1
	psrldq	xmm0, 4
	pmaxsd	xmm1, xmm0
	movd	edi, xmm1
	mov	DWORD PTR _ref_dim$1$[ebp], edi
$LN61@synthesize:

; 325  :   int ref_dim, ref_sub, n;
; 326  : 
; 327  :   for (ref_dim=dims[0], n=1; n < components; n++)

	cmp	ecx, ebx
	jge	SHORT $LN3@synthesize
$LL59@synthesize:

; 328  :     if (dims[n] > ref_dim)

	cmp	DWORD PTR [esi+ecx*4], edi
	cmovg	edi, DWORD PTR [esi+ecx*4]
	inc	ecx
	cmp	ecx, ebx
	jl	SHORT $LL59@synthesize
	mov	DWORD PTR _ref_dim$1$[ebp], edi
$LN3@synthesize:

; 330  :   for (ref_sub=1; ref_sub <= 255; ref_sub++)

	mov	esi, DWORD PTR _origin$[ebp]
	mov	ecx, 1
	mov	DWORD PTR _ref_sub$1$[ebp], ecx
$LL7@synthesize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	esi, esi
	jg	SHORT $LN28@synthesize

; 180  :     return -((-num)/den);

	mov	eax, esi
	cdq
	idiv	ecx
	jmp	SHORT $LN29@synthesize
$LN28@synthesize:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [esi-1]
	cdq
	idiv	ecx
	inc	eax
$LN29@synthesize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 332  :       int max_size = (ceil_ratio(origin,ref_sub)+ref_dim)*ref_sub;

	add	eax, edi
	imul	eax, ecx

; 333  :       int min_size = max_size - ref_sub + 1;

	mov	edi, eax
	mov	DWORD PTR _max_size$1$[ebp], eax
	sub	edi, ecx

; 334  :       for (n=0; n < components; n++)

	xor	eax, eax
	inc	edi
	mov	DWORD PTR _n$2$[ebp], eax
	test	ebx, ebx
	jle	$LN50@synthesize
	npad	4
$LL10@synthesize:

; 335  :         {
; 336  :           int sz, last_sz, sub;
; 337  :           
; 338  :           // Find smallest sub-sampling factor compatible with existing
; 339  :           // minimum canvas size and use this to deduce new minimum size.
; 340  :           sub = (min_size - origin) / dims[n]; // Roughly smallest factor.

	mov	ecx, DWORD PTR _dims$[ebp]
	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	eax, edi
	sub	eax, esi
	mov	DWORD PTR tv537[ebp], ebx
	cdq
	idiv	ebx
	mov	ecx, eax

; 341  :           if (sub <= 0)

	test	ecx, ecx
	jg	SHORT $LN46@synthesize

; 342  :             sub = 1;

	mov	ecx, 1

; 343  :           while ((sub > 1) &&

	jmp	SHORT $LL13@synthesize
$LN46@synthesize:
	cmp	ecx, 1
	jle	SHORT $LL13@synthesize
$LL11@synthesize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	esi, esi
	jg	SHORT $LN32@synthesize

; 180  :     return -((-num)/den);

	mov	eax, esi
	cdq
	idiv	ecx
	jmp	SHORT $LN33@synthesize
$LN32@synthesize:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [esi-1]
	cdq
	idiv	ecx
	inc	eax
$LN33@synthesize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 343  :           while ((sub > 1) &&

	add	eax, ebx
	imul	eax, ecx
	cmp	eax, edi
	jle	SHORT $LL13@synthesize

; 344  :                  (((ceil_ratio(origin,sub)+dims[n])*sub) > min_size))
; 345  :             sub--;

	dec	ecx
	cmp	ecx, 1
	jg	SHORT $LL11@synthesize
$LL13@synthesize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	esi, esi
	jg	SHORT $LN36@synthesize

; 180  :     return -((-num)/den);

	mov	eax, esi
	cdq
	idiv	ecx
	jmp	SHORT $LN37@synthesize
$LN36@synthesize:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [esi-1]
	cdq
	idiv	ecx
	inc	eax
$LN37@synthesize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 346  :           while ((sz=(ceil_ratio(origin,sub)+dims[n])*sub) < min_size)

	lea	edx, DWORD PTR [ebx+eax]
	imul	edx, ecx
	cmp	edx, edi
	jge	SHORT $LN14@synthesize

; 347  :             sub++;

	inc	ecx
	jmp	SHORT $LL13@synthesize
$LN14@synthesize:

; 348  :           if ((sz-sub+1) > min_size)

	mov	eax, edx
	sub	eax, ecx
	inc	eax
	cmp	eax, edi
	cmovg	edi, eax
	mov	DWORD PTR _min_size$1$[ebp], edi

; 349  :             min_size = sz-sub+1;
; 350  : 
; 351  :           if (min_size > max_size)

	cmp	edi, DWORD PTR _max_size$1$[ebp]
	jg	SHORT $LN90@synthesize
	mov	edi, DWORD PTR tv537[ebp]
	npad	9
$LL17@synthesize:

; 352  :             break; // Current reference sub-sampling factor cannot work.
; 353  : 
; 354  :           // Find largest sub-sampling factor compatible with existing
; 355  :           // maximum canvas size and use this to deduce new maximum size.
; 356  : 
; 357  :           do {
; 358  :               last_sz = sz;

	mov	ebx, edx

; 359  :               if (sub == 255)

	cmp	ecx, 255				; 000000ffH
	je	SHORT $LN16@synthesize

; 360  :                 break;
; 361  :               sub++;

	inc	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	esi, esi
	jg	SHORT $LN40@synthesize

; 180  :     return -((-num)/den);

	mov	eax, esi
	cdq
	idiv	ecx
	jmp	SHORT $LN41@synthesize
$LN40@synthesize:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [esi-1]
	cdq
	idiv	ecx
	inc	eax
$LN41@synthesize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 362  :               sz = (ceil_ratio(origin,sub)+dims[n])*sub;

	lea	edx, DWORD PTR [edi+eax]
	imul	edx, ecx

; 363  :             } while ((sz-sub+1) <= max_size);

	mov	eax, edx
	sub	eax, ecx
	inc	eax
	cmp	eax, DWORD PTR _max_size$1$[ebp]
	jle	SHORT $LL17@synthesize
$LN16@synthesize:

; 364  :           if (last_sz < max_size)

	mov	eax, DWORD PTR _max_size$1$[ebp]
	cmp	ebx, eax

; 365  :             max_size = last_sz;
; 366  :           
; 367  :           if (min_size > max_size)

	mov	edi, DWORD PTR _min_size$1$[ebp]
	cmovl	eax, ebx
	mov	ebx, DWORD PTR _components$[ebp]
	mov	DWORD PTR _max_size$1$[ebp], eax
	cmp	edi, eax
	mov	eax, DWORD PTR _n$2$[ebp]
	jg	SHORT $LN88@synthesize

; 334  :       for (n=0; n < components; n++)

	inc	eax
	mov	DWORD PTR _n$2$[ebp], eax
	cmp	eax, ebx
	jl	$LL10@synthesize
	jmp	SHORT $LN88@synthesize
$LN90@synthesize:
	mov	eax, DWORD PTR _n$2$[ebp]
	mov	ebx, DWORD PTR _components$[ebp]
$LN88@synthesize:
	mov	ecx, DWORD PTR _ref_sub$1$[ebp]
$LN50@synthesize:

; 368  :             break; // Current reference sub-sampling factor cannot work.
; 369  :         }
; 370  :       if (n == components)

	cmp	eax, ebx
	je	SHORT $LN52@synthesize

; 330  :   for (ref_sub=1; ref_sub <= 255; ref_sub++)

	mov	edi, DWORD PTR _ref_dim$1$[ebp]
	inc	ecx
	mov	DWORD PTR _ref_sub$1$[ebp], ecx
	cmp	ecx, 255				; 000000ffH
	jle	$LL7@synthesize

; 374  :         }
; 375  :     }
; 376  :   return false; // Failed to find compatible sub-sampling factors.

	pop	edi
	pop	esi
	xor	al, al
	pop	ebx

; 377  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@synthesize:

; 371  :         { // Succeeded.
; 372  :           size = min_size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax], edi

; 373  :           return true;

	mov	al, 1
	pop	edi
	pop	esi
	pop	ebx

; 377  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?synthesize_canvas_size@@YA_NHQAHHAAH@Z ENDP		; synthesize_canvas_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?int2log@@YAHH@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
?int2log@@YAHH@Z PROC					; int2log, COMDAT

; 299  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 300  :   int e;
; 301  : 
; 302  :   for (e=0; ((1<<e) > 0) && ((1<<e) < val); e++);

	mov	esi, DWORD PTR _val$[ebp]
	xor	ecx, ecx
	mov	eax, 1
	npad	2
$LL4@int2log:
	cmp	eax, esi
	jge	SHORT $LN3@int2log
	inc	ecx
	mov	eax, 1
	shl	eax, cl
	test	eax, eax
	jg	SHORT $LL4@int2log
$LN3@int2log:

; 303  :   if (val != (1<<e))

	mov	edx, 1
	xor	eax, eax
	shl	edx, cl
	cmp	esi, edx
	pop	esi
	cmovne	ecx, eax
	mov	eax, ecx

; 304  :     return 0;
; 305  :   return e;
; 306  : }

	pop	ebp
	ret	0
?int2log@@YAHH@Z ENDP					; int2log
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?display_options@@YAXPBDAAVkdu_message@@@Z
_TEXT	SEGMENT
_val$ = -180						; size = 4
_obp$1$ = -176						; size = 4
_pattern$GSCopy$1$ = -172				; size = 4
_multi_option$1$ = -165					; size = 1
_buf2$ = -164						; size = 80
_buf1$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_pattern$ = 8						; size = 4
_output$ = 12						; size = 4
?display_options@@YAXPBDAAVkdu_message@@@Z PROC		; display_options, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _pattern$[ebp]

; 249  :   char buf1[80], buf2[80], *bp, *obp, *last_bp;
; 250  :   int val;
; 251  :   bool multi_option;
; 252  : 
; 253  :   bp = buf1; obp = buf2; last_bp = NULL;

	lea	ecx, DWORD PTR _buf2$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _output$[ebp]
	lea	ebx, DWORD PTR _buf1$[ebp]
	mov	DWORD PTR _pattern$GSCopy$1$[ebp], eax

; 254  :   multi_option = false;
; 255  :   if (*pattern == '(')

	mov	al, BYTE PTR [eax]
	push	edi
	xor	edi, edi
	mov	DWORD PTR _obp$1$[ebp], ecx
	mov	BYTE PTR _multi_option$1$[ebp], 0
	cmp	al, 40					; 00000028H
	jne	$LN8@display_op
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_0CC@LLCJBDHK@Expected?5one?5of?5the?5identifiers?0@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _pattern$GSCopy$1$[ebp]
$LL4@display_op:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 259  :           pattern = parse_translator_entry(pattern+1,',',bp,80,val);

	lea	ecx, DWORD PTR _val$[ebp]
	inc	eax
	push	ecx
	push	80					; 00000050H
	push	ebx
	push	44					; 0000002cH
	push	eax
	call	?parse_translator_entry@@YAPBDPBDDQADHAAH@Z ; parse_translator_entry

; 260  :           if (multi_option)

	mov	cl, BYTE PTR _multi_option$1$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pattern$GSCopy$1$[ebp], eax
	test	cl, cl
	je	SHORT $LN10@display_op
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	call	DWORD PTR [edx+8]
	mov	cl, BYTE PTR _multi_option$1$[ebp]
$LN10@display_op:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 262  :           if (last_bp != NULL)

	test	edi, edi
	je	SHORT $LN11@display_op
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 263  :             { output << "\"" << last_bp << "\""; multi_option = true; }

	mov	cl, 1
	mov	BYTE PTR _multi_option$1$[ebp], cl
$LN11@display_op:

; 264  :           last_bp = bp; bp = obp; obp = last_bp;
; 265  :         } while (*pattern == ',');

	mov	eax, DWORD PTR _pattern$GSCopy$1$[ebp]
	mov	edi, ebx
	mov	ebx, DWORD PTR _obp$1$[ebp]
	mov	DWORD PTR _obp$1$[ebp], edi
	cmp	BYTE PTR [eax], 44			; 0000002cH
	je	SHORT $LL4@display_op

; 266  :       assert(*pattern == ')');
; 267  :       if (multi_option)

	test	cl, cl
	je	SHORT $LN12@display_op
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_04FJKIFICP@?5or?5?$AA@
	call	DWORD PTR [eax+8]
$LN12@display_op:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	edi
	call	DWORD PTR [eax+8]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	jmp	$LN61@display_op
$LN8@display_op:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 271  :   else if (*pattern == '[')

	cmp	al, 91					; 0000005bH
	jne	$LN13@display_op
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_0CK@HEDJDDBK@Expected?5one?5or?5more?5of?5the?5iden@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _pattern$GSCopy$1$[ebp]
	npad	5
$LL7@display_op:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 275  :           pattern = parse_translator_entry(pattern+1,'|',bp,80,val);

	lea	ecx, DWORD PTR _val$[ebp]
	inc	eax
	push	ecx
	push	80					; 00000050H
	push	ebx
	push	124					; 0000007cH
	push	eax
	call	?parse_translator_entry@@YAPBDPBDDQADHAAH@Z ; parse_translator_entry

; 276  :           if (multi_option)

	mov	cl, BYTE PTR _multi_option$1$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pattern$GSCopy$1$[ebp], eax
	test	cl, cl
	je	SHORT $LN15@display_op
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	call	DWORD PTR [eax+8]
	mov	cl, BYTE PTR _multi_option$1$[ebp]
$LN15@display_op:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 278  :           if (last_bp != NULL)

	test	edi, edi
	je	SHORT $LN16@display_op
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 279  :             { output << "\"" << last_bp << "\""; multi_option = true; }

	mov	cl, 1
	mov	BYTE PTR _multi_option$1$[ebp], cl
$LN16@display_op:

; 280  :           last_bp = bp; bp = obp; obp = last_bp;
; 281  :         } while (*pattern == '|');

	mov	eax, DWORD PTR _pattern$GSCopy$1$[ebp]
	mov	edi, ebx
	mov	ebx, DWORD PTR _obp$1$[ebp]
	mov	DWORD PTR _obp$1$[ebp], edi
	cmp	BYTE PTR [eax], 124			; 0000007cH
	je	SHORT $LL7@display_op

; 282  :       assert(*pattern == ']');
; 283  :       if (multi_option)

	test	cl, cl
	je	SHORT $LN17@display_op
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_04FJKIFICP@?5or?5?$AA@
	call	DWORD PTR [eax+8]
$LN17@display_op:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	edi
	call	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0BN@BJKINHLE@?$CC?0?5separated?5by?5?$GA?$HM?8?5symbols?4?$AA@
$LN61@display_op:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+8]
$LN13@display_op:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 289  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?display_options@@YAXPBDAAVkdu_message@@@Z ENDP		; display_options
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?parse_translator_entry@@YAPBDPBDDQADHAAH@Z
_TEXT	SEGMENT
_e$2 = -156						; size = 20
_value$GSCopy$1$ = -136					; size = 4
_buf$GSCopy$1$ = -132					; size = 4
_end_p$ = -128						; size = 4
tv294 = -124						; size = 4
_start$GSCopy$1$ = -120					; size = 4
_e$3 = -116						; size = 20
_e$4 = -116						; size = 20
_text$5 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_start$ = 8						; size = 4
_separator$ = 12					; size = 1
_buf$ = 16						; size = 4
_len$ = 20						; size = 4
_value$ = 24						; size = 4
?parse_translator_entry@@YAPBDPBDDQADHAAH@Z PROC	; parse_translator_entry, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?parse_translator_entry@@YAPBDPBDDQADHAAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR _len$[ebp]

; 202  :   int i;
; 203  : 
; 204  :   for (i=0; i < len; i++)

	xor	edi, edi
	mov	esi, DWORD PTR _start$[ebp]
	mov	eax, DWORD PTR _buf$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _start$GSCopy$1$[ebp], esi
	mov	DWORD PTR _buf$GSCopy$1$[ebp], eax
	mov	DWORD PTR _value$GSCopy$1$[ebp], ecx
	test	ebx, ebx
	jle	$LN45@parse_tran
	mov	dl, BYTE PTR _separator$[ebp]
	sub	eax, esi
	mov	DWORD PTR tv294[ebp], eax
	mov	ecx, eax
	npad	3
$LL4@parse_tran:

; 205  :     {
; 206  :       if ((start[i] == separator) || (start[i] == ')') || (start[i] == ']') ||

	mov	al, BYTE PTR [esi]
	cmp	al, dl
	je	SHORT $LN7@parse_tran
	cmp	al, 41					; 00000029H
	je	SHORT $LN7@parse_tran
	cmp	al, 93					; 0000005dH
	je	SHORT $LN7@parse_tran
	test	al, al
	je	SHORT $LN7@parse_tran

; 214  :       else if (start[i] == '=')

	cmp	al, 61					; 0000003dH
	je	SHORT $LN52@parse_tran
	jmp	SHORT $LN8@parse_tran
$LN7@parse_tran:

; 208  :         { KDU_ERROR_DEV(e,1); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0GM@JHCOHHHI@String?5translators?5in?5code?9strea@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 208  :         { KDU_ERROR_DEV(e,1); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_03NONCDIOG@?3?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	DWORD PTR _start$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 213  :         }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR tv294[ebp]
	mov	dl, BYTE PTR _separator$[ebp]
$LN8@parse_tran:

; 215  :         break;
; 216  :       buf[i] = start[i];

	mov	al, BYTE PTR [esi]
	inc	edi
	mov	BYTE PTR [ecx+esi], al
	inc	esi
	cmp	edi, ebx
	jl	$LL4@parse_tran
$LN52@parse_tran:
	mov	esi, DWORD PTR _start$GSCopy$1$[ebp]
$LN45@parse_tran:

; 217  :     }
; 218  :   if (i == len)

	cmp	edi, ebx
	jne	$LN9@parse_tran

; 219  :     { KDU_ERROR_DEV(e,2); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0EL@BICNPJDD@String?5translators?5in?5code?9strea@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 219  :     { KDU_ERROR_DEV(e,2); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$3[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 223  :         << ": \"" << start << "\".";

	lea	eax, DWORD PTR [ebx-1]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	push	eax
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$5[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$5[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0CO@KGDOBALG@?5characters?5in?5length?$CB?5Problem?5e@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_03NONCDIOG@?3?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 224  :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN9@parse_tran:

; 225  :   buf[i] = '\0';

	mov	eax, DWORD PTR _buf$GSCopy$1$[ebp]

; 226  :   start += i+1;

	inc	esi

; 227  : 
; 228  :   char *end_p;
; 229  : 
; 230  :   value = (int) strtol(start,&end_p,10);

	push	10					; 0000000aH
	add	esi, edi
	mov	BYTE PTR [eax+edi], 0
	lea	eax, DWORD PTR _end_p$[ebp]
	push	eax
	push	esi
	call	DWORD PTR __imp__strtol
	mov	ecx, DWORD PTR _value$GSCopy$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx], eax

; 231  :   if ((end_p == start) ||

	mov	eax, DWORD PTR _end_p$[ebp]
	cmp	eax, esi
	je	SHORT $LN11@parse_tran
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR _separator$[ebp]
	je	SHORT $LN10@parse_tran
	cmp	cl, 41					; 00000029H
	je	SHORT $LN10@parse_tran
	cmp	cl, 93					; 0000005dH
	je	SHORT $LN10@parse_tran
$LN11@parse_tran:

; 233  :     { KDU_ERROR_DEV(e,3); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0IM@FCIPKKGG@String?5translators?5in?5code?9strea@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 233  :     { KDU_ERROR_DEV(e,3); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_03NONCDIOG@?3?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 238  :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error

; 239  :   return(end_p);

	mov	eax, DWORD PTR _end_p$[ebp]
$LN10@parse_tran:

; 240  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?parse_translator_entry@@YAPBDPBDDQADHAAH@Z$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_translator_entry@@YAPBDPBDDQADHAAH@Z$1:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_translator_entry@@YAPBDPBDDQADHAAH@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?parse_translator_entry@@YAPBDPBDDQADHAAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?parse_translator_entry@@YAPBDPBDDQADHAAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?parse_translator_entry@@YAPBDPBDDQADHAAH@Z ENDP	; parse_translator_entry
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?find_lcm@@YAHHH@Z
_TEXT	SEGMENT
_common_part$1$ = -4					; size = 4
_m$ = 8							; size = 4
_n$ = 12						; size = 4
?find_lcm@@YAHHH@Z PROC					; find_lcm, COMDAT

; 164  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi

; 165  :   assert((m > 0) && (n > 0));
; 166  : 
; 167  :   /* The idea is to remove all common factors of m and n from m and
; 168  :      count them only once, in a `common_part'. */
; 169  : 
; 170  :   int common_part = 1;
; 171  :   int divisor = 2;
; 172  :   for (; (divisor <= m) && (divisor <= n); divisor++)

	mov	esi, DWORD PTR _n$[ebp]
	mov	ecx, 2
	push	edi
	mov	edi, DWORD PTR _m$[ebp]
	mov	ebx, 1
	mov	DWORD PTR _common_part$1$[ebp], ebx
	cmp	edi, ecx
	jl	SHORT $LN3@find_lcm
	npad	2
$LL4@find_lcm:
	cmp	ecx, esi
	jg	SHORT $LN18@find_lcm

; 173  :     {
; 174  :       while (((m % divisor) == 0) && ((n % divisor) == 0))

	mov	eax, edi
	cdq
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN2@find_lcm
	npad	3
$LL5@find_lcm:
	mov	eax, esi
	cdq
	idiv	ecx
	mov	ebx, eax
	test	edx, edx
	jne	SHORT $LN2@find_lcm

; 175  :         {
; 176  :           common_part *= divisor;

	mov	eax, ecx

; 177  :           m /= divisor;
; 178  :           n /= divisor;

	mov	esi, ebx
	imul	eax, DWORD PTR _common_part$1$[ebp]
	mov	DWORD PTR _common_part$1$[ebp], eax
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, eax
	cdq
	idiv	ecx
	test	edx, edx
	je	SHORT $LL5@find_lcm
$LN2@find_lcm:

; 165  :   assert((m > 0) && (n > 0));
; 166  : 
; 167  :   /* The idea is to remove all common factors of m and n from m and
; 168  :      count them only once, in a `common_part'. */
; 169  : 
; 170  :   int common_part = 1;
; 171  :   int divisor = 2;
; 172  :   for (; (divisor <= m) && (divisor <= n); divisor++)

	inc	ecx
	cmp	ecx, edi
	jle	SHORT $LL4@find_lcm
$LN18@find_lcm:
	mov	ebx, DWORD PTR _common_part$1$[ebp]
$LN3@find_lcm:

; 179  :         }
; 180  :     }
; 181  :   return m*n*common_part;

	imul	ebx, edi
	pop	edi
	imul	ebx, esi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 182  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?find_lcm@@YAHHH@Z ENDP					; find_lcm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?step_to_eps_mu@@YAXMAAH0@Z
_TEXT	SEGMENT
_e$2 = -40						; size = 20
tv192 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_val$ = 8						; size = 4
_eps$ = 12						; size = 4
_mu$ = 16						; size = 4
?step_to_eps_mu@@YAXMAAH0@Z PROC			; step_to_eps_mu, COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?step_to_eps_mu@@YAXMAAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	xorps	xmm0, xmm0

; 140  :   if (val <= 0.0F)

	comiss	xmm0, DWORD PTR _val$[ebp]
	jb	SHORT $LN5@step_to_ep

; 141  :     { KDU_ERROR_DEV(e,0); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0DM@BIIABMGK@Absolute?5quantization?5step?5sizes@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 141  :     { KDU_ERROR_DEV(e,0); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 144  :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN5@step_to_ep:

; 145  :   for (eps=0; val < 1.0F; eps++)

	mov	esi, DWORD PTR _eps$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	movss	xmm0, DWORD PTR _val$[ebp]
	comiss	xmm1, xmm0
	mov	DWORD PTR [esi], 0
	jbe	SHORT $LN3@step_to_ep
	movss	xmm2, DWORD PTR __real@40000000
	npad	4
$LL4@step_to_ep:
	inc	DWORD PTR [esi]

; 146  :     val *= 2.0F;

	mulss	xmm0, xmm2
	comiss	xmm1, xmm0
	ja	SHORT $LL4@step_to_ep
$LN3@step_to_ep:

; 147  :   mu = (int) floor(0.5F+((val-1.0F)*(1<<11)));

	subss	xmm0, xmm1
	sub	esp, 8
	mulss	xmm0, DWORD PTR __real@45000000
	addss	xmm0, DWORD PTR __real@3f000000
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR tv192[ebp], xmm0
	fld	QWORD PTR tv192[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR _mu$[ebp]
	mov	DWORD PTR [ecx], eax

; 148  :   if (mu >= (1<<11))

	cmp	eax, 2048				; 00000800H
	jl	SHORT $LN6@step_to_ep

; 149  :     { mu = 0; eps--; }

	mov	DWORD PTR [ecx], 0
	dec	DWORD PTR [esi]
$LN6@step_to_ep:

; 150  :   if (eps > 31)

	cmp	DWORD PTR [esi], 31			; 0000001fH
	jle	SHORT $LN7@step_to_ep

; 151  :     { eps = 31; mu = 0; }

	mov	DWORD PTR [esi], 31			; 0000001fH
	mov	DWORD PTR [ecx], 0
$LN7@step_to_ep:

; 152  :   if (eps < 0)

	cmp	DWORD PTR [esi], 0
	jge	SHORT $LN8@step_to_ep

; 153  :     { eps = 0; mu = (1<<11)-1; }

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [ecx], 2047			; 000007ffH
$LN8@step_to_ep:

; 154  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?step_to_eps_mu@@YAXMAAH0@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?step_to_eps_mu@@YAXMAAH0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?step_to_eps_mu@@YAXMAAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?step_to_eps_mu@@YAXMAAH0@Z ENDP			; step_to_eps_mu
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?match_attribute@@YAPAUkd_attribute@@PAU1@PBD@Z
_TEXT	SEGMENT
_list$ = 8						; size = 4
_name$ = 12						; size = 4
?match_attribute@@YAPAUkd_attribute@@PAU1@PBD@Z PROC	; match_attribute, COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 120  :   kd_attribute *scan;
; 121  :   for (scan=list; scan != NULL; scan=scan->next)

	mov	esi, DWORD PTR _list$[ebp]
	mov	eax, esi
	push	edi
	mov	edi, DWORD PTR _name$[ebp]
	test	esi, esi
	je	SHORT $LN25@match_attr
$LL4@match_attr:

; 122  :     if (scan->name == name)

	cmp	DWORD PTR [eax], edi
	je	SHORT $LN1@match_attr

; 120  :   kd_attribute *scan;
; 121  :   for (scan=list; scan != NULL; scan=scan->next)

	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	jne	SHORT $LL4@match_attr

; 123  :       return scan;
; 124  : 
; 125  :   // Direct match of string addresses failed.  Try content-oriented match.
; 126  :   for (scan=list; scan != NULL; scan=scan->next)

	test	esi, esi
	je	SHORT $LN25@match_attr
$LL7@match_attr:

; 127  :     if (strcmp(scan->name,name) == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, edi
$LL21@match_attr:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN22@match_attr
	test	dl, dl
	je	SHORT $LN23@match_attr
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN22@match_attr
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL21@match_attr
$LN23@match_attr:
	xor	eax, eax
	jmp	SHORT $LN24@match_attr
$LN22@match_attr:
	sbb	eax, eax
	or	eax, 1
$LN24@match_attr:
	test	eax, eax
	je	SHORT $LN25@match_attr

; 123  :       return scan;
; 124  : 
; 125  :   // Direct match of string addresses failed.  Try content-oriented match.
; 126  :   for (scan=list; scan != NULL; scan=scan->next)

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL7@match_attr
$LN25@match_attr:

; 128  :       break;
; 129  :   return scan;

	mov	eax, esi
$LN1@match_attr:
	pop	edi
	pop	esi

; 130  : }

	pop	ebp
	ret	0
?match_attribute@@YAPAUkd_attribute@@PAU1@PBD@Z ENDP	; match_attribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params_local.h
;	COMDAT ??_Gkd_attribute@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_attribute@@QAEPAXI@Z PROC			; kd_attribute::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 91   :       { delete[](values); }

	push	DWORD PTR [esi+24]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	40					; 00000028H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_attribute@@QAEPAXI@Z ENDP			; kd_attribute::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?describe@kd_attribute@@QAEXAAVkdu_message@@_N111@Z
_TEXT	SEGMENT
_val$1 = -112						; size = 4
_val$2 = -108						; size = 4
_this$GSCopy$1$ = -104					; size = 4
tv398 = -100						; size = 4
_text$3 = -96						; size = 2
_text$4 = -92						; size = 2
_locators$ = -88					; size = 3
_buf$5 = -84						; size = 80
_buf$6 = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_output$ = 8						; size = 4
_allow_tiles$ = 12					; size = 1
_allow_comps$ = 16					; size = 1
_treat_instances_like_components$ = 20			; size = 1
_include_comments$ = 24					; size = 1
?describe@kd_attribute@@QAEXAAVkdu_message@@_N111@Z PROC ; kd_attribute::describe, COMDAT
; _this$ = ecx

; 672  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _output$[ebp]

; 673  :   char locators[3];
; 674  :   int loc_pos = 0;

	xor	eax, eax
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi

; 675  :   if (allow_tiles)

	cmp	BYTE PTR _allow_tiles$[ebp], al
	je	SHORT $LN11@describe

; 676  :     locators[loc_pos++] = 'T';

	mov	BYTE PTR _locators$[ebp], 84		; 00000054H
	mov	eax, 1
$LN11@describe:

; 677  :   if (allow_comps && !(flags & kdu_params::ALL_COMPONENTS))

	cmp	BYTE PTR _allow_comps$[ebp], 0
	je	SHORT $LN12@describe
	test	BYTE PTR [edi+8], 4
	jne	SHORT $LN12@describe

; 678  :     locators[loc_pos++] = 'C';

	mov	BYTE PTR _locators$[ebp+eax], 67	; 00000043H
	inc	eax
$LN12@describe:

; 679  :   if (treat_instances_like_components)

	cmp	BYTE PTR _treat_instances_like_components$[ebp], 0
	je	SHORT $LN13@describe

; 680  :     locators[loc_pos++] = 'I';

	mov	BYTE PTR _locators$[ebp+eax], 73	; 00000049H
	inc	eax
$LN13@describe:

; 681  :   locators[loc_pos++] = '\0';

	cmp	eax, 3
	jae	$LN109@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 681  :   locators[loc_pos++] = '\0';

	mov	BYTE PTR _locators$[ebp+eax], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	ecx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 681  :   locators[loc_pos++] = '\0';

	inc	eax

; 683  :   if (loc_pos < 2)

	cmp	eax, 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 683  :   if (loc_pos < 2)

	jge	SHORT $LN14@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	push	OFFSET ??_C@_02OAMGPABD@?$DN?$HL?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 685  :   else

	jmp	SHORT $LN106@describe
$LN14@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_03JILILBPJ@?$FL?3?$DM?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _locators$[ebp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]
	push	OFFSET ??_C@_04PONDAPIE@?$DO?$FN?$DN?$HL?$AA@
$LN106@describe:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+8]
	push	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 687  :   for (int fnum=0; fnum < num_fields; fnum++)

	xor	ebx, ebx
	cmp	DWORD PTR [edi+16], ebx
	jle	$LN3@describe
	mov	DWORD PTR tv398[ebp], ebx
$LL4@describe:

; 688  :     {
; 689  :       if (fnum != 0)

	test	ebx, ebx
	je	SHORT $LN16@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	call	DWORD PTR [eax+8]
$LN16@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 691  :       char const *cp = values[fnum].pattern;

	mov	eax, DWORD PTR [edi+24]
	mov	edi, DWORD PTR tv398[ebp]
	mov	edi, DWORD PTR [edi+eax+4]

; 692  :       assert(cp != NULL);
; 693  :       if (*cp == 'I')

	mov	al, BYTE PTR [edi]
	cmp	al, 73					; 00000049H
	jne	SHORT $LN17@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_05GAGDNHHH@?$DMint?$DO?$AA@
	jmp	$LN107@describe
$LN17@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 695  :       else if (*cp == 'B')

	cmp	al, 66					; 00000042H
	jne	SHORT $LN19@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_08KMPCOBIE@?$DMyes?1no?$DO?$AA@
	jmp	$LN107@describe
$LN19@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 697  :       else if (*cp == 'F')

	cmp	al, 70					; 00000046H
	jne	SHORT $LN21@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_07FFCKHLFB@?$DMfloat?$DO?$AA@
	jmp	$LN107@describe
$LN21@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 699  :       else if (*cp == 'C')

	cmp	al, 67					; 00000043H
	jne	SHORT $LN23@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0N@LECANFFL@?$DMcustom?5int?$DO?$AA@
	jmp	$LN107@describe
$LN23@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 701  :       else if (*cp == '(')

	cmp	al, 40					; 00000028H
	jne	SHORT $LN25@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_05BAJLLFH@ENUM?$DM?$AA@
	call	DWORD PTR [eax+8]
$LL7@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 708  :               cp = parse_translator_entry(cp+1,',',buf,80,val);

	lea	eax, DWORD PTR _val$2[ebp]
	push	eax
	push	80					; 00000050H
	lea	eax, DWORD PTR _buf$6[ebp]
	push	eax
	lea	eax, DWORD PTR [edi+1]
	push	44					; 0000002cH
	push	eax
	call	?parse_translator_entry@@YAPBDPBDDQADHAAH@Z ; parse_translator_entry
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	edx, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 708  :               cp = parse_translator_entry(cp+1,',',buf,80,val);

	add	esp, 20					; 00000014H
	mov	edi, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	ecx, esi
	lea	eax, DWORD PTR _buf$6[ebp]
	push	eax
	call	DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 710  :               if (*cp == ',')

	cmp	BYTE PTR [edi], 44			; 0000002cH
	jne	SHORT $LN104@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$4[ebp]
	push	ecx
	mov	ecx, esi
	mov	WORD PTR _text$4[ebp], 44		; 0000002cH
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 712  :             } while (*cp == ',');

	cmp	BYTE PTR [edi], 44			; 0000002cH
	je	SHORT $LL7@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	jmp	SHORT $LN104@describe
$LN25@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 715  :       else if (*cp == '[')

	cmp	al, 91					; 0000005bH
	jne	SHORT $LN2@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_06EDILFCLO@FLAGS?$DM?$AA@
	call	DWORD PTR [eax+8]
$LL10@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 722  :               cp = parse_translator_entry(cp+1,'|',buf,80,val);

	lea	eax, DWORD PTR _val$1[ebp]
	push	eax
	push	80					; 00000050H
	lea	eax, DWORD PTR _buf$5[ebp]
	push	eax
	lea	eax, DWORD PTR [edi+1]
	push	124					; 0000007cH
	push	eax
	call	?parse_translator_entry@@YAPBDPBDDQADHAAH@Z ; parse_translator_entry
	add	esp, 20					; 00000014H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	lea	ecx, DWORD PTR _buf$5[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 722  :               cp = parse_translator_entry(cp+1,'|',buf,80,val);

	mov	edi, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 724  :               if (*cp == '|')

	cmp	BYTE PTR [edi], 124			; 0000007cH
	jne	SHORT $LN104@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$3[ebp]
	push	ecx
	mov	ecx, esi
	mov	WORD PTR _text$3[ebp], 124		; 0000007cH
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 726  :             } while (*cp == '|');

	cmp	BYTE PTR [edi], 124			; 0000007cH
	je	SHORT $LL10@describe
$LN104@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_01PPODPGHN@?$DO?$AA@
$LN107@describe:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+8]
$LN2@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 687  :   for (int fnum=0; fnum < num_fields; fnum++)

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	inc	ebx
	add	DWORD PTR tv398[ebp], 12		; 0000000cH
	cmp	ebx, DWORD PTR [edi+16]
	jl	$LL4@describe
$LN3@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_01CELHOKLL@?$HN?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 732  :   if (flags & kdu_params::MULTI_RECORD)

	test	BYTE PTR [edi+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	ecx, esi
	mov	eax, DWORD PTR [esi]
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 732  :   if (flags & kdu_params::MULTI_RECORD)

	je	SHORT $LN30@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_05MIHDFBBJ@?0?4?4?4?6?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 734  :   else

	jmp	SHORT $LN108@describe
$LN30@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
$LN108@describe:
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 736  :   if (include_comments)

	cmp	BYTE PTR _include_comments$[ebp], 0
	je	SHORT $LN32@describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_01GPOEFGEJ@?7?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	DWORD PTR [edi+4]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR [eax+8]
$LN32@describe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 738  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN109@describe:

; 681  :   locators[loc_pos++] = '\0';

	call	___report_rangecheckfailure
$LN110@describe:
$LN105@describe:
	int	3
?describe@kd_attribute@@QAEXAAVkdu_message@@_N111@Z ENDP ; kd_attribute::describe
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?augment_records@kd_attribute@@QAEXH@Z
_TEXT	SEGMENT
_e$2 = -44						; size = 20
_alloc_records$1$ = -24					; size = 4
tv316 = -20						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_new_records$ = 8					; size = 4
?augment_records@kd_attribute@@QAEXH@Z PROC		; kd_attribute::augment_records, COMDAT
; _this$ = ecx

; 633  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?augment_records@kd_attribute@@QAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 634  :   if (new_records <= num_records)

	mov	ebx, DWORD PTR _new_records$[ebp]
	cmp	ebx, DWORD PTR [edi+20]
	jle	$LN1@augment_re

; 635  :     return;
; 636  :   if (max_records < new_records)

	cmp	DWORD PTR [edi+36], ebx
	jge	$LN15@augment_re

; 637  :     { // Need to allocate more storage.
; 638  :       if (!(flags & kdu_params::MULTI_RECORD))

	test	BYTE PTR [edi+8], 1
	jne	SHORT $LN16@augment_re

; 639  :         { KDU_ERROR_DEV(e,4); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EA@NIBLGMMC@Attempting?5to?5write?5multiple?5rec@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 639  :         { KDU_ERROR_DEV(e,4); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	DWORD PTR [edi]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0CM@EMGKNDJI@?$CC?0?5which?5can?5accept?5only?5single?5@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 644  :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN16@augment_re:

; 645  : 
; 646  :       int alloc_records = max_records + new_records;

	mov	eax, DWORD PTR [edi+36]

; 647  :       att_val *alloc_vals = new att_val[alloc_records*num_fields];

	xor	ecx, ecx
	mov	esi, DWORD PTR [edi+16]
	add	eax, ebx
	imul	esi, eax
	mov	edx, 12					; 0000000cH
	mov	DWORD PTR _alloc_records$1$[ebp], eax
	mov	eax, esi
	mov	DWORD PTR $T3[ebp], esi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T4[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN18@augment_re
	test	esi, esi
	je	SHORT $LN19@augment_re
	add	ecx, 4
	npad	7
$LL31@augment_re:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params_local.h

; 68   :       { is_set = false; pattern=NULL; }

	mov	BYTE PTR [ecx+4], 0
	lea	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx-12], 0
	sub	esi, 1
	jne	SHORT $LL31@augment_re
	mov	ecx, DWORD PTR $T4[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 647  :       att_val *alloc_vals = new att_val[alloc_records*num_fields];

	jmp	SHORT $LN19@augment_re
$LN18@augment_re:
	xor	ecx, ecx
	mov	DWORD PTR $T4[ebp], ecx
$LN19@augment_re:

; 648  :       int rec, fld;
; 649  :       att_val *new_p, *old_p;
; 650  : 
; 651  :       for (new_p=alloc_vals, old_p=values, rec=0; rec < max_records; rec++)

	mov	esi, DWORD PTR [edi+24]
	xor	ebx, ebx
	mov	eax, ecx
	cmp	DWORD PTR [edi+36], ebx
	jle	SHORT $LN3@augment_re
	npad	7
$LL4@augment_re:

; 652  :         for (fld=0; fld < num_fields; fld++)

	xor	edx, edx
	cmp	DWORD PTR [edi+16], edx
	jle	SHORT $LN2@augment_re
$LL7@augment_re:

; 653  :           *(new_p++) = *(old_p++);

	movq	xmm0, QWORD PTR [esi]
	inc	edx
	movq	QWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR [esi+8]
	add	esi, 12					; 0000000cH
	mov	DWORD PTR [eax+8], ecx
	add	eax, 12					; 0000000cH
	cmp	edx, DWORD PTR [edi+16]
	jl	SHORT $LL7@augment_re
$LN2@augment_re:

; 648  :       int rec, fld;
; 649  :       att_val *new_p, *old_p;
; 650  : 
; 651  :       for (new_p=alloc_vals, old_p=values, rec=0; rec < max_records; rec++)

	inc	ebx
	cmp	ebx, DWORD PTR [edi+36]
	jl	SHORT $LL4@augment_re
$LN3@augment_re:

; 654  :       for (; rec < alloc_records; rec++)

	mov	ecx, DWORD PTR _alloc_records$1$[ebp]
	cmp	ebx, ecx
	jge	SHORT $LN9@augment_re
	sub	ecx, ebx
	mov	DWORD PTR tv316[ebp], ecx
$LL10@augment_re:

; 655  :         for (old_p -= num_fields, fld=0; fld < num_fields; fld++)

	mov	edx, DWORD PTR [edi+16]
	xor	ebx, ebx
	lea	ecx, DWORD PTR [edx*4]
	sub	ecx, edx
	neg	ecx
	lea	esi, DWORD PTR [esi+ecx*4]
	test	edx, edx
	jle	SHORT $LN8@augment_re
	npad	6
$LL13@augment_re:

; 656  :           { *new_p = *(old_p++); new_p->is_set = false; new_p++; }

	movq	xmm0, QWORD PTR [esi]
	inc	ebx
	movq	QWORD PTR [eax], xmm0
	mov	ecx, DWORD PTR [esi+8]
	add	esi, 12					; 0000000cH
	mov	DWORD PTR [eax+8], ecx
	mov	BYTE PTR [eax+8], 0
	add	eax, 12					; 0000000cH
	cmp	ebx, DWORD PTR [edi+16]
	jl	SHORT $LL13@augment_re
$LN8@augment_re:

; 654  :       for (; rec < alloc_records; rec++)

	sub	DWORD PTR tv316[ebp], 1
	jne	SHORT $LL10@augment_re
$LN9@augment_re:

; 657  :       delete[] values;

	push	DWORD PTR [edi+24]
	call	??_V@YAXPAX@Z				; operator delete[]

; 658  :       values = alloc_vals;

	mov	eax, DWORD PTR $T4[ebp]
	add	esp, 4
	mov	ebx, DWORD PTR _new_records$[ebp]
	mov	DWORD PTR [edi+24], eax

; 659  :       max_records = alloc_records;

	mov	eax, DWORD PTR _alloc_records$1$[ebp]
	mov	DWORD PTR [edi+36], eax
$LN15@augment_re:

; 660  :     }
; 661  :   num_records = new_records;

	mov	DWORD PTR [edi+20], ebx
$LN1@augment_re:

; 662  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?augment_records@kd_attribute@@QAEXH@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?augment_records@kd_attribute@@QAEXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?augment_records@kd_attribute@@QAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?augment_records@kd_attribute@@QAEXH@Z ENDP		; kd_attribute::augment_records
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params_local.h
;	COMDAT ??1kd_attribute@@QAE@XZ
_TEXT	SEGMENT
??1kd_attribute@@QAE@XZ PROC				; kd_attribute::~kd_attribute, COMDAT
; _this$ = ecx

; 91   :       { delete[](values); }

	push	DWORD PTR [ecx+24]
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
??1kd_attribute@@QAE@XZ ENDP				; kd_attribute::~kd_attribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0kd_attribute@@QAE@PBD0H0@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
$T2 = 8							; size = 4
$T3 = 8							; size = 4
_name$ = 8						; size = 4
_comment$ = 12						; size = 4
_flags$ = 16						; size = 4
_pattern$ = 20						; size = 4
??0kd_attribute@@QAE@PBD0H0@Z PROC			; kd_attribute::kd_attribute, COMDAT
; _this$ = ecx

; 585  : {

	push	ebp
	mov	ebp, esp

; 586  :   char const *ch;
; 587  : 
; 588  :   this->values = NULL;
; 589  :   this->name = name;

	mov	eax, DWORD PTR _name$[ebp]
	push	ebx
	push	esi

; 590  :   this->comment = comment;
; 591  :   this->flags = flags;
; 592  :   this->pattern = pattern;

	mov	esi, DWORD PTR _pattern$[ebp]

; 593  :   for (ch=pattern, num_fields=0; *ch != '\0'; ch++, num_fields++)

	mov	ebx, 93					; 0000005dH
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR _comment$[ebp]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [edi+8], eax
	mov	eax, esi
	mov	DWORD PTR [edi+24], 0
	mov	DWORD PTR [edi+12], esi
	mov	DWORD PTR [edi+16], 0
	mov	cl, BYTE PTR [esi]
	test	cl, cl
	je	SHORT $LN57@kd_attribu
	npad	6
$LL4@kd_attribu:

; 594  :     {
; 595  :       if ((*ch == 'F') || (*ch == 'B') || (*ch == 'I') || (*ch == 'C'))

	cmp	cl, 70					; 00000046H
	je	SHORT $LN2@kd_attribu
	cmp	cl, 66					; 00000042H
	je	SHORT $LN2@kd_attribu
	cmp	cl, 73					; 00000049H
	je	SHORT $LN2@kd_attribu
	cmp	cl, 67					; 00000043H
	je	SHORT $LN2@kd_attribu

; 596  :         continue;
; 597  : 
; 598  :       char term = '\0';

	xor	dl, dl

; 599  :       if (*ch == '(')

	cmp	cl, 40					; 00000028H
	jne	SHORT $LN16@kd_attribu

; 600  :         term = ')';

	mov	dl, 41					; 00000029H
	jmp	SHORT $LN18@kd_attribu
$LN16@kd_attribu:

; 601  :       else if (*ch == '[')

	cmp	cl, 91					; 0000005bH
	movzx	edx, dl
	cmove	edx, ebx
$LN18@kd_attribu:

; 602  :         term = ']';
; 603  :       for (ch++; (*ch != term) && (*ch != '\0'); ch++);

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	cmp	cl, dl
	je	SHORT $LN6@kd_attribu
$LL7@kd_attribu:
	test	cl, cl
	je	$LN60@kd_attribu
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	cmp	cl, dl
	jne	SHORT $LL7@kd_attribu
$LN6@kd_attribu:

; 604  :       if (*ch == '\0')

	cmp	BYTE PTR [eax], 0
	je	$LN60@kd_attribu
$LN2@kd_attribu:

; 593  :   for (ch=pattern, num_fields=0; *ch != '\0'; ch++, num_fields++)

	inc	DWORD PTR [edi+16]
	inc	eax
	mov	cl, BYTE PTR [eax]
	test	cl, cl
	jne	SHORT $LL4@kd_attribu
$LN57@kd_attribu:

; 609  :   this->values = new att_val[max_records*num_fields];

	mov	ebx, DWORD PTR [edi+16]
	xor	ecx, ecx
	mov	eax, ebx
	mov	DWORD PTR [edi+20], 0
	mov	edx, 12					; 0000000cH
	mov	DWORD PTR [edi+36], 1
	mul	edx
	mov	DWORD PTR $T2[ebp], ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN26@kd_attribu
	test	ebx, ebx
	je	SHORT $LN27@kd_attribu
	lea	ecx, DWORD PTR [eax+4]
$LL30@kd_attribu:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params_local.h

; 68   :       { is_set = false; pattern=NULL; }

	mov	BYTE PTR [ecx+4], 0
	lea	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx-12], 0
	sub	ebx, 1
	jne	SHORT $LL30@kd_attribu
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 609  :   this->values = new att_val[max_records*num_fields];

	jmp	SHORT $LN27@kd_attribu
$LN26@kd_attribu:
	xor	eax, eax
$LN27@kd_attribu:
	mov	DWORD PTR [edi+24], eax

; 610  :   for (ch=pattern, num_fields=0; *ch != '\0'; ch++, num_fields++)

	mov	DWORD PTR [edi+16], 0
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN9@kd_attribu
	mov	edx, 93					; 0000005dH
	npad	5
$LL10@kd_attribu:

; 611  :     {
; 612  :       values[num_fields].pattern = ch;

	mov	eax, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [eax+ecx*4+4], esi

; 613  :       if ((*ch == 'F') || (*ch == 'B') || (*ch == 'I') || (*ch == 'C'))

	mov	al, BYTE PTR [esi]
	cmp	al, 70					; 00000046H
	je	SHORT $LN8@kd_attribu
	cmp	al, 66					; 00000042H
	je	SHORT $LN8@kd_attribu
	cmp	al, 73					; 00000049H
	je	SHORT $LN8@kd_attribu
	cmp	al, 67					; 00000043H
	je	SHORT $LN8@kd_attribu

; 614  :         continue;
; 615  :       char term = '\0';

	xor	cl, cl

; 616  :       if (*ch == '(')

	cmp	al, 40					; 00000028H
	jne	SHORT $LN22@kd_attribu

; 617  :         term = ')';

	mov	cl, 41					; 00000029H
	jmp	SHORT $LN24@kd_attribu
$LN22@kd_attribu:

; 618  :       else if (*ch == '[')

	cmp	al, 91					; 0000005bH
	movzx	ecx, cl
	cmove	ecx, edx
$LN24@kd_attribu:

; 619  :         term = ']';
; 620  :       for (ch++; (*ch != term) && (*ch != '\0'); ch++);

	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, cl
	je	SHORT $LN8@kd_attribu
	npad	7
$LL13@kd_attribu:
	test	al, al
	je	SHORT $LN8@kd_attribu
	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, cl
	jne	SHORT $LL13@kd_attribu
$LN8@kd_attribu:

; 610  :   for (ch=pattern, num_fields=0; *ch != '\0'; ch++, num_fields++)

	inc	DWORD PTR [edi+16]
	inc	esi
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LL10@kd_attribu
$LN9@kd_attribu:

; 621  :     }
; 622  :   derived = false;

	mov	WORD PTR [edi+28], 0

; 623  :   parsed = false;
; 624  :   next = NULL;
; 625  : }

	mov	eax, edi
	mov	DWORD PTR [edi+32], 0
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	16					; 00000010H
$LN60@kd_attribu:

; 605  :         throw pattern;

	push	OFFSET __TI2CPAD
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T3[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN61@kd_attribu:
$LN59@kd_attribu:
	int	3
??0kd_attribute@@QAE@PBD0H0@Z ENDP			; kd_attribute::kd_attribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params_local.h
;	COMDAT ??0att_val@@QAE@XZ
_TEXT	SEGMENT
??0att_val@@QAE@XZ PROC					; att_val::att_val, COMDAT
; _this$ = ecx

; 68   :       { is_set = false; pattern=NULL; }

	mov	BYTE PTR [ecx+8], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0att_val@@QAE@XZ ENDP					; att_val::att_val
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??9kdu_coords@@QAE_NABU0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??9kdu_coords@@QAE_NABU0@@Z PROC			; kdu_coords::operator!=, COMDAT
; _this$ = ecx

; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@operator
	xor	al, al
	pop	ebp
	ret	4
$LN3@operator:
	mov	al, 1
	pop	ebp
	ret	4
??9kdu_coords@@QAE_NABU0@@Z ENDP			; kdu_coords::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??Zkdu_coords@@QAE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??Zkdu_coords@@QAE?AU0@ABU0@@Z PROC			; kdu_coords::operator-=, COMDAT
; _this$ = ecx

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx]
	sub	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebp
	ret	8
??Zkdu_coords@@QAE?AU0@ABU0@@Z ENDP			; kdu_coords::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?transpose@kdu_coords@@QAEXXZ
_TEXT	SEGMENT
?transpose@kdu_coords@@QAEXXZ PROC			; kdu_coords::transpose, COMDAT
; _this$ = ecx

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
	ret	0
?transpose@kdu_coords@@QAEXXZ ENDP			; kdu_coords::transpose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_coords@@QAE@HH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
??0kdu_coords@@QAE@HH@Z PROC				; kdu_coords::kdu_coords, COMDAT
; _this$ = ecx

; 210  :     kdu_coords(int x, int y) {this->x=x; this->y=y; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??0kdu_coords@@QAE@HH@Z ENDP				; kdu_coords::kdu_coords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_coords@@QAE@XZ
_TEXT	SEGMENT
??0kdu_coords@@QAE@XZ PROC				; kdu_coords::kdu_coords, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kdu_coords@@QAE@XZ ENDP				; kdu_coords::kdu_coords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ??1kdu_kernels@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kdu_kernels@@QAE@XZ PROC				; kdu_kernels::~kdu_kernels, COMDAT
; _this$ = ecx

; 147  :     ~kdu_kernels() { reset(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kdu_kernels@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	call	?reset@kdu_kernels@@AAEXXZ		; kdu_kernels::reset
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kdu_kernels@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kdu_kernels@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kdu_kernels@@QAE@XZ ENDP				; kdu_kernels::~kdu_kernels
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ??0kdu_kernels@@QAE@XZ
_TEXT	SEGMENT
??0kdu_kernels@@QAE@XZ PROC				; kdu_kernels::kdu_kernels, COMDAT
; _this$ = ecx

; 135  :     kdu_kernels() { clear(); }

	push	esi
	mov	esi, ecx
	call	?clear@kdu_kernels@@AAEXXZ		; kdu_kernels::clear
	mov	eax, esi
	pop	esi
	ret	0
??0kdu_kernels@@QAE@XZ ENDP				; kdu_kernels::kdu_kernels
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ??0kdu_kernel_step_info@@QAE@XZ
_TEXT	SEGMENT
??0kdu_kernel_step_info@@QAE@XZ PROC			; kdu_kernel_step_info::kdu_kernel_step_info, COMDAT
; _this$ = ecx

; 101  :       { support_length = support_min = 0;  downshift = rounding_offset = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0kdu_kernel_step_info@@QAE@XZ ENDP			; kdu_kernel_step_info::kdu_kernel_step_info
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gorg_params@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gorg_params@@UAEPAXI@Z PROC				; org_params::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gorg_params@@UAEPAXI@Z ENDP				; org_params::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1org_params@@UAE@XZ
_TEXT	SEGMENT
??1org_params@@UAE@XZ PROC				; org_params::~org_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1org_params@@UAE@XZ ENDP				; org_params::~org_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?read_marker_segment@org_params@@MAE_NGHQAEH@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_tpart_idx$ = 20					; size = 4
?read_marker_segment@org_params@@MAE_NGHQAEH@Z PROC	; org_params::read_marker_segment, COMDAT
; _this$ = ecx

; 3706 :       { return false; } // No marker segments for ORG parameters

	xor	al, al
	ret	16					; 00000010H
?read_marker_segment@org_params@@MAE_NGHQAEH@Z ENDP	; org_params::read_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?check_marker_segment@org_params@@MAE_NGHQAEAAH@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_c_idx$ = 20						; size = 4
?check_marker_segment@org_params@@MAE_NGHQAEAAH@Z PROC	; org_params::check_marker_segment, COMDAT
; _this$ = ecx

; 3703 :       { return false; } // No marker segments for ORG parameters

	xor	al, al
	ret	16					; 00000010H
?check_marker_segment@org_params@@MAE_NGHQAEAAH@Z ENDP	; org_params::check_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?copy_with_xforms@org_params@@MAEXPAVkdu_params@@HH_N11@Z
_TEXT	SEGMENT
_yes_no$ = -8						; size = 1
_flags$ = -4						; size = 4
_source$ = 8						; size = 4
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_transpose$ = 20					; size = 1
_vflip$ = 24						; size = 1
_hflip$ = 28						; size = 1
?copy_with_xforms@org_params@@MAEXPAVkdu_params@@HH_N11@Z PROC ; org_params::copy_with_xforms, COMDAT
; _this$ = ecx

; 9882 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 9883 :   int flags;
; 9884 :   bool yes_no;
; 9885 :   if (source->get(ORGtparts,0,0,flags,false))

	lea	eax, DWORD PTR _flags$[ebp]
	push	esi
	push	1
	push	1
	push	0
	push	eax
	push	0
	push	0
	mov	esi, ecx
	mov	ecx, DWORD PTR _source$[ebp]
	push	OFFSET ??_C@_09CNLDEMAK@ORGtparts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN2@copy_with_

; 9886 :     set(ORGtparts,0,0,flags);

	push	DWORD PTR _flags$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_09CNLDEMAK@ORGtparts?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN2@copy_with_:

; 9887 :   if (source->get(ORGgen_plt,0,0,yes_no,false))

	mov	ecx, DWORD PTR _source$[ebp]
	lea	eax, DWORD PTR _yes_no$[ebp]
	push	1
	push	1
	push	0
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@DMGGEJHL@ORGgen_plt?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN3@copy_with_

; 9888 :     set(ORGgen_plt,0,0,yes_no);

	push	DWORD PTR _yes_no$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_0L@DMGGEJHL@ORGgen_plt?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN3@copy_with_:
	pop	esi

; 9889 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?copy_with_xforms@org_params@@MAEXPAVkdu_params@@HH_N11@Z ENDP ; org_params::copy_with_xforms
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?new_object@org_params@@MAEPAVkdu_params@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_object@org_params@@MAEPAVkdu_params@@XZ PROC	; org_params::new_object, COMDAT
; _this$ = ecx

; 3698 :     virtual kdu_params *new_object() { return new org_params(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_object@org_params@@MAEPAVkdu_params@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_object
	mov	ecx, eax
	call	??0org_params@@QAE@XZ			; org_params::org_params
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_object:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_object@org_params@@MAEPAVkdu_params@@XZ$0:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?new_object@org_params@@MAEPAVkdu_params@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_object@org_params@@MAEPAVkdu_params@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_object@org_params@@MAEPAVkdu_params@@XZ ENDP	; org_params::new_object
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0org_params@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0org_params@@QAE@XZ PROC				; org_params::org_params, COMDAT
; _this$ = ecx

; 9809 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0org_params@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 9808 :   : kdu_params(ORG_params,true,false,true)

	push	0
	push	0
	push	1
	push	0
	push	1
	push	OFFSET ??_C@_03MNMMELJE@ORG?$AA@
	call	??0kdu_params@@QAE@PBD_N1111@Z		; kdu_params::kdu_params

; 9810 :   define_attribute(ORGtparts,

	push	4
	push	OFFSET ??_C@_0O@PEKBJBJM@?$FLR?$DN1?$HML?$DN2?$HMC?$DN4?$FN?$AA@
	push	OFFSET ??_C@_0DHD@FDALIENE@Controls?5the?5division?5of?5each?5ti@
	push	OFFSET ??_C@_09CNLDEMAK@ORGtparts?$AA@
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7org_params@@6B@
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 9811 :                    "Controls the division of each tile's packets into "
; 9812 :                    "tile-parts.  The attribute consists of one or "
; 9813 :                    "more of the flags, `R', `L' and `C', separated by "
; 9814 :                    "the vertical bar character, `|'.  If the `R' flag is "
; 9815 :                    "supplied, tile-parts will be introduced as necessary "
; 9816 :                    "to ensure that each tile-part consists of packets from "
; 9817 :                    "only one resolution level.  If `L' is supplied, "
; 9818 :                    "tile-parts are introduced as necessary to ensure that "
; 9819 :                    "each tile-part consists of packets from only one "
; 9820 :                    "quality layer.  Similarly, if the `C' flag is supplied, "
; 9821 :                    "each tile-part will consist of packets from only one "
; 9822 :                    "component.  Note that the cost of extra tile-part "
; 9823 :                    "headers will not be taken into account during rate "
; 9824 :                    "control, so that the code-stream may end up being a "
; 9825 :                    "little larger than you expect.\n"
; 9826 :                    "\t\t[By default, tile-part boundaries are "
; 9827 :                    "introduced only as required by the presence of multiple "
; 9828 :                    "\"Porder\" attribute specifications.]",
; 9829 :                    "[R=1|L=2|C=4]",ALL_COMPONENTS);
; 9830 :   define_attribute(ORGgen_plt,

	push	4
	push	OFFSET ??_C@_01HMGJMAIH@B?$AA@
	push	OFFSET ??_C@_0CLF@KMEJMICF@Requests?5the?5insertion?5of?5packet@
	push	OFFSET ??_C@_0L@DMGGEJHL@ORGgen_plt?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 9831 :                    "Requests the insertion of packet length information "
; 9832 :                    "in the header of all tile-parts associated with tiles "
; 9833 :                    "for which this attribute is turned on (has a value of "
; 9834 :                    "\"yes\").  The PLT marker segments written into the "
; 9835 :                    "relevant tile-part headers will hold the lengths of "
; 9836 :                    "those packets which belong to the same tile-part.  Note "
; 9837 :                    "that the cost of any PLT marker segments generated "
; 9838 :                    "as a result of this attribute being enabled will not be "
; 9839 :                    "taken into account during rate allocation.  This means "
; 9840 :                    "that the resulting code-streams will generally be a "
; 9841 :                    "little larger than one might expect; however, this is "
; 9842 :                    "probably a reasonable policy, since the PLT marker "
; 9843 :                    "segments may be removed without losing any information.",
; 9844 :                    "B",ALL_COMPONENTS);
; 9845 :   define_attribute(ORGgen_tlm,

	push	4
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0FAH@DOOOICPM@Requests?5the?5insertion?5of?5TLM?5?$CIt@
	push	OFFSET ??_C@_0L@CIAEHHDE@ORGgen_tlm?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 9846 :                    "Requests the insertion of TLM (tile-part-length) marker "
; 9847 :                    "segments in the main header, to facilitate random access "
; 9848 :                    "to the code-stream.  This attribute takes a single "
; 9849 :                    "integer-valued parameter, which identifies the maximum "
; 9850 :                    "number of tile-parts which will be written to the "
; 9851 :                    "code-stream for each tile.  The reason for including "
; 9852 :                    "this parameter is that space for the TLM information "
; 9853 :                    "must be reserved ahead of time; once the entire "
; 9854 :                    "code-stream has been written the generation machinery "
; 9855 :                    "goes back and overwrites this reserved space with actual "
; 9856 :                    "TLM data.  If the actual number of tile-parts which are "
; 9857 :                    "generate is less than the value supplied here, empty "
; 9858 :                    "tile-parts will be inserted into the code-stream so as "
; 9859 :                    "to use up all of the reserved TLM space.  For this "
; 9860 :                    "reason, you should try to estimate the maximum number "
; 9861 :                    "of tile-parts you will need as accurately as possible, "
; 9862 :                    "noting that the actual value may be hard to determine "
; 9863 :                    "ahead of time if incremental flushing features are to "
; 9864 :                    "be employed.  In any event, no JPEG2000 code-stream may "
; 9865 :                    "have more than 255 tile-parts.  An error will be "
; 9866 :                    "generated at run-time if the declared maximum number "
; 9867 :                    "of tile-parts turns out to be insufficient.  You should "
; 9868 :                    "note that this attribute may be ignored if the "
; 9869 :                    "target device does not support repositioning "
; 9870 :                    "functionality.",
; 9871 :                    "I",ALL_COMPONENTS);
; 9872 : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0org_params@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
__ehhandler$??0org_params@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0org_params@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0org_params@@QAE@XZ ENDP				; org_params::org_params
; Function compile flags: /Ogtp
;	COMDAT ??_Gcrg_params@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gcrg_params@@UAEPAXI@Z PROC				; crg_params::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gcrg_params@@UAEPAXI@Z ENDP				; crg_params::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1crg_params@@UAE@XZ
_TEXT	SEGMENT
??1crg_params@@UAE@XZ PROC				; crg_params::~crg_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1crg_params@@UAE@XZ ENDP				; crg_params::~crg_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?read_marker_segment@crg_params@@MAE_NGHQAEH@Z
_TEXT	SEGMENT
_e$2 = -156						; size = 20
_e$3 = -136						; size = 20
$T4 = -116						; size = 4
$T5 = -112						; size = 4
_num_components$ = -108					; size = 4
_this$GSCopy$1$ = -104					; size = 4
_text$6 = -100						; size = 80
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_tpart_idx$ = 20					; size = 4
?read_marker_segment@crg_params@@MAE_NGHQAEH@Z PROC	; crg_params::read_marker_segment, COMDAT
; _this$ = ecx

; 9763 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], eax

; 9764 :   kdu_byte *bp, *end;
; 9765 : 
; 9766 :   if ((tpart_idx != 0) || (code != KDU_CRG) || (comp_idx >= 0))

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	mov	ecx, DWORD PTR _num_bytes$[ebp]
	mov	esi, DWORD PTR _bytes$[ebp]
	jne	$LN6@read_marke
	mov	edx, 65379				; 0000ff63H
	cmp	WORD PTR _code$[ebp], dx
	jne	$LN6@read_marke
	cmp	DWORD PTR [eax+12], 0
	jge	$LN6@read_marke

; 9768 :   bp = bytes;
; 9769 :   end = bp + num_bytes;

	lea	ebx, DWORD PTR [esi+ecx]

; 9770 : 
; 9771 :   int num_components, c;
; 9772 :   kdu_params *siz = access_cluster(SIZ_params);

	mov	ecx, eax
	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 9773 :   if ((siz == NULL) || !siz->get(Scomponents,0,0,num_components))

	test	eax, eax
	je	SHORT $LN8@read_marke
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _num_components$[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0M@LFKICJFJ@Scomponents?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN8@read_marke:

; 9774 :     assert(0);
; 9775 : 
; 9776 :   try {

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 9777 :     for (c=0; c < num_components; c++)

	xor	edi, edi
$LL4@read_marke:
	cmp	edi, DWORD PTR _num_components$[ebp]
	jge	$LN3@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN19@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T5[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN44@read_marke:
$LN19@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9779 :         set(CRGoffset,c,1,kdu_read(bp,end,2)/((float)(1<<16)));

	sub	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	ecx, 8
	add	ecx, eax
	movd	xmm0, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9779 :         set(CRGoffset,c,1,kdu_read(bp,end,2)/((float)(1<<16)));

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@37800000
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	1
	push	edi
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN26@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T4[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN45@read_marke:
$LN26@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9780 :         set(CRGoffset,c,0,kdu_read(bp,end,2)/((float)(1<<16)));

	sub	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	ecx, 8
	add	ecx, eax
	movd	xmm0, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9780 :         set(CRGoffset,c,0,kdu_read(bp,end,2)/((float)(1<<16)));

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@37800000
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	edi
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	inc	edi
	jmp	$LL4@read_marke
$LN3@read_marke:

; 9781 :       }
; 9782 :     if (bp != end)

	cmp	esi, ebx
	je	$LN17@read_marke

; 9783 :       { KDU_ERROR(e,139);  e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0DF@NCKAKJE@Malformed?5CRG?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9783 :       { KDU_ERROR(e,139);  e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9785 :           << (int)(end-bp) <<

	sub	ebx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	BYTE PTR _e$3[ebp+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	ebx
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$6[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$6[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9787 :       }

	lea	ecx, DWORD PTR _e$3[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN17@read_marke:

; 9794 : 
; 9795 :   return true;

	mov	al, 1
	jmp	SHORT $LN1@read_marke
__catch$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z$0:

; 9790 :     { KDU_ERROR(e,140); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EH@POKFGLCF@Malformed?5CRG?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9790 :     { KDU_ERROR(e,140); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9793 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN17@read_marke
	ret	0
$LN6@read_marke:

; 9767 :     return false;

	xor	al, al
$LN1@read_marke:

; 9796 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN43@read_marke:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z$2:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z$3:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_marker_segment@crg_params@@MAE_NGHQAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_marker_segment@crg_params@@MAE_NGHQAEH@Z ENDP	; crg_params::read_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?check_marker_segment@crg_params@@MAE_NGHQAEAAH@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_c_idx$ = 20						; size = 4
?check_marker_segment@crg_params@@MAE_NGHQAEAAH@Z PROC	; crg_params::check_marker_segment, COMDAT
; _this$ = ecx

; 9751 : {

	push	ebp
	mov	ebp, esp

; 9752 :   c_idx = -1;

	mov	eax, DWORD PTR _c_idx$[ebp]

; 9753 :   return (code == KDU_CRG);

	mov	ecx, 65379				; 0000ff63H
	mov	DWORD PTR [eax], -1
	xor	eax, eax
	cmp	WORD PTR _code$[ebp], cx
	sete	al

; 9754 : }

	pop	ebp
	ret	16					; 00000010H
?check_marker_segment@crg_params@@MAE_NGHQAEAAH@Z ENDP	; crg_params::check_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
_TEXT	SEGMENT
_e$2 = -252						; size = 20
_length$1$ = -232					; size = 4
_out$GSCopy$1$ = -228					; size = 4
_e$3 = -224						; size = 20
_c$1$ = -204						; size = 4
_yoff$1$ = -200						; size = 4
tv306 = -196						; size = 8
tv300 = -196						; size = 8
tv294 = -196						; size = 8
tv288 = -196						; size = 8
_num_components$ = -188					; size = 4
_xoff$ = -184						; size = 4
_yoff$ = -180						; size = 4
_text$4 = -176						; size = 80
_text$5 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_out$ = 8						; size = 4
_last_marked$ = 12					; size = 4
_tpart_idx$ = 16					; size = 4
?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z PROC ; crg_params::write_marker_segment, COMDAT
; _this$ = ecx

; 9693 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 9694 :   int length;
; 9695 :   float xoff, yoff;
; 9696 : 
; 9697 :   if ((tpart_idx != 0) || (comp_idx >= 0))

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	mov	edi, DWORD PTR _out$[ebp]
	mov	DWORD PTR _out$GSCopy$1$[ebp], edi
	jne	$LN6@write_mark
	cmp	DWORD PTR [ebx+12], 0
	jge	$LN6@write_mark

; 9699 :   if (!get(CRGoffset,0,0,yoff))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _yoff$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	$LN6@write_mark

; 9700 :     return 0;
; 9701 :   assert(last_marked == NULL);
; 9702 : 
; 9703 :   int num_components, c;
; 9704 :   kdu_params *siz = access_cluster(SIZ_params);

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	mov	ecx, ebx
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 9705 :   if ((siz == NULL) || !siz->get(Scomponents,0,0,num_components))

	test	eax, eax
	je	SHORT $LN9@write_mark
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _num_components$[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0M@LFKICJFJ@Scomponents?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN9@write_mark:

; 9706 :     assert(0);
; 9707 : 
; 9708 :   length = 4 + 4*num_components;

	mov	eax, DWORD PTR _num_components$[ebp]
	lea	esi, DWORD PTR [eax*4+4]
	mov	DWORD PTR _length$1$[ebp], esi

; 9709 :   if (out == NULL)

	test	edi, edi
	jne	SHORT $LN10@write_mark

; 9710 :     return length;

	mov	eax, esi
	jmp	$LN1@write_mark
$LN10@write_mark:

; 9711 : 
; 9712 :   int acc_length = 0;
; 9713 : 
; 9714 :   acc_length += out->put(KDU_CRG);

	push	65379					; 0000ff63H
	mov	ecx, edi
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 9715 :   acc_length += out->put((kdu_uint16)(length-2));

	lea	eax, DWORD PTR [esi-2]
	mov	ecx, edi
	push	eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 9716 :   for (c=0; c < num_components; c++)

	xor	esi, esi
	mov	DWORD PTR _c$1$[ebp], esi
	cmp	DWORD PTR _num_components$[ebp], esi
	jle	$LN3@write_mark
$LL4@write_mark:

; 9717 :     {
; 9718 :       int x, y;
; 9719 : 
; 9720 :       if (!(get(CRGoffset,c,0,yoff) && get(CRGoffset,c,1,xoff)))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _yoff$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN12@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _xoff$[ebp]
	mov	ecx, ebx
	push	eax
	push	1
	push	esi
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN11@write_mark
$LN12@write_mark:

; 9721 :         { KDU_ERROR_DEV(e,137); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0CP@EMDHCGDH@Component?5registration?5informati@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9721 :         { KDU_ERROR_DEV(e,137); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9723 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN11@write_mark:

; 9724 :       if ((xoff < 0.0F) || (xoff >= 1.0F) || (yoff < 0.0F) || (yoff >= 1.0F))

	movss	xmm0, DWORD PTR _xoff$[ebp]
	xorps	xmm2, xmm2
	comiss	xmm2, xmm0
	ja	SHORT $LN14@write_mark
	movss	xmm3, DWORD PTR __real@3f800000
	comiss	xmm0, xmm3
	jae	SHORT $LN14@write_mark
	movss	xmm1, DWORD PTR _yoff$[ebp]
	comiss	xmm2, xmm1
	movss	DWORD PTR _yoff$1$[ebp], xmm1
	ja	SHORT $LN14@write_mark
	comiss	xmm1, xmm3
	jb	$LN13@write_mark
$LN14@write_mark:

; 9725 :         { KDU_ERROR(e,138); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0CK@GJEKKMBC@Illegal?5component?5registration?5o@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9725 :         { KDU_ERROR(e,138); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	movss	xmm0, DWORD PTR _yoff$[ebp]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);
; 263  :         put_text(text); return *this; }
; 264  :     kdu_message &operator<<(unsigned int val)
; 265  :       { char text[80];
; 266  :         sprintf(text,(mode_hex)?"%x":"%u",val);
; 267  :         put_text(text); return *this; }
; 268  :     kdu_message &operator<<(long val)
; 269  :       { return (*this)<<(int) val; }
; 270  :     kdu_message &operator<<(unsigned long val)
; 271  :       { return (*this)<<(unsigned int) val; }
; 272  :     kdu_message &operator<<(short int val)
; 273  :       { return (*this)<<(int) val; }
; 274  :     kdu_message &operator<<(unsigned short int val)
; 275  :       { return (*this)<<(unsigned int) val; }
; 276  : #ifdef KDU_LONG64
; 277  :     kdu_message &operator<<(kdu_long val)
; 278  :       { // Conveniently prints in decimal with thousands separated by commas
; 279  :         if (val < 0)
; 280  :           { (*this)<<'-'; val = -val; }
; 281  :         kdu_long base = 1;
; 282  :         while ((1000*base) <= val) base *= 1000;
; 283  :         int digits = (int)(val/base);   (*this) << digits;
; 284  :         while (base > 1)
; 285  :           { val -= base*digits;  base /= 1000;  digits = (int)(val/base);
; 286  :             char text[4]; sprintf(text,"%03d",digits); (*this)<<','<<text; }
; 287  :         return (*this);
; 288  :       }
; 289  : #endif
; 290  :     kdu_message &operator<<(float val)
; 291  :       { char text[80]; sprintf(text,"%f",val); put_text(text); return *this; }

	lea	eax, DWORD PTR _text$5[ebp]
	cvtps2pd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR _text$5[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	call	DWORD PTR [eax+8]
	movss	xmm0, DWORD PTR _xoff$[ebp]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);
; 263  :         put_text(text); return *this; }
; 264  :     kdu_message &operator<<(unsigned int val)
; 265  :       { char text[80];
; 266  :         sprintf(text,(mode_hex)?"%x":"%u",val);
; 267  :         put_text(text); return *this; }
; 268  :     kdu_message &operator<<(long val)
; 269  :       { return (*this)<<(int) val; }
; 270  :     kdu_message &operator<<(unsigned long val)
; 271  :       { return (*this)<<(unsigned int) val; }
; 272  :     kdu_message &operator<<(short int val)
; 273  :       { return (*this)<<(int) val; }
; 274  :     kdu_message &operator<<(unsigned short int val)
; 275  :       { return (*this)<<(unsigned int) val; }
; 276  : #ifdef KDU_LONG64
; 277  :     kdu_message &operator<<(kdu_long val)
; 278  :       { // Conveniently prints in decimal with thousands separated by commas
; 279  :         if (val < 0)
; 280  :           { (*this)<<'-'; val = -val; }
; 281  :         kdu_long base = 1;
; 282  :         while ((1000*base) <= val) base *= 1000;
; 283  :         int digits = (int)(val/base);   (*this) << digits;
; 284  :         while (base > 1)
; 285  :           { val -= base*digits;  base /= 1000;  digits = (int)(val/base);
; 286  :             char text[4]; sprintf(text,"%03d",digits); (*this)<<','<<text; }
; 287  :         return (*this);
; 288  :       }
; 289  : #endif
; 290  :     kdu_message &operator<<(float val)
; 291  :       { char text[80]; sprintf(text,"%f",val); put_text(text); return *this; }

	lea	eax, DWORD PTR _text$4[ebp]
	cvtps2pd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR _text$4[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0DA@KDCPJNDM@?$HN?4?5?5Legal?5range?5is?5from?50?40?5to?51@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9729 :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	movss	xmm1, DWORD PTR _yoff$[ebp]
	movss	xmm0, DWORD PTR _xoff$[ebp]
	movss	DWORD PTR _yoff$1$[ebp], xmm1
$LN13@write_mark:

; 9730 :       x = (int) floor(0.5F + xoff * (float)(1<<16));

	mulss	xmm0, DWORD PTR __real@47800000
	sub	esp, 8
	addss	xmm0, DWORD PTR __real@3f000000
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv306[ebp], xmm0
	fld	QWORD PTR tv306[ebp]
	fstp	QWORD PTR [esp]
	call	_floor

; 9731 :       if (x >= (1<<16))
; 9732 :         x = (1<<16) - 1;
; 9733 :       y = (int) floor(0.5F + yoff * (float)(1<<16));

	movss	xmm0, DWORD PTR _yoff$1$[ebp]
	mov	eax, 65535				; 0000ffffH
	mulss	xmm0, DWORD PTR __real@47800000
	fstp	QWORD PTR tv300[ebp]
	cvttsd2si edi, QWORD PTR tv300[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cmp	edi, 65536				; 00010000H
	cmovge	edi, eax
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv294[ebp], xmm0
	fld	QWORD PTR tv294[ebp]
	fstp	QWORD PTR [esp]
	call	_floor

; 9734 :       if (y >= (1<<16))
; 9735 :         y = (1<<16) - 1;
; 9736 :       acc_length += out->put((kdu_uint16) x);

	mov	ecx, DWORD PTR _out$GSCopy$1$[ebp]
	add	esp, 8
	fstp	QWORD PTR tv288[ebp]
	cvttsd2si esi, QWORD PTR tv288[ebp]
	mov	eax, 65535				; 0000ffffH
	push	edi
	cmp	esi, 65536				; 00010000H
	cmovge	esi, eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 9737 :       acc_length += out->put((kdu_uint16) y);

	mov	ecx, DWORD PTR _out$GSCopy$1$[ebp]
	push	esi
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put
	mov	esi, DWORD PTR _c$1$[ebp]
	inc	esi
	mov	DWORD PTR _c$1$[ebp], esi
	cmp	esi, DWORD PTR _num_components$[ebp]
	jl	$LL4@write_mark
$LN3@write_mark:

; 9738 :     }
; 9739 : 
; 9740 :   assert(length == acc_length);
; 9741 :   return length;

	mov	eax, DWORD PTR _length$1$[ebp]
	jmp	SHORT $LN1@write_mark
$LN6@write_mark:

; 9698 :     return 0;

	xor	eax, eax
$LN1@write_mark:

; 9742 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?write_marker_segment@crg_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ENDP ; crg_params::write_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?copy_with_xforms@crg_params@@MAEXPAVkdu_params@@HH_N11@Z
_TEXT	SEGMENT
_target_origin$ = -44					; size = 8
_source_origin$ = -36					; size = 8
_target_canvas$ = -28					; size = 8
_source_canvas$ = -20					; size = 8
tv390 = -12						; size = 4
_fact_x$1$ = -8						; size = 4
_x$ = -4						; size = 4
_source$ = 8						; size = 4
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
tv389 = 20						; size = 4
_transpose$ = 20					; size = 1
_fact_y$1$ = 24						; size = 4
_source_siz$1$ = 24					; size = 4
_vflip$ = 24						; size = 1
_y$ = 28						; size = 4
_hflip$ = 28						; size = 1
?copy_with_xforms@crg_params@@MAEXPAVkdu_params@@HH_N11@Z PROC ; crg_params::copy_with_xforms, COMDAT
; _this$ = ecx

; 9636 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 9637 :   if (vflip || hflip)

	cmp	BYTE PTR _vflip$[ebp], 0
	push	ebx
	mov	ebx, ecx
	jne	$LN5@copy_with_
	cmp	BYTE PTR _hflip$[ebp], 0
	jne	$LN5@copy_with_

; 9640 :       return;
; 9641 :     }
; 9642 : 
; 9643 :   // Start by finding out how the canvas dimensions have been changed
; 9644 :   kdu_params *source_siz = source->access_cluster(SIZ_params);

	push	esi
	push	edi
	mov	edi, DWORD PTR _source$[ebp]
	mov	ecx, edi
	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 9645 :   kdu_params *target_siz = this->access_cluster(SIZ_params);

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	mov	ecx, ebx
	mov	DWORD PTR _source_siz$1$[ebp], eax
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 9648 :   if (!(source_siz->get(Ssize,0,0,source_canvas.y) &&

	mov	ecx, DWORD PTR _source_siz$1$[ebp]
	mov	esi, eax
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _source_canvas$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _source_canvas$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9648 :   if (!(source_siz->get(Ssize,0,0,source_canvas.y) &&

	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _source_canvas$[ebp+4], 0
	mov	DWORD PTR _source_origin$[ebp], 0
	mov	DWORD PTR _source_origin$[ebp+4], 0
	mov	DWORD PTR _target_canvas$[ebp], 0
	mov	DWORD PTR _target_canvas$[ebp+4], 0
	mov	DWORD PTR _target_origin$[ebp], 0
	mov	DWORD PTR _target_origin$[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9648 :   if (!(source_siz->get(Ssize,0,0,source_canvas.y) &&

	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN7@copy_with_
	mov	ecx, DWORD PTR _source_siz$1$[ebp]
	lea	eax, DWORD PTR _source_canvas$[ebp+4]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN7@copy_with_
	mov	ecx, DWORD PTR _source_siz$1$[ebp]
	lea	eax, DWORD PTR _source_origin$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN7@copy_with_
	mov	ecx, DWORD PTR _source_siz$1$[ebp]
	lea	eax, DWORD PTR _source_origin$[ebp+4]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN7@copy_with_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _target_canvas$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN7@copy_with_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _target_canvas$[ebp+4]
	mov	ecx, esi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN7@copy_with_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _target_origin$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN7@copy_with_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _target_origin$[ebp+4]
	mov	ecx, esi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN7@copy_with_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	mov	eax, DWORD PTR _source_canvas$[ebp+4]
	mov	esi, DWORD PTR _source_canvas$[ebp]
	mov	ecx, DWORD PTR _target_canvas$[ebp+4]
	mov	edx, DWORD PTR _target_canvas$[ebp]
	sub	eax, DWORD PTR _source_origin$[ebp+4]
	sub	esi, DWORD PTR _source_origin$[ebp]
	sub	ecx, DWORD PTR _target_origin$[ebp+4]
	sub	edx, DWORD PTR _target_origin$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9659 :   if (transpose)

	cmp	BYTE PTR _transpose$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	mov	DWORD PTR _source_canvas$[ebp+4], eax
	mov	DWORD PTR _source_canvas$[ebp], esi
	mov	DWORD PTR _target_canvas$[ebp+4], ecx
	mov	DWORD PTR _target_canvas$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9659 :   if (transpose)

	je	SHORT $LN8@copy_with_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, esi
	mov	esi, eax
	mov	eax, ecx
	mov	DWORD PTR _source_canvas$[ebp], esi
	mov	ecx, DWORD PTR _target_canvas$[ebp+4]
	mov	DWORD PTR _source_canvas$[ebp+4], eax
$LN8@copy_with_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9661 :   int fact_x = source_canvas.x / target_canvas.x;

	cdq
	idiv	ecx

; 9662 :   int fact_y = source_canvas.y / target_canvas.y;
; 9663 :   assert((fact_x > 0) && (fact_y > 0)); // Actually should be powers of 2
; 9664 : 
; 9665 :   float y, x;
; 9666 :   int n = 0;
; 9667 :   while (source->get(CRGoffset,n,(transpose)?1:0,y,false,false) &&

	push	1
	mov	DWORD PTR _fact_x$1$[ebp], eax
	lea	ecx, DWORD PTR _y$[ebp]
	mov	eax, esi
	xor	esi, esi
	cdq
	idiv	DWORD PTR _target_canvas$[ebp]
	push	esi
	mov	DWORD PTR _fact_y$1$[ebp], eax
	xor	eax, eax
	cmp	BYTE PTR _transpose$[ebp], al
	push	esi
	push	ecx
	setne	al
	mov	ecx, edi
	push	eax
	push	esi
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	mov	DWORD PTR tv390[ebp], eax
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	$LN30@copy_with_
	mov	edi, DWORD PTR _skip_components$[ebp]
	xor	eax, eax
	cmp	BYTE PTR _transpose$[ebp], al
	sete	al
	neg	edi
	mov	DWORD PTR tv389[ebp], eax
$LL2@copy_with_:
	push	1
	push	0
	push	0
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _source$[ebp]
	push	eax
	push	esi
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	$LN3@copy_with_

; 9668 :          source->get(CRGoffset,n,(transpose)?0:1,x,false,false))
; 9669 :     {
; 9670 :       y = y / (float) fact_y;

	movd	xmm0, DWORD PTR _fact_y$1$[ebp]
	movss	xmm2, DWORD PTR _y$[ebp]

; 9671 :       x = x / (float) fact_x;

	movss	xmm1, DWORD PTR _x$[ebp]
	cvtdq2ps xmm0, xmm0
	divss	xmm2, xmm0
	movd	xmm0, DWORD PTR _fact_x$1$[ebp]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _y$[ebp], xmm2
	divss	xmm1, xmm0
	movss	DWORD PTR _x$[ebp], xmm1

; 9672 :       if (n >= skip_components)

	cmp	esi, DWORD PTR _skip_components$[ebp]
	jl	SHORT $LN9@copy_with_

; 9673 :         {
; 9674 :           set(CRGoffset,n-skip_components,0,y);

	cvtps2pd xmm0, xmm2
	sub	esp, 8
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	edi
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	movss	xmm0, DWORD PTR _x$[ebp]

; 9675 :           set(CRGoffset,n-skip_components,1,x);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	push	1
	push	edi
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
$LN9@copy_with_:

; 9662 :   int fact_y = source_canvas.y / target_canvas.y;
; 9663 :   assert((fact_x > 0) && (fact_y > 0)); // Actually should be powers of 2
; 9664 : 
; 9665 :   float y, x;
; 9666 :   int n = 0;
; 9667 :   while (source->get(CRGoffset,n,(transpose)?1:0,y,false,false) &&

	mov	ecx, DWORD PTR _source$[ebp]
	lea	eax, DWORD PTR _y$[ebp]
	push	1
	push	0
	push	0
	push	eax
	push	DWORD PTR tv390[ebp]

; 9676 :         }
; 9677 :       n++;

	inc	esi
	inc	edi
	push	esi
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	mov	eax, DWORD PTR tv389[ebp]
	jne	$LL2@copy_with_
$LN3@copy_with_:

; 9678 :     }
; 9679 :   if ((n > 0) && (n <= skip_components))

	test	esi, esi
	jle	SHORT $LN30@copy_with_
	cmp	esi, DWORD PTR _skip_components$[ebp]
	jg	SHORT $LN30@copy_with_

; 9680 :     { // Copy last actual offsets into the first target component.
; 9681 :       set(CRGoffset,0,0,y);

	movss	xmm0, DWORD PTR _y$[ebp]
	sub	esp, 8
	cvtps2pd xmm0, xmm0
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	movss	xmm0, DWORD PTR _x$[ebp]

; 9682 :       set(CRGoffset,0,1,x);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	push	1
	push	0
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
$LN30@copy_with_:
	pop	edi
	pop	esi
	pop	ebx

; 9683 :     }
; 9684 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN5@copy_with_:

; 9638 :     { // Can't deal with flipping.  Best to destroy any existing information.
; 9639 :       delete_unparsed_attribute(CRGoffset);

	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z ; kdu_params::delete_unparsed_attribute
	pop	ebx

; 9683 :     }
; 9684 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?copy_with_xforms@crg_params@@MAEXPAVkdu_params@@HH_N11@Z ENDP ; crg_params::copy_with_xforms
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?new_object@crg_params@@MAEPAVkdu_params@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_object@crg_params@@MAEPAVkdu_params@@XZ PROC	; crg_params::new_object, COMDAT
; _this$ = ecx

; 3596 :     virtual kdu_params *new_object() { return new crg_params(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_object@crg_params@@MAEPAVkdu_params@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_object
	mov	ecx, eax
	call	??0crg_params@@QAE@XZ			; crg_params::crg_params
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_object:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_object@crg_params@@MAEPAVkdu_params@@XZ$0:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?new_object@crg_params@@MAEPAVkdu_params@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_object@crg_params@@MAEPAVkdu_params@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_object@crg_params@@MAEPAVkdu_params@@XZ ENDP	; crg_params::new_object
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0crg_params@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0crg_params@@QAE@XZ PROC				; crg_params::crg_params, COMDAT
; _this$ = ecx

; 9611 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0crg_params@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 9610 :   : kdu_params(CRG_params,false,false,false)

	push	0
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_03IHBKPECM@CRG?$AA@
	call	??0kdu_params@@QAE@PBD_N1111@Z		; kdu_params::kdu_params

; 9612 :   define_attribute(CRGoffset,

	push	3
	push	OFFSET ??_C@_02NCIKDPBM@FF?$AA@
	push	OFFSET ??_C@_0CHB@BGCOENBE@Provides?5additional?5component?5re@
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7crg_params@@6B@
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 9613 :                    "Provides additional component registration offsets. "
; 9614 :                    "The offsets add to those implied by the canvas "
; 9615 :                    "coordinate system and should only be used when "
; 9616 :                    "canvas coordinates (notably `Ssize', `Soffset' and "
; 9617 :                    "`Ssampling') cannot be found, which adequately reflect "
; 9618 :                    "the relative displacement of the components. Each record "
; 9619 :                    "specifies offsets for one component, with the vertical "
; 9620 :                    "offset appearing first. Offsets must be in the range "
; 9621 :                    "0 (inclusive) to 1 (exclusive) and represent a fraction "
; 9622 :                    "of the relevant component sub-sampling factor (see "
; 9623 :                    "`Ssampling'). The last supplied record is repeated "
; 9624 :                    "as needed to recover offsets for all components. ",
; 9625 :                    "FF",MULTI_RECORD | CAN_EXTRAPOLATE);
; 9626 : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0crg_params@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
__ehhandler$??0crg_params@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0crg_params@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0crg_params@@QAE@XZ ENDP				; crg_params::crg_params
; Function compile flags: /Ogtp
;	COMDAT ??_Gpoc_params@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gpoc_params@@UAEPAXI@Z PROC				; poc_params::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gpoc_params@@UAEPAXI@Z ENDP				; poc_params::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1poc_params@@UAE@XZ
_TEXT	SEGMENT
??1poc_params@@UAE@XZ PROC				; poc_params::~poc_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1poc_params@@UAE@XZ ENDP				; poc_params::~poc_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?read_marker_segment@poc_params@@MAE_NGHQAEH@Z
_TEXT	SEGMENT
_e$2 = -180						; size = 20
_e$3 = -160						; size = 20
_num_records$1$ = -140					; size = 4
$T4 = -136						; size = 4
$T5 = -132						; size = 4
$T6 = -128						; size = 4
$T7 = -124						; size = 4
$T8 = -120						; size = 4
_num_components$ = -116					; size = 4
_component_bytes$1$ = -112				; size = 4
_this$GSCopy$1$ = -108					; size = 4
_bp$ = -104						; size = 4
_text$9 = -100						; size = 80
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_tpart_idx$ = 20					; size = 4
?read_marker_segment@poc_params@@MAE_NGHQAEH@Z PROC	; poc_params::read_marker_segment, COMDAT
; _this$ = ecx

; 9553 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	edi, DWORD PTR _num_bytes$[ebp]

; 9554 :   kdu_byte *bp, *end;
; 9555 :   int num_records, n;
; 9556 : 
; 9557 :   if (code != KDU_POC)

	mov	eax, 65375				; 0000ff5fH
	mov	esi, DWORD PTR _bytes$[ebp]
	cmp	WORD PTR _code$[ebp], ax
	je	SHORT $LN5@read_marke

; 9558 :     return false;

	xor	al, al
	jmp	$LN1@read_marke
$LN5@read_marke:

; 9559 :   bp = bytes;
; 9560 :   end = bp + num_bytes;
; 9561 : 
; 9562 :   int num_components, component_bytes;
; 9563 :   kdu_params *siz = access_cluster(SIZ_params);

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	lea	ebx, DWORD PTR [esi+edi]
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 9564 :   if ((siz == NULL) || !siz->get(Scomponents,0,0,num_components))

	test	eax, eax
	je	SHORT $LN7@read_marke
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _num_components$[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0M@LFKICJFJ@Scomponents?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN7@read_marke:

; 9565 :     assert(0);
; 9566 :   component_bytes = (num_components <= 256)?1:2;

	xor	eax, eax

; 9567 :   
; 9568 :   try {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	cmp	DWORD PTR _num_components$[ebp], 256	; 00000100H
	setg	al
	inc	eax
	mov	DWORD PTR _component_bytes$1$[ebp], eax

; 9569 :     num_records = num_bytes / (1+component_bytes+2+1+component_bytes+1);

	lea	ecx, DWORD PTR [eax*2+5]
	mov	eax, edi
	cdq
	idiv	ecx
	mov	DWORD PTR _num_records$1$[ebp], eax

; 9570 :     if (num_records < 1)

	cmp	eax, 1
	jge	SHORT $LN9@read_marke

; 9571 :       throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR $T8[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN57@read_marke:
$LN9@read_marke:

; 9572 :     for (n=0; n < num_records; n++)

	xor	edi, edi
$LL4@read_marke:
	cmp	edi, eax
	jge	$LN3@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN20@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T7[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN58@read_marke:
$LN20@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9574 :         set(Porder,n,0,kdu_read(bp,end,1));

	push	eax
	push	0
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9574 :         set(Porder,n,0,kdu_read(bp,end,1));

	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	ecx, esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 9575 :         set(Porder,n,1,kdu_read(bp,end,component_bytes));

	push	DWORD PTR _component_bytes$1$[ebp]
	lea	eax, DWORD PTR _bp$[ebp]
	push	ebx
	push	eax
	call	?kdu_read@@YAHAAPAEPAEH@Z		; kdu_read
	add	esp, 12					; 0000000cH
	mov	ecx, esi
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	esi, DWORD PTR _bp$[ebp]
	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN27@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T6[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN59@read_marke:
$LN27@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 93   :   if (nbytes > 1)
; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	ecx, 8
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9576 :         set(Porder,n,2,kdu_read(bp,end,2));

	push	ecx
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	2
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN33@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T5[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN60@read_marke:
$LN33@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9577 :         set(Porder,n,3,kdu_read(bp,end,1));

	push	eax
	push	3
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9577 :         set(Porder,n,3,kdu_read(bp,end,1));

	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	ecx, esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 9578 :         int comp_above = kdu_read(bp,end,component_bytes);

	push	DWORD PTR _component_bytes$1$[ebp]
	lea	eax, DWORD PTR _bp$[ebp]
	push	ebx
	push	eax
	call	?kdu_read@@YAHAAPAEPAEH@Z		; kdu_read
	add	esp, 12					; 0000000cH

; 9579 :         if ((comp_above == 0) && (component_bytes == 1))

	test	eax, eax
	jne	SHORT $LN10@read_marke
	cmp	DWORD PTR _component_bytes$1$[ebp], 1
	mov	ecx, 256				; 00000100H
	cmove	eax, ecx
$LN10@read_marke:

; 9580 :           comp_above = 256;
; 9581 :         set(Porder,n,4,comp_above);

	push	eax
	push	4
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	esi, DWORD PTR _bp$[ebp]
	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN39@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T4[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN61@read_marke:
$LN39@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9582 :         set(Porder,n,5,kdu_read(bp,end,1));

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	eax
	push	5
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	eax, DWORD PTR _num_records$1$[ebp]
	inc	edi
	jmp	$LL4@read_marke
$LN3@read_marke:

; 9583 :       }
; 9584 :     if (bp != end)

	cmp	esi, ebx
	je	SHORT $LN18@read_marke

; 9585 :       { KDU_ERROR(e,135); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0DF@CKFKOFOF@Malformed?5POC?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9585 :       { KDU_ERROR(e,135); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9587 :           << (int)(end-bp) <<

	sub	ebx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	BYTE PTR _e$3[ebp+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	ebx
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$9[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$9[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9589 :       }

	lea	ecx, DWORD PTR _e$3[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN18@read_marke:

; 9596 : 
; 9597 :   return true;

	mov	al, 1
$LN1@read_marke:

; 9598 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
__catch$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z$0:

; 9592 :     { KDU_ERROR(e,136);  e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EH@BLNGGECC@Malformed?5POC?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9592 :     { KDU_ERROR(e,136);  e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9595 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN18@read_marke
	ret	0
$LN56@read_marke:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z$2:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z$3:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-184]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_marker_segment@poc_params@@MAE_NGHQAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_marker_segment@poc_params@@MAE_NGHQAEH@Z ENDP	; poc_params::read_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?check_marker_segment@poc_params@@MAE_NGHQAEAAH@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_c_idx$ = 20						; size = 4
?check_marker_segment@poc_params@@MAE_NGHQAEAAH@Z PROC	; poc_params::check_marker_segment, COMDAT
; _this$ = ecx

; 9541 : {

	push	ebp
	mov	ebp, esp

; 9542 :   c_idx = -1;

	mov	eax, DWORD PTR _c_idx$[ebp]

; 9543 :   return (code == KDU_POC);

	mov	ecx, 65375				; 0000ff5fH
	mov	DWORD PTR [eax], -1
	xor	eax, eax
	cmp	WORD PTR _code$[ebp], cx
	sete	al

; 9544 : }

	pop	ebp
	ret	16					; 00000010H
?check_marker_segment@poc_params@@MAE_NGHQAEAAH@Z ENDP	; poc_params::check_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
_TEXT	SEGMENT
_num_components$ = -444					; size = 4
_val$2 = -440						; size = 4
_val$3 = -436						; size = 4
_val$4 = -432						; size = 4
_e$5 = -428						; size = 20
_profile$ = -408					; size = 4
_length$1$ = -404					; size = 4
_val$6 = -404						; size = 4
_order$ = -400						; size = 4
_res_above$ = -396					; size = 4
_layer_above$ = -392					; size = 4
_component_bytes$1$ = -388				; size = 4
_val$7 = -388						; size = 4
_comp_min$ = -384					; size = 4
_num_records$1$ = -380					; size = 4
_comp_above$ = -376					; size = 4
_res_min$ = -372					; size = 4
_e$8 = -368						; size = 20
_e$9 = -368						; size = 20
_e$10 = -368						; size = 20
_e$11 = -368						; size = 20
_e$12 = -368						; size = 20
_e$13 = -368						; size = 20
_e$14 = -368						; size = 20
_e$15 = -368						; size = 20
_last_marked$GSCopy$1$ = -348				; size = 4
_max_comp_above$1$ = -348				; size = 4
_word$1$ = -344						; size = 4
_word$1$ = -344						; size = 4
_word$1$ = -344						; size = 4
_word$1$ = -344						; size = 4
_value$1$ = -344					; size = 4
_value$1$ = -344					; size = 4
_value$1$ = -344					; size = 4
_value$1$ = -344					; size = 4
_value$1$ = -344					; size = 4
_byte$1$ = -337						; size = 1
_byte$1$ = -337						; size = 1
_byte$1$ = -337						; size = 1
_byte$1$ = -337						; size = 1
_byte$1$ = -337						; size = 1
_text$16 = -336						; size = 80
_text$17 = -256						; size = 80
_text$18 = -176						; size = 80
_text$19 = -176						; size = 80
_text$20 = -96						; size = 80
_text$21 = -96						; size = 80
_text$22 = -96						; size = 80
_text$23 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_out$ = 8						; size = 4
_last_marked$ = 12					; size = 4
_tpart_idx$ = 16					; size = 4
?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z PROC ; poc_params::write_marker_segment, COMDAT
; _this$ = ecx

; 9390 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 432				; 000001b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 9391 :   poc_params *ref = (poc_params *) last_marked;
; 9392 :   int length, num_records, n;
; 9393 :   int res_min, comp_min, layer_above, res_above, comp_above, order;
; 9394 : 
; 9395 :   if (tpart_idx != inst_idx)

	mov	eax, DWORD PTR _tpart_idx$[ebp]
	mov	edi, DWORD PTR _last_marked$[ebp]
	mov	esi, DWORD PTR _out$[ebp]
	mov	DWORD PTR _last_marked$GSCopy$1$[ebp], edi
	cmp	eax, DWORD PTR [ebx+16]
	je	SHORT $LN11@write_mark
$LN203@write_mark:

; 9396 :     return 0;

	xor	eax, eax
	jmp	$LN1@write_mark
$LN11@write_mark:

; 9397 :   for (n=0; get(Porder,n,0,res_min,false); n++);

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _res_min$[ebp]
	mov	DWORD PTR _num_records$1$[ebp], 0
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN3@write_mark
	xor	edi, edi
$LL4@write_mark:
	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _res_min$[ebp]
	inc	edi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL4@write_mark
	mov	DWORD PTR _num_records$1$[ebp], edi
	mov	edi, DWORD PTR _last_marked$GSCopy$1$[ebp]
$LN3@write_mark:

; 9398 :   num_records = n;
; 9399 :   if (num_records == 0)

	cmp	DWORD PTR _num_records$1$[ebp], 0
	je	SHORT $LN203@write_mark

; 9400 :     return 0; // No order information available.
; 9401 :   if ((ref != NULL) && (ref->tile_idx != this->tile_idx))

	test	edi, edi
	je	$LN20@write_mark
	mov	eax, DWORD PTR [ebx+8]
	cmp	DWORD PTR [edi+8], eax
	je	$LN20@write_mark

; 9402 :     { // See if we can skip the marker altogether.
; 9403 :       assert((ref->tile_idx < 0) && (inst_idx == 0));
; 9404 :       kdu_params *next_instance = access_relation(tile_idx,comp_idx,1,true);

	push	1
	push	1
	push	DWORD PTR [ebx+12]
	mov	ecx, ebx
	push	eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 9405 :       if ((next_instance == NULL) || !next_instance->get(Porder,0,0,res_min))

	test	eax, eax
	je	SHORT $LN15@write_mark
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _res_min$[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LN20@write_mark
$LN15@write_mark:

; 9406 :         { /* This is the only instance; otherwise, we would definitely need
; 9407 :              explicit markers for this tile. */
; 9408 :           for (n=0; n < num_records; n++)

	xor	edi, edi
	cmp	DWORD PTR _num_records$1$[ebp], edi
	jle	$LN20@write_mark
$LL7@write_mark:

; 9409 :             {
; 9410 :               if (!(get(Porder,n,0,res_min) && get(Porder,n,1,comp_min) &&

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _res_min$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN17@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _comp_min$[ebp]
	mov	ecx, ebx
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN17@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _layer_above$[ebp]
	mov	ecx, ebx
	push	eax
	push	2
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN17@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _res_above$[ebp]
	mov	ecx, ebx
	push	eax
	push	3
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN17@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _comp_above$[ebp]
	mov	ecx, ebx
	push	eax
	push	4
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN17@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _order$[ebp]
	mov	ecx, ebx
	push	eax
	push	5
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN16@write_mark
$LN17@write_mark:

; 9413 :                 { KDU_ERROR(e,128); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$15[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$15[ebp]
	lea	ecx, DWORD PTR _e$15[ebp]
	push	OFFSET ??_C@_0EM@NECPBKCJ@Information?5required?5to?5write?5PO@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9413 :                 { KDU_ERROR(e,128); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9416 :                 }

	lea	ecx, DWORD PTR _e$15[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN16@write_mark:

; 9417 :               if (!(ref->compare(Porder,n,0,res_min) &&

	mov	eax, DWORD PTR _res_min$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, DWORD PTR _last_marked$GSCopy$1$[ebp]
	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9417 :               if (!(ref->compare(Porder,n,0,res_min) &&

	mov	DWORD PTR _value$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$7[ebp]
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN185@write_mark
	mov	eax, DWORD PTR _value$1$[ebp]
	cmp	DWORD PTR _val$7[ebp], eax
	jne	$LN185@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9417 :               if (!(ref->compare(Porder,n,0,res_min) &&

	mov	eax, DWORD PTR _comp_min$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, DWORD PTR _last_marked$GSCopy$1$[ebp]
	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9417 :               if (!(ref->compare(Porder,n,0,res_min) &&

	mov	DWORD PTR _value$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$4[ebp]
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN185@write_mark
	mov	eax, DWORD PTR _value$1$[ebp]
	cmp	DWORD PTR _val$4[ebp], eax
	jne	$LN185@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9417 :               if (!(ref->compare(Porder,n,0,res_min) &&

	mov	eax, DWORD PTR _layer_above$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, DWORD PTR _last_marked$GSCopy$1$[ebp]
	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9417 :               if (!(ref->compare(Porder,n,0,res_min) &&

	mov	DWORD PTR _value$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$3[ebp]
	push	eax
	push	2
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN185@write_mark
	mov	eax, DWORD PTR _value$1$[ebp]
	cmp	DWORD PTR _val$3[ebp], eax
	jne	$LN185@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9417 :               if (!(ref->compare(Porder,n,0,res_min) &&

	mov	eax, DWORD PTR _res_above$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, DWORD PTR _last_marked$GSCopy$1$[ebp]
	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9417 :               if (!(ref->compare(Porder,n,0,res_min) &&

	mov	DWORD PTR _value$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$2[ebp]
	push	eax
	push	3
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN185@write_mark
	mov	eax, DWORD PTR _value$1$[ebp]
	cmp	DWORD PTR _val$2[ebp], eax
	jne	SHORT $LN185@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9417 :               if (!(ref->compare(Porder,n,0,res_min) &&

	mov	eax, DWORD PTR _comp_above$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, DWORD PTR _last_marked$GSCopy$1$[ebp]
	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9417 :               if (!(ref->compare(Porder,n,0,res_min) &&

	mov	DWORD PTR _value$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$6[ebp]
	push	eax
	push	4
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN185@write_mark
	mov	eax, DWORD PTR _value$1$[ebp]
	cmp	DWORD PTR _val$6[ebp], eax
	jne	SHORT $LN185@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9417 :               if (!(ref->compare(Porder,n,0,res_min) &&

	push	DWORD PTR _order$[ebp]
	mov	ecx, DWORD PTR _last_marked$GSCopy$1$[ebp]
	push	5
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	SHORT $LN185@write_mark

; 9406 :         { /* This is the only instance; otherwise, we would definitely need
; 9407 :              explicit markers for this tile. */
; 9408 :           for (n=0; n < num_records; n++)

	inc	edi
	cmp	edi, DWORD PTR _num_records$1$[ebp]
	jl	$LL7@write_mark
	jmp	SHORT $LN20@write_mark
$LN185@write_mark:

; 9418 :                     ref->compare(Porder,n,1,comp_min) &&
; 9419 :                     ref->compare(Porder,n,2,layer_above) &&
; 9420 :                     ref->compare(Porder,n,3,res_above) &&
; 9421 :                     ref->compare(Porder,n,4,comp_above) &&
; 9422 :                     ref->compare(Porder,n,5,order)))
; 9423 :                 break;
; 9424 :             }
; 9425 :           if (n < num_records)

	cmp	edi, DWORD PTR _num_records$1$[ebp]
	jl	$LN203@write_mark
$LN20@write_mark:

; 9426 :             return 0;
; 9427 :         }
; 9428 :     }
; 9429 : 
; 9430 :   // We are now committed to writing the marker, or at least simulating it.
; 9431 : 
; 9432 :   int num_components, component_bytes, max_comp_above;
; 9433 :   kdu_params *siz = access_cluster(SIZ_params);

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	mov	ecx, ebx
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	edi, eax

; 9434 :   if ((siz == NULL) || !siz->get(Scomponents,0,0,num_components))

	test	edi, edi
	je	SHORT $LN22@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _num_components$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@LFKICJFJ@Scomponents?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN22@write_mark:

; 9435 :     assert(0);
; 9436 :   if (num_components <= 256)

	cmp	DWORD PTR _num_components$[ebp], 256	; 00000100H
	jg	SHORT $LN23@write_mark

; 9437 :     { component_bytes = 1; max_comp_above = 256; }

	mov	DWORD PTR _component_bytes$1$[ebp], 1
	mov	DWORD PTR _max_comp_above$1$[ebp], 256	; 00000100H

; 9438 :   else

	jmp	SHORT $LN24@write_mark
$LN23@write_mark:

; 9439 :     { component_bytes = 2; max_comp_above = 16384; }

	mov	DWORD PTR _component_bytes$1$[ebp], 2
	mov	DWORD PTR _max_comp_above$1$[ebp], 16384 ; 00004000H
$LN24@write_mark:

; 9440 : 
; 9441 :   int profile = 0;

	mov	DWORD PTR _profile$[ebp], 0

; 9442 :   if (siz != NULL)

	test	edi, edi
	je	$LN28@write_mark

; 9443 :     siz->get(Sprofile,0,0,profile);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _profile$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 9444 :   if (profile == Sprofile_CINEMA2K)

	mov	eax, DWORD PTR _profile$[ebp]
	cmp	eax, 4
	jne	SHORT $LN26@write_mark

; 9445 :     { KDU_ERROR(e,0x11110830); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$14[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0MI@GKHFMGFB@Profile?5violation?5detected?4?5?5POC@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9450 :     }

	jmp	SHORT $LN202@write_mark
$LN26@write_mark:

; 9451 :   else if ((profile == Sprofile_CINEMA4K) && (tile_idx >= 0))

	cmp	eax, 5
	jne	SHORT $LN28@write_mark
	cmp	DWORD PTR [ebx+8], 0
	jl	SHORT $LN28@write_mark

; 9452 :     { KDU_ERROR(e,0x11110831); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$13[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0PF@DBCFCBGN@Profile?5violation?5detected?4?5?5POC@
$LN202@write_mark:
	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9458 :     }

	lea	ecx, DWORD PTR _e$13[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN28@write_mark:

; 9459 : 
; 9460 :   length = 4 + num_records*(1 + component_bytes + 2 + 1 + component_bytes + 1);

	mov	eax, DWORD PTR _component_bytes$1$[ebp]
	lea	edi, DWORD PTR [eax*2+5]
	imul	edi, DWORD PTR _num_records$1$[ebp]
	add	edi, 4
	mov	DWORD PTR _length$1$[ebp], edi

; 9461 :   if (out == NULL)

	test	esi, esi
	jne	SHORT $LN29@write_mark

; 9462 :     return length;

	mov	eax, edi
	jmp	$LN1@write_mark
$LN29@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN86@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN86@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN89@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN89@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 95			; 0000005fH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9467 :   acc_length += out->put((kdu_uint16)(length-2));

	lea	eax, DWORD PTR [edi-2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
	inc	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9467 :   acc_length += out->put((kdu_uint16)(length-2));

	movzx	eax, ax
	mov	DWORD PTR [esi+516], ecx
	mov	DWORD PTR _word$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [esi+520]
	jne	SHORT $LN94@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _word$1$[ebp]
$LN94@write_mark:

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, eax

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN97@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN97@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9468 :   for (n=0; n < num_records; n++)

	xor	edi, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR _word$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9468 :   for (n=0; n < num_records; n++)

	cmp	DWORD PTR _num_records$1$[ebp], edi
	jle	$LN9@write_mark
	npad	6
$LL10@write_mark:

; 9469 :     {
; 9470 :       if (!(get(Porder,n,0,res_min) && get(Porder,n,1,comp_min) &&

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _res_min$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN31@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _comp_min$[ebp]
	mov	ecx, ebx
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN31@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _layer_above$[ebp]
	mov	ecx, ebx
	push	eax
	push	2
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN31@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _res_above$[ebp]
	mov	ecx, ebx
	push	eax
	push	3
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN31@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _comp_above$[ebp]
	mov	ecx, ebx
	push	eax
	push	4
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN31@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _order$[ebp]
	mov	ecx, ebx
	push	eax
	push	5
	push	edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN30@write_mark
$LN31@write_mark:

; 9473 :         { KDU_ERROR_DEV(e,129); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$12[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_0EM@NECPBKCJ@Information?5required?5to?5write?5PO@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9473 :         { KDU_ERROR_DEV(e,129); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9476 :         }

	lea	ecx, DWORD PTR _e$12[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN30@write_mark:

; 9477 :       if ((res_min < 0) || (res_min >= 33))

	mov	eax, DWORD PTR _res_min$[ebp]
	test	eax, eax
	js	SHORT $LN33@write_mark
	cmp	eax, 33					; 00000021H
	jl	$LN32@write_mark
$LN33@write_mark:

; 9478 :         { KDU_ERROR(e,130); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$11[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_0BG@CGBIAPKK@Illegal?5lower?5bound?0?5?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9478 :         { KDU_ERROR(e,130); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$11[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _res_min$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$23[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$23[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	eax
	mov	eax, DWORD PTR _e$11[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_0GE@OHOJBMOK@?0?5for?5resolution?5level?5indices?5i@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9482 :         }

	lea	ecx, DWORD PTR _e$11[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN32@write_mark:

; 9483 :       if ((res_above <= res_min) || (res_above > 33))

	mov	eax, DWORD PTR _res_above$[ebp]
	cmp	eax, DWORD PTR _res_min$[ebp]
	jle	SHORT $LN35@write_mark
	cmp	eax, 33					; 00000021H
	jle	$LN34@write_mark
$LN35@write_mark:

; 9484 :         { KDU_ERROR(e,131); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$10[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0CC@GBMHHECB@Illegal?5upper?5bound?5?$CIexclusive?$CJ?0@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9484 :         { KDU_ERROR(e,131); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$10[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _res_above$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$22[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$22[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	eax
	mov	eax, DWORD PTR _e$10[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0HG@EBOPONFH@?0?5for?5resolution?5level?5indices?5i@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9489 :         }

	lea	ecx, DWORD PTR _e$10[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN34@write_mark:

; 9490 :       if ((comp_min < 0) || (comp_min >= max_comp_above))

	mov	ecx, DWORD PTR _comp_min$[ebp]
	test	ecx, ecx
	js	SHORT $LN37@write_mark
	mov	edx, DWORD PTR _max_comp_above$1$[ebp]
	cmp	ecx, edx
	jl	$LN36@write_mark
$LN37@write_mark:

; 9491 :         { KDU_ERROR(e,132); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$9[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0BG@CGBIAPKK@Illegal?5lower?5bound?0?5?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9491 :         { KDU_ERROR(e,132); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$9[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _comp_min$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$21[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$21[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	eax
	mov	eax, DWORD PTR _e$9[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0FK@PKCGAEDD@?0?5for?5component?5indices?5in?5progr@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9495 :             << max_comp_above-1 << ".";

	mov	eax, DWORD PTR _max_comp_above$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9495 :             << max_comp_above-1 << ".";

	dec	eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$9[ebp+4], 0
	push	eax
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$19[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$19[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	eax
	mov	eax, DWORD PTR _e$9[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9496 :         }

	lea	ecx, DWORD PTR _e$9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _comp_min$[ebp]
	mov	edx, DWORD PTR _max_comp_above$1$[ebp]
$LN36@write_mark:

; 9497 :       if ((comp_above <= comp_min) || (comp_above > max_comp_above))

	mov	eax, DWORD PTR _comp_above$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN39@write_mark
	cmp	eax, edx
	jle	$LN38@write_mark
$LN39@write_mark:

; 9498 :         { KDU_ERROR(e,133); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0CC@GBMHHECB@Illegal?5upper?5bound?5?$CIexclusive?$CJ?0@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9498 :         { KDU_ERROR(e,133); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$8[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _comp_above$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$18[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$18[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	eax
	mov	eax, DWORD PTR _e$8[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0GM@ILNCJPIC@?0?5for?5component?5indices?5in?5progr@
	call	DWORD PTR [eax+8]

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$8[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _max_comp_above$1$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$20[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$20[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	eax
	mov	eax, DWORD PTR _e$8[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9504 :         }

	lea	ecx, DWORD PTR _e$8[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _comp_above$[ebp]
$LN38@write_mark:

; 9505 :       if ((layer_above < 0) || (layer_above >= (1<<16)))

	mov	ecx, DWORD PTR _layer_above$[ebp]
	test	ecx, ecx
	js	SHORT $LN41@write_mark
	cmp	ecx, 65536				; 00010000H
	jl	$LN40@write_mark
$LN41@write_mark:

; 9506 :         { KDU_ERROR(e,134); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0CC@GBMHHECB@Illegal?5upper?5bound?5?$CIexclusive?$CJ?0@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9506 :         { KDU_ERROR(e,134); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$5[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _layer_above$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$17[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$17[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	eax
	mov	eax, DWORD PTR _e$5[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0FG@HKJPGEGC@?0?5for?5layer?5indices?5in?5progressi@
	call	DWORD PTR [eax+8]

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$5[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	65535					; 0000ffffH
	push	eax
	lea	eax, DWORD PTR _text$16[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$16[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	eax
	mov	eax, DWORD PTR _e$5[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9511 :         }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _comp_above$[ebp]
$LN40@write_mark:

; 9512 : 
; 9513 :       if ((comp_above >= max_comp_above) && (component_bytes == 1))

	cmp	eax, DWORD PTR _max_comp_above$1$[ebp]
	jl	SHORT $LN42@write_mark
	xor	ecx, ecx
	cmp	DWORD PTR _component_bytes$1$[ebp], 1
	cmove	eax, ecx
	mov	DWORD PTR _comp_above$[ebp], eax
$LN42@write_mark:

; 9514 :         comp_above = 0; // Interpreted as 256
; 9515 : 
; 9516 :       acc_length += out->put((kdu_byte) res_min);

	mov	al, BYTE PTR _res_min$[ebp]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN144@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN144@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9517 :       if (component_bytes == 1)

	cmp	DWORD PTR _component_bytes$1$[ebp], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9517 :       if (component_bytes == 1)

	jne	SHORT $LN43@write_mark

; 9518 :         acc_length += out->put((kdu_byte) comp_min);

	mov	cl, BYTE PTR _comp_min$[ebp]
	mov	BYTE PTR _byte$1$[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN147@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	cl, BYTE PTR _byte$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9519 :       else

	jmp	SHORT $LN147@write_mark
$LN43@write_mark:

; 9520 :         acc_length += out->put((kdu_uint16) comp_min);

	movzx	ecx, WORD PTR _comp_min$[ebp]
	mov	DWORD PTR _word$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN152@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _word$1$[ebp]
$LN152@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN155@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN155@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR _word$1$[ebp]
$LN147@write_mark:
	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9521 :       acc_length += out->put((kdu_uint16) layer_above);

	movzx	ecx, WORD PTR _layer_above$[ebp]
	mov	DWORD PTR _word$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN160@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _word$1$[ebp]
$LN160@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN163@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN163@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR _word$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9522 :       acc_length += out->put((kdu_byte) res_above);

	mov	cl, BYTE PTR _res_above$[ebp]
	mov	BYTE PTR _byte$1$[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN166@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	cl, BYTE PTR _byte$1$[ebp]
$LN166@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9523 :       if (component_bytes == 1)

	cmp	DWORD PTR _component_bytes$1$[ebp], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9523 :       if (component_bytes == 1)

	jne	SHORT $LN45@write_mark

; 9524 :         acc_length += out->put((kdu_byte) comp_above);

	mov	cl, BYTE PTR _comp_above$[ebp]
	mov	BYTE PTR _byte$1$[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN169@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	cl, BYTE PTR _byte$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9525 :       else

	jmp	SHORT $LN169@write_mark
$LN45@write_mark:

; 9526 :         acc_length += out->put((kdu_uint16) comp_above);

	movzx	ecx, WORD PTR _comp_above$[ebp]
	mov	DWORD PTR _word$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN174@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _word$1$[ebp]
$LN174@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN177@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN177@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR _word$1$[ebp]
$LN169@write_mark:
	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9527 :       acc_length += out->put((kdu_byte) order);

	mov	cl, BYTE PTR _order$[ebp]
	mov	BYTE PTR _byte$1$[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN180@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	cl, BYTE PTR _byte$1$[ebp]
$LN180@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9468 :   for (n=0; n < num_records; n++)

	inc	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9468 :   for (n=0; n < num_records; n++)

	cmp	edi, DWORD PTR _num_records$1$[ebp]
	jl	$LL10@write_mark
$LN9@write_mark:

; 9528 :     }
; 9529 : 
; 9530 :   assert(length == acc_length);
; 9531 :   return length;

	mov	eax, DWORD PTR _length$1$[ebp]
$LN1@write_mark:

; 9532 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0:
	lea	ecx, DWORD PTR _e$15[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1:
	lea	ecx, DWORD PTR _e$14[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$2:
	lea	ecx, DWORD PTR _e$13[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$3:
	lea	ecx, DWORD PTR _e$12[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$4:
	lea	ecx, DWORD PTR _e$11[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$5:
	lea	ecx, DWORD PTR _e$10[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$6:
	lea	ecx, DWORD PTR _e$9[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$7:
	lea	ecx, DWORD PTR _e$8[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$8:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-448]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?write_marker_segment@poc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ENDP ; poc_params::write_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?copy_with_xforms@poc_params@@MAEXPAVkdu_params@@HH_N11@Z
_TEXT	SEGMENT
_order$ = -24						; size = 4
_r_lim$ = -20						; size = 4
_layer_lim$ = -16					; size = 4
_r_min$ = -12						; size = 4
_c_min$ = -8						; size = 4
_this$1$ = -4						; size = 4
_c_lim$ = 8						; size = 4
_source$ = 8						; size = 4
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_transpose$ = 20					; size = 1
_vflip$ = 24						; size = 1
_hflip$ = 28						; size = 1
?copy_with_xforms@poc_params@@MAEXPAVkdu_params@@HH_N11@Z PROC ; poc_params::copy_with_xforms, COMDAT
; _this$ = ecx

; 9354 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	edi

; 9355 :   int r_min, c_min, layer_lim, r_lim, c_lim, order;
; 9356 :   if (source->get(Porder,0,0,r_min,false))

	mov	edi, DWORD PTR _source$[ebp]
	lea	eax, DWORD PTR _r_min$[ebp]
	push	1
	push	1
	push	0
	push	eax
	push	0
	push	0
	mov	DWORD PTR _this$1$[ebp], ecx
	mov	ecx, edi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN12@copy_with_

; 9357 :     {
; 9358 :       int n=0;
; 9359 :       while (source->get(Porder,n,0,r_min,false,false) &&
; 9360 :              source->get(Porder,n,1,c_min,false,false) &&
; 9361 :              source->get(Porder,n,2,layer_lim,false,false) &&
; 9362 :              source->get(Porder,n,3,r_lim,false,false) &&
; 9363 :              source->get(Porder,n,4,c_lim,false,false) &&

	push	esi
	push	1
	xor	esi, esi
	lea	eax, DWORD PTR _r_min$[ebp]
	push	esi
	push	esi
	push	eax
	push	esi
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@copy_with_
	push	ebx
	mov	ebx, DWORD PTR _skip_components$[ebp]
$LL2@copy_with_:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _c_min$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN14@copy_with_
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _layer_lim$[ebp]
	mov	ecx, edi
	push	eax
	push	2
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN14@copy_with_
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _r_lim$[ebp]
	mov	ecx, edi
	push	eax
	push	3
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN14@copy_with_
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _c_lim$[ebp]
	mov	ecx, edi
	push	eax
	push	4
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN14@copy_with_
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _order$[ebp]
	mov	ecx, edi
	push	eax
	push	5
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN14@copy_with_

; 9364 :              source->get(Porder,n,5,order,false,false))
; 9365 :         {
; 9366 :           c_min -= skip_components;

	mov	eax, DWORD PTR _c_min$[ebp]

; 9367 :           if (c_min < 0)

	mov	ecx, 0
	sub	eax, ebx
	cmovs	eax, ecx
	mov	DWORD PTR _c_min$[ebp], eax

; 9368 :             c_min = 0;
; 9369 :           c_lim -= skip_components;

	mov	eax, DWORD PTR _c_lim$[ebp]
	sub	eax, ebx
	mov	DWORD PTR _c_lim$[ebp], eax

; 9370 :           if (c_lim < 1)

	cmp	eax, 1
	jge	SHORT $LN6@copy_with_

; 9371 :             { c_lim = 1; layer_lim = 0; }

	mov	DWORD PTR _c_lim$[ebp], 1
	mov	DWORD PTR _layer_lim$[ebp], ecx
$LN6@copy_with_:

; 9372 :           set(Porder,n,0,r_min);

	push	DWORD PTR _r_min$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	0
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 9373 :           set(Porder,n,1,c_min);

	push	DWORD PTR _c_min$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	1
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 9374 :           set(Porder,n,2,layer_lim);

	push	DWORD PTR _layer_lim$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	2
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 9375 :           set(Porder,n,3,r_lim);

	push	DWORD PTR _r_lim$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	3
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 9376 :           set(Porder,n,4,c_lim);

	push	DWORD PTR _c_lim$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	4
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 9377 :           set(Porder,n,5,order);

	push	DWORD PTR _order$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	5
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _r_min$[ebp]

; 9378 :           n++;

	inc	esi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL2@copy_with_
$LN14@copy_with_:
	pop	ebx
$LN13@copy_with_:
	pop	esi
$LN12@copy_with_:
	pop	edi

; 9379 :         }
; 9380 :     }
; 9381 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?copy_with_xforms@poc_params@@MAEXPAVkdu_params@@HH_N11@Z ENDP ; poc_params::copy_with_xforms
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?new_object@poc_params@@MAEPAVkdu_params@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_object@poc_params@@MAEPAVkdu_params@@XZ PROC	; poc_params::new_object, COMDAT
; _this$ = ecx

; 3543 :     virtual kdu_params *new_object() { return new poc_params(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_object@poc_params@@MAEPAVkdu_params@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_object
	mov	ecx, eax
	call	??0poc_params@@QAE@XZ			; poc_params::poc_params
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_object:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_object@poc_params@@MAEPAVkdu_params@@XZ$0:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?new_object@poc_params@@MAEPAVkdu_params@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_object@poc_params@@MAEPAVkdu_params@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_object@poc_params@@MAEPAVkdu_params@@XZ ENDP	; poc_params::new_object
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0poc_params@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0poc_params@@QAE@XZ PROC				; poc_params::poc_params, COMDAT
; _this$ = ecx

; 9317 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0poc_params@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 9316 :   : kdu_params(POC_params,true,false,true)

	push	0
	push	0
	push	1
	push	0
	push	1
	push	OFFSET ??_C@_03LFCEPJHK@POC?$AA@
	call	??0kdu_params@@QAE@PBD_N1111@Z		; kdu_params::kdu_params

; 9318 :   define_attribute(Porder,

	push	1
	push	OFFSET ??_C@_0CK@KBNJDDCF@IIIII?$CILRCP?$DN0?0RLCP?$DN1?0RPCL?$DN2?0PCRL?$DN@
	push	OFFSET ??_C@_0EPM@KNAANCKO@Progression?5order?5change?5informa@
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7poc_params@@6B@
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 9319 :                    "Progression order change information.  The attribute may "
; 9320 :                    "be applied globally (main header), or in a tile-specific "
; 9321 :                    "manner (tile-part header).  In this latter case, multiple "
; 9322 :                    "instances of the attribute may be supplied for any "
; 9323 :                    "given tile, which will force the generation of multiple "
; 9324 :                    "tile-parts for the tile (one for each instance of the "
; 9325 :                    "`Porder' attribute).  As with all attributes, tile "
; 9326 :                    "specific forms are specified by appending a suffix of the "
; 9327 :                    "form \":T<tnum>\" to the attribute name, where <tnum> "
; 9328 :                    "stands for the tile number, starting from 0.  "
; 9329 :                    "Each instance of the attribute may contain one or more "
; 9330 :                    "progression records, each of which defines the order for "
; 9331 :                    "a collection of packets. Each record contains 6 fields. "
; 9332 :                    "The first two fields identify inclusive lower bounds for "
; 9333 :                    "the resolution level and image component indices, "
; 9334 :                    "respectively. The next three fields identify exclusive "
; 9335 :                    "upper bounds for the quality layer, resolution level and "
; 9336 :                    "image component indices, respectively. All indices are "
; 9337 :                    "zero-based, with resolution level 0 corresponding to the "
; 9338 :                    "LL_D subband. The final field in each record identifies "
; 9339 :                    "the progression order to be applied within the indicated "
; 9340 :                    "bounds. This order is applied only to those packets which "
; 9341 :                    "have not already been sequenced by previous records or "
; 9342 :                    "instances.",
; 9343 :                    "IIIII(LRCP=0,RLCP=1,RPCL=2,PCRL=3,CPRL=4)",MULTI_RECORD);
; 9344 : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0poc_params@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
__ehhandler$??0poc_params@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0poc_params@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0poc_params@@QAE@XZ ENDP				; poc_params::poc_params
; Function compile flags: /Ogtp
;	COMDAT ??_Grgn_params@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Grgn_params@@UAEPAXI@Z PROC				; rgn_params::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Grgn_params@@UAEPAXI@Z ENDP				; rgn_params::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1rgn_params@@UAE@XZ
_TEXT	SEGMENT
??1rgn_params@@UAE@XZ PROC				; rgn_params::~rgn_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1rgn_params@@UAE@XZ ENDP				; rgn_params::~rgn_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z
_TEXT	SEGMENT
_e$2 = -64						; size = 20
_e$3 = -44						; size = 20
_e$4 = -44						; size = 20
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_bp$ = 8						; size = 4
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_tpart_idx$ = 20					; size = 4
?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z PROC	; rgn_params::read_marker_segment, COMDAT
; _this$ = ecx

; 9247 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx

; 9248 :   kdu_byte *bp, *end;
; 9249 : 
; 9250 :   if ((tpart_idx != 0) || (code != KDU_RGN) || (comp_idx < 0))

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	jne	$LN3@read_marke
	mov	eax, 65374				; 0000ff5eH
	cmp	WORD PTR _code$[ebp], ax
	jne	$LN3@read_marke
	cmp	DWORD PTR [ebx+12], 0
	jl	$LN3@read_marke

; 9252 :   bp = bytes;

	mov	ecx, DWORD PTR _bytes$[ebp]

; 9253 :   end = bp + num_bytes;
; 9254 : 
; 9255 :   int component_bytes = (get_num_comps() <= 256)?1:2;

	xor	eax, eax
	mov	edi, DWORD PTR _num_bytes$[ebp]
	add	edi, ecx
	mov	DWORD PTR _bp$[ebp], ecx
	cmp	DWORD PTR [ebx+24], 256			; 00000100H

; 9256 : 
; 9257 :   try {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	setg	al
	inc	eax

; 9258 :     int which_comp = kdu_read(bp,end,component_bytes);

	push	eax
	lea	eax, DWORD PTR _bp$[ebp]
	push	edi
	push	eax
	call	?kdu_read@@YAHAAPAEPAEH@Z		; kdu_read
	add	esp, 12					; 0000000cH

; 9259 :     if (which_comp != comp_idx)

	cmp	eax, DWORD PTR [ebx+12]
	jne	$LN3@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	esi, DWORD PTR _bp$[ebp]
	mov	eax, edi
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN19@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T6[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN41@read_marke:
$LN19@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9263 :     if (style != 0)

	test	eax, eax
	je	SHORT $LN6@read_marke

; 9264 :       { KDU_ERROR(e,125); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0CK@MFEGEGLF@Encountered?5non?9Part1?5RGN?5marker@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9264 :       { KDU_ERROR(e,125); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9266 :       }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN6@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN28@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T5[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN42@read_marke:
$LN28@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9267 :     set(Rshift,0,0,kdu_read(bp,end,1));

	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06LDAKCIBF@Rshift?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9267 :     set(Rshift,0,0,kdu_read(bp,end,1));

	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 9268 :     if (bp != end)

	cmp	esi, edi
	je	SHORT $LN15@read_marke

; 9269 :       { KDU_ERROR(e,126); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0DF@HODFHOAP@Malformed?5RGN?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9269 :       { KDU_ERROR(e,126); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9271 :           << (int)(end-bp) <<

	sub	edi, esi
	lea	ecx, DWORD PTR _e$3[ebp]
	push	edi
	call	??6kdu_message@@QAEAAV0@H@Z		; kdu_message::operator<<
	mov	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9273 :       }

	lea	ecx, DWORD PTR _e$3[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN15@read_marke:

; 9280 : 
; 9281 :   return true;

	mov	al, 1

; 9282 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
__catch$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z$0:

; 9276 :     { KDU_ERROR(e,127); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EH@OLOKKCBP@Malformed?5RGN?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9276 :     { KDU_ERROR(e,127); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9279 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN15@read_marke
	ret	0
$LN3@read_marke:

; 9251 :     return false;

	xor	al, al

; 9282 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN40@read_marke:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z$2:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z$3:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z$4:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_marker_segment@rgn_params@@MAE_NGHQAEH@Z ENDP	; rgn_params::read_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?check_marker_segment@rgn_params@@MAE_NGHQAEAAH@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_c_idx$ = 20						; size = 4
?check_marker_segment@rgn_params@@MAE_NGHQAEAAH@Z PROC	; rgn_params::check_marker_segment, COMDAT
; _this$ = ecx

; 9231 : {

	push	ebp
	mov	ebp, esp

; 9232 :   if ((code != KDU_RGN) || (num_bytes < 2))

	mov	eax, 65374				; 0000ff5eH
	push	esi
	mov	esi, ecx
	cmp	WORD PTR _code$[ebp], ax
	jne	SHORT $LN3@check_mark
	cmp	DWORD PTR _num_bytes$[ebp], 2
	jl	SHORT $LN3@check_mark

; 9234 :   c_idx = *(bytes++);

	mov	eax, DWORD PTR _bytes$[ebp]
	mov	edx, DWORD PTR _c_idx$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR [edx], ecx

; 9235 :   if (num_comps > 256)

	cmp	DWORD PTR [esi+24], 256			; 00000100H
	jle	SHORT $LN4@check_mark

; 9236 :     c_idx = (c_idx<<8) + *(bytes++);

	movzx	eax, BYTE PTR [eax+1]
	shl	ecx, 8
	add	eax, ecx
	mov	DWORD PTR [edx], eax
$LN4@check_mark:

; 9237 :   return true;

	mov	al, 1
	pop	esi

; 9238 : }

	pop	ebp
	ret	16					; 00000010H
$LN3@check_mark:

; 9233 :     return false;

	xor	al, al
	pop	esi

; 9238 : }

	pop	ebp
	ret	16					; 00000010H
?check_marker_segment@rgn_params@@MAE_NGHQAEAAH@Z ENDP	; rgn_params::check_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
_TEXT	SEGMENT
_e$2 = -148						; size = 20
_e$3 = -128						; size = 20
_ref_shift$4 = -108					; size = 4
_profile$ = -104					; size = 4
_shift$ = -100						; size = 4
_text$5 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_out$ = 8						; size = 4
_last_marked$ = 12					; size = 4
_tpart_idx$ = 16					; size = 4
?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z PROC ; rgn_params::write_marker_segment, COMDAT
; _this$ = ecx

; 9165 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 9166 :   rgn_params *ref = (rgn_params *) last_marked;
; 9167 :   int length;
; 9168 :   int shift;
; 9169 : 
; 9170 :   if ((tpart_idx != 0) || (comp_idx < 0))

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	mov	esi, DWORD PTR _out$[ebp]
	mov	ebx, DWORD PTR _last_marked$[ebp]
	jne	SHORT $LN3@write_mark
	cmp	DWORD PTR [edi+12], 0
	jl	SHORT $LN3@write_mark

; 9172 : 
; 9173 :   if (!get(Rshift,0,0,shift))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _shift$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06LDAKCIBF@Rshift?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	edx, DWORD PTR _shift$[ebp]
	xor	ecx, ecx
	test	al, al
	cmove	edx, ecx
	mov	DWORD PTR _shift$[ebp], edx

; 9174 :     shift = 0;
; 9175 :   if (ref != NULL)

	test	ebx, ebx
	je	SHORT $LN5@write_mark

; 9176 :     {
; 9177 :       int ref_shift;
; 9178 : 
; 9179 :       if (!ref->get(Rshift,0,0,ref_shift))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _ref_shift$4[ebp]
	push	eax
	push	ecx
	push	ecx
	push	OFFSET ??_C@_06LDAKCIBF@Rshift?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	ecx, DWORD PTR _ref_shift$4[ebp]
	xor	edx, edx
	test	al, al
	cmove	ecx, edx

; 9180 :         ref_shift = 0;
; 9181 :       if (shift == ref_shift)

	mov	edx, DWORD PTR _shift$[ebp]
	cmp	edx, ecx
	jne	SHORT $LN9@write_mark
$LN3@write_mark:

; 9171 :     return 0;

	xor	eax, eax
$LN1@write_mark:

; 9222 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN5@write_mark:

; 9182 :         return 0;
; 9183 :     }
; 9184 :   else if (shift == 0)

	test	edx, edx
	je	SHORT $LN3@write_mark
$LN9@write_mark:

; 9185 :     return 0;
; 9186 : 
; 9187 :   if ((shift > 255) || (shift < 0))

	cmp	edx, 255				; 000000ffH
	jg	SHORT $LN11@write_mark
	test	edx, edx
	jns	SHORT $LN10@write_mark
$LN11@write_mark:

; 9188 :     { KDU_ERROR(e,124); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BH@MGDBKNNO@Illegal?5ROI?5up?9shift?0?5?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9188 :     { KDU_ERROR(e,124); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$3[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _shift$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$5[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$5[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0CA@JLDBBJDK@?4?5Legal?5range?5is?5from?50?5to?5255?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9191 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN10@write_mark:

; 9192 :   kdu_params *siz = access_cluster(SIZ_params);

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	mov	ecx, edi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 9193 :   int profile = 2;

	mov	DWORD PTR _profile$[ebp], 2

; 9194 :   if (siz != NULL)

	test	eax, eax
	je	SHORT $LN13@write_mark

; 9195 :     siz->get(Sprofile,0,0,profile);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _profile$[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 9196 :   if ((profile == Sprofile_CINEMA2K) || (profile == Sprofile_CINEMA4K))

	mov	eax, DWORD PTR _profile$[ebp]
	cmp	eax, 4
	je	SHORT $LN14@write_mark
	cmp	eax, 5
	jne	SHORT $LN13@write_mark
$LN14@write_mark:

; 9197 :     { KDU_ERROR(e,0x1111080a); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0JH@FLFHNCLL@Profile?5violation?5detected?4?5?5RGN@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9197 :     { KDU_ERROR(e,0x1111080a); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9201 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN13@write_mark:

; 9202 : 
; 9203 :   int component_bytes = (get_num_comps() <= 256)?1:2;

	xor	ebx, ebx
	cmp	DWORD PTR [edi+24], 256			; 00000100H
	setg	bl
	inc	ebx

; 9204 :   
; 9205 :   length = 6+component_bytes;

	lea	eax, DWORD PTR [ebx+6]

; 9206 :   if (out == NULL)

	test	esi, esi
	je	$LN1@write_mark

; 9207 :     return length;
; 9208 : 
; 9209 :   int acc_length = 0;
; 9210 : 
; 9211 :   acc_length += out->put(KDU_RGN);

	push	65374					; 0000ff5eH
	mov	ecx, esi
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 9212 :   acc_length += out->put((kdu_uint16)(length-2));

	lea	eax, DWORD PTR [ebx+4]
	mov	ecx, esi
	push	eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 9213 :   if (component_bytes == 1)
; 9214 :     acc_length += out->put((kdu_byte) comp_idx);

	mov	ecx, esi
	cmp	ebx, 1
	jne	SHORT $LN16@write_mark
	movzx	eax, BYTE PTR [edi+12]
	push	eax
	call	?put@kdu_output@@QAEHE@Z		; kdu_output::put

; 9215 :   else

	jmp	SHORT $LN17@write_mark
$LN16@write_mark:

; 9216 :     acc_length += out->put((kdu_uint16) comp_idx);

	movzx	eax, WORD PTR [edi+12]
	push	eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put
$LN17@write_mark:

; 9217 :   acc_length += out->put((kdu_byte) 0);

	push	0
	mov	ecx, esi
	call	?put@kdu_output@@QAEHE@Z		; kdu_output::put

; 9218 :   acc_length += out->put((kdu_byte) shift);

	push	DWORD PTR _shift$[ebp]
	mov	ecx, esi
	call	?put@kdu_output@@QAEHE@Z		; kdu_output::put

; 9219 : 
; 9220 :   assert(length == acc_length);
; 9221 :   return length;

	lea	eax, DWORD PTR [ebx+6]
	jmp	$LN1@write_mark
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?write_marker_segment@rgn_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ENDP ; rgn_params::write_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?copy_with_xforms@rgn_params@@MAEXPAVkdu_params@@HH_N11@Z
_TEXT	SEGMENT
_shift$ = -4						; size = 4
_source$ = 8						; size = 4
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_transpose$ = 20					; size = 1
_vflip$ = 24						; size = 1
_hflip$ = 28						; size = 1
?copy_with_xforms@rgn_params@@MAEXPAVkdu_params@@HH_N11@Z PROC ; rgn_params::copy_with_xforms, COMDAT
; _this$ = ecx

; 9152 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 9153 :   int shift;
; 9154 :   if (source->get(Rshift,0,0,shift,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _shift$[ebp]
	mov	esi, ecx
	mov	ecx, DWORD PTR _source$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06LDAKCIBF@Rshift?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN2@copy_with_

; 9155 :     set(Rshift,0,0,shift);

	push	DWORD PTR _shift$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_06LDAKCIBF@Rshift?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN2@copy_with_:
	pop	esi

; 9156 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?copy_with_xforms@rgn_params@@MAEXPAVkdu_params@@HH_N11@Z ENDP ; rgn_params::copy_with_xforms
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?new_object@rgn_params@@MAEPAVkdu_params@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_object@rgn_params@@MAEPAVkdu_params@@XZ PROC	; rgn_params::new_object, COMDAT
; _this$ = ecx

; 3486 :     virtual kdu_params *new_object() { return new rgn_params(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_object@rgn_params@@MAEPAVkdu_params@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_object
	mov	ecx, eax
	call	??0rgn_params@@QAE@XZ			; rgn_params::rgn_params
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_object:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_object@rgn_params@@MAEPAVkdu_params@@XZ$0:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?new_object@rgn_params@@MAEPAVkdu_params@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_object@rgn_params@@MAEPAVkdu_params@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_object@rgn_params@@MAEPAVkdu_params@@XZ ENDP	; rgn_params::new_object
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?finalize@rgn_params@@MAEX_N@Z
_TEXT	SEGMENT
_w$2 = -120						; size = 20
_val$ = -100						; size = 4
_text$3 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_after_reading$ = 8					; size = 1
?finalize@rgn_params@@MAEX_N@Z PROC			; rgn_params::finalize, COMDAT
; _this$ = ecx

; 9290 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?finalize@rgn_params@@MAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 9291 :   if (after_reading)

	cmp	BYTE PTR _after_reading$[ebp], 0
	jne	$LN4@finalize

; 9292 :     return;
; 9293 : 
; 9294 :   int val;
; 9295 :   if (!get(Rlevels,0,0,val))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07KGEEGGHK@Rlevels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN3@finalize

; 9296 :     set(Rlevels,0,0,4); // Default is 4 DWT levels of ROI mask propagation.

	push	4
	push	0
	push	0
	push	OFFSET ??_C@_07KGEEGGHK@Rlevels?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN3@finalize:

; 9297 :   if (get(Rshift,0,0,val) && (val > 37))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06LDAKCIBF@Rshift?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN4@finalize
	cmp	DWORD PTR _val$[ebp], 37		; 00000025H
	jle	SHORT $LN4@finalize

; 9298 :     { KDU_WARNING(w,8); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$2[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$2[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	OFFSET ??_C@_0HN@DAMJBHKE@Up?9shift?5values?5in?5the?5RGN?5marke@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9298 :     { KDU_WARNING(w,8); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _w$2[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _val$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$3[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$3[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	eax
	mov	eax, DWORD PTR _w$2[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$2[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	OFFSET ??_C@_0CD@DOBDENMB@?5in?5this?5case?0?5may?5cause?5problem@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9303 :     }

	lea	ecx, DWORD PTR _w$2[ebp]
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN4@finalize:

; 9304 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?finalize@rgn_params@@MAEX_N@Z$0:
	lea	ecx, DWORD PTR _w$2[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__ehhandler$?finalize@rgn_params@@MAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?finalize@rgn_params@@MAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?finalize@rgn_params@@MAEX_N@Z ENDP			; rgn_params::finalize
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0rgn_params@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0rgn_params@@QAE@XZ PROC				; rgn_params::rgn_params, COMDAT
; _this$ = ecx

; 9101 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0rgn_params@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 9100 :   : kdu_params(RGN_params,true,true,false,true)

	push	0
	push	1
	push	0
	push	1
	push	1
	push	OFFSET ??_C@_03KEJABOAE@RGN?$AA@
	call	??0kdu_params@@QAE@PBD_N1111@Z		; kdu_params::kdu_params

; 9102 :   define_attribute(Rshift,

	push	0
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0CHI@HKJBINKE@Region?5of?5interest?5up?9shift?5valu@
	push	OFFSET ??_C@_06LDAKCIBF@Rshift?$AA@
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7rgn_params@@6B@
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 9103 :                    "Region of interest up-shift value.  All subband samples "
; 9104 :                    "which are involved in the synthesis of any image sample "
; 9105 :                    "which belongs to the foreground region of an ROI mask "
; 9106 :                    "will be effectively shifted up (scaled by two the power "
; 9107 :                    "of this shift value) prior to quantization.  The "
; 9108 :                    "region geometry is specified independently and is not "
; 9109 :                    "explicitly signalled through the code-stream; instead, "
; 9110 :                    "this shift must be sufficiently large to enable the "
; 9111 :                    "decoder to separate the foreground and background "
; 9112 :                    "on the basis of the shifted sample amplitudes alone.  "
; 9113 :                    "You will receive an appropriate error message if the "
; 9114 :                    "shift value is too small.\n"
; 9115 :                    "\t\t[Default is 0]",
; 9116 :                    "I");
; 9117 :   define_attribute(Rlevels,

	push	0
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0BBM@FGPIIKPE@Number?5of?5initial?5?$CIhighest?5frequ@
	push	OFFSET ??_C@_07KGEEGGHK@Rlevels?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 9118 :                    "Number of initial (highest frequency) DWT levels through "
; 9119 :                    "which to propagate geometric information concerning the "
; 9120 :                    "foreground region for ROI processing.  Additional "
; 9121 :                    "levels (i.e., lower frequency subbands) will be treated "
; 9122 :                    "as belonging entirely to the foreground region.\n"
; 9123 :                    "\t\t[Default is 4]",
; 9124 :                    "I");
; 9125 :   define_attribute(Rweight,

	push	0
	push	OFFSET ??_C@_01BIAFAFID@F?$AA@
	push	OFFSET ??_C@_0DBK@IHBAFPAL@Region?5of?5interest?5significance?5@
	push	OFFSET ??_C@_07MDGMFIIN@Rweight?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 9126 :                    "Region of interest significance weight.  Although this "
; 9127 :                    "attribute may be used together with `Rshift', it is "
; 9128 :                    "common to use only one or the other.  All code-blocks "
; 9129 :                    "whose samples contribute in any way to the reconstruction "
; 9130 :                    "of the foreground region of an ROI mask will have their "
; 9131 :                    "distortion metrics scaled by the square of the supplied "
; 9132 :                    "weighting factor, for the purpose of rate allocation.  "
; 9133 :                    "This renders such blocks more important and assigns to "
; 9134 :                    "them relatively more bits, in a manner which "
; 9135 :                    "is closely related to the effect of the `Clevel_weights' "
; 9136 :                    "and `Cband_weights' attributes on the importance of "
; 9137 :                    "whole subbands.  Note that this region weighting "
; 9138 :                    "strategy is most effective when working with large "
; 9139 :                    "images and relatively small code-blocks (or precincts).\n"
; 9140 :                    "\t\t[Default is 1, i.e., no extra weighting]",
; 9141 :                    "F");
; 9142 : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0rgn_params@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
__ehhandler$??0rgn_params@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0rgn_params@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0rgn_params@@QAE@XZ ENDP				; rgn_params::rgn_params
; Function compile flags: /Ogtp
;	COMDAT ??_Gqcd_params@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gqcd_params@@UAEPAXI@Z PROC				; qcd_params::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gqcd_params@@UAEPAXI@Z ENDP				; qcd_params::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1qcd_params@@UAE@XZ
_TEXT	SEGMENT
??1qcd_params@@UAE@XZ PROC				; qcd_params::~qcd_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1qcd_params@@UAE@XZ ENDP				; qcd_params::~qcd_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z
_TEXT	SEGMENT
_e$2 = -176						; size = 20
_end$ = -156						; size = 4
$T3 = -152						; size = 4
$T4 = -148						; size = 4
$T5 = -144						; size = 4
$T6 = -140						; size = 4
_e$7 = -136						; size = 20
_e$8 = -136						; size = 20
_w$9 = -136						; size = 20
_this$GSCopy$1$ = -116					; size = 4
_reversible$10 = -109					; size = 1
_bp$ = -108						; size = 4
_style$1$ = -104					; size = 4
_derived$11 = -104					; size = 1
_profile$12 = -104					; size = 4
_text$13 = -100						; size = 80
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_tpart_idx$ = 20					; size = 4
?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z PROC	; qcd_params::read_marker_segment, COMDAT
; _this$ = ecx

; 8807 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi

; 8808 :   kdu_byte *bp, *end;
; 8809 : 
; 8810 :   if (tpart_idx != 0)

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	mov	eax, DWORD PTR _num_bytes$[ebp]
	mov	esi, DWORD PTR _bytes$[ebp]
	jne	SHORT $LN85@read_marke

; 8811 :     return false;
; 8812 :   bp = bytes;
; 8813 :   end = bp + num_bytes;
; 8814 :   if (comp_idx < 0)

	mov	edx, DWORD PTR [edi+12]
	lea	ebx, DWORD PTR [esi+eax]
	mov	DWORD PTR _bp$[ebp], esi
	mov	DWORD PTR _end$[ebp], ebx
	test	edx, edx
	jns	SHORT $LN9@read_marke

; 8815 :     { // Need QCD for success
; 8816 :       if (code != KDU_QCD)

	mov	eax, 65372				; 0000ff5cH
	cmp	WORD PTR _code$[ebp], ax
	je	SHORT $LN15@read_marke
$LN85@read_marke:

; 8817 :         return false;

	xor	al, al
	jmp	$LN1@read_marke
$LN9@read_marke:

; 8818 :     }
; 8819 :   else
; 8820 :     { // Need QCC for success
; 8821 :       int which_comp;
; 8822 : 
; 8823 :       if (code != KDU_QCC)

	mov	eax, 65373				; 0000ff5dH
	cmp	WORD PTR _code$[ebp], ax
	jne	SHORT $LN85@read_marke

; 8824 :         return false;
; 8825 :       if (get_num_comps() <= 256)

	cmp	DWORD PTR [edi+24], 256			; 00000100H

; 8826 :         which_comp = *(bp++);

	movzx	ecx, BYTE PTR [esi]
	jg	SHORT $LN13@read_marke
	inc	esi

; 8827 :       else

	jmp	SHORT $LN84@read_marke
$LN13@read_marke:

; 8828 :         { which_comp = *(bp++); which_comp = (which_comp<<8) + *(bp++); }

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax
	add	esi, 2
$LN84@read_marke:
	mov	DWORD PTR _bp$[ebp], esi

; 8829 :       if (which_comp != comp_idx)

	cmp	ecx, edx
	je	SHORT $LN15@read_marke

; 8830 :         return false;

	xor	al, al
	jmp	$LN1@read_marke
$LN15@read_marke:

; 8831 :     }
; 8832 : 
; 8833 :   if (tile_idx >= 0)

	cmp	DWORD PTR [edi+8], 0
	jl	$LN17@read_marke

; 8834 :     { // Check for profile compatibility.
; 8835 :       kdu_params *siz = access_cluster(SIZ_params);

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	mov	ecx, edi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 8836 :       assert(siz != NULL);
; 8837 :       int profile = 2; siz->get(Sprofile,0,0,profile);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _profile$12[ebp]
	mov	DWORD PTR _profile$12[ebp], 2
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 8838 :       if (profile == 0)

	cmp	DWORD PTR _profile$12[ebp], 0
	jne	SHORT $LN17@read_marke

; 8839 :         { KDU_WARNING(w,5); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$9[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$9[ebp]
	lea	ecx, DWORD PTR _w$9[ebp]
	push	OFFSET ??_C@_0NK@HGFFBJED@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8839 :         { KDU_WARNING(w,5); w <<

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8844 :             << tile_idx << ".";

	push	DWORD PTR [edi+8]
	lea	ecx, DWORD PTR _w$9[ebp]
	call	??6kdu_message@@QAEAAV0@H@Z		; kdu_message::operator<<
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	mov	ecx, eax
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8845 :         }

	lea	ecx, DWORD PTR _w$9[ebp]
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN17@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8848 :   try {

	mov	DWORD PTR __$EHRec$[ebp+12], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN46@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T6[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN86@read_marke:
$LN46@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8853 :       set(Qguard,0,0,(style>>5));

	mov	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _style$1$[ebp], eax
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8853 :       set(Qguard,0,0,(style>>5));

	sar	eax, 5
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06BGIMBACE@Qguard?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8853 :       set(Qguard,0,0,(style>>5));

	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 8854 :       style &= 31;

	mov	eax, DWORD PTR _style$1$[ebp]
	and	eax, 31					; 0000001fH

; 8855 :       if (style == 0)

	je	$LN80@read_marke

; 8856 :         { reversible = true; derived = false; }
; 8857 :       else if (style == 1)

	cmp	eax, 1
	jne	SHORT $LN21@read_marke

; 8858 :         { reversible = false; derived = true; }

	mov	BYTE PTR _derived$11[ebp], al
	jmp	SHORT $LN81@read_marke
$LN21@read_marke:

; 8859 :       else if (style == 2)

	cmp	eax, 2
	jne	SHORT $LN23@read_marke

; 8860 :         { reversible = false; derived = false; }

	mov	BYTE PTR _derived$11[ebp], 0

; 8861 :       else

	jmp	SHORT $LN81@read_marke
$LN23@read_marke:

; 8862 :         { KDU_ERROR(e,120); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0DG@NCOMABPP@Undefined?5style?5byte?5found?5in?5QC@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8862 :         { KDU_ERROR(e,120); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8865 :         }

	lea	ecx, DWORD PTR _e$8[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error

; 8866 :       if (!reversible)

	cmp	BYTE PTR _reversible$10[ebp], 0
	jne	$LN80@read_marke
$LN81@read_marke:

; 8867 :         set(Qderived,0,0,derived);

	push	DWORD PTR _derived$11[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 8871 :       else
; 8872 :         for (n=0; bp < (end-1); n++)

	xor	edi, edi
$LL7@read_marke:
	lea	eax, DWORD PTR [ebx-1]
	cmp	esi, eax
	jae	$LN6@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN61@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T5[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN87@read_marke:
$LN61@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8882 :             set(Qabs_steps,n,0,step);

	sub	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	ecx, 8
	add	ecx, eax
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8878 :             mu = val & ((1<<11)-1);

	mov	eax, ecx

; 8879 :             eps = val >> 11;

	sar	ecx, 11					; 0000000bH
	and	eax, 2047				; 000007ffH
	movd	xmm1, eax

; 8880 :             step = ((float) mu) / ((float)(1<<11)) + 1.0F;
; 8881 :             step = step / ((float)(1<<eps));

	mov	eax, 1
	cvtdq2ps xmm1, xmm1
	shl	eax, cl

; 8882 :             set(Qabs_steps,n,0,step);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	movd	xmm0, eax
	mulss	xmm1, DWORD PTR __real@3a000000
	cvtdq2ps xmm0, xmm0
	addss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	cvtps2pd xmm0, xmm1
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	edi
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	inc	edi
	jmp	$LL7@read_marke
$LN80@read_marke:

; 8868 :       if (reversible)
; 8869 :         for (n=0; bp < end; n++)

	xor	edi, edi
$LL4@read_marke:
	cmp	esi, ebx
	jae	SHORT $LN6@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN55@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T4[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN88@read_marke:
$LN55@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8870 :           set(Qabs_ranges,n,0,kdu_read(bp,end,1)>>3);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	sar	eax, 3
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8870 :           set(Qabs_ranges,n,0,kdu_read(bp,end,1)>>3);

	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	inc	edi
	jmp	SHORT $LL4@read_marke
$LN6@read_marke:

; 8883 :           }
; 8884 :         if (n < 1)

	cmp	edi, 1
	jge	SHORT $LN28@read_marke

; 8885 :           throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T3[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN89@read_marke:
__catch$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z$0:

; 8888 :     { KDU_ERROR(e,122); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$7[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_0EL@LJBJPKLN@Malformed?5QCD?1QCC?5marker?5segment@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8888 :     { KDU_ERROR(e,122); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8891 :     }

	lea	ecx, DWORD PTR _e$7[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN38@read_marke
	ret	0
$LN38@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
	mov	esi, DWORD PTR _bp$[ebp]
	mov	ebx, DWORD PTR _end$[ebp]
$LN28@read_marke:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8892 : 
; 8893 :   if (bp != end)

	cmp	esi, ebx
	je	$LN29@read_marke

; 8894 :     { KDU_ERROR(e,121); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0DJ@EBJLBPEO@Malformed?5QCD?1QCC?5marker?5segment@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8894 :     { KDU_ERROR(e,121); e <<

	mov	DWORD PTR __$EHRec$[ebp+12], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8896 :         << (int)(end-bp) <<

	sub	ebx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	BYTE PTR _e$2[ebp+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	ebx
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$13[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$13[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	eax
	mov	eax, DWORD PTR _e$2[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8898 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN29@read_marke:

; 8899 : 
; 8900 :   return true;

	mov	al, 1
$LN1@read_marke:

; 8901 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN83@read_marke:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z$2:
	lea	ecx, DWORD PTR _w$9[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z$3:
	lea	ecx, DWORD PTR _e$8[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z$4:
	lea	ecx, DWORD PTR _e$7[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z$5:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-180]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_marker_segment@qcd_params@@MAE_NGHQAEH@Z ENDP	; qcd_params::read_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?check_marker_segment@qcd_params@@MAE_NGHQAEAAH@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_c_idx$ = 20						; size = 4
?check_marker_segment@qcd_params@@MAE_NGHQAEAAH@Z PROC	; qcd_params::check_marker_segment, COMDAT
; _this$ = ecx

; 8784 : {

	push	ebp
	mov	ebp, esp

; 8785 :   if (code == KDU_QCD)

	mov	ax, WORD PTR _code$[ebp]
	push	esi
	mov	esi, ecx
	mov	ecx, 65372				; 0000ff5cH
	cmp	ax, cx
	jne	SHORT $LN2@check_mark

; 8786 :     {
; 8787 :       c_idx = -1;

	mov	eax, DWORD PTR _c_idx$[ebp]
	pop	esi
	mov	DWORD PTR [eax], -1

; 8788 :       return true;

	mov	al, 1

; 8798 : }

	pop	ebp
	ret	16					; 00000010H
$LN2@check_mark:

; 8789 :     }
; 8790 :   if ((code == KDU_QCC) && (num_bytes >= 2))

	mov	ecx, 65373				; 0000ff5dH
	cmp	ax, cx
	jne	SHORT $LN3@check_mark
	cmp	DWORD PTR _num_bytes$[ebp], 2
	jl	SHORT $LN3@check_mark

; 8791 :     {
; 8792 :       c_idx = *(bytes++);

	mov	eax, DWORD PTR _bytes$[ebp]
	mov	edx, DWORD PTR _c_idx$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR [edx], ecx

; 8793 :       if (num_comps > 256)

	cmp	DWORD PTR [esi+24], 256			; 00000100H
	jle	SHORT $LN4@check_mark

; 8794 :         c_idx = (c_idx<<8) + *(bytes++);

	movzx	eax, BYTE PTR [eax+1]
	shl	ecx, 8
	add	eax, ecx
	mov	DWORD PTR [edx], eax
$LN4@check_mark:

; 8795 :       return true;

	mov	al, 1
	pop	esi

; 8798 : }

	pop	ebp
	ret	16					; 00000010H
$LN3@check_mark:

; 8796 :     }
; 8797 :   return false;

	xor	al, al
	pop	esi

; 8798 : }

	pop	ebp
	ret	16					; 00000010H
?check_marker_segment@qcd_params@@MAE_NGHQAEAAH@Z ENDP	; qcd_params::check_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
_TEXT	SEGMENT
_e$2 = -212						; size = 20
_val$3 = -192						; size = 4
_ref_levels$4 = -188					; size = 4
_this$GSCopy$1$ = -184					; size = 4
_mu$5 = -180						; size = 4
_step$6 = -180						; size = 4
_val$7 = -176						; size = 4
_range$8 = -176						; size = 4
_levels$ = -172						; size = 4
_guard$ = -168						; size = 4
_derived$ = -164					; size = 1
_component_bytes$1$ = -160				; size = 4
_val$9 = -160						; size = 4
_eps$10 = -160						; size = 4
_e$11 = -156						; size = 20
_e$12 = -156						; size = 20
_e$13 = -156						; size = 20
_w$14 = -156						; size = 20
_e$15 = -156						; size = 20
_e$16 = -156						; size = 20
_e$17 = -156						; size = 20
_e$18 = -156						; size = 20
_e$19 = -156						; size = 20
_e$20 = -156						; size = 20
_e$21 = -156						; size = 20
_out$GSCopy$1$ = -136					; size = 4
_style$1$ = -136					; size = 4
_val$22 = -136						; size = 4
_profile$23 = -136					; size = 4
_value$1$ = -132					; size = 4
_last_marked$GSCopy$1$ = -132				; size = 4
_value$1$ = -132					; size = 4
_length$1$ = -132					; size = 4
_word$1$ = -128						; size = 4
_value$1$ = -128					; size = 4
_ref_cod$1$ = -128					; size = 4
_cod$2$ = -128						; size = 4
_val$24 = -128						; size = 4
_num_bands$1$ = -124					; size = 4
_decomp$25 = -124					; size = 4
_byte$1$ = -118						; size = 1
_ref_reversible$26 = -118				; size = 1
_reversible$ = -117					; size = 1
_band_descriptors$ = -116				; size = 98
_text$27 = -100						; size = 80
_text$28 = -100						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_out$ = 8						; size = 4
_last_marked$ = 12					; size = 4
_tpart_idx$ = 16					; size = 4
?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z PROC ; qcd_params::write_marker_segment, COMDAT
; _this$ = ecx

; 8593 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx

; 8594 :   qcd_params *ref = (qcd_params *) last_marked;
; 8595 :   int length, n;
; 8596 :   int guard, levels;
; 8597 :   bool reversible, derived;
; 8598 : 
; 8599 :   if (tpart_idx != 0)

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	mov	esi, DWORD PTR _out$[ebp]
	mov	edi, DWORD PTR _last_marked$[ebp]
	mov	DWORD PTR _out$GSCopy$1$[ebp], esi
	mov	DWORD PTR _last_marked$GSCopy$1$[ebp], edi
	je	SHORT $LN11@write_mark
$LN171@write_mark:

; 8600 :     return 0;

	xor	eax, eax
	jmp	$LN1@write_mark
$LN11@write_mark:

; 8601 :   kdu_params *cod = access_cluster(COD_params);

	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 8602 :   assert(cod != NULL);
; 8603 :   cod = cod->access_relation(tile_idx,comp_idx,0,true);

	push	1
	push	0
	push	DWORD PTR [ebx+12]
	mov	ecx, eax
	push	DWORD PTR [ebx+8]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	DWORD PTR _cod$2$[ebp], eax

; 8604 :   if (!((cod != NULL) &&

	test	eax, eax
	je	SHORT $LN13@write_mark
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _levels$[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN13@write_mark
	mov	ecx, DWORD PTR _cod$2$[ebp]
	lea	eax, DWORD PTR _reversible$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN12@write_mark
$LN13@write_mark:

; 8607 :     { KDU_ERROR_DEV(e,110); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$21[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$21[ebp]
	lea	ecx, DWORD PTR _e$21[ebp]
	push	OFFSET ??_C@_0FL@MPLKHCGE@Cannot?5write?5QCD?1QCC?5marker?5segm@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8607 :     { KDU_ERROR_DEV(e,110); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8610 :     }

	lea	ecx, DWORD PTR _e$21[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN12@write_mark:

; 8611 :   if (!get(Qguard,0,0,guard))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _guard$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06BGIMBACE@Qguard?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN14@write_mark

; 8612 :     { KDU_ERROR_DEV(e,111); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$20[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$20[ebp]
	lea	ecx, DWORD PTR _e$20[ebp]
	push	OFFSET ??_C@_0EA@FNJKHCGL@Cannot?5write?5QCD?1QCC?5marker?5segm@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8612 :     { KDU_ERROR_DEV(e,111); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8615 :     }

	lea	ecx, DWORD PTR _e$20[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN14@write_mark:

; 8616 :   if (reversible)

	cmp	BYTE PTR _reversible$[ebp], 0
	je	SHORT $LN15@write_mark

; 8617 :     derived = false;

	mov	BYTE PTR _derived$[ebp], 0

; 8623 : 
; 8624 :   kdu_int16 band_descriptors[49];
; 8625 :   int num_bands = 1;

	mov	DWORD PTR _num_bands$1$[ebp], 1
	jmp	SHORT $LN146@write_mark
$LN15@write_mark:

; 8618 :   else if (!get(Qderived,0,0,derived))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _derived$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN17@write_mark

; 8619 :     { KDU_ERROR_DEV(e,112); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$19[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$19[ebp]
	lea	ecx, DWORD PTR _e$19[ebp]
	push	OFFSET ??_C@_0HA@COCFLGOG@Cannot?5write?5QCD?1QCC?5marker?5segm@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8619 :     { KDU_ERROR_DEV(e,112); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8622 :     }

	lea	ecx, DWORD PTR _e$19[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN17@write_mark:

; 8626 :   if (!derived)

	cmp	BYTE PTR _derived$[ebp], 0
	mov	DWORD PTR _num_bands$1$[ebp], 1
	jne	SHORT $LN149@write_mark
$LN146@write_mark:

; 8627 :     {
; 8628 :       int decomp;
; 8629 :       for (n=0; n < levels; n++)

	xor	edi, edi
	cmp	DWORD PTR _levels$[ebp], edi
	jle	SHORT $LN164@write_mark
	mov	esi, DWORD PTR _cod$2$[ebp]
	lea	ebx, DWORD PTR [edi+1]
$LL4@write_mark:

; 8630 :         {
; 8631 :           cod->get(Cdecomp,n,0,decomp);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _decomp$25[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 8632 :           num_bands +=

	lea	eax, DWORD PTR _band_descriptors$[ebp]
	push	eax
	push	DWORD PTR _decomp$25[ebp]
	call	?expand_decomp_bands@cod_params@@SAHHQAF@Z ; cod_params::expand_decomp_bands
	dec	ebx
	inc	edi
	add	esp, 8
	add	ebx, eax
	cmp	edi, DWORD PTR _levels$[ebp]
	jl	SHORT $LL4@write_mark
	mov	esi, DWORD PTR _out$GSCopy$1$[ebp]
	mov	DWORD PTR _num_bands$1$[ebp], ebx
	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
$LN164@write_mark:
	mov	edi, DWORD PTR _last_marked$GSCopy$1$[ebp]
$LN149@write_mark:

; 8633 :             cod_params::expand_decomp_bands(decomp,band_descriptors) - 1;
; 8634 :         }
; 8635 :     }
; 8636 : 
; 8637 :   if (ref != NULL)

	test	edi, edi
	je	$LN153@write_mark

; 8638 :     { // See if we can avoid writing this marker.
; 8639 :       int ref_levels;
; 8640 :       bool ref_reversible;
; 8641 :       kdu_params *ref_cod =
; 8642 :         cod->access_relation(ref->tile_idx,ref->comp_idx,0,true);

	mov	ecx, DWORD PTR _cod$2$[ebp]
	push	1
	push	0
	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+8]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	DWORD PTR _ref_cod$1$[ebp], eax

; 8643 :       assert(ref_cod != NULL);
; 8644 :       if (!((ref_cod != NULL) &&

	test	eax, eax
	je	SHORT $LN21@write_mark
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _ref_levels$4[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN21@write_mark
	mov	ecx, DWORD PTR _ref_cod$1$[ebp]
	lea	eax, DWORD PTR _ref_reversible$26[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN20@write_mark
$LN21@write_mark:

; 8647 :         { KDU_ERROR_DEV(e,113); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$18[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$18[ebp]
	lea	ecx, DWORD PTR _e$18[ebp]
	push	OFFSET ??_C@_0FP@CMAJFDH@Cannot?5write?5QCD?1QCC?5marker?5segm@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8647 :         { KDU_ERROR_DEV(e,113); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8650 :         }

	lea	ecx, DWORD PTR _e$18[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN20@write_mark:

; 8652 :           ref->compare(Qguard,0,0,guard) &&

	mov	al, BYTE PTR _ref_reversible$26[ebp]
	cmp	al, BYTE PTR _reversible$[ebp]
	jne	$LN153@write_mark
	mov	eax, DWORD PTR _ref_levels$4[ebp]
	cmp	eax, DWORD PTR _levels$[ebp]
	jne	$LN153@write_mark
	mov	eax, DWORD PTR _guard$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, edi
	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8652 :           ref->compare(Qguard,0,0,guard) &&

	mov	DWORD PTR _value$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$7[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06BGIMBACE@Qguard?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN153@write_mark
	mov	eax, DWORD PTR _value$1$[ebp]
	cmp	DWORD PTR _val$7[ebp], eax
	jne	$LN153@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8652 :           ref->compare(Qguard,0,0,guard) &&

	cmp	BYTE PTR _reversible$[ebp], 0
	jne	SHORT $LN23@write_mark
	push	DWORD PTR _derived$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	call	?compare@kdu_params@@QAE_NPBDHH_N@Z	; kdu_params::compare
	test	al, al
	je	$LN153@write_mark
$LN23@write_mark:

; 8655 :           for (n=0; n < num_bands; n++)

	mov	eax, DWORD PTR _num_bands$1$[ebp]
	xor	edi, edi
	test	eax, eax
	jle	$LN151@write_mark
	mov	esi, DWORD PTR _last_marked$GSCopy$1$[ebp]
	npad	1
$LL7@write_mark:

; 8656 :             if (reversible)

	cmp	BYTE PTR _reversible$[ebp], 0

; 8657 :               {
; 8658 :                 int range;
; 8659 :                 if (!get(Qabs_ranges,n,0,range))

	mov	ecx, ebx
	push	1
	push	1
	push	1
	je	$LN24@write_mark
	lea	eax, DWORD PTR _range$8[ebp]
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN26@write_mark

; 8660 :                   { KDU_ERROR_DEV(e,114); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$17[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$17[ebp]
	lea	ecx, DWORD PTR _e$17[ebp]
	push	OFFSET ??_C@_0GB@PFKIFKOG@Cannot?5write?5QCD?1QCC?5marker?5segm@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8660 :                   { KDU_ERROR_DEV(e,114); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8664 :                   }

	lea	ecx, DWORD PTR _e$17[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN26@write_mark:

; 8665 :                 if (!ref->compare(Qabs_ranges,n,0,range))

	mov	eax, DWORD PTR _range$8[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, esi
	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8665 :                 if (!ref->compare(Qabs_ranges,n,0,range))

	mov	DWORD PTR _value$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$24[ebp]
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN163@write_mark
	mov	eax, DWORD PTR _value$1$[ebp]
	cmp	DWORD PTR _val$24[ebp], eax
	je	$LN5@write_mark
$LN163@write_mark:
	mov	eax, DWORD PTR _num_bands$1$[ebp]
$LN159@write_mark:
	mov	esi, DWORD PTR _out$GSCopy$1$[ebp]
$LN151@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8679 :           if (n == num_bands)

	cmp	edi, eax
	je	$LN171@write_mark
$LN153@write_mark:

; 8680 :             return 0; // No need to explicitly write a marker here.
; 8681 :         }
; 8682 :     }
; 8683 : 
; 8684 :   // We are now committed to writing (or simulating) a marker segment.
; 8685 :   if ((guard > 7) || (guard < 0))

	mov	eax, DWORD PTR _guard$[ebp]
	mov	edi, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	eax, 7
	jg	SHORT $LN32@write_mark
	test	eax, eax
	jns	$LN31@write_mark
$LN32@write_mark:

; 8686 :     { KDU_ERROR(e,116); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$15[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$15[ebp]
	lea	ecx, DWORD PTR _e$15[ebp]
	push	OFFSET ??_C@_0BP@OIAJENOM@Illegal?5number?5of?5guard?5bits?0?5?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8686 :     { KDU_ERROR(e,116); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$15[ebp+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	DWORD PTR _guard$[ebp]
	cmove	eax, edi
	push	eax
	lea	eax, DWORD PTR _text$28[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$28[ebp]
	lea	ecx, DWORD PTR _e$15[ebp]
	push	eax
	mov	eax, DWORD PTR _e$15[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$15[ebp]
	lea	ecx, DWORD PTR _e$15[ebp]
	push	OFFSET ??_C@_0BO@CHOCCCME@?4?5Legal?5range?5is?5from?50?5to?57?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8689 :     }

	lea	ecx, DWORD PTR _e$15[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN31@write_mark:

; 8690 :   
; 8691 :   int component_bytes = (get_num_comps() <= 256)?1:2;

	xor	eax, eax
	cmp	DWORD PTR [ebx+24], 256			; 00000100H
	setg	al
	inc	eax

; 8692 :   
; 8693 :   if (comp_idx < 0)

	cmp	DWORD PTR [ebx+12], 0
	mov	DWORD PTR _component_bytes$1$[ebp], eax
	jge	$LN33@write_mark

; 8694 :     length = 4 + 1;

	mov	eax, 5

; 8695 :   else

	jmp	$LN34@write_mark
$LN24@write_mark:

; 8666 :                   break;
; 8667 :               }
; 8668 :             else
; 8669 :               {
; 8670 :                 float step;
; 8671 :                 if (!get(Qabs_steps,n,0,step))

	lea	eax, DWORD PTR _step$6[ebp]
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN28@write_mark

; 8672 :                   { KDU_ERROR_DEV(e,115); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$16[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	OFFSET ??_C@_0FI@LONAPNHG@Cannot?5write?5QCD?1QCC?5marker?5segm@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8672 :                   { KDU_ERROR_DEV(e,115); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8675 :                   }

	lea	ecx, DWORD PTR _e$16[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN28@write_mark:

; 8676 :                 if (!ref->compare(Qabs_steps,n,0,step))

	movss	xmm0, DWORD PTR _step$6[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1243 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$9[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	mov	ecx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8676 :                 if (!ref->compare(Qabs_steps,n,0,step))

	movss	DWORD PTR _value$1$[ebp], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1243 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	$LN163@write_mark
	movss	xmm0, DWORD PTR _val$9[ebp]
	ucomiss	xmm0, DWORD PTR _value$1$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN163@write_mark
$LN5@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8655 :           for (n=0; n < num_bands; n++)

	mov	eax, DWORD PTR _num_bands$1$[ebp]
	inc	edi
	cmp	edi, eax
	jl	$LL7@write_mark
	jmp	$LN159@write_mark
$LN33@write_mark:

; 8696 :     length = 4 + component_bytes + 1;

	add	eax, 5
$LN34@write_mark:

; 8697 :   length += num_bands * (2-reversible);

	movzx	ecx, BYTE PTR _reversible$[ebp]
	mov	edi, 2
	mov	edx, edi
	sub	edx, ecx
	imul	edx, DWORD PTR _num_bands$1$[ebp]
	add	eax, edx
	mov	DWORD PTR _length$1$[ebp], eax

; 8698 :   if (out == NULL)

	test	esi, esi
	je	$LN1@write_mark

; 8699 :     return length;
; 8700 : 
; 8701 :   // Now for actually writing out the marker.
; 8702 :   if (tile_idx >= 0)

	cmp	DWORD PTR [ebx+8], 0
	jl	$LN39@write_mark

; 8703 :     { // Check for profile compatibility.
; 8704 :       kdu_params *siz = access_cluster(SIZ_params);

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	mov	ecx, ebx
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 8705 :       assert(siz != NULL);
; 8706 :       int profile = 2; siz->get(Sprofile,0,0,profile);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _profile$23[ebp]
	mov	DWORD PTR _profile$23[ebp], edi
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 8707 :       if (profile == 0)

	mov	eax, DWORD PTR _profile$23[ebp]
	test	eax, eax
	jne	$LN37@write_mark

; 8708 :         { KDU_WARNING(w,4); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$14[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$14[ebp]
	lea	ecx, DWORD PTR _w$14[ebp]
	push	OFFSET ??_C@_0NK@HGFFBJED@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8708 :         { KDU_WARNING(w,4); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _w$14[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR [ebx+8]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$27[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$27[ebp]
	lea	ecx, DWORD PTR _w$14[ebp]
	push	eax
	mov	eax, DWORD PTR _w$14[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$14[ebp]
	lea	ecx, DWORD PTR _w$14[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8714 :         }

	lea	ecx, DWORD PTR _w$14[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
	jmp	SHORT $LN39@write_mark
$LN37@write_mark:

; 8715 :       else if ((profile == Sprofile_CINEMA2K) ||

	cmp	eax, 4
	je	SHORT $LN40@write_mark
	cmp	eax, 5
	jne	SHORT $LN39@write_mark
$LN40@write_mark:

; 8717 :         { KDU_ERROR(e,0x11110809); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$13[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	OFFSET ??_C@_0LA@JJEBFCFM@Profile?5violation?5detected?4?5?5QCD@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8717 :         { KDU_ERROR(e,0x11110809); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8722 :         }

	lea	ecx, DWORD PTR _e$13[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN39@write_mark:

; 8723 :     }
; 8724 : 
; 8725 :   int acc_length = 0; // Count actual written bytes for consistency checking.
; 8726 :   int style = (guard << 5) + ((reversible)?0:(2-derived));

	cmp	BYTE PTR _reversible$[ebp], 0
	je	SHORT $LN52@write_mark
	xor	edi, edi
	jmp	SHORT $LN53@write_mark
$LN52@write_mark:
	movzx	eax, BYTE PTR _derived$[ebp]
	sub	edi, eax
$LN53@write_mark:
	mov	eax, DWORD PTR _guard$[ebp]

; 8727 :   if (comp_idx < 0)
; 8728 :     {
; 8729 :       acc_length += out->put(KDU_QCD);

	mov	ecx, esi
	shl	eax, 5
	add	eax, edi
	cmp	DWORD PTR [ebx+12], 0
	mov	DWORD PTR _style$1$[ebp], eax
	jge	SHORT $LN41@write_mark
	push	65372					; 0000ff5cH
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 8730 :       acc_length += out->put((kdu_uint16)(length-2));

	mov	eax, DWORD PTR _length$1$[ebp]
	add	eax, -2					; fffffffeH

; 8731 :       acc_length += out->put((kdu_byte) style);
; 8732 :     }
; 8733 :   else

	jmp	SHORT $LN169@write_mark
$LN41@write_mark:

; 8734 :     {
; 8735 :       acc_length += out->put(KDU_QCC);

	push	65373					; 0000ff5dH
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 8736 :       acc_length += out->put((kdu_uint16)(length-2));

	mov	eax, DWORD PTR _length$1$[ebp]
	mov	ecx, esi
	add	eax, -2					; fffffffeH
	push	eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 8737 :       if (component_bytes == 1)

	cmp	DWORD PTR _component_bytes$1$[ebp], 1
	jne	SHORT $LN43@write_mark

; 8738 :         acc_length += out->put((kdu_byte) comp_idx);

	mov	al, BYTE PTR [ebx+12]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN110@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN110@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8739 :       else

	jmp	SHORT $LN44@write_mark
$LN43@write_mark:

; 8740 :         acc_length += out->put((kdu_uint16) comp_idx);

	movzx	eax, WORD PTR [ebx+12]
$LN169@write_mark:
	push	eax
	mov	ecx, esi
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put
$LN44@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN113@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN113@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8743 :   for (n=0; n < num_bands; n++)

	xor	edi, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR _style$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8743 :   for (n=0; n < num_bands; n++)

	cmp	DWORD PTR _num_bands$1$[ebp], edi
	jle	$LN9@write_mark
$LL10@write_mark:

; 8744 :     if (reversible)

	cmp	BYTE PTR _reversible$[ebp], 0

; 8745 :       {
; 8746 :         int val;
; 8747 : 
; 8748 :         if (!get(Qabs_ranges,n,0,val))

	mov	ecx, ebx
	push	1
	push	1
	push	1
	je	$LN45@write_mark
	lea	eax, DWORD PTR _val$22[ebp]
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN47@write_mark

; 8749 :           { KDU_ERROR_DEV(e,117); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$12[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_0FG@JFODLLGA@Insufficient?5absolute?5ranging?5pa@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8749 :           { KDU_ERROR_DEV(e,117); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 9
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8752 :           }

	lea	ecx, DWORD PTR _e$12[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN47@write_mark:

; 8753 :         if ((val < 0) || (val > 31))

	mov	ebx, DWORD PTR _val$22[ebp]
	test	ebx, ebx
	js	SHORT $LN49@write_mark
	cmp	ebx, 31					; 0000001fH
	jle	SHORT $LN48@write_mark
$LN49@write_mark:

; 8754 :           { KDU_ERROR(e,118); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$11[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_0GI@PNGCMGM@Absolute?5ranging?5parameters?5for?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8754 :           { KDU_ERROR(e,118); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8757 :           }

	lea	ecx, DWORD PTR _e$11[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ebx, DWORD PTR _val$22[ebp]
$LN48@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8758 :         acc_length += out->put((kdu_byte)(val<<3));

	shl	bl, 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN120@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN120@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8760 :     else

	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	jmp	$LN170@write_mark
$LN45@write_mark:

; 8761 :       {
; 8762 :         float val;
; 8763 :         int eps, mu;
; 8764 : 
; 8765 :         if (!get(Qabs_steps,n,0,val))

	lea	eax, DWORD PTR _val$3[ebp]
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN50@write_mark

; 8766 :           { KDU_ERROR_DEV(e,119); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0GG@CKIKGBGG@Insufficient?5absolute?5quantizati@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8766 :           { KDU_ERROR_DEV(e,119); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8769 :           }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN50@write_mark:

; 8770 :         step_to_eps_mu(val,eps,mu);

	movss	xmm0, DWORD PTR _val$3[ebp]
	lea	eax, DWORD PTR _mu$5[ebp]
	push	eax
	lea	eax, DWORD PTR _eps$10[ebp]
	push	eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?step_to_eps_mu@@YAXMAAH0@Z		; step_to_eps_mu

; 8771 :         acc_length += out->put((kdu_uint16)((eps<<11)+mu));

	mov	eax, DWORD PTR _eps$10[ebp]
	add	esp, 12					; 0000000cH
	shl	eax, 11					; 0000000bH
	add	eax, DWORD PTR _mu$5[ebp]
	movzx	eax, ax
	mov	DWORD PTR _word$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN127@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN127@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, DWORD PTR _word$1$[ebp]
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN130@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN130@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR _word$1$[ebp]
	mov	BYTE PTR [eax], cl
$LN170@write_mark:
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8743 :   for (n=0; n < num_bands; n++)

	inc	edi
	cmp	edi, DWORD PTR _num_bands$1$[ebp]
	jl	$LL10@write_mark
$LN9@write_mark:

; 8772 :       }
; 8773 :   assert(length == acc_length);
; 8774 :   return length;

	mov	eax, DWORD PTR _length$1$[ebp]
$LN1@write_mark:

; 8775 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0:
	lea	ecx, DWORD PTR _e$21[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1:
	lea	ecx, DWORD PTR _e$20[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$2:
	lea	ecx, DWORD PTR _e$19[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$3:
	lea	ecx, DWORD PTR _e$18[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$4:
	lea	ecx, DWORD PTR _e$17[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$6:
	lea	ecx, DWORD PTR _e$15[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$5:
	lea	ecx, DWORD PTR _e$16[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$7:
	lea	ecx, DWORD PTR _w$14[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$8:
	lea	ecx, DWORD PTR _e$13[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$9:
	lea	ecx, DWORD PTR _e$12[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$10:
	lea	ecx, DWORD PTR _e$11[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$11:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-216]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?write_marker_segment@qcd_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ENDP ; qcd_params::write_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?copy_with_xforms@qcd_params@@MAEXPAVkdu_params@@HH_N11@Z
_TEXT	SEGMENT
_source_cod$2$ = -252					; size = 4
_step$1 = -248						; size = 4
_range$2 = -244						; size = 4
_source_decomp$3 = -240					; size = 4
_derived$ = -236					; size = 1
_guard$ = -232						; size = 4
_this$GSCopy$1$ = -228					; size = 4
_src$GSCopy$1$ = -224					; size = 4
_n$1$ = -220						; size = 4
_source_levels$ = -216					; size = 4
_source_reversible$ = -209				; size = 1
_b_offset$1$ = -208					; size = 4
_source_bands$ = -204					; size = 98
_target_bands$ = -104					; size = 98
__$ArrayPad$ = -4					; size = 4
_src$ = 8						; size = 4
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_transpose$ = 20					; size = 1
_vflip$ = 24						; size = 1
_hflip$ = 28						; size = 1
?copy_with_xforms@qcd_params@@MAEXPAVkdu_params@@HH_N11@Z PROC ; qcd_params::copy_with_xforms, COMDAT
; _this$ = ecx

; 8506 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _src$[ebp]

; 8507 :   qcd_params *source = (qcd_params *) src;
; 8508 :   int guard;
; 8509 :   bool derived;
; 8510 :   if (source->get(Qguard,0,0,guard,false))

	lea	eax, DWORD PTR _guard$[ebp]
	push	esi
	push	1
	push	1
	push	0
	push	eax
	push	0
	mov	esi, ecx
	mov	DWORD PTR _src$GSCopy$1$[ebp], ebx
	push	0
	push	OFFSET ??_C@_06BGIMBACE@Qguard?$AA@
	mov	ecx, ebx
	mov	DWORD PTR _this$GSCopy$1$[ebp], esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN11@copy_with_

; 8511 :     set(Qguard,0,0,guard);

	push	DWORD PTR _guard$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_06BGIMBACE@Qguard?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN11@copy_with_:

; 8512 :   if (source->get(Qderived,0,0,derived,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _derived$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN12@copy_with_

; 8513 :     set(Qderived,0,0,derived);

	push	DWORD PTR _derived$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN12@copy_with_:

; 8514 : 
; 8515 :   kdu_params *source_cod = source->access_cluster(COD_params);

	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	mov	ecx, ebx
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 8516 :   if ((source_cod == NULL) ||

	test	eax, eax
	je	$LN14@copy_with_
	push	edi
	push	1
	push	0
	push	DWORD PTR [ebx+12]
	mov	ecx, eax
	push	DWORD PTR [ebx+8]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	edi, eax
	mov	DWORD PTR _source_cod$2$[ebp], edi
	test	edi, edi
	je	$LN44@copy_with_

; 8517 :       ((source_cod =
; 8518 :         source_cod->access_relation(source->tile_idx,source->comp_idx,
; 8519 :                                     0,true)) == NULL))
; 8520 :     { assert(0); return; }
; 8521 : 
; 8522 :   int source_levels=0;
; 8523 :   bool source_reversible;
; 8524 :   source_cod->get(Clevels,0,0,source_levels);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _source_levels$[ebp]
	mov	DWORD PTR _source_levels$[ebp], 0
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 8525 :   source_cod->get(Creversible,0,0,source_reversible);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _source_reversible$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get

; 8526 : 
; 8527 :   int n; // Represents resolution level
; 8528 :   int b_in, b_out, b_offset; // Num quant vals written from previous levels
; 8529 :   int num_level_bands;
; 8530 :   kdu_int16 source_bands[49];
; 8531 :   kdu_int16 target_bands[49];
; 8532 :   source_bands[0] = target_bands[0] = 0; // Degenerate case for resolution 0
; 8533 :   for (n=0, b_offset=0, num_level_bands=1;
; 8534 :        n <= (source_levels-discard_levels); n++)

	mov	edx, DWORD PTR _discard_levels$[ebp]
	xor	eax, eax
	mov	WORD PTR _target_bands$[ebp], ax
	xor	ebx, ebx
	mov	WORD PTR _source_bands$[ebp], ax
	xor	ecx, ecx
	mov	DWORD PTR _n$1$[ebp], ebx
	lea	esi, DWORD PTR [eax+1]
	mov	DWORD PTR _b_offset$1$[ebp], ecx
	mov	eax, DWORD PTR _source_levels$[ebp]
	sub	eax, edx
	js	$LN44@copy_with_
	npad	1
$LL4@copy_with_:

; 8535 :     { // Each iteration of loop processes one resolution level, until there
; 8536 :       // are no more resolution levels for which quantization information is
; 8537 :       // available
; 8538 : 
; 8539 :       if (n > 0)

	test	ebx, ebx
	jle	SHORT $LN43@copy_with_

; 8540 :         { // Find description for the new resolution level
; 8541 :           int source_decomp;
; 8542 :           if (!source_cod->get(Cdecomp,source_levels-n,0,source_decomp))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _source_decomp$3[ebp]
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR _source_levels$[ebp]
	push	0
	sub	eax, ebx
	push	eax
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 8543 :             assert(0); // Forgot to finalize source parameter before copying
; 8544 :           num_level_bands =

	mov	edi, DWORD PTR _source_decomp$3[ebp]
	lea	eax, DWORD PTR _source_bands$[ebp]
	push	eax
	push	edi
	call	?expand_decomp_bands@cod_params@@SAHHQAF@Z ; cod_params::expand_decomp_bands
	mov	esi, eax
	add	esp, 8

; 8545 :             cod_params::expand_decomp_bands(source_decomp,source_bands);
; 8546 :           if (transpose)

	mov	al, BYTE PTR _transpose$[ebp]
	test	al, al
	je	$LN42@copy_with_

; 8547 :             {
; 8548 :               int target_decomp = cod_params::transpose_decomp(source_decomp);
; 8549 :               cod_params::expand_decomp_bands(target_decomp,target_bands);

	lea	eax, DWORD PTR _target_bands$[ebp]
	push	eax
	push	edi
	call	?transpose_decomp@cod_params@@SAHH@Z	; cod_params::transpose_decomp
	add	esp, 4
	push	eax
	call	?expand_decomp_bands@cod_params@@SAHHQAF@Z ; cod_params::expand_decomp_bands
	mov	ecx, DWORD PTR _b_offset$1$[ebp]
	add	esp, 8
	mov	edx, DWORD PTR _discard_levels$[ebp]
$LN43@copy_with_:
	mov	al, BYTE PTR _transpose$[ebp]
$LN39@copy_with_:

; 8550 :             }
; 8551 :         }
; 8552 : 
; 8553 :       for (b_out=(n==0)?0:1; b_out < num_level_bands; b_out++)

	xor	ebx, ebx
	cmp	DWORD PTR _n$1$[ebp], ebx
	setne	bl
	cmp	ebx, esi
	jge	$LN6@copy_with_
	lea	edi, DWORD PTR [ebx+ecx]
$LL7@copy_with_:

; 8554 :         {
; 8555 :           if (transpose)

	test	al, al
	je	$LN18@copy_with_

; 8556 :             {
; 8557 :               kdu_int16 desc_out, desc_in;
; 8558 :               desc_out = target_bands[b_out];

	movzx	ecx, WORD PTR _target_bands$[ebp+ebx*2]

; 8559 :               desc_in = ((desc_out & 0x00FF)<<8) | ((desc_out>>8) & 0x00FF);

	mov	eax, ecx
	shl	ecx, 8
	sar	eax, 8
	movzx	eax, al
	or	eax, ecx
	movzx	ecx, ax

; 8560 :               for (b_in=0; b_in < num_level_bands; b_in++)

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN41@copy_with_
$LL10@copy_with_:

; 8561 :                 if (source_bands[b_in] == desc_in)

	cmp	WORD PTR _source_bands$[ebp+eax*2], cx
	je	SHORT $LN41@copy_with_

; 8560 :               for (b_in=0; b_in < num_level_bands; b_in++)

	inc	eax
	cmp	eax, esi
	jl	SHORT $LL10@copy_with_
$LN41@copy_with_:
	mov	ecx, DWORD PTR _b_offset$1$[ebp]
$LN19@copy_with_:

; 8567 : 
; 8568 :           if (source_reversible)
; 8569 :             {
; 8570 :               int range;
; 8571 :               source->get(Qabs_ranges,b_offset+b_in,0,range);

	push	1
	add	eax, ecx
	mov	ecx, DWORD PTR _src$GSCopy$1$[ebp]
	cmp	BYTE PTR _source_reversible$[ebp], 0
	push	1
	push	1
	je	SHORT $LN21@copy_with_
	lea	edx, DWORD PTR _range$2[ebp]
	push	edx
	push	0
	push	eax
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 8572 :               set(Qabs_ranges,b_offset+b_out,0,range);

	push	DWORD PTR _range$2[ebp]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	0
	push	edi
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 8573 :             }
; 8574 :           else

	jmp	SHORT $LN5@copy_with_
$LN42@copy_with_:
	mov	ecx, DWORD PTR _b_offset$1$[ebp]
	mov	edx, DWORD PTR _discard_levels$[ebp]
	jmp	$LN39@copy_with_
$LN18@copy_with_:

; 8562 :                   break;
; 8563 :               assert(b_in < num_level_bands);
; 8564 :             }
; 8565 :           else
; 8566 :             b_in = b_out;

	mov	eax, ebx
	jmp	SHORT $LN19@copy_with_
$LN21@copy_with_:

; 8575 :             {
; 8576 :               float step;
; 8577 :               source->get(Qabs_steps,b_offset+b_in,0,step);

	lea	edx, DWORD PTR _step$1[ebp]
	push	edx
	push	0
	push	eax
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	movss	xmm0, DWORD PTR _step$1[ebp]

; 8578 :               set(Qabs_steps,b_offset+b_out,0,step);

	sub	esp, 8
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	edi
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
$LN5@copy_with_:

; 8550 :             }
; 8551 :         }
; 8552 : 
; 8553 :       for (b_out=(n==0)?0:1; b_out < num_level_bands; b_out++)

	mov	ecx, DWORD PTR _b_offset$1$[ebp]
	inc	ebx
	mov	al, BYTE PTR _transpose$[ebp]
	inc	edi
	cmp	ebx, esi
	jl	$LL7@copy_with_
	mov	edx, DWORD PTR _discard_levels$[ebp]
$LN6@copy_with_:

; 8526 : 
; 8527 :   int n; // Represents resolution level
; 8528 :   int b_in, b_out, b_offset; // Num quant vals written from previous levels
; 8529 :   int num_level_bands;
; 8530 :   kdu_int16 source_bands[49];
; 8531 :   kdu_int16 target_bands[49];
; 8532 :   source_bands[0] = target_bands[0] = 0; // Degenerate case for resolution 0
; 8533 :   for (n=0, b_offset=0, num_level_bands=1;
; 8534 :        n <= (source_levels-discard_levels); n++)

	mov	ebx, DWORD PTR _n$1$[ebp]

; 8579 :             }
; 8580 :         }
; 8581 : 
; 8582 :       b_offset += num_level_bands - 1;

	dec	ecx
	mov	eax, DWORD PTR _source_levels$[ebp]
	inc	ebx
	mov	edi, DWORD PTR _source_cod$2$[ebp]
	add	ecx, esi
	sub	eax, edx
	mov	DWORD PTR _b_offset$1$[ebp], ecx
	mov	DWORD PTR _n$1$[ebp], ebx
	cmp	ebx, eax
	jle	$LL4@copy_with_
$LN44@copy_with_:
	pop	edi
$LN14@copy_with_:

; 8583 :     }
; 8584 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?copy_with_xforms@qcd_params@@MAEXPAVkdu_params@@HH_N11@Z ENDP ; qcd_params::copy_with_xforms
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?finalize@qcd_params@@MAEX_N@Z
_TEXT	SEGMENT
_w$2 = -200						; size = 20
_e$3 = -200						; size = 20
_reversible$ = -180					; size = 4
_val$ = -176						; size = 4
_decomp$ = -172						; size = 4
_kernel_id$ = -168					; size = 4
_guard_bits$ = -164					; size = 4
_ref_step$ = -160					; size = 4
_cod$2$ = -156						; size = 4
_val$4 = -152						; size = 4
_mu$5 = -152						; size = 4
_mu$6 = -152						; size = 4
_eps$7 = -148						; size = 4
_eps$8 = -148						; size = 4
_atk_idx$9 = -148					; size = 4
_fval$ = -144						; size = 4
_atk$1$ = -140						; size = 4
_num_levels$ = -136					; size = 4
_precision$10 = -132					; size = 4
_values$1$ = -128					; size = 4
_num_bands$1$ = -128					; size = 4
_this$GSCopy$1$ = -124					; size = 4
tv790 = -124						; size = 4
_value$1$ = -124					; size = 4
_siz$1$ = -124						; size = 4
_abs_ranges$1$ = -124					; size = 4
_derived_from_LL$ = -120				; size = 1
_band_descriptors$ = -116				; size = 98
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_after_reading$ = 8					; size = 1
?finalize@qcd_params@@MAEX_N@Z PROC			; qcd_params::finalize, COMDAT
; _this$ = ecx

; 8909 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?finalize@qcd_params@@MAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 188				; 000000bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], esi

; 8910 :   if (after_reading)

	cmp	BYTE PTR _after_reading$[ebp], 0
	jne	$LN53@finalize

; 8911 :     return;
; 8912 :   int n, decomp, val, guard_bits;
; 8913 :   float fval;
; 8914 : 
; 8915 :   if (!get(Qguard,0,0,guard_bits))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _guard_bits$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06BGIMBACE@Qguard?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN22@finalize

; 8916 :     set(Qguard,0,0,guard_bits=1); // Default is 1 guard bit.

	push	1
	push	0
	push	0
	push	OFFSET ??_C@_06BGIMBACE@Qguard?$AA@
	mov	ecx, esi
	mov	DWORD PTR _guard_bits$[ebp], 1
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN22@finalize:

; 8917 : 
; 8918 :   kdu_params *cod = access_cluster(COD_params);

	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	mov	ecx, esi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 8919 :   assert(cod != NULL);
; 8920 :   cod = cod->access_relation(tile_idx,comp_idx,0,true);

	push	1
	push	0
	push	DWORD PTR [esi+12]
	mov	ecx, eax
	push	DWORD PTR [esi+8]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 8921 :   assert(cod != NULL);
; 8922 : 
; 8923 :   int reversible, num_levels, kernel_id;
; 8924 :   if (!(cod->get(Creversible,0,0,reversible) &&

	push	1
	push	1
	mov	ebx, eax
	lea	eax, DWORD PTR _reversible$[ebp]
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	mov	ecx, ebx
	mov	DWORD PTR _cod$2$[ebp], ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN24@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _num_levels$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN24@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _kernel_id$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN24@finalize:

; 8925 :         cod->get(Clevels,0,0,num_levels) &&
; 8926 :         cod->get(Ckernels,0,0,kernel_id)))
; 8927 :     assert(0);
; 8928 : 
; 8929 :   kdu_params *atk = NULL;
; 8930 :   if (kernel_id == Ckernels_ATK)

	cmp	DWORD PTR _kernel_id$[ebp], -1
	mov	DWORD PTR _atk$1$[ebp], 0
	jne	SHORT $LN28@finalize

; 8931 :     {
; 8932 :       int atk_idx;
; 8933 :       if (!cod->get(Catk,0,0,atk_idx))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _atk_idx$9[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 8934 :         assert(0);
; 8935 :       atk = access_cluster(ATK_params);

	push	OFFSET ??_C@_03IFCLAPBJ@ATK?$AA@
	mov	ecx, esi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	DWORD PTR _atk$1$[ebp], eax

; 8936 :       if ((atk == NULL) ||

	test	eax, eax
	je	SHORT $LN28@finalize
	push	1
	push	DWORD PTR _atk_idx$9[ebp]
	mov	ecx, eax
	push	-1
	push	DWORD PTR [esi+8]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	DWORD PTR _atk$1$[ebp], eax
$LN28@finalize:

; 8937 :           ((atk = atk->access_relation(tile_idx,-1,atk_idx,true)) == NULL))
; 8938 :         assert(0);
; 8939 :     }
; 8940 : 
; 8941 :   kdu_int16 band_descriptors[49];
; 8942 : 
; 8943 :   int num_bands = 1;
; 8944 :   for (n=0; n < num_levels; n++)

	xor	ebx, ebx
	mov	edi, 1
	mov	DWORD PTR _num_bands$1$[ebp], edi
	cmp	DWORD PTR _num_levels$[ebp], ebx
	jle	SHORT $LN3@finalize
	mov	esi, DWORD PTR _cod$2$[ebp]
$LL4@finalize:

; 8945 :     {
; 8946 :       cod->get(Cdecomp,n,0,decomp);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _decomp$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 8947 :       num_bands +=

	lea	eax, DWORD PTR _band_descriptors$[ebp]
	push	eax
	push	DWORD PTR _decomp$[ebp]
	call	?expand_decomp_bands@cod_params@@SAHHQAF@Z ; cod_params::expand_decomp_bands
	dec	edi
	inc	ebx
	add	esp, 8
	add	edi, eax
	cmp	ebx, DWORD PTR _num_levels$[ebp]
	jl	SHORT $LL4@finalize
	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR _num_bands$1$[ebp], edi
$LN3@finalize:

; 8948 :         cod_params::expand_decomp_bands(decomp,band_descriptors) - 1;
; 8949 :     }
; 8950 : 
; 8951 :   // Find out how many steps and/or ranges are available already
; 8952 :   int abs_steps=0, abs_ranges=0;

	xor	ebx, ebx

; 8953 :   while (get(Qabs_steps,abs_steps,0,fval,true,true,false))

	lea	eax, DWORD PTR _fval$[ebp]
	push	ebx
	push	1
	push	1
	push	eax
	push	ebx
	push	ebx
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	mov	ecx, esi
	mov	DWORD PTR _abs_ranges$1$[ebp], ebx
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN71@finalize
$LL5@finalize:
	push	0
	push	1
	push	1
	lea	eax, DWORD PTR _fval$[ebp]

; 8954 :     abs_steps++;

	inc	ebx
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL5@finalize
$LN71@finalize:

; 8955 :   while (get(Qabs_ranges,abs_ranges,0,val,true,true,false))

	push	0
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN8@finalize
	xor	edi, edi
	npad	5
$LL7@finalize:
	push	0
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]

; 8956 :     abs_ranges++;

	inc	edi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL7@finalize
	mov	DWORD PTR _abs_ranges$1$[ebp], edi
	mov	edi, DWORD PTR _num_bands$1$[ebp]
$LN8@finalize:

; 8957 : 
; 8958 :   // Now see if we need to generate some quantization parameters ourselves
; 8959 :   bool derived_from_LL=false;
; 8960 :   if (reversible)

	cmp	DWORD PTR _reversible$[ebp], 0

; 8961 :     {
; 8962 :       if ((!get(Qderived,0,0,derived_from_LL)) || derived_from_LL)

	mov	ecx, esi
	push	1
	push	1
	mov	BYTE PTR _derived_from_LL$[ebp], 0
	push	1
	je	$LN29@finalize
	lea	eax, DWORD PTR _derived_from_LL$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN31@finalize
	cmp	BYTE PTR _derived_from_LL$[ebp], 0
	je	SHORT $LN30@finalize
$LN31@finalize:

; 8963 :         set(Qderived,0,0,derived_from_LL=false);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	mov	ecx, esi
	mov	BYTE PTR _derived_from_LL$[ebp], 0
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN30@finalize:

; 8964 :       if (abs_ranges == num_bands)

	cmp	DWORD PTR _abs_ranges$1$[ebp], edi
	je	$LN53@finalize

; 8965 :         return; // Use the existing information
; 8966 : 
; 8967 :       // Implement default policy for absolute ranges.
; 8968 :       int precision;
; 8969 :       kdu_params *siz = access_cluster(SIZ_params);

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	mov	ecx, esi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 8970 :       if (!siz->get(Sprecision,

	mov	ecx, DWORD PTR [esi+12]
	xor	edx, edx
	push	1
	push	1
	test	ecx, ecx
	mov	DWORD PTR _siz$1$[ebp], eax
	push	1
	cmovs	ecx, edx
	lea	edx, DWORD PTR _precision$10[ebp]
	push	edx
	push	0
	push	ecx
	push	OFFSET ??_C@_0L@BADPNFGK@Sprecision?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN33@finalize

; 8972 :         { KDU_ERROR(e,123); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0JH@IGLAJBAL@Trying?5to?5finalize?5quantization?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8972 :         { KDU_ERROR(e,123); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8976 :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN33@finalize:

; 8977 :       if (comp_idx < 0)

	cmp	DWORD PTR [esi+12], 0
	jge	SHORT $LN10@finalize

; 8978 :         { // See if any of the specific components have different precisions
; 8979 :           // to the present one.  If so, make sure that unique instances of
; 8980 :           // the `qcd_params' object exist for those components, so we can
; 8981 :           // install the correct absolute ranges.
; 8982 :           for (int c=0; c < num_comps; c++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+24], ebx
	jle	SHORT $LN10@finalize
	mov	edi, DWORD PTR _siz$1$[ebp]
$LL11@finalize:

; 8983 :             if (!siz->compare(Sprecision,c,0,precision))

	mov	eax, DWORD PTR _precision$10[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, edi
	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8983 :             if (!siz->compare(Sprecision,c,0,precision))

	mov	DWORD PTR _value$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$4[ebp]
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0L@BADPNFGK@Sprecision?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN65@finalize
	mov	eax, DWORD PTR _value$1$[ebp]
	cmp	DWORD PTR _val$4[ebp], eax
	je	SHORT $LN9@finalize
$LN65@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8984 :               access_relation(tile_idx,c); // May create a new unique object

	push	0
	push	0
	push	ebx
	push	DWORD PTR [esi+8]
	mov	ecx, esi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
$LN9@finalize:

; 8978 :         { // See if any of the specific components have different precisions
; 8979 :           // to the present one.  If so, make sure that unique instances of
; 8980 :           // the `qcd_params' object exist for those components, so we can
; 8981 :           // install the correct absolute ranges.
; 8982 :           for (int c=0; c < num_comps; c++)

	inc	ebx
	cmp	ebx, DWORD PTR [esi+24]
	jl	SHORT $LL11@finalize
	mov	edi, DWORD PTR _num_bands$1$[ebp]
$LN10@finalize:

; 8985 :         }
; 8986 : 
; 8987 :       /* The default ranging parameters are based on the folowing:
; 8988 :          1) To avoid overflow/underflow we need
; 8989 :             `epsilon'+G >= `precision'+log2(B)
; 8990 :             where `epsilon' is the ranging parameter, G is the number of
; 8991 :             guard bits and B is the worst case (BIBO) bit-depth expansion for
; 8992 :             the reversible DWT.  Values for B are calculated using the
; 8993 :             `kdu_kernels::get_bibo_gain' function.
; 8994 :          2) If there are 3 or more components, we need to allow an extra bit
; 8995 :             in the chrominance channels if the RCT is used.  Since a single
; 8996 :             set of ranging parameters may have to work for some
; 8997 :             tile-components which use the RCT and others which do not, it is
; 8998 :             safest to always allow this extra bit.
; 8999 :          3) The BIBO gain values are accurate only for moderate to high
; 9000 :             bit-depth (precision) imagery.  At lower precisions, it is safer
; 9001 :             to increase the ranging parameters. */
; 9002 :       if (num_comps >= 3)

	cmp	DWORD PTR [esi+24], 3

; 9003 :         precision++; // Allows for the use of the RCT

	mov	eax, DWORD PTR _precision$10[ebp]
	jl	SHORT $LN36@finalize
	inc	eax
	mov	DWORD PTR _precision$10[ebp], eax
$LN36@finalize:

; 9004 :       if (precision < 5)

	cmp	eax, 5
	jge	SHORT $LN37@finalize

; 9005 :         precision++; // Safer for low bit-depth data

	inc	eax
	mov	DWORD PTR _precision$10[ebp], eax
$LN37@finalize:

; 9006 : 
; 9007 : 
; 9008 :       derive_absolute_ranges(this,cod,atk,num_levels,num_bands,

	push	DWORD PTR _guard_bits$[ebp]
	push	eax
	push	edi
	push	DWORD PTR _num_levels$[ebp]
	push	DWORD PTR _atk$1$[ebp]
	push	DWORD PTR _cod$2$[ebp]
	push	esi
	call	?derive_absolute_ranges@@YAXPAVqcd_params@@PAVkdu_params@@1HHHH@Z ; derive_absolute_ranges
	add	esp, 28					; 0000001cH

; 9009 :                              precision,guard_bits);
; 9010 :       set_derived(Qabs_ranges);

	mov	ecx, esi
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
	call	?set_derived@kdu_params@@QAEXPBD@Z	; kdu_params::set_derived

; 9011 :       return;

	jmp	$LN53@finalize
$LN29@finalize:

; 9012 :     }
; 9013 : 
; 9014 :   // Processing for irreversible step sizes is more complex.
; 9015 :   float ref_step;
; 9016 :   if (get(Qstep,0,0,ref_step))

	lea	eax, DWORD PTR _ref_step$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_05LCODFIOH@Qstep?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 9017 :     { // Ignore any existing step sizes in this case.
; 9018 :       if (get(Qabs_steps,0,0,fval,false,false,false))

	mov	ecx, esi
	test	al, al
	je	$LN38@finalize
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _fval$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN40@finalize

; 9019 :         { KDU_WARNING_DEV(w,6); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$2[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$2[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	OFFSET ??_C@_0BBO@GCINCGGG@Some?5absolute?5step?5sizes?5which?5y@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9019 :         { KDU_WARNING_DEV(w,6); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 9025 :         }

	lea	ecx, DWORD PTR _w$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN40@finalize:

; 9026 :       if (!get(Qderived,0,0,derived_from_LL))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _derived_from_LL$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	$LN41@finalize

; 9027 :         set(Qderived,0,0,derived_from_LL=false);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	mov	ecx, esi
	mov	BYTE PTR _derived_from_LL$[ebp], al
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 9028 :       derive_absolute_steps(this,cod,atk,num_levels,num_bands,ref_step,
; 9029 :                             derived_from_LL);
; 9030 :       set_derived(Qabs_steps);

	jmp	$LN41@finalize
$LN38@finalize:

; 9031 :     }
; 9032 :   else if (abs_steps >= num_bands)
; 9033 :     { // Use the available step sizes.
; 9034 :       if ((!get(Qderived,0,0,derived_from_LL)) || derived_from_LL)

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _derived_from_LL$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	cmp	ebx, edi
	jl	SHORT $LN42@finalize
	test	al, al
	je	SHORT $LN45@finalize
	cmp	BYTE PTR _derived_from_LL$[ebp], 0
	je	$LN51@finalize
$LN45@finalize:

; 9035 :         set(Qderived,0,0,derived_from_LL=false);

	mov	BYTE PTR _derived_from_LL$[ebp], 0
	push	0

; 9036 :     }

	jmp	SHORT $LN101@finalize
$LN42@finalize:

; 9037 :   else if (abs_steps == 1)

	cmp	ebx, 1
	jne	SHORT $LN46@finalize

; 9038 :     {
; 9039 :       if ((!get(Qderived,0,0,derived_from_LL)) || !derived_from_LL)

	test	al, al
	je	SHORT $LN49@finalize
	cmp	BYTE PTR _derived_from_LL$[ebp], 0
	jne	$LN97@finalize
$LN49@finalize:

; 9040 :         set(Qderived,0,0,derived_from_LL=true);

	mov	BYTE PTR _derived_from_LL$[ebp], 1
	push	1
$LN101@finalize:
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 9041 :     }
; 9042 :   else

	jmp	SHORT $LN47@finalize
$LN46@finalize:

; 9043 :     { // Must derive step sizes, using default reference step.
; 9044 :       if (!get(Qderived,0,0,derived_from_LL))

	test	al, al
	jne	SHORT $LN50@finalize

; 9045 :         set(Qderived,0,0,derived_from_LL=false);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	mov	ecx, esi
	mov	BYTE PTR _derived_from_LL$[ebp], al
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN50@finalize:

; 9046 :       set(Qstep,0,0,ref_step=1.0F/256.0F);

	movsd	xmm0, QWORD PTR __real@3f70000000000000
	sub	esp, 8
	mov	ecx, esi
	mov	DWORD PTR _ref_step$[ebp], 998244352	; 3b800000H
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	OFFSET ??_C@_05LCODFIOH@Qstep?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
$LN41@finalize:

; 9047 :       derive_absolute_steps(this,cod,atk,num_levels,num_bands,ref_step,

	push	DWORD PTR _derived_from_LL$[ebp]
	movss	xmm0, DWORD PTR _ref_step$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	DWORD PTR _num_levels$[ebp]
	push	DWORD PTR _atk$1$[ebp]
	push	DWORD PTR _cod$2$[ebp]
	push	esi
	call	?derive_absolute_steps@@YAXPAVqcd_params@@PAVkdu_params@@1HHM_N@Z ; derive_absolute_steps
	add	esp, 28					; 0000001cH

; 9048 :                             derived_from_LL);
; 9049 :       set_derived(Qabs_steps);

	mov	ecx, esi
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?set_derived@kdu_params@@QAEXPBD@Z	; kdu_params::set_derived
$LN47@finalize:

; 9050 :     }
; 9051 : 
; 9052 :   // At this point, the object has access to a set of valid step sizes.
; 9053 :   if (derived_from_LL)

	cmp	BYTE PTR _derived_from_LL$[ebp], 0
	je	SHORT $LN51@finalize
$LN97@finalize:

; 9054 :     num_bands = 1;

	mov	edi, 1
$LN51@finalize:

; 9055 :   if (get(Qabs_steps,0,0,fval,false,false,true))

	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _fval$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	$LN52@finalize

; 9056 :     { /* The attribute is not inherited.  Just make minor corrections to
; 9057 :          ensure that the values conform exactly to the epsilon-mu
; 9058 :          parametrization supported by the code-stream. */
; 9059 :       int eps, mu;
; 9060 : 
; 9061 :       for (n=0; n < num_bands; n++)

	xor	ebx, ebx
	test	edi, edi
	jle	$LN53@finalize
	npad	6
$LL14@finalize:

; 9062 :         {
; 9063 :           if (!get(Qabs_steps,n,0,fval))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _fval$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 9064 :             assert(0);
; 9065 :           step_to_eps_mu(fval,eps,mu);

	movss	xmm0, DWORD PTR _fval$[ebp]
	lea	eax, DWORD PTR _mu$6[ebp]
	push	eax
	lea	eax, DWORD PTR _eps$8[ebp]
	push	eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?step_to_eps_mu@@YAXMAAH0@Z		; step_to_eps_mu

; 9066 :           set(Qabs_steps,n,0,

	mov	ecx, DWORD PTR _eps$8[ebp]
	mov	eax, 1
	movd	xmm1, DWORD PTR _mu$6[ebp]
	add	esp, 4
	shl	eax, cl
	mov	ecx, esi
	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax
	mulss	xmm1, DWORD PTR __real@3a000000
	shr	eax, 31					; 0000001fH
	cvtdq2pd xmm0, xmm0
	addss	xmm1, DWORD PTR __real@3f800000
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	cvtps2pd xmm0, xmm1
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	ebx
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	inc	ebx
	cmp	ebx, edi
	jl	$LL14@finalize

; 9067 :               (1.0F+mu/((float)(1<<11)))/((float)((kdu_uint32)(1<<eps))));
; 9068 :         }
; 9069 :     }
; 9070 :   else

	jmp	$LN53@finalize
$LN52@finalize:

; 9071 :     { /* The step sizes which we have are inherited.  Make a local copy
; 9072 :          to ensure that nothing goes wrong. */
; 9073 :       int eps, mu;
; 9074 :       float *values = new float[num_bands];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR _values$1$[ebp], eax

; 9075 : 
; 9076 :       for (n=0; n < num_bands; n++)

	xor	ebx, ebx
	test	edi, edi
	jle	SHORT $LN16@finalize

; 9071 :     { /* The step sizes which we have are inherited.  Make a local copy
; 9072 :          to ensure that nothing goes wrong. */
; 9073 :       int eps, mu;
; 9074 :       float *values = new float[num_bands];

	mov	DWORD PTR tv790[ebp], eax
$LL17@finalize:

; 9077 :         if (!get(Qabs_steps,n,0,values[n],true,true,false))

	push	0
	push	1
	push	1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	mov	eax, DWORD PTR tv790[ebp]
	inc	ebx
	add	eax, 4
	mov	DWORD PTR tv790[ebp], eax
	cmp	ebx, edi
	jl	SHORT $LL17@finalize
	mov	eax, DWORD PTR _values$1$[ebp]
$LN16@finalize:

; 9078 :           assert(0);
; 9079 :       for (n=0; n < num_bands; n++)

	xor	ebx, ebx
	test	edi, edi
	jle	$LN19@finalize
$LL20@finalize:

; 9080 :         {
; 9081 :           step_to_eps_mu(values[n],eps,mu);

	movss	xmm0, DWORD PTR [eax+ebx*4]
	lea	ecx, DWORD PTR _mu$5[ebp]
	push	ecx
	lea	ecx, DWORD PTR _eps$7[ebp]
	push	ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?step_to_eps_mu@@YAXMAAH0@Z		; step_to_eps_mu

; 9082 :           set(Qabs_steps,n,0,

	mov	ecx, DWORD PTR _eps$7[ebp]
	mov	eax, 1
	movd	xmm1, DWORD PTR _mu$5[ebp]
	add	esp, 4
	shl	eax, cl
	mov	ecx, esi
	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax
	mulss	xmm1, DWORD PTR __real@3a000000
	shr	eax, 31					; 0000001fH
	cvtdq2pd xmm0, xmm0
	addss	xmm1, DWORD PTR __real@3f800000
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	cvtps2pd xmm0, xmm1
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	ebx
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	mov	eax, DWORD PTR _values$1$[ebp]
	inc	ebx
	cmp	ebx, edi
	jl	$LL20@finalize
$LN19@finalize:

; 9083 :               (1.0F+mu/((float)(1<<11)))/((float)((kdu_uint32)(1<<eps))));
; 9084 :         }
; 9085 :       set_derived(Qabs_steps);

	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	mov	ecx, esi
	call	?set_derived@kdu_params@@QAEXPBD@Z	; kdu_params::set_derived

; 9086 :       delete[] values;

	push	DWORD PTR _values$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN53@finalize:

; 9087 :     }
; 9088 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?finalize@qcd_params@@MAEX_N@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@qcd_params@@MAEX_N@Z$1:
	lea	ecx, DWORD PTR _w$2[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__ehhandler$?finalize@qcd_params@@MAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-204]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?finalize@qcd_params@@MAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?finalize@qcd_params@@MAEX_N@Z ENDP			; qcd_params::finalize
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?new_object@qcd_params@@MAEPAVkdu_params@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_object@qcd_params@@MAEPAVkdu_params@@XZ PROC	; qcd_params::new_object, COMDAT
; _this$ = ecx

; 3403 :     virtual kdu_params *new_object() { return new qcd_params(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_object@qcd_params@@MAEPAVkdu_params@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_object
	mov	ecx, eax
	call	??0qcd_params@@QAE@XZ			; qcd_params::qcd_params
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_object:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_object@qcd_params@@MAEPAVkdu_params@@XZ$0:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?new_object@qcd_params@@MAEPAVkdu_params@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_object@qcd_params@@MAEPAVkdu_params@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_object@qcd_params@@MAEPAVkdu_params@@XZ ENDP	; qcd_params::new_object
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0qcd_params@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0qcd_params@@QAE@XZ PROC				; qcd_params::qcd_params, COMDAT
; _this$ = ecx

; 8431 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0qcd_params@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 8430 :   : kdu_params(QCD_params,true,true,false)

	push	0
	push	0
	push	0
	push	1
	push	1
	push	OFFSET ??_C@_03ELMDPBLM@QCD?$AA@
	call	??0kdu_params@@QAE@PBD_N1111@Z		; kdu_params::kdu_params

; 8432 :   add_dependency(COD_params);

	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7qcd_params@@6B@
	call	?add_dependency@kdu_params@@IAEXPBD@Z	; kdu_params::add_dependency

; 8433 :   add_dependency(ADS_params);

	push	OFFSET ??_C@_03BLBGDEDA@ADS?$AA@
	mov	ecx, esi
	call	?add_dependency@kdu_params@@IAEXPBD@Z	; kdu_params::add_dependency

; 8434 : 
; 8435 :   define_attribute(Qguard,

	push	0
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0IA@OLHAIOBI@Number?5of?5guard?5bits?5to?5prevent?5@
	push	OFFSET ??_C@_06BGIMBACE@Qguard?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 8436 :                    "Number of guard bits to prevent overflow in the magnitude "
; 8437 :                    "bit-plane representation. Typical values are 1 or 2.\n"
; 8438 :                    "\t\t[Default is 1]",
; 8439 :                    "I");
; 8440 :   define_attribute(Qderived,

	push	0
	push	OFFSET ??_C@_01HMGJMAIH@B?$AA@
	push	OFFSET ??_C@_0BIH@EIAIGKMJ@Quantization?5steps?5derived?5from?5@
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 8441 :                    "Quantization steps derived from LL band parameters? "
; 8442 :                    "If \"yes\", all quantization step sizes will be related "
; 8443 :                    "to the LL subband's step sizes through appropriate powers "
; 8444 :                    "of 2 and only the LL band step size will be written in "
; 8445 :                    "code-stream markers. Otherwise, a separate step size will "
; 8446 :                    "be recorded for every subband. You cannot use this option "
; 8447 :                    "with reversible compression.\n"
; 8448 :                    "\t\t[Default is not derived]",
; 8449 :                    "B");
; 8450 :   define_attribute(Qstep,

	push	0
	push	OFFSET ??_C@_01BIAFAFID@F?$AA@
	push	OFFSET ??_C@_0KK@JJMLLFOI@Base?5step?5size?5to?5be?5used?5in?5der@
	push	OFFSET ??_C@_05LCODFIOH@Qstep?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 8451 :                    "Base step size to be used in deriving irreversible "
; 8452 :                    "quantization step sizes for every subband. The base "
; 8453 :                    "step parameter should be in the range 0 to 2.\n"
; 8454 :                    "\t\t[Default is 1/256]",
; 8455 :                    "F");
; 8456 :   define_attribute(Qabs_steps,

	push	1
	push	OFFSET ??_C@_01BIAFAFID@F?$AA@
	push	OFFSET ??_C@_0DLI@DECHONMD@Absolute?5quantization?5step?5sizes@
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 8457 :                    "Absolute quantization step sizes for each subband, "
; 8458 :                    "expressed as a fraction of the nominal dynamic range "
; 8459 :                    "for that subband. The nominal range is equal to 2^B "
; 8460 :                    "(B is the image sample bit-depth) multiplied by "
; 8461 :                    "the DC gain of each low-pass subband analysis filter and "
; 8462 :                    "the AC gain of each high-pass subband analysis filter, "
; 8463 :                    "involved in the construction of the relevant subband. "
; 8464 :                    "The bands are described one by one, in the following "
; 8465 :                    "sequence: LL_D, HL_D, LH_D, ..., HL_1, LH_1, HH_1.  "
; 8466 :                    "Here, D denotes the number of DWT levels.  Also, note "
; 8467 :                    "that the actual set of subbands for which values "
; 8468 :                    "are provided depends upon the decomposition structure "
; 8469 :                    "identified via `Cdecomp'.  A single step size must "
; 8470 :                    "be supplied for every subband (there is no "
; 8471 :                    "extrapolation), except in the event that `Qderived' is "
; 8472 :                    "set to \"yes\" -- then, only one parameter is allowed, "
; 8473 :                    "corresponding to the LL_D subband.\n"
; 8474 :                    "\t\t[For compressors, the absolute "
; 8475 :                    "step sizes are ignored if `Qstep' has been used.]",
; 8476 :                    "F",MULTI_RECORD); // No extrapolation.
; 8477 :   define_attribute(Qabs_ranges,

	push	1
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0DGG@FMKFADLL@Number?5of?5range?5bits?5used?5to?5cod@
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 8478 :                    "Number of range bits used to code each subband during "
; 8479 :                    "reversible compression.  Subbands appear in the sequence, "
; 8480 :                    "LL_D, HL_D, LH_D, ..., HL_1, LH_1, HH_1, where D denotes "
; 8481 :                    "the number of DWT levels.  Note that the actual set of "
; 8482 :                    "subbands for which values are provided depends upon the "
; 8483 :                    "decomposition structure, identified via `Cdecomp'.  The "
; 8484 :                    "number of range bits for a reversibly compressed subband, "
; 8485 :                    "plus the number of guard bits (see `Qguard'), is equal "
; 8486 :                    "to 1 plus the number of magnitude bit-planes which are "
; 8487 :                    "used for coding its samples.\n"
; 8488 :                    "\t\t[For compressors, most users will accept the "
; 8489 :                    "default policy, which sets the number of range bits to "
; 8490 :                    "the smallest value which is guaranteed to avoid overflow "
; 8491 :                    "or underflow in the bit-plane representation, "
; 8492 :                    "assuming that the RCT (colour transform) is used.  If "
; 8493 :                    "explicit values are supplied, they must be given for "
; 8494 :                    "each and every subband.]",
; 8495 :                    "I",MULTI_RECORD); // No extrapolation.
; 8496 : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0qcd_params@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
__ehhandler$??0qcd_params@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0qcd_params@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0qcd_params@@QAE@XZ ENDP				; qcd_params::qcd_params
; Function compile flags: /Ogtp
;	COMDAT ??_Gdfs_params@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gdfs_params@@UAEPAXI@Z PROC				; dfs_params::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gdfs_params@@UAEPAXI@Z ENDP				; dfs_params::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1dfs_params@@UAE@XZ
_TEXT	SEGMENT
??1dfs_params@@UAE@XZ PROC				; dfs_params::~dfs_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1dfs_params@@UAE@XZ ENDP				; dfs_params::~dfs_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z
_TEXT	SEGMENT
_e$2 = -68						; size = 20
_e$3 = -48						; size = 20
_this$1$ = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_bp$ = 8						; size = 4
_code$ = 8						; size = 2
_byte$6 = 12						; size = 4
_num_bytes$ = 12					; size = 4
_num_codes$1$ = 16					; size = 4
_bytes$ = 16						; size = 4
_end$ = 20						; size = 4
_tpart_idx$ = 20					; size = 4
?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z PROC	; dfs_params::read_marker_segment, COMDAT
; _this$ = ecx

; 8327 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 8328 :   int n, val;
; 8329 :   kdu_byte *bp, *end;
; 8330 : 
; 8331 :   if ((tpart_idx != 0) || (tile_idx >= 0) || (comp_idx >= 0))

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	jne	$LN6@read_marke
	cmp	DWORD PTR [ebx+8], 0
	jge	$LN6@read_marke
	cmp	DWORD PTR [ebx+12], 0
	jge	$LN6@read_marke

; 8333 :   if ((code != KDU_DFS) || (num_bytes < 2))

	mov	eax, 65394				; 0000ff72H
	cmp	WORD PTR _code$[ebp], ax
	jne	$LN6@read_marke
	mov	ecx, DWORD PTR _num_bytes$[ebp]
	cmp	ecx, 2
	jl	$LN6@read_marke

; 8334 :     return false;
; 8335 : 
; 8336 :   bp = bytes;
; 8337 :   end = bp + num_bytes;

	mov	eax, DWORD PTR _bytes$[ebp]
	lea	edx, DWORD PTR [ecx+eax]

; 8338 : 
; 8339 :   int s_dfs = *(bp++);  s_dfs = (s_dfs << 8) + *(bp++);

	movzx	ecx, BYTE PTR [eax]
	lea	esi, DWORD PTR [eax+1]
	shl	ecx, 8
	movzx	eax, BYTE PTR [esi]
	inc	esi
	add	ecx, eax
	mov	DWORD PTR _end$[ebp], edx

; 8340 :   if ((s_dfs & 0x00FF) != inst_idx)

	movzx	eax, cl
	mov	DWORD PTR _bp$[ebp], esi
	cmp	eax, DWORD PTR [ebx+16]
	jne	$LN6@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8343 :   try {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN24@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T5[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN48@read_marke:
$LN24@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8346 :       for (n=0, bits_left=0; n < num_codes; n++)

	xor	ebx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
	mov	DWORD PTR _num_codes$1$[ebp], eax
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8346 :       for (n=0, bits_left=0; n < num_codes; n++)

	xor	edi, edi
	npad	1
$LL4@read_marke:
	cmp	ebx, eax
	jge	$LN3@read_marke

; 8347 :         {
; 8348 :           if (bits_left == 0)

	test	edi, edi
	jne	SHORT $LN45@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN31@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T4[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN49@read_marke:
$LN31@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8349 :             { byte = kdu_read(bp,end,1); bits_left=8; }

	mov	edi, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
	mov	DWORD PTR _byte$6[ebp], eax
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8349 :             { byte = kdu_read(bp,end,1); bits_left=8; }

	jmp	SHORT $LN11@read_marke
$LN45@read_marke:
	mov	eax, DWORD PTR _byte$6[ebp]
$LN11@read_marke:

; 8350 :           bits_left -= 2;

	sub	edi, 2

; 8351 :           val = (byte >> bits_left) & 3;

	mov	ecx, edi
	sar	eax, cl
	and	eax, 3

; 8352 :           if (val > 0)

	jle	SHORT $LN16@read_marke

; 8353 :             val = (val==1)?3:(val-1); // Deal with silly numbering

	cmp	eax, 1
	jne	SHORT $LN15@read_marke
	mov	eax, 3
	jmp	SHORT $LN16@read_marke
$LN15@read_marke:
	dec	eax
$LN16@read_marke:

; 8354 :           set(DSdfs,n,0,val);

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	edx, DWORD PTR _end$[ebp]
	inc	ebx
	mov	eax, DWORD PTR _num_codes$1$[ebp]
	jmp	SHORT $LL4@read_marke
__catch$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z$0:

; 8358 :     { KDU_ERROR(e,0x25050501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EH@IOANDJIM@Malformed?5DFS?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8358 :     { KDU_ERROR(e,0x25050501); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8361 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN22@read_marke
	ret	0
$LN22@read_marke:
	mov	esi, DWORD PTR _bp$[ebp]
	mov	edx, DWORD PTR _end$[ebp]
$LN3@read_marke:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 8362 :   if (bp != end)

	cmp	esi, edx
	je	SHORT $LN13@read_marke

; 8363 :     { KDU_ERROR(e,0x25050502); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0DF@LFCOMKDP@Malformed?5DFS?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8363 :     { KDU_ERROR(e,0x25050502); e <<

	mov	DWORD PTR __$EHRec$[ebp+12], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8365 :         << (int)(end-bp) <<

	mov	eax, DWORD PTR _end$[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	sub	eax, esi
	push	eax
	call	??6kdu_message@@QAEAAV0@H@Z		; kdu_message::operator<<
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@
	mov	ecx, eax
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8367 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN13@read_marke:

; 8368 : 
; 8369 :   return true;

	mov	al, 1

; 8370 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN6@read_marke:

; 8332 :     return false;

	xor	al, al

; 8370 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN47@read_marke:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z$3:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_marker_segment@dfs_params@@MAE_NGHQAEH@Z ENDP	; dfs_params::read_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?check_marker_segment@dfs_params@@MAE_NGHQAEAAH@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_c_idx$ = 20						; size = 4
?check_marker_segment@dfs_params@@MAE_NGHQAEAAH@Z PROC	; dfs_params::check_marker_segment, COMDAT
; _this$ = ecx

; 8312 : {

	push	ebp
	mov	ebp, esp

; 8313 :   if ((code != KDU_DFS) || (num_bytes < 2))

	mov	eax, 65394				; 0000ff72H
	cmp	WORD PTR _code$[ebp], ax
	jne	SHORT $LN3@check_mark
	cmp	DWORD PTR _num_bytes$[ebp], 2
	jl	SHORT $LN3@check_mark

; 8315 :   int s_dfs = *(bytes++);  s_dfs = (s_dfs << 8) + *(bytes++);
; 8316 :   c_idx = s_dfs & 0x00FF;

	mov	eax, DWORD PTR _bytes$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	eax, DWORD PTR _c_idx$[ebp]
	mov	DWORD PTR [eax], ecx

; 8317 :   return ((c_idx >= 1) && (c_idx <= 127));

	cmp	ecx, 1
	jl	SHORT $LN5@check_mark
	cmp	ecx, 127				; 0000007fH
	jg	SHORT $LN5@check_mark
	mov	eax, 1

; 8318 : }

	pop	ebp
	ret	16					; 00000010H
$LN5@check_mark:

; 8317 :   return ((c_idx >= 1) && (c_idx <= 127));

	xor	eax, eax

; 8318 : }

	pop	ebp
	ret	16					; 00000010H
$LN3@check_mark:

; 8314 :     return false;

	xor	al, al

; 8318 : }

	pop	ebp
	ret	16					; 00000010H
?check_marker_segment@dfs_params@@MAE_NGHQAEAAH@Z ENDP	; dfs_params::check_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?write_marker_segment@dfs_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
_length$1$ = -4						; size = 4
_n$2$ = 8						; size = 4
_out$ = 8						; size = 4
_last_marked$ = 12					; size = 4
_val$ = 16						; size = 4
_tpart_idx$ = 16					; size = 4
?write_marker_segment@dfs_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z PROC ; dfs_params::write_marker_segment, COMDAT
; _this$ = ecx

; 8379 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 8380 :   int n, val;
; 8381 : 
; 8382 :   if ((inst_idx < 1) || (inst_idx > 127) || (tpart_idx != 0) ||
; 8383 :       (comp_idx >= 0) || (tile_idx >= 0))

	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, 1
	jl	$LN9@write_mark
	cmp	eax, 127				; 0000007fH
	jg	$LN9@write_mark
	cmp	DWORD PTR _tpart_idx$[ebp], 0
	jne	$LN9@write_mark
	cmp	DWORD PTR [ebx+12], 0
	jge	$LN9@write_mark
	cmp	DWORD PTR [ebx+8], 0
	jge	$LN9@write_mark

; 8385 : 
; 8386 :   for (n=0; get(DSdfs,n,0,val,false,false); n++);

	push	edi
	push	1
	xor	edi, edi
	lea	eax, DWORD PTR _val$[ebp]
	push	edi
	push	edi
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN3@write_mark
	npad	6
$LL4@write_mark:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _val$[ebp]
	inc	edi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL4@write_mark
$LN3@write_mark:

; 8387 :   int num_codes = n;
; 8388 : 
; 8389 :   int length = 7 + ((num_codes+3)>>2);

	lea	eax, DWORD PTR [edi+3]
	sar	eax, 2
	push	esi

; 8390 :   if (out == NULL)

	mov	esi, DWORD PTR _out$[ebp]
	add	eax, 7
	mov	DWORD PTR _length$1$[ebp], eax
	test	esi, esi
	je	$LN32@write_mark

; 8391 :     return length;
; 8392 : 
; 8393 :   kdu_byte byte, bits_left;
; 8394 :   int acc_length = 0;
; 8395 : 
; 8396 :   acc_length += out->put(KDU_DFS);

	push	65394					; 0000ff72H
	mov	ecx, esi
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 8397 :   acc_length += out->put((kdu_uint16)(length-2));

	mov	eax, DWORD PTR _length$1$[ebp]
	mov	ecx, esi
	add	eax, -2					; fffffffeH
	push	eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 8398 :   acc_length += out->put((kdu_uint16) inst_idx);

	movzx	eax, WORD PTR [ebx+16]
	mov	ecx, esi
	push	eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 8399 :   acc_length += out->put((kdu_byte) num_codes);

	push	edi
	mov	ecx, esi
	call	?put@kdu_output@@QAEHE@Z		; kdu_output::put

; 8400 :   for (byte=0, bits_left=8, n=0; n < num_codes; n++)

	xor	eax, eax
	xor	bh, bh
	mov	DWORD PTR _n$2$[ebp], eax
	mov	bl, 8
	test	edi, edi
	jle	$LN13@write_mark
$LL7@write_mark:

; 8401 :     {
; 8402 :       get(DSdfs,n,0,val);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	0
	push	eax
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 8403 :       if (val > 0)

	mov	edx, DWORD PTR _val$[ebp]
	test	edx, edx
	jle	SHORT $LN16@write_mark

; 8404 :         val = (val==3)?1:(val+1); // Deal with silly numbering

	cmp	edx, 3
	lea	eax, DWORD PTR [edx+1]
	mov	ecx, 1
	cmove	eax, ecx
	mov	edx, eax
	mov	DWORD PTR _val$[ebp], edx
$LN16@write_mark:

; 8405 :       bits_left -= 2;

	add	bl, 254					; 000000feH

; 8406 :       byte |= (kdu_byte)(val << bits_left);

	mov	cl, bl
	shl	dl, cl
	or	bh, dl

; 8407 :       if (bits_left == 0)

	test	bl, bl
	jne	SHORT $LN5@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN18@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN18@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8410 :           byte = 0; bits_left = 8;

	mov	bl, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], bh
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8410 :           byte = 0; bits_left = 8;

	xor	bh, bh
$LN5@write_mark:

; 8400 :   for (byte=0, bits_left=8, n=0; n < num_codes; n++)

	mov	eax, DWORD PTR _n$2$[ebp]
	inc	eax
	mov	DWORD PTR _n$2$[ebp], eax
	cmp	eax, edi
	jl	SHORT $LL7@write_mark

; 8411 :         }
; 8412 :     }
; 8413 :   if (bits_left < 8)

	cmp	bl, 8
	jae	SHORT $LN13@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN21@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN21@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bh
	inc	DWORD PTR [esi+516]
$LN13@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8417 :   return length;

	mov	eax, DWORD PTR _length$1$[ebp]
$LN32@write_mark:
	pop	esi
	pop	edi
	pop	ebx

; 8418 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN9@write_mark:

; 8384 :     return 0;

	xor	eax, eax
	pop	ebx

; 8418 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?write_marker_segment@dfs_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ENDP ; dfs_params::write_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?copy_with_xforms@dfs_params@@MAEXPAVkdu_params@@HH_N11@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_transpose$ = 20					; size = 1
_vflip$ = 24						; size = 1
_hflip$ = 28						; size = 1
?copy_with_xforms@dfs_params@@MAEXPAVkdu_params@@HH_N11@Z PROC ; dfs_params::copy_with_xforms, COMDAT
; _this$ = ecx

; 3308 :       { return; }

	ret	24					; 00000018H
?copy_with_xforms@dfs_params@@MAEXPAVkdu_params@@HH_N11@Z ENDP ; dfs_params::copy_with_xforms
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?finalize@dfs_params@@MAEX_N@Z
_TEXT	SEGMENT
_e$2 = -52						; size = 20
_e$3 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_val$ = 8						; size = 4
_after_reading$ = 8					; size = 1
?finalize@dfs_params@@MAEX_N@Z PROC			; dfs_params::finalize, COMDAT
; _this$ = ecx

; 8284 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?finalize@dfs_params@@MAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 8285 :   if (after_reading)

	cmp	BYTE PTR _after_reading$[ebp], 0
	jne	$LN3@finalize

; 8286 :     return;
; 8287 :   int n, val;
; 8288 :   for (n=0; get(DSdfs,n,0,val,false,false,false); n++)

	xor	esi, esi
	lea	eax, DWORD PTR _val$[ebp]
	push	esi
	push	esi
	push	esi
	push	eax
	push	esi
	push	esi
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN3@finalize
$LL4@finalize:

; 8289 :     {
; 8290 :       if ((inst_idx < 1) || (inst_idx > 127))

	mov	eax, DWORD PTR [edi+16]
	cmp	eax, 1
	jl	SHORT $LN7@finalize
	cmp	eax, 127				; 0000007fH
	jle	SHORT $LN6@finalize
$LN7@finalize:

; 8291 :         { KDU_ERROR(e,0x2604050a) e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0KI@NOLDCDIM@The?5?$GADSdfs?8?5attribute?5may?5be?5def@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8291 :         { KDU_ERROR(e,0x2604050a) e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8296 :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN6@finalize:

; 8297 :       if ((val < 0) || (val > 3))

	mov	eax, DWORD PTR _val$[ebp]
	test	eax, eax
	js	SHORT $LN9@finalize
	cmp	eax, 3
	jle	SHORT $LN2@finalize
$LN9@finalize:

; 8298 :         { KDU_ERROR(e,0x25050500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0FI@CMPAFODD@Illegal?5?$GADSdfs?8?5attribute?5value?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8298 :         { KDU_ERROR(e,0x25050500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8301 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@finalize:

; 8286 :     return;
; 8287 :   int n, val;
; 8288 :   for (n=0; get(DSdfs,n,0,val,false,false,false); n++)

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _val$[ebp]
	inc	esi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL4@finalize
$LN3@finalize:

; 8302 :     }
; 8303 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?finalize@dfs_params@@MAEX_N@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@dfs_params@@MAEX_N@Z$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?finalize@dfs_params@@MAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?finalize@dfs_params@@MAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?finalize@dfs_params@@MAEX_N@Z ENDP			; dfs_params::finalize
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?new_object@dfs_params@@MAEPAVkdu_params@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_object@dfs_params@@MAEPAVkdu_params@@XZ PROC	; dfs_params::new_object, COMDAT
; _this$ = ecx

; 3302 :     virtual kdu_params *new_object() { return new dfs_params(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_object@dfs_params@@MAEPAVkdu_params@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_object
	mov	ecx, eax
	call	??0dfs_params@@QAE@XZ			; dfs_params::dfs_params
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_object:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_object@dfs_params@@MAEPAVkdu_params@@XZ$0:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?new_object@dfs_params@@MAEPAVkdu_params@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_object@dfs_params@@MAEPAVkdu_params@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_object@dfs_params@@MAEPAVkdu_params@@XZ ENDP	; dfs_params::new_object
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0dfs_params@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0dfs_params@@QAE@XZ PROC				; dfs_params::dfs_params, COMDAT
; _this$ = ecx

; 8257 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0dfs_params@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 8256 :   : kdu_params(DFS_params,false,false,true,false,true)

	push	1
	push	0
	push	1
	push	0
	push	0
	push	OFFSET ??_C@_03CPEMBAGM@DFS?$AA@
	call	??0kdu_params@@QAE@PBD_N1111@Z		; kdu_params::kdu_params

; 8258 :   define_attribute(DSdfs,

	push	3
	push	OFFSET ??_C@_0BC@GOBGDILI@?$CIX?$DN0?0H?$DN1?0V?$DN2?0B?$DN3?$CJ?$AA@
	push	OFFSET ??_C@_0DBH@IBFFCHEI@Describes?5the?5primary?5subband?5de@
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7dfs_params@@6B@
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 8259 :                    "Describes the primary subband decomposition type "
; 8260 :                    "associated with each DWT level, starting from the "
; 8261 :                    "highest resolution (1'st level).  The value may be one "
; 8262 :                    "of `B' (split in both directions), `H' (split "
; 8263 :                    "horizontally), `V' (split vertically) or `X' (don't "
; 8264 :                    "split at all).  The last case is degenerate, since "
; 8265 :                    "it means that the DWT level in question produces no "
; 8266 :                    "detail subbands whatsoever, simply passing its input "
; 8267 :                    "image through to the next DWT level.  However, this can "
; 8268 :                    "be useful in some circumstances.  The primary subband "
; 8269 :                    "decomposition determines the downsampling factors "
; 8270 :                    "between each successive resolution level.  If there are "
; 8271 :                    "more DWT levels than `DSdfs' values, the last available "
; 8272 :                    "value is replicated, as required.\n"
; 8273 :                    "\t\t[You would not normally set values for this parameter "
; 8274 :                    "attribute yourself.]",
; 8275 :                    "(X=0,H=1,V=2,B=3)", MULTI_RECORD | CAN_EXTRAPOLATE);
; 8276 : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0dfs_params@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
__ehhandler$??0dfs_params@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0dfs_params@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0dfs_params@@QAE@XZ ENDP				; dfs_params::dfs_params
; Function compile flags: /Ogtp
;	COMDAT ??_Gads_params@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gads_params@@UAEPAXI@Z PROC				; ads_params::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gads_params@@UAEPAXI@Z ENDP				; ads_params::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1ads_params@@UAE@XZ
_TEXT	SEGMENT
??1ads_params@@UAE@XZ PROC				; ads_params::~ads_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1ads_params@@UAE@XZ ENDP				; ads_params::~ads_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?custom_textualize_field@ads_params@@MAEXAAVkdu_message@@PBDHH@Z
_TEXT	SEGMENT
_buf$1 = -28						; size = 21
__$ArrayPad$ = -4					; size = 4
_output$ = 8						; size = 4
_name$ = 12						; size = 4
_field_idx$ = 16					; size = 4
_val$ = 20						; size = 4
?custom_textualize_field@ads_params@@MAEXAAVkdu_message@@PBDHH@Z PROC ; ads_params::custom_textualize_field, COMDAT
; _this$ = ecx

; 8237 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8238 :   if ((strcmp(name,Ddecomp) == 0) && (field_idx == 0))

	mov	eax, DWORD PTR _name$[ebp]
	mov	ecx, OFFSET ??_C@_07MCCNNBND@Ddecomp?$AA@
	push	esi
	mov	esi, DWORD PTR _output$[ebp]
	npad	4
$LL6@custom_tex:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN7@custom_tex
	test	dl, dl
	je	SHORT $LN8@custom_tex
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN7@custom_tex
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL6@custom_tex
$LN8@custom_tex:
	xor	eax, eax
	jmp	SHORT $LN9@custom_tex
$LN7@custom_tex:
	sbb	eax, eax
	or	eax, 1
$LN9@custom_tex:
	test	eax, eax
	jne	SHORT $LN2@custom_tex
	cmp	DWORD PTR _field_idx$[ebp], eax
	jne	SHORT $LN2@custom_tex

; 8241 :       cod_params::textualize_decomp(buf,val);

	push	DWORD PTR _val$[ebp]
	lea	eax, DWORD PTR _buf$1[ebp]
	push	eax
	call	?textualize_decomp@cod_params@@SAXQADH@Z ; cod_params::textualize_decomp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _buf$1[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8241 :       cod_params::textualize_decomp(buf,val);

	add	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]
$LN2@custom_tex:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8244 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?custom_textualize_field@ads_params@@MAEXAAVkdu_message@@PBDHH@Z ENDP ; ads_params::custom_textualize_field
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?read_marker_segment@ads_params@@MAE_NGHQAEH@Z
_TEXT	SEGMENT
_e$2 = -176						; size = 20
_e$3 = -156						; size = 20
$T4 = -136						; size = 4
$T5 = -132						; size = 4
$T6 = -128						; size = 4
$T7 = -124						; size = 4
_this$GSCopy$1$ = -120					; size = 4
_num_codes$1$ = -116					; size = 4
_num_theta$1$ = -116					; size = 4
_byte$8 = -112						; size = 4
_end$ = -108						; size = 4
_bp$ = -104						; size = 4
_text$9 = -100						; size = 80
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_tpart_idx$ = 20					; size = 4
?read_marker_segment@ads_params@@MAE_NGHQAEH@Z PROC	; ads_params::read_marker_segment, COMDAT
; _this$ = ecx

; 8175 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], edx

; 8176 :   int n, val;
; 8177 :   kdu_byte *bp, *end;
; 8178 : 
; 8179 :   if (tpart_idx != 0)

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	mov	eax, DWORD PTR _num_bytes$[ebp]
	mov	esi, DWORD PTR _bytes$[ebp]
	jne	$LN10@read_marke

; 8180 :     return false;
; 8181 :   if ((code != KDU_ADS) || (num_bytes < 2))

	mov	ecx, 65395				; 0000ff73H
	cmp	WORD PTR _code$[ebp], cx
	jne	$LN10@read_marke
	cmp	eax, 2
	jl	$LN10@read_marke

; 8183 : 
; 8184 :   bp = bytes;
; 8185 :   end = bp + num_bytes;

	lea	ecx, DWORD PTR [esi+eax]

; 8186 : 
; 8187 :   int which_inst = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
	mov	DWORD PTR _end$[ebp], ecx
	mov	DWORD PTR _bp$[ebp], esi

; 8188 :   if (which_inst != inst_idx)

	cmp	eax, DWORD PTR [edx+16]
	jne	$LN10@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8191 :   try {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN27@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T7[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN69@read_marke:
$LN27@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8194 :       for (n=0, bits_left=0; n < num_theta; n++)

	xor	ebx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
	mov	DWORD PTR _num_theta$1$[ebp], eax
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8194 :       for (n=0, bits_left=0; n < num_theta; n++)

	xor	edi, edi
$LL4@read_marke:
	cmp	ebx, eax
	jge	SHORT $LN3@read_marke

; 8195 :         {
; 8196 :           if (bits_left == 0)

	test	edi, edi
	jne	SHORT $LN65@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ecx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN34@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T6[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN70@read_marke:
$LN34@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8197 :             { byte = kdu_read(bp,end,1); bits_left=8; }

	mov	edi, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
	mov	DWORD PTR _byte$8[ebp], eax
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8197 :             { byte = kdu_read(bp,end,1); bits_left=8; }

	jmp	SHORT $LN13@read_marke
$LN65@read_marke:
	mov	eax, DWORD PTR _byte$8[ebp]
$LN13@read_marke:

; 8198 :           bits_left -= 2;

	sub	edi, 2

; 8199 :           val = (byte >> bits_left) & 3;

	mov	ecx, edi
	sar	eax, cl

; 8200 :           set(DOads,n,0,val);

	mov	ecx, edx
	and	eax, 3
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	ecx, DWORD PTR _end$[ebp]
	inc	ebx
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR _num_theta$1$[ebp]
	jmp	SHORT $LL4@read_marke
$LN3@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ecx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN40@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T5[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN71@read_marke:
$LN40@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8204 :       for (n=0, bits_left=0; n < num_codes; n++)

	xor	ebx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
	mov	DWORD PTR _num_codes$1$[ebp], eax
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8204 :       for (n=0, bits_left=0; n < num_codes; n++)

	xor	edi, edi
	npad	3
$LL7@read_marke:
	cmp	ebx, eax
	jge	$LN6@read_marke

; 8205 :         {
; 8206 :           if (bits_left == 0)

	test	edi, edi
	jne	SHORT $LN66@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ecx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN46@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T4[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN72@read_marke:
$LN46@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8207 :             { byte = kdu_read(bp,end,1); bits_left=8; }

	mov	edi, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
	mov	DWORD PTR _byte$8[ebp], eax
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8207 :             { byte = kdu_read(bp,end,1); bits_left=8; }

	jmp	SHORT $LN14@read_marke
$LN66@read_marke:
	mov	eax, DWORD PTR _byte$8[ebp]
$LN14@read_marke:

; 8208 :           bits_left -= 2;

	sub	edi, 2

; 8209 :           val = (byte >> bits_left) & 3;

	mov	ecx, edi
	sar	eax, cl
	and	eax, 3

; 8210 :           if (val > 0)

	jle	SHORT $LN19@read_marke

; 8211 :             val = (val==1)?3:(val-1); // Deal with silly numbering

	cmp	eax, 1
	jne	SHORT $LN18@read_marke
	mov	eax, 3
	jmp	SHORT $LN19@read_marke
$LN18@read_marke:
	dec	eax
$LN19@read_marke:

; 8212 :           set(DSads,n,0,val);

	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	mov	ecx, edx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	ecx, DWORD PTR _end$[ebp]
	inc	ebx
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR _num_codes$1$[ebp]
	jmp	SHORT $LL7@read_marke
__catch$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z$0:

; 8216 :     { KDU_ERROR(e,0x26040503); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EH@JBFCFNFB@Malformed?5ADS?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8216 :     { KDU_ERROR(e,0x26040503); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8219 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN25@read_marke
	ret	0
$LN25@read_marke:
	mov	esi, DWORD PTR _bp$[ebp]
	mov	ecx, DWORD PTR _end$[ebp]
$LN6@read_marke:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 8220 :   if (bp != end)

	cmp	esi, ecx
	je	$LN16@read_marke

; 8221 :     { KDU_ERROR(e,0x26040504); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0DF@KMABOOPE@Malformed?5ADS?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8221 :     { KDU_ERROR(e,0x26040504); e <<

	mov	DWORD PTR __$EHRec$[ebp+12], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8223 :         << (int)(end-bp) <<

	mov	eax, DWORD PTR _end$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8223 :         << (int)(end-bp) <<

	sub	eax, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$3[ebp+4], 0
	push	eax
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$9[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$9[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8225 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN16@read_marke:

; 8226 : 
; 8227 :   return true;

	mov	al, 1
	jmp	SHORT $LN1@read_marke
$LN10@read_marke:

; 8182 :     return false;

	xor	al, al
$LN1@read_marke:

; 8228 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN68@read_marke:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z$3:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-180]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_marker_segment@ads_params@@MAE_NGHQAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_marker_segment@ads_params@@MAE_NGHQAEH@Z ENDP	; ads_params::read_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?check_marker_segment@ads_params@@MAE_NGHQAEAAH@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_c_idx$ = 20						; size = 4
?check_marker_segment@ads_params@@MAE_NGHQAEAAH@Z PROC	; ads_params::check_marker_segment, COMDAT
; _this$ = ecx

; 8161 : {

	push	ebp
	mov	ebp, esp

; 8162 :   if ((code != KDU_ADS) || (num_bytes < 1))

	mov	eax, 65395				; 0000ff73H
	cmp	WORD PTR _code$[ebp], ax
	jne	SHORT $LN3@check_mark
	cmp	DWORD PTR _num_bytes$[ebp], 1
	jl	SHORT $LN3@check_mark

; 8164 :   c_idx = *bytes;

	mov	eax, DWORD PTR _bytes$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	eax, DWORD PTR _c_idx$[ebp]
	mov	DWORD PTR [eax], ecx

; 8165 :   return ((c_idx >= 1) && (c_idx <= 127));

	cmp	ecx, 1
	jl	SHORT $LN5@check_mark
	cmp	ecx, 127				; 0000007fH
	jg	SHORT $LN5@check_mark
	mov	eax, 1

; 8166 : }

	pop	ebp
	ret	16					; 00000010H
$LN5@check_mark:

; 8165 :   return ((c_idx >= 1) && (c_idx <= 127));

	xor	eax, eax

; 8166 : }

	pop	ebp
	ret	16					; 00000010H
$LN3@check_mark:

; 8163 :     return false;

	xor	al, al

; 8166 : }

	pop	ebp
	ret	16					; 00000010H
?check_marker_segment@ads_params@@MAE_NGHQAEAAH@Z ENDP	; ads_params::check_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?write_marker_segment@ads_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
_TEXT	SEGMENT
_length$1$ = -12					; size = 4
_num_codes$1$ = -8					; size = 4
_val$ = -4						; size = 4
_n$6$ = 8						; size = 4
_n$5$ = 8						; size = 4
_out$ = 8						; size = 4
_word$1$ = 12						; size = 4
_num_theta$1$ = 12					; size = 4
_last_marked$ = 12					; size = 4
_byte$1$ = 15						; size = 1
_byte$2$ = 15						; size = 1
_byte$1$ = 15						; size = 1
_val$1 = 16						; size = 4
_val$2 = 16						; size = 4
_val$3 = 16						; size = 4
_val$4 = 16						; size = 4
_tpart_idx$ = 16					; size = 4
_bits_left$2$ = 19					; size = 1
_bits_left$1$ = 19					; size = 1
?write_marker_segment@ads_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z PROC ; ads_params::write_marker_segment, COMDAT
; _this$ = ecx

; 8073 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	edi
	mov	edi, ecx

; 8074 :   ads_params *ref = (ads_params *) last_marked;
; 8075 :   int n, val;
; 8076 : 
; 8077 :   if ((inst_idx < 1) || (inst_idx > 127) || (tpart_idx != 0) ||

	mov	eax, DWORD PTR [edi+16]
	cmp	eax, 1
	jl	$LN27@write_mark
	cmp	eax, 127				; 0000007fH
	jg	$LN27@write_mark
	cmp	DWORD PTR _tpart_idx$[ebp], 0
	jne	$LN27@write_mark
	cmp	DWORD PTR [edi+12], 0
	jge	$LN27@write_mark

; 8080 : 
; 8081 :   if (ref != NULL)

	cmp	DWORD PTR _last_marked$[ebp], 0
	push	ebx
	push	esi
	je	$LN29@write_mark

; 8085 :       for (n=0; identical && get(DOads,n,0,val,false,false); n++)

	xor	esi, esi
$LN163@write_mark:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	mov	bl, 1
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LL147@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, DWORD PTR _last_marked$[ebp]
	lea	eax, DWORD PTR _val$4[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8086 :         identical = ref->compare(DOads,n,0,val);

	mov	ebx, DWORD PTR _val$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	push	1
	push	1
	push	1
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN46@write_mark
	cmp	DWORD PTR _val$4[ebp], ebx
	jne	SHORT $LN46@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8085 :       for (n=0; identical && get(DOads,n,0,val,false,false); n++)

	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	jmp	SHORT $LN163@write_mark
$LL147@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8087 :       for (; identical && ref->get(DOads,n,0,val,false,false); n++)

	mov	ecx, DWORD PTR _last_marked$[ebp]
	lea	eax, DWORD PTR _val$[ebp]
	push	1
	push	0
	push	0
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN6@write_mark

; 8088 :         identical = compare(DOads,n,0,val);

	mov	ebx, DWORD PTR _val$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$3[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN46@write_mark
	cmp	DWORD PTR _val$3[ebp], ebx
	jne	SHORT $LN46@write_mark
	mov	bl, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8087 :       for (; identical && ref->get(DOads,n,0,val,false,false); n++)

	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	jmp	SHORT $LL147@write_mark
$LN46@write_mark:
	xor	bl, bl
$LN6@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8089 :       for (n=0; identical && get(DSads,n,0,val,false,false); n++)

	xor	esi, esi
	test	bl, bl
	je	$LN29@write_mark
	npad	4
$LL10@write_mark:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN9@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, DWORD PTR _last_marked$[ebp]
	lea	eax, DWORD PTR _val$2[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8090 :         identical = ref->compare(DSads,n,0,val);

	mov	ebx, DWORD PTR _val$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	push	1
	push	1
	push	1
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN29@write_mark
	cmp	DWORD PTR _val$2[ebp], ebx
	jne	SHORT $LN29@write_mark
	mov	bl, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8089 :       for (n=0; identical && get(DSads,n,0,val,false,false); n++)

	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	jmp	SHORT $LL10@write_mark
$LN9@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8091 :       for (; identical && ref->get(DSads,n,0,val,false,false); n++)

	test	bl, bl
	je	SHORT $LN29@write_mark
	npad	4
$LL13@write_mark:
	mov	ecx, DWORD PTR _last_marked$[ebp]
	lea	eax, DWORD PTR _val$[ebp]
	push	1
	push	0
	push	0
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN12@write_mark

; 8092 :         identical = compare(DSads,n,0,val);

	mov	ebx, DWORD PTR _val$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$1[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN29@write_mark
	cmp	DWORD PTR _val$1[ebp], ebx
	jne	SHORT $LN29@write_mark
	mov	bl, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8091 :       for (; identical && ref->get(DSads,n,0,val,false,false); n++)

	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	jmp	SHORT $LL13@write_mark
$LN12@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8093 :       if (identical)

	test	bl, bl
	jne	$LN164@write_mark
$LN29@write_mark:

; 8094 :         return 0;
; 8095 :     }
; 8096 : 
; 8097 :   for (n=0; get(DOads,n,0,val,false,false); n++);

	push	1
	xor	ebx, ebx
	lea	eax, DWORD PTR _val$[ebp]
	push	ebx
	push	ebx
	push	eax
	push	ebx
	push	ebx
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	mov	ecx, edi
	mov	DWORD PTR _num_theta$1$[ebp], ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN15@write_mark
	npad	1
$LL16@write_mark:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _val$[ebp]
	inc	ebx
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL16@write_mark
	mov	DWORD PTR _num_theta$1$[ebp], ebx
$LN15@write_mark:

; 8098 :   int num_theta = n;
; 8099 : 
; 8100 :   for (n=0; get(DSads,n,0,val,false,false); n++);

	push	1
	xor	esi, esi
	lea	eax, DWORD PTR _val$[ebp]
	push	esi
	push	esi
	push	eax
	push	esi
	push	esi
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	mov	ecx, edi
	mov	DWORD PTR _num_codes$1$[ebp], esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN18@write_mark
	xor	ebx, ebx
$LL19@write_mark:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _val$[ebp]
	inc	ebx
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL19@write_mark
	mov	DWORD PTR _num_codes$1$[ebp], ebx
	mov	ebx, DWORD PTR _num_theta$1$[ebp]
	mov	esi, DWORD PTR _num_codes$1$[ebp]
$LN18@write_mark:

; 8101 :   int num_codes = n;
; 8102 : 
; 8103 :   if ((num_theta == 0) && (num_codes == 0))

	test	ebx, ebx
	jne	SHORT $LN30@write_mark
	test	esi, esi
	jne	SHORT $LN30@write_mark
$LN164@write_mark:

; 8104 :     return 0; // Nothing to write

	xor	eax, eax
$LN161@write_mark:
	pop	esi
	pop	ebx
	pop	edi

; 8152 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN30@write_mark:

; 8105 : 
; 8106 : 
; 8107 :   int length = 7 + ((num_theta+3)>>2) + ((num_codes+3)>>2);

	lea	eax, DWORD PTR [esi+3]

; 8108 :   if (out == NULL)

	mov	esi, DWORD PTR _out$[ebp]
	sar	eax, 2
	lea	ecx, DWORD PTR [ebx+3]
	sar	ecx, 2
	add	eax, 7
	add	eax, ecx
	mov	DWORD PTR _length$1$[ebp], eax
	test	esi, esi
	je	SHORT $LN161@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN59@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN59@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN62@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN62@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 115			; 00000073H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8115 :   acc_length += out->put((kdu_uint16)(length-2));

	mov	eax, DWORD PTR _length$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8115 :   acc_length += out->put((kdu_uint16)(length-2));

	add	eax, -2					; fffffffeH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8115 :   acc_length += out->put((kdu_uint16)(length-2));

	movzx	eax, ax
	mov	DWORD PTR _word$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [esi+520]
	jne	SHORT $LN67@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _word$1$[ebp]
$LN67@write_mark:

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, eax

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN70@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN70@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR _word$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8116 :   acc_length += out->put((kdu_byte) inst_idx);

	mov	cl, BYTE PTR [edi+16]
	mov	BYTE PTR _byte$1$[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN73@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	cl, BYTE PTR _byte$1$[ebp]
$LN73@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN76@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN76@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8119 :   for (byte=0, bits_left=8, n=0; n < num_theta; n++)

	xor	cl, cl
	mov	BYTE PTR _byte$1$[ebp], cl
	mov	BYTE PTR _bits_left$1$[ebp], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], bl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8119 :   for (byte=0, bits_left=8, n=0; n < num_theta; n++)

	xor	eax, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8119 :   for (byte=0, bits_left=8, n=0; n < num_theta; n++)

	mov	DWORD PTR _n$5$[ebp], eax
	test	ebx, ebx
	jle	$LN33@write_mark
$LL22@write_mark:

; 8120 :     {
; 8121 :       get(DOads,n,0,val);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _val$[ebp]
	push	ecx
	push	0
	push	eax
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 8122 :       bits_left -= 2;

	mov	cl, BYTE PTR _bits_left$1$[ebp]

; 8123 :       byte |= (kdu_byte)(val << bits_left);

	mov	al, BYTE PTR _val$[ebp]
	add	cl, 254					; 000000feH
	mov	dl, BYTE PTR _byte$1$[ebp]
	shl	al, cl
	or	dl, al
	mov	BYTE PTR _bits_left$1$[ebp], cl
	mov	BYTE PTR _byte$1$[ebp], dl

; 8124 :       if (bits_left == 0)

	test	cl, cl
	jne	SHORT $LN20@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN79@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	dl, BYTE PTR _byte$1$[ebp]
$LN79@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8127 :           byte = 0; bits_left = 8;

	mov	cl, 8
	mov	BYTE PTR _byte$1$[ebp], 0
	mov	BYTE PTR _bits_left$1$[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], dl
	inc	DWORD PTR [esi+516]
$LN20@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8119 :   for (byte=0, bits_left=8, n=0; n < num_theta; n++)

	mov	eax, DWORD PTR _n$5$[ebp]
	inc	eax
	mov	DWORD PTR _n$5$[ebp], eax
	cmp	eax, ebx
	jl	SHORT $LL22@write_mark

; 8128 :         }
; 8129 :     }
; 8130 :   if (bits_left < 8)

	cmp	cl, 8
	jae	SHORT $LN33@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN82@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN82@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
$LN33@write_mark:

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN85@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN85@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8134 :   for (byte=0, bits_left=8, n=0; n < num_codes; n++)

	xor	cl, cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ebx, DWORD PTR _num_codes$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8134 :   for (byte=0, bits_left=8, n=0; n < num_codes; n++)

	mov	BYTE PTR _byte$2$[ebp], cl
	xor	ecx, ecx
	mov	BYTE PTR _bits_left$2$[ebp], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8134 :   for (byte=0, bits_left=8, n=0; n < num_codes; n++)

	mov	DWORD PTR _n$6$[ebp], ecx
	test	ebx, ebx
	jle	$LN36@write_mark
$LL25@write_mark:

; 8135 :     {
; 8136 :       get(DSads,n,0,val);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	0
	push	ecx
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 8137 :       if (val > 0)

	mov	edx, DWORD PTR _val$[ebp]
	test	edx, edx
	jle	SHORT $LN39@write_mark

; 8138 :         val = (val==3)?1:(val+1); // Deal with silly numbering

	cmp	edx, 3
	lea	eax, DWORD PTR [edx+1]
	mov	ecx, 1
	cmove	eax, ecx
	mov	edx, eax
	mov	DWORD PTR _val$[ebp], edx
$LN39@write_mark:

; 8139 :       bits_left -= 2;

	mov	al, BYTE PTR _bits_left$2$[ebp]
	add	al, 254					; 000000feH

; 8140 :       byte |= (kdu_byte)(val << bits_left);

	mov	cl, al
	mov	BYTE PTR _bits_left$2$[ebp], al
	shl	dl, cl
	or	BYTE PTR _byte$2$[ebp], dl

; 8141 :       if (bits_left == 0)

	test	al, al
	jne	SHORT $LN23@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN88@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN88@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	cl, BYTE PTR _byte$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8144 :           byte = 0; bits_left = 8;

	mov	BYTE PTR _byte$2$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8144 :           byte = 0; bits_left = 8;

	mov	al, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8144 :           byte = 0; bits_left = 8;

	mov	BYTE PTR _bits_left$2$[ebp], al
$LN23@write_mark:

; 8134 :   for (byte=0, bits_left=8, n=0; n < num_codes; n++)

	mov	ecx, DWORD PTR _n$6$[ebp]
	inc	ecx
	mov	DWORD PTR _n$6$[ebp], ecx
	cmp	ecx, ebx
	jl	SHORT $LL25@write_mark

; 8145 :         }
; 8146 :     }
; 8147 :   if (bits_left < 8)

	cmp	al, 8
	jae	SHORT $LN36@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN91@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN91@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	cl, BYTE PTR _byte$2$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
$LN36@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8151 :   return length;

	mov	eax, DWORD PTR _length$1$[ebp]
	pop	esi
	pop	ebx
	pop	edi

; 8152 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN27@write_mark:

; 8078 :       (comp_idx >= 0))
; 8079 :     return 0;

	xor	eax, eax
	pop	edi

; 8152 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?write_marker_segment@ads_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ENDP ; ads_params::write_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?copy_with_xforms@ads_params@@MAEXPAVkdu_params@@HH_N11@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_transpose$ = 20					; size = 1
_vflip$ = 24						; size = 1
_hflip$ = 28						; size = 1
?copy_with_xforms@ads_params@@MAEXPAVkdu_params@@HH_N11@Z PROC ; ads_params::copy_with_xforms, COMDAT
; _this$ = ecx

; 3238 :       { return; }

	ret	24					; 00000018H
?copy_with_xforms@ads_params@@MAEXPAVkdu_params@@HH_N11@Z ENDP ; ads_params::copy_with_xforms
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?finalize@ads_params@@MAEX_N@Z
_TEXT	SEGMENT
_e$2 = -168						; size = 20
_sub_val$1$ = -148					; size = 4
_e$3 = -144						; size = 20
tv510 = -124						; size = 4
_k$1$ = -120						; size = 4
_sub_levs$1$ = -116					; size = 4
_num_primary_bands$4 = -112				; size = 4
_n$1$ = -108						; size = 4
_this$GSCopy$1$ = -104					; size = 4
_val$ = -100						; size = 4
_text$5 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_after_reading$ = 8					; size = 1
?finalize@ads_params@@MAEX_N@Z PROC			; ads_params::finalize, COMDAT
; _this$ = ecx

; 7973 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?finalize@ads_params@@MAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx

; 7974 :   if (after_reading)

	cmp	BYTE PTR _after_reading$[ebp], 0
	jne	$LN3@finalize

; 7975 :     return;
; 7976 : 
; 7977 :   int n, k, val;
; 7978 :   int code_idx=0; // Index of next splitting code to be written to `DSads'.

	xor	esi, esi

; 7979 :   for (n=0; get(Ddecomp,n,0,val,false,false,false); n++)

	lea	eax, DWORD PTR _val$[ebp]
	push	esi
	push	esi
	push	esi
	push	eax
	push	esi
	push	esi
	push	OFFSET ??_C@_07MCCNNBND@Ddecomp?$AA@
	mov	DWORD PTR _n$1$[ebp], esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN3@finalize
	npad	3
$LL4@finalize:

; 7980 :     {
; 7981 :       // Start with validity checks
; 7982 :       if ((inst_idx < 1) || (inst_idx > 127))

	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, 1
	jl	SHORT $LN20@finalize
	cmp	eax, 127				; 0000007fH
	jle	SHORT $LN19@finalize
$LN20@finalize:

; 7983 :         { KDU_ERROR(e,0x26040501) e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0KK@HLPJKNOJ@The?5?$GADdecomp?8?5attribute?5may?5be?5d@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7983 :         { KDU_ERROR(e,0x26040501) e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7988 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN19@finalize:

; 7989 :       bool valid = true;
; 7990 :       int num_primary_bands;
; 7991 :       switch (val & 3) {

	mov	edi, DWORD PTR _val$[ebp]
	mov	bl, 1
	mov	eax, edi
	and	eax, 3
	cmp	eax, 3
	ja	SHORT $LN5@finalize
	jmp	DWORD PTR $LN74@finalize[eax*4]
$LN21@finalize:

; 7992 :           case 0:
; 7993 :             valid = (val == 0);

	test	edi, edi

; 7994 :             num_primary_bands = 0;

	mov	DWORD PTR _num_primary_bands$4[ebp], 0
	sete	bl

; 7995 :             break;

	jmp	SHORT $LN5@finalize
$LN22@finalize:

; 7996 :           case 1:
; 7997 :           case 2:
; 7998 :             valid = ((val >> 12) == 0);

	test	edi, -4096				; fffff000H

; 7999 :             num_primary_bands = 1;

	mov	DWORD PTR _num_primary_bands$4[ebp], 1
	sete	bl

; 8000 :             break;

	jmp	SHORT $LN5@finalize
$LN23@finalize:

; 8001 :           case 3:
; 8002 :             num_primary_bands = 3;

	mov	DWORD PTR _num_primary_bands$4[ebp], 3
$LN5@finalize:

; 8003 :             break;
; 8004 :         };
; 8005 :       for (k=0; k < 3; k++)

	mov	edx, 8
	npad	4
$LL9@finalize:

; 8006 :         switch ((val >> (10*k+2)) & 3) {

	lea	ecx, DWORD PTR [edx-6]
	mov	eax, edi
	sar	eax, cl
	and	eax, 3
	je	SHORT $LN24@finalize
	dec	eax
	cmp	eax, 1
	ja	SHORT $LN7@finalize

; 8009 :                 valid = false;
; 8010 :               break;
; 8011 :             case 1:
; 8012 :             case 2:
; 8013 :               if (((val >> (10*k+8)) & 0x0000000F) != 0)

	mov	eax, edi
	mov	ecx, edx
	sar	eax, cl
	test	al, 15					; 0000000fH
	je	SHORT $LN7@finalize

; 8014 :                 valid = false;

	xor	bl, bl

; 8015 :               break;

	jmp	SHORT $LN7@finalize
$LN24@finalize:

; 8007 :             case 0:
; 8008 :               if (((val >> (10*k+4)) & 0x000000FF) != 0)

	lea	ecx, DWORD PTR [edx-4]
	movzx	ebx, bl
	mov	eax, edi
	sar	eax, cl
	xor	ecx, ecx
	test	al, al
	cmovne	ebx, ecx
$LN7@finalize:

; 8003 :             break;
; 8004 :         };
; 8005 :       for (k=0; k < 3; k++)

	add	edx, 10					; 0000000aH
	cmp	edx, 38					; 00000026H
	jl	SHORT $LL9@finalize

; 8016 :             case 3:
; 8017 :               break;
; 8018 :           };
; 8019 :       if (!valid)

	test	bl, bl
	jne	$LN29@finalize

; 8020 :         { KDU_ERROR(e,0x26040502) e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0CO@MBLLCAAI@Encountered?5invalid?5?$GADdecomp?8?5at@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8020 :         { KDU_ERROR(e,0x26040502) e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_04FOFDHDLH@?0?50x?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	push	DWORD PTR _val$[ebp]
	lea	eax, DWORD PTR _text$5[ebp]

; 247  :       { bool old_mode = mode_hex; mode_hex = new_mode; return old_mode; }

	mov	BYTE PTR _e$3[ebp+4], 1

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$5[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@

; 247  :       { bool old_mode = mode_hex; mode_hex = new_mode; return old_mode; }

	mov	BYTE PTR _e$3[ebp+4], bl

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 8023 :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	edi, DWORD PTR _val$[ebp]
$LN29@finalize:

; 8024 : 
; 8025 :       // Now create `DOads' and `DSads' values
; 8026 :       if (n == 0)

	cmp	DWORD PTR _n$1$[ebp], 0
	jne	SHORT $LN30@finalize

; 8027 :         { // Erase any existing values just in case
; 8028 :           delete_unparsed_attribute(DOads);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	call	?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z ; kdu_params::delete_unparsed_attribute

; 8029 :           delete_unparsed_attribute(DSads);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	call	?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z ; kdu_params::delete_unparsed_attribute
	mov	edi, DWORD PTR _val$[ebp]
$LN30@finalize:

; 8030 :         }
; 8031 : 
; 8032 :       int sub_levs;
; 8033 :       int or_val = ((val >> 2) | (val >> 12) | (val >> 22)) & 0x3FF;

	mov	ebx, edi
	sar	ebx, 10					; 0000000aH
	or	ebx, edi
	sar	ebx, 10					; 0000000aH
	or	ebx, edi
	sar	ebx, 2
	and	ebx, 1023				; 000003ffH

; 8034 :       if (or_val == 0)

	jne	SHORT $LN31@finalize

; 8035 :         sub_levs = 1; // No splitting of any primary detail subband

	mov	ebx, 1
	jmp	SHORT $LN73@finalize
$LN31@finalize:

; 8036 :       else if ((or_val >> 2) == 0)

	and	ebx, -4					; fffffffcH
	neg	ebx
	sbb	ebx, ebx
	neg	ebx
	add	ebx, 2
$LN73@finalize:

; 8037 :         sub_levs = 2; // Need one extra sub-level
; 8038 :       else
; 8039 :         sub_levs = 3; // Need two extra sub-levels
; 8040 :       set(DOads,n,0,sub_levs);

	mov	edi, DWORD PTR _n$1$[ebp]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	ebx
	push	0
	push	edi
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	mov	DWORD PTR _sub_levs$1$[ebp], ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 8041 : 
; 8042 :       if (sub_levs == 1)

	cmp	ebx, 1
	je	$LN2@finalize

; 8043 :         continue; // No need for any splitting codes
; 8044 : 
; 8045 :       int code, sub_val;
; 8046 :       for (k=num_primary_bands-1; k >= 0; k--)

	mov	eax, DWORD PTR _num_primary_bands$4[ebp]
	add	eax, -1
	mov	DWORD PTR _k$1$[ebp], eax
	js	$LN2@finalize
	lea	eax, DWORD PTR [eax+eax*4]
	lea	ecx, DWORD PTR [eax*2+2]
	mov	DWORD PTR tv510[ebp], ecx
$LL14@finalize:

; 8047 :         { // Work from HH to LH to HL primary detail subbands
; 8048 :           sub_val = (val >> (2+k*10)) & 0x3FF;

	mov	eax, DWORD PTR _val$[ebp]
	sar	eax, cl

; 8049 :           code = sub_val & 3;
; 8050 :           set(DSads,code_idx++,0,code);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	and	eax, 1023				; 000003ffH
	mov	edi, eax
	mov	DWORD PTR _sub_val$1$[ebp], eax
	and	edi, 3
	push	edi
	push	0
	push	esi
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	inc	esi

; 8051 :           if ((sub_levs == 2) || (code == 0))

	cmp	ebx, 2
	je	SHORT $LN12@finalize
	test	edi, edi
	je	SHORT $LN12@finalize

; 8052 :             continue;
; 8053 : 
; 8054 :           int num_extra_codes = (code==3)?4:2;

	xor	ebx, ebx
	cmp	edi, 3
	sete	bl
	lea	ebx, DWORD PTR [ebx*2+2]

; 8055 :           for (; num_extra_codes > 0; num_extra_codes--)

	test	ebx, ebx
	jle	SHORT $LN71@finalize

; 8052 :             continue;
; 8053 : 
; 8054 :           int num_extra_codes = (code==3)?4:2;

	lea	edi, DWORD PTR [ebx+ebx]
	npad	4
$LL17@finalize:

; 8056 :             {
; 8057 :               code = (sub_val >> (2*num_extra_codes)) & 3;

	mov	eax, DWORD PTR _sub_val$1$[ebp]
	mov	ecx, edi
	sar	eax, cl

; 8058 :               set(DSads,code_idx++,0,code);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	and	eax, 3
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	dec	ebx
	inc	esi
	sub	edi, 2
	test	ebx, ebx
	jg	SHORT $LL17@finalize
$LN71@finalize:
	mov	ebx, DWORD PTR _sub_levs$1$[ebp]
$LN12@finalize:

; 8043 :         continue; // No need for any splitting codes
; 8044 : 
; 8045 :       int code, sub_val;
; 8046 :       for (k=num_primary_bands-1; k >= 0; k--)

	mov	eax, DWORD PTR _k$1$[ebp]
	mov	ecx, DWORD PTR tv510[ebp]
	dec	eax
	sub	ecx, 10					; 0000000aH
	mov	DWORD PTR _k$1$[ebp], eax
	mov	DWORD PTR tv510[ebp], ecx
	test	eax, eax
	jns	$LL14@finalize
	mov	edi, DWORD PTR _n$1$[ebp]
$LN2@finalize:

; 7979 :   for (n=0; get(Ddecomp,n,0,val,false,false,false); n++)

	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _val$[ebp]
	push	0
	push	0
	push	0
	push	eax
	push	0
	inc	edi
	mov	ecx, ebx
	push	edi
	push	OFFSET ??_C@_07MCCNNBND@Ddecomp?$AA@
	mov	DWORD PTR _n$1$[ebp], edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL4@finalize
$LN3@finalize:

; 8059 :             }
; 8060 :         }
; 8061 :     }
; 8062 : 
; 8063 :   assert((n == 0) || cod_params::is_valid_decomp_terminator(val));
; 8064 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN74@finalize:
	DD	$LN21@finalize
	DD	$LN22@finalize
	DD	$LN22@finalize
	DD	$LN23@finalize
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?finalize@ads_params@@MAEX_N@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@ads_params@@MAEX_N@Z$1:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?finalize@ads_params@@MAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?finalize@ads_params@@MAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?finalize@ads_params@@MAEX_N@Z ENDP			; ads_params::finalize
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?new_object@ads_params@@MAEPAVkdu_params@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_object@ads_params@@MAEPAVkdu_params@@XZ PROC	; ads_params::new_object, COMDAT
; _this$ = ecx

; 3231 :     virtual kdu_params *new_object() { return new ads_params(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_object@ads_params@@MAEPAVkdu_params@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_object
	mov	ecx, eax
	call	??0ads_params@@QAE@XZ			; ads_params::ads_params
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_object:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_object@ads_params@@MAEPAVkdu_params@@XZ$0:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?new_object@ads_params@@MAEPAVkdu_params@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_object@ads_params@@MAEPAVkdu_params@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_object@ads_params@@MAEPAVkdu_params@@XZ ENDP	; ads_params::new_object
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0ads_params@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ads_params@@QAE@XZ PROC				; ads_params::ads_params, COMDAT
; _this$ = ecx

; 7929 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ads_params@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 7928 :   : kdu_params(ADS_params,true,false,true,false,true)

	push	1
	push	0
	push	1
	push	0
	push	1
	push	OFFSET ??_C@_03BLBGDEDA@ADS?$AA@
	call	??0kdu_params@@QAE@PBD_N1111@Z		; kdu_params::kdu_params

; 7930 :   define_attribute(Ddecomp,

	push	1
	push	OFFSET ??_C@_01GFHCPBMG@C?$AA@
	push	OFFSET ??_C@_0BHE@CMGODJOA@This?5attribute?5is?5ultimately?5set@
	push	OFFSET ??_C@_07MCCNNBND@Ddecomp?$AA@
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7ads_params@@6B@
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 7931 :                    "This attribute is ultimately set so as to hold the same "
; 7932 :                    "information as the `Cdecomp' attribute of the COD/COC "
; 7933 :                    "marker segment whose `Cads' holds our instance index.  "
; 7934 :                    "Thus, for example, if `Cads'=3 then `Cdecomp' must be "
; 7935 :                    "identical to `Ddecomp:I3'.  This identification is "
; 7936 :                    "created by the internal machinery, however.  You should "
; 7937 :                    "not explicitly set `Ddecomp' values yourself.",
; 7938 :                    "C", MULTI_RECORD);
; 7939 :   define_attribute(DOads,

	push	3
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0BIG@MKJOPHKN@Number?5of?5sub?9levels?5in?5each?5suc@
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 7940 :                    "Number of sub-levels in each successive DWT level, "
; 7941 :                    "starting from the highest level.  Accesses to "
; 7942 :                    "non-existent values are supported by repeating the "
; 7943 :                    "last available value.  All entries must lie in the "
; 7944 :                    "range 1 to 3.  For the meaning of sub-levels in "
; 7945 :                    "JPEG2000 Part-2, the reader is referred to Annex F of "
; 7946 :                    "IS 15444-2.\n"
; 7947 :                    "\t\t[You would not normally set values for this "
; 7948 :                    "parameter attribute yourself.]",
; 7949 :                    "I", MULTI_RECORD | CAN_EXTRAPOLATE);
; 7950 :   define_attribute(DSads,

	push	3
	push	OFFSET ??_C@_0BC@GOBGDILI@?$CIX?$DN0?0H?$DN1?0V?$DN2?0B?$DN3?$CJ?$AA@
	push	OFFSET ??_C@_0CII@LBPCLNH@Array?5of?5splitting?5instructions?0@
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 7951 :                    "Array of splitting instructions, whose interpretation "
; 7952 :                    "generally depends upon the way in which ADS and DFS "
; 7953 :                    "tables are jointly referenced from COD/COC marker "
; 7954 :                    "segments, as identified by the `Cads' and `Cdfs' "
; 7955 :                    "attributes.  Each splitting instruction must take one "
; 7956 :                    "of the values: 3 (split horizontally and vertically); "
; 7957 :                    "2 (split vertically); 1 (split horizontally); or 0 "
; 7958 :                    "(do not split).  The last value is repeated as "
; 7959 :                    "necessary, if accesses are made beyond the end of the "
; 7960 :                    "array.  For the meaning of these splitting instructions, "
; 7961 :                    "the reader is referred to Annex F of IS 15444-2.\n"
; 7962 :                    "\t\t[You would not normally set values for this parameter "
; 7963 :                    "attribute yourself.]",
; 7964 :                    "(X=0,H=1,V=2,B=3)", MULTI_RECORD | CAN_EXTRAPOLATE);
; 7965 : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ads_params@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
__ehhandler$??0ads_params@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ads_params@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ads_params@@QAE@XZ ENDP				; ads_params::ads_params
; Function compile flags: /Ogtp
;	COMDAT ??_Gcod_params@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gcod_params@@UAEPAXI@Z PROC				; cod_params::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gcod_params@@UAEPAXI@Z ENDP				; cod_params::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1cod_params@@UAE@XZ
_TEXT	SEGMENT
??1cod_params@@UAE@XZ PROC				; cod_params::~cod_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1cod_params@@UAE@XZ ENDP				; cod_params::~cod_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?validate_dfs_data@cod_params@@AAEXH@Z
_TEXT	SEGMENT
_e$2 = -44						; size = 20
_val$3 = -24						; size = 4
_this$1$ = -20						; size = 4
_val$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_dfs_idx$ = 8						; size = 4
_validate$1$ = 11					; size = 1
?validate_dfs_data@cod_params@@AAEXH@Z PROC		; cod_params::validate_dfs_data, COMDAT
; _this$ = ecx

; 7566 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?validate_dfs_data@cod_params@@AAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, ecx
	mov	DWORD PTR _this$1$[ebp], eax

; 7567 :   if (dfs_idx == 0)

	mov	esi, DWORD PTR _dfs_idx$[ebp]
	test	esi, esi
	je	$LN3@validate_d

; 7568 :     return;
; 7569 :   kdu_params *dfs = access_cluster(DFS_params);

	push	OFFSET ??_C@_03CPEMBAGM@DFS?$AA@
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	ebx, eax

; 7570 :   if ((dfs == NULL) ||

	test	ebx, ebx
	je	SHORT $LN7@validate_d
	push	1
	push	esi
	push	-1
	push	-1
	mov	ecx, ebx
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	ebx, eax
$LN7@validate_d:

; 7571 :       ((dfs = dfs->access_relation(-1,-1,dfs_idx,true)) == NULL))
; 7572 :     assert(0); // Should not be able to happen
; 7573 : 
; 7574 :   int n, val;
; 7575 :   bool validate = dfs->get(DSdfs,0,0,val);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7576 :   for (n=0; get(Cdecomp,n,0,val,true,false); n++)

	mov	ecx, DWORD PTR _this$1$[ebp]
	xor	esi, esi
	push	1
	push	esi
	push	1
	mov	BYTE PTR _validate$1$[ebp], al
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	esi
	push	esi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN3@validate_d
$LL4@validate_d:

; 7577 :     {
; 7578 :       if (!validate)

	cmp	BYTE PTR _validate$1$[ebp], 0

; 7579 :         dfs->set(DSdfs,n,0,val&3);

	mov	ecx, ebx
	jne	SHORT $LN8@validate_d
	mov	eax, DWORD PTR _val$[ebp]
	and	eax, 3
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	jmp	SHORT $LN2@validate_d
$LN8@validate_d:

; 7580 :       else if (!dfs->compare(DSdfs,n,0,val&3))

	mov	edi, DWORD PTR _val$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$3[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7580 :       else if (!dfs->compare(DSdfs,n,0,val&3))

	and	edi, 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN15@validate_d
	cmp	DWORD PTR _val$3[ebp], edi
	jne	SHORT $LN15@validate_d
	mov	eax, 1
	jmp	SHORT $LN16@validate_d
$LN15@validate_d:
	xor	eax, eax
$LN16@validate_d:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7580 :       else if (!dfs->compare(DSdfs,n,0,val&3))

	test	al, al
	jne	SHORT $LN2@validate_d

; 7581 :         { KDU_ERROR_DEV(e,0x24050502); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0FO@DKHKMNAI@Incompatible?5?$GADSdfs?8?5and?5?$GACdecom@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7581 :         { KDU_ERROR_DEV(e,0x24050502); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7584 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@validate_d:

; 7576 :   for (n=0; get(Cdecomp,n,0,val,true,false); n++)

	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR _val$[ebp]
	push	1
	push	0
	push	1
	push	eax
	push	0
	inc	esi
	push	esi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL4@validate_d
$LN3@validate_d:

; 7585 :     }
; 7586 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?validate_dfs_data@cod_params@@AAEXH@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?validate_dfs_data@cod_params@@AAEXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?validate_dfs_data@cod_params@@AAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?validate_dfs_data@cod_params@@AAEXH@Z ENDP		; cod_params::validate_dfs_data
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?validate_ads_data@cod_params@@AAEXH@Z
_TEXT	SEGMENT
_e$2 = -96						; size = 20
_val$3 = -76						; size = 4
_e$4 = -72						; size = 20
_this$GSCopy$1$ = -52					; size = 4
_val$ = -48						; size = 4
_validate$1$ = -41					; size = 1
_buf$5 = -40						; size = 21
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_ads_idx$ = 8						; size = 4
?validate_ads_data@cod_params@@AAEXH@Z PROC		; cod_params::validate_ads_data, COMDAT
; _this$ = ecx

; 7514 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?validate_ads_data@cod_params@@AAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], esi
	mov	ebx, DWORD PTR _ads_idx$[ebp]

; 7515 :   if (ads_idx == 0)

	test	ebx, ebx
	je	$LN11@validate_a

; 7516 :     return;
; 7517 :   kdu_params *ads = access_cluster(ADS_params);

	push	OFFSET ??_C@_03BLBGDEDA@ADS?$AA@
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	edi, eax

; 7518 :   if ((ads == NULL) ||

	test	edi, edi
	je	SHORT $LN7@validate_a
	push	1
	push	ebx
	push	-1
	push	DWORD PTR [esi+8]
	mov	ecx, edi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	edi, eax
$LN7@validate_a:

; 7519 :       ((ads = ads->access_relation(tile_idx,-1,ads_idx,true)) == NULL))
; 7520 :     assert(0); // Should not be able to happen
; 7521 : 
; 7522 :   int n, val;
; 7523 :   bool validate = ads->get(Ddecomp,0,0,val);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07MCCNNBND@Ddecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7524 :   for (n=0; get(Cdecomp,n,0,val,true,false); n++)

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	xor	esi, esi
	push	1
	push	esi
	push	1
	mov	bl, al
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	esi
	push	esi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	mov	BYTE PTR _validate$1$[ebp], bl
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN11@validate_a
	npad	3
$LL4@validate_a:

; 7525 :     {
; 7526 :       if (!validate)
; 7527 :         ads->set(Ddecomp,n,0,val);

	mov	ecx, edi
	test	bl, bl
	jne	SHORT $LN8@validate_a
	push	DWORD PTR _val$[ebp]
	push	0
	push	esi
	push	OFFSET ??_C@_07MCCNNBND@Ddecomp?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	jmp	SHORT $LN2@validate_a
$LN8@validate_a:

; 7528 :       else if (!ads->compare(Ddecomp,n,0,val))

	mov	ebx, DWORD PTR _val$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$3[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_07MCCNNBND@Ddecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN17@validate_a
	cmp	DWORD PTR _val$3[ebp], ebx
	jne	SHORT $LN17@validate_a
	mov	eax, 1
	jmp	SHORT $LN18@validate_a
$LN17@validate_a:
	xor	eax, eax
$LN18@validate_a:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7528 :       else if (!ads->compare(Ddecomp,n,0,val))

	test	al, al
	jne	SHORT $LN35@validate_a

; 7529 :         { KDU_ERROR(e,0x24050501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BHK@LADFPGOB@Unacceptable?5interaction?5between@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7529 :         { KDU_ERROR(e,0x24050501); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7537 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN35@validate_a:
	mov	bl, BYTE PTR _validate$1$[ebp]
$LN2@validate_a:

; 7524 :   for (n=0; get(Cdecomp,n,0,val,true,false); n++)

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _val$[ebp]
	push	1
	push	0
	push	1
	push	eax
	push	0
	inc	esi
	push	esi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL4@validate_a

; 7538 :     }
; 7539 : 
; 7540 :   if ((n > 0) && !is_valid_decomp_terminator(val))

	test	esi, esi
	jle	SHORT $LN11@validate_a
	mov	esi, DWORD PTR _val$[ebp]
	push	esi
	call	?is_valid_decomp_terminator@cod_params@@SA_NH@Z ; cod_params::is_valid_decomp_terminator
	add	esp, 4
	test	al, al
	jne	SHORT $LN11@validate_a

; 7541 :     {
; 7542 :       char buf[21];  textualize_decomp(buf,val);

	lea	eax, DWORD PTR _buf$5[ebp]
	push	esi
	push	eax
	call	?textualize_decomp@cod_params@@SAXQADH@Z ; cod_params::textualize_decomp
	add	esp, 8

; 7543 :       KDU_ERROR(e,0x27040500) e <<

	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0DH@CDDAMBJI@Encountered?5invalid?5terminal?5?$GACd@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7543 :       KDU_ERROR(e,0x27040500) e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	lea	eax, DWORD PTR _buf$5[ebp]
	push	eax
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_04GPPIMOMJ@?$CC?4?5?5?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0CKE@KBAACNPK@Terminal?5splitting?5styles?5must?5h@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7557 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN11@validate_a:

; 7558 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?validate_ads_data@cod_params@@AAEXH@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?validate_ads_data@cod_params@@AAEXH@Z$1:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?validate_ads_data@cod_params@@AAEXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?validate_ads_data@cod_params@@AAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?validate_ads_data@cod_params@@AAEXH@Z ENDP		; cod_params::validate_ads_data
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?derive_decomposition_structure@cod_params@@AAEXPAVkdu_params@@0@Z
_TEXT	SEGMENT
_this$1$ = -56						; size = 4
_dfs_val$ = -52						; size = 4
tv435 = -48						; size = 4
_n$2$ = -44						; size = 4
_num_primary_bands$1 = -40				; size = 4
tv427 = -36						; size = 4
_sub_levs$ = -32					; size = 4
_code_idx$1$ = -28					; size = 4
_next_code$ = -24					; size = 4
_k$1$ = -20						; size = 4
tv431 = -16						; size = 4
tv436 = -12						; size = 4
_val$ = -8						; size = 4
_Oads_exhausted$1$ = -1					; size = 1
_dfs$ = 8						; size = 4
_ads$ = 12						; size = 4
?derive_decomposition_structure@cod_params@@AAEXPAVkdu_params@@0@Z PROC ; cod_params::derive_decomposition_structure, COMDAT
; _this$ = ecx

; 7441 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi

; 7442 :   int n, val;
; 7443 :   if (ads == NULL)

	mov	esi, DWORD PTR _ads$[ebp]
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx
	push	edi

; 7444 :     {
; 7445 :       assert(dfs != NULL); // Can't both be NULL
; 7446 :       for (n=0; dfs->get(DSdfs,n,0,val,true,false); n++)

	push	1
	push	0
	push	1
	test	esi, esi
	jne	SHORT $LN16@derive_dec
	mov	edi, DWORD PTR _dfs$[ebp]
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	esi
	push	esi
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN6@derive_dec
$LL4@derive_dec:

; 7447 :         set(Cdecomp,n,0,val);

	push	DWORD PTR _val$[ebp]
	mov	ecx, ebx
	push	0
	push	esi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	1
	push	0
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	inc	esi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL4@derive_dec
	pop	edi
	pop	esi
	pop	ebx

; 7505 :                is_valid_decomp_terminator(val)));
; 7506 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN16@derive_dec:

; 7448 :       return;
; 7449 :     }
; 7450 : 
; 7451 :   int sub_levs=1; // Default number of sub-levels
; 7452 :   int dfs_val=3; // Default is Mallat
; 7453 :   int code, next_code=0; // Default splitting code
; 7454 :   bool Oads_exhausted =
; 7455 :     ((ads == NULL) || !ads->get(DOads,0,0,sub_levs,true,false));

	lea	eax, DWORD PTR _sub_levs$[ebp]
	mov	DWORD PTR _sub_levs$[ebp], 1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	mov	ecx, esi
	mov	DWORD PTR _dfs_val$[ebp], 3
	mov	DWORD PTR _next_code$[ebp], 0
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7456 :   bool Sads_exhausted =
; 7457 :     ((ads == NULL) || !ads->get(DSads,0,0,next_code,true,false));

	push	1
	push	0
	push	1
	test	al, al
	mov	ecx, esi
	lea	eax, DWORD PTR _next_code$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	sete	BYTE PTR _Oads_exhausted$1$[ebp]
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al

; 7458 :   bool dfs_exhausted =
; 7459 :     ((dfs == NULL) || !dfs->get(DSdfs,0,0,dfs_val,true,false));

	mov	eax, DWORD PTR _dfs$[ebp]
	sete	bl
	mov	DWORD PTR tv431[ebp], ebx
	test	eax, eax
	je	SHORT $LN33@derive_dec
	push	1
	push	0
	push	1
	lea	ecx, DWORD PTR _dfs_val$[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	BYTE PTR tv427[ebp], 0
	test	al, al
	jne	SHORT $LN34@derive_dec
$LN33@derive_dec:
	mov	BYTE PTR tv427[ebp], 1
$LN34@derive_dec:

; 7460 :   val = 0;
; 7461 :   n = 0; // Index of current `DOads' and `DSdfs' parameters
; 7462 :   int code_idx = 1; // Index of next `DSads' parameter to be recovered

	mov	edi, 1
	mov	DWORD PTR _n$2$[ebp], 0
	mov	DWORD PTR _code_idx$1$[ebp], edi
	npad	2
$LL7@derive_dec:

; 7463 :   do {
; 7464 :       val = dfs_val & 3;

	mov	eax, DWORD PTR _dfs_val$[ebp]
	and	eax, 3
	mov	DWORD PTR _val$[ebp], eax

; 7465 :       int k, num_primary_bands, num_secondary_bands;
; 7466 :       switch (val) {

	cmp	eax, 3
	ja	SHORT $LN63@derive_dec
	jmp	DWORD PTR $LN65@derive_dec[eax*4]
$LN17@derive_dec:

; 7467 :           case 0: num_primary_bands = 0; break;

	xor	eax, eax
	mov	DWORD PTR _num_primary_bands$1[ebp], eax
	jmp	SHORT $LN8@derive_dec
$LN18@derive_dec:

; 7468 :           case 1:
; 7469 :           case 2: num_primary_bands = 1; break;

	mov	eax, 1
	mov	DWORD PTR _num_primary_bands$1[ebp], eax
	jmp	SHORT $LN8@derive_dec
$LN19@derive_dec:

; 7470 :           case 3: num_primary_bands = 3; break;

	mov	eax, 3
	mov	DWORD PTR _num_primary_bands$1[ebp], eax
	jmp	SHORT $LN8@derive_dec
$LN63@derive_dec:
	mov	eax, DWORD PTR _num_primary_bands$1[ebp]
$LN8@derive_dec:

; 7471 :         };
; 7472 :       for (k=num_primary_bands-1; k >= 0; k--)

	add	eax, -1
	mov	DWORD PTR _k$1$[ebp], eax
	js	$LN11@derive_dec
	lea	ebx, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [eax+eax*4]
	mov	DWORD PTR tv436[ebp], ebx
	mov	ecx, ebx
	lea	ebx, DWORD PTR [eax*2+2]
	mov	eax, DWORD PTR _k$1$[ebp]
	mov	DWORD PTR tv435[ebp], ebx
	npad	9
$LL12@derive_dec:

; 7473 :         {
; 7474 :           if (sub_levs == 1)

	cmp	DWORD PTR _sub_levs$[ebp], 1
	je	$LN10@derive_dec

; 7475 :             continue;
; 7476 :           code = next_code;
; 7477 :           if ((!Sads_exhausted) &&

	mov	edx, DWORD PTR tv431[ebp]
	mov	esi, DWORD PTR _next_code$[ebp]
	test	dl, dl
	jne	SHORT $LN54@derive_dec
	mov	ecx, DWORD PTR _ads$[ebp]
	lea	eax, DWORD PTR _next_code$[ebp]
	push	1
	push	0
	push	1
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	inc	edi
	mov	DWORD PTR _code_idx$1$[ebp], edi
	test	al, al
	jne	SHORT $LN58@derive_dec

; 7478 :               !ads->get(DSads,code_idx++,0,next_code,true,false))
; 7479 :             Sads_exhausted = true;

	mov	edx, 1
	mov	DWORD PTR tv431[ebp], edx
	jmp	SHORT $LN54@derive_dec
$LN58@derive_dec:
	mov	edx, DWORD PTR tv431[ebp]
$LN54@derive_dec:

; 7480 :           val |= (code << (2+k*10));

	mov	eax, esi
	mov	ecx, ebx
	shl	eax, cl
	or	DWORD PTR _val$[ebp], eax

; 7481 :           if ((code == 0) || (sub_levs == 2))

	test	esi, esi
	je	SHORT $LN61@derive_dec
	cmp	DWORD PTR _sub_levs$[ebp], 2
	je	SHORT $LN61@derive_dec

; 7482 :             continue;
; 7483 : 
; 7484 :           num_secondary_bands = (code==3)?4:2;

	xor	ebx, ebx
	cmp	esi, 3
	sete	bl
	lea	ebx, DWORD PTR [ebx*2+2]

; 7485 :           for (; num_secondary_bands > 0; num_secondary_bands--)

	test	ebx, ebx
	jle	SHORT $LN59@derive_dec

; 7491 :               val |= (code << (2+k*10+num_secondary_bands*2));

	mov	eax, DWORD PTR tv436[ebp]
	add	eax, ebx
	lea	edi, DWORD PTR [eax*2+2]
$LL15@derive_dec:

; 7486 :             {
; 7487 :               code = next_code;
; 7488 :               if ((!Sads_exhausted) &&

	mov	esi, DWORD PTR _next_code$[ebp]
	test	dl, dl
	jne	SHORT $LN55@derive_dec
	mov	ecx, DWORD PTR _ads$[ebp]
	lea	eax, DWORD PTR _next_code$[ebp]
	push	1
	push	0
	push	1
	push	eax
	push	0
	push	DWORD PTR _code_idx$1$[ebp]
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	inc	DWORD PTR _code_idx$1$[ebp]
	test	al, al
	jne	SHORT $LN57@derive_dec

; 7489 :                   !ads->get(DSads,code_idx++,0,next_code,true,false))
; 7490 :                 Sads_exhausted = true;

	mov	edx, 1
	mov	DWORD PTR tv431[ebp], edx
	jmp	SHORT $LN55@derive_dec
$LN57@derive_dec:
	mov	edx, DWORD PTR tv431[ebp]
$LN55@derive_dec:

; 7491 :               val |= (code << (2+k*10+num_secondary_bands*2));

	mov	ecx, edi
	dec	ebx
	shl	esi, cl
	sub	edi, 2
	or	DWORD PTR _val$[ebp], esi
	test	ebx, ebx
	jg	SHORT $LL15@derive_dec
	mov	edi, DWORD PTR _code_idx$1$[ebp]
$LN59@derive_dec:
	mov	ebx, DWORD PTR tv435[ebp]
$LN61@derive_dec:
	mov	ecx, DWORD PTR tv436[ebp]
	mov	eax, DWORD PTR _k$1$[ebp]
$LN10@derive_dec:

; 7471 :         };
; 7472 :       for (k=num_primary_bands-1; k >= 0; k--)

	dec	eax
	sub	ebx, 10					; 0000000aH
	sub	ecx, 5
	mov	DWORD PTR _k$1$[ebp], eax
	mov	DWORD PTR tv435[ebp], ebx
	mov	DWORD PTR tv436[ebp], ecx
	test	eax, eax
	jns	$LL12@derive_dec
	mov	ebx, DWORD PTR tv431[ebp]
	mov	esi, DWORD PTR _ads$[ebp]
$LN11@derive_dec:

; 7492 :             }
; 7493 :         }
; 7494 :       set(Cdecomp,n,0,val);

	push	DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	0
	push	DWORD PTR _n$2$[ebp]
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 7495 : 
; 7496 :       n++; // Advance to next index

	mov	eax, DWORD PTR _n$2$[ebp]
	inc	eax

; 7497 : 
; 7498 :       if ((!dfs_exhausted) && !dfs->get(DSdfs,n,0,dfs_val,true,false))

	cmp	BYTE PTR tv427[ebp], 0
	mov	DWORD PTR _n$2$[ebp], eax
	jne	SHORT $LN25@derive_dec
	push	1
	push	0
	push	1
	lea	ecx, DWORD PTR _dfs_val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _dfs$[ebp]
	push	0
	push	eax
	push	OFFSET ??_C@_05FJELFOMO@DSdfs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	ecx, DWORD PTR tv427[ebp]
	test	al, al
	mov	eax, 1
	movzx	ecx, cl
	cmove	ecx, eax
	mov	eax, DWORD PTR _n$2$[ebp]
	mov	DWORD PTR tv427[ebp], ecx
$LN25@derive_dec:

; 7499 :         dfs_exhausted = true;
; 7500 :       if ((!Oads_exhausted) && !ads->get(DOads,n,0,sub_levs,true,false))

	cmp	BYTE PTR _Oads_exhausted$1$[ebp], 0
	jne	SHORT $LN53@derive_dec
	push	1
	push	0
	push	1
	lea	ecx, DWORD PTR _sub_levs$[ebp]
	push	ecx
	push	0
	push	eax
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN5@derive_dec

; 7501 :         Oads_exhausted = true;

	mov	BYTE PTR _Oads_exhausted$1$[ebp], 1
$LN53@derive_dec:

; 7502 :       if (Oads_exhausted && (sub_levs < 2))

	cmp	DWORD PTR _sub_levs$[ebp], 2
	mov	eax, 1
	movzx	ebx, bl
	cmovl	ebx, eax
	mov	DWORD PTR tv431[ebp], ebx
$LN5@derive_dec:

; 7503 :         Sads_exhausted = true; // Will never read more Sads values
; 7504 :     } while (!(dfs_exhausted && Oads_exhausted && Sads_exhausted &&

	cmp	BYTE PTR tv427[ebp], 0
	je	$LL7@derive_dec
	cmp	BYTE PTR _Oads_exhausted$1$[ebp], 0
	je	$LL7@derive_dec
	test	bl, bl
	je	$LL7@derive_dec
	push	DWORD PTR _val$[ebp]
	call	?is_valid_decomp_terminator@cod_params@@SA_NH@Z ; cod_params::is_valid_decomp_terminator
	add	esp, 4
	test	al, al
	je	$LL7@derive_dec
$LN6@derive_dec:
	pop	edi
	pop	esi
	pop	ebx

; 7505 :                is_valid_decomp_terminator(val)));
; 7506 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN65@derive_dec:
	DD	$LN17@derive_dec
	DD	$LN18@derive_dec
	DD	$LN18@derive_dec
	DD	$LN19@derive_dec
?derive_decomposition_structure@cod_params@@AAEXPAVkdu_params@@0@Z ENDP ; cod_params::derive_decomposition_structure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?find_suitable_dfs_idx@cod_params@@AAEHXZ
_TEXT	SEGMENT
_e$2 = -56						; size = 20
_rel$2$ = -36						; size = 4
_max_dfs_idx$1$ = -32					; size = 4
_c$1$ = -28						; size = 4
_decomp1$3 = -24					; size = 4
_decomp2$4 = -20					; size = 4
_dfs_idx$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?find_suitable_dfs_idx@cod_params@@AAEHXZ PROC		; cod_params::find_suitable_dfs_idx, COMDAT
; _this$ = ecx

; 7332 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?find_suitable_dfs_idx@cod_params@@AAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 7333 :   kdu_params *rel;
; 7334 :   int dfs_idx=0;
; 7335 : 
; 7336 :   if (tile_idx >= 0)

	cmp	DWORD PTR [edi+8], 0
	mov	DWORD PTR _dfs_idx$[ebp], 0
	jl	SHORT $LN8@find_suita

; 7337 :     { // Must use main header DFS; can't redefine here
; 7338 :       rel = access_relation(-1,comp_idx,0);

	push	0
	push	0
	push	DWORD PTR [edi+12]
	push	-1
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 7339 :       rel->get(Cdfs,0,0,dfs_idx);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _dfs_idx$[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7340 :       if (dfs_idx == 0)

	mov	eax, DWORD PTR _dfs_idx$[ebp]
	test	eax, eax
	jne	$LN1@find_suita

; 7341 :         { KDU_ERROR(e,0x24050503); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BDN@MGKCOKBG@You?5are?5attempting?5to?5define?5a?5d@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7341 :         { KDU_ERROR(e,0x24050503); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7348 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN22@find_suita:
	mov	eax, DWORD PTR _dfs_idx$[ebp]

; 7380 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@find_suita:

; 7349 :       return dfs_idx;
; 7350 :     }
; 7351 : 
; 7352 :   int c, max_dfs_idx = 0;
; 7353 :   for (c=-1; c < comp_idx; c++)

	or	eax, -1
	xor	esi, esi
	mov	DWORD PTR _max_dfs_idx$1$[ebp], esi
	mov	DWORD PTR _c$1$[ebp], eax
	cmp	DWORD PTR [edi+12], eax
	jle	$LN28@find_suita
	npad	3
$LL4@find_suita:

; 7354 :     if (((rel = access_unique(-1,c,0)) != NULL) &&
; 7355 :         rel->get(Cdfs,0,0,dfs_idx) && (dfs_idx != 0))

	push	0
	push	eax
	push	-1
	mov	ecx, edi
	call	?access_unique@kdu_params@@QAEPAV1@HHH@Z ; kdu_params::access_unique
	mov	DWORD PTR _rel$2$[ebp], eax
	test	eax, eax
	je	$LN2@find_suita
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _dfs_idx$[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN2@find_suita
	mov	eax, DWORD PTR _dfs_idx$[ebp]
	test	eax, eax
	je	SHORT $LN2@find_suita

; 7356 :       { // Found potential result
; 7357 :         max_dfs_idx = dfs_idx;

	mov	DWORD PTR _max_dfs_idx$1$[ebp], eax

; 7358 : 
; 7359 :         int n=0, decomp1=3, decomp2=3;

	xor	esi, esi
	mov	DWORD PTR _decomp1$3[ebp], 3
	mov	DWORD PTR _decomp2$4[ebp], 3
	npad	1
$LL7@find_suita:

; 7360 :         bool compatible_decomp = true;
; 7361 :         bool have_Cdecomp, have_Ddecomp;
; 7362 :         do {
; 7363 :             have_Cdecomp = get(Cdecomp,n,0,decomp1,false,false);

	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _decomp1$3[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7364 :             have_Ddecomp = rel->get(Cdecomp,n,0,decomp2,false,false);

	mov	ecx, DWORD PTR _rel$2$[ebp]
	mov	bl, al
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _decomp2$4[ebp]
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7365 :             if ((decomp1 & 3) != (decomp2 & 3))

	mov	ecx, DWORD PTR _decomp2$4[ebp]
	xor	ecx, DWORD PTR _decomp1$3[ebp]
	test	cl, 3
	jne	SHORT $LN2@find_suita

; 7366 :               { compatible_decomp = false; break; }
; 7367 :             n++;

	inc	esi

; 7368 :           } while (have_Cdecomp || have_Ddecomp);

	test	bl, bl
	jne	SHORT $LL7@find_suita
	test	al, al
	jne	SHORT $LL7@find_suita
	jmp	$LN22@find_suita
$LN2@find_suita:

; 7349 :       return dfs_idx;
; 7350 :     }
; 7351 : 
; 7352 :   int c, max_dfs_idx = 0;
; 7353 :   for (c=-1; c < comp_idx; c++)

	mov	eax, DWORD PTR _c$1$[ebp]
	inc	eax
	mov	DWORD PTR _c$1$[ebp], eax
	cmp	eax, DWORD PTR [edi+12]
	jl	$LL4@find_suita
	mov	esi, DWORD PTR _max_dfs_idx$1$[ebp]
$LN28@find_suita:

; 7369 :         if (compatible_decomp)
; 7370 :           return dfs_idx;
; 7371 :       }
; 7372 : 
; 7373 :   // If we get here, we need to create a new DFS table
; 7374 :   dfs_idx = max_dfs_idx + 1;

	inc	esi

; 7375 :   rel = access_cluster(DFS_params);

	mov	ecx, edi
	push	OFFSET ??_C@_03CPEMBAGM@DFS?$AA@
	mov	DWORD PTR _dfs_idx$[ebp], esi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 7376 :   if (rel != NULL)

	test	eax, eax
	je	SHORT $LN13@find_suita

; 7377 :     rel->access_relation(-1,-1,dfs_idx,false);

	push	0
	push	esi
	push	-1
	push	-1
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	esi, DWORD PTR _dfs_idx$[ebp]
$LN13@find_suita:

; 7378 : 
; 7379 :   return dfs_idx;

	mov	eax, esi
$LN1@find_suita:

; 7380 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?find_suitable_dfs_idx@cod_params@@AAEHXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?find_suitable_dfs_idx@cod_params@@AAEHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?find_suitable_dfs_idx@cod_params@@AAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?find_suitable_dfs_idx@cod_params@@AAEHXZ ENDP		; cod_params::find_suitable_dfs_idx
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?find_suitable_ads_idx@cod_params@@AAEHXZ
_TEXT	SEGMENT
_ads_idx$1$ = -32					; size = 4
_ads_root$1$ = -28					; size = 4
_this$1$ = -24						; size = 4
_decomp2$1 = -20					; size = 4
_decomp1$2 = -16					; size = 4
_val$ = -12						; size = 4
_max_ads_idx$1$ = -8					; size = 4
_tile_specific$1$ = -1					; size = 1
?find_suitable_ads_idx@cod_params@@AAEHXZ PROC		; cod_params::find_suitable_ads_idx, COMDAT
; _this$ = ecx

; 7388 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 7389 :   kdu_params *ads_root = access_cluster(ADS_params);

	push	OFFSET ??_C@_03BLBGDEDA@ADS?$AA@
	mov	DWORD PTR _this$1$[ebp], edi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 7390 :   int val, ads_idx, max_ads_idx = 0;
; 7391 :   kdu_params *ads = NULL;
; 7392 :   bool tile_specific = false;
; 7393 :   if ((ads = ads_root->access_unique(tile_idx,-1,0)) != NULL)

	push	0
	mov	esi, eax
	mov	DWORD PTR _max_ads_idx$1$[ebp], 0
	push	-1
	push	DWORD PTR [edi+8]
	mov	ecx, esi
	mov	DWORD PTR _ads_root$1$[ebp], esi
	mov	BYTE PTR _tile_specific$1$[ebp], 0
	call	?access_unique@kdu_params@@QAEPAV1@HHH@Z ; kdu_params::access_unique
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN7@find_suita

; 7394 :     tile_specific = true;

	mov	BYTE PTR _tile_specific$1$[ebp], 1

; 7395 :   else

	jmp	SHORT $LN21@find_suita
$LN7@find_suita:

; 7396 :     ads = ads_root;

	mov	edi, esi
$LN21@find_suita:

; 7397 :   while (ads != NULL)

	test	edi, edi
	je	$LN30@find_suita
	npad	4
$LL2@find_suita:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 725  :     int get_instance() { return inst_idx; }

	mov	ebx, DWORD PTR [edi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7400 :       if (ads->get(Ddecomp,0,0,val) || ads->get(DOads,0,0,val) ||

	lea	eax, DWORD PTR _val$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07MCCNNBND@Ddecomp?$AA@
	mov	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 725  :     int get_instance() { return inst_idx; }

	mov	DWORD PTR _ads_idx$1$[ebp], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7400 :       if (ads->get(Ddecomp,0,0,val) || ads->get(DOads,0,0,val) ||

	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN10@find_suita
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_05MIABAABB@DOads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN10@find_suita
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_05GNBBHKJC@DSads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN23@find_suita
$LN10@find_suita:

; 7401 :           ads->get(DSads,0,0,val))
; 7402 :         { // ADS table non-empty
; 7403 :           if (ads_idx > max_ads_idx)

	cmp	ebx, DWORD PTR _max_ads_idx$1$[ebp]
	jle	SHORT $LN23@find_suita

; 7404 :             {
; 7405 :               max_ads_idx = ads_idx;

	mov	DWORD PTR _max_ads_idx$1$[ebp], ebx

; 7406 :           
; 7407 :               bool compatible_decomp = true;
; 7408 :               int n=0, decomp1=3, decomp2=3;

	xor	esi, esi
	mov	DWORD PTR _decomp1$2[ebp], 3
	mov	DWORD PTR _decomp2$1[ebp], 3
$LL6@find_suita:

; 7409 :               bool have_Cdecomp, have_Ddecomp;
; 7410 :               do {
; 7411 :                   have_Cdecomp = get(Cdecomp,n,0,decomp1,false,false);

	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR _decomp1$2[ebp]
	push	1
	push	0
	push	0
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7412 :                   have_Ddecomp = ads->get(Ddecomp,n,0,decomp2,false,false);

	push	1
	push	0
	push	0
	mov	bl, al
	mov	ecx, edi
	lea	eax, DWORD PTR _decomp2$1[ebp]
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_07MCCNNBND@Ddecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7413 :                   if (decomp1 != decomp2)

	mov	ecx, DWORD PTR _decomp1$2[ebp]
	cmp	ecx, DWORD PTR _decomp2$1[ebp]
	jne	SHORT $LN31@find_suita

; 7414 :                     { compatible_decomp = false; break; }
; 7415 :                   n++;

	inc	esi

; 7416 :                 } while (have_Cdecomp || have_Ddecomp);

	test	bl, bl
	jne	SHORT $LL6@find_suita
	test	al, al
	jne	SHORT $LL6@find_suita

; 7417 :               if (compatible_decomp)
; 7418 :                 return ads_idx;

	mov	eax, DWORD PTR _ads_idx$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 7433 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@find_suita:
	mov	esi, DWORD PTR _ads_root$1$[ebp]
$LN23@find_suita:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 807  :       access_next_inst() { return next_inst; }

	mov	edi, DWORD PTR [edi+56]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7422 :       if ((ads == NULL) && tile_specific)

	test	edi, edi
	jne	$LL2@find_suita
	cmp	BYTE PTR _tile_specific$1$[ebp], 0
	je	SHORT $LN30@find_suita

; 7423 :         { // Try looking in main header
; 7424 :           ads = ads_root;
; 7425 :           tile_specific = false;

	mov	BYTE PTR _tile_specific$1$[ebp], 0
	mov	edi, esi
	test	esi, esi
	jne	$LL2@find_suita
$LN30@find_suita:

; 7426 :         }
; 7427 :     }
; 7428 : 
; 7429 :   // If we get here, we need to create a new ADS table
; 7430 :   ads_idx = max_ads_idx + 1;

	mov	esi, DWORD PTR _max_ads_idx$1$[ebp]

; 7431 :   ads_root->access_relation(tile_idx,-1,ads_idx,false);

	mov	eax, DWORD PTR _this$1$[ebp]
	inc	esi
	mov	ecx, DWORD PTR _ads_root$1$[ebp]
	push	0
	push	esi
	push	-1
	push	DWORD PTR [eax+8]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	pop	edi

; 7432 :   return ads_idx;

	mov	eax, esi
	pop	esi
	pop	ebx

; 7433 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?find_suitable_ads_idx@cod_params@@AAEHXZ ENDP		; cod_params::find_suitable_ads_idx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?get_max_decomp_levels@cod_params@@SAXHAAH0@Z
_TEXT	SEGMENT
_num_vert1$1$ = -32					; size = 4
_num_hor2$1$ = -28					; size = 4
_count2_v$1$ = -24					; size = 4
_count2_h$1$ = -20					; size = 4
_count1_v$1$ = -16					; size = 4
_count1_h$1$ = -12					; size = 4
_num_vert2$1$ = -8					; size = 4
_num_hor1$1$ = -4					; size = 4
_decomp_val$ = 8					; size = 4
_h1$1$ = 12						; size = 4
_horizontal_levels$ = 12				; size = 4
_v1$1$ = 16						; size = 4
_vertical_levels$ = 16					; size = 4
?get_max_decomp_levels@cod_params@@SAXHAAH0@Z PROC	; cod_params::get_max_decomp_levels, COMDAT

; 7756 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 7757 :   int val;
; 7758 :   int h1, v1, h2, v2;
; 7759 :   int num_hor1, num_vert1, num_hor2, num_vert2;
; 7760 :   int count1_h, count1_v, count2_h, count2_v, count3_h, count3_v;
; 7761 : 
; 7762 :   num_hor1 = (decomp_val & 1) + 1;

	mov	ecx, DWORD PTR _decomp_val$[ebp]
	mov	eax, ecx
	push	ebx

; 7763 :   num_vert1 = ((decomp_val >> 1) & 1) + 1;

	mov	ebx, ecx
	and	eax, 1
	sar	ebx, 1
	inc	eax
	push	esi

; 7764 :   
; 7765 :   count1_h = num_hor1-1;
; 7766 :   count1_v = num_vert1-1;
; 7767 : 
; 7768 :   horizontal_levels = count1_h;
; 7769 :   vertical_levels = count1_v;

	mov	esi, DWORD PTR _vertical_levels$[ebp]
	and	ebx, 1
	inc	ebx
	mov	DWORD PTR _num_hor1$1$[ebp], eax
	push	edi
	mov	edi, DWORD PTR _horizontal_levels$[ebp]
	dec	eax

; 7770 : 
; 7771 :   decomp_val >>= 2;

	sar	ecx, 2
	lea	edx, DWORD PTR [ebx-1]
	mov	DWORD PTR _num_vert1$1$[ebp], ebx
	mov	DWORD PTR _count1_v$1$[ebp], edx
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [esi], edx

; 7772 :   for (v1=0; v1 < num_vert1; v1++)

	xor	edx, edx
	mov	DWORD PTR _count1_h$1$[ebp], eax
	mov	DWORD PTR _v1$1$[ebp], edx
	test	ebx, ebx
	jle	$LN3@get_max_de
	mov	ebx, DWORD PTR _num_hor1$1$[ebp]
$LL4@get_max_de:

; 7773 :     for (h1=0; h1 < num_hor1; h1++)

	xor	eax, eax
	mov	DWORD PTR _h1$1$[ebp], eax
	test	ebx, ebx
	jle	$LN2@get_max_de
$LL7@get_max_de:

; 7774 :       {
; 7775 :         if ((h1 == 0) && (v1 == 0))

	test	eax, eax
	jne	SHORT $LN14@get_max_de
	test	edx, edx
	je	$LN5@get_max_de
$LN14@get_max_de:

; 7776 :           continue;
; 7777 : 
; 7778 :         val = decomp_val; decomp_val >>= 10;

	mov	ebx, ecx
	sar	ecx, 10					; 0000000aH
	mov	DWORD PTR _decomp_val$[ebp], ecx

; 7779 :         if ((val & 3) == 0)

	test	bl, 3
	je	SHORT $LN36@get_max_de

; 7780 :           continue;
; 7781 : 
; 7782 :         num_hor2 = (val & 1) + 1;
; 7783 :         num_vert2 = ((val >> 1) & 1) + 1;
; 7784 : 
; 7785 :         count2_h = count1_h + (num_hor2-1);

	mov	edx, DWORD PTR _count1_h$1$[ebp]
	mov	ecx, ebx
	dec	edx
	and	ecx, 1
	inc	ecx
	mov	eax, ebx
	add	edx, ecx
	sar	eax, 1
	mov	DWORD PTR _count2_h$1$[ebp], edx
	and	eax, 1

; 7786 :         count2_v = count1_v + (num_vert2-1);

	mov	edx, DWORD PTR _count1_v$1$[ebp]
	inc	eax
	dec	edx
	mov	DWORD PTR _num_hor2$1$[ebp], ecx
	add	edx, eax
	mov	DWORD PTR _num_vert2$1$[ebp], eax
	mov	DWORD PTR _count2_v$1$[ebp], edx

; 7787 : 
; 7788 :         for (v2=0; v2 < num_vert2; v2++)

	test	eax, eax
	jle	SHORT $LN35@get_max_de
$LL10@get_max_de:

; 7789 :           for (h2=0; h2 < num_hor2; h2++)

	test	ecx, ecx
	jle	SHORT $LN8@get_max_de
	mov	edx, ecx
	npad	3
$LL13@get_max_de:

; 7790 :             {
; 7791 :               val >>= 2;

	sar	ebx, 2

; 7792 :               count3_h = count2_h + (val & 1);
; 7793 :               count3_v = count2_v + ((val >> 1) & 1);

	mov	eax, ebx
	mov	ecx, ebx
	sar	eax, 1
	and	ecx, 1
	add	ecx, DWORD PTR _count2_h$1$[ebp]
	and	eax, 1
	add	eax, DWORD PTR _count2_v$1$[ebp]

; 7794 : 
; 7795 :               if (count3_h > horizontal_levels)

	cmp	ecx, DWORD PTR [edi]
	jle	SHORT $LN16@get_max_de

; 7796 :                 horizontal_levels = count3_h;

	mov	DWORD PTR [edi], ecx
$LN16@get_max_de:

; 7797 :               if (count3_v > vertical_levels)

	cmp	eax, DWORD PTR [esi]
	jle	SHORT $LN11@get_max_de

; 7798 :                 vertical_levels = count3_v;

	mov	DWORD PTR [esi], eax
$LN11@get_max_de:

; 7789 :           for (h2=0; h2 < num_hor2; h2++)

	sub	edx, 1
	jne	SHORT $LL13@get_max_de
	mov	eax, DWORD PTR _num_vert2$1$[ebp]
	mov	ecx, DWORD PTR _num_hor2$1$[ebp]
$LN8@get_max_de:

; 7787 : 
; 7788 :         for (v2=0; v2 < num_vert2; v2++)

	sub	eax, 1
	mov	DWORD PTR _num_vert2$1$[ebp], eax
	jne	SHORT $LL10@get_max_de
$LN35@get_max_de:
	mov	edx, DWORD PTR _v1$1$[ebp]
	mov	ecx, DWORD PTR _decomp_val$[ebp]
	mov	eax, DWORD PTR _h1$1$[ebp]
$LN36@get_max_de:
	mov	ebx, DWORD PTR _num_hor1$1$[ebp]
$LN5@get_max_de:

; 7773 :     for (h1=0; h1 < num_hor1; h1++)

	inc	eax
	mov	DWORD PTR _h1$1$[ebp], eax
	cmp	eax, ebx
	jl	$LL7@get_max_de
$LN2@get_max_de:

; 7772 :   for (v1=0; v1 < num_vert1; v1++)

	inc	edx
	mov	DWORD PTR _v1$1$[ebp], edx
	cmp	edx, DWORD PTR _num_vert1$1$[ebp]
	jl	$LL4@get_max_de
$LN3@get_max_de:
	pop	edi
	pop	esi
	pop	ebx

; 7799 :             }
; 7800 :       }
; 7801 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?get_max_decomp_levels@cod_params@@SAXHAAH0@Z ENDP	; cod_params::get_max_decomp_levels
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?expand_decomp_bands@cod_params@@SAHHQAF@Z
_TEXT	SEGMENT
_num_hor2$1$ = -80					; size = 4
_count3_v$1$ = -76					; size = 4
_num_vert3$1$ = -72					; size = 4
_count3_h$1$ = -68					; size = 4
_high2_h$1$ = -64					; size = 4
_num_vert1$1$ = -60					; size = 4
_num_hor1$1$ = -56					; size = 4
_num_vert2$1$ = -52					; size = 4
_h2$1$ = -48						; size = 4
_v3$1$ = -44						; size = 4
_val$1$ = -40						; size = 4
_count1_v$1$ = -36					; size = 4
_h1$1$ = -32						; size = 4
_count1_h$1$ = -28					; size = 4
_v2$1$ = -24						; size = 4
_count2_h$1$ = -20					; size = 4
_high2_v$1$ = -16					; size = 4
_v1$1$ = -12						; size = 4
_count2_v$1$ = -8					; size = 4
_num_bands$1$ = -4					; size = 4
_decomp_val$ = 8					; size = 4
_descriptors$ = 12					; size = 4
?expand_decomp_bands@cod_params@@SAHHQAF@Z PROC		; cod_params::expand_decomp_bands, COMDAT

; 7809 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 7810 :   int num_bands = 0;
; 7811 :   int val;
; 7812 :   int h1, v1, h2, v2, h3, v3;
; 7813 :   int num_hor1, num_vert1, num_hor2, num_vert2, num_hor3, num_vert3;
; 7814 :   int count1_h, count1_v, count2_h, count2_v, count3_h, count3_v;
; 7815 :   int high1_h, high1_v, high2_h, high2_v, high3_h, high3_v;
; 7816 : 
; 7817 :   num_hor1 = (decomp_val & 1) + 1;

	mov	eax, DWORD PTR _decomp_val$[ebp]
	xor	ecx, ecx
	push	ebx

; 7818 :   num_vert1 = ((decomp_val >> 1) & 1) + 1;

	mov	ebx, eax
	mov	DWORD PTR _num_bands$1$[ebp], ecx
	mov	edx, eax
	sar	ebx, 1
	and	edx, 1

; 7819 :   
; 7820 :   count1_h = num_hor1-1;
; 7821 :   count1_v = num_vert1-1;
; 7822 : 
; 7823 :   decomp_val >>= 2;

	sar	eax, 2
	inc	edx
	mov	DWORD PTR _decomp_val$[ebp], eax
	and	ebx, 1
	mov	DWORD PTR _num_hor1$1$[ebp], edx
	inc	ebx
	push	esi
	lea	esi, DWORD PTR [edx-1]
	mov	DWORD PTR _num_vert1$1$[ebp], ebx
	push	edi

; 7824 :   for (v1=0; v1 < num_vert1; v1++)

	xor	edi, edi
	mov	DWORD PTR _count1_h$1$[ebp], esi
	mov	DWORD PTR _v1$1$[ebp], edi
	lea	edx, DWORD PTR [ebx-1]
	mov	DWORD PTR _count1_v$1$[ebp], edx
	test	ebx, ebx
	jle	$LN48@expand_dec
$LL4@expand_dec:

; 7825 :     for (h1=0; h1 < num_hor1; h1++)

	xor	ebx, ebx
	mov	DWORD PTR _h1$1$[ebp], ebx
	cmp	DWORD PTR _num_hor1$1$[ebp], ebx
	jle	$LN2@expand_dec
$LL7@expand_dec:

; 7826 :       {
; 7827 :         high1_h = h1;
; 7828 :         high1_v = v1;
; 7829 :         if ((h1 == 0) && (v1 == 0))

	test	ebx, ebx
	jne	SHORT $LN20@expand_dec
	test	edi, edi
	jne	SHORT $LN20@expand_dec

; 7830 :           { // This is the subband which is passed on to the next DWT level
; 7831 :             descriptors[num_bands++] = (kdu_int16)

	mov	eax, edx
	mov	edx, DWORD PTR _descriptors$[ebp]
	shl	eax, 8
	add	eax, esi
	mov	WORD PTR [edx+ecx*2], ax
	inc	ecx
	mov	DWORD PTR _num_bands$1$[ebp], ecx

; 7832 :               (count1_h + (high1_h<<2) + (count1_v<<8) + (high1_v<<10));
; 7833 :             continue;

	jmp	$LN5@expand_dec
$LN20@expand_dec:

; 7834 :           }
; 7835 : 
; 7836 :         val = decomp_val; decomp_val >>= 10;

	sar	DWORD PTR _decomp_val$[ebp], 10		; 0000000aH
	mov	DWORD PTR _val$1$[ebp], eax

; 7837 :         if ((val & 3) == 0)

	test	al, 3
	jne	SHORT $LN21@expand_dec

; 7838 :           { // This subband is refined no further
; 7839 :             descriptors[num_bands++] = (kdu_int16)

	lea	eax, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR _descriptors$[ebp]
	shl	eax, 6
	add	eax, ebx
	lea	eax, DWORD PTR [esi+eax*4]
	mov	WORD PTR [edx+ecx*2], ax
	inc	ecx
	mov	DWORD PTR _num_bands$1$[ebp], ecx

; 7840 :               (count1_h + (high1_h<<2) + (count1_v<<8) + (high1_v<<10));
; 7841 :             continue;

	jmp	$LN5@expand_dec
$LN21@expand_dec:

; 7842 :           }
; 7843 : 
; 7844 :         num_hor2 = (val & 1) + 1;
; 7845 :         num_vert2 = ((val >> 1) & 1) + 1;
; 7846 : 
; 7847 :         count2_h = count1_h + (num_hor2-1);
; 7848 :         count2_v = count1_v + (num_vert2-1);

	mov	edi, DWORD PTR _num_vert1$1$[ebp]
	mov	edx, eax
	sar	eax, 1
	and	edx, 1
	and	eax, 1

; 7849 : 
; 7850 :         for (v2=0; v2 < num_vert2; v2++)

	mov	DWORD PTR _v2$1$[ebp], 0
	inc	edx
	inc	eax
	dec	esi
	mov	DWORD PTR _num_hor2$1$[ebp], edx
	add	edi, -2					; fffffffeH
	mov	DWORD PTR _num_vert2$1$[ebp], eax
	add	esi, edx
	add	edi, eax
	mov	DWORD PTR _count2_h$1$[ebp], esi
	mov	DWORD PTR _count2_v$1$[ebp], edi
	test	eax, eax
	jle	$LN52@expand_dec
	mov	ebx, eax
	npad	5
$LL10@expand_dec:

; 7851 :           for (h2=0; h2 < num_hor2; h2++)

	xor	eax, eax
	mov	DWORD PTR _h2$1$[ebp], eax
	test	edx, edx
	jle	$LN8@expand_dec
	mov	ebx, DWORD PTR _v2$1$[ebp]
	mov	ecx, DWORD PTR _count1_v$1$[ebp]
	shl	ebx, cl
	or	ebx, DWORD PTR _v1$1$[ebp]
	mov	DWORD PTR _high2_v$1$[ebp], ebx
	npad	5
$LL13@expand_dec:

; 7852 :             {
; 7853 :               high2_h = high1_h | (h2 << count1_h);

	mov	ecx, DWORD PTR _count1_h$1$[ebp]
	mov	edx, eax

; 7854 :               high2_v = high1_v | (v2 << count1_v);
; 7855 : 
; 7856 :               val >>= 2;

	mov	eax, DWORD PTR _val$1$[ebp]
	shl	edx, cl
	or	edx, DWORD PTR _h1$1$[ebp]
	sar	eax, 2
	mov	DWORD PTR _high2_h$1$[ebp], edx
	mov	DWORD PTR _val$1$[ebp], eax

; 7857 :               if ((val & 3) == 0)

	test	al, 3
	jne	SHORT $LN22@expand_dec

; 7858 :                 { // This subband is refined no further
; 7859 :                   descriptors[num_bands++] = (kdu_int16)

	mov	ecx, DWORD PTR _num_bands$1$[ebp]
	lea	eax, DWORD PTR [edi+ebx*4]
	shl	eax, 6
	add	eax, edx
	mov	edx, DWORD PTR _descriptors$[ebp]
	lea	eax, DWORD PTR [esi+eax*4]
	mov	WORD PTR [edx+ecx*2], ax
	inc	ecx
	mov	DWORD PTR _num_bands$1$[ebp], ecx

; 7860 :                     (count2_h + (high2_h<<2) + (count2_v<<8) + (high2_v<<10));
; 7861 :                   continue;

	jmp	SHORT $LN11@expand_dec
$LN22@expand_dec:

; 7862 :                 }
; 7863 :               num_hor3 = (val & 1) + 1;

	mov	ebx, eax

; 7864 :               num_vert3 = ((val >> 1) & 1) + 1;

	sar	eax, 1
	and	ebx, 1
	and	eax, 1
	inc	ebx
	inc	eax
	mov	DWORD PTR _num_vert3$1$[ebp], eax

; 7865 : 
; 7866 :               count3_h = count2_h + (num_hor3-1);

	lea	ecx, DWORD PTR [ebx-1]
	add	ecx, esi

; 7867 :               count3_v = count2_v + (num_vert3-1);
; 7868 :               
; 7869 :               for (v3=0; v3 < num_vert3; v3++)

	xor	esi, esi
	mov	DWORD PTR _count3_h$1$[ebp], ecx
	mov	ecx, DWORD PTR _count2_v$1$[ebp]
	mov	DWORD PTR _v3$1$[ebp], esi
	lea	edx, DWORD PTR [ecx-1]
	add	edx, eax
	mov	DWORD PTR _count3_v$1$[ebp], edx
	test	eax, eax
	jg	SHORT $LN16@expand_dec
	mov	ecx, DWORD PTR _num_bands$1$[ebp]
$LN53@expand_dec:
	mov	edi, DWORD PTR _count2_v$1$[ebp]
	mov	esi, DWORD PTR _count2_h$1$[ebp]
	mov	ebx, DWORD PTR _high2_v$1$[ebp]
$LN11@expand_dec:

; 7851 :           for (h2=0; h2 < num_hor2; h2++)

	mov	eax, DWORD PTR _h2$1$[ebp]
	mov	edx, DWORD PTR _num_hor2$1$[ebp]
	inc	eax
	mov	DWORD PTR _h2$1$[ebp], eax
	cmp	eax, edx
	jl	SHORT $LL13@expand_dec
	mov	ebx, DWORD PTR _num_vert2$1$[ebp]
$LN8@expand_dec:

; 7849 : 
; 7850 :         for (v2=0; v2 < num_vert2; v2++)

	mov	eax, DWORD PTR _v2$1$[ebp]
	inc	eax
	mov	DWORD PTR _v2$1$[ebp], eax
	cmp	eax, ebx
	jl	$LL10@expand_dec
	mov	ebx, DWORD PTR _h1$1$[ebp]
$LN52@expand_dec:
	mov	edi, DWORD PTR _v1$1$[ebp]
	mov	esi, DWORD PTR _count1_h$1$[ebp]
$LN5@expand_dec:

; 7825 :     for (h1=0; h1 < num_hor1; h1++)

	mov	edx, DWORD PTR _count1_v$1$[ebp]
	inc	ebx
	mov	eax, DWORD PTR _decomp_val$[ebp]
	mov	DWORD PTR _h1$1$[ebp], ebx
	cmp	ebx, DWORD PTR _num_hor1$1$[ebp]
	jl	$LL7@expand_dec
$LN2@expand_dec:

; 7824 :   for (v1=0; v1 < num_vert1; v1++)

	inc	edi
	mov	DWORD PTR _v1$1$[ebp], edi
	cmp	edi, DWORD PTR _num_vert1$1$[ebp]
	jl	$LL4@expand_dec
$LN48@expand_dec:
	pop	edi
	pop	esi

; 7875 :                     (count3_h + (high3_h<<2) + (count3_v<<8) + (high3_v<<10));
; 7876 :                   }
; 7877 :             }
; 7878 :       }
; 7879 :   assert(num_bands <= 49);
; 7880 :   return num_bands;

	mov	eax, ecx
	pop	ebx

; 7881 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LL51@expand_dec:
	mov	ecx, DWORD PTR _count2_v$1$[ebp]
$LN16@expand_dec:

; 7870 :                 for (h3=0; h3 < num_hor3; h3++)

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN50@expand_dec
	mov	ax, si
	mov	esi, DWORD PTR _descriptors$[ebp]
	shl	ax, cl
	or	ax, WORD PTR _high2_v$1$[ebp]
	shl	ax, 2
	add	ax, dx
	shl	ax, 6
$LL19@expand_dec:

; 7871 :                   {
; 7872 :                     high3_h = high2_h | (h3 << count2_h);

	mov	ecx, DWORD PTR _count2_h$1$[ebp]
	mov	dx, di
	shl	dx, cl
	inc	edi
	or	dx, WORD PTR _high2_h$1$[ebp]

; 7873 :                     high3_v = high2_v | (v3 << count2_v);
; 7874 :                     descriptors[num_bands++] = (kdu_int16)

	mov	ecx, DWORD PTR _num_bands$1$[ebp]
	add	dx, ax
	shl	dx, 2
	add	dx, WORD PTR _count3_h$1$[ebp]
	mov	WORD PTR [esi+ecx*2], dx
	inc	ecx
	mov	DWORD PTR _num_bands$1$[ebp], ecx
	cmp	edi, ebx
	jl	SHORT $LL19@expand_dec
	mov	esi, DWORD PTR _v3$1$[ebp]
	mov	eax, DWORD PTR _num_vert3$1$[ebp]
	mov	edx, DWORD PTR _count3_v$1$[ebp]
	jmp	SHORT $LN14@expand_dec
$LN50@expand_dec:
	mov	ecx, DWORD PTR _num_bands$1$[ebp]
$LN14@expand_dec:

; 7867 :               count3_v = count2_v + (num_vert3-1);
; 7868 :               
; 7869 :               for (v3=0; v3 < num_vert3; v3++)

	inc	esi
	mov	DWORD PTR _v3$1$[ebp], esi
	cmp	esi, eax
	jl	SHORT $LL51@expand_dec
	jmp	$LN53@expand_dec
?expand_decomp_bands@cod_params@@SAHHQAF@Z ENDP		; cod_params::expand_decomp_bands
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?transpose_decomp@cod_params@@SAHH@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
?transpose_decomp@cod_params@@SAHH@Z PROC		; cod_params::transpose_decomp, COMDAT

; 7719 : {

	push	ebp
	mov	ebp, esp

; 7720 :   if ((val & 3) == 3) // F0 == 3

	mov	edx, DWORD PTR _val$[ebp]
	mov	eax, edx
	and	eax, 3
	cmp	al, 3
	jne	SHORT $LN2@transpose_

; 7721 :     { // Swap LH and HL primary detail subband splitting descriptors
; 7722 :       val = (val & 0xFFC00003) |

	mov	ecx, edx
	mov	eax, edx
	sar	ecx, 10					; 0000000aH
	and	eax, 4092				; 00000ffcH
	and	ecx, 4092				; 00000ffcH
	shl	eax, 10					; 0000000aH
	or	ecx, eax
	and	edx, -4194301				; ffc00003H
	or	edx, ecx
$LN2@transpose_:

; 7723 :         ((val & 0x00000FFC) << 10) | ((val >> 10) & 0x00000FFC);
; 7724 :     }
; 7725 : 
; 7726 :   if (((val >> 2) & 3) == 3) // F1 == 3

	mov	ecx, edx
	sar	ecx, 2
	mov	eax, ecx
	and	eax, 3
	cmp	al, 3
	jne	SHORT $LN3@transpose_

; 7727 :     { // Swap F3 (HL) with F4 (LH) secondary splitting descriptors
; 7728 :       val = (val & 0xFFFFFC3F) |

	mov	eax, edx
	and	ecx, 192				; 000000c0H
	and	eax, 192				; 000000c0H
	and	edx, -961				; fffffc3fH
	shl	eax, 2
	or	eax, ecx
	or	edx, eax
$LN3@transpose_:

; 7729 :         ((val & 0x000000C0) << 2) | ((val >> 2) & 0x000000C0);
; 7730 :     }
; 7731 :   if (((val >> 12) & 3) == 3) // F6 == 3

	mov	eax, edx
	and	eax, 12288				; 00003000H
	cmp	eax, 12288				; 00003000H
	jne	SHORT $LN4@transpose_

; 7732 :     { // Swap F8 (HL) with F9 (LH) secondary splitting descriptors
; 7733 :       val = (val & 0xFFF0FFFF) |

	mov	ecx, edx
	mov	eax, edx
	sar	ecx, 2
	and	eax, 196608				; 00030000H
	and	ecx, 196608				; 00030000H
	shl	eax, 2
	or	ecx, eax
	and	edx, -983041				; fff0ffffH
	or	edx, ecx
$LN4@transpose_:

; 7734 :         ((val & 0x00030000) << 2) | ((val >> 2) & 0x00030000);
; 7735 :     }
; 7736 :   if (((val >> 22) & 3) == 3) // F11 == 3

	mov	eax, edx
	and	eax, 12582912				; 00c00000H
	cmp	eax, 12582912				; 00c00000H
	jne	SHORT $LN5@transpose_

; 7737 :     { // Swap F13(HL) with F14(LH) secondary splitting descriptors
; 7738 :       val = (val & 0xC3FFFFFF) |

	mov	ecx, edx
	mov	eax, edx
	sar	ecx, 2
	and	eax, 201326592				; 0c000000H
	and	ecx, 201326592				; 0c000000H
	shl	eax, 2
	or	ecx, eax
	and	edx, -1006632961			; c3ffffffH
	or	edx, ecx
$LN5@transpose_:

; 7739 :         ((val & 0x0C000000) << 2) | ((val >> 2) & 0x0C000000);
; 7740 :     }
; 7741 : 
; 7742 :   // Finally, swap the odd and even bit positions of F0 through F15
; 7743 :   val = ((val & 0x55555555) << 1) | ((val >> 1) & 0x55555555);

	mov	eax, edx

; 7744 : 
; 7745 :   return val;

	lea	ecx, DWORD PTR [edx+edx]
	sar	eax, 1
	xor	eax, ecx
	lea	ecx, DWORD PTR [edx+edx]
	and	eax, 1431655765				; 55555555H
	xor	eax, ecx

; 7746 : }

	pop	ebp
	ret	0
?transpose_decomp@cod_params@@SAHH@Z ENDP		; cod_params::transpose_decomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?textualize_decomp@cod_params@@SAXQADH@Z
_TEXT	SEGMENT
_num_primary_bands$1$ = 8				; size = 4
_num_primary_bands$ = 8					; size = 4
_buf$ = 8						; size = 4
_val$ = 12						; size = 4
?textualize_decomp@cod_params@@SAXQADH@Z PROC		; cod_params::textualize_decomp, COMDAT

; 7594 : {

	push	ebp
	mov	ebp, esp

; 7595 :   char *bp=buf;

	mov	eax, DWORD PTR _buf$[ebp]
	push	ebx
	push	edi

; 7596 :   int b, num_primary_bands;
; 7597 : 
; 7598 :   switch (val & 3) {

	mov	edi, DWORD PTR _val$[ebp]
	mov	ecx, edi
	and	ecx, 3
	cmp	ecx, 3
	ja	SHORT $LN39@textualize
	jmp	DWORD PTR $LN45@textualize[ecx*4]
$LN12@textualize:

; 7599 :       case 0:
; 7600 :         *(bp++) = '-'; num_primary_bands = 0; break;

	mov	BYTE PTR [eax], 45			; 0000002dH
	inc	eax
	xor	ecx, ecx
	jmp	SHORT $LN42@textualize
$LN13@textualize:

; 7601 :       case 1:
; 7602 :         *(bp++) = 'H'; num_primary_bands = 1; break;

	mov	BYTE PTR [eax], 72			; 00000048H
	mov	ecx, 1
	inc	eax
	jmp	SHORT $LN42@textualize
$LN14@textualize:

; 7603 :       case 2:
; 7604 :         *(bp++) = 'V'; num_primary_bands = 1; break;

	mov	BYTE PTR [eax], 86			; 00000056H
	mov	ecx, 1
	inc	eax
	jmp	SHORT $LN42@textualize
$LN15@textualize:

; 7605 :       case 3:
; 7606 :         *(bp++) = 'B'; num_primary_bands = 3; break;

	mov	BYTE PTR [eax], 66			; 00000042H
	mov	ecx, 3
	inc	eax
	jmp	SHORT $LN42@textualize
$LN39@textualize:
	mov	ecx, DWORD PTR _num_primary_bands$[ebp]
$LN42@textualize:

; 7607 :     }
; 7608 : 
; 7609 :   *(bp++) = '(';

	mov	BYTE PTR [eax], 40			; 00000028H

; 7610 : 
; 7611 :   for (val>>=2, b=0; b < num_primary_bands; b++, val>>=10)

	xor	ebx, ebx
	inc	eax
	sar	edi, 2
	mov	DWORD PTR _num_primary_bands$1$[ebp], ecx
	test	ecx, ecx
	jle	SHORT $LN38@textualize
	push	esi
	lea	esi, DWORD PTR [ebx+3]
	npad	4
$LL6@textualize:

; 7612 :     {
; 7613 :       if (b > 0)

	test	ebx, ebx
	jle	SHORT $LN16@textualize

; 7614 :         *(bp++) = ':';

	mov	BYTE PTR [eax], 58			; 0000003aH
	inc	eax
$LN16@textualize:

; 7615 :       int tmp, num_chars = 1;
; 7616 :       if ((val & 3) == 3)

	mov	ecx, edi
	mov	edx, 1
	and	ecx, 3
	cmp	ecx, 3
	jne	SHORT $LN17@textualize

; 7617 :         num_chars += 4;

	lea	edx, DWORD PTR [ecx+2]

; 7619 :         num_chars += 2;
; 7620 :       for (tmp=val; num_chars > 0; num_chars--, tmp >>= 2)

	mov	esi, edi
	jmp	SHORT $LL40@textualize
$LN17@textualize:

; 7618 :       else if ((val & 3) != 0)

	test	ecx, ecx
	cmovne	edx, esi

; 7619 :         num_chars += 2;
; 7620 :       for (tmp=val; num_chars > 0; num_chars--, tmp >>= 2)

	mov	esi, edi
	test	edx, edx
	jle	SHORT $LN4@textualize
	npad	7
$LL40@textualize:

; 7621 :         switch (tmp & 3) {

	mov	ecx, esi
	and	ecx, 3
	cmp	ecx, 3
	ja	SHORT $LN7@textualize
	jmp	DWORD PTR $LN46@textualize[ecx*4]
$LN20@textualize:

; 7622 :             case 0: *(bp++) = '-'; break;

	mov	BYTE PTR [eax], 45			; 0000002dH
	jmp	SHORT $LN43@textualize
$LN21@textualize:

; 7623 :             case 1: *(bp++) = 'H'; break;

	mov	BYTE PTR [eax], 72			; 00000048H
	jmp	SHORT $LN43@textualize
$LN22@textualize:

; 7624 :             case 2: *(bp++) = 'V'; break;

	mov	BYTE PTR [eax], 86			; 00000056H
	jmp	SHORT $LN43@textualize
$LN23@textualize:

; 7625 :             case 3: *(bp++) = 'B'; break;

	mov	BYTE PTR [eax], 66			; 00000042H
$LN43@textualize:
	inc	eax
$LN7@textualize:

; 7619 :         num_chars += 2;
; 7620 :       for (tmp=val; num_chars > 0; num_chars--, tmp >>= 2)

	dec	edx
	sar	esi, 2
	test	edx, edx
	jg	SHORT $LL40@textualize
$LN4@textualize:

; 7610 : 
; 7611 :   for (val>>=2, b=0; b < num_primary_bands; b++, val>>=10)

	inc	ebx
	sar	edi, 10					; 0000000aH
	mov	esi, 3
	cmp	ebx, DWORD PTR _num_primary_bands$1$[ebp]
	jl	SHORT $LL6@textualize
	pop	esi
$LN38@textualize:
	pop	edi

; 7626 :           }
; 7627 :     }
; 7628 :   *(bp++) = ')';

	mov	WORD PTR [eax], 41			; 00000029H
	pop	ebx

; 7629 :   *bp = '\0';
; 7630 :   assert((bp-buf) <= 20);
; 7631 : }

	pop	ebp
	ret	0
$LN45@textualize:
	DD	$LN12@textualize
	DD	$LN13@textualize
	DD	$LN14@textualize
	DD	$LN15@textualize
$LN46@textualize:
	DD	$LN20@textualize
	DD	$LN21@textualize
	DD	$LN22@textualize
	DD	$LN23@textualize
?textualize_decomp@cod_params@@SAXQADH@Z ENDP		; cod_params::textualize_decomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?is_valid_decomp_terminator@cod_params@@SA_NH@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
?is_valid_decomp_terminator@cod_params@@SA_NH@Z PROC	; cod_params::is_valid_decomp_terminator, COMDAT

; 7889 : {

	push	ebp
	mov	ebp, esp

; 7890 :   if ((val & 3) == 3)

	mov	ecx, DWORD PTR _val$[ebp]
	mov	eax, ecx
	and	eax, 3
	cmp	al, 3
	jne	SHORT $LN5@is_valid_d

; 7891 :     {
; 7892 :       if ((((val >> 2) & 0x000003FF) != ((val >> 12) & 0x000003FF)) ||

	mov	edx, ecx
	mov	eax, ecx
	sar	edx, 2
	sar	eax, 12					; 0000000cH
	and	edx, 1023				; 000003ffH
	and	eax, 1023				; 000003ffH
	cmp	edx, eax
	jne	SHORT $LN6@is_valid_d
	mov	eax, ecx
	sar	eax, 22					; 00000016H
	and	eax, 1023				; 000003ffH
	cmp	edx, eax
	jne	SHORT $LN6@is_valid_d
$LN5@is_valid_d:

; 7893 :           (((val >> 2) & 0x000003FF) != ((val >> 22) & 0x000003FF)))
; 7894 :         return false; // Different splitting operations for the three
; 7895 :                       // primary detail subbands.
; 7896 :     }
; 7897 :   if (((val >> 4) & 0x000000FF) == 0)

	mov	eax, ecx
	sar	eax, 4
	movzx	edx, al
	test	al, al
	je	SHORT $LN10@is_valid_d

; 7898 :     return true; // At most one level of additional splitting
; 7899 : 
; 7900 :   switch ((val >> 2) & 3) {

	sar	ecx, 2
	and	ecx, 3
	sub	ecx, 1
	je	SHORT $LN9@is_valid_d
	sub	ecx, 1
	je	SHORT $LN11@is_valid_d
	sub	ecx, 1
	jne	SHORT $LN10@is_valid_d

; 7909 :         break;
; 7910 :       case 3:
; 7911 :         if (((val >> 4) & 0xFF) != 0xFF)

	cmp	edx, 255				; 000000ffH
	je	SHORT $LN10@is_valid_d

; 7912 :           return false;

	xor	al, al

; 7916 : }

	pop	ebp
	ret	0
$LN11@is_valid_d:

; 7904 :           return false;
; 7905 :         break;
; 7906 :       case 2:
; 7907 :         if (((val >> 4) & 0x0F) != 0x0C)

	and	eax, 15					; 0000000fH
	cmp	al, 12					; 0000000cH
	je	SHORT $LN10@is_valid_d
$LN6@is_valid_d:

; 7908 :           return false;

	xor	al, al

; 7916 : }

	pop	ebp
	ret	0
$LN9@is_valid_d:

; 7901 :       case 0: break;
; 7902 :       case 1:
; 7903 :         if (((val >> 4) & 0x0F) != 0x05)

	and	eax, 15					; 0000000fH
	cmp	al, 5
	jne	SHORT $LN6@is_valid_d
$LN10@is_valid_d:

; 7913 :         break;
; 7914 :     }
; 7915 :   return true;

	mov	al, 1

; 7916 : }

	pop	ebp
	ret	0
?is_valid_decomp_terminator@cod_params@@SA_NH@Z ENDP	; cod_params::is_valid_decomp_terminator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?custom_textualize_field@cod_params@@MAEXAAVkdu_message@@PBDHH@Z
_TEXT	SEGMENT
_buf$1 = -28						; size = 21
__$ArrayPad$ = -4					; size = 4
_output$ = 8						; size = 4
_name$ = 12						; size = 4
_field_idx$ = 16					; size = 4
_val$ = 20						; size = 4
?custom_textualize_field@cod_params@@MAEXAAVkdu_message@@PBDHH@Z PROC ; cod_params::custom_textualize_field, COMDAT
; _this$ = ecx

; 7640 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7641 :   if ((strcmp(name,Cdecomp) == 0) && (field_idx == 0))

	mov	eax, DWORD PTR _name$[ebp]
	mov	ecx, OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	push	esi
	mov	esi, DWORD PTR _output$[ebp]
	npad	4
$LL6@custom_tex:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN7@custom_tex
	test	dl, dl
	je	SHORT $LN8@custom_tex
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN7@custom_tex
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL6@custom_tex
$LN8@custom_tex:
	xor	eax, eax
	jmp	SHORT $LN9@custom_tex
$LN7@custom_tex:
	sbb	eax, eax
	or	eax, 1
$LN9@custom_tex:
	test	eax, eax
	jne	SHORT $LN2@custom_tex
	cmp	DWORD PTR _field_idx$[ebp], eax
	jne	SHORT $LN2@custom_tex

; 7644 :       textualize_decomp(buf,val);

	push	DWORD PTR _val$[ebp]
	lea	eax, DWORD PTR _buf$1[ebp]
	push	eax
	call	?textualize_decomp@cod_params@@SAXQADH@Z ; cod_params::textualize_decomp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _buf$1[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7644 :       textualize_decomp(buf,val);

	add	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]
$LN2@custom_tex:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7647 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?custom_textualize_field@cod_params@@MAEXAAVkdu_message@@PBDHH@Z ENDP ; cod_params::custom_textualize_field
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?custom_parse_field@cod_params@@MAEHPBD0HAAH@Z
_TEXT	SEGMENT
_string_start$1$ = -8					; size = 4
tv277 = -4						; size = 4
_b$1$ = 8						; size = 4
_string$ = 8						; size = 4
_sub_chars$1$ = 12					; size = 4
_name$ = 12						; size = 4
_num_primary_bands$1$ = 16				; size = 4
_field_idx$ = 16					; size = 4
_val$ = 20						; size = 4
?custom_parse_field@cod_params@@MAEHPBD0HAAH@Z PROC	; cod_params::custom_parse_field, COMDAT
; _this$ = ecx

; 7656 : {

	push	ebp
	mov	ebp, esp

; 7657 :   if ((strcmp(name,Cdecomp) != 0) || (field_idx != 0))

	mov	eax, DWORD PTR _name$[ebp]
	sub	esp, 8
	mov	ecx, OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	npad	2
$LL41@custom_par:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN42@custom_par
	test	dl, dl
	je	SHORT $LN43@custom_par
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN42@custom_par
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL41@custom_par
$LN43@custom_par:
	xor	eax, eax
	jmp	SHORT $LN44@custom_par
$LN42@custom_par:
	sbb	eax, eax
	or	eax, 1
$LN44@custom_par:
	test	eax, eax
	jne	$LN11@custom_par
	cmp	DWORD PTR _field_idx$[ebp], eax
	jne	$LN11@custom_par

; 7659 :   const char *string_start = string;

	push	ebx
	push	esi
	mov	esi, DWORD PTR _string$[ebp]
	mov	ebx, esi
	mov	DWORD PTR _string_start$1$[ebp], ebx

; 7660 :   int num_primary_bands;
; 7661 :   switch (*string) {

	movsx	eax, BYTE PTR [esi]
	add	eax, -45				; ffffffd3H
	cmp	eax, 41					; 00000029H
	ja	$LN16@custom_par
	movzx	eax, BYTE PTR $LN45@custom_par[eax]
	jmp	DWORD PTR $LN57@custom_par[eax*4]
$LN12@custom_par:

; 7662 :       case '-': val = 0; num_primary_bands = 0; break;

	mov	ecx, DWORD PTR _val$[ebp]
	xor	edx, edx
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN53@custom_par
$LN13@custom_par:

; 7663 :       case 'H': val = 1; num_primary_bands = 1; break;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, 1
	mov	DWORD PTR [ecx], 1
	jmp	SHORT $LN53@custom_par
$LN14@custom_par:

; 7664 :       case 'V': val = 2; num_primary_bands = 1; break;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, 1
	mov	DWORD PTR [ecx], 2
	jmp	SHORT $LN53@custom_par
$LN15@custom_par:

; 7665 :       case 'B': val = 3; num_primary_bands = 3; break;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, 3
	mov	DWORD PTR [ecx], 3
$LN53@custom_par:

; 7668 :     };
; 7669 :   string++;
; 7670 :   if (*(string++) != '(')

	mov	al, BYTE PTR [esi+1]
	add	esi, 2
	mov	DWORD PTR _num_primary_bands$1$[ebp], edx
	cmp	al, 40					; 00000028H
	je	SHORT $LN17@custom_par

; 7671 :     return (val = 0); // Error condition; no valid characters

	pop	esi
	mov	DWORD PTR [ecx], 0
	xor	eax, eax
	pop	ebx

; 7711 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN17@custom_par:

; 7672 : 
; 7673 :   int b;
; 7674 :   for (b=0; b < num_primary_bands; b++)

	xor	eax, eax
	mov	DWORD PTR _b$1$[ebp], eax
	push	edi
	test	edx, edx
	jle	$LN5@custom_par
	mov	DWORD PTR tv277[ebp], 2
	npad	6
$LL6@custom_par:

; 7675 :     {
; 7676 :       if (b > 0)

	test	eax, eax
	jle	SHORT $LN18@custom_par

; 7677 :         {
; 7678 :           if ((*string != ':') && (*string != ','))

	mov	al, BYTE PTR [esi]
	cmp	al, 58					; 0000003aH
	je	SHORT $LN19@custom_par
	cmp	al, 44					; 0000002cH
	jne	$LN33@custom_par
$LN19@custom_par:

; 7679 :             return (val = 0); // Error condition; no valid characters
; 7680 :           string++;

	inc	esi
$LN18@custom_par:

; 7681 :         }
; 7682 : 
; 7683 :       int n, sub_val, sub_chars, code;
; 7684 :       for (n=0, sub_chars=1, sub_val=0; n < sub_chars; n++, string++)

	xor	edi, edi
	mov	DWORD PTR _sub_chars$1$[ebp], 1
	xor	ebx, ebx
	npad	2
$LL9@custom_par:

; 7685 :         {
; 7686 :           if (*string == '-')

	mov	al, BYTE PTR [esi]
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN20@custom_par

; 7687 :             code = 0;

	xor	eax, eax
	jmp	SHORT $LN27@custom_par
$LN20@custom_par:

; 7688 :           else if (*string == 'H')

	cmp	al, 72					; 00000048H
	jne	SHORT $LN22@custom_par

; 7689 :             code = 1;

	mov	eax, 1
	jmp	SHORT $LN27@custom_par
$LN22@custom_par:

; 7690 :           else if (*string == 'V')

	cmp	al, 86					; 00000056H
	jne	SHORT $LN24@custom_par

; 7691 :             code = 2;

	mov	eax, 2
	jmp	SHORT $LN27@custom_par
$LN24@custom_par:

; 7692 :           else if (*string == 'B')

	cmp	al, 66					; 00000042H
	jne	$LN26@custom_par

; 7693 :             code = 3;

	mov	eax, 3
$LN27@custom_par:

; 7696 :           sub_val += code << (2*n);

	lea	ecx, DWORD PTR [edi+edi]
	mov	edx, eax
	shl	edx, cl
	add	ebx, edx

; 7697 :           if ((n == 0) && (string[1] != ':') &&
; 7698 :               (string[1] != ')') && (string[1] != ','))

	test	edi, edi
	jne	SHORT $LN49@custom_par
	mov	cl, BYTE PTR [esi+1]
	cmp	cl, 58					; 0000003aH
	je	SHORT $LN49@custom_par
	cmp	cl, 41					; 00000029H
	je	SHORT $LN49@custom_par
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN49@custom_par

; 7699 :             {
; 7700 :               sub_chars += (code > 0)?2:0;
; 7701 :               sub_chars += (code == 3)?2:0;

	xor	edx, edx
	mov	ecx, 2
	cmp	eax, 3
	cmove	edx, ecx
	xor	ecx, ecx
	test	eax, eax
	mov	eax, 2
	cmovg	ecx, eax
	add	ecx, DWORD PTR _sub_chars$1$[ebp]
	lea	eax, DWORD PTR [ecx+edx]
	mov	DWORD PTR _sub_chars$1$[ebp], eax
	jmp	SHORT $LN7@custom_par
$LN49@custom_par:
	mov	eax, DWORD PTR _sub_chars$1$[ebp]
$LN7@custom_par:

; 7681 :         }
; 7682 : 
; 7683 :       int n, sub_val, sub_chars, code;
; 7684 :       for (n=0, sub_chars=1, sub_val=0; n < sub_chars; n++, string++)

	inc	edi
	inc	esi
	cmp	edi, eax
	jl	SHORT $LL9@custom_par

; 7702 :             }
; 7703 :         }
; 7704 :       val |= (sub_val << ((10*b)+2));

	mov	edx, DWORD PTR tv277[ebp]
	mov	ecx, edx
	mov	eax, DWORD PTR _b$1$[ebp]
	add	edx, 10					; 0000000aH
	shl	ebx, cl
	inc	eax
	mov	ecx, DWORD PTR _val$[ebp]
	mov	DWORD PTR _b$1$[ebp], eax
	mov	DWORD PTR tv277[ebp], edx
	or	DWORD PTR [ecx], ebx
	cmp	eax, DWORD PTR _num_primary_bands$1$[ebp]
	jl	$LL6@custom_par

; 7677 :         {
; 7678 :           if ((*string != ':') && (*string != ','))

	mov	ebx, DWORD PTR _string_start$1$[ebp]
$LN5@custom_par:

; 7705 :     }
; 7706 : 
; 7707 :   if (*(string++) != ')')

	cmp	BYTE PTR [esi], 41			; 00000029H
	je	SHORT $LN29@custom_par
$LN33@custom_par:
	pop	edi
	pop	esi

; 7708 :     return (val = 0); // Error condition

	mov	DWORD PTR [ecx], 0
	xor	eax, eax
	pop	ebx

; 7711 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN26@custom_par:

; 7694 :           else
; 7695 :             return (val = 0); // Error condition

	mov	eax, DWORD PTR _val$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], 0
	xor	eax, eax

; 7711 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN29@custom_par:

; 7709 : 
; 7710 :   return (int)(string-string_start);

	sub	esi, ebx
	pop	edi
	lea	eax, DWORD PTR [esi+1]
	pop	esi
	pop	ebx

; 7711 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN16@custom_par:

; 7666 :       default:
; 7667 :         return (val = 0); // Error condition; no valid characters

	mov	eax, DWORD PTR _val$[ebp]
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], 0
	xor	eax, eax

; 7711 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN11@custom_par:

; 7658 :     return (val = 0);

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [eax], 0
	xor	eax, eax

; 7711 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	2
$LN57@custom_par:
	DD	$LN12@custom_par
	DD	$LN15@custom_par
	DD	$LN13@custom_par
	DD	$LN14@custom_par
	DD	$LN16@custom_par
$LN45@custom_par:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
?custom_parse_field@cod_params@@MAEHPBD0HAAH@Z ENDP	; cod_params::custom_parse_field
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?read_marker_segment@cod_params@@MAE_NGHQAEH@Z
_TEXT	SEGMENT
_e$2 = -204						; size = 20
$T3 = -184						; size = 4
$T4 = -180						; size = 4
$T5 = -176						; size = 4
$T6 = -172						; size = 4
$T7 = -168						; size = 4
$T8 = -164						; size = 4
$T9 = -160						; size = 4
$T10 = -156						; size = 4
$T11 = -152						; size = 4
$T12 = -148						; size = 4
$T13 = -144						; size = 4
_ppx$1$ = -140						; size = 4
_end$ = -140						; size = 4
_e$14 = -136						; size = 20
_w$15 = -136						; size = 20
_e$16 = -136						; size = 20
_e$17 = -136						; size = 20
_e$18 = -136						; size = 20
_e$19 = -136						; size = 20
_bp$ = -116						; size = 4
_val$1$ = -112						; size = 4
_n$1$ = -112						; size = 4
_use_precincts$ = -112					; size = 1
_val$1$ = -108						; size = 4
_levels$1$ = -108					; size = 4
_reversible$20 = -108					; size = 1
_this$GSCopy$ = -108					; size = 4
_profile$21 = -108					; size = 4
_val$1$ = -104						; size = 4
_val$1$ = -104						; size = 4
_levels$22 = -104					; size = 4
_text$23 = -100						; size = 80
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_tpart_idx$ = 20					; size = 4
?read_marker_segment@cod_params@@MAE_NGHQAEH@Z PROC	; cod_params::read_marker_segment, COMDAT
; _this$ = ecx

; 6747 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 6748 :   kdu_byte *bp, *end;
; 6749 :   bool use_precincts;
; 6750 : 
; 6751 :   if (tpart_idx != 0)

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	mov	eax, DWORD PTR _num_bytes$[ebp]
	mov	esi, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _this$GSCopy$[ebp], edi
	je	SHORT $LN5@read_marke
$LN150@read_marke:

; 6752 :     return false;

	xor	al, al
	jmp	$LN1@read_marke
$LN5@read_marke:

; 6753 :   bp = bytes;
; 6754 :   end = bp + num_bytes;
; 6755 :   if (comp_idx < 0)

	mov	edx, DWORD PTR [edi+12]
	lea	ebx, DWORD PTR [esi+eax]
	mov	DWORD PTR _bp$[ebp], esi
	mov	DWORD PTR _end$[ebp], ebx
	test	edx, edx
	jns	$LN6@read_marke

; 6756 :     { // Need COD
; 6757 :       if (code != KDU_COD)

	mov	eax, 65362				; 0000ff52H
	cmp	WORD PTR _code$[ebp], ax
	jne	SHORT $LN150@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6759 :       try {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN53@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T13[ebp]
	mov	DWORD PTR $T13[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN151@read_marke:
$LN53@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6761 :           if (style != (style & 31))

	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _val$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6761 :           if (style != (style & 31))

	and	eax, 31					; 0000001fH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6761 :           if (style != (style & 31))

	cmp	ecx, eax
	je	SHORT $LN10@read_marke

; 6762 :             { KDU_ERROR(e,101); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$19[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$19[ebp]
	lea	ecx, DWORD PTR _e$19[ebp]
	push	OFFSET ??_C@_0EA@CJECMJPA@Malformed?5COD?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6762 :             { KDU_ERROR(e,101); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6765 :             }

	lea	ecx, DWORD PTR _e$19[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _val$1$[ebp]
$LN10@read_marke:

; 6766 :           set(Cuse_precincts,0,0,use_precincts = (style&1)?true:false);

	and	cl, 1
	mov	BYTE PTR _use_precincts$[ebp], cl
	mov	ecx, edi
	push	DWORD PTR _use_precincts$[ebp]
	push	0
	push	0
	push	OFFSET ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 6767 :           set(Cuse_sop,0,0,(style&2)?true:false);

	mov	eax, DWORD PTR _val$1$[ebp]
	mov	ecx, edi
	shr	eax, 1
	and	al, 1
	movzx	eax, al
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08DAJNLNLL@Cuse_sop?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 6768 :           set(Cuse_eph,0,0,(style&4)?true:false);

	mov	eax, DWORD PTR _val$1$[ebp]
	mov	ecx, edi
	shr	eax, 2
	and	al, 1
	movzx	eax, al
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08NAIOMJOM@Cuse_eph?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 6769 :           set(Calign_blk_last,0,1,(style&8)?true:false);

	mov	eax, DWORD PTR _val$1$[ebp]
	mov	ecx, edi
	shr	eax, 3
	and	al, 1
	movzx	eax, al
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 6770 :           set(Calign_blk_last,0,0,(style&16)?true:false);

	mov	eax, DWORD PTR _val$1$[ebp]
	mov	ecx, edi
	shr	eax, 4
	and	al, 1
	movzx	eax, al
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN62@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T12[ebp]
	mov	DWORD PTR $T12[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN152@read_marke:
$LN62@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6771 :           set(Corder,0,0,kdu_read(bp,end,1));

	mov	ecx, edi
	push	eax
	push	0
	push	0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6771 :           set(Corder,0,0,kdu_read(bp,end,1));

	push	OFFSET ??_C@_06IKJBDDKO@Corder?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6771 :           set(Corder,0,0,kdu_read(bp,end,1));

	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN68@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR $T11[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN153@read_marke:
$LN68@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 93   :   if (nbytes > 1)
; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	ecx, 8
	add	ecx, eax
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6772 :           set(Clayers,0,0,kdu_read(bp,end,2));

	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_07BJCMAMHC@Clayers?$AA@
	mov	ecx, edi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN74@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR $T10[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN154@read_marke:
$LN74@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6774 :           set(Cycc,0,0,(sgcod & 1)?true:false);

	mov	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _val$1$[ebp], eax
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6774 :           set(Cycc,0,0,(sgcod & 1)?true:false);

	and	al, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6774 :           set(Cycc,0,0,(sgcod & 1)?true:false);

	movzx	eax, al
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04DEPIIIHA@Cycc?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 6775 :           set(Cmct,0,0,(sgcod & 1)?0:(sgcod & 6));

	mov	eax, DWORD PTR _val$1$[ebp]
	test	al, 1
	je	SHORT $LN31@read_marke
	xor	eax, eax
	jmp	SHORT $LN32@read_marke
$LN31@read_marke:
	and	eax, 6
$LN32@read_marke:
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04OOAAMMCO@Cmct?$AA@
	mov	ecx, edi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	jmp	SHORT $LN146@read_marke
__catch$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$0:

; 6778 :         { KDU_ERROR(e,102); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$18[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$18[ebp]
	lea	ecx, DWORD PTR _e$18[ebp]
	push	OFFSET ??_C@_0EH@OJAEGGAB@Malformed?5COD?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6778 :         { KDU_ERROR(e,102); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6781 :         }

	lea	ecx, DWORD PTR _e$18[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN49@read_marke
	ret	0
$LN49@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
	mov	edi, DWORD PTR _this$GSCopy$[ebp]
	mov	ebx, DWORD PTR _end$[ebp]
	mov	esi, DWORD PTR _bp$[ebp]
$LN146@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6809 :     }
; 6810 : 
; 6811 :   if (tile_idx >= 0)

	cmp	DWORD PTR [edi+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jl	$LN18@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6812 :     { // Check for profile compatibility.
; 6813 :       kdu_params *siz = access_cluster(SIZ_params);

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	mov	ecx, edi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 6814 :       assert(siz != NULL);
; 6815 :       int profile = 2; siz->get(Sprofile,0,0,profile);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _profile$21[ebp]
	mov	DWORD PTR _profile$21[ebp], 2
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 6816 :       if (profile == 0)

	cmp	DWORD PTR _profile$21[ebp], 0
	jne	SHORT $LN18@read_marke

; 6817 :         { KDU_WARNING(w,3); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$15[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$15[ebp]
	lea	ecx, DWORD PTR _w$15[ebp]
	push	OFFSET ??_C@_0NK@HPJJFAAC@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6817 :         { KDU_WARNING(w,3); w <<

	mov	DWORD PTR __$EHRec$[ebp+12], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6822 :             << tile_idx << ".";

	push	DWORD PTR [edi+8]
	lea	ecx, DWORD PTR _w$15[ebp]
	call	??6kdu_message@@QAEAAV0@H@Z		; kdu_message::operator<<
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	mov	ecx, eax
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6823 :         }

	lea	ecx, DWORD PTR _w$15[ebp]
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN18@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6826 :   try {

	mov	DWORD PTR __$EHRec$[ebp+12], 9
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	sub	eax, esi
	cmp	eax, 1
	jge	$LN98@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR $T8[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN155@read_marke:
$LN6@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6787 :       if (code != KDU_COC)

	mov	eax, 65363				; 0000ff53H
	cmp	WORD PTR _code$[ebp], ax
	jne	$LN150@read_marke

; 6788 :         return false;
; 6789 :       if (get_num_comps() <= 256)

	cmp	DWORD PTR [edi+24], 256			; 00000100H

; 6790 :         which_comp = *(bp++);

	movzx	ecx, BYTE PTR [esi]
	jg	SHORT $LN12@read_marke
	inc	esi

; 6791 :       else

	jmp	SHORT $LN147@read_marke
$LN12@read_marke:

; 6792 :         { which_comp = *(bp++); which_comp = (which_comp<<8) + *(bp++); }

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax
	add	esi, 2
$LN147@read_marke:
	mov	DWORD PTR _bp$[ebp], esi

; 6793 :       if (which_comp != comp_idx)

	cmp	ecx, edx
	jne	$LN150@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6795 :       try {

	mov	DWORD PTR __$EHRec$[ebp+12], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN84@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR $T9[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN156@read_marke:
$LN84@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6797 :         if (style != (style & 1))

	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _val$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6797 :         if (style != (style & 1))

	and	eax, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6797 :         if (style != (style & 1))

	cmp	ecx, eax
	je	SHORT $LN16@read_marke

; 6798 :           { KDU_ERROR(e,103); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$17[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$17[ebp]
	lea	ecx, DWORD PTR _e$17[ebp]
	push	OFFSET ??_C@_0DE@LDDJFDOP@Malformed?5COC?5marker?5segment?4?5In@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6798 :           { KDU_ERROR(e,103); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6801 :           }

	lea	ecx, DWORD PTR _e$17[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _val$1$[ebp]
$LN16@read_marke:

; 6802 :         set(Cuse_precincts,0,0,use_precincts = (style&1)?true:false);

	and	cl, 1
	mov	BYTE PTR _use_precincts$[ebp], cl
	mov	ecx, edi
	push	DWORD PTR _use_precincts$[ebp]
	push	0
	push	0
	push	OFFSET ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
	jmp	$LN146@read_marke
__catch$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$2:

; 6805 :         { KDU_ERROR(e,104); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$16[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	OFFSET ??_C@_0EH@CMJBHJJH@Malformed?5COC?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6805 :         { KDU_ERROR(e,104); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6808 :         }

	lea	ecx, DWORD PTR _e$16[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN49@read_marke
	ret	0
$LN98@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6835 :             set(Cdfs,0,0,(levels & 0x7F));

	mov	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6830 :     levels = kdu_read(bp,end,1);

	mov	DWORD PTR _levels$22[ebp], eax

; 6831 :     if (levels & 0x80)

	test	al, al
	jns	SHORT $LN20@read_marke

; 6835 :             set(Cdfs,0,0,(levels & 0x7F));

	and	eax, 127				; 0000007fH
	cmp	DWORD PTR [edi+8], 0
	push	eax
	push	0
	push	0
	jge	SHORT $LN22@read_marke
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 6836 :             set(Cads,0,0,0);

	push	0
	push	0
	push	0
	mov	ecx, edi
$LN22@read_marke:

; 6837 :           }
; 6838 :         else
; 6839 :           set(Cads,0,0,(levels & 0x7F));

	push	OFFSET ??_C@_04OONIPDNE@Cads?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 6840 :         if (!get(Clevels,0,0,levels))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _levels$22[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 6841 :           assert(0); // Must be able to inherit value from somewhere
; 6842 :       }
; 6843 :     else

	jmp	SHORT $LN21@read_marke
$LN20@read_marke:

; 6844 :       {
; 6845 :         set(Cads,0,0,0);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04OONIPDNE@Cads?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 6846 :         if (tile_idx < 0)

	cmp	DWORD PTR [edi+8], 0
	jge	SHORT $LN25@read_marke

; 6847 :           set(Cdfs,0,0,0);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	mov	ecx, edi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN25@read_marke:

; 6848 :         set(Clevels,0,0,levels);

	push	DWORD PTR _levels$22[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN21@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN104@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T7[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN157@read_marke:
$LN104@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6851 :     set(Cblk,0,1,1<<(2+kdu_read(bp,end,1)));

	mov	eax, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6851 :     set(Cblk,0,1,1<<(2+kdu_read(bp,end,1)));

	lea	ecx, DWORD PTR [ecx+2]
	shl	eax, cl
	mov	ecx, edi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN110@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T6[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN158@read_marke:
$LN110@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6852 :     set(Cblk,0,0,1<<(2+kdu_read(bp,end,1)));

	mov	eax, 1
	add	ecx, 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6852 :     set(Cblk,0,0,1<<(2+kdu_read(bp,end,1)));

	shl	eax, cl
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN116@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T5[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN159@read_marke:
$LN116@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6853 :     set(Cmodes,0,0,kdu_read(bp,end,1));

	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06EGDCPANH@Cmodes?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6853 :     set(Cmodes,0,0,kdu_read(bp,end,1));

	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN122@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T4[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN160@read_marke:
$LN122@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6857 :         set(Catk,0,0,xforms);

	mov	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
	mov	DWORD PTR _val$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6855 :     if (xforms >= 2)

	cmp	eax, 2
	jl	SHORT $LN26@read_marke

; 6857 :         set(Catk,0,0,xforms);

	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 6858 :         set(Ckernels,0,0,Ckernels_ATK);

	push	-1

; 6859 :       }
; 6860 :     else

	jmp	SHORT $LN148@read_marke
$LN26@read_marke:

; 6861 :       {
; 6862 :         set(Catk,0,0,0);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 6863 :         set(Creversible,0,0,reversible=(xforms==1));

	cmp	DWORD PTR _val$1$[ebp], 1
	mov	ecx, edi
	sete	BYTE PTR _reversible$20[ebp]
	push	DWORD PTR _reversible$20[ebp]
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 6864 :         set(Ckernels,0,0,(reversible)?Ckernels_W5X3:Ckernels_W9X7);

	xor	eax, eax
	cmp	BYTE PTR _reversible$20[ebp], al
	setne	al
	push	eax
$LN148@read_marke:
	push	0
	push	0
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	mov	ecx, edi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 6865 :       }
; 6866 :     if (use_precincts)

	cmp	BYTE PTR _use_precincts$[ebp], 0
	je	$LN3@read_marke

; 6867 :       for (n=0; n <= levels; n++)

	xor	edx, edx
$LN149@read_marke:
	mov	eax, DWORD PTR _levels$22[ebp]
	mov	DWORD PTR _n$1$[ebp], edx
	mov	DWORD PTR _levels$1$[ebp], eax
	cmp	edx, eax
	jg	SHORT $LN3@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN128@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T3[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN161@read_marke:
$LN128@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6872 :           ppy = ppx >> 4;

	mov	ecx, eax

; 6873 :           ppx &= 0x0F;

	and	eax, 15					; 0000000fH
	mov	DWORD PTR _ppx$1$[ebp], eax

; 6874 :           set(Cprecincts,levels-n,0,1<<ppy);

	mov	eax, 1
	sar	ecx, 4
	shl	eax, cl
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR _levels$1$[ebp]
	push	0
	sub	eax, edx
	push	eax
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 6875 :           set(Cprecincts,levels-n,1,1<<ppx);

	mov	ecx, DWORD PTR _ppx$1$[ebp]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR _levels$22[ebp]
	sub	eax, DWORD PTR _n$1$[ebp]
	push	1
	push	eax
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	edx, DWORD PTR _n$1$[ebp]
	inc	edx
	jmp	$LN149@read_marke
$LN3@read_marke:

; 6876 :         }
; 6877 :     if (bp != end)

	cmp	esi, ebx
	je	SHORT $LN51@read_marke

; 6878 :       { KDU_ERROR(e,106); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$14[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	OFFSET ??_C@_0DJ@BKGFKCIK@Malformed?5COD?1COC?5marker?5segment@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6878 :       { KDU_ERROR(e,106); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 10		; 0000000aH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6880 :           << (int)(end-bp) <<

	sub	ebx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	BYTE PTR _e$14[ebp+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	ebx
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$23[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$23[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	eax
	mov	eax, DWORD PTR _e$14[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	OFFSET ??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6882 :       }

	lea	ecx, DWORD PTR _e$14[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN51@read_marke:

; 6889 : 
; 6890 :   return true;

	mov	al, 1
$LN1@read_marke:

; 6891 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
__catch$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$4:

; 6885 :     { KDU_ERROR(e,107);  e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EL@MEODJCKN@Malformed?5COD?1COC?5marker?5segment@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6885 :     { KDU_ERROR(e,107);  e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 12		; 0000000cH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6888 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN51@read_marke
	ret	0
$LN145@read_marke:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$6:
	lea	ecx, DWORD PTR _e$19[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$7:
	lea	ecx, DWORD PTR _e$18[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$10:
	lea	ecx, DWORD PTR _w$15[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$8:
	lea	ecx, DWORD PTR _e$17[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$9:
	lea	ecx, DWORD PTR _e$16[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$11:
	lea	ecx, DWORD PTR _e$14[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z$12:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_marker_segment@cod_params@@MAE_NGHQAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_marker_segment@cod_params@@MAE_NGHQAEH@Z ENDP	; cod_params::read_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?check_marker_segment@cod_params@@MAE_NGHQAEAAH@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_c_idx$ = 20						; size = 4
?check_marker_segment@cod_params@@MAE_NGHQAEAAH@Z PROC	; cod_params::check_marker_segment, COMDAT
; _this$ = ecx

; 6724 : {

	push	ebp
	mov	ebp, esp

; 6725 :   if (code == KDU_COD)

	mov	ax, WORD PTR _code$[ebp]
	push	esi
	mov	esi, ecx
	mov	ecx, 65362				; 0000ff52H
	cmp	ax, cx
	jne	SHORT $LN2@check_mark

; 6726 :     {
; 6727 :       c_idx = -1;

	mov	eax, DWORD PTR _c_idx$[ebp]
	pop	esi
	mov	DWORD PTR [eax], -1

; 6728 :       return true;

	mov	al, 1

; 6738 : }

	pop	ebp
	ret	16					; 00000010H
$LN2@check_mark:

; 6729 :     }
; 6730 :   if ((code == KDU_COC) && (num_bytes >= 2))

	mov	ecx, 65363				; 0000ff53H
	cmp	ax, cx
	jne	SHORT $LN3@check_mark
	cmp	DWORD PTR _num_bytes$[ebp], 2
	jl	SHORT $LN3@check_mark

; 6731 :     {
; 6732 :       c_idx = *(bytes++);

	mov	eax, DWORD PTR _bytes$[ebp]
	mov	edx, DWORD PTR _c_idx$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR [edx], ecx

; 6733 :       if (num_comps > 256)

	cmp	DWORD PTR [esi+24], 256			; 00000100H
	jle	SHORT $LN4@check_mark

; 6734 :         c_idx = (c_idx<<8) + *(bytes++);

	movzx	eax, BYTE PTR [eax+1]
	shl	ecx, 8
	add	eax, ecx
	mov	DWORD PTR [edx], eax
$LN4@check_mark:

; 6735 :       return true;

	mov	al, 1
	pop	esi

; 6738 : }

	pop	ebp
	ret	16					; 00000010H
$LN3@check_mark:

; 6736 :     }
; 6737 :   return false;

	xor	al, al
	pop	esi

; 6738 : }

	pop	ebp
	ret	16					; 00000010H
?check_marker_segment@cod_params@@MAE_NGHQAEAAH@Z ENDP	; cod_params::check_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
_TEXT	SEGMENT
_e$2 = -276						; size = 20
_value$1$ = -256					; size = 4
_ppx$ = -252						; size = 4
_ppy$ = -248						; size = 4
_align_last_y$ = -244					; size = 1
_reversible$ = -240					; size = 1
_modes$ = -236						; size = 4
_blk_y$ = -232						; size = 4
_blk_x$ = -228						; size = 4
_order$ = -224						; size = 4
_use_sop$ = -220					; size = 1
_use_eph$ = -216					; size = 1
_align_last_x$ = -212					; size = 1
_atk_idx$ = -208					; size = 4
_mct_flags$ = -204					; size = 4
_kernels$ = -200					; size = 4
_ads_idx$ = -196					; size = 4
_dfs_idx$ = -192					; size = 4
_layers$ = -188						; size = 4
_profile$ = -184					; size = 4
_ppy$1$ = -180						; size = 4
_component_bytes$1$ = -180				; size = 4
_ads_idx$1$ = -180					; size = 4
_ycb$ = -180						; size = 4
_use_precincts$ = -176					; size = 1
_e$3 = -172						; size = 20
_e$4 = -172						; size = 20
_e$5 = -172						; size = 20
_e$6 = -172						; size = 20
_e$7 = -172						; size = 20
_e$8 = -172						; size = 20
_e$9 = -172						; size = 20
_e$10 = -172						; size = 20
_e$11 = -172						; size = 20
_style$1$ = -152					; size = 4
_style$1$ = -152					; size = 4
_val$12 = -152						; size = 4
_val$13 = -152						; size = 4
_value$1$ = -148					; size = 4
_value$1$ = -148					; size = 4
_val$14 = -148						; size = 4
_prec_test$15 = -148					; size = 4
_value$1$ = -144					; size = 4
_length$2$ = -144					; size = 4
_length$1$ = -144					; size = 4
_val$16 = -144						; size = 4
_val$17 = -144						; size = 4
_xcb$1$ = -140						; size = 4
_siz$1$ = -140						; size = 4
_ppx$18 = -140						; size = 4
_use_ycc$ = -133					; size = 1
_levels$ = -132						; size = 4
_val$19 = -126						; size = 1
_rev_test$20 = -126					; size = 1
_value$1$ = -125					; size = 1
_value$1$ = -125					; size = 1
_last_marked$GSCopy$1$ = -124				; size = 4
_ycb$1$ = -124						; size = 4
tv1868 = -124						; size = 4
_ppy$21 = -124						; size = 4
_byte$1$ = -117						; size = 1
_byte$1$ = -117						; size = 1
_byte$1$ = -117						; size = 1
_byte$1$ = -117						; size = 1
_byte$1$ = -117						; size = 1
_val$22 = -117						; size = 1
_w$23 = -116						; size = 20
_e$24 = -116						; size = 20
_e$25 = -116						; size = 20
_e$26 = -116						; size = 20
_e$27 = -116						; size = 20
_e$28 = -116						; size = 20
_e$29 = -116						; size = 20
_coc$30 = -108						; size = 12
_text$31 = -96						; size = 80
_text$32 = -96						; size = 80
_text$33 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_out$ = 8						; size = 4
_last_marked$ = 12					; size = 4
_tpart_idx$ = 16					; size = 4
?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z PROC ; cod_params::write_marker_segment, COMDAT
; _this$ = ecx

; 6440 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 6441 :   cod_params *ref = (cod_params *) last_marked;
; 6442 :   int length, n;
; 6443 :   bool use_ycc, use_sop, use_eph, align_last_x, align_last_y;
; 6444 :   int mct_flags, layers, order;
; 6445 :   bool reversible, use_precincts;
; 6446 :   int levels, ads_idx, dfs_idx;
; 6447 :   int kernels, atk_idx, blk_y, blk_x, modes;
; 6448 :   int ppx, ppy;
; 6449 : 
; 6450 :   if (tpart_idx != 0)

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	mov	esi, DWORD PTR _last_marked$[ebp]
	mov	edi, DWORD PTR _out$[ebp]
	mov	DWORD PTR _last_marked$GSCopy$1$[ebp], esi
	je	SHORT $LN11@write_mark
$LN241@write_mark:

; 6451 :     return 0;

	xor	eax, eax
	jmp	$LN1@write_mark
$LN11@write_mark:

; 6452 : 
; 6453 :   // Collect most of the parameters.
; 6454 :   if (!(get(Cycc,0,0,use_ycc) && get(Cmct,0,0,mct_flags) &&

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _use_ycc$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04DEPIIIHA@Cycc?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _mct_flags$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04OOAAMMCO@Cmct?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _layers$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BJCMAMHC@Clayers?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _use_sop$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08DAJNLNLL@Cuse_sop?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _use_eph$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08NAIOMJOM@Cuse_eph?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _order$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06IKJBDDKO@Corder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _align_last_y$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _align_last_x$[ebp]
	mov	ecx, ebx
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _levels$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _dfs_idx$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _ads_idx$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04OONIPDNE@Cads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _reversible$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _kernels$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _atk_idx$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _blk_y$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _blk_x$[ebp]
	mov	ecx, ebx
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _modes$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06EGDCPANH@Cmodes?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN13@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _use_precincts$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN12@write_mark
$LN13@write_mark:

; 6464 :     { KDU_ERROR_DEV(e,91); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$29[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$29[ebp]
	lea	ecx, DWORD PTR _e$29[ebp]
	push	OFFSET ??_C@_0HD@OCHJAHPC@Unable?5to?5write?5COD?5marker?5segme@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6464 :     { KDU_ERROR_DEV(e,91); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6467 :     }

	lea	ecx, DWORD PTR _e$29[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN12@write_mark:

; 6468 : 
; 6469 :   if (ref != NULL)

	test	esi, esi
	je	$LN227@write_mark

; 6487 :           ref->compare(Cmodes,0,0,modes) &&

	mov	al, BYTE PTR _use_ycc$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1237 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, esi
	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6487 :           ref->compare(Cmodes,0,0,modes) &&

	mov	BYTE PTR _value$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1237 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$19[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04DEPIIIHA@Cycc?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN227@write_mark
	mov	al, BYTE PTR _value$1$[ebp]
	cmp	BYTE PTR _val$19[ebp], al
	jne	$LN227@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6487 :           ref->compare(Cmodes,0,0,modes) &&

	mov	eax, DWORD PTR _mct_flags$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, esi
	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6487 :           ref->compare(Cmodes,0,0,modes) &&

	mov	DWORD PTR _value$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$14[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04OOAAMMCO@Cmct?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN227@write_mark
	mov	eax, DWORD PTR _value$1$[ebp]
	cmp	DWORD PTR _val$14[ebp], eax
	jne	$LN227@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6487 :           ref->compare(Cmodes,0,0,modes) &&

	mov	eax, DWORD PTR _layers$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, esi
	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6487 :           ref->compare(Cmodes,0,0,modes) &&

	mov	DWORD PTR _value$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$17[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BJCMAMHC@Clayers?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN227@write_mark
	mov	eax, DWORD PTR _value$1$[ebp]
	cmp	DWORD PTR _val$17[ebp], eax
	jne	$LN227@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6487 :           ref->compare(Cmodes,0,0,modes) &&

	push	DWORD PTR _use_sop$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_08DAJNLNLL@Cuse_sop?$AA@
	call	?compare@kdu_params@@QAE_NPBDHH_N@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	push	DWORD PTR _use_eph$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_08NAIOMJOM@Cuse_eph?$AA@
	call	?compare@kdu_params@@QAE_NPBDHH_N@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	push	DWORD PTR _order$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_06IKJBDDKO@Corder?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	push	DWORD PTR _align_last_y$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?compare@kdu_params@@QAE_NPBDHH_N@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	push	DWORD PTR _align_last_x$[ebp]
	mov	ecx, esi
	push	1
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?compare@kdu_params@@QAE_NPBDHH_N@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	push	DWORD PTR _levels$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	push	DWORD PTR _ads_idx$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_04OONIPDNE@Cads?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	push	DWORD PTR _dfs_idx$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	cmp	DWORD PTR _ads_idx$[ebp], 0
	je	SHORT $LN16@write_mark
	cmp	DWORD PTR [esi+8], 0
	jl	$LN227@write_mark
$LN16@write_mark:
	cmp	DWORD PTR _dfs_idx$[ebp], 0
	je	SHORT $LN17@write_mark
	cmp	DWORD PTR [ebx+8], 0
	jl	$LN227@write_mark
$LN17@write_mark:
	push	DWORD PTR _reversible$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?compare@kdu_params@@QAE_NPBDHH_N@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	push	DWORD PTR _kernels$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	push	DWORD PTR _atk_idx$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	push	DWORD PTR _blk_y$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	push	DWORD PTR _blk_x$[ebp]
	mov	ecx, esi
	push	1
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	push	DWORD PTR _modes$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_06EGDCPANH@Cmodes?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark
	push	DWORD PTR _use_precincts$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
	call	?compare@kdu_params@@QAE_NPBDHH_N@Z	; kdu_params::compare
	test	al, al
	je	$LN227@write_mark

; 6488 :           ref->compare(Cuse_precincts,0,0,use_precincts))
; 6489 :         { // So far, so good. Just need to check on precincts now.
; 6490 :           if (!use_precincts)

	cmp	BYTE PTR _use_precincts$[ebp], 0
	je	$LN241@write_mark

; 6491 :             return 0; // Object identical to reference.
; 6492 :           for (n=0; n <= levels; n++)

	xor	esi, esi
	cmp	DWORD PTR _levels$[ebp], esi
	jl	$LN241@write_mark
$LL4@write_mark:

; 6493 :             if (!(get(Cprecincts,n,0,ppy) && get(Cprecincts,n,1,ppx) &&

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _ppy$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN209@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _ppx$[ebp]
	mov	ecx, ebx
	push	eax
	push	1
	push	esi
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN209@write_mark
	push	DWORD PTR _ppy$[ebp]
	mov	ecx, DWORD PTR _last_marked$GSCopy$1$[ebp]
	push	0
	push	esi
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	SHORT $LN209@write_mark
	push	DWORD PTR _ppx$[ebp]
	mov	ecx, DWORD PTR _last_marked$GSCopy$1$[ebp]
	push	1
	push	esi
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	SHORT $LN209@write_mark

; 6491 :             return 0; // Object identical to reference.
; 6492 :           for (n=0; n <= levels; n++)

	inc	esi
	cmp	esi, DWORD PTR _levels$[ebp]
	jle	SHORT $LL4@write_mark

; 6451 :     return 0;

	xor	eax, eax
	jmp	$LN1@write_mark
$LN209@write_mark:

; 6494 :                   ref->compare(Cprecincts,n,0,ppy) &&
; 6495 :                   ref->compare(Cprecincts,n,1,ppx)))
; 6496 :               break;
; 6497 :           if (n > levels)

	cmp	esi, DWORD PTR _levels$[ebp]
	jg	$LN241@write_mark
	mov	esi, DWORD PTR _last_marked$GSCopy$1$[ebp]
$LN227@write_mark:

; 6502 :   if ((ads_idx != 0) && (tile_idx >= 0) &&

	cmp	DWORD PTR _ads_idx$[ebp], 0
	je	SHORT $LN22@write_mark
	cmp	DWORD PTR [ebx+8], 0
	jl	SHORT $LN22@write_mark
	test	esi, esi
	je	SHORT $LN107@write_mark
	mov	eax, DWORD PTR _levels$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, esi
	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6502 :   if ((ads_idx != 0) && (tile_idx >= 0) &&

	mov	DWORD PTR _value$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$16[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN107@write_mark
	mov	eax, DWORD PTR _value$1$[ebp]
	cmp	DWORD PTR _val$16[ebp], eax
	je	SHORT $LN22@write_mark
$LN107@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6504 :     { KDU_ERROR(e,0x25040501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$28[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$28[ebp]
	lea	ecx, DWORD PTR _e$28[ebp]
	push	OFFSET ??_C@_0BLH@FGHKBOHC@Illegal?5combination?5of?5?$GAClevels?8@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6504 :     { KDU_ERROR(e,0x25040501); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6514 :     }

	lea	ecx, DWORD PTR _e$28[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN22@write_mark:

; 6515 :   if ((dfs_idx != 0) && (tile_idx < 0) && (comp_idx >= 0) &&

	cmp	DWORD PTR _dfs_idx$[ebp], 0
	je	SHORT $LN24@write_mark
	cmp	DWORD PTR [ebx+8], 0
	jge	SHORT $LN24@write_mark
	cmp	DWORD PTR [ebx+12], 0
	jl	SHORT $LN24@write_mark
	test	esi, esi
	je	SHORT $LN25@write_mark
	push	DWORD PTR _levels$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	jne	SHORT $LN24@write_mark
$LN25@write_mark:

; 6517 :     { KDU_ERROR(e,0x24050500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$27[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$27[ebp]
	lea	ecx, DWORD PTR _e$27[ebp]
	push	OFFSET ??_C@_0BEM@DMPFDMNO@Illegal?5combination?5of?5?$GAClevels?8@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6517 :     { KDU_ERROR(e,0x24050500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6525 :     }

	lea	ecx, DWORD PTR _e$27[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN24@write_mark:

; 6526 : 
; 6527 :   // We are now committed to writing (or simulating) a marker segment.
; 6528 : 
; 6529 :   kdu_params *siz = access_cluster(SIZ_params); // We will need this.

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	mov	ecx, ebx
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 6530 :   assert(siz != NULL);
; 6531 :   if ((layers < 0) || (layers >= (1<<16)))

	mov	ecx, DWORD PTR _layers$[ebp]
	mov	esi, eax
	mov	DWORD PTR _siz$1$[ebp], esi
	test	ecx, ecx
	js	SHORT $LN27@write_mark
	cmp	ecx, 65536				; 00010000H
	jl	SHORT $LN26@write_mark
$LN27@write_mark:

; 6532 :     { KDU_ERROR_DEV(e,92); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$26[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$26[ebp]
	lea	ecx, DWORD PTR _e$26[ebp]
	push	OFFSET ??_C@_0CD@EICILEGK@Illegal?5number?5of?5quality?5layers@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6532 :     { KDU_ERROR_DEV(e,92); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$26[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _layers$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$33[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$33[ebp]
	lea	ecx, DWORD PTR _e$26[ebp]
	push	eax
	mov	eax, DWORD PTR _e$26[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$26[ebp]
	lea	ecx, DWORD PTR _e$26[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6534 :     }

	lea	ecx, DWORD PTR _e$26[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN26@write_mark:

; 6535 :   if ((levels < 0) || (levels > 32))

	mov	eax, DWORD PTR _levels$[ebp]
	test	eax, eax
	js	SHORT $LN29@write_mark
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN28@write_mark
$LN29@write_mark:

; 6536 :     { KDU_ERROR_DEV(e,93); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$25[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$25[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	OFFSET ??_C@_0BP@JIANFEOP@Illegal?5number?5of?5DWT?5levels?0?5?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6536 :     { KDU_ERROR_DEV(e,93); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$25[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _levels$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$32[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$32[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	eax
	mov	eax, DWORD PTR _e$25[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$25[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	OFFSET ??_C@_0BK@GFANLIDL@?4?5Legal?5range?5is?50?5to?532?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6539 :     }

	lea	ecx, DWORD PTR _e$25[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN28@write_mark:

; 6540 : 
; 6541 :   int component_bytes = (get_num_comps() <= 256)?1:2;

	xor	eax, eax
	cmp	DWORD PTR [ebx+24], 256			; 00000100H
	setg	al
	inc	eax

; 6542 : 
; 6543 :   if (comp_idx < 0)

	cmp	DWORD PTR [ebx+12], 0
	mov	DWORD PTR _component_bytes$1$[ebp], eax
	jge	$LN30@write_mark

; 6544 :     { // Generating a COD marker.
; 6545 :       length = 4 + 1 + (1+2+1);
; 6546 :       if (use_ycc)

	cmp	BYTE PTR _use_ycc$[ebp], 0
	mov	DWORD PTR _length$1$[ebp], 9
	je	$LN31@write_mark

; 6547 :         { // Check compatibility
; 6548 :           if (mct_flags != 0)

	cmp	DWORD PTR _mct_flags$[ebp], 0
	je	SHORT $LN33@write_mark

; 6549 :             { KDU_ERROR(e,0x04060700); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$24[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$24[ebp]
	lea	ecx, DWORD PTR _e$24[ebp]
	push	OFFSET ??_C@_0HM@DEKELPAG@You?5cannot?5use?5a?5Part?91?5colour?5t@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6549 :             { KDU_ERROR(e,0x04060700); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6553 :             }

	lea	ecx, DWORD PTR _e$24[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN33@write_mark:

; 6554 :           kdu_params *coc[3];
; 6555 :           coc[0] = access_relation(tile_idx,0,0,true);

	push	1
	push	0
	push	0
	push	DWORD PTR [ebx+8]
	mov	ecx, ebx
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 6556 :           coc[1] = access_relation(tile_idx,1,0,true);

	push	1
	push	0
	push	1
	push	DWORD PTR [ebx+8]
	mov	esi, eax
	mov	ecx, ebx
	mov	DWORD PTR _coc$30[ebp], esi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 6557 :           coc[2] = access_relation(tile_idx,2,0,true);

	push	1
	push	0
	push	2
	push	DWORD PTR [ebx+8]
	mov	ecx, ebx
	mov	DWORD PTR _coc$30[ebp+4], eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 6558 :           bool rev_test; coc[0]->get(Creversible,0,0,rev_test);

	push	1
	push	1
	push	1
	mov	DWORD PTR _coc$30[ebp+8], eax
	mov	ecx, esi
	lea	eax, DWORD PTR _rev_test$20[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get

; 6559 :           int prec_test;
; 6560 :           siz->get(Sprecision,0,0,prec_test);

	mov	ecx, DWORD PTR _siz$1$[ebp]
	lea	eax, DWORD PTR _prec_test$15[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@BADPNFGK@Sprecision?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 6561 :           for (n=1; (n < 3) && (coc[n] != NULL); n++)

	mov	esi, 1
	npad	5
$LL7@write_mark:
	mov	ecx, DWORD PTR _coc$30[ebp+esi*4]
	test	ecx, ecx
	je	$LN233@write_mark

; 6563 :               if (!(coc[n]->compare(Creversible,0,0,rev_test) &&

	mov	al, BYTE PTR _rev_test$20[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1237 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6563 :               if (!(coc[n]->compare(Creversible,0,0,rev_test) &&

	mov	BYTE PTR _value$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1237 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$22[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN135@write_mark
	mov	al, BYTE PTR _value$1$[ebp]
	cmp	BYTE PTR _val$22[ebp], al
	jne	SHORT $LN135@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6563 :               if (!(coc[n]->compare(Creversible,0,0,rev_test) &&

	mov	eax, DWORD PTR _prec_test$15[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, DWORD PTR _siz$1$[ebp]
	push	1
	push	1
	push	1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6563 :               if (!(coc[n]->compare(Creversible,0,0,rev_test) &&

	mov	DWORD PTR _value$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	eax, DWORD PTR _val$13[ebp]
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_0L@BADPNFGK@Sprecision?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN135@write_mark
	mov	eax, DWORD PTR _value$1$[ebp]
	cmp	DWORD PTR _val$13[ebp], eax
	je	SHORT $LN5@write_mark
$LN135@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6565 :                 { KDU_ERROR(e,94); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$11[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_0JD@JKCKBNOF@You?5cannot?5use?5a?5colour?5transfor@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6565 :                 { KDU_ERROR(e,94); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6570 :                 }

	lea	ecx, DWORD PTR _e$11[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN5@write_mark:

; 6561 :           for (n=1; (n < 3) && (coc[n] != NULL); n++)

	inc	esi
	cmp	esi, 3
	jl	$LL7@write_mark
$LN233@write_mark:

; 6571 :             }
; 6572 :         }
; 6573 :     }
; 6574 :   else

	mov	esi, DWORD PTR _siz$1$[ebp]
	jmp	SHORT $LN31@write_mark
$LN30@write_mark:

; 6575 :     { // Generating a COC marker.
; 6576 :       length = 4 + component_bytes + 1;

	add	eax, 5
	mov	DWORD PTR _length$1$[ebp], eax
$LN31@write_mark:

; 6577 :     }
; 6578 :   length += 5 + use_precincts*(levels+1);

	mov	ecx, DWORD PTR _levels$[ebp]
	movzx	eax, BYTE PTR _use_precincts$[ebp]
	inc	ecx
	imul	ecx, eax
	mov	eax, DWORD PTR _length$1$[ebp]
	add	eax, 5
	add	eax, ecx
	mov	DWORD PTR _length$2$[ebp], eax

; 6579 :   if (out == NULL)

	test	edi, edi
	je	$LN1@write_mark

; 6580 :     return length;
; 6581 : 
; 6582 :   // Now we are committed to actually writing the marker segment.
; 6583 :   int profile = 2; siz->get(Sprofile,0,0,profile);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _profile$[ebp]
	mov	DWORD PTR _profile$[ebp], 2
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 6584 :   if (tile_idx >= 0)

	cmp	DWORD PTR [ebx+8], 0

; 6585 :     { // Check for profile compatibility.
; 6586 :       if (profile == 0)

	mov	eax, DWORD PTR _profile$[ebp]
	jl	$LN40@write_mark
	test	eax, eax
	jne	SHORT $LN38@write_mark

; 6587 :         { KDU_WARNING(w,0); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$23[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$23[ebp]
	lea	ecx, DWORD PTR _w$23[ebp]
	push	OFFSET ??_C@_0NK@HPJJFAAC@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6587 :         { KDU_WARNING(w,0); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _w$23[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR [ebx+8]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$31[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$31[ebp]
	lea	ecx, DWORD PTR _w$23[ebp]
	push	eax
	mov	eax, DWORD PTR _w$23[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$23[ebp]
	lea	ecx, DWORD PTR _w$23[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6593 :         }

	lea	ecx, DWORD PTR _w$23[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
	jmp	SHORT $LN242@write_mark
$LN38@write_mark:

; 6594 :       else if ((profile == Sprofile_CINEMA2K) ||

	cmp	eax, 4
	je	SHORT $LN41@write_mark
	cmp	eax, 5
	jne	SHORT $LN40@write_mark
$LN41@write_mark:

; 6596 :         { KDU_ERROR(e,0x11110807); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$10[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0LA@PCHBPKGD@Profile?5violation?5detected?4?5?5COD@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6596 :         { KDU_ERROR(e,0x11110807); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6601 :         }

	lea	ecx, DWORD PTR _e$10[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN242@write_mark:
	mov	eax, DWORD PTR _profile$[ebp]
$LN40@write_mark:

; 6602 :     }
; 6603 :   if ((comp_idx >= 0) &&
; 6604 :       ((profile == Sprofile_CINEMA2K) || (profile == Sprofile_CINEMA4K)) &&
; 6605 :       (ref != NULL) && !ref->compare(Clevels,0,0,levels))

	cmp	DWORD PTR [ebx+12], 0
	jl	SHORT $LN42@write_mark
	cmp	eax, 4
	je	SHORT $LN43@write_mark
	cmp	eax, 5
	jne	SHORT $LN42@write_mark
$LN43@write_mark:
	mov	eax, DWORD PTR _last_marked$GSCopy$1$[ebp]
	test	eax, eax
	je	SHORT $LN42@write_mark
	mov	esi, DWORD PTR _levels$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	lea	ecx, DWORD PTR _val$12[ebp]
	push	1
	push	1
	push	1
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN149@write_mark
	cmp	DWORD PTR _val$12[ebp], esi
	je	SHORT $LN42@write_mark
$LN149@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6606 :     { KDU_ERROR(e,0x11110808); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$9[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0BAB@INJJPFGA@About?5to?5write?5a?5component?9speci@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6606 :     { KDU_ERROR(e,0x11110808); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 9
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6612 :     }

	lea	ecx, DWORD PTR _e$9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN42@write_mark:

; 6613 : 
; 6614 :   if (atk_idx == 0)

	mov	eax, DWORD PTR _atk_idx$[ebp]
	test	eax, eax
	jne	SHORT $LN44@write_mark

; 6615 :     {
; 6616 :       if ((reversible && (kernels != Ckernels_W5X3)) ||

	cmp	BYTE PTR _reversible$[ebp], al
	je	SHORT $LN219@write_mark
	cmp	DWORD PTR _kernels$[ebp], 1
	jne	SHORT $LN47@write_mark
	jmp	SHORT $LN49@write_mark
$LN219@write_mark:
	cmp	DWORD PTR _kernels$[ebp], 0
	je	SHORT $LN49@write_mark
$LN47@write_mark:

; 6617 :           ((!reversible) && (kernels != Ckernels_W9X7)))
; 6618 :         { KDU_ERROR(e,0x19050501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0BBG@KCPOGFOJ@Illegal?5?$GACkernels?8?5value?5found?5w@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6626 :     }

	jmp	SHORT $LN238@write_mark
$LN44@write_mark:

; 6627 :   else if ((atk_idx < 2) || (atk_idx > 255))

	cmp	eax, 2
	jl	SHORT $LN50@write_mark
	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN49@write_mark
$LN50@write_mark:

; 6628 :     { KDU_ERROR(e,0x19050500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$7[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0HN@HPMPNOPC@Illegal?5ATK?5instance?5index?5found@
$LN238@write_mark:
	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6632 :     }

	lea	ecx, DWORD PTR _e$7[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN49@write_mark:

; 6633 : 
; 6634 :   int acc_length = 0; // Accumulate actual length for verification purposes.
; 6635 : 
; 6636 :   if (comp_idx < 0)

	cmp	DWORD PTR [ebx+12], 0
	jge	$LN51@write_mark

; 6637 :     {
; 6638 :       int style = (((int) use_precincts) << 0) + (((int) use_sop) << 1) +
; 6639 :                   (((int) use_eph) << 2) + (((int) align_last_x) << 3) +

	movzx	eax, BYTE PTR _align_last_x$[ebp]
	movzx	ecx, BYTE PTR _align_last_y$[ebp]

; 6640 :                   (((int) align_last_y) << 4);
; 6641 :       acc_length += out->put(KDU_COD);

	push	65362					; 0000ff52H
	lea	ecx, DWORD PTR [eax+ecx*2]
	movzx	eax, BYTE PTR _use_eph$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*2]
	movzx	eax, BYTE PTR _use_sop$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*2]
	movzx	eax, BYTE PTR _use_precincts$[ebp]
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	ecx, edi
	mov	DWORD PTR _style$1$[ebp], eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 6642 :       acc_length += out->put((kdu_uint16)(length-2));

	mov	eax, DWORD PTR _length$2$[ebp]
	mov	ecx, edi
	add	eax, -2					; fffffffeH
	push	eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN158@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN158@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	ecx, DWORD PTR _style$1$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [edi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6644 :       acc_length += out->put((kdu_byte) order);

	mov	cl, BYTE PTR _order$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	eax
	mov	DWORD PTR [edi+516], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6644 :       acc_length += out->put((kdu_byte) order);

	mov	BYTE PTR _byte$1$[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN161@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
	mov	cl, BYTE PTR _byte$1$[ebp]
$LN161@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	BYTE PTR [eax], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6645 :       acc_length += out->put((kdu_uint16) layers);

	mov	ecx, edi
	push	DWORD PTR _layers$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [edi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6645 :       acc_length += out->put((kdu_uint16) layers);

	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 6646 :       acc_length += out->put((kdu_byte)(mct_flags | ((use_ycc)?1:0)));

	cmp	BYTE PTR _use_ycc$[ebp], 0
	setne	al
	or	al, BYTE PTR _mct_flags$[ebp]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN164@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN164@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	cl, BYTE PTR _byte$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6648 :   else

	jmp	$LN239@write_mark
$LN51@write_mark:

; 6649 :     {
; 6650 :       int style = (((int) use_precincts) << 0);

	movzx	eax, BYTE PTR _use_precincts$[ebp]

; 6651 :       acc_length += out->put(KDU_COC);

	mov	ecx, edi
	push	65363					; 0000ff53H
	mov	DWORD PTR _style$1$[ebp], eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 6652 :       acc_length += out->put((kdu_uint16)(length-2));

	mov	eax, DWORD PTR _length$2$[ebp]
	mov	ecx, edi
	add	eax, -2					; fffffffeH
	push	eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 6653 :       if (component_bytes == 1)

	cmp	DWORD PTR _component_bytes$1$[ebp], 1
	jne	SHORT $LN53@write_mark

; 6654 :         acc_length += out->put((kdu_byte) comp_idx);

	mov	al, BYTE PTR [ebx+12]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN167@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN167@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [edi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6655 :       else

	jmp	SHORT $LN54@write_mark
$LN53@write_mark:

; 6656 :         acc_length += out->put((kdu_uint16) comp_idx);

	movzx	eax, WORD PTR [ebx+12]
	mov	ecx, edi
	push	eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put
$LN54@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN170@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN170@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR _style$1$[ebp]
$LN239@write_mark:
	mov	eax, DWORD PTR [edi+516]
	mov	BYTE PTR [eax], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6662 :   if (((xcb = int2log(blk_x)) < 0) || ((ycb = int2log(blk_y)) < 0))

	push	DWORD PTR _blk_x$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [edi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6662 :   if (((xcb = int2log(blk_x)) < 0) || ((ycb = int2log(blk_y)) < 0))

	call	?int2log@@YAHH@Z			; int2log
	add	esp, 4
	mov	DWORD PTR _xcb$1$[ebp], eax
	test	eax, eax
	js	SHORT $LN235@write_mark
	push	DWORD PTR _blk_y$[ebp]
	call	?int2log@@YAHH@Z			; int2log
	add	esp, 4
	mov	DWORD PTR _ycb$1$[ebp], eax
	test	eax, eax
	jns	SHORT $LN55@write_mark
	jmp	SHORT $LN56@write_mark
$LN235@write_mark:
	mov	ecx, DWORD PTR _ycb$[ebp]
	mov	DWORD PTR _ycb$1$[ebp], ecx
$LN56@write_mark:

; 6663 :     { KDU_ERROR_DEV(e,95); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$6[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	OFFSET ??_C@_0DD@IFOGDLHK@Maximum?5code?9block?5dimensions?5mu@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6663 :     { KDU_ERROR_DEV(e,95); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6665 :     }

	lea	ecx, DWORD PTR _e$6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _ycb$1$[ebp]
$LN55@write_mark:

; 6666 :   if ((xcb < 2) || (ycb < 2) || ((xcb+ycb) > 12))

	mov	ecx, DWORD PTR _xcb$1$[ebp]
	cmp	ecx, 2
	jl	SHORT $LN58@write_mark
	cmp	eax, 2
	jl	SHORT $LN58@write_mark
	add	eax, ecx
	cmp	eax, 12					; 0000000cH
	jle	SHORT $LN57@write_mark
$LN58@write_mark:

; 6667 :     { KDU_ERROR_DEV(e,96); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0HD@OIMMHFN@Maximum?5code?9block?5dimensions?5mu@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6667 :     { KDU_ERROR_DEV(e,96); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6670 :     }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN57@write_mark:

; 6671 : 
; 6672 :   if (tile_idx < 0)

	cmp	DWORD PTR [ebx+8], 0
	jge	SHORT $LN59@write_mark

; 6673 :     { // Record either `Clevels' or `Cdfs'
; 6674 :       if ((dfs_idx == 0) || (comp_idx < 0))

	mov	eax, DWORD PTR _dfs_idx$[ebp]
	test	eax, eax
	je	SHORT $LN63@write_mark
	cmp	DWORD PTR [ebx+12], 0
	jl	SHORT $LN63@write_mark

; 6675 :         acc_length += out->put((kdu_byte) levels);
; 6676 :       else
; 6677 :         acc_length += out->put((kdu_byte)(0x80 | dfs_idx));

	or	al, 128					; 00000080H
	mov	ecx, edi
	movzx	eax, al
	push	eax
	call	?put@kdu_output@@QAEHE@Z		; kdu_output::put
	jmp	SHORT $LN65@write_mark
$LN59@write_mark:

; 6678 :     }
; 6679 :   else
; 6680 :     { // Record either `Clevels' or `Cads'
; 6681 :       if (ads_idx == 0)

	mov	eax, DWORD PTR _ads_idx$[ebp]
	test	eax, eax
	jne	SHORT $LN64@write_mark
$LN63@write_mark:

; 6682 :         acc_length += out->put((kdu_byte) levels);

	mov	al, BYTE PTR _levels$[ebp]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN177@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN177@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	cl, BYTE PTR _byte$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6683 :       else

	jmp	SHORT $LN240@write_mark
$LN64@write_mark:

; 6684 :         acc_length += out->put((kdu_byte)(0x80 | ads_idx));

	or	al, 128					; 00000080H
	mov	DWORD PTR _ads_idx$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN183@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN183@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR _ads_idx$1$[ebp]
$LN240@write_mark:
	mov	eax, DWORD PTR [edi+516]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [edi+516]
$LN65@write_mark:

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN186@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN186@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6687 :   acc_length += out->put((kdu_byte)(xcb-2));

	mov	ecx, DWORD PTR _xcb$1$[ebp]
	sub	cl, 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [edi+516]
	inc	eax
	mov	DWORD PTR [edi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN189@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN189@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6688 :   acc_length += out->put((kdu_byte)(ycb-2));

	mov	ecx, DWORD PTR _ycb$1$[ebp]
	sub	cl, 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [edi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6689 :   acc_length += out->put((kdu_byte) modes);

	mov	cl, BYTE PTR _modes$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	eax
	mov	DWORD PTR [edi+516], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6689 :   acc_length += out->put((kdu_byte) modes);

	mov	BYTE PTR _byte$1$[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN192@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
	mov	cl, BYTE PTR _byte$1$[ebp]
$LN192@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	BYTE PTR [eax], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6690 :   acc_length += out->put((kdu_byte)((atk_idx==0)?kernels:atk_idx));

	mov	ecx, DWORD PTR _atk_idx$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	edx, DWORD PTR [edi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6690 :   acc_length += out->put((kdu_byte)((atk_idx==0)?kernels:atk_idx));

	movzx	eax, cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6690 :   acc_length += out->put((kdu_byte)((atk_idx==0)?kernels:atk_idx));

	mov	DWORD PTR tv1868[ebp], eax
	test	ecx, ecx
	mov	ecx, DWORD PTR tv1868[ebp]
	movzx	eax, BYTE PTR _kernels$[ebp]
	cmove	ecx, eax
	mov	DWORD PTR [edi+516], edx
	mov	DWORD PTR tv1868[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	edx, DWORD PTR [edi+520]
	jne	SHORT $LN195@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR tv1868[ebp]
$LN195@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [edi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6692 :   if (use_precincts)

	cmp	BYTE PTR _use_precincts$[ebp], 0
	je	$LN9@write_mark

; 6693 :     for (n=0; n <= levels; n++)

	mov	eax, DWORD PTR _levels$[ebp]
	xor	esi, esi
	test	eax, eax
	js	$LN9@write_mark
	npad	4
$LL10@write_mark:

; 6694 :       {
; 6695 :         int ppx, ppy;
; 6696 : 
; 6697 :         if (!(get(Cprecincts,levels-n,0,ppy) &&

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _ppy$21[ebp]
	sub	eax, esi
	push	ecx
	push	0
	push	eax
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN68@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _ppx$18[ebp]
	mov	ecx, ebx
	push	eax
	mov	eax, DWORD PTR _levels$[ebp]
	push	1
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN67@write_mark
$LN68@write_mark:

; 6699 :           { KDU_ERROR_DEV(e,98); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0CN@PBFFALNG@No?5precinct?5dimensions?5supplied?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6699 :           { KDU_ERROR_DEV(e,98); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6701 :           }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN67@write_mark:

; 6702 :         if (((ppx = int2log(ppx)) < 0) || ((ppy = int2log(ppy)) < 0))

	push	DWORD PTR _ppx$18[ebp]
	call	?int2log@@YAHH@Z			; int2log
	add	esp, 4
	mov	DWORD PTR _ppx$18[ebp], eax
	test	eax, eax
	js	SHORT $LN70@write_mark
	push	DWORD PTR _ppy$21[ebp]
	call	?int2log@@YAHH@Z			; int2log
	add	esp, 4
	mov	DWORD PTR _ppy$21[ebp], eax
	test	eax, eax
	jns	SHORT $LN69@write_mark
$LN70@write_mark:

; 6703 :           { KDU_ERROR_DEV(e,99); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0CP@INIGLHJN@Precinct?5dimensions?5must?5be?5exac@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6703 :           { KDU_ERROR_DEV(e,99); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6705 :           }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _ppy$21[ebp]
$LN69@write_mark:

; 6706 :         if ((ppx > 15) || (ppy > 15))

	mov	ecx, DWORD PTR _ppx$18[ebp]
	cmp	ecx, 15					; 0000000fH
	jg	SHORT $LN72@write_mark
	cmp	eax, 15					; 0000000fH
	jle	SHORT $LN71@write_mark
$LN72@write_mark:

; 6707 :           { KDU_ERROR_DEV(e,100); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0CJ@EGMBEELA@Precinct?5dimensions?5may?5not?5exce@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6707 :           { KDU_ERROR_DEV(e,100); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 16		; 00000010H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6709 :           }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _ppy$21[ebp]
	mov	ecx, DWORD PTR _ppx$18[ebp]
$LN71@write_mark:

; 6710 :         acc_length += out->put((kdu_byte)(ppx+(ppy<<4)));

	shl	al, 4
	add	al, cl
	mov	DWORD PTR _ppy$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN204@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN204@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6693 :     for (n=0; n <= levels; n++)

	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR _ppy$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [edi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6693 :     for (n=0; n <= levels; n++)

	mov	eax, DWORD PTR _levels$[ebp]
	cmp	esi, eax
	jle	$LL10@write_mark
$LN9@write_mark:

; 6711 :       }
; 6712 : 
; 6713 :   assert(length == acc_length);
; 6714 :   return length;

	mov	eax, DWORD PTR _length$2$[ebp]
$LN1@write_mark:

; 6715 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0:
	lea	ecx, DWORD PTR _e$29[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1:
	lea	ecx, DWORD PTR _e$28[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$2:
	lea	ecx, DWORD PTR _e$27[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$3:
	lea	ecx, DWORD PTR _e$26[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$4:
	lea	ecx, DWORD PTR _e$25[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$5:
	lea	ecx, DWORD PTR _e$24[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$6:
	lea	ecx, DWORD PTR _e$11[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$7:
	lea	ecx, DWORD PTR _w$23[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$8:
	lea	ecx, DWORD PTR _e$10[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$9:
	lea	ecx, DWORD PTR _e$9[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$10:
	lea	ecx, DWORD PTR _e$8[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$11:
	lea	ecx, DWORD PTR _e$7[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$12:
	lea	ecx, DWORD PTR _e$6[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$13:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$14:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$15:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$16:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?write_marker_segment@cod_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ENDP ; cod_params::write_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?copy_with_xforms@cod_params@@MAEXPAVkdu_params@@HH_N11@Z
_TEXT	SEGMENT
_e$2 = -116						; size = 20
_modes$ = -96						; size = 4
_blk_x$ = -92						; size = 4
_blk_y$ = -88						; size = 4
_use_precincts$ = -84					; size = 1
_atk_idx$ = -80						; size = 4
_kernels$ = -76						; size = 4
_reversible$ = -72					; size = 1
_dfs_idx$ = -68						; size = 4
_order$3 = -64						; size = 4
_use_eph$4 = -60					; size = 1
_use_sop$5 = -56					; size = 1
_num_layers$6 = -52					; size = 4
_mct_flags$7 = -48					; size = 4
_max_bytes$ = -44					; size = 4
_x$ = -40						; size = 4
_num_levels$ = -36					; size = 4
_x_last$8 = -32						; size = 1
_y_last$9 = -28						; size = 1
_use_ycc$10 = -24					; size = 1
_y$ = -20						; size = 4
_decomp_val$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_weight$ = 8						; size = 4
_source$ = 8						; size = 4
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_n$2$ = 20						; size = 4
_transpose$ = 20					; size = 1
tv572 = 24						; size = 4
_vflip$ = 24						; size = 1
tv574 = 28						; size = 4
tv571 = 28						; size = 4
_hflip$ = 28						; size = 1
?copy_with_xforms@cod_params@@MAEXPAVkdu_params@@HH_N11@Z PROC ; cod_params::copy_with_xforms, COMDAT
; _this$ = ecx

; 6322 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?copy_with_xforms@cod_params@@MAEXPAVkdu_params@@HH_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 6323 :   if (comp_idx < 0)

	cmp	DWORD PTR [edi+12], 0
	mov	esi, DWORD PTR _source$[ebp]
	jge	$LN25@copy_with_

; 6324 :     { // Start with the attributes which are common to all components
; 6325 :       bool use_ycc;
; 6326 :       int mct_flags;
; 6327 :       int num_layers;
; 6328 :       bool use_sop, use_eph;
; 6329 :       int order;
; 6330 :       bool x_last, y_last;
; 6331 : 
; 6332 :       if (source->get(Cycc,0,0,use_ycc,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _use_ycc$10[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04DEPIIIHA@Cycc?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN18@copy_with_

; 6333 :         {
; 6334 :           if (skip_components)

	movzx	eax, BYTE PTR _use_ycc$10[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR _skip_components$[ebp], ecx
	cmovne	eax, ecx
	mov	BYTE PTR _use_ycc$10[ebp], al

; 6335 :             use_ycc = false;
; 6336 :           set(Cycc,0,0,use_ycc);

	push	DWORD PTR _use_ycc$10[ebp]
	push	ecx
	push	ecx
	push	OFFSET ??_C@_04DEPIIIHA@Cycc?$AA@
	mov	ecx, edi
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN18@copy_with_:

; 6337 :         }
; 6338 :       if (source->get(Cmct,0,0,mct_flags,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _mct_flags$7[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04OOAAMMCO@Cmct?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN20@copy_with_

; 6339 :         set(Cmct,0,0,mct_flags);

	push	DWORD PTR _mct_flags$7[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_04OOAAMMCO@Cmct?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN20@copy_with_:

; 6340 :       if (source->get(Clayers,0,0,num_layers,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _num_layers$6[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BJCMAMHC@Clayers?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN21@copy_with_

; 6341 :         set(Clayers,0,0,num_layers);

	push	DWORD PTR _num_layers$6[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_07BJCMAMHC@Clayers?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN21@copy_with_:

; 6342 :       if (source->get(Cuse_sop,0,0,use_sop,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _use_sop$5[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08DAJNLNLL@Cuse_sop?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN22@copy_with_

; 6343 :         set(Cuse_sop,0,0,use_sop);

	push	DWORD PTR _use_sop$5[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_08DAJNLNLL@Cuse_sop?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN22@copy_with_:

; 6344 :       if (source->get(Cuse_eph,0,0,use_eph,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _use_eph$4[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08NAIOMJOM@Cuse_eph?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN23@copy_with_

; 6345 :         set(Cuse_eph,0,0,use_eph);

	push	DWORD PTR _use_eph$4[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_08NAIOMJOM@Cuse_eph?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN23@copy_with_:

; 6346 :       if (source->get(Corder,0,0,order,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _order$3[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06IKJBDDKO@Corder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN24@copy_with_

; 6347 :         set(Corder,0,0,order);

	push	DWORD PTR _order$3[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_06IKJBDDKO@Corder?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN24@copy_with_:

; 6348 :       if (source->get(Calign_blk_last,0,(transpose)?1:0,y_last,false) &&

	mov	bl, BYTE PTR _transpose$[ebp]
	lea	eax, DWORD PTR _y_last$9[ebp]
	push	1
	push	1
	push	0
	push	eax
	xor	eax, eax
	mov	ecx, esi
	test	bl, bl
	setne	al
	push	eax
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN25@copy_with_
	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _x_last$8[ebp]
	mov	ecx, esi
	push	eax
	xor	eax, eax
	test	bl, bl
	sete	al
	push	eax
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN25@copy_with_

; 6349 :           source->get(Calign_blk_last,0,(transpose)?0:1,x_last,false))
; 6350 :         {
; 6351 :           if (hflip) x_last = !x_last;

	cmp	BYTE PTR _hflip$[ebp], 0
	je	SHORT $LN26@copy_with_
	cmp	BYTE PTR _x_last$8[ebp], 0
	sete	BYTE PTR _x_last$8[ebp]
$LN26@copy_with_:

; 6352 :           if (vflip) y_last = !y_last;

	cmp	BYTE PTR _vflip$[ebp], 0
	je	SHORT $LN27@copy_with_
	cmp	BYTE PTR _y_last$9[ebp], 0
	sete	BYTE PTR _y_last$9[ebp]
$LN27@copy_with_:

; 6353 :           set(Calign_blk_last,0,0,y_last); set(Calign_blk_last,0,1,x_last);

	push	DWORD PTR _y_last$9[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
	push	DWORD PTR _x_last$8[ebp]
	mov	ecx, edi
	push	1
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN25@copy_with_:

; 6354 :         }
; 6355 :     }
; 6356 : 
; 6357 :   // Now for the tile-component specific attributes
; 6358 :   int num_levels, dfs_idx;
; 6359 :   bool reversible;
; 6360 :   int kernels, atk_idx;
; 6361 :   bool use_precincts;
; 6362 :   int blk_x, blk_y;
; 6363 :   int modes;
; 6364 : 
; 6365 :   if (source->get(Clevels,0,0,num_levels,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _num_levels$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN28@copy_with_

; 6366 :     {
; 6367 :       num_levels -= discard_levels;

	mov	eax, DWORD PTR _num_levels$[ebp]
	sub	eax, DWORD PTR _discard_levels$[ebp]
	mov	DWORD PTR _num_levels$[ebp], eax

; 6368 :       if (num_levels < 0)

	jns	SHORT $LN29@copy_with_

; 6369 :         { KDU_ERROR_DEV(e,90); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0HE@NKGALBNL@Attempting?5to?5discard?5too?5many?5r@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6369 :         { KDU_ERROR_DEV(e,90); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6373 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _num_levels$[ebp]
$LN29@copy_with_:

; 6374 :       set(Clevels,0,0,num_levels);

	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	mov	ecx, edi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN28@copy_with_:

; 6375 :     }
; 6376 :   if (source->get(Cdfs,0,0,dfs_idx,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _dfs_idx$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN30@copy_with_

; 6377 :     set(Cdfs,0,0,dfs_idx);

	push	DWORD PTR _dfs_idx$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN30@copy_with_:

; 6378 : 
; 6379 :        // Note that we deliberately do not copy `Cads' since it is best
; 6380 :        // to let the `finalize' function assign new ADS indices during
; 6381 :        // transcoding
; 6382 : 
; 6383 :   int n, decomp_val;
; 6384 :   for (n=0; source->get(Cdecomp,n,0,decomp_val,false,false); n++)

	push	1
	xor	ebx, ebx
	lea	eax, DWORD PTR _decomp_val$[ebp]
	push	ebx
	push	ebx
	push	eax
	push	ebx
	push	ebx
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN33@copy_with_
	mov	ecx, DWORD PTR _discard_levels$[ebp]
	neg	ecx
	mov	DWORD PTR tv571[ebp], ecx
	npad	6
$LL4@copy_with_:

; 6385 :     {
; 6386 :       if (transpose)

	cmp	BYTE PTR _transpose$[ebp], 0
	je	SHORT $LN66@copy_with_

; 6387 :         decomp_val = transpose_decomp(decomp_val);

	push	DWORD PTR _decomp_val$[ebp]
	call	?transpose_decomp@cod_params@@SAHH@Z	; cod_params::transpose_decomp
	mov	ecx, DWORD PTR tv571[ebp]
	add	esp, 4
	mov	DWORD PTR _decomp_val$[ebp], eax
	jmp	SHORT $LN31@copy_with_
$LN66@copy_with_:
	mov	eax, DWORD PTR _decomp_val$[ebp]
$LN31@copy_with_:

; 6388 :       if (n >= discard_levels)

	cmp	ebx, DWORD PTR _discard_levels$[ebp]
	jl	SHORT $LN2@copy_with_

; 6389 :         set(Cdecomp,n-discard_levels,0,decomp_val);

	push	eax
	push	0
	push	ecx
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	mov	ecx, edi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN2@copy_with_:

; 6378 : 
; 6379 :        // Note that we deliberately do not copy `Cads' since it is best
; 6380 :        // to let the `finalize' function assign new ADS indices during
; 6381 :        // transcoding
; 6382 : 
; 6383 :   int n, decomp_val;
; 6384 :   for (n=0; source->get(Cdecomp,n,0,decomp_val,false,false); n++)

	inc	DWORD PTR tv571[ebp]
	lea	eax, DWORD PTR _decomp_val$[ebp]
	push	1
	push	0
	push	0
	push	eax
	push	0
	inc	ebx
	mov	ecx, esi
	push	ebx
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	ecx, DWORD PTR tv571[ebp]
	test	al, al
	jne	SHORT $LL4@copy_with_

; 6390 :     }
; 6391 :   if ((n > 0) && (n <= discard_levels))

	test	ebx, ebx
	jle	SHORT $LN33@copy_with_
	cmp	ebx, DWORD PTR _discard_levels$[ebp]
	jg	SHORT $LN33@copy_with_

; 6392 :     set(Cdecomp,0,0,decomp_val); // We discarded it all; replicate last entry

	push	DWORD PTR _decomp_val$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN33@copy_with_:

; 6393 : 
; 6394 :   if (source->get(Creversible,0,0,reversible,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _reversible$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN34@copy_with_

; 6395 :     set(Creversible,0,0,reversible);

	push	DWORD PTR _reversible$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN34@copy_with_:

; 6396 :   if (source->get(Ckernels,0,0,kernels,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _kernels$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN35@copy_with_

; 6397 :     set(Ckernels,0,0,kernels);

	push	DWORD PTR _kernels$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN35@copy_with_:

; 6398 :   if (source->get(Catk,0,0,atk_idx,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _atk_idx$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN36@copy_with_

; 6399 :     set(Catk,0,0,atk_idx);

	push	DWORD PTR _atk_idx$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN36@copy_with_:

; 6400 :   if (source->get(Cuse_precincts,0,0,use_precincts,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _use_precincts$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN37@copy_with_

; 6401 :     set(Cuse_precincts,0,0,use_precincts);

	push	DWORD PTR _use_precincts$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN37@copy_with_:

; 6402 :   if (source->get(Cblk,0,(transpose)?1:0,blk_y,false) &&

	mov	bl, BYTE PTR _transpose$[ebp]
	lea	ecx, DWORD PTR _blk_y$[ebp]
	push	1
	push	1
	xor	eax, eax
	test	bl, bl
	push	0
	push	ecx
	setne	al
	mov	ecx, esi
	push	eax
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	mov	DWORD PTR tv574[ebp], eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN38@copy_with_
	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _blk_x$[ebp]
	mov	ecx, esi
	push	eax
	xor	eax, eax
	test	bl, bl
	sete	al
	push	eax
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN38@copy_with_

; 6403 :       source->get(Cblk,0,(transpose)?0:1,blk_x,false))
; 6404 :     { set(Cblk,0,0,blk_y); set(Cblk,0,1,blk_x); }

	push	DWORD PTR _blk_y$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _blk_x$[ebp]
	mov	ecx, edi
	push	1
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN38@copy_with_:

; 6405 :   if (source->get(Cmodes,0,0,modes,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _modes$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06EGDCPANH@Cmodes?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN39@copy_with_

; 6406 :     set(Cmodes,0,0,modes);

	push	DWORD PTR _modes$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_06EGDCPANH@Cmodes?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN39@copy_with_:

; 6407 : 
; 6408 :   int x, y;
; 6409 :   if (source->get(Cprecincts,discard_levels,(transpose)?1:0,y,false) &&

	mov	ebx, DWORD PTR _discard_levels$[ebp]
	lea	eax, DWORD PTR _y$[ebp]
	push	1
	push	1
	push	0
	push	eax
	push	DWORD PTR tv574[ebp]
	mov	ecx, esi
	push	ebx
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN67@copy_with_
	push	1
	xor	eax, eax
	lea	ecx, DWORD PTR _x$[ebp]
	cmp	BYTE PTR _transpose$[ebp], al
	push	1
	push	0
	push	ecx
	sete	al
	mov	ecx, esi
	push	eax
	push	ebx
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	mov	DWORD PTR tv572[ebp], eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN67@copy_with_

; 6410 :       source->get(Cprecincts,discard_levels,(transpose)?0:1,x,false))
; 6411 :     { // Copy precinct dimensions
; 6412 :       set(Cprecincts,0,0,y); set(Cprecincts,0,1,x);

	push	DWORD PTR _y$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _x$[ebp]
	mov	ecx, edi
	push	1
	push	0
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 6413 :       for (n=1; source->get(Cprecincts,discard_levels+n,(transpose)?1:0,y,
; 6414 :                             false,false) &&

	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _n$2$[ebp], 1
	push	eax
	push	DWORD PTR tv574[ebp]
	lea	eax, DWORD PTR [ebx+1]
	mov	ecx, esi
	push	eax
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN67@copy_with_
$LL7@copy_with_:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _x$[ebp]
	mov	ecx, esi
	push	eax
	push	DWORD PTR tv572[ebp]
	mov	eax, DWORD PTR _n$2$[ebp]
	add	eax, ebx
	push	eax
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN67@copy_with_

; 6415 :                 source->get(Cprecincts,discard_levels+n,(transpose)?0:1,x,
; 6416 :                             false,false); n++)
; 6417 :         { set(Cprecincts,n,0,y); set(Cprecincts,n,1,x); }

	push	DWORD PTR _y$[ebp]
	mov	ecx, edi
	push	0
	push	DWORD PTR _n$2$[ebp]
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _x$[ebp]
	mov	ecx, edi
	push	1
	push	DWORD PTR _n$2$[ebp]
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	eax, DWORD PTR _n$2$[ebp]
	lea	ecx, DWORD PTR _y$[ebp]
	push	1
	push	0
	push	0
	push	ecx
	push	DWORD PTR tv574[ebp]
	inc	eax
	mov	ecx, esi
	mov	DWORD PTR _n$2$[ebp], eax
	add	eax, ebx
	push	eax
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL7@copy_with_
$LN67@copy_with_:

; 6418 :     }
; 6419 : 
; 6420 :   float weight;
; 6421 :   if (source->get(Cweight,0,0,weight,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _weight$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07HDHNGJDI@Cweight?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN41@copy_with_

; 6422 :     set(Cweight,0,0,weight);

	movss	xmm0, DWORD PTR _weight$[ebp]
	sub	esp, 8
	cvtps2pd xmm0, xmm0
	mov	ecx, edi
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	OFFSET ??_C@_07HDHNGJDI@Cweight?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
$LN41@copy_with_:

; 6423 :   for (n=0; source->get(Clev_weights,n,0,weight,false,false); n++)

	push	1
	xor	ebx, ebx
	lea	eax, DWORD PTR _weight$[ebp]
	push	ebx
	push	ebx
	push	eax
	push	ebx
	push	ebx
	push	OFFSET ??_C@_0N@HICBBPMC@Clev_weights?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN9@copy_with_
$LL10@copy_with_:
	movss	xmm0, DWORD PTR _weight$[ebp]

; 6424 :     set(Clev_weights,n,0,weight);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	mov	ecx, edi
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	ebx
	push	OFFSET ??_C@_0N@HICBBPMC@Clev_weights?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _weight$[ebp]
	inc	ebx
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0N@HICBBPMC@Clev_weights?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL10@copy_with_
$LN9@copy_with_:

; 6425 :   for (n=0; source->get(Cband_weights,n,0,weight,false,false); n++)

	push	1
	xor	ebx, ebx
	lea	eax, DWORD PTR _weight$[ebp]
	push	ebx
	push	ebx
	push	eax
	push	ebx
	push	ebx
	push	OFFSET ??_C@_0O@GLALLHKC@Cband_weights?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN12@copy_with_
	npad	3
$LL13@copy_with_:
	movss	xmm0, DWORD PTR _weight$[ebp]

; 6426 :     set(Cband_weights,n,0,weight);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	mov	ecx, edi
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	ebx
	push	OFFSET ??_C@_0O@GLALLHKC@Cband_weights?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _weight$[ebp]
	inc	ebx
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0O@GLALLHKC@Cband_weights?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL13@copy_with_
$LN12@copy_with_:

; 6427 :   
; 6428 :   int max_bytes;
; 6429 :   for (n=0; source->get(Creslengths,n,0,max_bytes,false,false); n++)

	push	1
	xor	ebx, ebx
	lea	eax, DWORD PTR _max_bytes$[ebp]
	push	ebx
	push	ebx
	push	eax
	push	ebx
	push	ebx
	push	OFFSET ??_C@_0M@HKNEBDCB@Creslengths?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN15@copy_with_
	npad	7
$LL16@copy_with_:

; 6430 :     set(Creslengths,n,0,max_bytes);

	push	DWORD PTR _max_bytes$[ebp]
	mov	ecx, edi
	push	0
	push	ebx
	push	OFFSET ??_C@_0M@HKNEBDCB@Creslengths?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _max_bytes$[ebp]
	inc	ebx
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0M@HKNEBDCB@Creslengths?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL16@copy_with_
$LN15@copy_with_:

; 6431 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?copy_with_xforms@cod_params@@MAEXPAVkdu_params@@HH_N11@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?copy_with_xforms@cod_params@@MAEXPAVkdu_params@@HH_N11@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?copy_with_xforms@cod_params@@MAEXPAVkdu_params@@HH_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?copy_with_xforms@cod_params@@MAEXPAVkdu_params@@HH_N11@Z ENDP ; cod_params::copy_with_xforms
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?finalize@cod_params@@MAEX_N@Z
_TEXT	SEGMENT
_e$2 = -240						; size = 20
_progression_order$ = -220				; size = 4
_modes$ = -216						; size = 4
_mcc_base$1$ = -212					; size = 4
_sub_x$3 = -212						; size = 4
_sub_y$4 = -208						; size = 4
_inst_idx$5 = -208					; size = 4
_profile$ = -204					; size = 4
_bval$ = -197						; size = 1
_blk_size$ = -196					; size = 8
_precinct_siz$6 = -188					; size = 8
_precision$7 = -184					; size = 4
_xform_type$8 = -184					; size = 4
_m_components$ = -180					; size = 4
_decomp$ = -176						; size = 4
_last_sub_x$9 = -172					; size = 4
_num_stages$10 = -172					; size = 4
_mco$2$ = -168						; size = 4
_last_sub_y$11 = -168					; size = 4
_stage_idx$1$ = -164					; size = 4
_k_rev$12 = -164					; size = 1
_last_precision$13 = -164				; size = 4
_use_ycc$ = -160					; size = 1
_mct_flags$ = -156					; size = 4
_dwt_levels$ = -152					; size = 4
_rev$14 = -145						; size = 1
_last_rev$15 = -145					; size = 1
_siz$1$ = -144						; size = 4
_dfs$1$ = -144						; size = 4
tv1826 = -144						; size = 4
_kernels$ = -140					; size = 4
_atk_idx$ = -136					; size = 4
_ads_idx$ = -132					; size = 4
_dfs_idx$ = -128					; size = 4
_val$ = -124						; size = 4
_e$16 = -120						; size = 20
_e$17 = -120						; size = 20
_w$18 = -120						; size = 20
_e$19 = -120						; size = 20
_e$20 = -120						; size = 20
_e$21 = -120						; size = 20
_w$22 = -120						; size = 20
_e$23 = -120						; size = 20
_e$24 = -120						; size = 20
_e$25 = -120						; size = 20
_e$26 = -120						; size = 20
_e$27 = -120						; size = 20
_e$28 = -120						; size = 20
_e$29 = -120						; size = 20
_reversible$ = -97					; size = 1
_text$30 = -96						; size = 80
_text$31 = -96						; size = 80
_text$32 = -96						; size = 80
_text$33 = -96						; size = 80
_text$34 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_after_reading$ = 8					; size = 1
?finalize@cod_params@@MAEX_N@Z PROC			; cod_params::finalize, COMDAT
; _this$ = ecx

; 6899 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?finalize@cod_params@@MAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 6900 :   int n, val, ads_idx, dfs_idx, decomp;
; 6901 :   bool bval;
; 6902 : 
; 6903 :   if (!after_reading)

	mov	bl, BYTE PTR _after_reading$[ebp]
	mov	edi, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	test	bl, bl
	jne	$LN48@finalize

; 6904 :     {
; 6905 :       if (!get(Clayers,0,0,val))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BJCMAMHC@Clayers?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LN30@finalize

; 6906 :         set(Clayers,0,0,1);

	push	1
	push	0
	push	0
	push	OFFSET ??_C@_07BJCMAMHC@Clayers?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN283@finalize:
	mov	ebx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
$LN32@finalize:

; 6913 :       if (!get(Cuse_sop,0,0,val))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08DAJNLNLL@Cuse_sop?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN33@finalize

; 6914 :         set(Cuse_sop,0,0,0);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_08DAJNLNLL@Cuse_sop?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN33@finalize:

; 6915 :       if (!get(Cuse_eph,0,0,val))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08NAIOMJOM@Cuse_eph?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN34@finalize

; 6916 :         set(Cuse_eph,0,0,0);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_08NAIOMJOM@Cuse_eph?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN34@finalize:

; 6917 :       if (!get(Calign_blk_last,0,0,val))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN35@finalize

; 6918 :         {
; 6919 :           assert(!get(Calign_blk_last,0,1,val));
; 6920 :           set(Calign_blk_last,0,0,0);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 6921 :           set(Calign_blk_last,0,1,0);

	push	0
	push	1
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN35@finalize:

; 6922 :         }
; 6923 :       if (!get(Clevels,0,0,val))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LN36@finalize

; 6924 :         set(Clevels,0,0,5);

	push	5
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	jmp	$LN38@finalize
$LN30@finalize:

; 6907 :       else if (val > 16384)

	cmp	DWORD PTR _val$[ebp], 16384		; 00004000H
	jle	$LN283@finalize

; 6908 :         { KDU_ERROR(e,108); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$29[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$29[ebp]
	lea	ecx, DWORD PTR _e$29[ebp]
	push	OFFSET ??_C@_0CD@EICILEGK@Illegal?5number?5of?5quality?5layers@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6908 :         { KDU_ERROR(e,108); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$29[ebp+4], 0
	mov	eax, edi
	push	DWORD PTR _val$[ebp]
	mov	ebx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmove	eax, ebx
	push	eax
	lea	eax, DWORD PTR _text$34[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$34[ebp]
	lea	ecx, DWORD PTR _e$29[ebp]
	push	eax
	mov	eax, DWORD PTR _e$29[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$29[ebp]
	lea	ecx, DWORD PTR _e$29[ebp]
	push	OFFSET ??_C@_0GK@BLGJFPGL@?0?5detected?5by?5coding?5parameter?5s@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6912 :         }

	lea	ecx, DWORD PTR _e$29[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	jmp	$LN32@finalize
$LN36@finalize:

; 6925 :       else if (val > 32)

	cmp	DWORD PTR _val$[ebp], 32		; 00000020H
	jle	SHORT $LN38@finalize

; 6926 :         { KDU_ERROR(e,109); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$28[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$28[ebp]
	lea	ecx, DWORD PTR _e$28[ebp]
	push	OFFSET ??_C@_0BP@JIANFEOP@Illegal?5number?5of?5DWT?5levels?0?5?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6926 :         { KDU_ERROR(e,109); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$28[ebp+4], 0
	mov	eax, edi
	push	DWORD PTR _val$[ebp]
	cmove	eax, ebx
	push	eax
	lea	eax, DWORD PTR _text$33[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$33[ebp]
	lea	ecx, DWORD PTR _e$28[ebp]
	push	eax
	mov	eax, DWORD PTR _e$28[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$28[ebp]
	lea	ecx, DWORD PTR _e$28[ebp]
	push	OFFSET ??_C@_0HP@FAEJKEME@?0?5detected?5by?5coding?5parameter?5s@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6931 :         }

	lea	ecx, DWORD PTR _e$28[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN38@finalize:

; 6932 : 
; 6933 :       bool need_dfs=false, need_ads=false;
; 6934 :       for (n=0; get(Cdecomp,n,0,decomp,false,false); n++)

	push	1
	xor	edi, edi
	xor	al, al
	push	edi
	push	edi
	mov	DWORD PTR tv1826[ebp], eax
	mov	ecx, esi
	lea	eax, DWORD PTR _decomp$[ebp]
	xor	bl, bl
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN280@finalize
	npad	10
$LL4@finalize:

; 6935 :         { // Check decomposition structural information supplied here
; 6936 :           if ((decomp & 3) != 3)

	mov	ecx, DWORD PTR _decomp$[ebp]
	mov	edx, 1
	mov	al, cl
	movzx	ebx, bl
	and	al, 3
	cmp	al, 3

; 6937 :             need_dfs = true;
; 6938 :           if ((decomp & ~3) != 0)

	mov	eax, DWORD PTR tv1826[ebp]
	push	edx
	cmovne	ebx, edx
	movzx	eax, al
	test	ecx, -4					; fffffffcH
	mov	ecx, esi
	push	0
	cmovne	eax, edx
	inc	edi
	push	0
	mov	DWORD PTR tv1826[ebp], eax
	lea	eax, DWORD PTR _decomp$[ebp]
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL4@finalize

; 6939 :             need_ads = true;
; 6940 :         }
; 6941 :   
; 6942 :       if (need_dfs)

	test	bl, bl
	je	SHORT $LN41@finalize

; 6943 :         {
; 6944 :           if (!get(Cdfs,0,0,dfs_idx,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _dfs_idx$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN44@finalize

; 6945 :             set(Cdfs,0,0,dfs_idx=find_suitable_dfs_idx());

	mov	ecx, esi
	call	?find_suitable_dfs_idx@cod_params@@AAEHXZ ; cod_params::find_suitable_dfs_idx
	mov	DWORD PTR _dfs_idx$[ebp], eax
	push	eax

; 6946 :         }

	jmp	SHORT $LN285@finalize
$LN41@finalize:

; 6947 :       else if (n > 0)

	test	edi, edi
	jle	SHORT $LN44@finalize

; 6948 :         set(Cdfs,0,0,dfs_idx=0); // Have new decomp style with no need for DFS

	mov	DWORD PTR _dfs_idx$[ebp], 0
	push	0
$LN285@finalize:
	push	0
	push	0
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN44@finalize:

; 6949 : 
; 6950 :       if (need_ads)

	mov	eax, DWORD PTR tv1826[ebp]
	test	al, al
	je	SHORT $LN45@finalize

; 6951 :         {
; 6952 :           if (!get(Cads,0,0,ads_idx,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _ads_idx$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04OONIPDNE@Cads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN280@finalize

; 6953 :             set(Cads,0,0,ads_idx=find_suitable_ads_idx());

	mov	ecx, esi
	call	?find_suitable_ads_idx@cod_params@@AAEHXZ ; cod_params::find_suitable_ads_idx
	mov	DWORD PTR _ads_idx$[ebp], eax
	push	eax

; 6954 :         }

	jmp	SHORT $LN292@finalize
$LN45@finalize:

; 6955 :       else if (n > 0)

	test	edi, edi
	jle	SHORT $LN280@finalize

; 6956 :         set(Cads,0,0,ads_idx=0); // Have new decomp style with no need for ADS

	mov	DWORD PTR _ads_idx$[ebp], 0
	push	0
$LN292@finalize:
	push	0
	push	0
	push	OFFSET ??_C@_04OONIPDNE@Cads?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN280@finalize:
	mov	bl, BYTE PTR _after_reading$[ebp]
$LN48@finalize:

; 6957 :     }
; 6958 : 
; 6959 :   if (!get(Cads,0,0,ads_idx))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _ads_idx$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04OONIPDNE@Cads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	ecx, DWORD PTR _ads_idx$[ebp]
	xor	edx, edx

; 6960 :     ads_idx = 0;
; 6961 :   if (!get(Cdfs,0,0,dfs_idx))

	push	1
	push	1
	push	1
	test	al, al
	lea	eax, DWORD PTR _dfs_idx$[ebp]
	push	eax
	push	edx
	cmove	ecx, edx
	push	edx
	mov	DWORD PTR _ads_idx$[ebp], ecx
	mov	ecx, esi
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	edi, DWORD PTR _dfs_idx$[ebp]
	xor	ecx, ecx
	test	al, al

; 6962 :     dfs_idx = 0;
; 6963 :   if (((ads_idx != 0) || (dfs_idx != 0)) && after_reading)

	mov	eax, DWORD PTR _ads_idx$[ebp]
	cmove	edi, ecx
	mov	DWORD PTR _dfs_idx$[ebp], edi
	test	eax, eax
	jne	SHORT $LN52@finalize
	test	edi, edi
	je	$LN60@finalize
$LN52@finalize:
	test	bl, bl
	je	$LN60@finalize

; 6964 :     { // Use ADS and/or DFS to derive `Cdecomp' information
; 6965 :       kdu_params *ads = NULL;

	xor	ebx, ebx

; 6966 :       if ((ads_idx > 0) &&

	test	eax, eax
	jle	SHORT $LN53@finalize
	push	OFFSET ??_C@_03BLBGDEDA@ADS?$AA@
	mov	ecx, esi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $LN54@finalize
	push	1
	push	DWORD PTR _ads_idx$[ebp]
	mov	ecx, ebx
	push	-1
	push	DWORD PTR [esi+8]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	ebx, eax
	test	ebx, ebx
	jne	SHORT $LN286@finalize
$LN54@finalize:

; 6969 :         { KDU_ERROR(e,0x2450501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$27[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$27[ebp]
	lea	ecx, DWORD PTR _e$27[ebp]
	push	OFFSET ??_C@_0JP@NFJAKPFP@ADS?5table?5index?5encountered?5whil@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6969 :         { KDU_ERROR(e,0x2450501); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6973 :         }

	lea	ecx, DWORD PTR _e$27[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN286@finalize:
	mov	edi, DWORD PTR _dfs_idx$[ebp]
$LN53@finalize:

; 6974 :       kdu_params *dfs = NULL;

	mov	DWORD PTR _dfs$1$[ebp], 0

; 6975 :       if ((dfs_idx > 0) &&

	test	edi, edi
	jle	SHORT $LN55@finalize
	push	OFFSET ??_C@_03CPEMBAGM@DFS?$AA@
	mov	ecx, esi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	DWORD PTR _dfs$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN56@finalize
	push	1
	push	edi
	push	-1
	push	-1
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	DWORD PTR _dfs$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN55@finalize
$LN56@finalize:

; 6978 :         { KDU_ERROR(e,0x2450502); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$26[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$26[ebp]
	lea	ecx, DWORD PTR _e$26[ebp]
	push	OFFSET ??_C@_0JL@PNHEEPLI@DFS?5table?5index?5encountered?5whil@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6978 :         { KDU_ERROR(e,0x2450502); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 6982 :         }

	lea	ecx, DWORD PTR _e$26[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN55@finalize:

; 6983 : 
; 6984 :       if ((comp_idx < 0) && (tile_idx >= 0) && (ads != NULL))

	cmp	DWORD PTR [esi+12], 0
	jge	SHORT $LN59@finalize
	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	js	SHORT $LN59@finalize
	test	ebx, ebx
	je	SHORT $LN59@finalize

; 6985 :         { // See if we should defer resolution of the decomposition structure
; 6986 :           // until we are working with an actual tile-component.
; 6987 :           for (n=0; n < num_comps; n++)

	mov	eax, DWORD PTR [esi+24]
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN239@finalize
$LL7@finalize:

; 6988 :             if (access_unique(tile_idx,n) == NULL)

	push	0
	push	edi
	push	ecx
	mov	ecx, esi
	call	?access_unique@kdu_params@@QAEPAV1@HHH@Z ; kdu_params::access_unique
	test	eax, eax
	mov	eax, DWORD PTR [esi+24]
	je	SHORT $LN239@finalize

; 6985 :         { // See if we should defer resolution of the decomposition structure
; 6986 :           // until we are working with an actual tile-component.
; 6987 :           for (n=0; n < num_comps; n++)

	mov	ecx, DWORD PTR [esi+8]
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL7@finalize
$LN239@finalize:

; 6989 :               break;
; 6990 :           if (n == num_comps)

	cmp	edi, eax
	jne	SHORT $LN59@finalize

; 6991 :             {
; 6992 :               ads = dfs = NULL;
; 6993 :               ads_idx = dfs_idx = 0;

	mov	DWORD PTR _dfs_idx$[ebp], 0
	mov	DWORD PTR _ads_idx$[ebp], 0

; 6994 :             }
; 6995 :         }
; 6996 :       if ((dfs != NULL) || (ads != NULL))

	jmp	SHORT $LN60@finalize
$LN59@finalize:
	mov	eax, DWORD PTR _dfs$1$[ebp]
	test	eax, eax
	jne	SHORT $LN61@finalize
	test	ebx, ebx
	je	SHORT $LN60@finalize
$LN61@finalize:

; 6997 :         derive_decomposition_structure(dfs,ads);

	push	ebx
	push	eax
	mov	ecx, esi
	call	?derive_decomposition_structure@cod_params@@AAEXPAVkdu_params@@0@Z ; cod_params::derive_decomposition_structure
$LN60@finalize:

; 6998 :     }
; 6999 : 
; 7000 : 
; 7001 :   if (!get(Cdecomp,0,0,decomp))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _decomp$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN62@finalize

; 7002 :     set(Cdecomp,0,0,decomp=3); // Default Mallat structure

	push	3
	push	0
	push	0
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	mov	ecx, esi
	mov	DWORD PTR _decomp$[ebp], 3
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN62@finalize:

; 7003 : 
; 7004 :   if (!after_reading)

	mov	bl, BYTE PTR _after_reading$[ebp]
	test	bl, bl
	jne	SHORT $LN65@finalize

; 7005 :     {
; 7006 :       if (!get(Cads,0,0,ads_idx))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _ads_idx$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04OONIPDNE@Cads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN64@finalize

; 7007 :         set(Cads,0,0,ads_idx=0);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04OONIPDNE@Cads?$AA@
	mov	ecx, esi
	mov	DWORD PTR _ads_idx$[ebp], 0
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN64@finalize:

; 7008 :       if (!get(Cdfs,0,0,dfs_idx))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _dfs_idx$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN65@finalize

; 7009 :         set(Cdfs,0,0,dfs_idx=0);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	mov	ecx, esi
	mov	DWORD PTR _dfs_idx$[ebp], 0
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN65@finalize:

; 7010 :     }
; 7011 : 
; 7012 :   if (dfs_idx > 0)

	mov	eax, DWORD PTR _dfs_idx$[ebp]
	test	eax, eax
	jle	SHORT $LN66@finalize

; 7013 :     validate_dfs_data(dfs_idx);

	push	eax
	mov	ecx, esi
	call	?validate_dfs_data@cod_params@@AAEXH@Z	; cod_params::validate_dfs_data
	mov	eax, DWORD PTR _dfs_idx$[ebp]
$LN66@finalize:

; 7014 :   if ((tile_idx >= 0) && (ads_idx > 0))

	cmp	DWORD PTR [esi+8], 0
	jl	SHORT $LN272@finalize
	mov	ecx, DWORD PTR _ads_idx$[ebp]
	test	ecx, ecx
	jle	SHORT $LN272@finalize

; 7015 :     validate_ads_data(ads_idx);

	push	ecx
	mov	ecx, esi
	call	?validate_ads_data@cod_params@@AAEXH@Z	; cod_params::validate_ads_data
	mov	eax, DWORD PTR _dfs_idx$[ebp]
$LN272@finalize:

; 7016 : 
; 7017 :   if (!after_reading)

	test	bl, bl
	jne	SHORT $LN12@finalize

; 7018 :     {
; 7019 :       if ((comp_idx < 0) && (tile_idx < 0) && (dfs_idx > 0))

	cmp	DWORD PTR [esi+12], 0
	jge	SHORT $LN9@finalize
	cmp	DWORD PTR [esi+8], 0
	jge	SHORT $LN12@finalize
	test	eax, eax
	jle	SHORT $LN9@finalize

; 7020 :         { // Need to instantiate phsical objects in each component to make sure
; 7021 :           // the non-trivial `Cdfs' value in this cluster head actually gets
; 7022 :           // written in component-specific COC marker segments, as required.
; 7023 :             for (int c=0; c < num_comps; c++)

	xor	edi, edi
	cmp	DWORD PTR [esi+24], edi
	jle	SHORT $LN9@finalize
	npad	3
$LL10@finalize:

; 7024 :               access_relation(-1,c,0,false); // Forces creation of new object

	push	0
	push	0
	push	edi
	push	-1
	mov	ecx, esi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	inc	edi
	cmp	edi, DWORD PTR [esi+24]
	jl	SHORT $LL10@finalize
$LN9@finalize:

; 7025 :         }
; 7026 : 
; 7027 :       if ((tile_idx < 0) && (ads_idx > 0))

	cmp	DWORD PTR [esi+8], 0
	jge	SHORT $LN12@finalize
	cmp	DWORD PTR _ads_idx$[ebp], 0
	jle	SHORT $LN12@finalize

; 7028 :         { // Need to instantiate physical objects in each tile to make sure the
; 7029 :           // non-trivial `Cads' value in this main header object actually
; 7030 :           // gets written in a tile-specific COD/COC marker segment.  This is
; 7031 :           // because `Cads' cannot be written in a main header COD/COC marker
; 7032 :           // segment.
; 7033 :           for (int t=0; t < num_tiles; t++)

	xor	edi, edi
	cmp	DWORD PTR [esi+20], edi
	jle	SHORT $LN12@finalize
	npad	6
$LL13@finalize:

; 7034 :             access_relation(t,comp_idx,0,false);// Force creation of new object

	push	0
	push	0
	push	DWORD PTR [esi+12]
	mov	ecx, esi
	push	edi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	inc	edi
	cmp	edi, DWORD PTR [esi+20]
	jl	SHORT $LL13@finalize
$LN12@finalize:

; 7035 :         }
; 7036 :     }
; 7037 : 
; 7038 :   // Check for one or another of Catk, Ckernels, Creversible being specified
; 7039 :   // explicitly for this object -- may require adjusting the other two
; 7040 :   // quantities, if incompatible.
; 7041 :   bool reversible;
; 7042 :   int kernels, atk_idx;
; 7043 :   if (!get(Catk,0,0,atk_idx))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _atk_idx$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN71@finalize

; 7044 :     set(Catk,0,0,atk_idx=0); // Can't make a non-trivial default for ATK index

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	mov	ecx, esi
	mov	DWORD PTR _atk_idx$[ebp], 0
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN71@finalize:

; 7045 :   if (get(Catk,0,0,atk_idx,false) && (atk_idx != 0))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _atk_idx$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN72@finalize
	cmp	DWORD PTR _atk_idx$[ebp], 0
	je	SHORT $LN72@finalize

; 7046 :     { // ATK provided specifically for this tile-component.
; 7047 :       if ((!get(Ckernels,0,0,kernels,false)) || (kernels != Ckernels_ATK))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _kernels$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN75@finalize
	cmp	DWORD PTR _kernels$[ebp], -1
	je	$LN273@finalize
$LN75@finalize:

; 7048 :         set(Ckernels,0,0,kernels=Ckernels_ATK);

	mov	DWORD PTR _kernels$[ebp], -1
	push	-1

; 7049 :     }

	jmp	$LN288@finalize
$LN72@finalize:

; 7050 :   else if (get(Ckernels,0,0,kernels,false) && (kernels != Ckernels_ATK))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _kernels$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN76@finalize
	cmp	DWORD PTR _kernels$[ebp], -1
	je	$LN76@finalize

; 7051 :     { // One of the Part-1 kernels specified explicitly for this tile-component
; 7052 :       if ((!get(Catk,0,0,atk_idx,false)) || (atk_idx != 0))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _atk_idx$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN79@finalize
	cmp	DWORD PTR _atk_idx$[ebp], 0
	je	SHORT $LN78@finalize
$LN79@finalize:

; 7053 :         set(Catk,0,0,atk_idx=0);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	mov	ecx, esi
	mov	DWORD PTR _atk_idx$[ebp], 0
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN78@finalize:

; 7054 :       if (kernels == Ckernels_W5X3)

	mov	eax, DWORD PTR _kernels$[ebp]
	cmp	eax, 1
	jne	SHORT $LN80@finalize

; 7055 :         {
; 7056 :           if ((!get(Creversible,0,0,reversible,false)) || !reversible)

	push	eax
	push	eax
	push	0
	lea	eax, DWORD PTR _reversible$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN83@finalize
	cmp	BYTE PTR _reversible$[ebp], 0
	jne	$LN273@finalize
$LN83@finalize:

; 7057 :             set(Creversible,0,0,reversible=true);

	mov	BYTE PTR _reversible$[ebp], 1
	push	1

; 7058 :         }

	jmp	SHORT $LN289@finalize
$LN80@finalize:

; 7059 :       else if (kernels == Ckernels_W9X7)

	test	eax, eax
	jne	$LN273@finalize

; 7060 :         {
; 7061 :           if ((!get(Creversible,0,0,reversible,false)) || reversible)

	push	1
	push	1
	push	eax
	lea	eax, DWORD PTR _reversible$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN87@finalize
	cmp	BYTE PTR _reversible$[ebp], 0
	je	$LN273@finalize
$LN87@finalize:

; 7062 :             set(Creversible,0,0,reversible=false);

	mov	BYTE PTR _reversible$[ebp], 0
	push	0
$LN289@finalize:
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 7063 :         }
; 7064 :       else
; 7065 :         assert(0); // Should not be possible

	jmp	$LN273@finalize
$LN76@finalize:

; 7066 :     }
; 7067 :   else if (get(Creversible,0,0,reversible,false) &&

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _reversible$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN273@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _atk_idx$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN89@finalize
	cmp	DWORD PTR _atk_idx$[ebp], 0
	jne	SHORT $LN269@finalize
$LN89@finalize:

; 7068 :            ((!get(Catk,0,0,atk_idx)) || (atk_idx == 0)))
; 7069 :     { // Reversibility explicitly set here, and there is no ATK index
; 7070 :       if ((!get(Ckernels,0,0,kernels)) ||

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _kernels$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	cl, BYTE PTR _reversible$[ebp]
	test	al, al
	je	SHORT $LN91@finalize
	xor	eax, eax
	test	cl, cl
	setne	al
	cmp	DWORD PTR _kernels$[ebp], eax
	je	SHORT $LN273@finalize
$LN91@finalize:

; 7071 :           (kernels != ((reversible)?Ckernels_W5X3:Ckernels_W9X7)))
; 7072 :         set(Ckernels,0,0,kernels=((reversible)?Ckernels_W5X3:Ckernels_W9X7));

	xor	eax, eax
	test	cl, cl
	setne	al
	mov	DWORD PTR _kernels$[ebp], eax
	push	eax
$LN288@finalize:
	push	0
	push	0
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN273@finalize:

; 7073 :     }
; 7074 : 
; 7075 :   // Find reversibility from ATK info if necessary
; 7076 :   if (atk_idx != 0)

	cmp	DWORD PTR _atk_idx$[ebp], 0
	je	$LN95@finalize
$LN269@finalize:

; 7077 :     {
; 7078 :       bool k_rev;
; 7079 :       kdu_params *atk = access_cluster(ATK_params);

	push	OFFSET ??_C@_03IFCLAPBJ@ATK?$AA@
	mov	ecx, esi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 7080 :       if ((atk == NULL) ||
; 7081 :           ((atk = atk->access_relation(tile_idx,-1,atk_idx,true)) == NULL) ||

	test	eax, eax
	je	SHORT $LN94@finalize
	push	1
	push	DWORD PTR _atk_idx$[ebp]
	mov	ecx, eax
	push	-1
	push	DWORD PTR [esi+8]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	test	eax, eax
	je	SHORT $LN94@finalize
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _k_rev$12[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0M@OFOCCDJH@Kreversible?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN93@finalize
$LN94@finalize:

; 7083 :         { KDU_ERROR(e,0x19050502); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$25[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$25[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	OFFSET ??_C@_0KB@HDNIPBLH@Unable?5to?5access?5the?5?$GAKreversibl@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7083 :         { KDU_ERROR(e,0x19050502); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$25[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$25[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _atk_idx$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$32[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$32[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	eax
	mov	eax, DWORD PTR _e$25[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7088 :         }

	lea	ecx, DWORD PTR _e$25[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN93@finalize:

; 7089 :       if ((!get(Creversible,0,0,reversible,false)) || (reversible != k_rev))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _reversible$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	mov	eax, DWORD PTR _k_rev$12[ebp]
	je	SHORT $LN96@finalize
	cmp	BYTE PTR _reversible$[ebp], al
	je	SHORT $LN95@finalize
$LN96@finalize:

; 7090 :         set(Creversible,0,0,reversible=k_rev);

	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	mov	ecx, esi
	mov	BYTE PTR _reversible$[ebp], al
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN95@finalize:

; 7091 :     }
; 7092 : 
; 7093 :   // Install default values for Ckernels and Creversible if necessary
; 7094 :   if ((!get(Creversible,0,0,reversible)) && !after_reading)

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _reversible$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN97@finalize
	test	bl, bl
	jne	SHORT $LN97@finalize

; 7095 :     set(Creversible,0,0,reversible=false);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	mov	ecx, esi
	mov	BYTE PTR _reversible$[ebp], bl
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN97@finalize:

; 7096 :   if ((!get(Ckernels,0,0,kernels)) && !after_reading)

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _kernels$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN98@finalize
	test	bl, bl
	jne	SHORT $LN98@finalize

; 7097 :     set(Ckernels,0,0,kernels=Ckernels_W9X7);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	mov	ecx, esi
	mov	DWORD PTR _kernels$[ebp], 0
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN98@finalize:

; 7098 : 
; 7099 :   // Check for compatibility of Ckernels, Catk, Creversible
; 7100 :   if (atk_idx == 0)

	mov	eax, DWORD PTR _atk_idx$[ebp]
	test	eax, eax
	jne	SHORT $LN99@finalize

; 7101 :     {
; 7102 :       if ((reversible && (kernels != Ckernels_W5X3)) ||

	cmp	BYTE PTR _reversible$[ebp], al
	je	SHORT $LN268@finalize
	cmp	DWORD PTR _kernels$[ebp], 1
	jne	SHORT $LN102@finalize
	jmp	SHORT $LN104@finalize
$LN268@finalize:
	cmp	DWORD PTR _kernels$[ebp], 0
	je	SHORT $LN104@finalize
$LN102@finalize:

; 7103 :           ((!reversible) && (kernels != Ckernels_W9X7)))
; 7104 :         { KDU_ERROR(e,0x19050503); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$24[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0BAO@ECCKKNFO@Illegal?5?$GACkernels?8?5value?5found?5w@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7112 :     }

	jmp	SHORT $LN290@finalize
$LN99@finalize:

; 7113 :   else if ((atk_idx < 2) || (atk_idx > 255))

	cmp	eax, 2
	jl	SHORT $LN105@finalize
	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN104@finalize
$LN105@finalize:

; 7114 :     { KDU_ERROR(e,0x19050504); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$23[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0HE@FAOENAIF@Illegal?5ATK?5instance?5index?5found@
$LN290@finalize:
	mov	eax, DWORD PTR _e$23[ebp]
	lea	ecx, DWORD PTR _e$23[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7118 :     }

	lea	ecx, DWORD PTR _e$23[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN104@finalize:

; 7119 : 
; 7120 :   if (after_reading)

	test	bl, bl
	jne	$LN147@finalize

; 7121 :     return;
; 7122 : 
; 7123 :   // Now we can look at filling out the `Cmct' attribute
; 7124 :   kdu_params *siz = access_cluster(SIZ_params);

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	mov	ecx, esi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 7125 :   int m_components = 0;  siz->get(Mcomponents,0,0,m_components);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _m_components$[ebp]
	mov	DWORD PTR _siz$1$[ebp], eax
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0M@FAIBBHLL@Mcomponents?$AA@
	mov	ecx, eax
	mov	DWORD PTR _m_components$[ebp], 0
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7126 :   int mct_flags = 0; get(Cmct,0,0,mct_flags);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _mct_flags$[ebp]
	mov	DWORD PTR _mct_flags$[ebp], 0
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04OOAAMMCO@Cmct?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7127 :   if ((comp_idx < 0) && !after_reading)

	cmp	DWORD PTR [esi+12], 0
	jge	$LN107@finalize

; 7128 :     {
; 7129 :       mct_flags = 0;
; 7130 :       kdu_params *mco=NULL, *mcc_base=NULL;
; 7131 :       int num_stages = 0;
; 7132 :       if ((m_components > 0) && ((mco = access_cluster(MCO_params)) != NULL) &&
; 7133 :           ((mco = mco->access_relation(tile_idx,-1,0,true)) != NULL) &&
; 7134 :           mco->get(Mnum_stages,0,0,num_stages) && (num_stages > 0) &&

	cmp	DWORD PTR _m_components$[ebp], 0
	mov	DWORD PTR _mct_flags$[ebp], 0
	mov	DWORD PTR _num_stages$10[ebp], 0
	jle	$LN274@finalize
	push	OFFSET ??_C@_03LCPIMAFA@MCO?$AA@
	mov	ecx, esi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	test	eax, eax
	je	$LN274@finalize
	push	1
	push	0
	push	-1
	push	DWORD PTR [esi+8]
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	ebx, eax
	mov	DWORD PTR _mco$2$[ebp], ebx
	test	ebx, ebx
	je	$LN274@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _num_stages$10[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@BMJAMMCN@Mnum_stages?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN274@finalize
	mov	edi, DWORD PTR _num_stages$10[ebp]
	test	edi, edi
	jle	$LN274@finalize
	push	OFFSET ??_C@_03BOENIPFM@MCC?$AA@
	mov	ecx, esi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	DWORD PTR _mcc_base$1$[ebp], eax
	test	eax, eax
	je	$LN274@finalize

; 7135 :           ((mcc_base = access_cluster(MCC_params)) != NULL))
; 7136 :         {
; 7137 :           kdu_params *mcc;
; 7138 :           int inst_idx, stage_idx;
; 7139 :           for (stage_idx=0; stage_idx < num_stages; stage_idx++)

	xor	eax, eax
	mov	DWORD PTR _stage_idx$1$[ebp], eax
	test	edi, edi
	jle	$LN274@finalize
	npad	7
$LL16@finalize:

; 7140 :             if (mco->get(Mstages,stage_idx,0,inst_idx) &&

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _inst_idx$5[ebp]
	push	ecx
	push	0
	push	eax
	push	OFFSET ??_C@_07CNNLMAHC@Mstages?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN14@finalize
	mov	ecx, DWORD PTR _mcc_base$1$[ebp]
	push	1
	push	DWORD PTR _inst_idx$5[ebp]
	push	-1
	push	DWORD PTR [esi+8]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $LN282@finalize

; 7141 :                 ((mcc = mcc_base->access_relation(tile_idx,-1,inst_idx,
; 7142 :                                                   true)) != NULL))
; 7143 :               {
; 7144 :                 int block_idx, xform_type;
; 7145 :                 for (block_idx=0;

	xor	edi, edi

; 7146 :                      mcc->get(Mstage_xforms,block_idx,0,

	lea	eax, DWORD PTR _xform_type$8[ebp]
	push	edi
	push	edi
	push	1
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN282@finalize
$LL19@finalize:

; 7149 :                   {
; 7150 :                     if ((block_idx == Mxform_DEP) ||

	test	edi, edi
	je	SHORT $LN112@finalize
	cmp	edi, 9
	je	SHORT $LN112@finalize

; 7153 :                     else if (block_idx == Mxform_DWT)

	cmp	edi, 3
	jne	SHORT $LN17@finalize

; 7154 :                       mct_flags |= Cmct_DWT;

	or	DWORD PTR _mct_flags$[ebp], 4
	jmp	SHORT $LN17@finalize
$LN112@finalize:

; 7151 :                         (block_idx == Mxform_MATRIX))
; 7152 :                       mct_flags |= Cmct_ARRAY;

	or	DWORD PTR _mct_flags$[ebp], 2
$LN17@finalize:

; 7146 :                      mcc->get(Mstage_xforms,block_idx,0,

	push	0
	push	0
	push	1
	lea	eax, DWORD PTR _xform_type$8[ebp]

; 7147 :                               xform_type,true,false,false);
; 7148 :                      block_idx++)

	inc	edi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL19@finalize
$LN282@finalize:
	mov	ebx, DWORD PTR _mco$2$[ebp]
$LN14@finalize:

; 7135 :           ((mcc_base = access_cluster(MCC_params)) != NULL))
; 7136 :         {
; 7137 :           kdu_params *mcc;
; 7138 :           int inst_idx, stage_idx;
; 7139 :           for (stage_idx=0; stage_idx < num_stages; stage_idx++)

	mov	eax, DWORD PTR _stage_idx$1$[ebp]
	inc	eax
	mov	DWORD PTR _stage_idx$1$[ebp], eax
	cmp	eax, DWORD PTR _num_stages$10[ebp]
	jl	$LL16@finalize
$LN274@finalize:

; 7155 :                   }
; 7156 :               }
; 7157 :         }
; 7158 :       set(Cmct,0,0,mct_flags);

	push	DWORD PTR _mct_flags$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_04OOAAMMCO@Cmct?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN107@finalize:

; 7159 :     }
; 7160 :   bool use_ycc;
; 7161 :   if (!get(Cycc,0,0,use_ycc))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _use_ycc$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04DEPIIIHA@Cycc?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	$LN114@finalize

; 7162 :     { // Determine the default, based on component compatibility
; 7163 :       assert(comp_idx < 0);
; 7164 :       int components = get_num_comps();
; 7165 :       use_ycc = false; // No transform unless the following conditions are met
; 7166 :       if ((components >= 3) && (m_components == 0))

	cmp	DWORD PTR [esi+24], 3
	mov	BYTE PTR _use_ycc$[ebp], al
	jl	$LN122@finalize
	cmp	DWORD PTR _m_components$[ebp], 0
	jne	$LN122@finalize

; 7167 :         {
; 7168 :           int precision, last_precision;
; 7169 :           bool rev, last_rev;
; 7170 :           int sub_x, last_sub_x, sub_y, last_sub_y, c;
; 7171 :           assert(siz != NULL);
; 7172 :           for (c=0; c < 3; c++, last_rev=rev, last_precision=precision,

	mov	bh, BYTE PTR _last_rev$15[ebp]
	xor	edi, edi
	npad	1
$LL22@finalize:

; 7174 :             {
; 7175 :               kdu_params *coc = access_relation(tile_idx,c,0,true);

	push	1
	push	0
	push	edi
	push	DWORD PTR [esi+8]
	mov	ecx, esi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 7176 :               if (!(coc->get(Creversible,0,0,rev) &&

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _rev$14[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN117@finalize
	mov	ecx, DWORD PTR _siz$1$[ebp]
	lea	eax, DWORD PTR _precision$7[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0L@BADPNFGK@Sprecision?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN117@finalize
	mov	ecx, DWORD PTR _siz$1$[ebp]
	lea	eax, DWORD PTR _sub_y$4[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN117@finalize
	mov	ecx, DWORD PTR _siz$1$[ebp]
	lea	eax, DWORD PTR _sub_x$3[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN117@finalize:

; 7177 :                   siz->get(Sprecision,c,0,precision) &&
; 7178 :                   siz->get(Ssampling,c,0,sub_y) &&
; 7179 :                   siz->get(Ssampling,c,1,sub_x)))
; 7180 :                 assert(0);
; 7181 :               if (c == 0)

	mov	bl, BYTE PTR _rev$14[ebp]
	mov	edx, DWORD PTR _precision$7[ebp]
	mov	ecx, DWORD PTR _sub_x$3[ebp]
	mov	eax, DWORD PTR _sub_y$4[ebp]
	test	edi, edi
	je	SHORT $LN20@finalize

; 7182 :                 {
; 7183 :                   last_rev = rev; last_precision = precision;
; 7184 :                   last_sub_x = sub_x; last_sub_y = sub_y;
; 7185 :                 }
; 7186 :               else if ((rev != last_rev) || (precision != last_precision) ||
; 7187 :                        (sub_x != last_sub_x) || (sub_y != last_sub_y))

	cmp	bl, bh
	jne	SHORT $LN240@finalize
	cmp	edx, DWORD PTR _last_precision$13[ebp]
	jne	SHORT $LN240@finalize
	cmp	ecx, DWORD PTR _last_sub_x$9[ebp]
	jne	SHORT $LN240@finalize
	cmp	eax, DWORD PTR _last_sub_y$11[ebp]
	jne	SHORT $LN240@finalize
$LN20@finalize:

; 7173 :                last_sub_x=sub_x, last_sub_y=sub_y)

	inc	edi
	mov	DWORD PTR _last_precision$13[ebp], edx
	mov	DWORD PTR _last_sub_x$9[ebp], ecx
	mov	bh, bl
	mov	DWORD PTR _last_sub_y$11[ebp], eax
	cmp	edi, 3
	jl	$LL22@finalize
$LN240@finalize:

; 7188 :                 break;
; 7189 :             }
; 7190 :           if (c == 3)

	movzx	eax, BYTE PTR _use_ycc$[ebp]
	cmp	edi, 3
	mov	ecx, 1
	cmove	eax, ecx
	mov	BYTE PTR _use_ycc$[ebp], al
$LN122@finalize:

; 7191 :             use_ycc = true; // All conditions satisfied for component transform
; 7192 :         }
; 7193 :       set(Cycc,0,0,use_ycc);

	push	DWORD PTR _use_ycc$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_04DEPIIIHA@Cycc?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN114@finalize:

; 7194 :     }
; 7195 :   if (use_ycc && (this->get_num_comps() < 3))

	mov	al, BYTE PTR _use_ycc$[ebp]
	test	al, al
	je	SHORT $LN124@finalize
	cmp	DWORD PTR [esi+24], 3
	jge	SHORT $LN123@finalize

; 7196 :     set(Cycc,0,0,false);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04DEPIIIHA@Cycc?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
	mov	al, BYTE PTR _use_ycc$[ebp]
$LN123@finalize:

; 7197 :   if (use_ycc && (m_components != 0))

	test	al, al
	je	SHORT $LN124@finalize
	cmp	DWORD PTR _m_components$[ebp], 0
	je	SHORT $LN124@finalize

; 7198 :     set(Cycc,0,0,false);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04DEPIIIHA@Cycc?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN124@finalize:

; 7199 : 
; 7200 :   // Finally, consider code-blocks, precincts and the Digital Cinema profiles
; 7201 :   int profile = 0;  siz->get(Sprofile,0,0,profile);

	mov	ecx, DWORD PTR _siz$1$[ebp]
	lea	eax, DWORD PTR _profile$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	mov	DWORD PTR _profile$[ebp], 0
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7202 :   bool dcinema = (profile==Sprofile_CINEMA2K) || (profile==Sprofile_CINEMA4K);

	mov	eax, DWORD PTR _profile$[ebp]
	cmp	eax, 4
	je	SHORT $LN149@finalize
	cmp	eax, 5
	je	SHORT $LN149@finalize
	xor	bl, bl
	jmp	SHORT $LN150@finalize
$LN149@finalize:
	mov	bl, 1
$LN150@finalize:

; 7204 :   if (!(get(Cblk,0,0,blk_size.y) && get(Cblk,0,1,blk_size.x)))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _blk_size$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _blk_size$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7204 :   if (!(get(Cblk,0,0,blk_size.y) && get(Cblk,0,1,blk_size.x)))

	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	mov	ecx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _blk_size$[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7204 :   if (!(get(Cblk,0,0,blk_size.y) && get(Cblk,0,1,blk_size.x)))

	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN126@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _blk_size$[ebp+4]
	mov	ecx, esi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN125@finalize
$LN126@finalize:

; 7205 :     {
; 7206 :       blk_size.x = blk_size.y = (dcinema)?32:64;

	mov	ecx, 32					; 00000020H
	test	bl, bl
	mov	eax, 64					; 00000040H
	cmovne	eax, ecx

; 7207 :       set(Cblk,0,0,blk_size.y);  set(Cblk,0,1,blk_size.x);

	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	mov	DWORD PTR _blk_size$[ebp], eax
	mov	DWORD PTR _blk_size$[ebp+4], eax
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _blk_size$[ebp+4]
	mov	ecx, esi
	push	1
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN125@finalize:

; 7208 :     }
; 7209 :   int modes;
; 7210 :   if (!get(Cmodes,0,0,modes))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _modes$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06EGDCPANH@Cmodes?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN127@finalize

; 7211 :     set(Cmodes,0,0,modes=0);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_06EGDCPANH@Cmodes?$AA@
	mov	ecx, esi
	mov	DWORD PTR _modes$[ebp], 0
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN127@finalize:

; 7212 :   int progression_order;
; 7213 :   if (!get(Corder,0,0,progression_order))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _progression_order$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06IKJBDDKO@Corder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN128@finalize

; 7214 :     {
; 7215 :       progression_order = (dcinema)?Corder_CPRL:Corder_LRCP;

	xor	eax, eax
	mov	ecx, 4
	test	bl, bl
	cmovne	eax, ecx

; 7216 :       set(Corder,0,0,progression_order);

	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06IKJBDDKO@Corder?$AA@
	mov	DWORD PTR _progression_order$[ebp], eax
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN128@finalize:

; 7217 :     }
; 7218 :   int dwt_levels;
; 7219 :   get(Clevels,0,0,dwt_levels);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _dwt_levels$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7220 :   
; 7221 :   if (get(Cprecincts,0,0,val,false,false))

	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN24@finalize

; 7222 :     { // Precinct dimensions explicitly set for this tile-component.
; 7223 :       set(Cuse_precincts,0,0,true);
; 7224 :     }
; 7225 :   else if (dcinema)

	test	bl, bl
	je	$LN131@finalize

; 7226 :     { // Force the use of digital cinema precincts
; 7227 :       for (int lev=0; lev <= dwt_levels; lev++)

	mov	ecx, DWORD PTR _dwt_levels$[ebp]
	xor	edi, edi
	test	ecx, ecx
	js	SHORT $LN24@finalize
	mov	edx, 128				; 00000080H
$LL25@finalize:

; 7228 :         {
; 7229 :           set(Cprecincts,lev,0,(lev==dwt_levels)?128:256);

	cmp	edi, ecx
	mov	eax, 256				; 00000100H
	mov	ecx, esi
	cmove	eax, edx
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 7230 :           set(Cprecincts,lev,1,(lev==dwt_levels)?128:256);

	cmp	edi, DWORD PTR _dwt_levels$[ebp]
	mov	ecx, 128				; 00000080H
	mov	eax, 256				; 00000100H
	cmove	eax, ecx
	mov	ecx, esi
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	ecx, DWORD PTR _dwt_levels$[ebp]
	inc	edi
	mov	edx, 128				; 00000080H
	cmp	edi, ecx
	jle	SHORT $LL25@finalize
$LN24@finalize:

; 7231 :         }
; 7232 :       set(Cuse_precincts,0,0,true);

	push	1
	push	0
	push	0
	push	OFFSET ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 7236 :   
; 7237 :   if (dcinema)

	test	bl, bl
	je	$LN275@finalize

; 7238 :     {
; 7239 :       get(Clayers,0,0,val);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BJCMAMHC@Clayers?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7240 :       if (val != 1)

	cmp	DWORD PTR _val$[ebp], 1
	je	SHORT $LN135@finalize

; 7241 :         { KDU_WARNING(w,0x11110801); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$22[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$22[ebp]
	lea	ecx, DWORD PTR _w$22[ebp]
	push	OFFSET ??_C@_0BBC@GFMDHLNB@Profile?5violation?5detected?4?5?5The@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7241 :         { KDU_WARNING(w,0x11110801); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7248 :         }

	lea	ecx, DWORD PTR _w$22[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN135@finalize:

; 7249 :       if ((blk_size.x != 32) || (blk_size.y != 32))

	cmp	DWORD PTR _blk_size$[ebp+4], 32		; 00000020H
	jne	SHORT $LN137@finalize
	cmp	DWORD PTR _blk_size$[ebp], 32		; 00000020H
	je	SHORT $LN136@finalize
$LN137@finalize:

; 7250 :         { KDU_ERROR(e,0x11110802); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$21[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$21[ebp]
	lea	ecx, DWORD PTR _e$21[ebp]
	push	OFFSET ??_C@_0KF@NKKOHPBE@Profile?5violation?5detected?4?5?5The@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7250 :         { KDU_ERROR(e,0x11110802); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7255 :         }

	lea	ecx, DWORD PTR _e$21[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN136@finalize:

; 7256 :       if (modes != 0)

	cmp	DWORD PTR _modes$[ebp], 0
	je	SHORT $LN138@finalize

; 7257 :         { KDU_ERROR(e,0x11110805); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$20[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$20[ebp]
	lea	ecx, DWORD PTR _e$20[ebp]
	push	OFFSET ??_C@_0IK@BEGMJOLL@Profile?5violation?5detected?4?5?5Req@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7257 :         { KDU_ERROR(e,0x11110805); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 9
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7261 :         }

	lea	ecx, DWORD PTR _e$20[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN138@finalize:

; 7262 :       for (int lev=0; lev <= dwt_levels; lev++)

	xor	edi, edi
	cmp	DWORD PTR _dwt_levels$[ebp], edi
	jl	$LN27@finalize
$LL28@finalize:

; 7265 :           get(Cprecincts,lev,0,precinct_siz.y);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _precinct_siz$6[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _precinct_siz$6[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7265 :           get(Cprecincts,lev,0,precinct_siz.y);

	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	mov	ecx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _precinct_siz$6[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7265 :           get(Cprecincts,lev,0,precinct_siz.y);

	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 7266 :           get(Cprecincts,lev,1,precinct_siz.x);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _precinct_siz$6[ebp+4]
	mov	ecx, esi
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 210  :     kdu_coords(int x, int y) {this->x=x; this->y=y; }

	mov	ecx, 128				; 00000080H
	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7268 :           if (lev < dwt_levels)

	cmp	edi, DWORD PTR _dwt_levels$[ebp]
	jge	SHORT $LN139@finalize

; 7269 :             reqd_siz.x = reqd_siz.y = 256;

	mov	eax, 256				; 00000100H
	mov	ecx, eax
$LN139@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }

	cmp	DWORD PTR _precinct_siz$6[ebp+4], ecx
	jne	SHORT $LN210@finalize
	cmp	DWORD PTR _precinct_siz$6[ebp], eax
	jne	SHORT $LN210@finalize
	xor	eax, eax
	jmp	SHORT $LN211@finalize
$LN210@finalize:
	mov	eax, 1
$LN211@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7270 :           if (precinct_siz != reqd_siz)

	test	al, al
	je	SHORT $LN26@finalize

; 7271 :             { KDU_ERROR(e,0x11110806); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$19[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$19[ebp]
	lea	ecx, DWORD PTR _e$19[ebp]
	push	OFFSET ??_C@_0OO@FGOLANDB@Profile?5violation?5detected?4?5?5Req@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7271 :             { KDU_ERROR(e,0x11110806); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7277 :             }

	lea	ecx, DWORD PTR _e$19[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN26@finalize:

; 7262 :       for (int lev=0; lev <= dwt_levels; lev++)

	inc	edi
	cmp	edi, DWORD PTR _dwt_levels$[ebp]
	jle	$LL28@finalize
$LN27@finalize:

; 7278 :         }
; 7279 :       if ((this->comp_idx < 0) && !get(Creslengths,0,0,val))

	cmp	DWORD PTR [esi+12], 0
	jge	$LN275@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@HKNEBDCB@Creslengths?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN275@finalize

; 7280 :         { KDU_WARNING(w,0x11110820); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$18[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$18[ebp]
	lea	ecx, DWORD PTR _w$18[ebp]
	push	OFFSET ??_C@_0DGO@NKGPBPEP@Profile?5violation?5may?5occur?5with@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7280 :         { KDU_WARNING(w,0x11110820); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7299 :         }

	lea	ecx, DWORD PTR _w$18[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
	jmp	SHORT $LN275@finalize
$LN131@finalize:

; 7233 :     }
; 7234 :   else if (!get(Cuse_precincts,0,0,bval))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _bval$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN275@finalize

; 7235 :     set(Cuse_precincts,0,0,false); // Default is not to use precincts.

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN275@finalize:

; 7300 :     }
; 7301 :   if (profile == Sprofile_CINEMA2K)

	mov	eax, DWORD PTR _profile$[ebp]
	cmp	eax, 4
	jne	$LN142@finalize

; 7302 :     {
; 7303 :       if (dwt_levels > 5)

	cmp	DWORD PTR _dwt_levels$[ebp], 5
	jle	SHORT $LN144@finalize

; 7304 :         { KDU_ERROR(e,0x11110803); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$17[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$17[ebp]
	lea	ecx, DWORD PTR _e$17[ebp]
	push	OFFSET ??_C@_0HC@OGIJFNLO@Profile?5violation?5detected?4?5?5The@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7304 :         { KDU_ERROR(e,0x11110803); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$17[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _val$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$31[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$31[ebp]
	lea	ecx, DWORD PTR _e$17[ebp]
	push	eax
	mov	eax, DWORD PTR _e$17[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$17[ebp]
	lea	ecx, DWORD PTR _e$17[ebp]
	push	OFFSET ??_C@_0BB@NIPBGPHB@?5levels?0?5though?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7308 :         }

	lea	ecx, DWORD PTR _e$17[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN144@finalize:

; 7309 :       if (progression_order != Corder_CPRL)

	cmp	DWORD PTR _progression_order$[ebp], 4
	je	$LN147@finalize

; 7310 :         { KDU_ERROR(e,0x1111081a); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$16[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	OFFSET ??_C@_0FM@FEAHACJA@Profile?5violation?5detected?4?5?5The@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7310 :         { KDU_ERROR(e,0x1111081a); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7313 :         }

	lea	ecx, DWORD PTR _e$16[ebp]

; 7314 :     }

	jmp	$LN291@finalize
$LN142@finalize:

; 7315 :   else if (profile == Sprofile_CINEMA4K)

	cmp	eax, 5
	jne	$LN147@finalize

; 7316 :     {
; 7317 :       if (dwt_levels > 6)

	cmp	DWORD PTR _dwt_levels$[ebp], 6
	jle	$LN147@finalize

; 7318 :         { KDU_ERROR(e,0x11110804); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0HC@MIEFLBEH@Profile?5violation?5detected?4?5?5The@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7318 :         { KDU_ERROR(e,0x11110804); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$2[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _val$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$30[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$30[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	eax
	mov	eax, DWORD PTR _e$2[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BB@NIPBGPHB@?5levels?0?5though?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 7322 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
$LN291@finalize:
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN147@finalize:

; 7323 :     }                  
; 7324 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$0:
	lea	ecx, DWORD PTR _e$29[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$1:
	lea	ecx, DWORD PTR _e$28[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$2:
	lea	ecx, DWORD PTR _e$27[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$3:
	lea	ecx, DWORD PTR _e$26[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$4:
	lea	ecx, DWORD PTR _e$25[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$5:
	lea	ecx, DWORD PTR _e$24[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$6:
	lea	ecx, DWORD PTR _e$23[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$7:
	lea	ecx, DWORD PTR _w$22[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$8:
	lea	ecx, DWORD PTR _e$21[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$9:
	lea	ecx, DWORD PTR _e$20[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$10:
	lea	ecx, DWORD PTR _e$19[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$11:
	lea	ecx, DWORD PTR _w$18[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$12:
	lea	ecx, DWORD PTR _e$17[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$13:
	lea	ecx, DWORD PTR _e$16[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@cod_params@@MAEX_N@Z$14:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?finalize@cod_params@@MAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?finalize@cod_params@@MAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?finalize@cod_params@@MAEX_N@Z ENDP			; cod_params::finalize
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?new_object@cod_params@@MAEPAVkdu_params@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_object@cod_params@@MAEPAVkdu_params@@XZ PROC	; cod_params::new_object, COMDAT
; _this$ = ecx

; 2961 :     virtual kdu_params *new_object() { return new cod_params; }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_object@cod_params@@MAEPAVkdu_params@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_object
	mov	ecx, eax
	call	??0cod_params@@QAE@XZ			; cod_params::cod_params
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_object:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_object@cod_params@@MAEPAVkdu_params@@XZ$0:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?new_object@cod_params@@MAEPAVkdu_params@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_object@cod_params@@MAEPAVkdu_params@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_object@cod_params@@MAEPAVkdu_params@@XZ ENDP	; cod_params::new_object
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0cod_params@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0cod_params@@QAE@XZ PROC				; cod_params::cod_params, COMDAT
; _this$ = ecx

; 5997 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0cod_params@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 5996 :   : kdu_params(COD_params,true,true,false)

	push	0
	push	0
	push	0
	push	1
	push	1
	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	call	??0kdu_params@@QAE@PBD_N1111@Z		; kdu_params::kdu_params

; 5998 :   add_dependency(QCD_params);

	push	OFFSET ??_C@_03ELMDPBLM@QCD?$AA@
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7cod_params@@6B@
	call	?add_dependency@kdu_params@@IAEXPBD@Z	; kdu_params::add_dependency

; 5999 :   define_attribute(Cycc,

	push	4
	push	OFFSET ??_C@_01HMGJMAIH@B?$AA@
	push	OFFSET ??_C@_0KP@IBLLLJAN@RGB?5to?5Luminance?9Chrominance?5con@
	push	OFFSET ??_C@_04DEPIIIHA@Cycc?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6000 :                    "RGB to Luminance-Chrominance conversion?\n"
; 6001 :                    "\t\t[Default is to convert images with 3 or more "
; 6002 :                    "components, unless a Part 2 multi-component transform "
; 6003 :                    "is defined -- `Mcomponents' > 0]",
; 6004 :                    "B",ALL_COMPONENTS);
; 6005 :   define_attribute(Cmct,

	push	4
	push	OFFSET ??_C@_0BA@NBBPEJNG@?$FLARRAY?$DN2?$HMDWT?$DN4?$FN?$AA@
	push	OFFSET ??_C@_0FCM@DHPAPCJF@This?5parameter?5should?5be?50?5unles@
	push	OFFSET ??_C@_04OOAAMMCO@Cmct?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6006 :     "This parameter should be 0 unless a Part 2 multi-component transform "
; 6007 :     "is being used, in which case it contains one or both of the "
; 6008 :     "`ARRAY' and `DWT' options -- if both options are present, they are "
; 6009 :     "separated by a `|'.  The `ARRAY' option will be present if and only "
; 6010 :     "if an array-based multi-component transform block is associated with "
; 6011 :     "the image, or the relevant tile (for tile-specific instances of the "
; 6012 :     "attribute).  The `DWT' option will be present if and only if a DWT-based "
; 6013 :     "multi-component transform block is associated with the image, or the "
; 6014 :     "relevant tile (for tile-specific instances of the COD marker segment).  "
; 6015 :     "Both flags will be present if both types of multi-component transform "
; 6016 :     "block are employed for the image or tile, as appropriate.  During "
; 6017 :     "codestream generation, the information in this parameter is generated "
; 6018 :     "automatically to conform with the information provided via the `Mstages' "
; 6019 :     "and `Mstage_xforms' attributes.  "
; 6020 :     "When reading an existing codestream, the information in this parameter "
; 6021 :     "should either be correct or 0.  In the latter case, the internal "
; 6022 :     "machinery interprets the codestream as one generated by versions of "
; 6023 :     "Kakadu prior to v6.0, wherein the transform coefficients for "
; 6024 :     "reversible matrix-based transforms were accidentally transposed -- the "
; 6025 :     "transposition error is corrected automatically in this case.",
; 6026 :                    "[ARRAY=2|DWT=4]",ALL_COMPONENTS);
; 6027 :   define_attribute(Clayers,

	push	4
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0EB@BJCCPLJM@Number?5of?5quality?5layers?4?5May?5no@
	push	OFFSET ??_C@_07BJCMAMHC@Clayers?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6028 :                    "Number of quality layers. May not exceed 16384.\n"
; 6029 :                    "\t\t[Default is 1]",
; 6030 :                    "I",ALL_COMPONENTS);
; 6031 :   define_attribute(Cuse_sop,

	push	4
	push	OFFSET ??_C@_01HMGJMAIH@B?$AA@
	push	OFFSET ??_C@_0EK@NKHIFEB@Include?5SOP?5markers?5?$CIi?4e?4?0?5resyn@
	push	OFFSET ??_C@_08DAJNLNLL@Cuse_sop?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6032 :                    "Include SOP markers (i.e., resync markers)?\n"
; 6033 :                    "\t\t[Default is no SOP markers]",
; 6034 :                    "B",ALL_COMPONENTS);
; 6035 :   define_attribute(Cuse_eph,

	push	4
	push	OFFSET ??_C@_01HMGJMAIH@B?$AA@
	push	OFFSET ??_C@_0FG@HPJEBCAG@Include?5EPH?5markers?5?$CImarker?5end?5@
	push	OFFSET ??_C@_08NAIOMJOM@Cuse_eph?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6036 :                    "Include EPH markers (marker end of each packet header)?\n"
; 6037 :                    "\t\t[Default is no EPH markers]",
; 6038 :                    "B",ALL_COMPONENTS);
; 6039 :   define_attribute(Corder,

	push	4
	push	OFFSET ??_C@_0CF@FILGKLGM@?$CILRCP?$DN0?0RLCP?$DN1?0RPCL?$DN2?0PCRL?$DN3?0CPR@
	push	OFFSET ??_C@_0BFK@PBIMDDLA@Default?5progression?5order?5?$CImay?5b@
	push	OFFSET ??_C@_06IKJBDDKO@Corder?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6040 :                    "Default progression order (may be overridden by "
; 6041 :                    "Porder).  The four character identifiers have the "
; 6042 :                    "following interpretation: L=layer; R=resolution; "
; 6043 :                    "C=component; P=position. The first character in the "
; 6044 :                    "identifier refers to the index which progresses most "
; 6045 :                    "slowly, while the last refers to the index which "
; 6046 :                    "progresses most quickly.\n"
; 6047 :                    "\t\t[Default is LRCP]",
; 6048 :                    "(LRCP=0,RLCP=1,RPCL=2,PCRL=3,CPRL=4)",ALL_COMPONENTS);
; 6049 :   define_attribute(Calign_blk_last,

	push	4
	push	OFFSET ??_C@_02LBOPFCME@BB?$AA@
	push	OFFSET ??_C@_0CAO@IFLBKBBI@If?5?$CCyes?$CC?0?5the?5code?9block?5partiti@
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6050 :                    "If \"yes\", the code-block partition is aligned so that "
; 6051 :                    "the last sample in each nominal block (ignoring the "
; 6052 :                    "effect of boundaries) is aligned at a multiple of "
; 6053 :                    "the block dimension (a power of 2).  Equivalently, the "
; 6054 :                    "first sample in each nominal block lies at a location "
; 6055 :                    "which is a multiple of the block dimension, plus 1. By "
; 6056 :                    "default (i.e., \"no\"), the first sample of each block is "
; 6057 :                    "aligned at a multiple of the block dimension. The "
; 6058 :                    "alignment is specified separately for both dimensions, "
; 6059 :                    "with the vertical dimension specified first.",
; 6060 :                    "BB",ALL_COMPONENTS);
; 6061 :   define_attribute(Clevels,

	push	0
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0FI@ILBHKDEJ@Number?5of?5wavelet?5decomposition?5@
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6062 :                    "Number of wavelet decomposition levels, or stages.  May "
; 6063 :                    "not exceed 32.\n"
; 6064 :                    "\t\t[Default is 5]",
; 6065 :                    "I");
; 6066 :   define_attribute(Cads,

	push	0
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0DCE@BCLFNHJE@Index?5of?5the?5ADS?5marker?5segment?5@
	push	OFFSET ??_C@_04OONIPDNE@Cads?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6067 :                    "Index of the ADS marker segment used to hold Arbitrary "
; 6068 :                    "Downsampling Style information.  If ADS information is "
; 6069 :                    "involved, the value of the `Cads' index must lie in the "
; 6070 :                    "range 1 to 127.  A value of 0 means that no ADS marker "
; 6071 :                    "segment is referenced.  You will not normally set this "
; 6072 :                    "parameter yourself.  It is preferable to allow the "
; 6073 :                    "internal machinery to find a suitable index.  In any "
; 6074 :                    "event, the ADS information recorded in the `DOads' and "
; 6075 :                    "`DSads' attributes will be generated automatically from "
; 6076 :                    "information contained in `Cdecomp'.  During marker "
; 6077 :                    "segment reading, the ADS information is used together "
; 6078 :                    "with any DFS information (see `Cdfs') in order to "
; 6079 :                    "reconstruct the `Cdecomp' attribute.\n"
; 6080 :                    "\t\t[Best not to set this yourself.  An index is selected "
; 6081 :                    "automatically if `Cdecomp' defines a non-trivial "
; 6082 :                    "decomposition.]",
; 6083 :                    "I");
; 6084 :   define_attribute(Cdfs,

	push	0
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0DIF@JIOHBMHM@Index?5of?5the?5DFS?5marker?5segment?5@
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6085 :                    "Index of the DFS marker segment used to hold Downsampling "
; 6086 :                    "Factor Style information.  If DFS information is "
; 6087 :                    "involved, the value of the `Cdfs' index must be in the "
; 6088 :                    "range 1 to 127.  A value of 0 means that no DFS marker "
; 6089 :                    "segment is referenced.  This attribute is ignored "
; 6090 :                    "outside of the main header (i.e., for non-negative tile "
; 6091 :                    "indices).  You will not normally set this parameter "
; 6092 :                    "yourself.  Rather, it is preferable to allow the "
; 6093 :                    "internal machinery to find a suitable index for you.  "
; 6094 :                    "In any event, the DFS instructions recorded in the "
; 6095 :                    "`DSdfs' attribute will be generated automatically "
; 6096 :                    "from information contained in `Cdecomp'.  During "
; 6097 :                    "marker segment reading, the DFS instructions will be "
; 6098 :                    "read, along with any ADS information (see `Cads') in "
; 6099 :                    "order to reconstruct the `Cdecomp' attribute.\n"
; 6100 :                    "\t\t[Best not to set this yourself.  An index is selected "
; 6101 :                    "automatically if `Cdecomp' defines a non-trivial "
; 6102 :                    "decomposition.]",
; 6103 :                    "I");
; 6104 :   define_attribute(Cdecomp,

	push	3
	push	OFFSET ??_C@_01GFHCPBMG@C?$AA@
	push	OFFSET ??_C@_0MDH@GKKAPHJL@Manages?5the?5information?5associat@
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6105 :                    "Manages the information associated with the JPEG2000 "
; 6106 :                    "Part-2 `ADS' and `DFS' marker segments, if any, as "
; 6107 :                    "referenced by the `Cads' and `Cdfs' attributes.  If "
; 6108 :                    "neither of these is present, the default value of 3 "
; 6109 :                    "is used, which yields the conventional Mallat "
; 6110 :                    "decomposition structure.  Each record describes the "
; 6111 :                    "subband splitting processes for one entire DWT level, "
; 6112 :                    "starting from the first (highest frequency) level.  "
; 6113 :                    "The textual form of each record commences with a "
; 6114 :                    "primary splitting code, which is one of the "
; 6115 :                    "characters: `B' (split both ways a la Mallat); `H' "
; 6116 :                    "(split only horizontally); `V' (split only vertically); "
; 6117 :                    "or `-' (do not split at all -- degenerate case).  The "
; 6118 :                    "first option produces three primary detail subbands, "
; 6119 :                    "denoted HL, LH and HH.  The second and third options "
; 6120 :                    "produce only one primary detail subband (HX or XH), "
; 6121 :                    "while the last option produces no detail subbands at "
; 6122 :                    "all.  The primary splitting code is followed by "
; 6123 :                    "parentheses, containing 0, 1 or 3 colon-separated "
; 6124 :                    "sub-strings, each of which describes the additional "
; 6125 :                    "splitting operations to be applied to each primary "
; 6126 :                    "detail subband.  Each sub-string consists of 1, 3 or 5 "
; 6127 :                    "characters, drawn from `-' (meaning no-split), `H' "
; 6128 :                    "(meaning a horizontal split), `V' (meaning a vertical "
; 6129 :                    "split) and `B' (meaning a bi-directional split).  If the "
; 6130 :                    "sub-string commences with `H' or `V', two additional "
; 6131 :                    "characters may be provided to describe further splitting "
; 6132 :                    "of the low- and high-pass subbands produced by the "
; 6133 :                    "first split.  If the sub-string commences with `B', "
; 6134 :                    "four additional characters may be provided to describe "
; 6135 :                    "further splitting of the LL, HL, LH and HH "
; 6136 :                    "subbands produced by the primary split.  Alternatively, "
; 6137 :                    "the sub-string may consist only of the initial character, "
; 6138 :                    "in which case no further splitting is involved.  Thus, "
; 6139 :                    "\"B\" and \"B----\" are equivalent sub-strings, as are "
; 6140 :                    "\"H\" and \"H--\".\n"
; 6141 :                    "\t   If insufficient parameters are supplied to "
; 6142 :                    "accommodate the number of desired DWT levels, the final "
; 6143 :                    "value is simply replicated.  Note, however, that the "
; 6144 :                    "last value must conform to some specific rules, "
; 6145 :                    "which derive from the way in which JPEG2000 Part-2 "
; 6146 :                    "defines extrapolation for information found in the ADS "
; 6147 :                    "and DFS marker segments.  In particular, the terminal "
; 6148 :                    "parameter must have identical splitting descriptors for "
; 6149 :                    "all primary detail subbands (remember there are 0, 1 or "
; 6150 :                    "3 of these).  Moreover, within each of these "
; 6151 :                    "descriptors, all splitting codes (`-', `H', 'V' and 'B') "
; 6152 :                    "must be identical.  The only exception to this occurs "
; 6153 :                    "where all primary detail subbands are split only once, "
; 6154 :                    "in which case all primary detail subbands must have "
; 6155 :                    "identical sub-strings holding one of the patterns, "
; 6156 :                    "\"B----\", \"H--\", \"V--\" or \"-\".  Thus, "
; 6157 :                    "\"B(-:-:-)\", \"H(BBBBB)\", \"B(HHH:HHH:HHH)\", "
; 6158 :                    "\"V(H--)\" and \"B(V--:V--:V--)\" are all legal "
; 6159 :                    "terminal values, while \"B(B:B:-)\" and \"V(VV-)\" are "
; 6160 :                    "not legal.\n"
; 6161 :                    "\t\t[If `Cdecomp' is not specified, a value is determined "
; 6162 :                    "from the ADS and/or DFS information referenced by "
; 6163 :                    "`Cads' and `Cdfs'.  If there is no such information, the "
; 6164 :                    "default `Cdecomp' value is \"B(-,-,-)\", which translates "
; 6165 :                    "to the integer value, 3.  All Part-1 codestreams must "
; 6166 :                    "use this Mallat decomposition style.]",
; 6167 :                    "C", MULTI_RECORD | CAN_EXTRAPOLATE);
; 6168 :   define_attribute(Creversible,

	push	0
	push	OFFSET ??_C@_01HMGJMAIH@B?$AA@
	push	OFFSET ??_C@_0JI@BJEOBCA@Reversible?5compression?$DP?6?7?7?$FLDefau@
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6169 :                    "Reversible compression?\n"
; 6170 :                    "\t\t[Default is irreversible, if `Ckernels' and "
; 6171 :                    "`Catk' are not used.  Otherwise, the reversibility is "
; 6172 :                    "derived from those values.]",
; 6173 :                    "B");
; 6174 :   define_attribute(Ckernels,

	push	0
	push	OFFSET ??_C@_0BH@OGDGPMGJ@?$CIW9X7?$DN0?0W5X3?$DN1?0ATK?$DN?91?$CJ?$AA@
	push	OFFSET ??_C@_0BDE@IGHHDMOK@Wavelet?5kernels?5to?5use?4?5?5The?5spe@
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6175 :                    "Wavelet kernels to use.  The special value, `ATK' "
; 6176 :                    "means that an ATK (Arbitrary Transform Kernel) marker "
; 6177 :                    "segment is used to store the DWT kernel.  In this case, "
; 6178 :                    "the `Catk' attribute must be non-zero.\n"
; 6179 :                    "\t\t[Default is W5X3 if `Creversible' is true, "
; 6180 :                    "W9X7 if `Creversible' is false, and ATK if "
; 6181 :                    "`Catk' is non-zero.]",
; 6182 :                    "(W9X7=0,W5X3=1,ATK=-1)");
; 6183 :   define_attribute(Catk,

	push	0
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0CNA@EFIGBGL@A?5value?5of?50?5means?5that?5the?5DWT?5@
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6184 :                    "A value of 0 means that the DWT kernel is one of W5X3 "
; 6185 :                    "or W9X7, as specified by the `Ckernels' attribute.  "
; 6186 :                    "Otherwise, this attribute holds the index of the ATK "
; 6187 :                    "marker segment which defines the transform kernel.  "
; 6188 :                    "The index must lie in the range 2 to 255 and "
; 6189 :                    "corresponding `Kreversible', `Krev_steps' or "
; 6190 :                    "`Kirv_steps' attributes must exist, which have the same "
; 6191 :                    "index (instance) value.  Thus, for example, if `Catk=3', "
; 6192 :                    "you must also supply a value for `Kreversible:I3' and/or "
; 6193 :                    "`Krev_steps:I3' or `Kirv_steps:I3', as appropriate.  "
; 6194 :                    "This information allows the internal machinery to deduce "
; 6195 :                    "whether the transform is reversible or not.  The ATK "
; 6196 :                    "information in these parameter attributes can also "
; 6197 :                    "be tile-specific.\n"
; 6198 :                    "\t\t[Default is 0]",
; 6199 :                    "I");
; 6200 :   define_attribute(Cuse_precincts,

	push	0
	push	OFFSET ??_C@_01HMGJMAIH@B?$AA@
	push	OFFSET ??_C@_0HE@LHMCCMEI@Explicitly?5specify?5whether?5or?5no@
	push	OFFSET ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6201 :                    "Explicitly specify whether or not precinct dimensions "
; 6202 :                    "are supplied.\n"
; 6203 :                    "\t\t[Default is \"no\" unless `Cprecincts' is "
; 6204 :                    "used]",
; 6205 :                    "B");
; 6206 :   define_attribute(Cprecincts,

	push	3
	push	OFFSET ??_C@_02FOEOGEOO@II?$AA@
	push	OFFSET ??_C@_0BEJ@DFLAPAFH@Precinct?5dimensions?5?$CImust?5be?5pow@
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6207 :                    "Precinct dimensions (must be powers of 2). Multiple "
; 6208 :                    "records may be supplied, in which case the first record "
; 6209 :                    "refers to the highest resolution level and subsequent "
; 6210 :                    "records to lower resolution levels. The last specified "
; 6211 :                    "record is used for any remaining lower resolution levels."
; 6212 :                    "Inside each record, vertical coordinates appear first.",
; 6213 :                    "II",MULTI_RECORD | CAN_EXTRAPOLATE);
; 6214 :   define_attribute(Cblk,

	push	0
	push	OFFSET ??_C@_02FOEOGEOO@II?$AA@
	push	OFFSET ??_C@_0PA@DKDAIDMK@Nominal?5code?9block?5dimensions?5?$CIm@
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6215 :                    "Nominal code-block dimensions (must be powers of 2, "
; 6216 :                    "no less than 4 and no greater than 1024). Actual "
; 6217 :                    "dimensions are subject to precinct, tile and image "
; 6218 :                    "dimensions. Vertical coordinates appear first.\n"
; 6219 :                    "\t\t[Default block dimensions are {64,64}]",
; 6220 :                    "II");
; 6221 :   define_attribute(Cmodes,

	push	0
	push	OFFSET ??_C@_0DL@FGLGNEBO@?$FLBYPASS?$DN1?$HMRESET?$DN2?$HMRESTART?$DN4?$HMCAUS@
	push	OFFSET ??_C@_0GG@LCCKLEAC@Block?5coder?5mode?5switches?4?5Any?5c@
	push	OFFSET ??_C@_06EGDCPANH@Cmodes?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6222 :                  "Block coder mode switches. Any combination is legal.\n"
; 6223 :                  "\t\t[By default, all mode switches are turned off]",
; 6224 :                  "[BYPASS=1|RESET=2|RESTART=4|CAUSAL=8|ERTERM=16|SEGMARK=32]");
; 6225 :   define_attribute(Cweight,

	push	0
	push	OFFSET ??_C@_01BIAFAFID@F?$AA@
	push	OFFSET ??_C@_0BHM@MPDDOEC@Multiplier?5for?5subband?5weighting@
	push	OFFSET ??_C@_07HDHNGJDI@Cweight?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6226 :                    "Multiplier for subband weighting factors (see "
; 6227 :                    "`Clev_weights' and `Cband_weights' below).  Scaling all "
; 6228 :                    "the weights by a single quantity has no impact on their "
; 6229 :                    "relative significance.  However, you may supply a "
; 6230 :                    "separate weight for each component, or even each "
; 6231 :                    "tile-component, allowing you to control the relative "
; 6232 :                    "signicance of image components or tile-components in a "
; 6233 :                    "simple manner.",
; 6234 :                    "F");
; 6235 :   define_attribute(Clev_weights,

	push	3
	push	OFFSET ??_C@_01BIAFAFID@F?$AA@
	push	OFFSET ??_C@_0CEE@FMHLHNCK@Weighting?5factors?5for?5each?5succe@
	push	OFFSET ??_C@_0N@HICBBPMC@Clev_weights?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6236 :                    "Weighting factors for each successive resolution "
; 6237 :                    "level, starting from the highest resolution and working "
; 6238 :                    "down to the lowest (but not including the LL band!!). The "
; 6239 :                    "last supplied weight is repeated as necessary.  Weight "
; 6240 :                    "values are squared to obtain energy weights for weighted "
; 6241 :                    "MSE calculations.  The LL subband always has a weight of "
; 6242 :                    "1.0, regardless of the number of resolution levels.  "
; 6243 :                    "However, the weights associated with all subbands, "
; 6244 :                    "including the LL band, are multiplied by the value "
; 6245 :                    "supplied by `Cweight', which may be specialized to "
; 6246 :                    "individual components or tile-components.",
; 6247 :                    "F",MULTI_RECORD | CAN_EXTRAPOLATE);
; 6248 :   define_attribute(Cband_weights,

	push	3
	push	OFFSET ??_C@_01BIAFAFID@F?$AA@
	push	OFFSET ??_C@_0FOI@OMMBBAAN@Weighting?5factors?5for?5each?5succe@
	push	OFFSET ??_C@_0O@GLALLHKC@Cband_weights?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6249 :                    "Weighting factors for each successive subband, "
; 6250 :                    "starting from the highest frequency subbands and working "
; 6251 :                    "down (i.e., HH1, LH1, HL1, HH2, ...). The last supplied "
; 6252 :                    "weight is repeated as necessary for all remaining "
; 6253 :                    "subbands (except the LL band). If `Clev_weights' is also "
; 6254 :                    "supplied, both sets of weighting factors are combined "
; 6255 :                    "(multiplied).  Weight values are squared to obtain energy "
; 6256 :                    "weights for weighted MSE calculations.  The LL subband "
; 6257 :                    "always has a weight of 1.0, which avoids "
; 6258 :                    "problems which may occur when image components or "
; 6259 :                    "tiles have different numbers of resolution levels.  "
; 6260 :                    "To modify the relative weighting of components or "
; 6261 :                    "tile-components, including their LL subbands, use "
; 6262 :                    "the `Cweight' option; its weighting factors are "
; 6263 :                    "multiplied by those specified using `Cband_weights' and "
; 6264 :                    "`Clev_weights'.  If the `Cdecomp' attribute is used to "
; 6265 :                    "describe more general packet wavelet transforms, all "
; 6266 :                    "subbands obtained by splitting an HL, LH or HH subband "
; 6267 :                    "will be assigned the same weight.  No mechanism is "
; 6268 :                    "provided for specifying their weights separately.  "
; 6269 :                    "Moreover, all three weights (HL, LH and HH) are "
; 6270 :                    "present for each resolution level, even if that "
; 6271 :                    "level only involves horizontal or vertical splitting, "
; 6272 :                    "and even in the degenerate case of no splitting at "
; 6273 :                    "all.  For horizontal splitting only, subbands derived "
; 6274 :                    "from HX use the corresponding HL weight; HH and LH "
; 6275 :                    "weights are then ignored.  Similarly for vertical "
; 6276 :                    "splitting only, subbands derived from XH use the "
; 6277 :                    "corresponding LH weight; HH and HL weights are then "
; 6278 :                    "ignored.",
; 6279 :                    "F",MULTI_RECORD | CAN_EXTRAPOLATE);
; 6280 :   define_attribute(Creslengths,

	push	1
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0HEO@NJIJCAOA@Maximum?5number?5of?5compressed?5byt@
	push	OFFSET ??_C@_0M@HKNEBDCB@Creslengths?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 6281 :        "Maximum number of compressed bytes (packet headers plus packet "
; 6282 :        "bodies) that can be produced for each successive image resolution, "
; 6283 :        "starting from the highest resolution and working down to the lowest.  "
; 6284 :        "The limit applies to the cumulative number of bytes generated for "
; 6285 :        "the resolution in question and all lower resolutions.  If the "
; 6286 :        "attribute is global to the entire codestream (no T or C "
; 6287 :        "specifier), the limit for each resolution applies to the "
; 6288 :        "cumulative number of bytes up to that resolution in all tiles and "
; 6289 :        "all image components.  If the attribute is tile-specific "
; 6290 :        "but not component-specific, the limit for each resolution applies "
; 6291 :        "to the cumulative number of bytes up to that resolution for all "
; 6292 :        "image components within the tile.  If the attribute is "
; 6293 :        "component-specific, the limit applies to the cumulative number of "
; 6294 :        "bytes up to the resolution in question across all tiles, but only "
; 6295 :        "in that image component.  Finally, if the attribute is "
; 6296 :        "component-specific and tile-specific, the limit applies to the "
; 6297 :        "cumulative number of bytes up to the resolution in question, within "
; 6298 :        "just that tile-component.  You can provide limits of all four types.  "
; 6299 :        "Moreover, you need not provide limits for all resolutions. "
; 6300 :        "The initial set of byte limits applies only to the first quality "
; 6301 :        "layer to be generated during compression.  Limits for additional "
; 6302 :        "quality layers may be supplied by inserting zero or negative values "
; 6303 :        "into the list; these are treated as layer delimiters.  So, for "
; 6304 :        "example, the parameter string \"1000,700,0,3000,2000,0,10000\" "
; 6305 :        "provides limits of 1000 and 700 bytes for the highest and second "
; 6306 :        "highest resolutions in the first quality layer, 3000 and 2000 bytes "
; 6307 :        "for the same resolutions in the second quality layer, and a limit "
; 6308 :        "of 10000 bytes only to the highest resolution in the third quality "
; 6309 :        "layer.  Any subsequent quality layers are not restricted by this "
; 6310 :        "parameter attribute.",
; 6311 :        "I",MULTI_RECORD);
; 6312 : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0cod_params@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
__ehhandler$??0cod_params@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0cod_params@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0cod_params@@QAE@XZ ENDP				; cod_params::cod_params
; Function compile flags: /Ogtp
;	COMDAT ??_Gatk_params@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gatk_params@@UAEPAXI@Z PROC				; atk_params::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gatk_params@@UAEPAXI@Z ENDP				; atk_params::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1atk_params@@UAE@XZ
_TEXT	SEGMENT
??1atk_params@@UAE@XZ PROC				; atk_params::~atk_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1atk_params@@UAE@XZ ENDP				; atk_params::~atk_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?read_marker_segment@atk_params@@MAE_NGHQAEH@Z
_TEXT	SEGMENT
$T2 = -200						; size = 4
$T3 = -196						; size = 4
$T4 = -192						; size = 4
$T5 = -188						; size = 4
$T6 = -184						; size = 4
$T7 = -180						; size = 4
_this$GSCopy$ = -176					; size = 4
_p_val$8 = -176						; size = 4
_Ds$1$ = -172						; size = 4
_e$9 = -168						; size = 20
_e$10 = -168						; size = 20
_e$11 = -168						; size = 20
_e$12 = -168						; size = 20
_e$13 = -168						; size = 20
_symmetric$ = -148					; size = 1
_Ns$14 = -148						; size = 4
tv852 = -144						; size = 4
_bytes_per_coeff$1$ = -140				; size = 4
tv87 = -136						; size = 8
_coeff$1$ = -132					; size = 4
tv146 = -132						; size = 4
_s_min$1$ = -128					; size = 4
_reversible$ = -128					; size = 1
_n_val$15 = -128					; size = 4
tv850 = -124						; size = 4
_end$ = -120						; size = 4
_this$GSCopy$1$ = -116					; size = 4
_extension$1$ = -112					; size = 4
_num_coeffs$ = -112					; size = 4
_s$1$ = -108						; size = 4
_bp$ = -104						; size = 4
_text$16 = -100						; size = 80
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_tpart_idx$ = 20					; size = 4
?read_marker_segment@atk_params@@MAE_NGHQAEH@Z PROC	; atk_params::read_marker_segment, COMDAT
; _this$ = ecx

; 5655 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 188				; 000000bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx

; 5656 :   kdu_byte *bp, *end;
; 5657 : 
; 5658 :   if (tpart_idx != 0)

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	mov	eax, DWORD PTR _num_bytes$[ebp]
	mov	esi, DWORD PTR _bytes$[ebp]
	mov	DWORD PTR _this$GSCopy$[ebp], ebx
	jne	$LN15@read_marke

; 5659 :     return false;
; 5660 :   if ((code != KDU_ATK) || (num_bytes < 2))

	mov	ecx, 65401				; 0000ff79H
	cmp	WORD PTR _code$[ebp], cx
	jne	$LN15@read_marke
	cmp	eax, 2
	jl	$LN15@read_marke

; 5662 : 
; 5663 :   bp = bytes;
; 5664 :   end = bp + num_bytes;
; 5665 : 
; 5666 :   int s_atk = *(bp++);  s_atk = (s_atk<<8) + *(bp++);

	movzx	edx, BYTE PTR [esi]
	add	eax, esi
	mov	DWORD PTR _end$[ebp], eax
	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	edx, 8
	add	edx, eax
	mov	DWORD PTR _bp$[ebp], esi

; 5667 :   int which_inst = s_atk & 0x00FF;

	movzx	eax, dl
	mov	DWORD PTR _extension$1$[ebp], edx

; 5668 :   if (which_inst != inst_idx)

	cmp	eax, DWORD PTR [ebx+16]
	jne	$LN15@read_marke

; 5669 :     return false;
; 5670 : 
; 5671 :   int bytes_per_coeff = 1 << ((s_atk >> 8) & 3);

	mov	ecx, edx
	mov	eax, 1
	sar	ecx, 8
	and	ecx, 3
	shl	eax, cl
	mov	DWORD PTR _bytes_per_coeff$1$[ebp], eax

; 5672 :   if (bytes_per_coeff > 8)

	cmp	eax, 8
	jle	SHORT $LN17@read_marke

; 5673 :     { KDU_ERROR(e,0x2005050a); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$13[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	OFFSET ??_C@_0GL@MACCMDJG@Cannot?5process?5ATK?5marker?5segmen@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5673 :     { KDU_ERROR(e,0x2005050a); e <<

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5676 :     }

	lea	ecx, DWORD PTR _e$13[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	edx, DWORD PTR _extension$1$[ebp]
$LN17@read_marke:

; 5677 : 
; 5678 :   bool symmetric = ((s_atk >> 11) & 1)?true:false;

	mov	eax, edx

; 5679 :   bool reversible = ((s_atk >> 12) & 1)?true:false;

	mov	ecx, edx

; 5680 :   int m_last = ((s_atk >> 13) & 1);

	mov	edi, edx
	sar	eax, 11					; 0000000bH
	and	eax, -255				; ffffff01H
	sar	ecx, 12					; 0000000cH
	sar	edi, 13					; 0000000dH
	and	ecx, -255				; ffffff01H

; 5681 :   int extension = ((s_atk >> 14) & 1)?Kextension_SYM:Kextension_CON;

	sar	edx, 14					; 0000000eH
	and	edi, 1
	and	edx, 1
	mov	DWORD PTR tv850[ebp], eax
	mov	BYTE PTR _symmetric$[ebp], al
	mov	DWORD PTR tv852[ebp], ecx
	mov	BYTE PTR _reversible$[ebp], cl
	mov	DWORD PTR _extension$1$[ebp], edx

; 5682 : 
; 5683 :   if (symmetric && (extension != Kextension_SYM))

	test	al, al
	je	SHORT $LN18@read_marke
	cmp	edx, 1
	je	SHORT $LN18@read_marke

; 5684 :     { KDU_ERROR(e,0x2005050b); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$12[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_0JJ@EJINJNCB@Malformed?5ATK?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5684 :     { KDU_ERROR(e,0x2005050b); e <<

	mov	DWORD PTR __$EHRec$[ebp+12], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5688 :     }

	lea	ecx, DWORD PTR _e$12[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR tv852[ebp]
$LN18@read_marke:

; 5689 : 
; 5690 :   if (reversible && (bytes_per_coeff > 2))

	test	cl, cl
	je	SHORT $LN19@read_marke
	cmp	DWORD PTR _bytes_per_coeff$1$[ebp], 2
	jle	SHORT $LN19@read_marke

; 5691 :     { KDU_ERROR(e,0x21050500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$11[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_0HD@HJBDDKNG@Cannot?5process?5ATK?5marker?5segmen@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5691 :     { KDU_ERROR(e,0x21050500); e <<

	mov	DWORD PTR __$EHRec$[ebp+12], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5694 :     }

	lea	ecx, DWORD PTR _e$11[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN19@read_marke:

; 5695 : 
; 5696 :   set(Kreversible,0,0,reversible);

	push	DWORD PTR _reversible$[ebp]
	mov	ecx, ebx
	push	0
	push	0
	push	OFFSET ??_C@_0M@OFOCCDJH@Kreversible?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 5697 :   set(Ksymmetric,0,0,symmetric);

	push	DWORD PTR _symmetric$[ebp]
	mov	ecx, ebx
	push	0
	push	0
	push	OFFSET ??_C@_0L@BNGLHLNI@Ksymmetric?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 5698 :   set(Kextension,0,0,extension);

	push	DWORD PTR _extension$1$[ebp]
	mov	ecx, ebx
	push	0
	push	0
	push	OFFSET ??_C@_0L@JOGHAEOB@Kextension?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5699 : 
; 5700 :   int num_coeffs = 0;
; 5701 :   try {
; 5702 :       if (!reversible)

	cmp	BYTE PTR tv852[ebp], 0
	mov	DWORD PTR _num_coeffs$[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 3
	jne	SHORT $LN21@read_marke

; 5703 :         bp += bytes_per_coeff; // Skip over the K value -- it is redundant

	add	esi, DWORD PTR _bytes_per_coeff$1$[ebp]
	mov	DWORD PTR _bp$[ebp], esi
$LN21@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	ebx, DWORD PTR _end$[ebp]
	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN59@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T7[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN121@read_marke:
$LN59@read_marke:

; 92   :   val = *(bp++);

	movzx	edx, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5707 :       if ((s_max & 1) != (1-m_last))

	mov	ecx, 1
	dec	edx
	mov	DWORD PTR _s_min$1$[ebp], 0
	mov	eax, edx
	mov	DWORD PTR _s$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5707 :       if ((s_max & 1) != (1-m_last))

	sub	ecx, edi
	and	eax, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5707 :       if ((s_max & 1) != (1-m_last))

	cmp	eax, ecx
	je	SHORT $LN115@read_marke

; 5708 :         { s_max++; s_min++; }

	inc	edx
	mov	eax, 1
	mov	DWORD PTR _s$1$[ebp], edx
	mov	DWORD PTR _s_min$1$[ebp], eax
	jmp	SHORT $LN22@read_marke
$LN115@read_marke:
	xor	eax, eax
$LN22@read_marke:
	mov	ecx, DWORD PTR tv850[ebp]
$LL4@read_marke:

; 5709 :       for (s=s_max; s >= s_min; s--)

	cmp	edx, eax
	jl	$LN3@read_marke

; 5710 :         { // ATK marker segment records lifting steps in synthesis order, but
; 5711 :           // we store them in analysis order
; 5712 :           if (!symmetric)

	test	cl, cl
	jne	SHORT $LN23@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN66@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T6[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN122@read_marke:
$LN66@read_marke:

; 92   :   val = *(bp++);

	movzx	edi, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5715 :               Ns -= (Ns & 0x80)?256:0; // Convert to 2's complement

	mov	eax, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5715 :               Ns -= (Ns & 0x80)?256:0; // Convert to 2's complement

	and	eax, 128				; 00000080H
	add	eax, eax
	sub	edi, eax
	mov	DWORD PTR _Ns$14[ebp], edi
$LN23@read_marke:

; 5716 :             }
; 5717 :           if (reversible)

	cmp	BYTE PTR tv852[ebp], 0
	je	SHORT $LN24@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN72@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T5[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN123@read_marke:
$LN72@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5720 :               Rs = kdu_read(bp,end,bytes_per_coeff);

	mov	esi, DWORD PTR _bytes_per_coeff$1$[ebp]
	push	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _Ds$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5720 :               Rs = kdu_read(bp,end,bytes_per_coeff);

	lea	eax, DWORD PTR _bp$[ebp]
	push	ebx
	push	eax
	call	?kdu_read@@YAHAAPAEPAEH@Z		; kdu_read

; 5721 :               if (bytes_per_coeff == 1)
; 5722 :                 Rs -= (Rs & 0x80)?(1<<8):0; // Convert to 2's complement

	mov	edx, DWORD PTR _s$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	edi, eax
	cmp	esi, 1
	jne	SHORT $LN26@read_marke
	mov	esi, DWORD PTR _bp$[ebp]
	mov	ecx, edi
	and	ecx, 128				; 00000080H
	add	ecx, ecx
	sub	edi, ecx
	mov	ecx, DWORD PTR tv850[ebp]
	jmp	SHORT $LN25@read_marke
$LN26@read_marke:

; 5725 :             }
; 5726 :           else

	mov	ecx, DWORD PTR tv850[ebp]
	cmp	esi, 2
	mov	esi, DWORD PTR _bp$[ebp]
	jne	SHORT $LN25@read_marke

; 5723 :               else if (bytes_per_coeff == 2)
; 5724 :                 Rs -= (Rs & 0x8000)?(1<<16):0; // Convert to 2's complement

	mov	eax, edi
	and	eax, 32768				; 00008000H
	add	eax, eax
	sub	edi, eax

; 5725 :             }
; 5726 :           else

	jmp	SHORT $LN25@read_marke
$LN24@read_marke:

; 5727 :             Ds = Rs = 0;

	xor	edi, edi
	mov	DWORD PTR _Ds$1$[ebp], edi
$LN25@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN78@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T4[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN124@read_marke:
$LN78@read_marke:

; 92   :   val = *(bp++);

	movzx	ebx, BYTE PTR [esi]
	inc	esi
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5729 :           if (symmetric)

	test	cl, cl
	je	SHORT $LN29@read_marke

; 5730 :             {
; 5731 :               Ls <<= 1; // Only half the entries signalled in ATK segment
; 5732 :               Ns = -((Ls + (s&1) - 1) >> 1);

	mov	eax, edx
	add	ebx, ebx
	and	eax, 1
	dec	eax
	add	eax, ebx
	sar	eax, 1
	neg	eax
	mov	DWORD PTR _Ns$14[ebp], eax
$LN29@read_marke:

; 5733 :             }
; 5734 :           set(Ksteps,s,0,Ls);  set(Ksteps,s,1,Ns);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	ebx
	push	0
	push	edx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _Ns$14[ebp]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	1
	push	DWORD PTR _s$1$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5735 :           set(Ksteps,s,2,Ds);  set(Ksteps,s,3,Rs);

	push	DWORD PTR _Ds$1$[ebp]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	2
	push	DWORD PTR _s$1$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	edi
	push	3
	push	DWORD PTR _s$1$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5736 :           if (symmetric)

	mov	ecx, DWORD PTR tv850[ebp]
	test	cl, cl
	je	SHORT $LN30@read_marke

; 5737 :             Ls >>= 1; // Go back to number of entries in ATK segment

	sar	ebx, 1
$LN30@read_marke:

; 5738 :           for (n=0; n < Ls; n++)

	xor	edi, edi
$LL7@read_marke:
	cmp	edi, ebx
	jge	$LN6@read_marke

; 5739 :             { // Read coefficients, writing them in reverse order into the
; 5740 :               // `Kcoeffs' array, as appropriate.  Later on, we will reverse
; 5741 :               // the entire array.
; 5742 :               int ival=0;
; 5743 :               float coeff=0.0F;
; 5744 :               switch (bytes_per_coeff) {

	mov	eax, DWORD PTR _bytes_per_coeff$1$[ebp]
	xorps	xmm1, xmm1
	dec	eax
	movss	DWORD PTR _coeff$1$[ebp], xmm1
	cmp	eax, 7
	ja	$LN35@read_marke
	jmp	DWORD PTR $LN120@read_marke[eax*4]
$LN31@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN84@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T3[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN125@read_marke:
$LN84@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5747 :                   ival -= (ival & 0x80)?(1<<8):0; // Convert to 2's comp

	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5747 :                   ival -= (ival & 0x80)?(1<<8):0; // Convert to 2's comp

	and	eax, 128				; 00000080H
	add	eax, eax
	sub	ecx, eax
	movd	xmm1, ecx

; 5748 :                   coeff = (float) ival;

	cvtdq2ps xmm1, xmm1

; 5749 :                   break;

	jmp	$LN118@read_marke
$LN32@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN90@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T2[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN126@read_marke:
$LN90@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 93   :   if (nbytes > 1)
; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	ecx, 8
	add	ecx, eax
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5752 :                   ival -= (ival & 0x8000)?(1<<16):0; // Convert to 2's comp

	mov	eax, ecx
	and	eax, 32768				; 00008000H
	add	eax, eax
	sub	ecx, eax
	movd	xmm1, ecx

; 5753 :                   coeff = (float) ival;

	cvtdq2ps xmm1, xmm1

; 5754 :                   break;

	jmp	SHORT $LN118@read_marke
$LN33@read_marke:

; 5755 :                 case 4:
; 5756 :                   coeff = kdu_read_float(bp,end);

	push	DWORD PTR _end$[ebp]
	lea	eax, DWORD PTR _bp$[ebp]
	push	eax
	call	?kdu_read_float@@YAMAAPAEPAE@Z		; kdu_read_float
	fstp	DWORD PTR tv146[ebp]
	movss	xmm1, DWORD PTR tv146[ebp]

; 5757 :                   assert(!reversible);
; 5758 :                   break;

	jmp	SHORT $LN119@read_marke
$LN34@read_marke:

; 5759 :                 case 8:
; 5760 :                   coeff = (float) kdu_read_double(bp,end);

	push	DWORD PTR _end$[ebp]
	lea	eax, DWORD PTR _bp$[ebp]
	push	eax
	call	?kdu_read_double@@YANAAPAEPAE@Z		; kdu_read_double
	fstp	QWORD PTR tv87[ebp]
	movsd	xmm1, QWORD PTR tv87[ebp]
	cvtpd2ps xmm1, xmm1
$LN119@read_marke:
	mov	esi, DWORD PTR _bp$[ebp]
	add	esp, 8
$LN118@read_marke:
	movss	DWORD PTR _coeff$1$[ebp], xmm1
$LN35@read_marke:

; 5761 :                   assert(!reversible);
; 5762 :                   break;
; 5763 :                 default: assert(0);
; 5764 :                 };
; 5765 :               if (reversible)

	cmp	BYTE PTR tv852[ebp], 0
	je	SHORT $LN36@read_marke

; 5766 :                 coeff /= (float)(1<<Ds); 

	mov	ecx, DWORD PTR _Ds$1$[ebp]
	mov	eax, 1
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR _coeff$1$[ebp], xmm1
$LN36@read_marke:

; 5767 :               set(Kcoeffs,num_coeffs+Ls-1-n,0,coeff);

	mov	ecx, DWORD PTR _num_coeffs$[ebp]
	sub	esp, 8
	cvtps2pd xmm0, xmm1
	mov	eax, ebx
	dec	ecx
	sub	eax, edi
	add	eax, ecx
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	eax
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set

; 5768 :               if (symmetric)

	mov	ecx, DWORD PTR tv850[ebp]
	test	cl, cl
	je	SHORT $LN5@read_marke

; 5769 :                 { // Write second, not reversed copy of coefficients
; 5770 :                   set(Kcoeffs,num_coeffs+Ls+n,0,coeff);

	movss	xmm0, DWORD PTR _coeff$1$[ebp]
	lea	eax, DWORD PTR [edi+ebx]
	add	eax, DWORD PTR _num_coeffs$[ebp]
	sub	esp, 8
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	eax
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	mov	ecx, DWORD PTR tv850[ebp]
$LN5@read_marke:

; 5738 :           for (n=0; n < Ls; n++)

	inc	edi
	jmp	$LL7@read_marke
$LN6@read_marke:

; 5771 :                 }
; 5772 :             }
; 5773 :           num_coeffs += (symmetric)?(Ls+Ls):Ls;

	test	cl, cl
	je	SHORT $LN41@read_marke
	add	ebx, ebx
$LN41@read_marke:

; 5709 :       for (s=s_max; s >= s_min; s--)

	mov	edx, DWORD PTR _s$1$[ebp]

; 5771 :                 }
; 5772 :             }
; 5773 :           num_coeffs += (symmetric)?(Ls+Ls):Ls;

	add	DWORD PTR _num_coeffs$[ebp], ebx
	dec	edx
	mov	ebx, DWORD PTR _end$[ebp]
	mov	eax, DWORD PTR _s_min$1$[ebp]
	mov	DWORD PTR _s$1$[ebp], edx
	jmp	$LL4@read_marke
$LN3@read_marke:

; 5774 :         }
; 5775 :       if (s == 0)
; 5776 :         { // First lifting step is empty; not recorded in ATK marker segment
; 5777 :           set(Ksteps,s,0,0);  set(Ksteps,s,1,0);

	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	test	edx, edx
	jne	$LN38@read_marke
	push	edx
	push	edx
	push	edx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	0
	push	1
	push	0
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5778 :           set(Ksteps,s,2,0);  set(Ksteps,s,3,0);

	push	0
	push	2
	push	0
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	0
	push	3
	push	0
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	jmp	SHORT $LN38@read_marke
__catch$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$0:

; 5782 :     { KDU_ERROR(e,0x205050c); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$10[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0EI@CBNJBHNF@Malformed?5ATK?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5782 :     { KDU_ERROR(e,0x205050c); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5785 :     }

	lea	ecx, DWORD PTR _e$10[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN51@read_marke
	ret	0
$LN51@read_marke:
	mov	esi, DWORD PTR _bp$[ebp]
	mov	ebx, DWORD PTR _this$GSCopy$[ebp]
$LN38@read_marke:
	mov	edi, DWORD PTR _end$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	cmp	esi, edi
	je	$LN39@read_marke

; 5787 :     { KDU_ERROR(e,0x2005050d); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$9[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0DF@MILOCDIO@Malformed?5ATK?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5787 :     { KDU_ERROR(e,0x2005050d); e <<

	mov	DWORD PTR __$EHRec$[ebp+12], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5789 :         << (int)(end-bp) <<

	sub	edi, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	BYTE PTR _e$9[ebp+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	edi
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$16[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$16[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	eax
	mov	eax, DWORD PTR _e$9[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5791 :     }

	lea	ecx, DWORD PTR _e$9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN39@read_marke:

; 5792 : 
; 5793 :   // Now all we have to do is reverse the order of the coefficient entries
; 5794 :   int n, p;
; 5795 :   for (n=0, p=num_coeffs-1; n < p; n++, p--)

	mov	esi, DWORD PTR _num_coeffs$[ebp]
	xor	edi, edi
	dec	esi
	test	esi, esi
	jle	$LN11@read_marke
$LL12@read_marke:

; 5796 :     {
; 5797 :       float n_val, p_val;
; 5798 :       get(Kcoeffs,n,0,n_val);  get(Kcoeffs,p,0,p_val);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _n_val$15[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _p_val$8[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	movss	xmm0, DWORD PTR _p_val$8[ebp]

; 5799 :       set(Kcoeffs,n,0,p_val);  set(Kcoeffs,p,0,n_val);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	edi
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	movss	xmm0, DWORD PTR _n_val$15[ebp]
	sub	esp, 8
	cvtps2pd xmm0, xmm0
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	esi
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	inc	edi
	dec	esi
	cmp	edi, esi
	jl	SHORT $LL12@read_marke
$LN11@read_marke:

; 5800 :     }
; 5801 : 
; 5802 :   return true;

	mov	al, 1
	jmp	SHORT $LN1@read_marke
$LN15@read_marke:

; 5661 :     return false;

	xor	al, al
$LN1@read_marke:

; 5803 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN117@read_marke:
	npad	2
$LN120@read_marke:
	DD	$LN31@read_marke
	DD	$LN32@read_marke
	DD	$LN35@read_marke
	DD	$LN33@read_marke
	DD	$LN35@read_marke
	DD	$LN35@read_marke
	DD	$LN35@read_marke
	DD	$LN34@read_marke
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$2:
	lea	ecx, DWORD PTR _e$13[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$3:
	lea	ecx, DWORD PTR _e$12[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$4:
	lea	ecx, DWORD PTR _e$11[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$5:
	lea	ecx, DWORD PTR _e$10[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z$6:
	lea	ecx, DWORD PTR _e$9[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-204]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_marker_segment@atk_params@@MAE_NGHQAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_marker_segment@atk_params@@MAE_NGHQAEH@Z ENDP	; atk_params::read_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?check_marker_segment@atk_params@@MAE_NGHQAEAAH@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_c_idx$ = 20						; size = 4
?check_marker_segment@atk_params@@MAE_NGHQAEAAH@Z PROC	; atk_params::check_marker_segment, COMDAT
; _this$ = ecx

; 5640 : {

	push	ebp
	mov	ebp, esp

; 5641 :   if ((code != KDU_ATK) || (num_bytes < 2))

	mov	eax, 65401				; 0000ff79H
	cmp	WORD PTR _code$[ebp], ax
	jne	SHORT $LN3@check_mark
	cmp	DWORD PTR _num_bytes$[ebp], 2
	jl	SHORT $LN3@check_mark

; 5643 :   int s_atk = *(bytes++);  s_atk = (s_atk<<8) + *(bytes++);
; 5644 :   c_idx = s_atk & 0x00FF;

	mov	eax, DWORD PTR _bytes$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	eax, DWORD PTR _c_idx$[ebp]
	mov	DWORD PTR [eax], ecx

; 5645 :   return ((c_idx >= 2) && (c_idx <= 255));

	cmp	ecx, 2
	jl	SHORT $LN5@check_mark
	cmp	ecx, 255				; 000000ffH
	jg	SHORT $LN5@check_mark
	mov	eax, 1

; 5646 : }

	pop	ebp
	ret	16					; 00000010H
$LN5@check_mark:

; 5645 :   return ((c_idx >= 2) && (c_idx <= 255));

	xor	eax, eax

; 5646 : }

	pop	ebp
	ret	16					; 00000010H
$LN3@check_mark:

; 5642 :     return false;

	xor	al, al

; 5646 : }

	pop	ebp
	ret	16					; 00000010H
?check_marker_segment@atk_params@@MAE_NGHQAEAAH@Z ENDP	; atk_params::check_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
_TEXT	SEGMENT
_e$2 = -212						; size = 20
_gain_p$1$ = -192					; size = 8
_extension$ = -184					; size = 4
_dc_gain$1$ = -180					; size = 8
tv990 = -180						; size = 8
tv984 = -180						; size = 8
_dc_gain$3$ = -172					; size = 8
_s$1$ = -168						; size = 4
_e$3 = -164						; size = 20
_e$4 = -164						; size = 20
_e$5 = -164						; size = 20
_Rs$ = -144						; size = 4
_Ds$ = -140						; size = 4
_Ns$ = -136						; size = 4
_num_steps$1$ = -132					; size = 4
_n_off$1$ = -132					; size = 4
_symmetric$ = -128					; size = 1
_coeff$ = -124						; size = 4
_reversible$ = -120					; size = 1
_length$3$ = -116					; size = 4
_n$1$ = -116						; size = 4
_word$1$ = -112						; size = 4
_out$GSCopy$1$ = -112					; size = 4
_both$6 = -112						; size = 4
_both$7 = -112						; size = 4
_s_atk$2$ = -108					; size = 4
_s$3$ = -108						; size = 4
_s$2$ = -108						; size = 4
_tested_steps$1$ = -108					; size = 4
tv788 = -108						; size = 4
_last_marked$GSCopy$1$ = -104				; size = 4
_n_off$3$ = -104					; size = 4
_Ls$ = -100						; size = 4
_text$8 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_out$ = 8						; size = 4
_last_marked$ = 12					; size = 4
_tpart_idx$ = 16					; size = 4
?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z PROC ; atk_params::write_marker_segment, COMDAT
; _this$ = ecx

; 5812 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 5813 :   atk_params *ref = (atk_params *) last_marked;
; 5814 :   if ((inst_idx < 2) || (inst_idx > 255) || (tpart_idx != 0) ||

	mov	eax, DWORD PTR [edi+16]
	mov	esi, DWORD PTR _out$[ebp]
	mov	ebx, DWORD PTR _last_marked$[ebp]
	mov	DWORD PTR _out$GSCopy$1$[ebp], esi
	mov	DWORD PTR _last_marked$GSCopy$1$[ebp], ebx
	cmp	eax, 2
	jl	$LN24@write_mark
	cmp	eax, 255				; 000000ffH
	jg	$LN24@write_mark
	cmp	DWORD PTR _tpart_idx$[ebp], 0
	jne	$LN24@write_mark
	cmp	DWORD PTR [edi+12], 0
	jge	$LN24@write_mark

; 5817 : 
; 5818 :   // Collect the scalar parameters
; 5819 :   bool reversible, symmetric;
; 5820 :   int extension;
; 5821 : 
; 5822 :   if (!(get(Kreversible,0,0,reversible) &&

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _reversible$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@OFOCCDJH@Kreversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN26@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _symmetric$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@BNGLHLNI@Ksymmetric?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN26@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _extension$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@JOGHAEOB@Kextension?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN25@write_mark
$LN26@write_mark:

; 5825 :     { KDU_ERROR_DEV(e,0x2007050a); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0DL@COILGNIP@Unable?5to?5write?5ATK?5marker?5segme@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5825 :     { KDU_ERROR_DEV(e,0x2007050a); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5827 :     }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN25@write_mark:

; 5828 : 
; 5829 :   int s, Ls, Ns, Ds, Rs;
; 5830 :   int n, n_off;
; 5831 :   float coeff;
; 5832 :   if (ref != NULL)

	test	ebx, ebx
	je	$LN33@write_mark

; 5833 :     { // See if we can skip marker segment generation.
; 5834 :       if (ref->compare(Kreversible,0,0,reversible) &&
; 5835 :           ref->compare(Ksymmetric,0,0,symmetric) &&

	push	DWORD PTR _reversible$[ebp]
	mov	ecx, ebx
	push	0
	push	0
	push	OFFSET ??_C@_0M@OFOCCDJH@Kreversible?$AA@
	call	?compare@kdu_params@@QAE_NPBDHH_N@Z	; kdu_params::compare
	test	al, al
	je	$LN33@write_mark
	push	DWORD PTR _symmetric$[ebp]
	mov	ecx, ebx
	push	0
	push	0
	push	OFFSET ??_C@_0L@BNGLHLNI@Ksymmetric?$AA@
	call	?compare@kdu_params@@QAE_NPBDHH_N@Z	; kdu_params::compare
	test	al, al
	je	$LN33@write_mark
	push	DWORD PTR _extension$[ebp]
	mov	ecx, ebx
	push	0
	push	0
	push	OFFSET ??_C@_0L@JOGHAEOB@Kextension?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN33@write_mark

; 5836 :           ref->compare(Kextension,0,0,extension))
; 5837 :         { // So far so good.  Now let's check the lifting steps themselves
; 5838 :           int tested_steps = 0;
; 5839 :           for (n_off=0, s=0;
; 5840 :                get(Ksteps,s,0,Ls) && get(Ksteps,s,1,Ns) &&
; 5841 :                get(Ksteps,s,2,Ds) && get(Ksteps,s,3,Rs);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Ls$[ebp]
	mov	DWORD PTR _tested_steps$1$[ebp], 0
	push	eax
	xor	ebx, ebx
	mov	DWORD PTR _n_off$1$[ebp], 0
	push	ebx
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, edi
	mov	DWORD PTR _s$1$[ebp], ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN24@write_mark
	mov	esi, DWORD PTR _last_marked$GSCopy$1$[ebp]
$LL4@write_mark:
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Ns$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN121@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Ds$[ebp]
	mov	ecx, edi
	push	eax
	push	2
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN121@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Rs$[ebp]
	mov	ecx, edi
	push	eax
	push	3
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN121@write_mark

; 5843 :             {
; 5844 :               tested_steps = s+1;
; 5845 :               if (!(ref->compare(Ksteps,s,0,Ls) &&

	push	DWORD PTR _Ls$[ebp]
	lea	eax, DWORD PTR [ebx+1]
	mov	ecx, esi
	push	0
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	DWORD PTR _tested_steps$1$[ebp], eax
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN121@write_mark
	push	DWORD PTR _Ns$[ebp]
	mov	ecx, esi
	push	1
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN121@write_mark
	push	DWORD PTR _Ds$[ebp]
	mov	ecx, esi
	push	2
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN121@write_mark
	push	DWORD PTR _Rs$[ebp]
	mov	ecx, esi
	push	3
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHH@Z	; kdu_params::compare
	test	al, al
	je	$LN121@write_mark

; 5846 :                     ref->compare(Ksteps,s,1,Ns) &&
; 5847 :                     ref->compare(Ksteps,s,2,Ds) &&
; 5848 :                     ref->compare(Ksteps,s,3,Rs)))
; 5849 :                 break;
; 5850 :               for (n=0; n < Ls; n++)

	mov	ecx, DWORD PTR _Ls$[ebp]
	xor	eax, eax
	mov	DWORD PTR _n$1$[ebp], eax
	test	ecx, ecx
	jle	SHORT $LN120@write_mark
	mov	ebx, DWORD PTR _n_off$1$[ebp]
	npad	4
$LL7@write_mark:

; 5851 :                 {
; 5852 :                   get(Kcoeffs,n_off+n,0,coeff);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _coeff$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 5853 :                   if (!ref->compare(Kcoeffs,n_off+n,0,coeff))

	movss	xmm0, DWORD PTR _coeff$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _last_marked$GSCopy$1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	0
	push	ebx
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?compare@kdu_params@@QAE_NPBDHHM@Z	; kdu_params::compare
	mov	ecx, DWORD PTR _Ls$[ebp]
	test	al, al
	mov	eax, DWORD PTR _n$1$[ebp]
	je	SHORT $LN145@write_mark

; 5846 :                     ref->compare(Ksteps,s,1,Ns) &&
; 5847 :                     ref->compare(Ksteps,s,2,Ds) &&
; 5848 :                     ref->compare(Ksteps,s,3,Rs)))
; 5849 :                 break;
; 5850 :               for (n=0; n < Ls; n++)

	inc	eax
	inc	ebx
	mov	DWORD PTR _n$1$[ebp], eax
	cmp	eax, ecx
	jl	SHORT $LL7@write_mark
$LN145@write_mark:
	mov	esi, DWORD PTR _last_marked$GSCopy$1$[ebp]
	mov	ebx, DWORD PTR _s$1$[ebp]
$LN120@write_mark:

; 5854 :                     break;
; 5855 :                 }
; 5856 :               if (n != Ls)

	cmp	eax, ecx
	jne	SHORT $LN121@write_mark

; 5836 :           ref->compare(Kextension,0,0,extension))
; 5837 :         { // So far so good.  Now let's check the lifting steps themselves
; 5838 :           int tested_steps = 0;
; 5839 :           for (n_off=0, s=0;
; 5840 :                get(Ksteps,s,0,Ls) && get(Ksteps,s,1,Ns) &&
; 5841 :                get(Ksteps,s,2,Ds) && get(Ksteps,s,3,Rs);

	mov	ebx, DWORD PTR _tested_steps$1$[ebp]
	lea	eax, DWORD PTR _Ls$[ebp]

; 5842 :                s++, n_off+=Ls)

	add	DWORD PTR _n_off$1$[ebp], ecx
	mov	ecx, edi
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	DWORD PTR _s$1$[ebp], ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL4@write_mark
$LN121@write_mark:

; 5857 :                 break;
; 5858 :             }
; 5859 : 
; 5860 :           if (s == tested_steps)

	mov	esi, DWORD PTR _out$GSCopy$1$[ebp]
	cmp	ebx, DWORD PTR _tested_steps$1$[ebp]
	je	$LN24@write_mark
$LN33@write_mark:

; 5861 :             return 0; // Object identical to reference; did not break early.
; 5862 :         }
; 5863 :     }
; 5864 : 
; 5865 :   // We are now committed to writing (or simulating) a marker segment.
; 5866 :   int num_steps=0, num_coeffs=0;
; 5867 :   for (s=0; get(Ksteps,s,0,Ls) && get(Ksteps,s,1,Ns) &&
; 5868 :             get(Ksteps,s,2,Ds) && get(Ksteps,s,3,Rs); s++)

	push	1
	push	1
	push	1
	xor	ebx, ebx
	lea	eax, DWORD PTR _Ls$[ebp]
	push	eax
	push	ebx
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, edi
	mov	DWORD PTR _num_steps$1$[ebp], ebx
	mov	DWORD PTR _n_off$3$[ebp], ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN9@write_mark
	xor	esi, esi
	npad	3
$LL10@write_mark:
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Ns$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN147@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Ds$[ebp]
	mov	ecx, edi
	push	eax
	push	2
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN147@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Rs$[ebp]
	mov	ecx, edi
	push	eax
	push	3
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN147@write_mark

; 5869 :     { num_steps++;  num_coeffs += Ls; }

	add	esi, DWORD PTR _Ls$[ebp]
	lea	eax, DWORD PTR _Ls$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	inc	ebx
	mov	ecx, edi
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL10@write_mark
$LN147@write_mark:
	mov	DWORD PTR _n_off$3$[ebp], esi
	mov	esi, DWORD PTR _out$GSCopy$1$[ebp]
	mov	DWORD PTR _num_steps$1$[ebp], ebx
$LN9@write_mark:

; 5870 : 
; 5871 :   int num_coeff_entries = (symmetric)?(num_coeffs>>1):num_coeffs;

	cmp	BYTE PTR _symmetric$[ebp], 0
	mov	edx, DWORD PTR _n_off$3$[ebp]
	je	SHORT $LN58@write_mark
	sar	edx, 1
$LN58@write_mark:

; 5872 : 
; 5873 :   int length = 4 + 2; // Marker code, length and Satk
; 5874 :   if (!reversible)

	mov	eax, DWORD PTR _reversible$[ebp]
	mov	ecx, 6
	test	al, al
	mov	DWORD PTR tv788[ebp], 10		; 0000000aH
	cmove	ecx, DWORD PTR tv788[ebp]

; 5875 :     length += 4; // For signalling the K value
; 5876 :   length++; // For signalling num_steps

	inc	ecx

; 5877 :   if (reversible)

	test	al, al
	je	SHORT $LN35@write_mark

; 5878 :     length += num_steps*5 + num_coeff_entries*2; // 2-byte integer coeffs

	lea	eax, DWORD PTR [ecx+ebx*4]
	add	eax, ebx
	lea	eax, DWORD PTR [eax+edx*2]

; 5879 :   else

	jmp	SHORT $LN149@write_mark
$LN35@write_mark:

; 5880 :     length += num_steps*2 + num_coeff_entries*4; // 4-byte float coeffs

	lea	eax, DWORD PTR [ebx+edx*2]
	lea	eax, DWORD PTR [ecx+eax*2]
$LN149@write_mark:

; 5881 :   if (symmetric)

	mov	edx, DWORD PTR _symmetric$[ebp]
	mov	DWORD PTR _length$3$[ebp], eax
	test	dl, dl
	je	SHORT $LN37@write_mark

; 5882 :     length -= num_steps; // Don't need to signal the Ns value.

	sub	eax, ebx
	mov	DWORD PTR _length$3$[ebp], eax
$LN37@write_mark:

; 5883 : 
; 5884 :   if (out == NULL)

	test	esi, esi
	je	$LN1@write_mark

; 5885 :     return length;
; 5886 : 
; 5887 :   // If we get here, we are committed to actually writing the marker segment
; 5888 :   int s_atk = inst_idx;

	mov	ecx, DWORD PTR [edi+16]

; 5889 :   if (symmetric)

	test	dl, dl
	je	SHORT $LN39@write_mark

; 5890 :     s_atk += (1<<11);

	add	ecx, 2048				; 00000800H
$LN39@write_mark:

; 5891 :   if (reversible)

	mov	edx, DWORD PTR _reversible$[ebp]
	test	dl, dl
	je	SHORT $LN40@write_mark

; 5892 :     s_atk += (1 << 12);

	add	ecx, 4096				; 00001000H
$LN40@write_mark:

; 5893 :   if (num_steps & 1)

	test	bl, 1
	je	SHORT $LN41@write_mark

; 5894 :     s_atk += (1 << 13);

	add	ecx, 8192				; 00002000H
$LN41@write_mark:

; 5895 :   if (extension == Kextension_SYM)

	cmp	DWORD PTR _extension$[ebp], 1
	jne	SHORT $LN42@write_mark

; 5896 :     s_atk += (1 << 14);

	add	ecx, 16384				; 00004000H
$LN42@write_mark:

; 5897 : 
; 5898 :   if (reversible)
; 5899 :     s_atk += (1<<8); // 2-byte integer coefficients

	lea	eax, DWORD PTR [ecx+256]

; 5900 :   else
; 5901 :     s_atk += (2<<8); // 4-byte floating point coefficients

	add	ecx, 512				; 00000200H
	test	dl, dl

; 5902 : 
; 5903 :   int acc_length = 0; // Accumulate actual length for verification purposes.
; 5904 :   acc_length += out->put(KDU_ATK);

	push	65401					; 0000ff79H
	cmovne	ecx, eax
	mov	DWORD PTR _s_atk$2$[ebp], ecx
	mov	ecx, esi
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 5905 :   acc_length += out->put((kdu_uint16)(length-2));

	mov	eax, DWORD PTR _length$3$[ebp]
	mov	ecx, esi
	add	eax, -2					; fffffffeH
	push	eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 5906 :   acc_length += out->put((kdu_uint16) s_atk);

	push	DWORD PTR _s_atk$2$[ebp]
	mov	ecx, esi
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 5907 : 
; 5908 :   if (!reversible)

	cmp	BYTE PTR _reversible$[ebp], 0
	jne	$LN45@write_mark

; 5909 :     { // Calculate and write the K value
; 5910 :       double dc_gain=1.0, gain_p=1.0, gain_pp=1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000

; 5911 :       for (n_off=0, s=0; get(Ksteps,s,0,Ls); s++, n_off+=Ls)

	lea	eax, DWORD PTR _Ls$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, edi
	movsd	QWORD PTR _gain_p$1$[ebp], xmm0
	movsd	QWORD PTR _dc_gain$3$[ebp], xmm0
	mov	DWORD PTR _s$2$[ebp], 0
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN12@write_mark
	xor	esi, esi
$LL13@write_mark:

; 5912 :         {
; 5913 :           dc_gain = 0.0;
; 5914 :           for (n=0; n < Ls; n++)

	mov	eax, DWORD PTR _Ls$[ebp]
	xorps	xmm1, xmm1
	xor	ebx, ebx
	movsd	QWORD PTR _dc_gain$1$[ebp], xmm1
	test	eax, eax
	jle	SHORT $LN15@write_mark
	npad	6
$LL16@write_mark:

; 5915 :             {
; 5916 :               get(Kcoeffs,n_off+n,0,coeff);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _coeff$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	lea	eax, DWORD PTR [ebx+esi]
	push	eax
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	movss	xmm0, DWORD PTR _coeff$[ebp]
	inc	ebx
	mov	eax, DWORD PTR _Ls$[ebp]

; 5917 :               dc_gain += coeff;

	cvtps2pd xmm1, xmm0
	addsd	xmm1, QWORD PTR _dc_gain$1$[ebp]
	movsd	QWORD PTR _dc_gain$1$[ebp], xmm1
	cmp	ebx, eax
	jl	SHORT $LL16@write_mark
$LN15@write_mark:

; 5918 :             }
; 5919 :           dc_gain = gain_pp + dc_gain*gain_p;

	movsd	xmm2, QWORD PTR _gain_p$1$[ebp]
	add	esi, eax
	mov	ecx, DWORD PTR _s$2$[ebp]
	lea	eax, DWORD PTR _Ls$[ebp]
	push	1
	push	1
	movaps	xmm0, xmm2
	inc	ecx
	mulsd	xmm0, xmm1
	push	1
	push	eax
	push	0
	push	ecx
	addsd	xmm0, QWORD PTR _dc_gain$3$[ebp]
	mov	DWORD PTR _s$2$[ebp], ecx
	mov	ecx, edi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@

; 5920 :           gain_pp = gain_p;  gain_p = dc_gain;

	movsd	QWORD PTR _dc_gain$3$[ebp], xmm2
	movsd	QWORD PTR _gain_p$1$[ebp], xmm0
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL13@write_mark
	mov	esi, DWORD PTR _out$GSCopy$1$[ebp]
	mov	ebx, DWORD PTR _num_steps$1$[ebp]
$LN12@write_mark:

; 5921 :         }
; 5922 :       dc_gain = (s & 1)?gain_pp:gain_p;

	test	BYTE PTR _s$2$[ebp], 1
	je	SHORT $LN59@write_mark
	movsd	xmm0, QWORD PTR _dc_gain$3$[ebp]
	jmp	SHORT $LN60@write_mark
$LN59@write_mark:
	movsd	xmm0, QWORD PTR _gain_p$1$[ebp]
$LN60@write_mark:

; 5923 :       acc_length += out->put((float) dc_gain); // This is the K value

	cvtpd2ps xmm0, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 171  :         put(both.ival);

	mov	ecx, esi
	movss	DWORD PTR _both$7[ebp], xmm0
	push	DWORD PTR _both$7[ebp]
	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put
$LN45@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5926 :   if (num_steps > 255)

	cmp	ebx, 255				; 000000ffH
	jle	$LN46@write_mark

; 5927 :     { KDU_ERROR_DEV(e,0x20020701); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0EC@DFOKDDOA@Cannot?5write?5ATK?5?$CIarbitrary?5tran@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5927 :     { KDU_ERROR_DEV(e,0x20020701); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$4[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	ebx
	push	eax
	lea	eax, DWORD PTR _text$8[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$8[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	eax
	mov	eax, DWORD PTR _e$4[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0DI@KAHDNOFP@lifting?5steps?4?5?5Maximum?5number?5o@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5931 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN46@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN80@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN80@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5934 :   for (n_off=num_coeffs, s=num_steps-1; s >= 0; s--)

	add	ebx, -1
	mov	DWORD PTR _s$3$[ebp], ebx
	js	$LN18@write_mark
	npad	6
$LL19@write_mark:

; 5935 :     { // Write the parameters for each lifting step, in synthesis order
; 5936 :       get(Ksteps,s,0,Ls);  get(Ksteps,s,1,Ns);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Ls$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Ns$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 5937 :       get(Ksteps,s,2,Ds);  get(Ksteps,s,3,Rs);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Ds$[ebp]
	mov	ecx, edi
	push	eax
	push	2
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Rs$[ebp]
	mov	ecx, edi
	push	eax
	push	3
	push	ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 5938 :       if (!symmetric)

	cmp	BYTE PTR _symmetric$[ebp], 0
	jne	SHORT $LN47@write_mark

; 5939 :         {
; 5940 :           if ((Ns > 255) || (Ls > 255))

	mov	ebx, DWORD PTR _Ns$[ebp]
	cmp	ebx, 255				; 000000ffH
	jg	SHORT $LN49@write_mark
	cmp	DWORD PTR _Ls$[ebp], 255		; 000000ffH
	jle	SHORT $LN48@write_mark
$LN49@write_mark:

; 5941 :             { KDU_ERROR_DEV(e,0x20020702); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0JK@FJJJODFB@Cannot?5write?5ATK?5?$CIarbitrary?5tran@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5941 :             { KDU_ERROR_DEV(e,0x20020702); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5945 :             }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ebx, DWORD PTR _Ns$[ebp]
$LN48@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN85@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN85@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
$LN47@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5948 :       if (reversible)

	cmp	BYTE PTR _reversible$[ebp], 0
	je	SHORT $LN50@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5950 :           acc_length += out->put((kdu_byte) Ds);

	mov	bl, BYTE PTR _Ds$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN88@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN88@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5951 :           acc_length += out->put((kdu_uint16)(Rs & 0x00FFFF));

	movzx	ebx, WORD PTR _Rs$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN93@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN93@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN96@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN96@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
$LN50@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5953 :       if (symmetric)

	cmp	BYTE PTR _symmetric$[ebp], 0

; 5954 :         {
; 5955 :           if (Ls > 510)

	mov	ebx, DWORD PTR _Ls$[ebp]
	je	SHORT $LN51@write_mark
	cmp	ebx, 510				; 000001feH
	jle	SHORT $LN52@write_mark

; 5956 :             { KDU_ERROR_DEV(e,0x20020703); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0JA@OGLNENPI@Cannot?5write?5ATK?5?$CIarbitrary?5tran@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5956 :             { KDU_ERROR_DEV(e,0x20020703); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5960 :             }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ebx, DWORD PTR _Ls$[ebp]
$LN52@write_mark:

; 5961 :           Ls >>= 1; // Only write half the coefficients

	sar	ebx, 1
	mov	DWORD PTR _Ls$[ebp], ebx
$LN51@write_mark:

; 5963 :       n_off -= Ls;

	mov	ecx, DWORD PTR _n_off$3$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5963 :       n_off -= Ls;

	sub	ecx, ebx
	mov	DWORD PTR _n_off$3$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN101@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _n_off$3$[ebp]
$LN101@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5966 :       for (n=0; n < Ls; n++)

	xor	ebx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5966 :       for (n=0; n < Ls; n++)

	mov	eax, DWORD PTR _Ls$[ebp]
	test	eax, eax
	jle	$LN21@write_mark
$LL22@write_mark:

; 5967 :         {
; 5968 :           get(Kcoeffs,n_off+n,0,coeff);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _coeff$[ebp]
	push	eax
	push	0
	lea	eax, DWORD PTR [ebx+ecx]
	mov	ecx, edi
	push	eax
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 5969 :           if (reversible)

	cmp	BYTE PTR _reversible$[ebp], 0
	je	$LN53@write_mark

; 5970 :             {
; 5971 :               int ival = (int) floor(coeff*((float)(1<<Ds)) + 0.5F);

	mov	ecx, DWORD PTR _Ds$[ebp]
	mov	eax, 1
	shl	eax, cl
	sub	esp, 8
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR _coeff$[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv990[ebp], xmm0
	fld	QWORD PTR tv990[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv984[ebp]
	cvttsd2si eax, QWORD PTR tv984[ebp]
	add	esp, 8

; 5972 :               acc_length += out->put((kdu_uint16)(ival & 0x00FFFF));

	movzx	eax, ax
	mov	DWORD PTR _word$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN106@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN106@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, DWORD PTR _word$1$[ebp]
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN109@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN109@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR _word$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5974 :           else

	jmp	SHORT $LN20@write_mark
$LN53@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 170  :         both.fval = val;

	movss	xmm0, DWORD PTR _coeff$[ebp]

; 171  :         put(both.ival);

	mov	ecx, esi
	movss	DWORD PTR _both$6[ebp], xmm0
	push	DWORD PTR _both$6[ebp]
	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put
$LN20@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5966 :       for (n=0; n < Ls; n++)

	mov	eax, DWORD PTR _Ls$[ebp]
	inc	ebx
	mov	ecx, DWORD PTR _n_off$3$[ebp]
	cmp	ebx, eax
	jl	$LL22@write_mark
$LN21@write_mark:

; 5975 :             acc_length += out->put(coeff);
; 5976 :         }
; 5977 : 
; 5978 :       if (symmetric)

	cmp	BYTE PTR _symmetric$[ebp], 0
	je	SHORT $LN17@write_mark

; 5979 :         n_off -= Ls; // Skip over remaining ones

	sub	DWORD PTR _n_off$3$[ebp], eax
$LN17@write_mark:

; 5934 :   for (n_off=num_coeffs, s=num_steps-1; s >= 0; s--)

	mov	ebx, DWORD PTR _s$3$[ebp]
	sub	ebx, 1
	mov	DWORD PTR _s$3$[ebp], ebx
	jns	$LL19@write_mark
$LN18@write_mark:

; 5980 :     }
; 5981 : 
; 5982 :   assert(length == acc_length);
; 5983 :   return length;

	mov	eax, DWORD PTR _length$3$[ebp]
	jmp	SHORT $LN1@write_mark
$LN24@write_mark:

; 5815 :       (comp_idx >= 0))
; 5816 :     return 0;

	xor	eax, eax
$LN1@write_mark:

; 5984 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$2:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$3:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-216]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?write_marker_segment@atk_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ENDP ; atk_params::write_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?copy_with_xforms@atk_params@@MAEXPAVkdu_params@@HH_N11@Z
_TEXT	SEGMENT
_e$2 = -68						; size = 20
_Rs$ = -48						; size = 4
_Ds$ = -44						; size = 4
_extension$ = -40					; size = 4
_reversible$ = -36					; size = 1
_this$1$ = -32						; size = 4
_coeff$ = -28						; size = 4
_Ns$ = -24						; size = 4
_symmetric$ = -20					; size = 1
_Ls$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_source$ = 8						; size = 4
_flip_taps$1$ = 11					; size = 1
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_transpose$ = 20					; size = 1
_s$1$ = 24						; size = 4
_vflip$ = 24						; size = 1
_n_off$1$ = 28						; size = 4
_hflip$ = 28						; size = 1
?copy_with_xforms@atk_params@@MAEXPAVkdu_params@@HH_N11@Z PROC ; atk_params::copy_with_xforms, COMDAT
; _this$ = ecx

; 5467 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?copy_with_xforms@atk_params@@MAEXPAVkdu_params@@HH_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi

; 5468 :   bool reversible, symmetric;
; 5469 :   if (!source->get(Kreversible,0,0,reversible))

	mov	ebx, DWORD PTR _source$[ebp]
	lea	eax, DWORD PTR _reversible$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@OFOCCDJH@Kreversible?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN30@copy_with_

; 5470 :     return; // Nothing to copy
; 5471 :   if (!source->get(Ksymmetric,0,0,symmetric))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _symmetric$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@BNGLHLNI@Ksymmetric?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN10@copy_with_

; 5472 :     {
; 5473 :       source->finalize(false); // In case user forgot to finalize source params

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	push	0
	call	DWORD PTR [eax+32]

; 5474 :       if (!source->get(Ksymmetric,0,0,symmetric))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _symmetric$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@BNGLHLNI@Ksymmetric?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN30@copy_with_
$LN10@copy_with_:

; 5475 :         return; // Something wrong with the source
; 5476 :     }
; 5477 : 
; 5478 :   set(Kreversible,0,0,reversible);

	push	DWORD PTR _reversible$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_0M@OFOCCDJH@Kreversible?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 5479 :   set(Ksymmetric,0,0,symmetric);

	push	DWORD PTR _symmetric$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_0L@BNGLHLNI@Ksymmetric?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 5480 : 
; 5481 :   int extension;
; 5482 :   if (source->get(Kextension,0,0,extension))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _extension$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@JOGHAEOB@Kextension?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN11@copy_with_

; 5483 :     set(Kextension,0,0,extension);

	push	DWORD PTR _extension$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_0L@JOGHAEOB@Kextension?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN11@copy_with_:

; 5484 : 
; 5485 :   bool flip_taps = false;
; 5486 :   if ((vflip || hflip) && !symmetric)

	mov	cl, BYTE PTR _vflip$[ebp]
	mov	al, BYTE PTR _hflip$[ebp]
	mov	BYTE PTR _flip_taps$1$[ebp], 0
	test	cl, cl
	jne	SHORT $LN13@copy_with_
	test	al, al
	je	SHORT $LN14@copy_with_
$LN13@copy_with_:
	cmp	BYTE PTR _symmetric$[ebp], 0
	jne	SHORT $LN14@copy_with_

; 5487 :     {
; 5488 :       flip_taps = true;

	mov	BYTE PTR _flip_taps$1$[ebp], 1

; 5489 :       if (vflip != hflip)

	cmp	cl, al
	je	SHORT $LN14@copy_with_

; 5490 :         { KDU_ERROR(e,0x19050505); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BIA@GBIBAJFK@Cannot?5transpose?5ATK?5marker?5segm@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5490 :         { KDU_ERROR(e,0x19050505); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5499 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN14@copy_with_:

; 5500 :     }
; 5501 : 
; 5502 :   float coeff=0.0F;
; 5503 :   int s, n, n_off, Ls, Ns, Ds, Rs;
; 5504 :   for (s=0, n_off=0; source->get(Ksteps,s,0,Ls,false,false) &&
; 5505 :                      source->get(Ksteps,s,1,Ns,false,false) &&
; 5506 :                      source->get(Ksteps,s,2,Ds,false,false) &&

	push	1
	xor	edi, edi
	mov	DWORD PTR _coeff$[ebp], 0
	push	edi
	push	edi
	lea	eax, DWORD PTR _Ls$[ebp]
	mov	DWORD PTR _s$1$[ebp], 0
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, ebx
	mov	DWORD PTR _n_off$1$[ebp], edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN30@copy_with_
$LL4@copy_with_:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _Ns$[ebp]
	mov	ecx, ebx
	push	eax
	push	1
	push	DWORD PTR _s$1$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN30@copy_with_
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _Ds$[ebp]
	mov	ecx, ebx
	push	eax
	push	2
	push	DWORD PTR _s$1$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN30@copy_with_
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _Rs$[ebp]
	mov	ecx, ebx
	push	eax
	push	3
	push	DWORD PTR _s$1$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN30@copy_with_

; 5509 :     {
; 5510 :       if (flip_taps)

	cmp	BYTE PTR _flip_taps$1$[ebp], 0
	mov	edx, DWORD PTR _Ls$[ebp]
	je	SHORT $LN15@copy_with_

; 5511 :         Ns = -(Ns + Ls - 1) + 1-2*(s&1);

	mov	eax, DWORD PTR _s$1$[ebp]
	mov	ecx, 2
	and	eax, 1
	add	eax, eax
	sub	ecx, eax
	sub	ecx, DWORD PTR _Ns$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _Ns$[ebp], ecx
$LN15@copy_with_:

; 5512 :       set(Ksteps,s,0,Ls);

	push	edx
	push	0
	push	DWORD PTR _s$1$[ebp]
	mov	ecx, esi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5513 :       set(Ksteps,s,1,Ns);

	push	DWORD PTR _Ns$[ebp]
	mov	ecx, esi
	push	1
	push	DWORD PTR _s$1$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5514 :       set(Ksteps,s,2,Ds);

	push	DWORD PTR _Ds$[ebp]
	mov	ecx, esi
	push	2
	push	DWORD PTR _s$1$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5515 :       set(Ksteps,s,3,Rs);

	push	DWORD PTR _Rs$[ebp]
	mov	ecx, esi
	push	3
	push	DWORD PTR _s$1$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5516 :       for (n=0; n < Ls; n++)

	mov	eax, DWORD PTR _Ls$[ebp]
	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN2@copy_with_
$LL7@copy_with_:

; 5517 :         { // Copy the coefficients for this lifting step
; 5518 :           source->get(Kcoeffs,n_off+n,0,coeff);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _coeff$[ebp]
	add	edi, esi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	movss	xmm0, DWORD PTR _coeff$[ebp]

; 5519 :           if (flip_taps)
; 5520 :             set(Kcoeffs,n_off+Ls-1-n,0,coeff);

	sub	esp, 8
	cmp	BYTE PTR _flip_taps$1$[ebp], 0
	mov	ecx, DWORD PTR _this$1$[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	je	SHORT $LN16@copy_with_
	mov	eax, DWORD PTR _Ls$[ebp]
	mov	edi, DWORD PTR _n_off$1$[ebp]
	sub	eax, esi
	dec	eax
	add	eax, edi
	push	eax
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set

; 5521 :           else

	jmp	SHORT $LN5@copy_with_
$LN16@copy_with_:

; 5522 :             set(Kcoeffs,n_off+n,0,coeff);

	push	edi
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	mov	edi, DWORD PTR _n_off$1$[ebp]
$LN5@copy_with_:

; 5516 :       for (n=0; n < Ls; n++)

	mov	eax, DWORD PTR _Ls$[ebp]
	inc	esi
	cmp	esi, eax
	jl	SHORT $LL7@copy_with_
$LN2@copy_with_:

; 5507 :                      source->get(Ksteps,s,3,Rs,false,false);
; 5508 :        s++, n_off+=Ls)

	mov	ecx, DWORD PTR _s$1$[ebp]
	add	edi, eax
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _Ls$[ebp]
	mov	DWORD PTR _n_off$1$[ebp], edi
	push	eax
	inc	ecx
	push	0
	push	ecx
	mov	DWORD PTR _s$1$[ebp], ecx
	mov	ecx, ebx
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	esi, DWORD PTR _this$1$[ebp]
	test	al, al
	jne	$LL4@copy_with_
$LN30@copy_with_:

; 5523 :         }
; 5524 :     }
; 5525 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?copy_with_xforms@atk_params@@MAEXPAVkdu_params@@HH_N11@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?copy_with_xforms@atk_params@@MAEXPAVkdu_params@@HH_N11@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?copy_with_xforms@atk_params@@MAEXPAVkdu_params@@HH_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?copy_with_xforms@atk_params@@MAEXPAVkdu_params@@HH_N11@Z ENDP ; atk_params::copy_with_xforms
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?finalize@atk_params@@MAEX_N@Z
_TEXT	SEGMENT
_e$2 = -116						; size = 20
_e$3 = -96						; size = 20
_e$4 = -96						; size = 20
_e$5 = -96						; size = 20
_e$6 = -96						; size = 20
_e$7 = -96						; size = 20
_e$8 = -96						; size = 20
_e$9 = -96						; size = 20
_gain_p$1$ = -76					; size = 8
_dc_gain$3$ = -68					; size = 8
_dc_gain$1$ = -60					; size = 8
_is_symmetric$ = -52					; size = 1
_sym_coeff$10 = -52					; size = 4
_Ns$ = -48						; size = 4
_Rs$ = -44						; size = 4
_extension$ = -40					; size = 4
_Ds$ = -36						; size = 4
tv570 = -32						; size = 4
_s$1$ = -32						; size = 4
_coeff$ = -28						; size = 4
_n_off$1$ = -24						; size = 4
_Ls$ = -20						; size = 4
_check_symmetric$ = -15					; size = 1
_reversible$ = -14					; size = 1
_is_symmetric$1$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_after_reading$ = 8					; size = 1
?finalize@atk_params@@MAEX_N@Z PROC			; atk_params::finalize, COMDAT
; _this$ = ecx

; 5533 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?finalize@atk_params@@MAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 5534 :   int s=0, n, n_off, Ls, Ns, Ds, Rs;
; 5535 :   float coeff;
; 5536 :   bool reversible;
; 5537 :   if (!get(Kreversible,0,0,reversible))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _reversible$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@OFOCCDJH@Kreversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN10@finalize

; 5538 :     {
; 5539 :       if (get(Ksteps,0,0,Ls) || get(Kcoeffs,0,0,coeff))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Ls$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN11@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _coeff$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	$LN31@finalize
$LN11@finalize:

; 5540 :         { KDU_ERROR(e,23050500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$9[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0IK@HMACHLFE@You?5cannot?5provide?5custom?5transf@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5540 :         { KDU_ERROR(e,23050500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5544 :         }

	lea	ecx, DWORD PTR _e$9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN10@finalize:

; 5545 :       else
; 5546 :         return; // Nothing here
; 5547 :     }
; 5548 : 
; 5549 :   // Check lifting step information
; 5550 :   bool is_symmetric = true; // Until proven otherwise
; 5551 :   double dc_gain=1.0, gain_p=1.0, gain_pp=1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000

; 5552 :   for (n_off=0, s=0; get(Ksteps,s,0,Ls); s++, n_off+=Ls)

	lea	eax, DWORD PTR _Ls$[ebp]
	push	1
	push	1
	push	1
	xor	edi, edi
	mov	BYTE PTR _is_symmetric$1$[ebp], 1
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, ebx
	movsd	QWORD PTR _gain_p$1$[ebp], xmm0
	movsd	QWORD PTR _dc_gain$3$[ebp], xmm0
	mov	DWORD PTR _n_off$1$[ebp], edi
	mov	DWORD PTR _s$1$[ebp], edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN3@finalize
$LL4@finalize:

; 5553 :     {
; 5554 :       if (!(get(Ksteps,s,1,Ns) && get(Ksteps,s,2,Ds) && get(Ksteps,s,3,Rs)))

	mov	esi, DWORD PTR _s$1$[ebp]
	lea	eax, DWORD PTR _Ns$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	esi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN13@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Ds$[ebp]
	mov	ecx, ebx
	push	eax
	push	2
	push	esi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN13@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Rs$[ebp]
	mov	ecx, ebx
	push	eax
	push	3
	push	esi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN12@finalize
$LN13@finalize:

; 5555 :         { KDU_ERROR(e,0x20050501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0GB@HNGPDMEK@Incomplete?5?$GAKsteps?8?5record?5?$CIneed@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5555 :         { KDU_ERROR(e,0x20050501); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5558 :         }

	lea	ecx, DWORD PTR _e$8[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN12@finalize:

; 5559 :       if ((Ds < 0) || (Ds > 24))

	mov	eax, DWORD PTR _Ds$[ebp]
	test	eax, eax
	js	SHORT $LN15@finalize
	cmp	eax, 24					; 00000018H
	jle	SHORT $LN14@finalize
$LN15@finalize:

; 5560 :         { KDU_ERROR(e,0x20050502); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$7[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_0IB@GILFGDAI@Invalid?5downshifting?5value?5?$CI3?8rd@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5560 :         { KDU_ERROR(e,0x20050502); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5564 :         }

	lea	ecx, DWORD PTR _e$7[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _Ds$[ebp]
$LN14@finalize:

; 5565 :       if ((!reversible) && ((Ds > 0) || (Rs > 0)))

	cmp	BYTE PTR _reversible$[ebp], 0
	jne	SHORT $LN16@finalize
	test	eax, eax
	jg	SHORT $LN17@finalize
	cmp	DWORD PTR _Rs$[ebp], 0
	jle	SHORT $LN16@finalize
$LN17@finalize:

; 5566 :         { KDU_ERROR(e,0x23050501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$6[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	OFFSET ??_C@_0IK@EBAJKINC@For?5irreversible?5transforms?5?$CI?$GAKr@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5566 :         { KDU_ERROR(e,0x23050501); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5570 :         }

	lea	ecx, DWORD PTR _e$6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN16@finalize:

; 5571 :       if ((Ls & 1) || (Ns != -((Ls + (s&1)-1)>>1)))

	mov	ecx, DWORD PTR _Ls$[ebp]
	test	cl, 1
	jne	SHORT $LN19@finalize
	mov	eax, esi
	and	eax, 1
	dec	eax
	add	eax, ecx
	sar	eax, 1
	neg	eax
	cmp	DWORD PTR _Ns$[ebp], eax
	je	SHORT $LN18@finalize
$LN19@finalize:

; 5572 :         is_symmetric = false;

	mov	BYTE PTR _is_symmetric$1$[ebp], 0
$LN18@finalize:
	xorps	xmm0, xmm0

; 5575 :       for (n=0; n < Ls; n++)

	xor	esi, esi
	movsd	QWORD PTR _dc_gain$1$[ebp], xmm0
	test	ecx, ecx
	jle	$LN6@finalize

; 5573 : 
; 5574 :       dc_gain = 0.0;

	mov	eax, DWORD PTR _n_off$1$[ebp]
	mov	edi, eax
$LL7@finalize:

; 5576 :         {
; 5577 :           if (!get(Kcoeffs,n_off+n,0,coeff))

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _coeff$[ebp]
	add	eax, esi
	push	ecx
	push	0
	push	eax
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN20@finalize

; 5578 :             { KDU_ERROR(e,0x20050503); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0LL@ICCFCJEB@Insufficient?5?$GAKcoeffs?8?5records?5f@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5578 :             { KDU_ERROR(e,0x20050503); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5584 :             }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN20@finalize:

; 5585 :           dc_gain += coeff;
; 5586 :           if (is_symmetric && (n < (Ls>>1)))

	cmp	BYTE PTR _is_symmetric$1$[ebp], 0
	movss	xmm0, DWORD PTR _coeff$[ebp]
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR _dc_gain$1$[ebp]
	movsd	QWORD PTR _dc_gain$1$[ebp], xmm0
	je	SHORT $LN67@finalize
	mov	ecx, DWORD PTR _Ls$[ebp]
	mov	eax, ecx
	sar	eax, 1
	cmp	esi, eax
	jge	SHORT $LN5@finalize

; 5587 :             {
; 5588 :               float sym_coeff;
; 5589 :               if (!(get(Kcoeffs,n_off+Ls-1-n,0,sym_coeff) &&

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _sym_coeff$10[ebp]
	push	eax
	lea	eax, DWORD PTR [ecx-1]
	mov	ecx, ebx
	push	0
	add	eax, edi
	push	eax
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN23@finalize
	movss	xmm0, DWORD PTR _coeff$[ebp]
	ucomiss	xmm0, DWORD PTR _sym_coeff$10[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN67@finalize
$LN23@finalize:

; 5590 :                     (coeff == sym_coeff)))
; 5591 :                 is_symmetric = false;

	mov	BYTE PTR _is_symmetric$1$[ebp], 0
$LN67@finalize:
	mov	ecx, DWORD PTR _Ls$[ebp]
$LN5@finalize:

; 5575 :       for (n=0; n < Ls; n++)

	mov	eax, DWORD PTR _n_off$1$[ebp]
	inc	esi
	dec	edi
	cmp	esi, ecx
	jl	$LL7@finalize
	mov	edi, eax
$LN6@finalize:

; 5592 :             }
; 5593 :         }
; 5594 :       dc_gain = gain_pp + dc_gain*gain_p;

	movsd	xmm1, QWORD PTR _gain_p$1$[ebp]
	add	edi, ecx
	mov	eax, DWORD PTR _s$1$[ebp]
	lea	ecx, DWORD PTR _Ls$[ebp]
	push	1
	push	1
	movaps	xmm0, xmm1
	mov	DWORD PTR _n_off$1$[ebp], edi
	mulsd	xmm0, QWORD PTR _dc_gain$1$[ebp]
	inc	eax
	push	1
	push	ecx
	push	0
	push	eax
	addsd	xmm0, QWORD PTR _dc_gain$3$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, ebx

; 5595 :       gain_pp = gain_p;  gain_p = dc_gain;

	movsd	QWORD PTR _dc_gain$3$[ebp], xmm1
	mov	DWORD PTR _s$1$[ebp], eax
	movsd	QWORD PTR _gain_p$1$[ebp], xmm0
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL4@finalize
$LN3@finalize:

; 5596 :     }
; 5597 :   if (get(Kcoeffs,n_off,0,coeff))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _coeff$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN24@finalize

; 5598 :     { KDU_ERROR(e,0x20050504); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0LH@KFFJGFML@Too?5many?5?$GAKcoeffs?8?5records?5found@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5598 :     { KDU_ERROR(e,0x20050504); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5603 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN24@finalize:

; 5604 : 
; 5605 :   dc_gain = (s & 1)?gain_pp:gain_p;

	test	BYTE PTR _s$1$[ebp], 1
	je	SHORT $LN33@finalize
	movsd	xmm1, QWORD PTR _dc_gain$3$[ebp]
	jmp	SHORT $LN34@finalize
$LN33@finalize:
	movsd	xmm1, QWORD PTR _gain_p$1$[ebp]
$LN34@finalize:

; 5606 :   if (reversible && ((dc_gain > 1.001) || (dc_gain < 0.999)))

	cmp	BYTE PTR _reversible$[ebp], 0
	je	SHORT $LN25@finalize
	comisd	xmm1, QWORD PTR __real@3ff004189374bc6a
	ja	SHORT $LN26@finalize
	movsd	xmm0, QWORD PTR __real@3feff7ced916872b
	comisd	xmm0, xmm1
	jbe	SHORT $LN25@finalize
$LN26@finalize:

; 5607 :     { KDU_ERROR(e,0x20050505); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0HP@IHFGAOCO@Reversible?5lifting?5steps?5defined@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5607 :     { KDU_ERROR(e,0x20050505); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5611 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN25@finalize:

; 5612 : 
; 5613 :   int extension;
; 5614 :   if (!get(Kextension,0,0,extension))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _extension$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@JOGHAEOB@Kextension?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN27@finalize

; 5615 :     set(Kextension,0,0,

	xor	eax, eax
	mov	ecx, ebx
	cmp	BYTE PTR _is_symmetric$1$[ebp], al
	setne	al
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@JOGHAEOB@Kextension?$AA@
	mov	DWORD PTR _extension$[ebp], eax
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN27@finalize:

; 5616 :         extension=((is_symmetric)?Kextension_SYM:Kextension_CON));
; 5617 :   if (extension != Kextension_SYM)

	movzx	eax, BYTE PTR _is_symmetric$1$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR _extension$[ebp], 1

; 5618 :     is_symmetric = false;
; 5619 :  
; 5620 :   bool check_symmetric;
; 5621 :   if (!get(Ksymmetric,0,0,check_symmetric,false))

	push	1
	cmovne	eax, ecx
	push	1
	push	ecx
	mov	DWORD PTR tv570[ebp], eax
	mov	BYTE PTR _is_symmetric$[ebp], al
	lea	eax, DWORD PTR _check_symmetric$[ebp]
	push	eax
	push	ecx
	push	ecx
	push	OFFSET ??_C@_0L@BNGLHLNI@Ksymmetric?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN29@finalize

; 5622 :     set(Ksymmetric,0,0,is_symmetric);

	push	DWORD PTR _is_symmetric$[ebp]
	mov	ecx, ebx
	push	0
	push	0
	push	OFFSET ??_C@_0L@BNGLHLNI@Ksymmetric?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 5631 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN29@finalize:

; 5623 :   else if (check_symmetric && !is_symmetric)

	cmp	BYTE PTR _check_symmetric$[ebp], 0
	je	SHORT $LN31@finalize
	cmp	BYTE PTR tv570[ebp], 0
	jne	SHORT $LN31@finalize

; 5624 :     { KDU_ERROR(e,0x20050509); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0OH@MFIHEDLO@Invalid?5?$GAKsymmetric?8?5value?5found@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5624 :     { KDU_ERROR(e,0x20050509); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5630 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN31@finalize:

; 5631 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$0:
	lea	ecx, DWORD PTR _e$9[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$1:
	lea	ecx, DWORD PTR _e$8[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$2:
	lea	ecx, DWORD PTR _e$7[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$3:
	lea	ecx, DWORD PTR _e$6[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$4:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$5:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$6:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@atk_params@@MAEX_N@Z$7:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?finalize@atk_params@@MAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?finalize@atk_params@@MAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?finalize@atk_params@@MAEX_N@Z ENDP			; atk_params::finalize
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?new_object@atk_params@@MAEPAVkdu_params@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_object@atk_params@@MAEPAVkdu_params@@XZ PROC	; atk_params::new_object, COMDAT
; _this$ = ecx

; 2521 :     virtual kdu_params *new_object() { return new atk_params(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_object@atk_params@@MAEPAVkdu_params@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_object
	mov	ecx, eax
	call	??0atk_params@@QAE@XZ			; atk_params::atk_params
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_object:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_object@atk_params@@MAEPAVkdu_params@@XZ$0:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?new_object@atk_params@@MAEPAVkdu_params@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_object@atk_params@@MAEPAVkdu_params@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_object@atk_params@@MAEPAVkdu_params@@XZ ENDP	; atk_params::new_object
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0atk_params@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0atk_params@@QAE@XZ PROC				; atk_params::atk_params, COMDAT
; _this$ = ecx

; 5381 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0atk_params@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 5380 :   : kdu_params(ATK_params,true,false,true,false,true)

	push	1
	push	0
	push	1
	push	0
	push	1
	push	OFFSET ??_C@_03IFCLAPBJ@ATK?$AA@
	call	??0kdu_params@@QAE@PBD_N1111@Z		; kdu_params::kdu_params

; 5382 :   define_attribute(Kreversible,

	push	0
	push	OFFSET ??_C@_01HMGJMAIH@B?$AA@
	push	OFFSET ??_C@_0CGL@OFBGPMKE@This?5attribute?5determines?5how?5th@
	push	OFFSET ??_C@_0M@OFOCCDJH@Kreversible?$AA@
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7atk_params@@6B@
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 5383 :      "This attribute determines how the `Ksteps' and `Kcoeffs' attributes "
; 5384 :      "should be treated.  In the end, this parameter attribute must agree "
; 5385 :      "with the value of the `Creversible' attribute, for any tile-component "
; 5386 :      "which uses this transformation kernel.  However this consistency "
; 5387 :      "may be created by specifying `Kreversible' and leaving `Creversible' "
; 5388 :      "unspecified, so that an appropriate default value will be selected.\n"
; 5389 :      "\t\t[A default value cannot be created automatically, so you must "
; 5390 :      "explicitly specify a value if you want ATK information to become "
; 5391 :      "available for any particular instance index in the main header "
; 5392 :      "or a tile header.]",
; 5393 :      "B");
; 5394 : 
; 5395 :   define_attribute(Ksymmetric,

	push	0
	push	OFFSET ??_C@_01HMGJMAIH@B?$AA@
	push	OFFSET ??_C@_0COP@MOCEJKKL@If?5true?0?5the?5transform?5kernel?5be@
	push	OFFSET ??_C@_0L@BNGLHLNI@Ksymmetric?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 5396 :      "If true, the transform kernel belongs to the whole-sample "
; 5397 :      "symmetric class, which is treated specially by JPEG2000 Part-2.  "
; 5398 :      "The translated impulse responses of these kernels are all "
; 5399 :      "symmetric about 0 -- see the Taubman & Marcellin book, Chapter 6, "
; 5400 :      "for a definition of translated impulse responses.  Equivalently, "
; 5401 :      "all lifting steps involve even-length symmetric lifting coefficients, "
; 5402 :      "Cs[n], where the coefficients associated with steps s=0, 2, 4, ... "
; 5403 :      "are symmetric about n = 1/2 and the coefficients associated with "
; 5404 :      "steps s=1, 3, 5, ... are symmetric about n = -1/2.\n"
; 5405 :      "\t\t[If you do not explicitly specify this attribute, it will be "
; 5406 :      "determined automatically from the lifting coefficient values "
; 5407 :      "supplied via `Krev_coeffs' or `Kirv_coeffs', as appropriate.]",
; 5408 :      "B");
; 5409 : 
; 5410 :   define_attribute(Kextension,

	push	0
	push	OFFSET ??_C@_0O@PBGDLPEF@?$CICON?$DN0?0SYM?$DN1?$CJ?$AA@
	push	OFFSET ??_C@_0CNF@DACPPFDL@Identifies?5the?5boundary?5extensio@
	push	OFFSET ??_C@_0L@JOGHAEOB@Kextension?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 5411 :      "Identifies the boundary extension method to be applied in each "
; 5412 :      "lifting step.  If `CON', boundary samples are simply replicated.  "
; 5413 :      "The other possible value, `SYM', means that boundary samples "
; 5414 :      "are symmetrically extended.  The centre of symmetry in this case "
; 5415 :      "is the boundary sample location within an interleaved representation "
; 5416 :      "in which low-pass samples occupy the even indexed locations and "
; 5417 :      "high-pass samples occupy the odd indexed locations.  The `SYM' "
; 5418 :      "method must be used if `Ksymmetric' is true.  Conversely, for "
; 5419 :      "filters which do not have the whole-sample symmetric property, "
; 5420 :      "you are strongly recommended to use the `CON' extension method.\n"
; 5421 :      "\t\t[Defaults to `SYM' if the filters are whole-sample symmetric "
; 5422 :      "and `CON' otherwise.]",
; 5423 :      "(CON=0,SYM=1)");
; 5424 : 
; 5425 :   define_attribute(Ksteps,

	push	1
	push	OFFSET ??_C@_04NENCGHGO@IIII?$AA@
	push	OFFSET ??_C@_0DMN@NFEELAKF@Array?5with?5one?5entry?5for?5each?5li@
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 5426 :      "Array with one entry for each lifting step.  The first entry "
; 5427 :      "corrsponds to lifting step s=0, which updates odd indexed samples, "
; 5428 :      "based on even indexed samples; the second entry corresponds to "
; 5429 :      "lifting step s=1, which updates even indexed samples, based on "
; 5430 :      "odd indexed samples; and so forth.  The first field in each record "
; 5431 :      "holds the length, Ls, of the coefficient array Cs[n], for the "
; 5432 :      "relevant step s.  The second field is the location of the first "
; 5433 :      "entry, Ns, where Cs[n] is defined for n=Ns to Ns+Ls-1.  The value "
; 5434 :      "of Ns is typically negative, but need not be.  For symmetric "
; 5435 :      "kernels, Ls must be even and Ns must satisfy Ns=-floor((Ls+p-1)/2), "
; 5436 :      "where p is the lifting step parity (0 if s is even, 1 if s is odd).  "
; 5437 :      "The third and fourth fields must both be 0 if `Kreversible' is "
; 5438 :      "false.  For reversible transform kernels, however, the third "
; 5439 :      "field holds the downshift value, Ds, while the fourth field holds "
; 5440 :      "the rounding offset, Rs, to be added immediately prior to "
; 5441 :      "downshifting.",
; 5442 :      "IIII",MULTI_RECORD);
; 5443 : 
; 5444 :   define_attribute(Kcoeffs,

	push	1
	push	OFFSET ??_C@_01BIAFAFID@F?$AA@
	push	OFFSET ??_C@_0CIE@OIBNHEMA@Holds?5the?5lifting?5coefficients?0?5@
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 5445 :      "Holds the lifting coefficients, Cs[n].  The first L0 records "
; 5446 :      "describe the coefficients of the first lifting step.  These are "
; 5447 :      "followed by the L1 coefficients of the second lifting step, and "
; 5448 :      "so forth.  The Ls values are identified by the first field in "
; 5449 :      "each `Ksteps' record.  Lifting step s may be described by "
; 5450 :      "X_s[2k+1-p] += TRUNC(sum_{Ns<=n<Ns+Ls} Cs[n]*X_{s-1}[2k+p+2n]).  "
; 5451 :      "In the case of an irreversible transform, the TRUNC operator "
; 5452 :      "does nothing and all arithmetic is performed (at least "
; 5453 :      "notionally) in floating point.  For reversible transforms, "
; 5454 :      "TRUNC(a) = floor(a + Rs*2^{-Ds}) and Cs[n] is guaranteed to be "
; 5455 :      "an integer multiple of 2^{-Ds}.",
; 5456 :      "F",MULTI_RECORD);
; 5457 : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0atk_params@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
__ehhandler$??0atk_params@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0atk_params@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0atk_params@@QAE@XZ ENDP				; atk_params::atk_params
; Function compile flags: /Ogtp
;	COMDAT ??_Gmco_params@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gmco_params@@UAEPAXI@Z PROC				; mco_params::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gmco_params@@UAEPAXI@Z ENDP				; mco_params::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1mco_params@@UAE@XZ
_TEXT	SEGMENT
??1mco_params@@UAE@XZ PROC				; mco_params::~mco_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1mco_params@@UAE@XZ ENDP				; mco_params::~mco_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?read_marker_segment@mco_params@@MAE_NGHQAEH@Z
_TEXT	SEGMENT
_e$2 = -156						; size = 20
_e$3 = -136						; size = 20
_this$GSCopy$1$ = -116					; size = 4
$T4 = -112						; size = 4
_num_stages$1$ = -108					; size = 4
$T5 = -104						; size = 4
_text$6 = -100						; size = 80
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_tpart_idx$ = 20					; size = 4
?read_marker_segment@mco_params@@MAE_NGHQAEH@Z PROC	; mco_params::read_marker_segment, COMDAT
; _this$ = ecx

; 5283 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx

; 5284 :   kdu_byte *bp, *end;
; 5285 : 
; 5286 :   if (tpart_idx != 0)

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	mov	eax, DWORD PTR _num_bytes$[ebp]
	mov	esi, DWORD PTR _bytes$[ebp]
	je	SHORT $LN5@read_marke

; 5287 :     return false;

	xor	al, al
	jmp	$LN1@read_marke
$LN5@read_marke:

; 5288 :   bp = bytes;
; 5289 :   end = bp + num_bytes;

	lea	ebx, DWORD PTR [esi+eax]

; 5290 :   try {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN16@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T5[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN41@read_marke:
$LN16@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5292 :       set(Mnum_stages,0,0,num_stages);

	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@BMJAMMCN@Mnum_stages?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _num_stages$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5292 :       set(Mnum_stages,0,0,num_stages);

	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5293 :       for (n=0; n < num_stages; n++)

	xor	edi, edi
$LL4@read_marke:
	cmp	edi, DWORD PTR _num_stages$1$[ebp]
	jge	SHORT $LN3@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ebx
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN23@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T4[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN42@read_marke:
$LN23@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5296 :           set(Mstages,n,0,idx);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_07CNNLMAHC@Mstages?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	inc	edi
	jmp	SHORT $LL4@read_marke
$LN3@read_marke:

; 5297 :         }
; 5298 :       if (bp != end)

	cmp	esi, ebx
	je	SHORT $LN14@read_marke

; 5299 :         { KDU_ERROR(e,0x21070512); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0DF@IOEIPGFI@Malformed?5MCO?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5299 :         { KDU_ERROR(e,0x21070512); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5301 :             << (int)(end-bp) <<

	sub	ebx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	BYTE PTR _e$3[ebp+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	ebx
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$6[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$6[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5303 :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN14@read_marke:

; 5310 :   return true;

	mov	al, 1
$LN1@read_marke:

; 5311 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
__catch$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z$0:

; 5306 :     { KDU_ERROR(e,0x21070513); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EH@FMIBNLCC@Malformed?5MCO?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5306 :     { KDU_ERROR(e,0x21070513); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5309 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN14@read_marke
	ret	0
$LN40@read_marke:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z$2:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z$3:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_marker_segment@mco_params@@MAE_NGHQAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_marker_segment@mco_params@@MAE_NGHQAEH@Z ENDP	; mco_params::read_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?check_marker_segment@mco_params@@MAE_NGHQAEAAH@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_c_idx$ = 20						; size = 4
?check_marker_segment@mco_params@@MAE_NGHQAEAAH@Z PROC	; mco_params::check_marker_segment, COMDAT
; _this$ = ecx

; 5235 : {

	push	ebp
	mov	ebp, esp

; 5236 :   c_idx = -1;

	mov	eax, DWORD PTR _c_idx$[ebp]

; 5237 :   return (code == KDU_MCO);

	mov	ecx, 65399				; 0000ff77H
	mov	DWORD PTR [eax], -1
	xor	eax, eax
	cmp	WORD PTR _code$[ebp], cx
	sete	al

; 5238 : }

	pop	ebp
	ret	16					; 00000010H
?check_marker_segment@mco_params@@MAE_NGHQAEAAH@Z ENDP	; mco_params::check_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?write_marker_segment@mco_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
_TEXT	SEGMENT
_e$2 = -48						; size = 20
_val$3 = -28						; size = 4
_length$1$ = -24					; size = 4
_val$4 = -24						; size = 4
_idx$ = -20						; size = 4
_num_stages$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_out$ = 8						; size = 4
_last_marked$ = 12					; size = 4
_byte$1$ = 15						; size = 1
_byte$1$ = 15						; size = 1
_tpart_idx$ = 16					; size = 4
?write_marker_segment@mco_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z PROC ; mco_params::write_marker_segment, COMDAT
; _this$ = ecx

; 5320 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?write_marker_segment@mco_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 5321 :   mco_params *ref = (mco_params *) last_marked;
; 5322 :   if ((inst_idx != 0) || (comp_idx >= 0))

	cmp	DWORD PTR [ebx+16], 0
	jne	$LN9@write_mark
	cmp	DWORD PTR [ebx+12], 0
	jge	$LN9@write_mark

; 5324 : 
; 5325 :   int n, idx=0, num_stages;
; 5326 :   if (!get(Mnum_stages,0,0,num_stages,false))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _num_stages$[ebp]
	mov	DWORD PTR _idx$[ebp], 0
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@BMJAMMCN@Mnum_stages?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN9@write_mark

; 5327 :     return 0;
; 5328 : 
; 5329 :   if (num_stages > 255)

	mov	esi, DWORD PTR _num_stages$[ebp]
	cmp	esi, 255				; 000000ffH
	jle	SHORT $LN11@write_mark

; 5330 :     { KDU_ERROR(e,0x21070514); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EP@OLCFAFPF@Cannot?5write?5MCO?5marker?5segment?$DL@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5330 :     { KDU_ERROR(e,0x21070514); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5333 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	esi, DWORD PTR _num_stages$[ebp]
$LN11@write_mark:

; 5334 : 
; 5335 :   if (ref != NULL)

	mov	eax, DWORD PTR _last_marked$[ebp]
	test	eax, eax
	je	$LN16@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _val$4[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0M@BMJAMMCN@Mnum_stages?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN48@write_mark
	cmp	DWORD PTR _val$4[ebp], esi
	jne	SHORT $LN48@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5339 :           for (n=0; n < num_stages; n++)

	mov	esi, DWORD PTR _num_stages$[ebp]
	xor	edi, edi
	test	esi, esi
	jle	SHORT $LN28@write_mark
	npad	5
$LL4@write_mark:

; 5340 :             {
; 5341 :               if (!get(Mstages,n,0,idx))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _idx$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_07CNNLMAHC@Mstages?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	mov	ecx, DWORD PTR _last_marked$[ebp]
	lea	eax, DWORD PTR _val$3[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5343 :               if (!ref->compare(Mstages,n,0,idx))

	mov	esi, DWORD PTR _idx$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	push	1
	push	1
	push	1
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_07CNNLMAHC@Mstages?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN47@write_mark
	cmp	DWORD PTR _val$3[ebp], esi
	jne	SHORT $LN47@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5339 :           for (n=0; n < num_stages; n++)

	mov	esi, DWORD PTR _num_stages$[ebp]
	inc	edi
	cmp	edi, esi
	jl	SHORT $LL4@write_mark
	jmp	SHORT $LN28@write_mark
$LN47@write_mark:
	mov	esi, DWORD PTR _num_stages$[ebp]
$LN28@write_mark:

; 5344 :                 break;
; 5345 :             }
; 5346 :           if (n == num_stages)

	cmp	edi, esi
	jne	SHORT $LN16@write_mark
$LN9@write_mark:

; 5323 :     return 0;

	xor	eax, eax

; 5368 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN48@write_mark:

; 5347 :             return 0; // Object identical to reference

	mov	esi, DWORD PTR _num_stages$[ebp]
$LN16@write_mark:

; 5348 :         }
; 5349 :     }
; 5350 : 
; 5351 :   // We are now committed to writing (or simulating) a marker segment.
; 5352 :   int length = 4 + 1 + num_stages;

	lea	edi, DWORD PTR [esi+5]

; 5353 :   if (out == NULL)

	mov	esi, DWORD PTR _out$[ebp]
	mov	DWORD PTR _length$1$[ebp], edi
	test	esi, esi
	jne	SHORT $LN17@write_mark

; 5354 :     return length;

	mov	eax, edi

; 5368 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN17@write_mark:

; 5355 : 
; 5356 :   // If we get here, we are committed to actually writing the marker segment
; 5357 :   int acc_length = 0; // Accumulate actual length for verification purposes.
; 5358 :   acc_length += out->put(KDU_MCO);

	push	65399					; 0000ff77H
	mov	ecx, esi
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 5359 :   acc_length += out->put((kdu_uint16)(length-2));

	lea	eax, DWORD PTR [edi-2]
	mov	ecx, esi
	push	eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 5360 :   acc_length += out->put((kdu_byte) num_stages);

	mov	al, BYTE PTR _num_stages$[ebp]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN31@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN31@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5361 :   for (n=0; n < num_stages; n++)

	xor	edi, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5361 :   for (n=0; n < num_stages; n++)

	cmp	DWORD PTR _num_stages$[ebp], edi
	jle	SHORT $LN6@write_mark
$LL7@write_mark:

; 5362 :     {
; 5363 :       get(Mstages,n,0,idx);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _idx$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_07CNNLMAHC@Mstages?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 5364 :       acc_length += out->put((kdu_byte) idx);

	mov	al, BYTE PTR _idx$[ebp]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN34@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN34@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5361 :   for (n=0; n < num_stages; n++)

	inc	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5361 :   for (n=0; n < num_stages; n++)

	cmp	edi, DWORD PTR _num_stages$[ebp]
	jl	SHORT $LL7@write_mark
$LN6@write_mark:

; 5365 :     }
; 5366 :   assert(length == acc_length);
; 5367 :   return length;

	mov	eax, DWORD PTR _length$1$[ebp]

; 5368 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?write_marker_segment@mco_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?write_marker_segment@mco_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?write_marker_segment@mco_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?write_marker_segment@mco_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ENDP ; mco_params::write_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?copy_with_xforms@mco_params@@MAEXPAVkdu_params@@HH_N11@Z
_TEXT	SEGMENT
_e$2 = -56						; size = 20
_dummy_val$3 = -36					; size = 4
_stage_idx$ = -32					; size = 4
_num_stages$ = -28					; size = 4
_this$1$ = -24						; size = 4
_old_components$ = -20					; size = 4
_new_components$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_source$ = 8						; size = 4
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_transpose$ = 20					; size = 1
_vflip$ = 24						; size = 1
_hflip$ = 28						; size = 1
?copy_with_xforms@mco_params@@MAEXPAVkdu_params@@HH_N11@Z PROC ; mco_params::copy_with_xforms, COMDAT
; _this$ = ecx

; 5148 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?copy_with_xforms@mco_params@@MAEXPAVkdu_params@@HH_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 5149 :   int num_stages;
; 5150 :   int n, stage_idx;
; 5151 : 
; 5152 :   if (!source->get(Mnum_stages,0,0,num_stages))

	mov	esi, DWORD PTR _source$[ebp]
	lea	eax, DWORD PTR _num_stages$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@BMJAMMCN@Mnum_stages?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN8@copy_with_

; 5153 :     return;
; 5154 : 
; 5155 :   // We may need to create an extra transform stage to account for lost
; 5156 :   // codestream image components.
; 5157 :   int old_components=1, new_components=1;
; 5158 :   kdu_params *siz = access_cluster(SIZ_params);

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	mov	ecx, ebx
	mov	DWORD PTR _old_components$[ebp], 1
	mov	DWORD PTR _new_components$[ebp], 1
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 5159 :   kdu_params *source_siz = source->access_cluster(SIZ_params);

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	mov	ecx, esi
	mov	edi, eax
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	esi, eax

; 5160 :   if (siz != NULL)

	test	edi, edi
	je	SHORT $LN11@copy_with_

; 5161 :     siz->get(Scomponents,0,0,new_components);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _new_components$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@LFKICJFJ@Scomponents?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN11@copy_with_:

; 5162 :   if (source_siz != NULL)

	test	esi, esi
	je	SHORT $LN12@copy_with_

; 5163 :     source_siz->get(Scomponents,0,0,old_components);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _old_components$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@LFKICJFJ@Scomponents?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN12@copy_with_:

; 5164 :   int extra_output_stages = 0;

	xor	edi, edi

; 5165 :   if ((skip_components > 0) || (new_components != old_components))

	cmp	DWORD PTR _skip_components$[ebp], edi
	jg	SHORT $LN14@copy_with_
	mov	eax, DWORD PTR _new_components$[ebp]
	cmp	eax, DWORD PTR _old_components$[ebp]
	je	$LN13@copy_with_
$LN14@copy_with_:

; 5166 :     { // Create an appropriate null transform
; 5167 :       kdu_params *mcc = access_cluster(MCC_params);
; 5168 :       mcc = access_relation(tile_idx,-1,0);

	push	0
	push	0
	push	-1
	push	DWORD PTR [ebx+8]
	mov	ecx, ebx
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	ebx, eax

; 5169 :       assert(mcc != NULL);
; 5170 :       int free_inst=1;

	mov	esi, 1
$LL2@copy_with_:

; 5177 :           for (scan=mcc; scan != NULL; scan=scan->access_next_inst())

	mov	ecx, ebx
	test	ebx, ebx
	je	SHORT $LN41@copy_with_
	npad	8
$LL6@copy_with_:

; 5178 :             if (scan->get_instance() == free_inst)

	cmp	DWORD PTR [ecx+16], esi
	je	$LN31@copy_with_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 807  :       access_next_inst() { return next_inst; }

	mov	ecx, DWORD PTR [ecx+56]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5177 :           for (scan=mcc; scan != NULL; scan=scan->access_next_inst())

	test	ecx, ecx
	jne	SHORT $LL6@copy_with_
$LN41@copy_with_:

; 5185 :         }
; 5186 : 
; 5187 :       if (free_inst > 255)

	cmp	esi, 255				; 000000ffH
	jle	SHORT $LN17@copy_with_

; 5188 :         { KDU_ERROR(e,0x22070500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BCA@FMBIIPEN@Unable?5to?5modify?5the?5existing?5mu@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5188 :         { KDU_ERROR(e,0x22070500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5194 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN17@copy_with_:

; 5195 : 
; 5196 :       extra_output_stages = 1;
; 5197 :       set(Mstages,0,0,free_inst);

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	edi, 1
	push	esi
	push	0
	push	0
	push	OFFSET ??_C@_07CNNLMAHC@Mstages?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5198 : 
; 5199 :       mcc = mcc->access_relation(tile_idx,-1,free_inst); // Creates a new one

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, ebx
	push	0
	push	esi
	push	-1
	push	DWORD PTR [eax+8]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 5200 :       mcc->set(Mstage_inputs,0,0,0);

	push	0
	push	0
	mov	esi, eax
	push	0
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5201 :       mcc->set(Mstage_inputs,0,1,new_components-1);

	mov	ecx, DWORD PTR _new_components$[ebp]
	dec	ecx
	push	ecx
	push	edi
	push	0
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5202 :       mcc->set(Mstage_outputs,0,0,skip_components);

	mov	ebx, DWORD PTR _skip_components$[ebp]
	mov	ecx, esi
	push	ebx
	push	0
	push	0
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5203 :       mcc->set(Mstage_outputs,0,1,skip_components+new_components-1);

	mov	eax, DWORD PTR _new_components$[ebp]
	mov	ecx, esi
	dec	eax
	add	eax, ebx
	push	eax
	push	edi
	push	0
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5204 :       if (skip_components > 0)

	test	ebx, ebx
	jle	SHORT $LN18@copy_with_

; 5205 :         {
; 5206 :           mcc->set(Mstage_outputs,1,0,0);

	push	0
	push	0
	push	edi
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5207 :           mcc->set(Mstage_outputs,1,1,skip_components-1);

	lea	eax, DWORD PTR [ebx-1]
	mov	ecx, esi
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN18@copy_with_:

; 5208 :         }
; 5209 :       if ((skip_components+new_components) < old_components)

	mov	eax, DWORD PTR _new_components$[ebp]
	lea	ecx, DWORD PTR [eax+ebx]
	cmp	ecx, DWORD PTR _old_components$[ebp]
	jge	SHORT $LN19@copy_with_

; 5210 :         {
; 5211 :           mcc->set(Mstage_outputs,2,0,skip_components+new_components);

	push	ecx
	push	0
	push	2
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5212 :           mcc->set(Mstage_outputs,2,1,old_components-1);

	mov	eax, DWORD PTR _old_components$[ebp]
	mov	ecx, esi
	dec	eax
	push	eax
	push	1
	push	2
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	eax, DWORD PTR _new_components$[ebp]
$LN19@copy_with_:

; 5213 :         }
; 5214 :       mcc->set(Mstage_blocks,0,0,new_components);

	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5215 :       mcc->set(Mstage_blocks,0,1,old_components);

	push	DWORD PTR _old_components$[ebp]
	mov	ecx, esi
	push	1
	push	0
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5216 :       mcc->set(Mstage_xforms,0,0,Mxform_MATRIX);

	push	9
	push	0
	push	0
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5217 :       mcc->set(Mstage_xforms,0,1,0);

	push	0
	push	1
	push	0
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5218 :       mcc->set(Mstage_xforms,0,2,0);

	push	0
	push	2
	push	0
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5219 :       mcc->set(Mstage_xforms,0,3,0);

	push	0
	push	3
	push	0
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5220 :       mcc->set(Mstage_xforms,0,4,0);

	push	0
	push	4
	push	0
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN13@copy_with_:

; 5221 :     }
; 5222 : 
; 5223 :   set(Mnum_stages,0,0,num_stages+extra_output_stages);

	mov	eax, DWORD PTR _num_stages$[ebp]
	mov	ecx, ebx
	add	eax, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@BMJAMMCN@Mnum_stages?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5224 :   for (n=0; (n < num_stages) && source->get(Mstages,n,0,stage_idx); n++)

	xor	esi, esi
	cmp	DWORD PTR _num_stages$[ebp], esi
	jle	SHORT $LN8@copy_with_
	npad	3
$LL9@copy_with_:
	mov	ecx, DWORD PTR _source$[ebp]
	lea	eax, DWORD PTR _stage_idx$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_07CNNLMAHC@Mstages?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN8@copy_with_

; 5225 :     set(Mstages,n+extra_output_stages,0,stage_idx);

	push	DWORD PTR _stage_idx$[ebp]
	lea	eax, DWORD PTR [esi+edi]
	mov	ecx, ebx
	push	0
	push	eax
	push	OFFSET ??_C@_07CNNLMAHC@Mstages?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	inc	esi
	cmp	esi, DWORD PTR _num_stages$[ebp]
	jl	SHORT $LL9@copy_with_
$LN8@copy_with_:

; 5226 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN31@copy_with_:

; 5179 :               {
; 5180 :                 found_free_inst = !scan->get(Mstage_inputs,0,0,dummy_val);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _dummy_val$3[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	sete	al

; 5181 :                 break;
; 5182 :               }
; 5183 :           if (!found_free_inst)

	test	al, al
	jne	$LN41@copy_with_

; 5184 :             free_inst++;

	inc	esi

; 5171 :       bool found_free_inst = false;
; 5172 :       while (!found_free_inst)

	jmp	$LL2@copy_with_
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?copy_with_xforms@mco_params@@MAEXPAVkdu_params@@HH_N11@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?copy_with_xforms@mco_params@@MAEXPAVkdu_params@@HH_N11@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?copy_with_xforms@mco_params@@MAEXPAVkdu_params@@HH_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?copy_with_xforms@mco_params@@MAEXPAVkdu_params@@HH_N11@Z ENDP ; mco_params::copy_with_xforms
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?finalize@mco_params@@MAEX_N@Z
_TEXT	SEGMENT
_e$2 = -60						; size = 20
_e$3 = -40						; size = 20
_c_idx$ = -20						; size = 4
_num_stages$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_mct_components$ = 8					; size = 4
_after_reading$ = 8					; size = 1
?finalize@mco_params@@MAEX_N@Z PROC			; mco_params::finalize, COMDAT
; _this$ = ecx

; 5246 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?finalize@mco_params@@MAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 5247 :   if (after_reading)

	cmp	BYTE PTR _after_reading$[ebp], 0
	jne	$LN8@finalize

; 5248 :     return;
; 5249 : 
; 5250 :   int mct_components = 0;
; 5251 :   kdu_params *siz = access_cluster(SIZ_params);

	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	mov	DWORD PTR _mct_components$[ebp], 0
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 5252 :   if (siz != NULL)

	test	eax, eax
	je	SHORT $LN3@finalize

; 5253 :     siz->get(Mcomponents,0,0,mct_components);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _mct_components$[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0M@FAIBBHLL@Mcomponents?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN3@finalize:

; 5254 : 
; 5255 :   int num_stages = 0;
; 5256 :   if (!get(Mnum_stages,0,0,num_stages))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _num_stages$[ebp]
	mov	DWORD PTR _num_stages$[ebp], 0
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@BMJAMMCN@Mnum_stages?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN4@finalize

; 5257 :     {
; 5258 :       if (mct_components > 0)

	cmp	DWORD PTR _mct_components$[ebp], 0
	jle	SHORT $LN7@finalize

; 5259 :         set(Mnum_stages,0,0,num_stages=0);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0M@BMJAMMCN@Mnum_stages?$AA@
	mov	ecx, esi
	mov	DWORD PTR _num_stages$[ebp], 0
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 5260 :           // Set default value of 0 stages where MCT is being used
; 5261 :     }

	jmp	SHORT $LN7@finalize
$LN4@finalize:

; 5262 :   else if (mct_components == 0)

	cmp	DWORD PTR _mct_components$[ebp], 0
	jne	SHORT $LN7@finalize

; 5263 :     { KDU_ERROR(e,0x21070510); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0JP@JHGJOPNH@You?5may?5not?5provide?5a?5value?5for?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5263 :     { KDU_ERROR(e,0x21070510); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5267 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN7@finalize:

; 5268 :   int c_idx;
; 5269 :   if ((num_stages > 0) && !get(Mstages,num_stages-1,0,c_idx))

	mov	eax, DWORD PTR _num_stages$[ebp]
	test	eax, eax
	jle	SHORT $LN8@finalize
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _c_idx$[ebp]
	dec	eax
	push	ecx
	push	0
	push	eax
	push	OFFSET ??_C@_07CNNLMAHC@Mstages?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN8@finalize

; 5270 :     { KDU_ERROR(e,0x21070511); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0GN@BOBKGGGG@The?5number?5of?5records?5supplied?5f@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5270 :     { KDU_ERROR(e,0x21070511); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5273 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN8@finalize:

; 5274 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?finalize@mco_params@@MAEX_N@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@mco_params@@MAEX_N@Z$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?finalize@mco_params@@MAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?finalize@mco_params@@MAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?finalize@mco_params@@MAEX_N@Z ENDP			; mco_params::finalize
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?new_object@mco_params@@MAEPAVkdu_params@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_object@mco_params@@MAEPAVkdu_params@@XZ PROC	; mco_params::new_object, COMDAT
; _this$ = ecx

; 2400 :     virtual kdu_params *new_object()  { return new mco_params(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_object@mco_params@@MAEPAVkdu_params@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_object
	mov	ecx, eax
	call	??0mco_params@@QAE@XZ			; mco_params::mco_params
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_object:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_object@mco_params@@MAEPAVkdu_params@@XZ$0:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?new_object@mco_params@@MAEPAVkdu_params@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_object@mco_params@@MAEPAVkdu_params@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_object@mco_params@@MAEPAVkdu_params@@XZ ENDP	; mco_params::new_object
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0mco_params@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0mco_params@@QAE@XZ PROC				; mco_params::mco_params, COMDAT
; _this$ = ecx

; 5105 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0mco_params@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 5104 :   : kdu_params(MCO_params,true,false,false)

	push	0
	push	0
	push	0
	push	0
	push	1
	push	OFFSET ??_C@_03LCPIMAFA@MCO?$AA@
	call	??0kdu_params@@QAE@PBD_N1111@Z		; kdu_params::kdu_params

; 5106 :   define_attribute(Mnum_stages,

	push	0
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0FCK@KEJNIDFA@Identifies?5the?5number?5of?5stages?5@
	push	OFFSET ??_C@_0M@BMJAMMCN@Mnum_stages?$AA@
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7mco_params@@6B@
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 5107 :     "Identifies the number of stages in the multi-component transform "
; 5108 :     "to be applied to this tile, or (for main header attributes) as "
; 5109 :     "a default for tiles which do not specify the `Mnum_stages' attribute.  "
; 5110 :     "If this value is 0, the spatially transformed codestream components "
; 5111 :     "associated with the relevant tile are mapped directly to the "
; 5112 :     "output components specified via the global `Mcomponents', "
; 5113 :     "`Msigned' and `Mprecision' attributes.  If `Mcomponents' is larger "
; 5114 :     "than `Scomponents', some final components are automatically "
; 5115 :     "set to 0.  Where the number of stages is 0, codestream components "
; 5116 :     "which are identified as unsigned by the `Ssigned' attribute are "
; 5117 :     "first offset (at least nominally) by half their dynamic range, "
; 5118 :     "in the usual fashion.  If, on the other hand, `Mnum_stages' specifies "
; 5119 :     "a non-zero number of transform stages, component offsets must "
; 5120 :     "be provided by the multi-component transform stages themselves.\n"
; 5121 :     "\t\t   It is worth noting that the above description applies to "
; 5122 :     "inverse transformation (synthesis) during decompression.  For a "
; 5123 :     "discussion of the conditions under which an appropriate forward "
; 5124 :     "transform can be performed during compression, see the description "
; 5125 :     "of the `Mcomponents' attribute.\n"
; 5126 :     "\t\t[This attribute defaults to 0 if a non-zero `Mcomponents' value "
; 5127 :     "exists, indicating the presence of a multi-component transform.]",
; 5128 :     "I");
; 5129 :   define_attribute(Mstages,

	push	1
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0BKE@DNMMMJKF@Provides?5?$GAMnum_stages?8?5records?0?5@
	push	OFFSET ??_C@_07CNNLMAHC@Mstages?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 5130 :     "Provides `Mnum_stages' records, each of which holds the instance index "
; 5131 :     "(in the range 0 to 255) associated with the `Mstage_inputs', "
; 5132 :     "`Mstage_outputs', `Mstage_blocks' and `Mstage_xforms' attributes "
; 5133 :     "which describe the corresponding stage in the inverse multi-component "
; 5134 :     "transform procedure.  The last stage is the one which produces the "
; 5135 :     "final decompressed components described by `Mcomponents', `Msigned' "
; 5136 :     "and `Mprecision'.",
; 5137 :     "I",MULTI_RECORD);
; 5138 : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0mco_params@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
__ehhandler$??0mco_params@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0mco_params@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0mco_params@@QAE@XZ ENDP				; mco_params::mco_params
; Function compile flags: /Ogtp
;	COMDAT ??_Gmcc_params@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gmcc_params@@UAEPAXI@Z PROC				; mcc_params::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gmcc_params@@UAEPAXI@Z ENDP				; mcc_params::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1mcc_params@@UAE@XZ
_TEXT	SEGMENT
??1mcc_params@@UAE@XZ PROC				; mcc_params::~mcc_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1mcc_params@@UAE@XZ ENDP				; mcc_params::~mcc_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z
_TEXT	SEGMENT
_e$2 = -228						; size = 20
_num_blocks$1$ = -208					; size = 4
_offset_idx$1$ = -204					; size = 4
$T3 = -200						; size = 4
$T4 = -196						; size = 4
$T5 = -192						; size = 4
$T6 = -188						; size = 4
$T7 = -184						; size = 4
$T8 = -180						; size = 4
$T9 = -176						; size = 4
$T10 = -172						; size = 4
$T11 = -168						; size = 4
_e$12 = -164						; size = 20
_e$13 = -164						; size = 20
_e$14 = -164						; size = 20
_xform_idx$1$ = -144					; size = 4
_idx_bytes$2$ = -144					; size = 4
_block_in$1$ = -140					; size = 4
_xform_type$1$ = -136					; size = 4
_block_out$1$ = -132					; size = 4
_n$1$ = -132						; size = 4
_b$1$ = -128						; size = 4
_out_range_idx$1$ = -124				; size = 4
_in_range_idx$1$ = -120					; size = 4
_aux2$1$ = -116						; size = 4
_n$2$ = -116						; size = 4
_idx_bytes$1$ = -116					; size = 4
_this$GSCopy$1$ = -112					; size = 4
_end$ = -108						; size = 4
_bp$ = -104						; size = 4
_text$15 = -100						; size = 80
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_tpart_idx$ = 20					; size = 4
?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z PROC	; mcc_params::read_marker_segment, COMDAT
; _this$ = ecx

; 4807 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi

; 4808 :   kdu_byte *bp, *end;
; 4809 : 
; 4810 :   if (tpart_idx != 0)

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	mov	eax, DWORD PTR _num_bytes$[ebp]
	mov	esi, DWORD PTR _bytes$[ebp]
	jne	$LN13@read_marke

; 4811 :     return false;
; 4812 :   if ((code != KDU_MCC) || (num_bytes < 3))

	mov	ecx, 65397				; 0000ff75H
	cmp	WORD PTR _code$[ebp], cx
	jne	$LN13@read_marke
	cmp	eax, 3
	jl	$LN13@read_marke

; 4814 : 
; 4815 :   bp = bytes;
; 4816 :   end = bp + num_bytes;
; 4817 : 
; 4818 :   int z_mcc = *(bp++);  z_mcc = (z_mcc<<8) + *(bp++);

	movzx	ecx, BYTE PTR [esi]
	add	eax, esi
	mov	DWORD PTR _end$[ebp], eax
	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax

; 4819 :   int which_inst = *(bp++);

	movzx	eax, BYTE PTR [esi+2]
	add	esi, 3
	mov	DWORD PTR _bp$[ebp], esi

; 4820 :   if (which_inst != inst_idx)

	cmp	eax, DWORD PTR [edi+16]
	jne	$LN13@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	edi, DWORD PTR _end$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4823 :   if ((z_mcc != 0) || (kdu_read(bp,end,2) != 0))

	test	ecx, ecx
	jne	SHORT $LN16@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN50@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR $T11[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN134@read_marke:
$LN50@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	ecx, 8
	mov	DWORD PTR _bp$[ebp], esi
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4823 :   if ((z_mcc != 0) || (kdu_read(bp,end,2) != 0))

	je	SHORT $LN15@read_marke
$LN16@read_marke:

; 4824 :     { KDU_ERROR(e,0x2107050b); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$14[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	OFFSET ??_C@_0BEB@BKBLPOMO@Encountered?5MCC?5?$CIMulti?9component@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4824 :     { KDU_ERROR(e,0x2107050b); e <<

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4831 :     }

	lea	ecx, DWORD PTR _e$14[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN15@read_marke:

; 4834 :       int in_range_idx=0, out_range_idx=0;

	xor	eax, eax
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	mov	DWORD PTR _out_range_idx$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4834 :       int in_range_idx=0, out_range_idx=0;

	mov	DWORD PTR _in_range_idx$1$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	cmp	eax, 2
	jge	SHORT $LN59@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR $T10[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN135@read_marke:
$LN59@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	ecx, 8
	add	ecx, eax
	mov	DWORD PTR _bp$[ebp], esi
	mov	DWORD PTR _num_blocks$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4837 :       for (b=0; b < num_blocks; b++)

	xor	ebx, ebx
$LN133@read_marke:
	mov	DWORD PTR _b$1$[ebp], ebx
	cmp	ebx, ecx
	jge	$LN3@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN65@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR $T9[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN136@read_marke:
$LN65@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4840 :           if (xform_type == 0)

	test	eax, eax
	jne	SHORT $LN18@read_marke

; 4841 :             xform_type = Mxform_DEP;

	mov	DWORD PTR _xform_type$1$[ebp], eax
	jmp	SHORT $LN22@read_marke
$LN18@read_marke:

; 4842 :           else if (xform_type == 1)

	cmp	eax, 1
	jne	SHORT $LN20@read_marke

; 4843 :             xform_type = Mxform_MATRIX;

	mov	eax, 9
	mov	DWORD PTR _xform_type$1$[ebp], eax
	jmp	SHORT $LN22@read_marke
$LN20@read_marke:

; 4844 :           else if (xform_type == 3)

	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	lea	ecx, DWORD PTR [ecx*4-1]
	mov	DWORD PTR _xform_type$1$[ebp], ecx
$LN22@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN71@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR $T8[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN137@read_marke:
$LN71@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4852 :           for (from=to=-1, n=0; n < block_in; n++)

	or	ebx, -1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4852 :           for (from=to=-1, n=0; n < block_in; n++)

	or	edx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 94   :     val = (val<<8) + *(bp++);

	shl	ecx, 8
	add	esi, 2
	add	ecx, eax
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4850 :           int block_in = Nmcc & 0x7FFF;

	mov	eax, ecx

; 4851 :           idx_bytes = 1 + ((Nmcc >> 15) & 1);

	sar	ecx, 15					; 0000000fH
	and	ecx, 1
	and	eax, 32767				; 00007fffH
	inc	ecx
	mov	DWORD PTR _block_in$1$[ebp], eax
	mov	DWORD PTR _idx_bytes$1$[ebp], ecx

; 4852 :           for (from=to=-1, n=0; n < block_in; n++)

	xor	eax, eax
$LN130@read_marke:
	mov	DWORD PTR _n$1$[ebp], eax
	cmp	eax, DWORD PTR _block_in$1$[ebp]
	jge	$LN6@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, ecx
	jge	SHORT $LN77@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T7[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN138@read_marke:
$LN77@read_marke:

; 92   :   val = *(bp++);

	movzx	edi, BYTE PTR [esi]
	inc	esi
	mov	DWORD PTR _bp$[ebp], esi

; 93   :   if (nbytes > 1)

	cmp	ecx, 1
	jle	SHORT $LN78@read_marke

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi]
	shl	edi, 8
	add	edi, eax
	inc	esi
	mov	DWORD PTR _bp$[ebp], esi
$LN78@read_marke:

; 95   :   if (nbytes > 2)

	cmp	ecx, 2
	jle	SHORT $LN79@read_marke

; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi]
	shl	edi, 8
	add	edi, eax
	inc	esi
	mov	DWORD PTR _bp$[ebp], esi
$LN79@read_marke:

; 97   :   if (nbytes > 3)

	cmp	ecx, 3
	jle	SHORT $LN80@read_marke

; 98   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi]
	shl	edi, 8
	add	edi, eax
	inc	esi
	mov	DWORD PTR _bp$[ebp], esi
$LN80@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4855 :               if (to < 0)

	test	ebx, ebx
	js	SHORT $LN129@read_marke

; 4856 :                 from = to = c_idx;
; 4857 :               else if (c_idx == (to+1))

	lea	eax, DWORD PTR [ebx+1]
	cmp	edi, eax
	jne	SHORT $LN26@read_marke

; 4858 :                 to++;

	mov	edi, DWORD PTR _end$[ebp]
	mov	ebx, eax
	mov	eax, DWORD PTR _n$1$[ebp]
	inc	eax
	jmp	$LN130@read_marke
$LN26@read_marke:

; 4859 :               else
; 4860 :                 {
; 4861 :                   set(Mstage_inputs,in_range_idx,0,from);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	edx
	push	0
	push	DWORD PTR _in_range_idx$1$[ebp]
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4862 :                   set(Mstage_inputs,in_range_idx,1,to);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _in_range_idx$1$[ebp]
	push	1
	push	ebx
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	ecx, DWORD PTR _idx_bytes$1$[ebp]

; 4863 :                   in_range_idx++;

	inc	ebx
	mov	DWORD PTR _in_range_idx$1$[ebp], ebx
$LN129@read_marke:

; 4864 :                   from = to = c_idx;

	mov	eax, DWORD PTR _n$1$[ebp]
	mov	edx, edi
	mov	ebx, edi
	inc	eax
	mov	edi, DWORD PTR _end$[ebp]
	jmp	$LN130@read_marke
$LN6@read_marke:

; 4865 :                 }
; 4866 :             }
; 4867 :           if (to >= 0)

	test	ebx, ebx
	js	SHORT $LN28@read_marke

; 4868 :             {
; 4869 :               set(Mstage_inputs,in_range_idx,0,from);

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	ecx, edi
	push	edx
	push	0
	push	DWORD PTR _in_range_idx$1$[ebp]
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4870 :               set(Mstage_inputs,in_range_idx,1,to);

	push	ebx
	mov	ebx, DWORD PTR _in_range_idx$1$[ebp]
	mov	ecx, edi
	push	1
	push	ebx
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	edi, DWORD PTR _end$[ebp]

; 4871 :               in_range_idx++;

	inc	ebx
	mov	DWORD PTR _in_range_idx$1$[ebp], ebx
$LN28@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN83@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T6[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN139@read_marke:
$LN83@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4877 :           for (from=to=-1, n=0; n < block_out; n++)

	or	ebx, -1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4877 :           for (from=to=-1, n=0; n < block_out; n++)

	or	edx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 94   :     val = (val<<8) + *(bp++);

	shl	ecx, 8
	add	esi, 2
	add	ecx, eax
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4875 :           int block_out = Mmcc & 0x7FFF;

	mov	edi, ecx

; 4876 :           idx_bytes = 1 + ((Mmcc >> 15) & 1);

	sar	ecx, 15					; 0000000fH
	and	ecx, 1
	and	edi, 32767				; 00007fffH
	inc	ecx
	mov	DWORD PTR _block_out$1$[ebp], edi
	mov	DWORD PTR _idx_bytes$2$[ebp], ecx

; 4877 :           for (from=to=-1, n=0; n < block_out; n++)

	xor	eax, eax
$LN132@read_marke:
	mov	DWORD PTR _n$2$[ebp], eax
	cmp	eax, edi
	jge	$LN9@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, esi
	cmp	eax, ecx
	jge	SHORT $LN89@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T5[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN140@read_marke:
$LN89@read_marke:

; 92   :   val = *(bp++);

	movzx	edi, BYTE PTR [esi]
	inc	esi
	mov	DWORD PTR _bp$[ebp], esi

; 93   :   if (nbytes > 1)

	cmp	ecx, 1
	jle	SHORT $LN90@read_marke

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi]
	shl	edi, 8
	add	edi, eax
	inc	esi
	mov	DWORD PTR _bp$[ebp], esi
$LN90@read_marke:

; 95   :   if (nbytes > 2)

	cmp	ecx, 2
	jle	SHORT $LN91@read_marke

; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi]
	shl	edi, 8
	add	edi, eax
	inc	esi
	mov	DWORD PTR _bp$[ebp], esi
$LN91@read_marke:

; 97   :   if (nbytes > 3)

	cmp	ecx, 3
	jle	SHORT $LN92@read_marke

; 98   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi]
	shl	edi, 8
	add	edi, eax
	inc	esi
	mov	DWORD PTR _bp$[ebp], esi
$LN92@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4880 :               if (to < 0)

	test	ebx, ebx
	js	SHORT $LN131@read_marke

; 4881 :                 from = to = c_idx;
; 4882 :               else if (c_idx == (to+1))

	lea	eax, DWORD PTR [ebx+1]
	cmp	edi, eax
	jne	SHORT $LN31@read_marke

; 4883 :                 to++;

	mov	edi, DWORD PTR _block_out$1$[ebp]
	mov	ebx, eax
	mov	eax, DWORD PTR _n$2$[ebp]
	inc	eax
	jmp	SHORT $LN132@read_marke
$LN31@read_marke:

; 4884 :               else
; 4885 :                 {
; 4886 :                   set(Mstage_outputs,out_range_idx,0,from);

	mov	eax, DWORD PTR _out_range_idx$1$[ebp]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	edx
	push	0
	push	eax
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4887 :                   set(Mstage_outputs,out_range_idx,1,to);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _out_range_idx$1$[ebp]
	push	1
	push	ebx
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	ecx, DWORD PTR _idx_bytes$2$[ebp]

; 4888 :                   out_range_idx++;

	inc	ebx
	mov	DWORD PTR _out_range_idx$1$[ebp], ebx
$LN131@read_marke:

; 4889 :                   from = to = c_idx;

	mov	eax, DWORD PTR _n$2$[ebp]
	mov	edx, edi
	mov	ebx, edi
	inc	eax
	mov	edi, DWORD PTR _block_out$1$[ebp]
	jmp	$LN132@read_marke
$LN9@read_marke:

; 4890 :                 }
; 4891 :             }
; 4892 :           if (to >= 0)
; 4893 :             {
; 4894 :               set(Mstage_outputs,out_range_idx,0,from);

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	test	ebx, ebx
	js	SHORT $LN33@read_marke
	mov	eax, DWORD PTR _out_range_idx$1$[ebp]
	mov	ecx, edi
	push	edx
	push	0
	push	eax
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4895 :               set(Mstage_outputs,out_range_idx,1,to);

	push	ebx
	mov	ebx, DWORD PTR _out_range_idx$1$[ebp]
	mov	ecx, edi
	push	1
	push	ebx
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4896 :               out_range_idx++;

	inc	ebx
	mov	DWORD PTR _out_range_idx$1$[ebp], ebx
$LN33@read_marke:

; 4897 :             }
; 4898 :   
; 4899 :           set(Mstage_blocks,b,0,block_in);

	push	DWORD PTR _block_in$1$[ebp]
	mov	ebx, DWORD PTR _b$1$[ebp]
	mov	ecx, edi
	push	0
	push	ebx
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4900 :           set(Mstage_blocks,b,1,block_out);

	push	DWORD PTR _block_out$1$[ebp]
	mov	ecx, edi
	push	1
	push	ebx
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	ecx, DWORD PTR _end$[ebp]
	mov	eax, ecx
	sub	eax, esi
	cmp	eax, 3
	jge	SHORT $LN95@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T4[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN141@read_marke:
$LN95@read_marke:

; 92   :   val = *(bp++);

	movzx	ebx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4906 :           if (xform_type == Mxform_DWT)

	mov	edx, DWORD PTR _xform_type$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 94   :     val = (val<<8) + *(bp++);

	shl	ebx, 8
	add	ebx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4905 :           int aux1=0, aux2=0;

	mov	DWORD PTR _aux2$1$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+2]
	add	esi, 3
	shl	ebx, 8
	add	ebx, eax
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4903 :           int xform_idx = Tmcc & 0xFF;

	movzx	eax, bl
	mov	DWORD PTR _xform_idx$1$[ebp], eax

; 4904 :           int offset_idx = (Tmcc >> 8) & 0xFF;

	mov	eax, ebx
	sar	eax, 8
	movzx	eax, al

; 4908 :               aux1 = (Tmcc >> 16) & 63;

	sar	ebx, 16					; 00000010H
	mov	DWORD PTR _offset_idx$1$[ebp], eax
	cmp	edx, 3
	jne	SHORT $LN34@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4908 :               aux1 = (Tmcc >> 16) & 63;

	and	ebx, 63					; 0000003fH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	sub	eax, esi
	cmp	eax, 4
	jge	SHORT $LN101@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T3[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN142@read_marke:
$LN101@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax

; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+2]
	shl	ecx, 8
	add	ecx, eax

; 98   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+3]
	shl	ecx, 8
	add	ecx, eax
	add	esi, 4
	mov	DWORD PTR _aux2$1$[ebp], ecx
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4911 :           else

	jmp	SHORT $LN35@read_marke
$LN34@read_marke:

; 4912 :             aux1 = (Tmcc >> 16) & 1;

	and	ebx, 1
$LN35@read_marke:

; 4913 : 
; 4914 :           if ((block_in < 1) || (block_out < 1) ||
; 4915 :               ((xform_type != Mxform_DEP) && (xform_type != Mxform_MATRIX) &&
; 4916 :                (xform_type != Mxform_DWT)) || (aux1 > 32) ||

	mov	ecx, DWORD PTR _block_in$1$[ebp]
	cmp	ecx, 1
	jl	SHORT $LN37@read_marke
	mov	eax, DWORD PTR _block_out$1$[ebp]
	cmp	eax, 1
	jl	SHORT $LN37@read_marke
	test	edx, edx
	je	SHORT $LN38@read_marke
	cmp	edx, 9
	je	SHORT $LN38@read_marke
	cmp	edx, 3
	jne	SHORT $LN37@read_marke
$LN38@read_marke:
	cmp	ebx, 32					; 00000020H
	jg	SHORT $LN37@read_marke
	cmp	ecx, eax
	je	SHORT $LN36@read_marke
	cmp	edx, 9
	je	SHORT $LN36@read_marke
$LN37@read_marke:

; 4918 :             { KDU_ERROR(e,0x2107050c); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$13[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	OFFSET ??_C@_0HM@HFEFAMNA@Malformed?5MCC?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4918 :             { KDU_ERROR(e,0x2107050c); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4922 :             }

	lea	ecx, DWORD PTR _e$13[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	edx, DWORD PTR _xform_type$1$[ebp]
$LN36@read_marke:

; 4923 : 
; 4924 :           set(Mstage_xforms,b,0,xform_type);

	push	edx
	push	0
	push	DWORD PTR _b$1$[ebp]
	mov	ecx, edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4925 :           set(Mstage_xforms,b,1,xform_idx);

	push	DWORD PTR _xform_idx$1$[ebp]
	mov	ecx, edi
	push	1
	push	DWORD PTR _b$1$[ebp]
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4926 :           set(Mstage_xforms,b,2,offset_idx);

	push	DWORD PTR _offset_idx$1$[ebp]
	mov	ecx, edi
	push	2
	push	DWORD PTR _b$1$[ebp]
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4927 :           set(Mstage_xforms,b,3,aux1);

	push	ebx
	mov	ebx, DWORD PTR _b$1$[ebp]
	mov	ecx, edi
	push	3
	push	ebx
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4928 :           set(Mstage_xforms,b,4,aux2);

	push	DWORD PTR _aux2$1$[ebp]
	mov	ecx, edi
	push	4
	push	ebx
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	edi, DWORD PTR _end$[ebp]
	inc	ebx
	mov	ecx, DWORD PTR _num_blocks$1$[ebp]
	jmp	$LN133@read_marke
__catch$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z$0:

; 4932 :     { KDU_ERROR(e,0x2107050d); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$12[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_0EI@NPIHMIKE@Malformed?5MCC?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4932 :     { KDU_ERROR(e,0x2107050d); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4935 :     }

	lea	ecx, DWORD PTR _e$12[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN48@read_marke
	ret	0
$LN48@read_marke:
	mov	esi, DWORD PTR _bp$[ebp]
	mov	edi, DWORD PTR _end$[ebp]
$LN3@read_marke:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 4936 :   if (bp != end)

	cmp	esi, edi
	je	$LN39@read_marke

; 4937 :     { KDU_ERROR(e,0x2107050e); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0DF@LFIMCEFC@Malformed?5MCC?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4937 :     { KDU_ERROR(e,0x2107050e); e <<

	mov	DWORD PTR __$EHRec$[ebp+12], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4939 :         << (int)(end-bp) <<

	sub	edi, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	BYTE PTR _e$2[ebp+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	edi
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$15[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$15[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	eax
	mov	eax, DWORD PTR _e$2[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4941 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN39@read_marke:

; 4942 : 
; 4943 :   return true;

	mov	al, 1
	jmp	SHORT $LN1@read_marke
$LN13@read_marke:

; 4813 :     return false;

	xor	al, al
$LN1@read_marke:

; 4944 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN128@read_marke:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z$2:
	lea	ecx, DWORD PTR _e$14[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z$3:
	lea	ecx, DWORD PTR _e$13[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z$4:
	lea	ecx, DWORD PTR _e$12[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z$5:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_marker_segment@mcc_params@@MAE_NGHQAEH@Z ENDP	; mcc_params::read_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?check_marker_segment@mcc_params@@MAE_NGHQAEAAH@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_c_idx$ = 20						; size = 4
?check_marker_segment@mcc_params@@MAE_NGHQAEAAH@Z PROC	; mcc_params::check_marker_segment, COMDAT
; _this$ = ecx

; 4793 : {

	push	ebp
	mov	ebp, esp

; 4794 :   if ((code != KDU_MCC) || (num_bytes < 3))

	mov	eax, 65397				; 0000ff75H
	cmp	WORD PTR _code$[ebp], ax
	jne	SHORT $LN3@check_mark
	cmp	DWORD PTR _num_bytes$[ebp], 3
	jl	SHORT $LN3@check_mark

; 4796 :   c_idx = bytes[2];

	mov	eax, DWORD PTR _bytes$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	eax, DWORD PTR _c_idx$[ebp]
	mov	DWORD PTR [eax], ecx

; 4797 :   return true;

	mov	al, 1

; 4798 : }

	pop	ebp
	ret	16					; 00000010H
$LN3@check_mark:

; 4795 :     return false;

	xor	al, al

; 4798 : }

	pop	ebp
	ret	16					; 00000010H
?check_marker_segment@mcc_params@@MAE_NGHQAEAAH@Z ENDP	; mcc_params::check_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
_TEXT	SEGMENT
_e$2 = -128						; size = 20
_e$3 = -108						; size = 20
_aux2$ = -88						; size = 4
_xform_idx$ = -84					; size = 4
_offset_idx$ = -80					; size = 4
_aux1$ = -76						; size = 4
_b$2$ = -72						; size = 4
_next_range_idx_out$1$ = -68				; size = 4
_to_out$ = -64						; size = 4
tv886 = -60						; size = 4
_c$2$ = -56						; size = 4
_c$1$ = -56						; size = 4
_to_in$ = -52						; size = 4
_length$1$ = -48					; size = 4
_comps_in$1$ = -48					; size = 4
_block_out$ = -44					; size = 4
_block_in$ = -40					; size = 4
_to$ = -36						; size = 4
_num_blocks$1$ = -32					; size = 4
_comps_out$1$ = -32					; size = 4
_xform_type$ = -28					; size = 4
_from_out$ = -24					; size = 4
_from_in$ = -20						; size = 4
_from$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_next_range_idx_in$1$ = 8				; size = 4
_out$ = 8						; size = 4
_last_marked$ = 12					; size = 4
_idx_bytes$1$ = 16					; size = 4
_tpart_idx$ = 16					; size = 4
?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z PROC ; mcc_params::write_marker_segment, COMDAT
; _this$ = ecx

; 4953 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 4954 :   if ((inst_idx > 255) || (tpart_idx != 0) || (comp_idx >= 0))

	cmp	DWORD PTR [edi+16], 255			; 000000ffH
	jg	$LN21@write_mark
	cmp	DWORD PTR _tpart_idx$[ebp], 0
	jne	$LN21@write_mark
	cmp	DWORD PTR [edi+12], 0
	jge	$LN21@write_mark

; 4956 : 
; 4957 :   // Determine the precision with which component indices will be represented
; 4958 :   // and the total number of input and output components
; 4959 :   int n, from, to;
; 4960 :   int idx_bytes=1, comps_in=0, comps_out=0;
; 4961 :   for (n=0; get(Mstage_inputs,n,0,from,false,false) &&

	push	1
	xor	esi, esi
	mov	DWORD PTR _idx_bytes$1$[ebp], 1
	push	esi
	push	esi
	lea	eax, DWORD PTR _from$[ebp]
	xor	ebx, ebx
	push	eax
	push	esi
	push	esi
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	mov	DWORD PTR _comps_in$1$[ebp], ebx
	mov	DWORD PTR _comps_out$1$[ebp], ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN3@write_mark
$LL4@write_mark:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _to$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	esi
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN173@write_mark

; 4963 :     {
; 4964 :       comps_in += to+1-from;

	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, edx
	sub	eax, DWORD PTR _from$[ebp]
	inc	eax
	add	ebx, eax

; 4965 :       if ((from > 255) || (to > 255))

	cmp	DWORD PTR _from$[ebp], 255		; 000000ffH
	jg	SHORT $LN23@write_mark
	cmp	edx, 255				; 000000ffH
	jle	SHORT $LN2@write_mark
$LN23@write_mark:

; 4966 :         idx_bytes = 2;

	mov	DWORD PTR _idx_bytes$1$[ebp], 2
$LN2@write_mark:

; 4956 : 
; 4957 :   // Determine the precision with which component indices will be represented
; 4958 :   // and the total number of input and output components
; 4959 :   int n, from, to;
; 4960 :   int idx_bytes=1, comps_in=0, comps_out=0;
; 4961 :   for (n=0; get(Mstage_inputs,n,0,from,false,false) &&

	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _from$[ebp]

; 4962 :             get(Mstage_inputs,n,1,to,false,false); n++)

	inc	esi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL4@write_mark
$LN173@write_mark:
	mov	DWORD PTR _comps_in$1$[ebp], ebx
$LN3@write_mark:

; 4967 :     }
; 4968 :   for (n=0; get(Mstage_outputs,n,0,from,false,false) &&

	push	1
	xor	esi, esi
	lea	eax, DWORD PTR _from$[ebp]
	push	esi
	push	esi
	push	eax
	push	esi
	push	esi
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN6@write_mark
	xor	ebx, ebx
$LL7@write_mark:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _to$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	esi
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN174@write_mark

; 4970 :     {
; 4971 :       comps_out += to+1-from;

	mov	edx, DWORD PTR _to$[ebp]
	mov	eax, edx
	sub	eax, DWORD PTR _from$[ebp]
	inc	eax
	add	ebx, eax

; 4972 :       if ((from > 255) || (to > 255))

	cmp	DWORD PTR _from$[ebp], 255		; 000000ffH
	jg	SHORT $LN25@write_mark
	cmp	edx, 255				; 000000ffH
	jle	SHORT $LN5@write_mark
$LN25@write_mark:

; 4973 :         idx_bytes = 2;

	mov	DWORD PTR _idx_bytes$1$[ebp], 2
$LN5@write_mark:

; 4967 :     }
; 4968 :   for (n=0; get(Mstage_outputs,n,0,from,false,false) &&

	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _from$[ebp]

; 4969 :             get(Mstage_outputs,n,1,to,false,false); n++)

	inc	esi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL7@write_mark
$LN174@write_mark:
	mov	DWORD PTR _comps_out$1$[ebp], ebx
	mov	ebx, DWORD PTR _comps_in$1$[ebp]
$LN6@write_mark:

; 4974 :     }
; 4975 : 
; 4976 :   // Calculate the length
; 4977 :   int length = 11; // Marker code, length, Zmcc, Imcc, Ymcc and Qmcc fields
; 4978 :   length += idx_bytes * (comps_in + comps_out);

	add	ebx, DWORD PTR _comps_out$1$[ebp]

; 4979 :   int b, xform_type;
; 4980 :   for (b=0; get(Mstage_xforms,b,0,xform_type,false,false); b++)

	lea	eax, DWORD PTR _xform_type$[ebp]
	imul	ebx, DWORD PTR _idx_bytes$1$[ebp]
	xor	esi, esi
	push	1
	push	esi
	push	esi
	push	eax
	push	esi
	push	esi
	add	ebx, 11					; 0000000bH
	mov	DWORD PTR _num_blocks$1$[ebp], esi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	ecx, edi
	mov	DWORD PTR _length$1$[ebp], ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN9@write_mark
$LL10@write_mark:

; 4981 :     {
; 4982 :       length += 8; // For Xmcc, Nmcc, Mmcc and Tmcc fields.

	add	ebx, 8

; 4983 :       if (xform_type == Mxform_DWT)

	cmp	DWORD PTR _xform_type$[ebp], 3
	jne	SHORT $LN8@write_mark

; 4984 :         length += 4; // For the Omcc field

	add	ebx, 4
$LN8@write_mark:

; 4979 :   int b, xform_type;
; 4980 :   for (b=0; get(Mstage_xforms,b,0,xform_type,false,false); b++)

	mov	eax, DWORD PTR _num_blocks$1$[ebp]
	lea	ecx, DWORD PTR _xform_type$[ebp]
	push	1
	push	0
	push	0
	push	ecx
	inc	eax
	mov	ecx, edi
	push	0
	push	eax
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	DWORD PTR _num_blocks$1$[ebp], eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL10@write_mark
	mov	esi, DWORD PTR _num_blocks$1$[ebp]
	mov	DWORD PTR _length$1$[ebp], ebx
$LN9@write_mark:

; 4985 :     }
; 4986 :   int num_blocks = b;
; 4987 : 
; 4988 :   if (length > 65537)

	cmp	ebx, 65537				; 00010001H
	jle	SHORT $LN27@write_mark

; 4989 :     { KDU_ERROR(e,0x2107050f); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BIP@MNLLGAPJ@Unable?5to?5write?5MCC?5?$CIMulti?9compo@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4989 :     { KDU_ERROR(e,0x2107050f); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4997 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN27@write_mark:

; 4998 : 
; 4999 :   if (num_blocks == 0)

	test	esi, esi
	je	$LN21@write_mark

; 5000 :     return 0;
; 5001 : 
; 5002 :   if (out == NULL)

	mov	esi, DWORD PTR _out$[ebp]
	test	esi, esi
	jne	SHORT $LN29@write_mark

; 5003 :     return length;

	mov	eax, ebx

; 5092 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN29@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN51@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN51@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN54@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN54@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 117			; 00000075H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5008 :   acc_length += out->put((kdu_uint16)(length-2));

	lea	eax, DWORD PTR [ebx-2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
	inc	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5008 :   acc_length += out->put((kdu_uint16)(length-2));

	movzx	ebx, ax
	mov	DWORD PTR [esi+516], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [esi+520]
	jne	SHORT $LN59@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN59@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN62@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN62@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN67@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN67@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 0
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN70@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN70@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 0
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5010 :   acc_length += out->put((kdu_byte) inst_idx); // Imcc value

	mov	bl, BYTE PTR [edi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN73@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN73@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN78@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN78@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 0
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN81@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN81@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 0
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN86@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN86@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ebx, DWORD PTR _num_blocks$1$[ebp]
	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN89@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN89@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5014 :   int next_range_idx_in=0, next_range_idx_out=0;

	mov	DWORD PTR _next_range_idx_in$1$[ebp], 0
	mov	DWORD PTR _next_range_idx_out$1$[ebp], 0

; 5016 :   int c, block_in, block_out, xform_idx, offset_idx, aux1, aux2;
; 5017 :   for (b=0; b < num_blocks; b++)

	mov	DWORD PTR _b$2$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5015 :   int from_in=0, to_in=-1, from_out=0, to_out=-1;

	mov	DWORD PTR _from_in$[ebp], 0
	mov	DWORD PTR _to_in$[ebp], -1
	mov	DWORD PTR _from_out$[ebp], 0
	mov	DWORD PTR _to_out$[ebp], -1

; 5016 :   int c, block_in, block_out, xform_idx, offset_idx, aux1, aux2;
; 5017 :   for (b=0; b < num_blocks; b++)

	test	ebx, ebx
	jle	$LN12@write_mark
	mov	eax, DWORD PTR _idx_bytes$1$[ebp]
	shl	eax, 15					; 0000000fH
	add	eax, -32768				; ffff8000H
	xor	ebx, ebx
	mov	DWORD PTR tv886[ebp], eax
$LL13@write_mark:

; 5018 :     {
; 5019 :       get(Mstage_blocks,b,0,block_in);  get(Mstage_blocks,b,1,block_out);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _block_in$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _block_out$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	ebx
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 5020 :       get(Mstage_xforms,b,0,xform_type);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _xform_type$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 5021 :       get(Mstage_xforms,b,1,xform_idx);  get(Mstage_xforms,b,2,offset_idx);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _xform_idx$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	ebx
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _offset_idx$[ebp]
	mov	ecx, edi
	push	eax
	push	2
	push	ebx
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 5022 :       get(Mstage_xforms,b,3,aux1);  get(Mstage_xforms,b,4,aux2);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _aux1$[ebp]
	mov	ecx, edi
	push	eax
	push	3
	push	ebx
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _aux2$[ebp]
	mov	ecx, edi
	push	eax
	push	4
	push	ebx
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 5023 :       if (xform_type == Mxform_DEP)

	mov	eax, DWORD PTR _xform_type$[ebp]
	test	eax, eax
	jne	SHORT $LN30@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN92@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN92@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 0
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5024 :         acc_length += out->put((kdu_byte) 0);

	jmp	$LN35@write_mark
$LN30@write_mark:

; 5025 :       else if (xform_type == Mxform_MATRIX)

	cmp	eax, 9
	jne	SHORT $LN32@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN95@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN95@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 1
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5026 :         acc_length += out->put((kdu_byte) 1);

	jmp	SHORT $LN35@write_mark
$LN32@write_mark:

; 5027 :       else if (xform_type == Mxform_DWT)

	cmp	eax, 3
	jne	SHORT $LN34@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN98@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN98@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 3
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5029 :       else

	jmp	SHORT $LN35@write_mark
$LN34@write_mark:

; 5030 :         { KDU_ERROR(e,0x04060701); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0DJM@PGFFJOFI@You?5can?5no?5longer?5generate?5a?5cod@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5030 :         { KDU_ERROR(e,0x04060701); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5048 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN35@write_mark:

; 5049 : 
; 5050 :       int Nmcc = ((idx_bytes-1)<<15) + block_in;

	mov	ebx, DWORD PTR tv886[ebp]
	add	ebx, DWORD PTR _block_in$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN105@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN105@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN108@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN108@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5052 :       for (c=0; c < block_in; c++)

	mov	DWORD PTR _c$1$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5052 :       for (c=0; c < block_in; c++)

	cmp	DWORD PTR _block_in$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5052 :       for (c=0; c < block_in; c++)

	jle	$LN15@write_mark
	mov	ebx, DWORD PTR _from_in$[ebp]
$LL16@write_mark:

; 5053 :         {
; 5054 :           if (from_in > to_in)

	cmp	ebx, DWORD PTR _to_in$[ebp]
	jle	SHORT $LN36@write_mark

; 5055 :             {
; 5056 :               get(Mstage_inputs,next_range_idx_in,0,from_in);

	mov	ebx, DWORD PTR _next_range_idx_in$1$[ebp]
	lea	eax, DWORD PTR _from_in$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 5057 :               get(Mstage_inputs,next_range_idx_in,1,to_in);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _to_in$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	ebx
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 5058 :               next_range_idx_in++;

	inc	ebx
	mov	DWORD PTR _next_range_idx_in$1$[ebp], ebx
	mov	ebx, DWORD PTR _from_in$[ebp]
$LN36@write_mark:

; 5060 :           if (idx_bytes == 1)

	cmp	DWORD PTR _idx_bytes$1$[ebp], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5060 :           if (idx_bytes == 1)

	je	SHORT $LN178@write_mark

; 5061 :             acc_length += out->put((kdu_byte) from_in);
; 5062 :           else
; 5063 :             acc_length += out->put((kdu_uint16) from_in);

	movzx	ebx, bx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN116@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN116@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]
$LN178@write_mark:

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN119@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN119@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5052 :       for (c=0; c < block_in; c++)

	mov	eax, DWORD PTR _c$1$[ebp]

; 5064 :           from_in++;

	mov	ebx, DWORD PTR _from_in$[ebp]
	inc	eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5064 :           from_in++;

	inc	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5064 :           from_in++;

	mov	DWORD PTR _from_in$[ebp], ebx
	mov	DWORD PTR _c$1$[ebp], eax
	cmp	eax, DWORD PTR _block_in$[ebp]
	jl	$LL16@write_mark
$LN15@write_mark:

; 5065 :         }
; 5066 : 
; 5067 :       int Mmcc = ((idx_bytes-1)<<15) + block_out;

	mov	ebx, DWORD PTR tv886[ebp]
	add	ebx, DWORD PTR _block_out$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [esi+520]
	jne	SHORT $LN124@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN124@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN127@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN127@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5069 :       for (c=0; c < block_out; c++)

	mov	DWORD PTR _c$2$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5069 :       for (c=0; c < block_out; c++)

	cmp	DWORD PTR _block_out$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5069 :       for (c=0; c < block_out; c++)

	jle	$LN18@write_mark
	mov	ebx, DWORD PTR _from_out$[ebp]
	npad	1
$LL19@write_mark:

; 5070 :         {
; 5071 :           if (from_out > to_out)

	cmp	ebx, DWORD PTR _to_out$[ebp]
	jle	SHORT $LN39@write_mark

; 5072 :             {
; 5073 :               get(Mstage_outputs,next_range_idx_out,0,from_out);

	mov	ebx, DWORD PTR _next_range_idx_out$1$[ebp]
	lea	eax, DWORD PTR _from_out$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 5074 :               get(Mstage_outputs,next_range_idx_out,1,to_out);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _to_out$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	ebx
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 5075 :               next_range_idx_out++;

	inc	ebx
	mov	DWORD PTR _next_range_idx_out$1$[ebp], ebx
	mov	ebx, DWORD PTR _from_out$[ebp]
$LN39@write_mark:

; 5077 :           if (idx_bytes == 1)

	cmp	DWORD PTR _idx_bytes$1$[ebp], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5077 :           if (idx_bytes == 1)

	je	SHORT $LN181@write_mark

; 5078 :             acc_length += out->put((kdu_byte) from_out);
; 5079 :           else
; 5080 :             acc_length += out->put((kdu_uint16) from_out);

	movzx	ebx, bx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN135@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN135@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]
$LN181@write_mark:

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN138@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN138@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5069 :       for (c=0; c < block_out; c++)

	mov	ecx, DWORD PTR _c$2$[ebp]
	inc	ecx
	mov	DWORD PTR _c$2$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], bl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5081 :           from_out++;

	mov	ebx, DWORD PTR _from_out$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5081 :           from_out++;

	inc	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5081 :           from_out++;

	mov	DWORD PTR _from_out$[ebp], ebx
	cmp	ecx, DWORD PTR _block_out$[ebp]
	jl	$LL19@write_mark
$LN18@write_mark:

; 5082 :         }
; 5083 : 
; 5084 :       acc_length += out->put((kdu_byte) aux1); // MSB of Tmcc

	mov	bl, BYTE PTR _aux1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN141@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN141@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5085 :       acc_length += out->put((kdu_byte) offset_idx); // Second byte of Tmcc

	mov	bl, BYTE PTR _offset_idx$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN144@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN144@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5086 :       acc_length += out->put((kdu_byte) xform_idx); // LSB of Tmcc

	mov	bl, BYTE PTR _xform_idx$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN147@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN147@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 5087 :       if (xform_type == Mxform_DWT)

	cmp	DWORD PTR _xform_type$[ebp], 3
	jne	SHORT $LN11@write_mark

; 5088 :         acc_length += out->put((kdu_uint32) aux2); // Omcc field

	push	DWORD PTR _aux2$[ebp]
	mov	ecx, esi
	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put
$LN11@write_mark:

; 5016 :   int c, block_in, block_out, xform_idx, offset_idx, aux1, aux2;
; 5017 :   for (b=0; b < num_blocks; b++)

	mov	ebx, DWORD PTR _b$2$[ebp]
	inc	ebx
	mov	DWORD PTR _b$2$[ebp], ebx
	cmp	ebx, DWORD PTR _num_blocks$1$[ebp]
	jl	$LL13@write_mark
$LN12@write_mark:

; 5089 :     }
; 5090 :   assert(length == acc_length);
; 5091 :   return length;

	mov	eax, DWORD PTR _length$1$[ebp]

; 5092 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN21@write_mark:

; 4955 :     return 0;

	xor	eax, eax

; 5092 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?write_marker_segment@mcc_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ENDP ; mcc_params::write_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?copy_with_xforms@mcc_params@@MAEXPAVkdu_params@@HH_N11@Z
_TEXT	SEGMENT
_aux2$ = -32						; size = 4
_aux1$ = -28						; size = 4
_offset_idx$ = -24					; size = 4
_xform_idx$ = -20					; size = 4
_block_out$ = -16					; size = 4
_xform_type$ = -12					; size = 4
_block_in$ = -8						; size = 4
_from$ = -4						; size = 4
_to$ = 8						; size = 4
_source$ = 8						; size = 4
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_transpose$ = 20					; size = 1
_vflip$ = 24						; size = 1
_hflip$ = 28						; size = 1
?copy_with_xforms@mcc_params@@MAEXPAVkdu_params@@HH_N11@Z PROC ; mcc_params::copy_with_xforms, COMDAT
; _this$ = ecx

; 4759 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 4760 :   int n, from, to;
; 4761 :   for (n=0; source->get(Mstage_inputs,n,0,from,false,false) &&

	lea	eax, DWORD PTR _from$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _source$[ebp]
	mov	ebx, ecx
	push	edi
	push	1
	xor	edi, edi
	mov	ecx, esi
	push	edi
	push	edi
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN31@copy_with_
	npad	6
$LL4@copy_with_:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _to$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN31@copy_with_

; 4762 :             source->get(Mstage_inputs,n,1,to,false,false); n++)
; 4763 :     { set(Mstage_inputs,n,0,from);  set(Mstage_inputs,n,1,to); }

	push	DWORD PTR _from$[ebp]
	mov	ecx, ebx
	push	0
	push	edi
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _to$[ebp]
	mov	ecx, ebx
	push	1
	push	edi
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _from$[ebp]
	inc	edi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL4@copy_with_
$LN31@copy_with_:

; 4764 :   for (n=0; source->get(Mstage_outputs,n,0,from,false,false) &&

	push	1
	xor	edi, edi
	lea	eax, DWORD PTR _from$[ebp]
	push	edi
	push	edi
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN32@copy_with_
	npad	5
$LL7@copy_with_:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _to$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN32@copy_with_

; 4765 :             source->get(Mstage_outputs,n,1,to,false,false); n++)
; 4766 :     { set(Mstage_outputs,n,0,from);  set(Mstage_outputs,n,1,to); }

	push	DWORD PTR _from$[ebp]
	mov	ecx, ebx
	push	0
	push	edi
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _to$[ebp]
	mov	ecx, ebx
	push	1
	push	edi
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _from$[ebp]
	inc	edi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL7@copy_with_
$LN32@copy_with_:

; 4767 : 
; 4768 :   int block_in, block_out;
; 4769 :   for (n=0; source->get(Mstage_blocks,n,0,block_in,false,false) &&

	push	1
	xor	edi, edi
	lea	eax, DWORD PTR _block_in$[ebp]
	push	edi
	push	edi
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN33@copy_with_
	npad	5
$LL10@copy_with_:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _block_out$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN33@copy_with_

; 4770 :             source->get(Mstage_blocks,n,1,block_out,false,false); n++)
; 4771 :     { set(Mstage_blocks,n,0,block_in);  set(Mstage_blocks,n,1,block_out); }

	push	DWORD PTR _block_in$[ebp]
	mov	ecx, ebx
	push	0
	push	edi
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _block_out$[ebp]
	mov	ecx, ebx
	push	1
	push	edi
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _block_in$[ebp]
	inc	edi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL10@copy_with_
$LN33@copy_with_:

; 4772 : 
; 4773 :   int xform_type, xform_idx, offset_idx, aux1, aux2;
; 4774 :   for (n=0; source->get(Mstage_xforms,n,0,xform_type,false,false) &&
; 4775 :             source->get(Mstage_xforms,n,1,xform_idx,false,false) &&
; 4776 :             source->get(Mstage_xforms,n,2,offset_idx,false,false) &&
; 4777 :             source->get(Mstage_xforms,n,3,aux1,false,false) &&

	push	1
	xor	edi, edi
	lea	eax, DWORD PTR _xform_type$[ebp]
	push	edi
	push	edi
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN34@copy_with_
	npad	1
$LL13@copy_with_:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _xform_idx$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN34@copy_with_
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _offset_idx$[ebp]
	mov	ecx, esi
	push	eax
	push	2
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN34@copy_with_
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _aux1$[ebp]
	mov	ecx, esi
	push	eax
	push	3
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN34@copy_with_
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _aux2$[ebp]
	mov	ecx, esi
	push	eax
	push	4
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN34@copy_with_

; 4778 :             source->get(Mstage_xforms,n,4,aux2,false,false); n++)
; 4779 :     {
; 4780 :       set(Mstage_xforms,n,0,xform_type);

	push	DWORD PTR _xform_type$[ebp]
	mov	ecx, ebx
	push	0
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4781 :       set(Mstage_xforms,n,1,xform_idx);  set(Mstage_xforms,n,2,offset_idx);

	push	DWORD PTR _xform_idx$[ebp]
	mov	ecx, ebx
	push	1
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _offset_idx$[ebp]
	mov	ecx, ebx
	push	2
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4782 :       set(Mstage_xforms,n,3,aux1);       set(Mstage_xforms,n,4,aux2);

	push	DWORD PTR _aux1$[ebp]
	mov	ecx, ebx
	push	3
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _aux2$[ebp]
	mov	ecx, ebx
	push	4
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _xform_type$[ebp]
	inc	edi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL13@copy_with_
$LN34@copy_with_:
	pop	edi
	pop	esi
	pop	ebx

; 4783 :     }
; 4784 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?copy_with_xforms@mcc_params@@MAEXPAVkdu_params@@HH_N11@Z ENDP ; mcc_params::copy_with_xforms
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?finalize@mcc_params@@MAEX_N@Z
_TEXT	SEGMENT
_e$2 = -88						; size = 20
_e$3 = -68						; size = 20
_e$4 = -68						; size = 20
_e$5 = -68						; size = 20
_e$6 = -68						; size = 20
_e$7 = -68						; size = 20
_e$8 = -68						; size = 20
_e$9 = -68						; size = 20
_aux2$10 = -48						; size = 4
_offset_id$11 = -44					; size = 4
_xform_id$12 = -40					; size = 4
_block_out$ = -36					; size = 4
_block_in$ = -32					; size = 4
_num_blocks$1$ = -28					; size = 4
_xform_type$ = -24					; size = 4
_input_components$1$ = -20				; size = 4
_aux1$13 = -20						; size = 4
_to$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
_after_reading$ = 8					; size = 1
?finalize@mcc_params@@MAEX_N@Z PROC			; mcc_params::finalize, COMDAT
; _this$ = ecx

; 4660 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?finalize@mcc_params@@MAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 4661 :   if (after_reading)

	cmp	BYTE PTR _after_reading$[ebp], 0
	jne	$LN29@finalize

; 4662 :     return;
; 4663 : 
; 4664 :   int n, from, to;
; 4665 :   int input_components=0, output_components=0;
; 4666 :   for (n=0; get(Mstage_inputs,n,0,from,false,false) &&

	push	1
	xor	edi, edi
	mov	DWORD PTR _input_components$1$[ebp], 0
	push	edi
	push	edi
	lea	eax, DWORD PTR _from$[ebp]
	xor	ebx, ebx
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN3@finalize
	npad	5
$LL4@finalize:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _to$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN72@finalize

; 4667 :             get(Mstage_inputs,n,1,to,false,false); n++)
; 4668 :     {
; 4669 :       if ((from > to) || (from < 0) || (to >= 16384))

	mov	ecx, DWORD PTR _from$[ebp]
	mov	eax, DWORD PTR _to$[ebp]
	cmp	ecx, eax
	jg	SHORT $LN16@finalize
	test	ecx, ecx
	js	SHORT $LN16@finalize
	cmp	eax, 16384				; 00004000H
	jl	SHORT $LN15@finalize
$LN16@finalize:

; 4670 :         { KDU_ERROR(e,0x21070503); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$9[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0MP@KPAJGLC@Illegal?5parameters?5supplied?5for?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4670 :         { KDU_ERROR(e,0x21070503); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4675 :         }

	lea	ecx, DWORD PTR _e$9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _from$[ebp]
	mov	eax, DWORD PTR _to$[ebp]
$LN15@finalize:

; 4676 :       input_components += to+1-from;

	push	1
	sub	eax, ecx
	inc	edi
	push	0
	inc	eax
	mov	ecx, esi
	push	0
	add	ebx, eax
	lea	eax, DWORD PTR _from$[ebp]
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL4@finalize
$LN72@finalize:
	mov	DWORD PTR _input_components$1$[ebp], ebx
	xor	ebx, ebx
$LN3@finalize:

; 4677 :     }
; 4678 :   for (n=0; get(Mstage_outputs,n,0,from,false,false) &&

	push	1
	xor	edi, edi
	lea	eax, DWORD PTR _from$[ebp]
	push	edi
	push	edi
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN6@finalize
$LL7@finalize:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _to$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN6@finalize

; 4679 :             get(Mstage_outputs,n,1,to,false,false); n++)
; 4680 :     {
; 4681 :       if ((from > to) || (from < 0) || (to >= 16384))

	mov	ecx, DWORD PTR _from$[ebp]
	mov	eax, DWORD PTR _to$[ebp]
	cmp	ecx, eax
	jg	SHORT $LN18@finalize
	test	ecx, ecx
	js	SHORT $LN18@finalize
	cmp	eax, 16384				; 00004000H
	jl	SHORT $LN17@finalize
$LN18@finalize:

; 4682 :         { KDU_ERROR(e,0x21070504); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0NA@EPMHNEKF@Illegal?5parameters?5supplied?5for?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4682 :         { KDU_ERROR(e,0x21070504); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4687 :         }

	lea	ecx, DWORD PTR _e$8[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _from$[ebp]
	mov	eax, DWORD PTR _to$[ebp]
$LN17@finalize:

; 4688 :       output_components += to+1-from;

	push	1
	sub	eax, ecx
	inc	edi
	push	0
	inc	eax
	mov	ecx, esi
	push	0
	add	ebx, eax
	lea	eax, DWORD PTR _from$[ebp]
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL7@finalize
$LN6@finalize:

; 4689 :     }
; 4690 :   int num_blocks=0, block_in, block_out;
; 4691 :   for (n=0; get(Mstage_blocks,n,0,block_in,false,false) &&

	push	1
	xor	edi, edi
	mov	DWORD PTR _num_blocks$1$[ebp], 0
	push	edi
	push	edi
	lea	eax, DWORD PTR _block_in$[ebp]
	mov	ecx, esi
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN9@finalize
	npad	4
$LL10@finalize:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _block_out$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN9@finalize

; 4693 :     {
; 4694 :       num_blocks++;
; 4695 :       input_components -= block_in;

	mov	eax, DWORD PTR _block_in$[ebp]

; 4696 :       output_components -= block_out;

	mov	ecx, DWORD PTR _block_out$[ebp]
	sub	ebx, ecx
	inc	DWORD PTR _num_blocks$1$[ebp]
	sub	DWORD PTR _input_components$1$[ebp], eax

; 4697 :       if ((block_in < 1) || (block_out < 1))

	cmp	eax, 1
	jl	SHORT $LN20@finalize
	cmp	ecx, 1
	jge	SHORT $LN8@finalize
$LN20@finalize:

; 4698 :         { KDU_ERROR(e,0x21070505); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$7[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_0KN@DKKKLGFN@Malformed?5?$GAMstage_blocks?8?5attrib@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4698 :         { KDU_ERROR(e,0x21070505); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4702 :         }

	lea	ecx, DWORD PTR _e$7[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN8@finalize:

; 4689 :     }
; 4690 :   int num_blocks=0, block_in, block_out;
; 4691 :   for (n=0; get(Mstage_blocks,n,0,block_in,false,false) &&

	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _block_in$[ebp]

; 4692 :             get(Mstage_blocks,n,1,block_out,false,false); n++)

	inc	edi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL10@finalize
$LN9@finalize:

; 4703 :     }
; 4704 :   if ((input_components != 0) || (output_components != 0))

	cmp	DWORD PTR _input_components$1$[ebp], 0
	jne	SHORT $LN22@finalize
	test	ebx, ebx
	je	SHORT $LN21@finalize
$LN22@finalize:

; 4705 :     { KDU_ERROR(e,0x21070506); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$6[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	OFFSET ??_C@_0BBC@MHOANFBM@Malformed?5?$GAMstage_blocks?8?5attrib@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4705 :     { KDU_ERROR(e,0x21070506); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4711 :     }

	lea	ecx, DWORD PTR _e$6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN21@finalize:

; 4712 : 
; 4713 :   int num_xforms=0, xform_type;
; 4714 :   for (n=0; get(Mstage_xforms,n,0,xform_type,false,false); n++)

	push	1
	xor	edi, edi
	lea	eax, DWORD PTR _xform_type$[ebp]
	push	edi
	push	edi
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	ecx, esi
	xor	ebx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN12@finalize
$LL13@finalize:

; 4715 :     {
; 4716 :       num_xforms++;
; 4717 :       int xform_id, offset_id, aux1, aux2;
; 4718 :       if ((!(get(Mstage_xforms,n,1,xform_id,false,false) &&
; 4719 :              get(Mstage_xforms,n,2,offset_id,false,false) &&
; 4720 :              get(Mstage_xforms,n,3,aux1,false,false) &&
; 4721 :              get(Mstage_xforms,n,4,aux2,false,false))) ||
; 4722 :           (xform_id < 0) || (xform_id > 255) ||
; 4723 :           (offset_id < 0) || (offset_id > 255))

	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _xform_id$12[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	inc	ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN24@finalize
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _offset_id$11[ebp]
	mov	ecx, esi
	push	eax
	push	2
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN24@finalize
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _aux1$13[ebp]
	mov	ecx, esi
	push	eax
	push	3
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN24@finalize
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _aux2$10[ebp]
	mov	ecx, esi
	push	eax
	push	4
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN24@finalize
	cmp	DWORD PTR _xform_id$12[ebp], 255	; 000000ffH
	ja	SHORT $LN24@finalize
	mov	eax, DWORD PTR _offset_id$11[ebp]
	test	eax, eax
	js	SHORT $LN24@finalize
	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN23@finalize
$LN24@finalize:

; 4724 :         { KDU_ERROR(e,0x21070507); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0KK@DLAOAECJ@Malformed?5?$GAMstage_xforms?8?5attrib@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4724 :         { KDU_ERROR(e,0x21070507); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4728 :         }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN23@finalize:

; 4729 :       if ((xform_type == Mxform_DWT) && ((aux1 < 0) || (aux1 > 32)))

	cmp	DWORD PTR _xform_type$[ebp], 3
	jne	SHORT $LN71@finalize
	mov	eax, DWORD PTR _aux1$13[ebp]
	test	eax, eax
	js	SHORT $LN26@finalize
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN11@finalize
$LN26@finalize:

; 4730 :         { KDU_ERROR(e,0x21070508); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0KH@KFJPFAEH@Malformed?5?$GAMstage_xforms?8?5attrib@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4730 :         { KDU_ERROR(e,0x21070508); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4734 :         }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error

; 4735 :       if ((xform_type != Mxform_DWT) && ((aux1 != (aux1&1)) || (aux2 != 0)))

	cmp	DWORD PTR _xform_type$[ebp], 3
	je	SHORT $LN11@finalize
$LN71@finalize:
	mov	eax, DWORD PTR _aux1$13[ebp]
	and	eax, 1
	cmp	DWORD PTR _aux1$13[ebp], eax
	jne	SHORT $LN28@finalize
	cmp	DWORD PTR _aux2$10[ebp], 0
	je	SHORT $LN11@finalize
$LN28@finalize:

; 4736 :         { KDU_ERROR(e,0x21070509); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0NL@PJCAENA@Malformed?5?$GAMstage_xforms?8?5attrib@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4736 :         { KDU_ERROR(e,0x21070509); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4741 :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN11@finalize:

; 4712 : 
; 4713 :   int num_xforms=0, xform_type;
; 4714 :   for (n=0; get(Mstage_xforms,n,0,xform_type,false,false); n++)

	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _xform_type$[ebp]
	inc	edi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LL13@finalize
$LN12@finalize:

; 4742 :     }
; 4743 :   if (num_blocks != num_xforms)

	cmp	DWORD PTR _num_blocks$1$[ebp], ebx
	je	SHORT $LN29@finalize

; 4744 :     { KDU_ERROR(e,0x2107050a); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0LD@CNACCFCO@Malformed?5?$GAMstage_xforms?8?5attrib@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4744 :     { KDU_ERROR(e,0x2107050a); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4748 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN29@finalize:

; 4749 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$0:
	lea	ecx, DWORD PTR _e$9[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$1:
	lea	ecx, DWORD PTR _e$8[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$2:
	lea	ecx, DWORD PTR _e$7[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$3:
	lea	ecx, DWORD PTR _e$6[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$4:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$5:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$6:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@mcc_params@@MAEX_N@Z$7:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?finalize@mcc_params@@MAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?finalize@mcc_params@@MAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?finalize@mcc_params@@MAEX_N@Z ENDP			; mcc_params::finalize
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?new_object@mcc_params@@MAEPAVkdu_params@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_object@mcc_params@@MAEPAVkdu_params@@XZ PROC	; mcc_params::new_object, COMDAT
; _this$ = ecx

; 2326 :     virtual kdu_params *new_object()  { return new mcc_params(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_object@mcc_params@@MAEPAVkdu_params@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_object
	mov	ecx, eax
	call	??0mcc_params@@QAE@XZ			; mcc_params::mcc_params
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_object:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_object@mcc_params@@MAEPAVkdu_params@@XZ$0:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?new_object@mcc_params@@MAEPAVkdu_params@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_object@mcc_params@@MAEPAVkdu_params@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_object@mcc_params@@MAEPAVkdu_params@@XZ ENDP	; mcc_params::new_object
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0mcc_params@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0mcc_params@@QAE@XZ PROC				; mcc_params::mcc_params, COMDAT
; _this$ = ecx

; 4569 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0mcc_params@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 4568 :   : kdu_params(MCC_params,true,false,true,false,true)

	push	1
	push	0
	push	1
	push	0
	push	1
	push	OFFSET ??_C@_03BOENIPFM@MCC?$AA@
	call	??0kdu_params@@QAE@PBD_N1111@Z		; kdu_params::kdu_params

; 4570 :   define_attribute(Mstage_inputs,

	push	1
	push	OFFSET ??_C@_02FOEOGEOO@II?$AA@
	push	OFFSET ??_C@_0DAF@JDFCJPDD@This?5attribute?5is?5used?5to?5descri@
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7mcc_params@@6B@
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 4571 :     "This attribute is used to describe a list of input component "
; 4572 :     "indices which are used by all transform blocks in a single stage of the "
; 4573 :     "multi-component transform.  This list of component indices is a "
; 4574 :     "concatenation of the index ranges <A1>-<B1>, <A2>-<B2>, ..., where "
; 4575 :     "An <= Bn are the first and second fields in the n'th record of the "
; 4576 :     "`Mstage_inputs' attribute.   The list of input component indices may "
; 4577 :     "contain repeated values, but must cover all components produced by the "
; 4578 :     "previous stage (or all codestream component indices, if this is "
; 4579 :     "the first stage).  In particular, it must always include 0.  "
; 4580 :     "The first transform block operates on the first N1 components "
; 4581 :     "identified by this list; the second transform block operates on the "
; 4582 :     "next N2 components in this list; and so forth.",
; 4583 :     "II",MULTI_RECORD);
; 4584 :   define_attribute(Mstage_outputs,

	push	1
	push	OFFSET ??_C@_02FOEOGEOO@II?$AA@
	push	OFFSET ??_C@_0DLG@NNDEDDPH@This?5attribute?5is?5used?5to?5descri@
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 4585 :     "This attribute is used to describe a list of output component "
; 4586 :     "indices which are produced by this stage.  This list  of component "
; 4587 :     "indices is a concatenation of the index ranges <A1>-<B1>, <A2>-<B2>, "
; 4588 :     "..., where An <= Bn are the first and second fields in the n'th "
; 4589 :     "record of the `Mstage_outputs' attribute.  The list of output "
; 4590 :     "component indices may not contain any repeated component indices, "
; 4591 :     "but it may contain \"holes\".  The transform stage is considered "
; 4592 :     "to generate components with indices from 0 to the largest index "
; 4593 :     "in the output list; any components in this range which are not "
; 4594 :     "listed (these are the holes) are taken to be identically equal to "
; 4595 :     "0.  The first transform block in the stage processes the first N1 "
; 4596 :     "components in the list to produces the first M1 components in the "
; 4597 :     "output list; the second transform block in the stage processes the "
; 4598 :     "next N1 components in the input list, producing the next M2 "
; 4599 :     "components in the output list; and so forth.",
; 4600 :     "II",MULTI_RECORD);
; 4601 :   define_attribute(Mstage_blocks,

	push	1
	push	OFFSET ??_C@_02FOEOGEOO@II?$AA@
	push	OFFSET ??_C@_0CLK@PPHGAGLD@This?5attribute?5provides?5the?5valu@
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 4602 :     "This attribute provides the values Nc and Mc which appear in the "
; 4603 :     "descriptions of `Mstage_inputs' and `Mstage_outputs', for each "
; 4604 :     "transform block (equivalently, each component collection), c.  "
; 4605 :     "The `Mstage_blocks' parameter attribute should contain one "
; 4606 :     "record for each transform.  Each record contains two strictly "
; 4607 :     "positive integers, identifying the number of input components Nk, "
; 4608 :     "and the number of output components, Mk, produced by the k'th "
; 4609 :     "transform.  No transform may consume or produce 0 components.  "
; 4610 :     "Between them, the various transform blocks must consume all "
; 4611 :     "components in the input list described by `Mstage_inputs' and "
; 4612 :     "produce all components in the output list described by "
; 4613 :     "`Mstage_outputs'.",
; 4614 :     "II",MULTI_RECORD);
; 4615 :   define_attribute(Mstage_xforms,

	push	1
	push	OFFSET ??_C@_0CE@JIOANCKI@?$CIDEP?$DN0?0MATRIX?$DN9?0DWT?$DN3?0MAT?$DN1000?$CJI@
	push	OFFSET ??_C@_0IIP@CHGEJKJG@This?5attribute?5provides?5one?5reco@
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 4616 :     "This attribute provides one record for each transform block, "
; 4617 :     "which describes the type of transform to be implemented in that "
; 4618 :     "block and the parameters of the transform.  The first field "
; 4619 :     "identifies the transform as one of \"dependency transform\" "
; 4620 :     "(`DEP'), \"decorrelation matrix transform\" (`MATRIX'), or \"discrete "
; 4621 :     "wavelet transform\" (`DWT').  Do not use the `MAT' option; that option "
; 4622 :     "is provided to catch backward compatibility problems with Kakadu "
; 4623 :     "versions prior to v6.0, in which reversible decorrelation matrix "
; 4624 :     "transforms used a non-compliant organization for the coefficient "
; 4625 :     "values.  Kakadu will refuse to generate codestreams which use the "
; 4626 :     "`MAT' option, although it should be able to correctly recover and "
; 4627 :     "render codestreams generated with this option prior to v6.0.  It "
; 4628 :     "does this by recognizing the absence of the `Cmct' parameter "
; 4629 :     "attribute (another oversight prior to v6.0) as an indication that "
; 4630 :     "the non-compliant organization is being used.\n"
; 4631 :     "\t\t   The 2'nd field of each record holds the instance index of the "
; 4632 :     "`Mtriang_coeffs' (for dependency transforms) or `Mmatrix_coeffs' "
; 4633 :     "(for decorrelation matrix transforms) attributes, which provide "
; 4634 :     "the actual transform coefficients, unless the transform is a DWT; "
; 4635 :     "in this last case the 2'nd field holds 0 for the 9/7 DWT, 1 "
; 4636 :     "for the 5/3 DWT, or the instance index (in the range 2 to 255) of an "
; 4637 :     "`ATK' marker segment whose `Kreversible', `Ksymmetric', `Kextension', "
; 4638 :     "`Ksteps' and `Kcoeffs' attributes describe the DWT kernel.\n"
; 4639 :     "\t\t   The 3'rd field of each record holds the instance index of the "
; 4640 :     "`Mvector_coeffs' attribute which describes any offsets to be "
; 4641 :     "applied after inverse transformation of the input components to "
; 4642 :     "the block.  A value of 0 for this field means that there is no "
; 4643 :     "offset; otherwise, the value must be in the range 1 to 255.\n"
; 4644 :     "\t\t   For DWT transforms, the 4'th field in the record identifies "
; 4645 :     "the number of DWT levels to be used, in the range 0 to 32, while "
; 4646 :     "the final field holds the transform origin, which plays the "
; 4647 :     "same role as `Sorigin', but along the component axis.  For "
; 4648 :     "dependency and decorrelation transforms, the 4'th field "
; 4649 :     "must hold 0 if the transform is irreversible, or 1 if it is "
; 4650 :     "reversible, while the 5'th field must hold 0.",
; 4651 :     "(DEP=0,MATRIX=9,DWT=3,MAT=1000)IIII",MULTI_RECORD);
; 4652 : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0mcc_params@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
__ehhandler$??0mcc_params@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0mcc_params@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0mcc_params@@QAE@XZ ENDP				; mcc_params::mcc_params
; Function compile flags: /Ogtp
;	COMDAT ??_Gmct_params@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gmct_params@@UAEPAXI@Z PROC				; mct_params::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	112					; 00000070H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gmct_params@@UAEPAXI@Z ENDP				; mct_params::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1mct_params@@UAE@XZ
_TEXT	SEGMENT
??1mct_params@@UAE@XZ PROC				; mct_params::~mct_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1mct_params@@UAE@XZ ENDP				; mct_params::~mct_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?read_marker_segment@mct_params@@MAE_NGHQAEH@Z
_TEXT	SEGMENT
_e$2 = -88						; size = 20
_e$3 = -88						; size = 20
_e$4 = -88						; size = 20
_e$5 = -68						; size = 20
tv386 = -48						; size = 8
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
_coeff_type$1$ = -28					; size = 4
_num_coeffs$1$ = -24					; size = 4
_z_mct$2$ = -24						; size = 4
_existing_coeffs$9 = -20				; size = 4
__$EHRec$ = -16						; size = 16
_bytes_per_coeff$10 = 8					; size = 4
_z_final$11 = 8						; size = 4
_z_next$12 = 8						; size = 4
_bp$ = 8						; size = 4
_code$ = 8						; size = 2
tv385 = 12						; size = 4
_size_name$1$ = 12					; size = 4
_coeff$13 = 12						; size = 4
_num_bytes$ = 12					; size = 4
_coeffs_name$1$ = 16					; size = 4
_bytes$ = 16						; size = 4
_end$ = 20						; size = 4
_tpart_idx$ = 20					; size = 4
?read_marker_segment@mct_params@@MAE_NGHQAEH@Z PROC	; mct_params::read_marker_segment, COMDAT
; _this$ = ecx

; 4352 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx

; 4353 :   kdu_byte *bp, *end;
; 4354 : 
; 4355 :   if (tpart_idx != 0)

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	jne	$LN13@read_marke

; 4356 :     return false;
; 4357 :   if ((code != KDU_MCT) || (num_bytes < 4) || (inst_idx == 0))

	mov	eax, 65396				; 0000ff74H
	cmp	WORD PTR _code$[ebp], ax
	jne	$LN13@read_marke
	mov	ecx, DWORD PTR _num_bytes$[ebp]
	cmp	ecx, 4
	jl	$LN13@read_marke
	cmp	DWORD PTR [ebx+16], 0
	je	$LN13@read_marke

; 4359 : 
; 4360 :   bp = bytes;
; 4361 :   end = bp + num_bytes;

	mov	eax, DWORD PTR _bytes$[ebp]
	add	ecx, eax

; 4362 : 
; 4363 :   int z_mct = *(bp++);  z_mct = (z_mct<<8) + *(bp++);

	lea	esi, DWORD PTR [eax+1]
	mov	DWORD PTR _end$[ebp], ecx

; 4364 :   int i_mct = *(bp++);  i_mct = (i_mct<<8) + *(bp++);

	movzx	ecx, BYTE PTR [esi+1]
	shl	ecx, 8
	movzx	edi, BYTE PTR [eax]
	movzx	eax, BYTE PTR [esi]
	shl	edi, 8
	add	edi, eax
	movzx	eax, BYTE PTR [esi+2]
	add	ecx, eax
	mov	DWORD PTR _z_mct$2$[ebp], edi

; 4365 :   int which_inst = i_mct & 0x00FF;
; 4366 :   int xform_type = (i_mct >> 8) & 3;

	mov	edx, ecx
	movzx	eax, cl
	sar	edx, 8
	add	esi, 3

; 4367 :   int coeff_type = (i_mct >> 10) & 3;

	sar	ecx, 10					; 0000000aH
	and	edx, 3
	and	ecx, 3
	mov	DWORD PTR _bp$[ebp], esi
	mov	DWORD PTR _coeff_type$1$[ebp], ecx

; 4368 :   if ((which_inst != inst_idx) || (xform_type == 3))

	cmp	eax, DWORD PTR [ebx+16]
	jne	$LN13@read_marke
	cmp	edx, 3
	je	$LN13@read_marke

; 4369 :     return false;
; 4370 : 
; 4371 :   try {

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 4372 :       const char *size_name=NULL, *coeffs_name=NULL;

	mov	DWORD PTR _size_name$1$[ebp], 0
	mov	DWORD PTR _coeffs_name$1$[ebp], 0

; 4373 :       int y_mct = (z_mct==0)?(kdu_read(bp,end,2)):0;

	test	edi, edi
	jne	SHORT $LN37@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN48@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR $T8[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN89@read_marke:
$LN48@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 93   :   if (nbytes > 1)
; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax
	add	esi, 2
	mov	DWORD PTR _bp$[ebp], esi

; 99   :   return val;
; 100  : }

	jmp	SHORT $LN38@read_marke
$LN37@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4373 :       int y_mct = (z_mct==0)?(kdu_read(bp,end,2)):0;

	xor	ecx, ecx
$LN38@read_marke:

; 4374 :       int z_next, z_final;
; 4375 :       switch (xform_type) {

	sub	edx, 0
	je	SHORT $LN17@read_marke
	sub	edx, 1
	je	SHORT $LN19@read_marke
	sub	edx, 1
	jne	SHORT $LN79@read_marke

; 4386 :         case 2: // Offset vector coefficients
; 4387 :           if (z_mct == 0) Zmct_vector_final = y_mct;

	test	edi, edi
	jne	SHORT $LN22@read_marke
	mov	DWORD PTR [ebx+100], ecx
$LN22@read_marke:

; 4388 :           z_next = Zmct_vector_next++;  z_final = Zmct_vector_final;

	mov	edi, DWORD PTR [ebx+96]
	mov	ecx, DWORD PTR [ebx+100]

; 4389 :           size_name = Mvector_size;  coeffs_name = Mvector_coeffs;

	mov	DWORD PTR _size_name$1$[ebp], OFFSET ??_C@_0N@EBBFOCKJ@Mvector_size?$AA@
	mov	DWORD PTR _coeffs_name$1$[ebp], OFFSET ??_C@_0P@DIALIICI@Mvector_coeffs?$AA@
	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR [ebx+96], eax

; 4390 :           break;

	jmp	SHORT $LN23@read_marke
$LN79@read_marke:

; 4379 :           size_name = Mtriang_size;  coeffs_name = Mtriang_coeffs;

	mov	edi, DWORD PTR _z_next$12[ebp]
	mov	ecx, DWORD PTR _z_final$11[ebp]
	jmp	SHORT $LN23@read_marke
$LN19@read_marke:

; 4380 :           break;
; 4381 :         case 1: // Decorrelation matrix coefficients
; 4382 :           if (z_mct == 0) Zmct_matrix_final = y_mct;

	test	edi, edi
	jne	SHORT $LN20@read_marke
	mov	DWORD PTR [ebx+92], ecx
$LN20@read_marke:

; 4383 :           z_next = Zmct_matrix_next++;  z_final = Zmct_matrix_final;

	mov	edi, DWORD PTR [ebx+88]
	mov	ecx, DWORD PTR [ebx+92]

; 4384 :           size_name = Mmatrix_size;  coeffs_name = Mmatrix_coeffs;

	mov	DWORD PTR _size_name$1$[ebp], OFFSET ??_C@_0N@FIDBGNAL@Mmatrix_size?$AA@
	mov	DWORD PTR _coeffs_name$1$[ebp], OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR [ebx+88], eax

; 4385 :           break;

	jmp	SHORT $LN23@read_marke
$LN17@read_marke:

; 4376 :         case 0: // Dependency transform coefficients
; 4377 :           if (z_mct == 0) Zmct_triang_final = y_mct;

	test	edi, edi
	jne	SHORT $LN18@read_marke
	mov	DWORD PTR [ebx+108], ecx
$LN18@read_marke:

; 4378 :           z_next = Zmct_triang_next++;  z_final = Zmct_triang_final;

	mov	edi, DWORD PTR [ebx+104]
	mov	ecx, DWORD PTR [ebx+108]

; 4379 :           size_name = Mtriang_size;  coeffs_name = Mtriang_coeffs;

	mov	DWORD PTR _size_name$1$[ebp], OFFSET ??_C@_0N@CCNKIJHO@Mtriang_size?$AA@
	mov	DWORD PTR _coeffs_name$1$[ebp], OFFSET ??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@
	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR [ebx+104], eax
$LN23@read_marke:

; 4391 :         case 3:
; 4392 :           assert(0);
; 4393 :         }
; 4394 : 
; 4395 :       if ((z_mct > z_final) || (z_mct < z_next))

	mov	eax, DWORD PTR _z_mct$2$[ebp]
	cmp	eax, ecx
	jg	SHORT $LN25@read_marke
	cmp	eax, edi
	jge	SHORT $LN86@read_marke
$LN25@read_marke:

; 4396 :         { KDU_ERROR(e,0x20070503); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0BBF@IPOKLLIB@Encountered?5repeat?5or?5out?9of?9ran@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4396 :         { KDU_ERROR(e,0x20070503); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4402 :         }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _z_mct$2$[ebp]

; 4403 :       if (z_mct != z_next)

	cmp	eax, edi
$LN86@read_marke:
	je	SHORT $LN26@read_marke

; 4404 :         { KDU_ERROR(e,0x20070504); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BCP@HHOAMAFM@Encountered?5out?9of?9order?5?$GAZmct?8?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4404 :         { KDU_ERROR(e,0x20070504); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4411 :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN26@read_marke:

; 4412 : 
; 4413 :       int bytes_per_coeff;
; 4414 :       switch (coeff_type) {

	mov	eax, DWORD PTR _coeff_type$1$[ebp]
	cmp	eax, 3
	ja	SHORT $LN80@read_marke
	jmp	DWORD PTR $LN87@read_marke[eax*4]
$LN27@read_marke:

; 4415 :         case 0: bytes_per_coeff = 2; break;

	mov	ecx, 2
	jmp	SHORT $LN4@read_marke
$LN28@read_marke:

; 4416 :         case 1:
; 4417 :         case 2: bytes_per_coeff = 4; break;

	mov	ecx, 4
	jmp	SHORT $LN4@read_marke
$LN29@read_marke:

; 4418 :         case 3: bytes_per_coeff = 8; break;

	mov	ecx, 8
	jmp	SHORT $LN4@read_marke
$LN80@read_marke:
	mov	ecx, DWORD PTR _bytes_per_coeff$10[ebp]
$LN4@read_marke:

; 4419 :         }
; 4420 : 
; 4421 :       int num_coeffs = ((int)(end-bp)) / bytes_per_coeff;

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, esi
	cdq
	idiv	ecx

; 4422 :       int c, existing_coeffs = 0;

	xor	ecx, ecx

; 4423 :       if (z_next > 0)

	test	edi, edi

; 4424 :         get(size_name,0,0,existing_coeffs);

	mov	edi, DWORD PTR _size_name$1$[ebp]
	mov	DWORD PTR _num_coeffs$1$[ebp], eax
	mov	DWORD PTR _existing_coeffs$9[ebp], ecx
	jle	SHORT $LN30@read_marke
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _existing_coeffs$9[ebp]
	push	eax
	push	ecx
	push	ecx
	push	edi
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	ecx, DWORD PTR _existing_coeffs$9[ebp]
	mov	eax, DWORD PTR _num_coeffs$1$[ebp]
$LN30@read_marke:

; 4425 :       set(size_name,0,0,existing_coeffs+num_coeffs);

	add	eax, ecx
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	edi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4426 :       for (c=0; c < num_coeffs; c++)

	xor	edi, edi
$LL8@read_marke:
	cmp	edi, DWORD PTR _num_coeffs$1$[ebp]
	jge	$LN7@read_marke

; 4427 :         {
; 4428 :           int ival;
; 4429 :           float coeff;
; 4430 :           switch (coeff_type) {

	mov	eax, DWORD PTR _coeff_type$1$[ebp]
	cmp	eax, 3
	ja	$LN82@read_marke
	jmp	DWORD PTR $LN88@read_marke[eax*4]
$LN31@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN59@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T7[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN90@read_marke:
$LN59@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 93   :   if (nbytes > 1)
; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	ecx, 8
	add	ecx, eax
	mov	DWORD PTR _bp$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4433 :               ival -= (ival & 0x8000)?(1<<16):0; // Convert to 2's comp

	mov	eax, ecx
	and	eax, 32768				; 00008000H
	add	eax, eax
	sub	ecx, eax
	movd	xmm0, ecx

; 4434 :               coeff = (float) ival;

	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _coeff$13[ebp], xmm0

; 4435 :               break;

	jmp	$LN9@read_marke
$LN32@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, esi
	cmp	eax, 4
	jge	SHORT $LN65@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T6[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN91@read_marke:
$LN65@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 93   :   if (nbytes > 1)
; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax

; 95   :   if (nbytes > 2)
; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+2]
	shl	ecx, 8
	add	ecx, eax

; 97   :   if (nbytes > 3)
; 98   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+3]
	shl	ecx, 8
	add	ecx, eax
	add	esi, 4
	mov	DWORD PTR _bp$[ebp], esi
	movd	xmm0, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4438 :               coeff = (float) ival;

	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _coeff$13[ebp], xmm0

; 4439 :               break;

	jmp	SHORT $LN9@read_marke
$LN33@read_marke:

; 4440 :             case 2: // 32-bit floating point coefficients
; 4441 :               coeff = kdu_read_float(bp,end);

	push	DWORD PTR _end$[ebp]
	lea	eax, DWORD PTR _bp$[ebp]
	push	eax
	call	?kdu_read_float@@YAMAAPAEPAE@Z		; kdu_read_float

; 4442 :               break;

	mov	esi, DWORD PTR _bp$[ebp]
	add	esp, 8
	fstp	DWORD PTR tv385[ebp]
	movss	xmm0, DWORD PTR tv385[ebp]
	movss	DWORD PTR _coeff$13[ebp], xmm0
	jmp	SHORT $LN9@read_marke
$LN34@read_marke:

; 4443 :             case 3: // 64-bit floating point coefficients
; 4444 :               coeff = (float) kdu_read_double(bp,end);

	push	DWORD PTR _end$[ebp]
	lea	eax, DWORD PTR _bp$[ebp]
	push	eax
	call	?kdu_read_double@@YANAAPAEPAE@Z		; kdu_read_double
	mov	esi, DWORD PTR _bp$[ebp]
	add	esp, 8
	fstp	QWORD PTR tv386[ebp]
	movsd	xmm0, QWORD PTR tv386[ebp]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR _coeff$13[ebp], xmm0
	jmp	SHORT $LN9@read_marke
$LN82@read_marke:
	movss	xmm0, DWORD PTR _coeff$13[ebp]
$LN9@read_marke:

; 4445 :               break;
; 4446 :             }
; 4447 :           set(coeffs_name,existing_coeffs+c,0,coeff);

	mov	eax, DWORD PTR _existing_coeffs$9[ebp]
	sub	esp, 8
	cvtps2pd xmm0, xmm0
	add	eax, edi
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	eax
	push	DWORD PTR _coeffs_name$1$[ebp]
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	inc	edi
	jmp	$LL8@read_marke
__catch$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z$0:

; 4451 :     { KDU_ERROR(e,0x20070505); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EI@NNANLLPB@Malformed?5MCT?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4451 :     { KDU_ERROR(e,0x20070505); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4454 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN46@read_marke
	ret	0
$LN46@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
	mov	esi, DWORD PTR _bp$[ebp]
$LN7@read_marke:
	mov	ebx, DWORD PTR _end$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4455 :   if (bp != end)

	cmp	esi, ebx
	je	SHORT $LN35@read_marke

; 4456 :     { KDU_ERROR(e,0x20070506); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0DF@BKIIOFOO@Malformed?5MCT?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4456 :     { KDU_ERROR(e,0x20070506); e <<

	mov	DWORD PTR __$EHRec$[ebp+12], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4458 :         << (int)(end-bp) <<

	sub	ebx, esi
	lea	ecx, DWORD PTR _e$5[ebp]
	push	ebx
	call	??6kdu_message@@QAEAAV0@H@Z		; kdu_message::operator<<
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@
	mov	ecx, eax
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4460 :     }

	lea	ecx, DWORD PTR _e$5[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN35@read_marke:

; 4461 : 
; 4462 :   return true;

	mov	al, 1

; 4463 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN13@read_marke:

; 4358 :     return false;

	xor	al, al

; 4463 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN85@read_marke:
	npad	2
$LN87@read_marke:
	DD	$LN27@read_marke
	DD	$LN28@read_marke
	DD	$LN28@read_marke
	DD	$LN29@read_marke
$LN88@read_marke:
	DD	$LN31@read_marke
	DD	$LN32@read_marke
	DD	$LN33@read_marke
	DD	$LN34@read_marke
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z$2:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z$3:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z$4:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z$5:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_marker_segment@mct_params@@MAE_NGHQAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_marker_segment@mct_params@@MAE_NGHQAEH@Z ENDP	; mct_params::read_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?check_marker_segment@mct_params@@MAE_NGHQAEAAH@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_c_idx$ = 20						; size = 4
?check_marker_segment@mct_params@@MAE_NGHQAEAAH@Z PROC	; mct_params::check_marker_segment, COMDAT
; _this$ = ecx

; 4337 : {

	push	ebp
	mov	ebp, esp

; 4338 :   if ((code != KDU_MCT) || (num_bytes < 4))

	mov	eax, 65396				; 0000ff74H
	cmp	WORD PTR _code$[ebp], ax
	jne	SHORT $LN3@check_mark
	cmp	DWORD PTR _num_bytes$[ebp], 4
	jl	SHORT $LN3@check_mark

; 4340 :   int i_mct = bytes[2];  i_mct = (i_mct<<8) + bytes[3];

	mov	eax, DWORD PTR _bytes$[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	movzx	eax, BYTE PTR [eax+3]
	shl	ecx, 8
	add	ecx, eax

; 4341 :   c_idx = i_mct & 0x00FF;

	mov	eax, DWORD PTR _c_idx$[ebp]
	movzx	edx, cl
	mov	DWORD PTR [eax], edx

; 4342 :   return ((c_idx >= 1) && (c_idx <= 255) && (((i_mct >> 8) & 3) != 3));

	cmp	edx, 1
	jl	SHORT $LN5@check_mark
	cmp	edx, 255				; 000000ffH
	jg	SHORT $LN5@check_mark
	and	ecx, 768				; 00000300H
	cmp	ecx, 768				; 00000300H
	je	SHORT $LN5@check_mark
	mov	eax, 1

; 4343 : }

	pop	ebp
	ret	16					; 00000010H
$LN5@check_mark:

; 4342 :   return ((c_idx >= 1) && (c_idx <= 255) && (((i_mct >> 8) & 3) != 3));

	xor	eax, eax

; 4343 : }

	pop	ebp
	ret	16					; 00000010H
$LN3@check_mark:

; 4339 :     return false;

	xor	al, al

; 4343 : }

	pop	ebp
	ret	16					; 00000010H
?check_marker_segment@mct_params@@MAE_NGHQAEAAH@Z ENDP	; mct_params::check_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?write_marker_segment@mct_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
_TEXT	SEGMENT
_num_segs$1$ = -72					; size = 4
tv728 = -68						; size = 4
_written_mct_coeffs$1$ = -64				; size = 4
_this$GSCopy$1$ = -60					; size = 4
tv804 = -56						; size = 8
tv798 = -56						; size = 8
tv769 = -56						; size = 8
_seg_mct_coeffs$2$ = -52				; size = 4
_both$1 = -52						; size = 4
_length$1$ = -48					; size = 4
_z$1$ = -44						; size = 4
tv726 = -40						; size = 4
_coeff$2 = -36						; size = 4
_use_ints$1$ = -29					; size = 1
_typed_names$ = -28					; size = 12
_typed_sizes$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_last_marked$ = 12					; size = 4
_tpart_idx$ = 16					; size = 4
?write_marker_segment@mct_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z PROC ; mct_params::write_marker_segment, COMDAT
; _this$ = ecx

; 4472 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	esi, DWORD PTR _out$[ebp]
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx

; 4473 :   if ((inst_idx < 1) || (inst_idx > 255) || (tpart_idx != 0) ||

	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, 1
	jl	$LN18@write_mark
	cmp	eax, 255				; 000000ffH
	jg	$LN18@write_mark
	cmp	DWORD PTR _tpart_idx$[ebp], 0
	jne	$LN18@write_mark
	cmp	DWORD PTR [ebx+12], 0
	jge	$LN18@write_mark

; 4474 :       (comp_idx >= 0))
; 4475 :     return 0;
; 4476 : 
; 4477 :   // Collect the array sizes
; 4478 :   int typed_sizes[3]={0,0,0}; // 0 for triang, 1 for matrix, 2 for vector
; 4479 :   get(Mtriang_size,0,0,typed_sizes[0],false);

	push	edi
	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _typed_sizes$[ebp]
	mov	DWORD PTR _typed_sizes$[ebp], 0
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@CCNKIJHO@Mtriang_size?$AA@
	mov	DWORD PTR _typed_sizes$[ebp+4], 0
	mov	DWORD PTR _typed_sizes$[ebp+8], 0
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 4480 :   get(Mmatrix_size,0,0,typed_sizes[1],false);

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _typed_sizes$[ebp+4]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@FIDBGNAL@Mmatrix_size?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 4481 :   get(Mvector_size,0,0,typed_sizes[2],false);

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _typed_sizes$[ebp+8]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@EBBFOCKJ@Mvector_size?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 4482 : 
; 4483 :   // Calculate the length of all marker segments
; 4484 :   int t, length = 0;
; 4485 :   for (t=0; t < 3; t++)
; 4486 :     {
; 4487 :       if (typed_sizes[t] == 0)

	mov	edi, DWORD PTR _typed_sizes$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR _length$1$[ebp], ebx
	test	edi, edi
	je	SHORT $LN2@write_mark

; 4488 :         continue; // Nothing for this type
; 4489 :       int max_mct_coeffs = (16384-16)/4; // Leaves up to 16 bytes for header
; 4490 :       int num_segs = 1 + ((typed_sizes[t]-1) / max_mct_coeffs);

	lea	ecx, DWORD PTR [edi-1]
	mov	eax, -2145384445			; 80200803H
	imul	ecx
	add	edx, ecx
	sar	edx, 11					; 0000000bH
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 4491 :       length += 10; // Marker code, length, Zmct, Imct and Ymct fields
; 4492 :       length += 8 * (num_segs-1); // Extra segs don't have Ymct
; 4493 :       length += typed_sizes[t] * 4; // the coefficients themselves

	lea	eax, DWORD PTR [edi+eax*2]
	lea	ebx, DWORD PTR [eax*4+10]
	mov	DWORD PTR _length$1$[ebp], ebx
$LN2@write_mark:

; 4482 : 
; 4483 :   // Calculate the length of all marker segments
; 4484 :   int t, length = 0;
; 4485 :   for (t=0; t < 3; t++)
; 4486 :     {
; 4487 :       if (typed_sizes[t] == 0)

	mov	edi, DWORD PTR _typed_sizes$[ebp+4]
	test	edi, edi
	je	SHORT $LN94@write_mark

; 4488 :         continue; // Nothing for this type
; 4489 :       int max_mct_coeffs = (16384-16)/4; // Leaves up to 16 bytes for header
; 4490 :       int num_segs = 1 + ((typed_sizes[t]-1) / max_mct_coeffs);

	lea	ecx, DWORD PTR [edi-1]
	mov	eax, -2145384445			; 80200803H
	imul	ecx
	add	edx, ecx
	sar	edx, 11					; 0000000bH
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 4491 :       length += 10; // Marker code, length, Zmct, Imct and Ymct fields
; 4492 :       length += 8 * (num_segs-1); // Extra segs don't have Ymct
; 4493 :       length += typed_sizes[t] * 4; // the coefficients themselves

	lea	eax, DWORD PTR [edi+eax*2]
	lea	ebx, DWORD PTR [ebx+eax*4]
	add	ebx, 10					; 0000000aH
	mov	DWORD PTR _length$1$[ebp], ebx
$LN94@write_mark:

; 4482 : 
; 4483 :   // Calculate the length of all marker segments
; 4484 :   int t, length = 0;
; 4485 :   for (t=0; t < 3; t++)
; 4486 :     {
; 4487 :       if (typed_sizes[t] == 0)

	mov	edi, DWORD PTR _typed_sizes$[ebp+8]
	test	edi, edi
	je	SHORT $LN96@write_mark

; 4488 :         continue; // Nothing for this type
; 4489 :       int max_mct_coeffs = (16384-16)/4; // Leaves up to 16 bytes for header
; 4490 :       int num_segs = 1 + ((typed_sizes[t]-1) / max_mct_coeffs);

	lea	ecx, DWORD PTR [edi-1]
	mov	eax, -2145384445			; 80200803H
	imul	ecx
	add	edx, ecx
	sar	edx, 11					; 0000000bH
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 4491 :       length += 10; // Marker code, length, Zmct, Imct and Ymct fields
; 4492 :       length += 8 * (num_segs-1); // Extra segs don't have Ymct
; 4493 :       length += typed_sizes[t] * 4; // the coefficients themselves

	lea	eax, DWORD PTR [edi+eax*2]
	lea	ebx, DWORD PTR [ebx+eax*4]
	add	ebx, 10					; 0000000aH
	mov	DWORD PTR _length$1$[ebp], ebx
$LN96@write_mark:

; 4494 :     }
; 4495 : 
; 4496 :   if ((out == NULL) || (length == 0))

	test	esi, esi
	je	$LN21@write_mark
	test	ebx, ebx
	je	$LN21@write_mark

; 4498 : 
; 4499 :   // If we get here, we are committed to actually writing the marker segments
; 4500 :   int acc_length = 0; // Accumulate actual length for verification purposes.
; 4501 :   const char *typed_names[3] = {Mtriang_coeffs,Mmatrix_coeffs,Mvector_coeffs};
; 4502 :   for (t=0; t < 3; t++)

	xor	ebx, ebx
	mov	DWORD PTR _typed_names$[ebp], OFFSET ??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@
	mov	DWORD PTR _typed_names$[ebp+4], OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	mov	DWORD PTR _typed_names$[ebp+8], OFFSET ??_C@_0P@DIALIICI@Mvector_coeffs?$AA@
	mov	DWORD PTR tv728[ebp], 0
	mov	DWORD PTR tv726[ebp], ebx
	npad	7
$LL7@write_mark:

; 4503 :     {
; 4504 :       if (typed_sizes[t] == 0)

	mov	eax, DWORD PTR _typed_sizes$[ebp+ebx]
	test	eax, eax
	je	$LN5@write_mark

; 4505 :         continue; // Nothing for this type
; 4506 : 
; 4507 :       // See if we should use integers or floats to represent the data
; 4508 :       int n;
; 4509 :       float coeff=0.0F;
; 4510 :       bool use_ints = true;
; 4511 :       for (n=0; n < typed_sizes[t]; n++)

	xor	edi, edi
	mov	DWORD PTR _coeff$2[ebp], 0
	mov	BYTE PTR _use_ints$1$[ebp], 1
	test	eax, eax
	jle	SHORT $LN9@write_mark

; 4512 :         {
; 4513 :           get(typed_names[t],n,0,coeff);

	mov	ebx, DWORD PTR _typed_names$[ebp+ebx]
$LL10@write_mark:
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _coeff$2[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	edi
	push	ebx
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	movss	xmm0, DWORD PTR _coeff$2[ebp]

; 4514 :           coeff -= (float) floor(coeff+0.5);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv804[ebp], xmm0
	fld	QWORD PTR tv804[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	movss	xmm1, DWORD PTR _coeff$2[ebp]
	add	esp, 8
	fstp	QWORD PTR tv798[ebp]
	movsd	xmm0, QWORD PTR tv798[ebp]
	cvtpd2ps xmm0, xmm0
	subss	xmm1, xmm0

; 4515 :           if ((coeff > 0.0001F) || (coeff < 0.0001F))

	movss	xmm0, DWORD PTR __real@38d1b717
	comiss	xmm1, xmm0
	movss	DWORD PTR _coeff$2[ebp], xmm1
	ja	SHORT $LN79@write_mark
	comiss	xmm0, xmm1
	ja	SHORT $LN79@write_mark

; 4505 :         continue; // Nothing for this type
; 4506 : 
; 4507 :       // See if we should use integers or floats to represent the data
; 4508 :       int n;
; 4509 :       float coeff=0.0F;
; 4510 :       bool use_ints = true;
; 4511 :       for (n=0; n < typed_sizes[t]; n++)

	mov	eax, DWORD PTR tv726[ebp]
	inc	edi
	cmp	edi, DWORD PTR _typed_sizes$[ebp+eax]
	jl	SHORT $LL10@write_mark

; 4515 :           if ((coeff > 0.0001F) || (coeff < 0.0001F))

	jmp	SHORT $LN102@write_mark
$LN79@write_mark:

; 4516 :             { use_ints = false; break; }

	mov	BYTE PTR _use_ints$1$[ebp], 0
$LN102@write_mark:
	mov	ebx, DWORD PTR tv726[ebp]
$LN9@write_mark:

; 4517 :         }
; 4518 : 
; 4519 :       // Now write the marker segments
; 4520 :       int max_mct_coeffs = (16384-16)/4; // Leaves up to 16 bytes for header
; 4521 :       int z, num_segs = 1 + ((typed_sizes[t]-1) / max_mct_coeffs);

	mov	ecx, DWORD PTR _typed_sizes$[ebp+ebx]
	mov	eax, -2145384445			; 80200803H
	dec	ecx
	imul	ecx
	add	edx, ecx

; 4522 :       int seg_mct_coeffs, written_mct_coeffs=0;

	xor	ecx, ecx
	sar	edx, 11					; 0000000bH
	mov	eax, edx
	mov	DWORD PTR _written_mct_coeffs$1$[ebp], ecx
	shr	eax, 31					; 0000001fH
	inc	edx
	add	edx, eax

; 4523 :       for (z=0; z < num_segs; z++, written_mct_coeffs+=seg_mct_coeffs)

	xor	eax, eax
	mov	DWORD PTR _num_segs$1$[ebp], edx
	mov	DWORD PTR _z$1$[ebp], eax
	test	edx, edx
	jle	$LN5@write_mark
	npad	6
$LL13@write_mark:

; 4524 :         {
; 4525 :           seg_mct_coeffs = typed_sizes[t] - written_mct_coeffs;

	mov	ebx, DWORD PTR _typed_sizes$[ebp+ebx]
	sub	ebx, ecx

; 4526 :           if (seg_mct_coeffs > max_mct_coeffs)

	mov	ecx, 4092				; 00000ffcH
	cmp	ebx, 4092				; 00000ffcH
	cmovg	ebx, ecx

; 4527 :             seg_mct_coeffs = max_mct_coeffs;
; 4528 :           int seg_length = 8 + 4*seg_mct_coeffs + ((z==0)?2:0);

	xor	edi, edi
	test	eax, eax
	mov	DWORD PTR _seg_mct_coeffs$2$[ebp], ebx
	mov	eax, 2
	cmove	edi, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN35@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN35@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN38@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN38@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 116			; 00000074H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4530 :           acc_length += out->put((kdu_uint16)(seg_length-2));

	lea	eax, DWORD PTR [ebx*4+6]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4530 :           acc_length += out->put((kdu_uint16)(seg_length-2));

	add	eax, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4530 :           acc_length += out->put((kdu_uint16)(seg_length-2));

	movzx	ebx, ax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [esi+520]
	jne	SHORT $LN43@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN43@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN46@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN46@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN51@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN51@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ebx, DWORD PTR _z$1$[ebp]
	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN54@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN54@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4532 :           int i_mct = inst_idx + (t<<8);

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
	mov	ecx, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4532 :           int i_mct = inst_idx + (t<<8);

	mov	ebx, DWORD PTR [eax+16]
	add	ebx, DWORD PTR tv728[ebp]

; 4533 :           if (use_ints)
; 4534 :             i_mct += (1<<10); // Record as 32-bit integers

	lea	eax, DWORD PTR [ebx+1024]

; 4535 :           else
; 4536 :             i_mct += (2<<10); // Record as 32-bit floats

	add	ebx, 2048				; 00000800H
	cmp	BYTE PTR _use_ints$1$[ebp], 0
	cmovne	ebx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [esi+520]
	jne	SHORT $LN59@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN59@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN62@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN62@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4538 :           if (z == 0)

	cmp	DWORD PTR _z$1$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4538 :           if (z == 0)

	jne	SHORT $LN28@write_mark

; 4539 :             acc_length += out->put((kdu_uint16)(num_segs-1));

	mov	eax, DWORD PTR _num_segs$1$[ebp]
	dec	eax
	movzx	ebx, ax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [esi+520]
	jne	SHORT $LN67@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN67@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN70@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN70@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
$LN28@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4540 :           for (n=0; n < seg_mct_coeffs; n++)

	mov	ebx, DWORD PTR _seg_mct_coeffs$2$[ebp]
	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN11@write_mark
$LL16@write_mark:

; 4541 :             {
; 4542 :               get(typed_names[t],written_mct_coeffs+n,0,coeff);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _coeff$2[ebp]
	push	1
	push	1
	push	1
	push	eax
	mov	eax, DWORD PTR _written_mct_coeffs$1$[ebp]
	push	0
	add	eax, edi
	push	eax
	mov	eax, DWORD PTR tv726[ebp]
	push	DWORD PTR _typed_names$[ebp+eax]
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 4543 :               if (use_ints)

	cmp	BYTE PTR _use_ints$1$[ebp], 0
	movss	xmm0, DWORD PTR _coeff$2[ebp]
	je	SHORT $LN29@write_mark

; 4544 :                 {
; 4545 :                   int int_coeff = (int) floor(coeff + 0.5);

	cvtps2pd xmm0, xmm0
	sub	esp, 8
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv769[ebp], xmm0
	fld	QWORD PTR tv769[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse

; 4546 :                   acc_length += out->put((kdu_uint32) int_coeff);

	push	eax

; 4547 :                 }
; 4548 :               else

	jmp	SHORT $LN103@write_mark
$LN29@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 170  :         both.fval = val;

	movss	DWORD PTR _both$1[ebp], xmm0

; 171  :         put(both.ival);

	push	DWORD PTR _both$1[ebp]
$LN103@write_mark:
	mov	ecx, esi
	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4540 :           for (n=0; n < seg_mct_coeffs; n++)

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL16@write_mark
$LN11@write_mark:

; 4523 :       for (z=0; z < num_segs; z++, written_mct_coeffs+=seg_mct_coeffs)

	mov	eax, DWORD PTR _z$1$[ebp]
	mov	ecx, DWORD PTR _written_mct_coeffs$1$[ebp]
	inc	eax
	add	ecx, ebx
	mov	DWORD PTR _z$1$[ebp], eax
	mov	ebx, DWORD PTR tv726[ebp]
	mov	DWORD PTR _written_mct_coeffs$1$[ebp], ecx
	cmp	eax, DWORD PTR _num_segs$1$[ebp]
	jl	$LL13@write_mark
$LN5@write_mark:

; 4498 : 
; 4499 :   // If we get here, we are committed to actually writing the marker segments
; 4500 :   int acc_length = 0; // Accumulate actual length for verification purposes.
; 4501 :   const char *typed_names[3] = {Mtriang_coeffs,Mmatrix_coeffs,Mvector_coeffs};
; 4502 :   for (t=0; t < 3; t++)

	add	DWORD PTR tv728[ebp], 256		; 00000100H
	add	ebx, 4
	mov	DWORD PTR tv726[ebp], ebx
	cmp	ebx, 12					; 0000000cH
	jl	$LL7@write_mark

; 4549 :                 acc_length += out->put(coeff);
; 4550 :             }
; 4551 :         }
; 4552 :     }
; 4553 : 
; 4554 :   assert(length == acc_length);
; 4555 :   return length;

	mov	eax, DWORD PTR _length$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 4556 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN21@write_mark:
	pop	edi
	pop	esi

; 4497 :     return length;

	mov	eax, ebx
	pop	ebx

; 4556 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN18@write_mark:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	eax, eax
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?write_marker_segment@mct_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ENDP ; mct_params::write_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?copy_with_xforms@mct_params@@MAEXPAVkdu_params@@HH_N11@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_coeff$ = 8						; size = 4
_source$ = 8						; size = 4
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_transpose$ = 20					; size = 1
_vflip$ = 24						; size = 1
_hflip$ = 28						; size = 1
?copy_with_xforms@mct_params@@MAEXPAVkdu_params@@HH_N11@Z PROC ; mct_params::copy_with_xforms, COMDAT
; _this$ = ecx

; 4260 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi

; 4261 :   float coeff;
; 4262 :   int n, count;
; 4263 :   if (source->get(Mmatrix_size,0,0,count,false) && (count > 0))

	mov	edi, DWORD PTR _source$[ebp]
	lea	eax, DWORD PTR _count$[ebp]
	push	1
	push	1
	push	0
	push	eax
	push	0
	push	0
	mov	ebx, ecx
	mov	ecx, edi
	push	OFFSET ??_C@_0N@FIDBGNAL@Mmatrix_size?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN27@copy_with_
	mov	eax, DWORD PTR _count$[ebp]
	test	eax, eax
	jle	SHORT $LN27@copy_with_

; 4264 :     {
; 4265 :       set(Mmatrix_size,0,0,count);

	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@FIDBGNAL@Mmatrix_size?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4266 :       for (n=0; (n < count) && source->get(Mmatrix_coeffs,n,0,coeff); n++)

	xor	esi, esi
	cmp	DWORD PTR _count$[ebp], esi
	jle	SHORT $LN27@copy_with_
	npad	7
$LL4@copy_with_:
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _coeff$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN27@copy_with_

; 4267 :         set(Mmatrix_coeffs,n,0,coeff);

	movss	xmm0, DWORD PTR _coeff$[ebp]
	sub	esp, 8
	cvtps2pd xmm0, xmm0
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	esi
	push	OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	inc	esi
	cmp	esi, DWORD PTR _count$[ebp]
	jl	SHORT $LL4@copy_with_
$LN27@copy_with_:

; 4268 :     }
; 4269 :   if (source->get(Mvector_size,0,0,count,false) && (count > 0))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _count$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@EBBFOCKJ@Mvector_size?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN28@copy_with_
	mov	eax, DWORD PTR _count$[ebp]
	test	eax, eax
	jle	SHORT $LN28@copy_with_

; 4270 :     {
; 4271 :       set(Mvector_size,0,0,count);

	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@EBBFOCKJ@Mvector_size?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4272 :       for (n=0; (n < count) && source->get(Mvector_coeffs,n,0,coeff); n++)

	xor	esi, esi
	cmp	DWORD PTR _count$[ebp], esi
	jle	SHORT $LN28@copy_with_
	npad	1
$LL7@copy_with_:
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _coeff$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_0P@DIALIICI@Mvector_coeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN28@copy_with_

; 4273 :         set(Mvector_coeffs,n,0,coeff);

	movss	xmm0, DWORD PTR _coeff$[ebp]
	sub	esp, 8
	cvtps2pd xmm0, xmm0
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	esi
	push	OFFSET ??_C@_0P@DIALIICI@Mvector_coeffs?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	inc	esi
	cmp	esi, DWORD PTR _count$[ebp]
	jl	SHORT $LL7@copy_with_
$LN28@copy_with_:

; 4274 :     }
; 4275 :   if (source->get(Mtriang_size,0,0,count,false) && (count > 0))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _count$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@CCNKIJHO@Mtriang_size?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN29@copy_with_
	mov	eax, DWORD PTR _count$[ebp]
	test	eax, eax
	jle	SHORT $LN29@copy_with_

; 4276 :     {
; 4277 :       set(Mtriang_size,0,0,count);

	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@CCNKIJHO@Mtriang_size?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4278 :       for (n=0; (n < count) && source->get(Mtriang_coeffs,n,0,coeff); n++)

	xor	esi, esi
	cmp	DWORD PTR _count$[ebp], esi
	jle	SHORT $LN29@copy_with_
	npad	1
$LL10@copy_with_:
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _coeff$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN29@copy_with_

; 4279 :         set(Mtriang_coeffs,n,0,coeff);

	movss	xmm0, DWORD PTR _coeff$[ebp]
	sub	esp, 8
	cvtps2pd xmm0, xmm0
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	esi
	push	OFFSET ??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@
	call	?set@kdu_params@@QAEXPBDHHN@Z		; kdu_params::set
	inc	esi
	cmp	esi, DWORD PTR _count$[ebp]
	jl	SHORT $LL10@copy_with_
$LN29@copy_with_:
	pop	edi
	pop	esi
	pop	ebx

; 4280 :     }
; 4281 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?copy_with_xforms@mct_params@@MAEXPAVkdu_params@@HH_N11@Z ENDP ; mct_params::copy_with_xforms
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?finalize@mct_params@@MAEX_N@Z
_TEXT	SEGMENT
_e$2 = -64						; size = 20
_e$3 = -44						; size = 20
_e$4 = -44						; size = 20
_e$5 = -44						; size = 20
_coeff$ = -24						; size = 4
_triang_size$ = -20					; size = 4
_vector_size$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_matrix_size$ = 8					; size = 4
_after_reading$ = 8					; size = 1
?finalize@mct_params@@MAEX_N@Z PROC			; mct_params::finalize, COMDAT
; _this$ = ecx

; 4289 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?finalize@mct_params@@MAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 4290 :   if (after_reading)

	cmp	BYTE PTR _after_reading$[ebp], 0
	je	SHORT $LN2@finalize

; 4291 :     {
; 4292 :       if ((Zmct_matrix_next <= Zmct_matrix_final) ||
; 4293 :           (Zmct_vector_next <= Zmct_vector_final) ||

	mov	eax, DWORD PTR [esi+88]
	cmp	eax, DWORD PTR [esi+92]
	jle	SHORT $LN4@finalize
	mov	eax, DWORD PTR [esi+96]
	cmp	eax, DWORD PTR [esi+100]
	jle	SHORT $LN4@finalize
	mov	eax, DWORD PTR [esi+104]
	cmp	eax, DWORD PTR [esi+108]
	jg	$LN10@finalize
$LN4@finalize:

; 4295 :         { KDU_ERROR(e,0x20070500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0KN@OBNKNPAB@Failed?5to?5read?5all?5MCT?5marker?5se@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4295 :         { KDU_ERROR(e,0x20070500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4299 :         }

	lea	ecx, DWORD PTR _e$5[ebp]

; 4300 :       return;

	jmp	$LN30@finalize
$LN2@finalize:

; 4301 :     }
; 4302 :   int matrix_size=0, vector_size=0, triang_size=0;
; 4303 :   float coeff;
; 4304 :   if ((get(Mmatrix_size,0,0,matrix_size,false) && (matrix_size <= 0)) ||
; 4305 :       (get(Mvector_size,0,0,vector_size,false) && (vector_size <= 0)) ||

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _matrix_size$[ebp]
	mov	DWORD PTR _matrix_size$[ebp], 0
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@FIDBGNAL@Mmatrix_size?$AA@
	mov	DWORD PTR _vector_size$[ebp], 0
	mov	DWORD PTR _triang_size$[ebp], 0
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN7@finalize
	cmp	DWORD PTR _matrix_size$[ebp], 0
	jle	SHORT $LN6@finalize
$LN7@finalize:
	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _vector_size$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@EBBFOCKJ@Mvector_size?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN8@finalize
	cmp	DWORD PTR _vector_size$[ebp], 0
	jle	SHORT $LN6@finalize
$LN8@finalize:
	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _triang_size$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@CCNKIJHO@Mtriang_size?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN27@finalize
	cmp	DWORD PTR _triang_size$[ebp], 0
	jg	SHORT $LN27@finalize
$LN6@finalize:

; 4307 :     { KDU_ERROR(e,0x20070501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0JE@JFBAAJII@Illegal?5value?5?$CIanything?5?$DM?$DN?50?$CJ?5fo@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4307 :     { KDU_ERROR(e,0x20070501); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4311 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN27@finalize:

; 4312 :   if ((inst_idx == 0) && (matrix_size | vector_size | triang_size))

	cmp	DWORD PTR [esi+16], 0
	mov	ecx, DWORD PTR _matrix_size$[ebp]
	jne	SHORT $LN9@finalize
	mov	eax, DWORD PTR _triang_size$[ebp]
	or	eax, DWORD PTR _vector_size$[ebp]
	or	eax, ecx
	je	SHORT $LN9@finalize

; 4313 :     { KDU_ERROR(e,0x21070501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0OJ@PDOPGBL@It?5is?5illegal?5to?5supply?5?$GAMvector@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4313 :     { KDU_ERROR(e,0x21070501); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4318 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _matrix_size$[ebp]
$LN9@finalize:

; 4319 :   if (((matrix_size > 0) && !get(Mmatrix_coeffs,matrix_size-1,0,coeff)) ||
; 4320 :       ((vector_size > 0) && !get(Mvector_coeffs,vector_size-1,0,coeff)) ||

	test	ecx, ecx
	jle	SHORT $LN12@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _coeff$[ebp]
	push	eax
	push	0
	lea	eax, DWORD PTR [ecx-1]
	mov	ecx, esi
	push	eax
	push	OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN11@finalize
$LN12@finalize:
	mov	eax, DWORD PTR _vector_size$[ebp]
	test	eax, eax
	jle	SHORT $LN13@finalize
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _coeff$[ebp]
	dec	eax
	push	ecx
	push	0
	push	eax
	push	OFFSET ??_C@_0P@DIALIICI@Mvector_coeffs?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN11@finalize
$LN13@finalize:
	mov	eax, DWORD PTR _triang_size$[ebp]
	test	eax, eax
	jle	SHORT $LN10@finalize
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _coeff$[ebp]
	dec	eax
	push	ecx
	push	0
	push	eax
	push	OFFSET ??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN10@finalize
$LN11@finalize:

; 4322 :     { KDU_ERROR(e,0x20070502); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0NI@PEHFOKHE@The?5number?5of?5?$GAMmatrix_coeffs?8?0?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4322 :     { KDU_ERROR(e,0x20070502); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4327 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
$LN30@finalize:
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN10@finalize:

; 4328 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?finalize@mct_params@@MAEX_N@Z$0:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@mct_params@@MAEX_N@Z$1:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@mct_params@@MAEX_N@Z$2:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@mct_params@@MAEX_N@Z$3:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?finalize@mct_params@@MAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?finalize@mct_params@@MAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?finalize@mct_params@@MAEX_N@Z ENDP			; mct_params::finalize
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?new_object@mct_params@@MAEPAVkdu_params@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_object@mct_params@@MAEPAVkdu_params@@XZ PROC	; mct_params::new_object, COMDAT
; _this$ = ecx

; 2162 :     virtual kdu_params *new_object()  { return new mct_params(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_object@mct_params@@MAEPAVkdu_params@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_object
	mov	ecx, eax
	call	??0mct_params@@QAE@XZ			; mct_params::mct_params
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_object:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_object@mct_params@@MAEPAVkdu_params@@XZ$0:
	push	112					; 00000070H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?new_object@mct_params@@MAEPAVkdu_params@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_object@mct_params@@MAEPAVkdu_params@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_object@mct_params@@MAEPAVkdu_params@@XZ ENDP	; mct_params::new_object
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0mct_params@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0mct_params@@QAE@XZ PROC				; mct_params::mct_params, COMDAT
; _this$ = ecx

; 4163 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0mct_params@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 4162 :   : kdu_params(MCT_params,true,false,true,false,true)

	push	1
	push	0
	push	1
	push	0
	push	1
	push	OFFSET ??_C@_03BLMOALMK@MCT?$AA@
	call	??0kdu_params@@QAE@PBD_N1111@Z		; kdu_params::kdu_params

; 4164 :   define_attribute(Mmatrix_size,

	push	0
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0DPN@GBDINPGJ@Identifies?5the?5number?5of?5matrix?5@
	push	OFFSET ??_C@_0N@FIDBGNAL@Mmatrix_size?$AA@
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7mct_params@@6B@
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 4165 :     "Identifies the number of matrix elements, if any, represented "
; 4166 :     "by this object.  The actual matrix coefficients are represented "
; 4167 :     "by the `Mmatrix_coeffs' attribute.  Matrices are used to describe "
; 4168 :     "reversible and irreversible inverse component decorrelation "
; 4169 :     "transforms.  This is done by referencing the current attribute's "
; 4170 :     "instance index from the second field in each record of the "
; 4171 :     "`Mstage_xforms' attribute used to describe a multi-component "
; 4172 :     "transformation stage.  Thus, for example, "
; 4173 :     "\"Mstage_xforms:I1={MATRIX,1,4,0,0},{MATRIX,3,0,1,0}\" declares that "
; 4174 :     "a given multi-component transform stage, having instance index 1, "
; 4175 :     "and two component collections, employs matrix transforms for both "
; 4176 :     "collections.  The first collection's matrix is described by "
; 4177 :     "`Mmatrix_size:I1' and `Mmatrix_coeffs:I1', while the second "
; 4178 :     "collection's matrix is described by `Mmatrix_size:I3' and "
; 4179 :     "`Mmatrix_coeffs:I3'.  To understand the last two fields in each "
; 4180 :     "record of the `Mstage_xforms' attribute, please refer to the "
; 4181 :     "separate description of that attribute.",
; 4182 :     "I");
; 4183 :   define_attribute(Mmatrix_coeffs,

	push	1
	push	OFFSET ??_C@_01BIAFAFID@F?$AA@
	push	OFFSET ??_C@_0BGK@IHFIBLIK@Coefficients?5of?5the?5matrix?0?5if?5t@
	push	OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 4184 :     "Coefficients of the matrix, if there is one, whose number of "
; 4185 :     "elements is given by `Mmatrix_size'.  The coefficients appear "
; 4186 :     "in row-major order (first row, then second row, etc.).  The "
; 4187 :     "height and width of the matrix are not recorded here, but "
; 4188 :     "matrices are not required to be square.  For reversible transforms, "
; 4189 :     "the matrix coefficients are required to be integers.",
; 4190 :     "F",MULTI_RECORD);
; 4191 :   define_attribute(Mvector_size,

	push	0
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0DNI@IDMIDCPL@Identifies?5the?5number?5of?5vector?5@
	push	OFFSET ??_C@_0N@EBBFOCKJ@Mvector_size?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 4192 :     "Identifies the number of vector elements, if any, represented "
; 4193 :     "by this object.  The actual vector coefficients are represented "
; 4194 :     "by the `Mvector_coeffs' attribute.  Vectors are used to describe "
; 4195 :     "offsets to be applied to the component sample values after "
; 4196 :     "inverse transformation.  This is done by referencing the current "
; 4197 :     "attribute's instance index from the third field in each record of "
; 4198 :     "the `Mstage_xforms' attribute used to describe a multi-component "
; 4199 :     "transform stage.  Thus, for example, "
; 4200 :     "\"Mstage_xforms:I1={MATRIX,1,4,0,0},{MATRIX,3,0,1,0}\" declares that "
; 4201 :     "a given multi-component transform stage, having instance index 1, "
; 4202 :     "and two component collections, employs matrix transforms for both "
; 4203 :     "collections.  The first collection also involves offsets, described "
; 4204 :     "via `Mvector_size:I4' and `Mvector_coeffs:I4', while the second "
; 4205 :     "collection does not use offsets.  to understand the remaining fields "
; 4206 :     "in each record of the `Mstage_xforms' attribute, consult the separate "
; 4207 :     "description of that attribute.",
; 4208 :     "I");
; 4209 :   define_attribute(Mvector_coeffs,

	push	3
	push	OFFSET ??_C@_01BIAFAFID@F?$AA@
	push	OFFSET ??_C@_0BEO@GFEMDFDK@Coefficients?5of?5the?5vector?0?5if?5t@
	push	OFFSET ??_C@_0P@DIALIICI@Mvector_coeffs?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 4210 :     "Coefficients of the vector, if there is one, whose number of "
; 4211 :     "elements is given by `Mvector_size'.  Unlike `Mmatrix_coeffs' and "
; 4212 :     "`Mtriang_coeffs', this attribute is extrapolated if insufficient "
; 4213 :     "parameters are supplied -- that is, the last supplied value is "
; 4214 :     "replicated as required in order to provide all `Mvector_size' "
; 4215 :     "vector elements.",
; 4216 :     "F",MULTI_RECORD|CAN_EXTRAPOLATE);
; 4217 :   define_attribute(Mtriang_size,

	push	0
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0EBK@HDHPILKI@Identifies?5the?5total?5number?5of?5s@
	push	OFFSET ??_C@_0N@CCNKIJHO@Mtriang_size?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 4218 :     "Identifies the total number of sub-triangular matrix elements, "
; 4219 :     "if any, represented by this object.  A sub-triangular matrix is "
; 4220 :     "square, with no coefficients above the diagonal and at least one "
; 4221 :     "coefficient missing from the diagonal.  A strictly sub-triangular "
; 4222 :     "M x M matrix will have M*(M-1)/2 coefficients, all below the diagonal.  "
; 4223 :     "Matrices of this form are used to describe irreversible multicomponent "
; 4224 :     "dependency transforms.  Reversible dependency transforms, however, "
; 4225 :     "include all but the upper left diagonal entry, for a total of "
; 4226 :     "M*(M+1)/2-1 coefficients.  Dependency transforms are described by "
; 4227 :     "referencing the current attribute's instance index from the second "
; 4228 :     "field in each record of the `Mstage_xforms' attribute used to "
; 4229 :     "describe a multi-component transform stage.  Thus, for example, "
; 4230 :     "\"Mstage_xforms:I1={DEP,5,0,0,0}\" declares that "
; 4231 :     "a given multi-component transform stage, having instance index 1, "
; 4232 :     "and one component collection, employs a dependency transform, whose "
; 4233 :     "coefficients are counted by `Mtriang_size:I5' and found in "
; 4234 :     "`Mtriang_coeffs:I5'.",
; 4235 :     "I");
; 4236 :   define_attribute(Mtriang_coeffs,

	push	1
	push	OFFSET ??_C@_01BIAFAFID@F?$AA@
	push	OFFSET ??_C@_0CAB@FHBPNALP@Coefficients?5of?5the?5sub?9triangul@
	push	OFFSET ??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 4237 :     "Coefficients of the sub-triangular matrix, if any, whose number "
; 4238 :     "of elements is represented by the `Mtriang_size' attribute.  The "
; 4239 :     "coefficients are arranged in row-major order.  Thus, for a "
; 4240 :     "dependency transform with M inputs and outputs, the first coefficient "
; 4241 :     "(first two for reversible transforms) comes from the second "
; 4242 :     "row of the matrix, the next two (three for reversible transforms) "
; 4243 :     "comes from the third row of the matrix, and so forth.  For "
; 4244 :     "reversible transforms, the coefficients must all have integer values.",
; 4245 :     "F",MULTI_RECORD);
; 4246 :   
; 4247 :   Zmct_matrix_next = 0;  Zmct_matrix_final = -1;

	mov	DWORD PTR [esi+88], 0

; 4248 :   Zmct_vector_next = 0;  Zmct_vector_final = -1;
; 4249 :   Zmct_triang_next = 0;  Zmct_triang_final = -1;
; 4250 : }

	mov	eax, esi
	mov	DWORD PTR [esi+92], -1
	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+100], -1
	mov	DWORD PTR [esi+104], 0
	mov	DWORD PTR [esi+108], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0mct_params@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
__ehhandler$??0mct_params@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0mct_params@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0mct_params@@QAE@XZ ENDP				; mct_params::mct_params
; Function compile flags: /Ogtp
;	COMDAT ??_Gsiz_params@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsiz_params@@UAEPAXI@Z PROC				; siz_params::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gsiz_params@@UAEPAXI@Z ENDP				; siz_params::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1siz_params@@UAE@XZ
_TEXT	SEGMENT
??1siz_params@@UAE@XZ PROC				; siz_params::~siz_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1siz_params@@UAE@XZ ENDP				; siz_params::~siz_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?read_marker_segment@siz_params@@MAE_NGHQAEH@Z
_TEXT	SEGMENT
_e$2 = -220						; size = 20
$T3 = -200						; size = 4
$T4 = -196						; size = 4
$T5 = -192						; size = 4
$T6 = -188						; size = 4
$T7 = -184						; size = 4
$T8 = -180						; size = 4
$T9 = -176						; size = 4
$T10 = -172						; size = 4
$T11 = -168						; size = 4
$T12 = -164						; size = 4
$T13 = -160						; size = 4
$T14 = -156						; size = 4
$T15 = -152						; size = 4
$T16 = -148						; size = 4
$T17 = -144						; size = 4
_e$18 = -140						; size = 20
_e$19 = -140						; size = 20
_e$20 = -140						; size = 20
_e$21 = -140						; size = 20
_val$4$ = -120						; size = 4
_num_components$1$ = -120				; size = 4
tv1065 = -120						; size = 4
_val$1$ = -116						; size = 4
_val$4$ = -116						; size = 4
_uses_cap$22 = -116					; size = 1
_val$4$ = -112						; size = 4
_num_components$2$ = -112				; size = 4
_profile$1$ = -112					; size = 4
_val$4$ = -108						; size = 4
_precision$1$ = -108					; size = 4
_extensions$1$ = -108					; size = 4
_this$GSCopy$1$ = -104					; size = 4
_c$2$ = -104						; size = 4
_text$23 = -100						; size = 80
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_tpart_idx$ = 20					; size = 4
?read_marker_segment@siz_params@@MAE_NGHQAEH@Z PROC	; siz_params::read_marker_segment, COMDAT
; _this$ = ecx

; 3610 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx

; 3611 :   if (tpart_idx != 0)

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	mov	eax, DWORD PTR _num_bytes$[ebp]
	mov	esi, DWORD PTR _bytes$[ebp]
	jne	$LN23@read_marke

; 3612 :     return false;
; 3613 :   kdu_byte *bp=bytes, *end=bytes+num_bytes;

	lea	edi, DWORD PTR [esi+eax]

; 3614 :   int c, num_components, precision;
; 3615 : 
; 3616 :   if (code == KDU_SIZ)

	mov	ecx, 65361				; 0000ff51H
	mov	ax, WORD PTR _code$[ebp]
	cmp	ax, cx
	jne	$LN9@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3619 :       try {

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN43@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T17[ebp]
	mov	DWORD PTR $T17[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN169@read_marke:
$LN43@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	ecx, 8
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3621 :           bool uses_cap = (profile & 0x4000)?true:false;

	mov	eax, ecx
	shr	eax, 14					; 0000000eH
	and	al, 1
	mov	BYTE PTR _uses_cap$22[ebp], al

; 3622 :           if (profile & 0x8000)

	test	ecx, 32768				; 00008000H
	je	SHORT $LN12@read_marke

; 3623 :             {
; 3624 :               extensions = profile & 0x3FFF;

	and	ecx, 16383				; 00003fffH
	mov	DWORD PTR _extensions$1$[ebp], ecx

; 3625 :               profile = 3;

	mov	ecx, 3

; 3626 :             }
; 3627 :           else

	jmp	SHORT $LN19@read_marke
$LN12@read_marke:

; 3628 :             {
; 3629 :               extensions = 0;
; 3630 :               profile &= ~0x4000;

	and	ecx, -16385				; ffffbfffH
	mov	DWORD PTR _extensions$1$[ebp], 0
	mov	DWORD PTR _profile$1$[ebp], ecx

; 3631 :               if ((profile < 0) || (profile > 4))

	jl	SHORT $LN15@read_marke
	cmp	ecx, 4
	jle	SHORT $LN14@read_marke
$LN15@read_marke:

; 3632 :                 { KDU_ERROR(e,0x21040503); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$21[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$21[ebp]
	lea	ecx, DWORD PTR _e$21[ebp]
	push	OFFSET ??_C@_0CI@CLEFFBLP@Invalid?5SIZ?5marker?5segment?5encou@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3632 :                 { KDU_ERROR(e,0x21040503); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3634 :                 }

	lea	ecx, DWORD PTR _e$21[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _profile$1$[ebp]
$LN14@read_marke:

; 3635 :               if (profile == 0)

	test	ecx, ecx
	jne	SHORT $LN16@read_marke

; 3636 :                 profile = 2; // The unrestricted profile (Profile-2) has Rsiz=0

	mov	ecx, 2
	jmp	SHORT $LN19@read_marke
$LN16@read_marke:

; 3637 :               else if (profile >= 3)

	cmp	ecx, 3
	jl	SHORT $LN18@read_marke

; 3638 :                 profile++;

	inc	ecx

; 3639 :               else

	jmp	SHORT $LN19@read_marke
$LN18@read_marke:

; 3640 :                 profile--;

	dec	ecx
$LN19@read_marke:

; 3641 :             }
; 3642 :           set(Sprofile,0,0,profile);

	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3643 :           set(Sextensions,0,0,extensions);

	push	DWORD PTR _extensions$1$[ebp]
	mov	ecx, ebx
	push	0
	push	0
	push	OFFSET ??_C@_0M@NJJFAENN@Sextensions?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3644 :           set(Scap,0,0,uses_cap);

	push	DWORD PTR _uses_cap$22[ebp]
	mov	ecx, ebx
	push	0
	push	0
	push	OFFSET ??_C@_04JNHDNPF@Scap?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 4
	jge	SHORT $LN60@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T16[ebp]
	mov	DWORD PTR $T16[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN170@read_marke:
$LN60@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax

; 95   :   if (nbytes > 2)
; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+2]
	shl	ecx, 8
	add	ecx, eax

; 98   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+3]
	shl	ecx, 8
	add	esi, 4
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3648 :           set(Ssize,0,1,size.x=kdu_read(bp,end,4));

	push	ecx
	push	1
	push	0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 98   :     val = (val<<8) + *(bp++);

	mov	DWORD PTR _val$4$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3648 :           set(Ssize,0,1,size.x=kdu_read(bp,end,4));

	mov	ecx, ebx
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 4
	jge	SHORT $LN66@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T15[ebp]
	mov	DWORD PTR $T15[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN171@read_marke:
$LN66@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax

; 95   :   if (nbytes > 2)
; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+2]
	shl	ecx, 8
	add	ecx, eax

; 98   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+3]
	shl	ecx, 8
	add	esi, 4
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3649 :           set(Ssize,0,0,size.y=kdu_read(bp,end,4));

	push	ecx
	push	0
	push	0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 98   :     val = (val<<8) + *(bp++);

	mov	DWORD PTR _val$4$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3649 :           set(Ssize,0,0,size.y=kdu_read(bp,end,4));

	mov	ecx, ebx
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 4
	jge	SHORT $LN72@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T14[ebp]
	mov	DWORD PTR $T14[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN172@read_marke:
$LN72@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax

; 95   :   if (nbytes > 2)
; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+2]
	shl	ecx, 8
	add	ecx, eax

; 98   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+3]
	shl	ecx, 8
	add	esi, 4
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3650 :           set(Sorigin,0,1,origin.x=kdu_read(bp,end,4));

	push	ecx
	push	1
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 4
	jge	SHORT $LN78@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T13[ebp]
	mov	DWORD PTR $T13[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN173@read_marke:
$LN78@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax

; 95   :   if (nbytes > 2)
; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+2]
	shl	ecx, 8
	add	ecx, eax

; 98   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+3]
	shl	ecx, 8
	add	esi, 4
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3651 :           set(Sorigin,0,0,origin.y=kdu_read(bp,end,4));

	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 4
	jge	SHORT $LN84@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T12[ebp]
	mov	DWORD PTR $T12[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN174@read_marke:
$LN84@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax

; 95   :   if (nbytes > 2)
; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+2]
	shl	ecx, 8
	add	ecx, eax

; 98   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+3]
	shl	ecx, 8
	add	esi, 4
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3652 :           set(Stiles,0,1,tiles.x=kdu_read(bp,end,4));

	push	ecx
	push	1
	push	0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 98   :     val = (val<<8) + *(bp++);

	mov	DWORD PTR _val$4$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3652 :           set(Stiles,0,1,tiles.x=kdu_read(bp,end,4));

	mov	ecx, ebx
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 4
	jge	SHORT $LN90@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR $T11[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN175@read_marke:
$LN90@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax

; 95   :   if (nbytes > 2)
; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+2]
	shl	ecx, 8
	add	ecx, eax

; 98   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+3]
	shl	ecx, 8
	add	esi, 4
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3653 :           set(Stiles,0,0,tiles.y=kdu_read(bp,end,4));

	push	ecx
	push	0
	push	0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 98   :     val = (val<<8) + *(bp++);

	mov	DWORD PTR _val$4$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3653 :           set(Stiles,0,0,tiles.y=kdu_read(bp,end,4));

	mov	ecx, ebx
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 4
	jge	SHORT $LN96@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR $T10[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN176@read_marke:
$LN96@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax

; 95   :   if (nbytes > 2)
; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+2]
	shl	ecx, 8
	add	ecx, eax

; 98   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+3]
	shl	ecx, 8
	add	esi, 4
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3654 :           set(Stile_origin,0,1,tile_origin.x=kdu_read(bp,end,4));

	push	ecx
	push	1
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 4
	jge	SHORT $LN102@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR $T9[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN177@read_marke:
$LN102@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax

; 95   :   if (nbytes > 2)
; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+2]
	shl	ecx, 8
	add	ecx, eax

; 98   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+3]
	shl	ecx, 8
	add	esi, 4
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3655 :           set(Stile_origin,0,0,tile_origin.y=kdu_read(bp,end,4));

	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3656 : 
; 3657 :           if ((tiles.x < 0) && (size.x >= 0))

	cmp	DWORD PTR _val$4$[ebp], 0
	jge	SHORT $LN20@read_marke
	mov	eax, DWORD PTR _val$4$[ebp]
	test	eax, eax
	js	SHORT $LN20@read_marke

; 3658 :             set(Stiles,0,1,tiles.x=size.x);

	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN20@read_marke:

; 3659 :           if ((tiles.y < 0) && (size.y >= 0))

	cmp	DWORD PTR _val$4$[ebp], 0
	jge	SHORT $LN21@read_marke
	mov	eax, DWORD PTR _val$4$[ebp]
	test	eax, eax
	js	SHORT $LN21@read_marke

; 3660 :             set(Stiles,0,0,tiles.y=size.y);

	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN21@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN108@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR $T8[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN178@read_marke:
$LN108@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	ecx, 8
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3667 :           set(Scomponents,0,0,num_components = kdu_read(bp,end,2));

	push	ecx
	push	0
	push	0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 94   :     val = (val<<8) + *(bp++);

	mov	DWORD PTR _num_components$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3667 :           set(Scomponents,0,0,num_components = kdu_read(bp,end,2));

	mov	ecx, ebx
	push	OFFSET ??_C@_0M@LFKICJFJ@Scomponents?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3668 :           for (c=0; c < num_components; c++)

	xor	ebx, ebx
	npad	4
$LL4@read_marke:
	cmp	ebx, DWORD PTR _num_components$1$[ebp]
	jge	$LN3@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN114@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T7[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN179@read_marke:
$LN114@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3671 :               set(Ssigned,c,0,(precision>>7)&1);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 92   :   val = *(bp++);

	mov	DWORD PTR _val$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3671 :               set(Ssigned,c,0,(precision>>7)&1);

	sar	eax, 7
	and	eax, 1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_07MGJMMJC@Ssigned?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3672 :               set(Sprecision,c,0,(precision&0x7F)+1);

	mov	eax, DWORD PTR _val$1$[ebp]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	and	eax, 127				; 0000007fH
	inc	eax
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0L@BADPNFGK@Sprecision?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN120@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T6[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN180@read_marke:
$LN120@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3673 :               set(Ssampling,c,1,kdu_read(bp,end,1));

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	eax
	push	1
	push	ebx
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN126@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T5[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN181@read_marke:
$LN126@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3674 :               set(Ssampling,c,0,kdu_read(bp,end,1));

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	inc	ebx
	jmp	$LL4@read_marke
$LN3@read_marke:

; 3675 :             }
; 3676 :           if (bp != end)

	cmp	esi, edi
	je	SHORT $LN39@read_marke

; 3677 :             { KDU_ERROR(e,74); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$20[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0DF@MIHNMLL@Malformed?5SIZ?5marker?5segment?5enc@
$LN168@read_marke:
	mov	eax, DWORD PTR _e$20[ebp]
	lea	ecx, DWORD PTR _e$20[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3679 :                 << (int)(end-bp) <<

	sub	edi, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	BYTE PTR _e$20[ebp+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	edi
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$23[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$23[ebp]
	lea	ecx, DWORD PTR _e$20[ebp]
	push	eax
	mov	eax, DWORD PTR _e$20[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$20[ebp]
	lea	ecx, DWORD PTR _e$20[ebp]
	push	OFFSET ??_C@_0BK@CHACHIIH@?5bytes?5were?5not?5consumed?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3681 :             }

	lea	ecx, DWORD PTR _e$20[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN39@read_marke:

; 3688 :       return true;

	mov	al, 1
	jmp	$LN1@read_marke
__catch$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$0:

; 3684 :         { KDU_ERROR(e,75); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$19[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$19[ebp]
	lea	ecx, DWORD PTR _e$19[ebp]
	push	OFFSET ??_C@_0EH@PJEAPICM@Malformed?5SIZ?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3684 :         { KDU_ERROR(e,75); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3687 :         }

	lea	ecx, DWORD PTR _e$19[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN39@read_marke
	ret	0
$LN9@read_marke:

; 3689 :     }
; 3690 :   else if (code == KDU_CBD)

	mov	ecx, 65400				; 0000ff78H
	cmp	ax, cx
	jne	$LN23@read_marke
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3692 :       try {

	mov	DWORD PTR __$EHRec$[ebp+12], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	sub	eax, esi
	cmp	eax, 2
	jge	SHORT $LN140@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T4[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN182@read_marke:
$LN140@read_marke:

; 92   :   val = *(bp++);

	movzx	ecx, BYTE PTR [esi]

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	ecx, 8
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3694 :           bool all_same = (num_components & 0x8000)?true:false;

	mov	eax, ecx

; 3695 :           num_components &= 0x7FFF;

	and	ecx, 32767				; 00007fffH

; 3696 :           set(Mcomponents,0,0,num_components);

	push	ecx
	push	0
	shr	eax, 15					; 0000000fH
	push	0
	and	eax, -255				; ffffff01H
	mov	DWORD PTR _num_components$2$[ebp], ecx
	push	OFFSET ??_C@_0M@FAIBBHLL@Mcomponents?$AA@
	mov	ecx, ebx
	mov	DWORD PTR tv1065[ebp], eax
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	edx, DWORD PTR _num_components$2$[ebp]

; 3697 :           precision=0;

	xor	eax, eax

; 3698 :           for (c=0; c < num_components; c++)

	xor	ecx, ecx
$LN167@read_marke:
	mov	DWORD PTR _c$2$[ebp], ecx
	cmp	ecx, edx
	jge	SHORT $LN6@read_marke

; 3699 :             {
; 3700 :               if ((precision == 0) || !all_same)

	test	eax, eax
	je	SHORT $LN26@read_marke
	cmp	BYTE PTR tv1065[ebp], 0
	jne	SHORT $LN5@read_marke
$LN26@read_marke:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 1
	jge	SHORT $LN146@read_marke

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T3[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN183@read_marke:
$LN146@read_marke:

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [esi]
	inc	esi
	mov	DWORD PTR _precision$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3703 :                   set(Msigned,c,0,(precision>>7)&1);

	sar	eax, 7
	and	eax, 1
	push	eax
	push	0
	push	ecx
	push	OFFSET ??_C@_07GFFIOPIL@Msigned?$AA@
	mov	ecx, ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3704 :                   set(Mprecision,c,0,(precision&0x7F)+1);

	mov	eax, DWORD PTR _precision$1$[ebp]
	mov	ecx, ebx
	and	eax, 127				; 0000007fH
	inc	eax
	push	eax
	push	0
	push	DWORD PTR _c$2$[ebp]
	push	OFFSET ??_C@_0L@OMLPDKKH@Mprecision?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	ecx, DWORD PTR _c$2$[ebp]
	mov	eax, DWORD PTR _precision$1$[ebp]
	mov	edx, DWORD PTR _num_components$2$[ebp]
$LN5@read_marke:

; 3698 :           for (c=0; c < num_components; c++)

	inc	ecx
	jmp	SHORT $LN167@read_marke
$LN6@read_marke:

; 3705 :                 }
; 3706 :             }
; 3707 :           if (bp != end)

	cmp	esi, edi
	je	$LN39@read_marke

; 3708 :             { KDU_ERROR(e,0x19070504); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$18[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
	mov	BYTE PTR __$EHRec$[ebp+12], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0DF@PNFFNEFI@Malformed?5CBD?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
	jmp	$LN168@read_marke
__catch$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$2:

; 3715 :         { KDU_ERROR(e,0x19070505); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EH@FOFCLFAN@Malformed?5CBD?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3715 :         { KDU_ERROR(e,0x19070505); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3718 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, $LN39@read_marke
	ret	0
$LN23@read_marke:

; 3719 :       return true;
; 3720 :     }
; 3721 : 
; 3722 :   return false;

	xor	al, al
$LN1@read_marke:

; 3723 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN166@read_marke:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$4:
	lea	ecx, DWORD PTR _e$21[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$5:
	lea	ecx, DWORD PTR _e$20[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$6:
	lea	ecx, DWORD PTR _e$19[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$7:
	lea	ecx, DWORD PTR _e$18[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z$8:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-224]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_marker_segment@siz_params@@MAE_NGHQAEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_marker_segment@siz_params@@MAE_NGHQAEH@Z ENDP	; siz_params::read_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?check_marker_segment@siz_params@@MAE_NGHQAEAAH@Z
_TEXT	SEGMENT
_output_comps$1 = 8					; size = 4
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_c_idx$ = 20						; size = 4
?check_marker_segment@siz_params@@MAE_NGHQAEAAH@Z PROC	; siz_params::check_marker_segment, COMDAT
; _this$ = ecx

; 3586 : {

	push	ebp
	mov	ebp, esp

; 3587 :   c_idx = -1;

	mov	eax, DWORD PTR _c_idx$[ebp]
	push	esi
	mov	esi, ecx

; 3588 :   if (code == KDU_SIZ)

	mov	ecx, 65361				; 0000ff51H
	mov	DWORD PTR [eax], -1
	mov	ax, WORD PTR _code$[ebp]
	cmp	ax, cx
	je	SHORT $LN6@check_mark

; 3589 :     return true;
; 3590 :   else if (code == KDU_CBD)

	mov	ecx, 65400				; 0000ff78H
	cmp	ax, cx
	jne	SHORT $LN4@check_mark

; 3591 :     { // If this is a CBD marker segment and the SIZ marker segment has
; 3592 :       // already been parsed, clear the `marked' flag so as to allow the
; 3593 :       // CBD marker segment to be parsed by this object as well.
; 3594 :       int output_comps;
; 3595 :       if (!get(Mcomponents,0,0,output_comps))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _output_comps$1[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@FAIBBHLL@Mcomponents?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN6@check_mark

; 3596 :         marked = false;

	mov	BYTE PTR [esi+29], al
$LN6@check_mark:

; 3597 :       return true;

	mov	al, 1
	pop	esi

; 3601 : }

	pop	ebp
	ret	16					; 00000010H
$LN4@check_mark:

; 3598 :     }
; 3599 :   else
; 3600 :     return false;

	xor	al, al
	pop	esi

; 3601 : }

	pop	ebp
	ret	16					; 00000010H
?check_marker_segment@siz_params@@MAE_NGHQAEAAH@Z ENDP	; siz_params::check_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
_TEXT	SEGMENT
_e$2 = -348						; size = 20
_profile$ = -328					; size = 4
_out$GSCopy$1$ = -324					; size = 4
_extensions$ = -320					; size = 4
_this$GSCopy$1$ = -316					; size = 4
_c$1$ = -312						; size = 4
_yr$3 = -308						; size = 4
_xr$4 = -304						; size = 4
_yp$5 = -300						; size = 4
_xp$6 = -296						; size = 4
_yr$ = -292						; size = 4
_levels$7 = -288					; size = 4
_xr$ = -284						; size = 4
_cbd_length$1$ = -280					; size = 4
_is_signed$ = -276					; size = 4
_siz_length$1$ = -272					; size = 4
_num_output_components$ = -268				; size = 4
_xto$ = -264						; size = 4
_yt$ = -260						; size = 4
_xt$ = -256						; size = 4
_y_lcm$1$ = -252					; size = 4
_yo$ = -248						; size = 4
_y$ = -244						; size = 4
_x$ = -240						; size = 4
_y_off$1$ = -236					; size = 4
_t$1$ = -236						; size = 4
_num_components$ = -232					; size = 4
_yto$ = -228						; size = 4
_xo$ = -224						; size = 4
_uses_cap$ = -217					; size = 1
_precision$ = -216					; size = 4
_x_off$1$ = -212					; size = 4
_cod$1$ = -212						; size = 4
_e$8 = -208						; size = 20
_e$9 = -208						; size = 20
_e$10 = -208						; size = 20
_e$11 = -208						; size = 20
_e$12 = -208						; size = 20
_e$13 = -208						; size = 20
_e$14 = -208						; size = 20
_e$15 = -208						; size = 20
_e$16 = -208						; size = 20
_e$17 = -208						; size = 20
_e$18 = -208						; size = 20
_r_siz$1$ = -188					; size = 4
_x_lcm$1$ = -188					; size = 4
_word$1$ = -184						; size = 4
_word$1$ = -184						; size = 4
_word$1$ = -184						; size = 4
_word$1$ = -184						; size = 4
_num_tiles$1$ = -184					; size = 4
_byte$1$ = -177						; size = 1
_byte$1$ = -177						; size = 1
_byte$1$ = -177						; size = 1
_byte$1$ = -177						; size = 1
_use_precincts$19 = -177				; size = 1
_text$20 = -176						; size = 80
_text$21 = -176						; size = 80
_text$22 = -96						; size = 80
_text$23 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_out$ = 8						; size = 4
_last_marked$ = 12					; size = 4
_tpart_idx$ = 16					; size = 4
?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z PROC ; siz_params::write_marker_segment, COMDAT
; _this$ = ecx

; 3373 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], esi

; 3374 :   bool uses_cap;
; 3375 :   int profile, extensions, x, y, xo, yo, xt, yt, xto, yto, num_components;
; 3376 : 
; 3377 :   assert(last_marked == NULL);
; 3378 :   if (tpart_idx != 0)

	cmp	DWORD PTR _tpart_idx$[ebp], 0
	mov	ebx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _out$GSCopy$1$[ebp], ebx
	je	SHORT $LN17@write_mark

; 3379 :     return 0;

	xor	eax, eax
	jmp	$LN1@write_mark
$LN17@write_mark:

; 3380 :   if (!(get(Sprofile,0,0,profile) &&

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _profile$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN19@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _uses_cap$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04JNHDNPF@Scap?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN19@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _extensions$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@NJJFAENN@Sextensions?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN19@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _y$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN19@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _x$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN19@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _yo$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN19@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _xo$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN19@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _yt$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN19@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _xt$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN19@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _yto$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN19@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _xto$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN19@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _num_components$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@LFKICJFJ@Scomponents?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN18@write_mark
$LN19@write_mark:

; 3388 :     { KDU_ERROR_DEV(e,64); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$18[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$18[ebp]
	lea	ecx, DWORD PTR _e$18[ebp]
	push	OFFSET ??_C@_0CI@CMGIGAHL@Unable?5to?5write?5SIZ?5marker?5segme@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3388 :     { KDU_ERROR_DEV(e,64); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3390 :     }

	lea	ecx, DWORD PTR _e$18[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN18@write_mark:

; 3391 : 
; 3392 :   if ((num_components < 1) || (num_components > 16384))

	mov	eax, DWORD PTR _num_components$[ebp]
	cmp	eax, 1
	jl	SHORT $LN21@write_mark
	cmp	eax, 16384				; 00004000H
	jle	SHORT $LN20@write_mark
$LN21@write_mark:

; 3393 :     { KDU_ERROR_DEV(e,65); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$17[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$17[ebp]
	lea	ecx, DWORD PTR _e$17[ebp]
	push	OFFSET ??_C@_0EF@JGBMKHNL@Illegal?5number?5of?5image?5componen@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3393 :     { KDU_ERROR_DEV(e,65); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3396 :     }

	lea	ecx, DWORD PTR _e$17[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _num_components$[ebp]
$LN20@write_mark:

; 3397 : 
; 3398 :   int siz_length = 4 + 2 + 4*8 + 2 + 3*num_components;
; 3399 :   int cbd_length = 0;
; 3400 :   int num_output_components;
; 3401 :   if (get(Mcomponents,0,0,num_output_components) &&

	push	1
	lea	eax, DWORD PTR [eax+eax*2]
	xor	edi, edi
	push	1
	add	eax, 40					; 00000028H
	mov	DWORD PTR _cbd_length$1$[ebp], edi
	push	1
	mov	DWORD PTR _siz_length$1$[ebp], eax
	mov	ecx, esi
	lea	eax, DWORD PTR _num_output_components$[ebp]
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_0M@FAIBBHLL@Mcomponents?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN22@write_mark
	mov	eax, DWORD PTR _num_output_components$[ebp]
	test	eax, eax
	je	SHORT $LN22@write_mark

; 3402 :       (num_output_components != 0))
; 3403 :     {
; 3404 :       if ((num_output_components < 1) || (num_output_components > 16384))

	cmp	eax, 1
	jl	SHORT $LN24@write_mark
	cmp	eax, 16384				; 00004000H
	jle	SHORT $LN23@write_mark
$LN24@write_mark:

; 3405 :         { KDU_ERROR_DEV(e,0x19070501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$16[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	OFFSET ??_C@_0FJ@POPHKFAB@Illegal?5number?5of?5MCT?5output?5com@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3405 :         { KDU_ERROR_DEV(e,0x19070501); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3408 :         }

	lea	ecx, DWORD PTR _e$16[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _num_output_components$[ebp]
$LN23@write_mark:

; 3409 :       cbd_length = 6 + num_output_components;

	lea	edi, DWORD PTR [eax+6]
	mov	DWORD PTR _cbd_length$1$[ebp], edi
$LN22@write_mark:

; 3410 :     }
; 3411 :   if (out == NULL)

	test	ebx, ebx
	jne	SHORT $LN25@write_mark

; 3412 :     return siz_length + cbd_length;

	mov	eax, DWORD PTR _siz_length$1$[ebp]
	add	eax, edi
	jmp	$LN1@write_mark
$LN25@write_mark:

; 3413 : 
; 3414 :   // Deal with negative canvas coordinates.
; 3415 :   if ((xto < 0) || (yto < 0)) // These are the most negative coordinates

	mov	edi, DWORD PTR _xto$[ebp]
	mov	ecx, DWORD PTR _yto$[ebp]
	test	edi, edi
	js	SHORT $LN27@write_mark
	test	ecx, ecx
	js	SHORT $LN27@write_mark
	mov	edx, DWORD PTR _yo$[ebp]
	mov	eax, DWORD PTR _xo$[ebp]
	jmp	$LN26@write_mark
$LN27@write_mark:

; 3416 :     { /* For a better understanding of canvas coordinate equivalence
; 3417 :          transformations, consult Section 11.4.2 of the book by Taubman
; 3418 :          and Marcellin. */
; 3419 : 
; 3420 :       int x_lcm = xt; // Coordinate shifts must at least be multiples

	mov	eax, DWORD PTR _xt$[ebp]

; 3421 :       int y_lcm = yt; // of the relevant tile dimensions.

	mov	edx, DWORD PTR _yt$[ebp]
	mov	DWORD PTR _x_lcm$1$[ebp], eax

; 3422 : 
; 3423 :       // Before proceeding, let's see if there is in fact only one tile
; 3424 :       // (across, down, or in both directions).  If so, the amount of
; 3425 :       // translation need not be divisible by the tile size, so long as
; 3426 :       // we ensure that the output image also has only one tile (across, down
; 3427 :       // or in both directions).  We can arrange for this by modifying both
; 3428 :       // the LCM values initialized above and the tile origin position.
; 3429 :       if ((xto+xt) >= x)

	add	eax, edi
	mov	DWORD PTR _y_lcm$1$[ebp], edx
	cmp	eax, DWORD PTR _x$[ebp]
	jl	SHORT $LN28@write_mark

; 3430 :         { x_lcm = 1;  xto = xo; }

	mov	eax, DWORD PTR _xo$[ebp]
	mov	DWORD PTR _x_lcm$1$[ebp], 1
	mov	DWORD PTR _xto$[ebp], eax
$LN28@write_mark:

; 3431 :       if ((yto+yt) >= y)

	lea	eax, DWORD PTR [ecx+edx]
	cmp	eax, DWORD PTR _y$[ebp]
	jl	SHORT $LN29@write_mark

; 3432 :         { y_lcm = 1;  yto = yo; }

	mov	eax, DWORD PTR _yo$[ebp]
	mov	DWORD PTR _y_lcm$1$[ebp], 1
	mov	DWORD PTR _yto$[ebp], eax
$LN29@write_mark:

; 3433 : 
; 3434 :       kdu_params *cod = this->access_cluster(COD_params);

	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	mov	ecx, esi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	edi, eax

; 3435 :       int num_tiles = ceil_ratio(x-xo,xt) * ceil_ratio(y-yo,yt);

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, DWORD PTR _xo$[ebp]
	mov	DWORD PTR _cod$1$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN83@write_mark

; 180  :     return -((-num)/den);

	cdq
	idiv	DWORD PTR _xt$[ebp]
	mov	ecx, eax
	jmp	SHORT $LN84@write_mark
$LN83@write_mark:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	DWORD PTR _xt$[ebp]
	lea	ecx, DWORD PTR [eax+1]
$LN84@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3435 :       int num_tiles = ceil_ratio(x-xo,xt) * ceil_ratio(y-yo,yt);

	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _yo$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN87@write_mark

; 180  :     return -((-num)/den);

	cdq
	idiv	DWORD PTR _yt$[ebp]
	jmp	SHORT $LN88@write_mark
$LN87@write_mark:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	DWORD PTR _yt$[ebp]
	inc	eax
$LN88@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3435 :       int num_tiles = ceil_ratio(x-xo,xt) * ceil_ratio(y-yo,yt);

	imul	eax, ecx

; 3436 :       for (int t=-1; t < num_tiles; t++)

	or	ecx, -1
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _num_tiles$1$[ebp], eax
	cmp	eax, ecx
	jle	$LN3@write_mark
	mov	eax, DWORD PTR _num_components$[ebp]
	mov	edx, DWORD PTR _num_tiles$1$[ebp]
	npad	2
$LL4@write_mark:

; 3437 :         for (int c=0; c < num_components; c++)

	xor	ebx, ebx
	mov	DWORD PTR _c$1$[ebp], ebx
	test	eax, eax
	jle	$LN2@write_mark
$LL7@write_mark:

; 3438 :           {
; 3439 :             int xr=1, yr=1;
; 3440 :             get(Ssampling,c,0,yr); get(Ssampling,c,1,xr);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _yr$3[ebp]
	mov	DWORD PTR _xr$4[ebp], 1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	mov	ecx, esi
	mov	DWORD PTR _yr$3[ebp], 1
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _xr$4[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	ebx
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 3441 :             int levels;
; 3442 :             bool use_precincts;
; 3443 :             if ((cod == NULL) ||
; 3444 :                 ((cod = cod->access_relation(t,c,0,true)) == NULL) ||

	test	edi, edi
	je	SHORT $LN32@write_mark
	push	1
	push	0
	push	ebx
	push	DWORD PTR _t$1$[ebp]
	mov	ecx, edi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	edi, eax
	mov	DWORD PTR _cod$1$[ebp], edi
	test	edi, edi
	je	SHORT $LN32@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _levels$7[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN32@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _use_precincts$19[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN30@write_mark
$LN32@write_mark:

; 3447 :               { KDU_ERROR_DEV(e,66); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$15[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$15[ebp]
	lea	ecx, DWORD PTR _e$15[ebp]
	push	OFFSET ??_C@_0NO@JDICNLBH@Attempting?5to?5write?5geometricall@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3447 :               { KDU_ERROR_DEV(e,66); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3453 :               }

	lea	ecx, DWORD PTR _e$15[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN30@write_mark:

; 3454 :             int r=levels, res_exp=0;

	mov	esi, DWORD PTR _levels$7[ebp]

; 3455 :             for (; r >= 0; r--, res_exp++)

	test	esi, esi
	js	$LN5@write_mark
	npad	5
$LL10@write_mark:

; 3456 :               {
; 3457 :                 int xp=15, yp=15;
; 3458 :                 if (use_precincts)

	cmp	BYTE PTR _use_precincts$19[ebp], 0
	mov	eax, 15					; 0000000fH
	mov	edx, eax
	mov	DWORD PTR _xp$6[ebp], eax
	mov	DWORD PTR _yp$5[ebp], edx
	je	SHORT $LN33@write_mark

; 3459 :                   { cod->get(Cprecincts,(levels-r),0,yp);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _yp$5[ebp]
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR _levels$7[ebp]
	push	0
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 3460 :                     cod->get(Cprecincts,(levels-r),1,xp); }

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _xp$6[ebp]
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR _levels$7[ebp]
	push	1
	sub	eax, esi
	push	eax
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	eax, DWORD PTR _xp$6[ebp]
	mov	edx, DWORD PTR _yp$5[ebp]
$LN33@write_mark:

; 3461 :                 kdu_int32 x_precinct = xr<<(xp+r); // Precinct dimensions on

	mov	ebx, DWORD PTR _xr$4[ebp]
	lea	ecx, DWORD PTR [eax+esi]

; 3462 :                 kdu_int32 y_precinct = yr<<(yp+r); // full resolution canvas

	mov	edi, DWORD PTR _yr$3[ebp]
	shl	ebx, cl
	lea	ecx, DWORD PTR [edx+esi]
	shl	edi, cl

; 3463 :                 if ((x_precinct <= 0) || (y_precinct <= 0))

	test	ebx, ebx
	jle	SHORT $LN35@write_mark
	test	edi, edi
	jg	SHORT $LN34@write_mark
$LN35@write_mark:

; 3464 :                   { KDU_ERROR(e,67); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$14[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	OFFSET ??_C@_0OI@OALKHBMD@Error?5attempting?5to?5convert?5geom@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3464 :                   { KDU_ERROR(e,67); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3470 :                   }

	lea	ecx, DWORD PTR _e$14[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN34@write_mark:

; 3471 :                 x_lcm = find_lcm(x_lcm,x_precinct);

	mov	ecx, DWORD PTR _x_lcm$1$[ebp]
	push	ebx
	push	ecx
	call	?find_lcm@@YAHHH@Z			; find_lcm

; 3472 :                 y_lcm = find_lcm(y_lcm,y_precinct);

	mov	ecx, DWORD PTR _y_lcm$1$[ebp]
	push	edi
	push	ecx
	mov	DWORD PTR _x_lcm$1$[ebp], eax
	call	?find_lcm@@YAHHH@Z			; find_lcm
	mov	edi, DWORD PTR _cod$1$[ebp]
	add	esp, 16					; 00000010H
	sub	esi, 1
	mov	DWORD PTR _y_lcm$1$[ebp], eax
	jns	$LL10@write_mark
	mov	ebx, DWORD PTR _c$1$[ebp]
$LN5@write_mark:

; 3437 :         for (int c=0; c < num_components; c++)

	mov	eax, DWORD PTR _num_components$[ebp]
	inc	ebx
	mov	edi, DWORD PTR _cod$1$[ebp]
	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR _c$1$[ebp], ebx
	cmp	ebx, eax
	jl	$LL7@write_mark
	mov	ecx, DWORD PTR _t$1$[ebp]
	mov	edx, DWORD PTR _num_tiles$1$[ebp]
$LN2@write_mark:

; 3436 :       for (int t=-1; t < num_tiles; t++)

	inc	ecx
	mov	DWORD PTR _t$1$[ebp], ecx
	cmp	ecx, edx
	jl	$LL4@write_mark
	mov	ebx, DWORD PTR _out$GSCopy$1$[ebp]
$LN3@write_mark:

; 3477 :         int x_off = (xto < 0)?(x_lcm * ceil_ratio(-xto,x_lcm)):0;

	mov	edi, DWORD PTR _xto$[ebp]
	test	edi, edi
	jns	SHORT $LN60@write_mark
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 180  :     return -((-num)/den);

	mov	ecx, DWORD PTR _x_lcm$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3477 :         int x_off = (xto < 0)?(x_lcm * ceil_ratio(-xto,x_lcm)):0;

	mov	eax, edi
	neg	eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN95@write_mark

; 180  :     return -((-num)/den);

	cdq
	idiv	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3477 :         int x_off = (xto < 0)?(x_lcm * ceil_ratio(-xto,x_lcm)):0;

	imul	eax, ecx
	mov	DWORD PTR _x_off$1$[ebp], eax
	jmp	SHORT $LN61@write_mark
$LN95@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ecx
	inc	eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3477 :         int x_off = (xto < 0)?(x_lcm * ceil_ratio(-xto,x_lcm)):0;

	imul	eax, ecx
	mov	DWORD PTR _x_off$1$[ebp], eax
	jmp	SHORT $LN61@write_mark
$LN60@write_mark:
	mov	DWORD PTR _x_off$1$[ebp], 0
$LN61@write_mark:

; 3478 :         int y_off = (yto < 0)?(y_lcm * ceil_ratio(-yto,y_lcm)):0;

	mov	ecx, DWORD PTR _yto$[ebp]
	test	ecx, ecx
	jns	SHORT $LN62@write_mark
	neg	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	ecx, ecx
	jg	SHORT $LN99@write_mark

; 180  :     return -((-num)/den);

	mov	eax, ecx
	mov	ecx, DWORD PTR _y_lcm$1$[ebp]
	cdq
	idiv	ecx
	mov	edx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3478 :         int y_off = (yto < 0)?(y_lcm * ceil_ratio(-yto,y_lcm)):0;

	imul	edx, ecx
	mov	ecx, DWORD PTR _yto$[ebp]
	jmp	SHORT $LN223@write_mark
$LN99@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ecx-1]
	mov	ecx, DWORD PTR _y_lcm$1$[ebp]
	cdq
	idiv	ecx
	lea	edx, DWORD PTR [eax+1]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3478 :         int y_off = (yto < 0)?(y_lcm * ceil_ratio(-yto,y_lcm)):0;

	imul	edx, ecx
	mov	ecx, DWORD PTR _yto$[ebp]
	jmp	SHORT $LN223@write_mark
$LN62@write_mark:
	xor	edx, edx
$LN223@write_mark:

; 3479 :         x += x_off; xo += x_off; xto += x_off;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _x_off$1$[ebp]

; 3480 :         y += y_off; yo += y_off; yto += y_off;

	add	DWORD PTR _y$[ebp], edx
	add	edi, DWORD PTR _x_off$1$[ebp]
	mov	DWORD PTR _y_off$1$[ebp], edx
	mov	edx, DWORD PTR _yo$[ebp]
	add	edx, DWORD PTR _y_off$1$[ebp]
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _xo$[ebp]
	add	eax, DWORD PTR _x_off$1$[ebp]
	add	ecx, DWORD PTR _y_off$1$[ebp]
	mov	DWORD PTR _xo$[ebp], eax
	mov	DWORD PTR _xto$[ebp], edi
	mov	DWORD PTR _yo$[ebp], edx
	mov	DWORD PTR _yto$[ebp], ecx
$LN26@write_mark:

; 3481 :         assert((xto >= 0) && (yto >= 0));
; 3482 :     }
; 3483 : 
; 3484 :   // Check for legal sequencing of the tile and image origins.
; 3485 :   if ((xo < xto) || (yo < yto) || (xo >= (xto+xt)) || (yo >= (yto+yt)) ||
; 3486 :       (x <= xo) || (y <= yo))

	cmp	eax, edi
	jl	SHORT $LN37@write_mark
	cmp	edx, ecx
	jl	SHORT $LN37@write_mark
	mov	eax, DWORD PTR _xt$[ebp]
	add	eax, edi
	mov	edi, DWORD PTR _xo$[ebp]
	cmp	edi, eax
	jge	SHORT $LN37@write_mark
	mov	eax, DWORD PTR _yt$[ebp]
	add	eax, ecx
	cmp	edx, eax
	jge	SHORT $LN37@write_mark
	cmp	DWORD PTR _x$[ebp], edi
	jle	SHORT $LN37@write_mark
	cmp	DWORD PTR _y$[ebp], edx
	jg	SHORT $LN36@write_mark
$LN37@write_mark:

; 3487 :     { KDU_ERROR_DEV(e,68); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$13[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	OFFSET ??_C@_0JL@PMLPBNBK@Cannot?5write?5SIZ?5marker?5with?5ill@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3487 :     { KDU_ERROR_DEV(e,68); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3491 :     }

	lea	ecx, DWORD PTR _e$13[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN36@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [ebx+516]
	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN107@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN107@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	eax, DWORD PTR [ebx+516]
	inc	eax
	mov	DWORD PTR [ebx+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN110@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN110@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
	mov	BYTE PTR [eax], 81			; 00000051H
	mov	ecx, DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3495 :   acc_length += out->put((kdu_uint16)(siz_length-2));

	mov	eax, DWORD PTR _siz_length$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3495 :   acc_length += out->put((kdu_uint16)(siz_length-2));

	add	eax, -2					; fffffffeH
	mov	DWORD PTR [ebx+516], ecx
	movzx	eax, ax
	mov	DWORD PTR _word$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [ebx+520]
	jne	SHORT $LN115@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _word$1$[ebp]
$LN115@write_mark:

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, eax

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [ebx+516]
	inc	eax
	mov	DWORD PTR [ebx+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN118@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN118@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
	mov	ecx, DWORD PTR _word$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3497 :   kdu_uint16 r_siz = 0;

	mov	DWORD PTR _r_siz$1$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3498 :   if (profile == 3)

	mov	eax, DWORD PTR _profile$[ebp]
	cmp	eax, 3
	jne	SHORT $LN38@write_mark

; 3499 :     r_siz = ((kdu_uint16) extensions) | 0x8000; // Part-2 codestream

	mov	eax, DWORD PTR _extensions$[ebp]
	or	eax, 32768				; 00008000H
	movzx	eax, ax
	mov	DWORD PTR _r_siz$1$[ebp], eax
	jmp	SHORT $LN46@write_mark
$LN38@write_mark:

; 3500 :   else if ((extensions != 0) || (profile > 5) || (profile < 0))

	cmp	DWORD PTR _extensions$[ebp], 0
	jne	SHORT $LN42@write_mark
	cmp	eax, 5
	ja	SHORT $LN42@write_mark

; 3506 :   else if (profile == 2)

	cmp	eax, 2
	jne	SHORT $LN43@write_mark

; 3507 :     r_siz = 0; // Generic Part-1 codestream

	xor	eax, eax
	mov	DWORD PTR _r_siz$1$[ebp], eax
	jmp	SHORT $LN46@write_mark
$LN43@write_mark:

; 3508 :   else if (profile > 3)

	cmp	eax, 3
	jle	SHORT $LN45@write_mark

; 3509 :     r_siz = (kdu_uint16)(profile-1); // Digital Cinema profiles

	dec	eax
	movzx	eax, ax
	mov	DWORD PTR _r_siz$1$[ebp], eax

; 3510 :   else

	jmp	SHORT $LN46@write_mark
$LN45@write_mark:

; 3511 :     r_siz = (kdu_uint16)(profile+1); // Part-1 Profile-0/Profile-1 codestream

	inc	eax
	movzx	eax, ax
	mov	DWORD PTR _r_siz$1$[ebp], eax
	jmp	SHORT $LN46@write_mark
$LN42@write_mark:

; 3501 :     { KDU_ERROR(e,0x21040502); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$12[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_0HF@BDHEFLHF@Illegal?5profile?5index?4?5?5?$CCSprofil@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3501 :     { KDU_ERROR(e,0x21040502); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3505 :     }

	lea	ecx, DWORD PTR _e$12[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	xor	eax, eax
$LN46@write_mark:

; 3512 :   if (uses_cap)

	cmp	BYTE PTR _uses_cap$[ebp], 0
	je	SHORT $LN47@write_mark

; 3513 :     r_siz |= 0x4000;

	or	eax, 16384				; 00004000H
	mov	DWORD PTR _r_siz$1$[ebp], eax
$LN47@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [ebx+516]
	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN125@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN125@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, DWORD PTR _r_siz$1$[ebp]
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [ebx+516]
	inc	eax
	mov	DWORD PTR [ebx+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN128@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN128@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
	mov	ecx, DWORD PTR _r_siz$1$[ebp]
	mov	BYTE PTR [eax], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3516 :   acc_length += out->put((kdu_uint32) x);

	mov	ecx, ebx
	push	DWORD PTR _x$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3516 :   acc_length += out->put((kdu_uint32) x);

	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put

; 3517 :   acc_length += out->put((kdu_uint32) y);

	push	DWORD PTR _y$[ebp]
	mov	ecx, ebx
	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put

; 3518 :   acc_length += out->put((kdu_uint32) xo);

	push	DWORD PTR _xo$[ebp]
	mov	ecx, ebx
	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put

; 3519 :   acc_length += out->put((kdu_uint32) yo);

	push	DWORD PTR _yo$[ebp]
	mov	ecx, ebx
	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put

; 3520 :   acc_length += out->put((kdu_uint32) xt);

	push	DWORD PTR _xt$[ebp]
	mov	ecx, ebx
	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put

; 3521 :   acc_length += out->put((kdu_uint32) yt);

	push	DWORD PTR _yt$[ebp]
	mov	ecx, ebx
	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put

; 3522 :   acc_length += out->put((kdu_uint32) xto);

	push	DWORD PTR _xto$[ebp]
	mov	ecx, ebx
	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put

; 3523 :   acc_length += out->put((kdu_uint32) yto);

	push	DWORD PTR _yto$[ebp]
	mov	ecx, ebx
	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put

; 3524 :   acc_length += out->put((kdu_uint16) num_components);

	movzx	eax, WORD PTR _num_components$[ebp]
	mov	DWORD PTR _word$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [ebx+516]
	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN133@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN133@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, DWORD PTR _word$1$[ebp]
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [ebx+516]
	inc	eax
	mov	DWORD PTR [ebx+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN136@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN136@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3526 :   for (c=0; c < num_components; c++)

	xor	edi, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR _word$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [ebx+516]
	mov	eax, DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3526 :   for (c=0; c < num_components; c++)

	cmp	DWORD PTR _num_components$[ebp], edi
	jle	$LN12@write_mark
	npad	3
$LL13@write_mark:

; 3527 :     {
; 3528 :       if (!(get(Ssigned,c,0,is_signed) && get(Sprecision,c,0,precision) &&

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _is_signed$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_07MGJMMJC@Ssigned?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN49@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _precision$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0L@BADPNFGK@Sprecision?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN49@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _yr$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN49@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _xr$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN48@write_mark
$LN49@write_mark:

; 3530 :         { KDU_ERROR_DEV(e,70); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$11[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_0GO@MOMFJPHA@Unable?5to?5write?5SIZ?5marker?5segme@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3530 :         { KDU_ERROR_DEV(e,70); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3533 :         }

	lea	ecx, DWORD PTR _e$11[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN48@write_mark:

; 3534 :       if ((precision < 1) || (precision > 38))

	mov	ecx, DWORD PTR _precision$[ebp]
	cmp	ecx, 1
	jl	SHORT $LN51@write_mark
	cmp	ecx, 38					; 00000026H
	jle	$LN50@write_mark
$LN51@write_mark:

; 3535 :         { KDU_ERROR_DEV(e,71); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$10[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0CB@NEMDCGAB@Illegal?5image?5sample?5bit?9depth?0?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3535 :         { KDU_ERROR_DEV(e,71); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$10[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _precision$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$21[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$21[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	eax
	mov	eax, DWORD PTR _e$10[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0CP@NJAPNNOL@?4?5Legal?5range?5is?5from?51?5to?538?5bi@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3538 :         }

	lea	ecx, DWORD PTR _e$10[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _precision$[ebp]
$LN50@write_mark:

; 3539 :       if ((xr < 1) || (xr > 255) || (yr < 1) || (yr > 255))

	mov	eax, DWORD PTR _xr$[ebp]
	dec	eax
	cmp	eax, 254				; 000000feH
	ja	SHORT $LN53@write_mark
	mov	eax, DWORD PTR _yr$[ebp]
	cmp	eax, 1
	jl	SHORT $LN53@write_mark
	cmp	eax, 255				; 000000ffH
	jle	$LN52@write_mark
$LN53@write_mark:

; 3540 :         { KDU_ERROR_DEV(e,72); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$9[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0CK@FCLHCLL@Illegal?5component?5sub?9sampling?5f@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3540 :         { KDU_ERROR_DEV(e,72); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 9
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$9[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _yr$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$20[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$20[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	eax
	mov	eax, DWORD PTR _e$9[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$9[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _xr$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$23[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$23[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	eax
	mov	eax, DWORD PTR _e$9[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0CB@HBCCFDNA@?$HN?4?5Legal?5range?5is?5from?51?5to?5255?4@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3544 :         }

	lea	ecx, DWORD PTR _e$9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _precision$[ebp]
$LN52@write_mark:

; 3545 :       acc_length += out->put((kdu_byte)(precision-1 + (is_signed<<7)));

	mov	al, BYTE PTR _is_signed$[ebp]
	shl	al, 7
	dec	al
	add	al, cl
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [ebx+516]
	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN157@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN157@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [ebx+516]
	mov	eax, DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3546 :       acc_length += out->put((kdu_byte) xr);

	mov	cl, BYTE PTR _xr$[ebp]
	mov	BYTE PTR _byte$1$[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN160@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
	mov	cl, BYTE PTR _byte$1$[ebp]
$LN160@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [ebx+516]
	mov	eax, DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3547 :       acc_length += out->put((kdu_byte) yr);

	mov	cl, BYTE PTR _yr$[ebp]
	mov	BYTE PTR _byte$1$[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN163@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
	mov	cl, BYTE PTR _byte$1$[ebp]
$LN163@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3526 :   for (c=0; c < num_components; c++)

	inc	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [ebx+516]
	mov	eax, DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3526 :   for (c=0; c < num_components; c++)

	cmp	edi, DWORD PTR _num_components$[ebp]
	jl	$LL13@write_mark
$LN12@write_mark:

; 3548 :     }
; 3549 :   assert(acc_length == siz_length);
; 3550 :   if (cbd_length == 0)

	mov	edi, DWORD PTR _cbd_length$1$[ebp]
	test	edi, edi
	jne	SHORT $LN54@write_mark

; 3551 :     return siz_length;

	mov	eax, DWORD PTR _siz_length$1$[ebp]
	jmp	$LN1@write_mark
$LN54@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN168@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN168@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	eax, DWORD PTR [ebx+516]
	inc	eax
	mov	DWORD PTR [ebx+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN171@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN171@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
	mov	BYTE PTR [eax], 120			; 00000078H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3556 :   acc_length += out->put((kdu_uint16)(cbd_length-2));

	lea	eax, DWORD PTR [edi-2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [ebx+516]
	inc	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3556 :   acc_length += out->put((kdu_uint16)(cbd_length-2));

	movzx	eax, ax
	mov	DWORD PTR [ebx+516], ecx
	mov	DWORD PTR _word$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [ebx+520]
	jne	SHORT $LN176@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _word$1$[ebp]
$LN176@write_mark:

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, eax

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [ebx+516]
	inc	eax
	mov	DWORD PTR [ebx+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN179@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN179@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
	mov	ecx, DWORD PTR _word$1$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3557 :   acc_length += out->put((kdu_uint16) num_output_components);

	movzx	ecx, WORD PTR _num_output_components$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	eax
	mov	DWORD PTR [ebx+516], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3557 :   acc_length += out->put((kdu_uint16) num_output_components);

	mov	DWORD PTR _word$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN184@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _word$1$[ebp]
$LN184@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [ebx+516]
	inc	eax
	mov	DWORD PTR [ebx+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN187@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN187@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3558 :   for (c=0; c < num_output_components; c++)

	xor	edi, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR _word$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3558 :   for (c=0; c < num_output_components; c++)

	cmp	DWORD PTR _num_output_components$[ebp], edi
	jle	$LN15@write_mark
	npad	7
$LL16@write_mark:

; 3559 :     {
; 3560 :       if (!(get(Msigned,c,0,is_signed) && get(Mprecision,c,0,precision)))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _is_signed$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_07GFFIOPIL@Msigned?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN56@write_mark
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _precision$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0L@OMLPDKKH@Mprecision?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN55@write_mark
$LN56@write_mark:

; 3561 :         { KDU_ERROR_DEV(e,0x19070502); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0HM@MMCEOMEI@Unable?5to?5write?5CBD?5marker?5segme@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3561 :         { KDU_ERROR_DEV(e,0x19070502); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3565 :         }

	lea	ecx, DWORD PTR _e$8[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN55@write_mark:

; 3566 :       if ((precision < 1) || (precision > 38))

	mov	ecx, DWORD PTR _precision$[ebp]
	cmp	ecx, 1
	jl	SHORT $LN58@write_mark
	cmp	ecx, 38					; 00000026H
	jle	$LN57@write_mark
$LN58@write_mark:

; 3567 :         { KDU_ERROR_DEV(e,0x19070503); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0CN@JHCHBCDJ@Illegal?5precision?5for?5MCT?5output@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3567 :         { KDU_ERROR_DEV(e,0x19070503); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$2[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _precision$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$22[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$22[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	eax
	mov	eax, DWORD PTR _e$2[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0CP@NJAPNNOL@?4?5Legal?5range?5is?5from?51?5to?538?5bi@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3571 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _precision$[ebp]
$LN57@write_mark:

; 3572 :       acc_length += out->put((kdu_byte)(precision-1 + (is_signed<<7)));

	mov	al, BYTE PTR _is_signed$[ebp]
	shl	al, 7
	dec	al
	add	al, cl
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [ebx+516]
	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN198@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN198@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3558 :   for (c=0; c < num_output_components; c++)

	inc	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3558 :   for (c=0; c < num_output_components; c++)

	cmp	edi, DWORD PTR _num_output_components$[ebp]
	jl	$LL16@write_mark
$LN15@write_mark:

; 3573 :     }
; 3574 :   assert(acc_length == cbd_length);
; 3575 : 
; 3576 :   return siz_length + cbd_length;

	mov	eax, DWORD PTR _cbd_length$1$[ebp]
	add	eax, DWORD PTR _siz_length$1$[ebp]
$LN1@write_mark:

; 3577 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$0:
	lea	ecx, DWORD PTR _e$18[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$1:
	lea	ecx, DWORD PTR _e$17[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$2:
	lea	ecx, DWORD PTR _e$16[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$3:
	lea	ecx, DWORD PTR _e$15[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$4:
	lea	ecx, DWORD PTR _e$14[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$5:
	lea	ecx, DWORD PTR _e$13[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$6:
	lea	ecx, DWORD PTR _e$12[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$7:
	lea	ecx, DWORD PTR _e$11[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$8:
	lea	ecx, DWORD PTR _e$10[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$9:
	lea	ecx, DWORD PTR _e$9[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$10:
	lea	ecx, DWORD PTR _e$8[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z$11:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-352]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?write_marker_segment@siz_params@@MAEHPAVkdu_output@@PAVkdu_params@@H@Z ENDP ; siz_params::write_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z
_TEXT	SEGMENT
_e$2 = -148						; size = 20
_e$3 = -128						; size = 20
_e$4 = -128						; size = 20
_uses_cap$ = -108					; size = 1
_extensions$ = -104					; size = 4
_profile$ = -100					; size = 4
_source_coc$2$ = -96					; size = 4
_source_coc$1$ = -96					; size = 4
_is_signed$ = -92					; size = 1
_precision$ = -88					; size = 4
_subs_x$ = -84						; size = 4
_subs_y$ = -80						; size = 4
_canvas_y$ = -76					; size = 4
_source_cod$1$ = -72					; size = 4
tv876 = -72						; size = 4
_decomp$ = -68						; size = 4
_tiles_x$ = -64						; size = 4
_tiles_y$ = -60						; size = 4
_num_output_components$ = -56				; size = 4
_this$1$ = -52						; size = 4
_origin_x$ = -48					; size = 4
_origin_y$ = -44					; size = 4
_canvas_x$ = -40					; size = 4
_num_components$ = -36					; size = 4
_tile_origin_x$ = -32					; size = 4
_tile_origin_y$ = -28					; size = 4
_gcd_exponent$1$ = -24					; size = 4
_n$1$ = -20						; size = 4
_canvas_y$1$ = -20					; size = 4
tv874 = -20						; size = 4
_gcd_exponent$2$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_source$ = 8						; size = 4
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_transpose$ = 20					; size = 1
tv875 = 24						; size = 4
_vflip$ = 24						; size = 1
tv873 = 28						; size = 4
_hflip$ = 28						; size = 1
?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z PROC ; siz_params::copy_with_xforms, COMDAT
; _this$ = ecx

; 3195 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi

; 3196 :   bool uses_cap;
; 3197 :   int profile, extensions;
; 3198 :   int canvas_x, canvas_y, origin_x, origin_y;
; 3199 :   int tiles_y, tiles_x, tile_origin_y, tile_origin_x;
; 3200 : 
; 3201 :   if (!(source->get(Sprofile,0,0,profile) &&

	mov	ebx, DWORD PTR _source$[ebp]
	lea	eax, DWORD PTR _profile$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN31@copy_with_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _uses_cap$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04JNHDNPF@Scap?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN31@copy_with_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _extensions$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@NJJFAENN@Sextensions?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN31@copy_with_
	push	1
	xor	eax, eax
	lea	ecx, DWORD PTR _canvas_y$[ebp]
	cmp	BYTE PTR _transpose$[ebp], al
	push	1
	push	1
	push	ecx
	setne	al
	mov	ecx, ebx
	push	eax
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	mov	DWORD PTR tv876[ebp], eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN31@copy_with_
	push	1
	xor	eax, eax
	lea	ecx, DWORD PTR _canvas_x$[ebp]
	cmp	BYTE PTR _transpose$[ebp], al
	push	1
	push	1
	push	ecx
	sete	al
	mov	ecx, ebx
	push	eax
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	mov	DWORD PTR tv874[ebp], eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN31@copy_with_
	mov	edi, DWORD PTR tv876[ebp]
	lea	eax, DWORD PTR _origin_y$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	edi
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN31@copy_with_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _origin_x$[ebp]
	mov	ecx, ebx
	push	eax
	push	DWORD PTR tv874[ebp]
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN31@copy_with_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _tiles_y$[ebp]
	mov	ecx, ebx
	push	eax
	push	edi
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN31@copy_with_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _tiles_x$[ebp]
	mov	ecx, ebx
	push	eax
	push	DWORD PTR tv874[ebp]
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN31@copy_with_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _tile_origin_y$[ebp]
	mov	ecx, ebx
	push	eax
	push	edi
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN31@copy_with_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _tile_origin_x$[ebp]
	mov	ecx, ebx
	push	eax
	push	DWORD PTR tv874[ebp]
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN30@copy_with_
$LN31@copy_with_:

; 3212 :     { KDU_ERROR_DEV(e,61); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0IK@CCHOHMJN@Unable?5to?5copy?5SIZ?5parameters?0?5u@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3212 :     { KDU_ERROR_DEV(e,61); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3216 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN30@copy_with_:

; 3217 : 
; 3218 :   if (vflip || hflip)

	cmp	BYTE PTR _vflip$[ebp], 0
	jne	SHORT $LN33@copy_with_
	cmp	BYTE PTR _hflip$[ebp], 0
	jne	SHORT $LN33@copy_with_

; 3219 :     profile = 3; // Requires the use of the Part 2 alternate code-block anchor

	mov	eax, DWORD PTR _profile$[ebp]
	jmp	SHORT $LN32@copy_with_
$LN33@copy_with_:
	mov	eax, 3
	mov	DWORD PTR _profile$[ebp], eax
$LN32@copy_with_:

; 3220 : 
; 3221 :   set(Sprofile,0,0,profile);

	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3222 :   set(Scap,0,0,uses_cap);

	push	DWORD PTR _uses_cap$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_04JNHDNPF@Scap?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set

; 3223 :   set(Sextensions,0,0,extensions);

	push	DWORD PTR _extensions$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_0M@NJJFAENN@Sextensions?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3224 : 
; 3225 :   int num_components=0;
; 3226 :   if (source->get(Scomponents,0,0,num_components))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _num_components$[ebp]
	mov	DWORD PTR _num_components$[ebp], 0
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@LFKICJFJ@Scomponents?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 3227 :     {
; 3228 :       if (num_components <= skip_components)

	mov	edi, DWORD PTR _skip_components$[ebp]
	test	al, al
	je	SHORT $LN34@copy_with_
	mov	eax, DWORD PTR _num_components$[ebp]
	cmp	eax, edi
	jg	SHORT $LN35@copy_with_

; 3229 :         { KDU_ERROR_DEV(e,62); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0EK@BLNJMGGP@Attempting?5to?5discard?5all?5of?5the@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3229 :         { KDU_ERROR_DEV(e,62); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3232 :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _num_components$[ebp]
$LN35@copy_with_:

; 3233 :       set(Scomponents,0,0,num_components-skip_components);

	sub	eax, edi
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@LFKICJFJ@Scomponents?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN34@copy_with_:

; 3234 :     }
; 3235 : 
; 3236 :   int num_output_components=0;
; 3237 :   if (source->get(Mcomponents,0,0,num_output_components))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _num_output_components$[ebp]
	mov	DWORD PTR _num_output_components$[ebp], 0
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@FAIBBHLL@Mcomponents?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN36@copy_with_

; 3238 :     set(Mcomponents,0,0,num_output_components);

	push	DWORD PTR _num_output_components$[ebp]
	mov	ecx, esi
	push	0
	push	0
	push	OFFSET ??_C@_0M@FAIBBHLL@Mcomponents?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN36@copy_with_:

; 3247 :   if (discard_levels > 0)

	mov	esi, DWORD PTR _discard_levels$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	xor	edx, edx
	mov	DWORD PTR _gcd_exponent$1$[ebp], 0
	mov	DWORD PTR _gcd_exponent$2$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3246 :   kdu_params *source_cod=NULL, *source_coc;

	mov	DWORD PTR _source_cod$1$[ebp], edx

; 3247 :   if (discard_levels > 0)

	test	esi, esi
	jle	$LN122@copy_with_

; 3248 :     {
; 3249 :       gcd_exponent.x = gcd_exponent.y = discard_levels;
; 3250 :       if ((extensions & Sextensions_DECOMP) &&

	test	BYTE PTR _extensions$[ebp], 32		; 00000020H
	mov	ecx, esi
	mov	edx, esi
	mov	DWORD PTR _gcd_exponent$1$[ebp], ecx
	mov	DWORD PTR _gcd_exponent$2$[ebp], edx
	je	$LN3@copy_with_
	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	mov	ecx, ebx
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	DWORD PTR _source_cod$1$[ebp], eax
	test	eax, eax
	je	$LN129@copy_with_

; 3251 :           ((source_cod = source->access_cluster(COD_params)) != NULL))
; 3252 :         {
; 3253 :           for (n=skip_components; n < num_components; n++)

	mov	eax, edi
	mov	DWORD PTR _n$1$[ebp], edi
	cmp	edi, DWORD PTR _num_components$[ebp]
	jge	$LN129@copy_with_
	npad	2
$LL4@copy_with_:

; 3256 :               if (((source_coc=source_cod->access_relation(-1,n,0)) != NULL) &&

	mov	ecx, DWORD PTR _source_cod$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	xor	ebx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3256 :               if (((source_coc=source_cod->access_relation(-1,n,0)) != NULL) &&

	push	ebx
	push	ebx
	push	eax
	push	-1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	xor	edi, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3256 :               if (((source_coc=source_cod->access_relation(-1,n,0)) != NULL) &&

	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	DWORD PTR _source_coc$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN131@copy_with_
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _decomp$[ebp]
	push	ecx
	push	ebx
	push	ebx
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN131@copy_with_

; 3257 :                   source_coc->get(Cdecomp,0,0,decomp))
; 3258 :                 { // Use decomposition information to compute downsampling
; 3259 :                   for (d=0; d < discard_levels; d++)

	xor	esi, esi
	cmp	DWORD PTR _discard_levels$[ebp], ebx
	jle	SHORT $LN6@copy_with_
	npad	5
$LL7@copy_with_:

; 3260 :                     {
; 3261 :                       source_coc->get(Cdecomp,d,0,decomp);

	mov	ecx, DWORD PTR _source_coc$1$[ebp]
	lea	eax, DWORD PTR _decomp$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 3262 :                       exponent.x += (decomp & 1);

	mov	ecx, DWORD PTR _decomp$[ebp]
	inc	esi
	mov	eax, ecx

; 3263 :                       exponent.y += ((decomp & 2) >> 1);

	sar	ecx, 1
	and	eax, 1
	and	ecx, 1
	add	ebx, eax
	add	edi, ecx
	cmp	esi, DWORD PTR _discard_levels$[ebp]
	jl	SHORT $LL7@copy_with_
$LN6@copy_with_:

; 3264 :                     }
; 3265 :                   if (exponent.x < gcd_exponent.x)

	mov	edx, DWORD PTR _gcd_exponent$2$[ebp]
	cmp	ebx, edx

; 3266 :                     gcd_exponent.x = exponent.x;
; 3267 :                   if (exponent.y < gcd_exponent.y)

	mov	ecx, DWORD PTR _gcd_exponent$1$[ebp]
	cmovl	edx, ebx
	cmp	edi, ecx
	mov	DWORD PTR _gcd_exponent$2$[ebp], edx
	cmovl	ecx, edi
	mov	DWORD PTR _gcd_exponent$1$[ebp], ecx
	jmp	SHORT $LN2@copy_with_
$LN131@copy_with_:
	mov	edx, DWORD PTR _gcd_exponent$2$[ebp]
	mov	ecx, DWORD PTR _gcd_exponent$1$[ebp]
$LN2@copy_with_:

; 3251 :           ((source_cod = source->access_cluster(COD_params)) != NULL))
; 3252 :         {
; 3253 :           for (n=skip_components; n < num_components; n++)

	mov	eax, DWORD PTR _n$1$[ebp]
	inc	eax
	mov	DWORD PTR _n$1$[ebp], eax
	cmp	eax, DWORD PTR _num_components$[ebp]
	jl	$LL4@copy_with_
	mov	esi, DWORD PTR _discard_levels$[ebp]
	mov	ebx, DWORD PTR _source$[ebp]
	jmp	SHORT $LN3@copy_with_
$LN129@copy_with_:
	mov	ecx, esi
	mov	edx, ecx
$LN3@copy_with_:

; 3268 :                     gcd_exponent.y = exponent.y;
; 3269 :                 }
; 3270 :             }
; 3271 :         }
; 3272 :       if (transpose)

	cmp	BYTE PTR _transpose$[ebp], 0
	je	SHORT $LN127@copy_with_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	edi, edx
	mov	DWORD PTR _gcd_exponent$2$[ebp], ecx
	mov	DWORD PTR _gcd_exponent$1$[ebp], edi
	jmp	SHORT $LN42@copy_with_
$LN127@copy_with_:
	mov	edi, DWORD PTR _gcd_exponent$1$[ebp]
$LN42@copy_with_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3276 :       dependencies.y = canvas_y | origin_y | tiles_y | tile_origin_y;

	mov	ecx, DWORD PTR _tile_origin_y$[ebp]
	or	ecx, DWORD PTR _tiles_y$[ebp]
	mov	eax, DWORD PTR _tile_origin_x$[ebp]
	or	eax, DWORD PTR _tiles_x$[ebp]
	or	ecx, DWORD PTR _origin_y$[ebp]
	mov	edx, DWORD PTR _canvas_y$[ebp]
	or	ecx, edx
	or	eax, DWORD PTR _origin_x$[ebp]
	or	eax, DWORD PTR _canvas_x$[ebp]
	mov	DWORD PTR _canvas_y$1$[ebp], edx

; 3277 :       for (n=0; n < gcd_exponent.x; n++, dependencies.x>>=1)

	xor	edx, edx
	cmp	DWORD PTR _gcd_exponent$2$[ebp], edx
	jle	SHORT $LN132@copy_with_
$LL10@copy_with_:

; 3278 :         if (dependencies.x & 1)

	test	al, 1
	jne	$LN89@copy_with_

; 3277 :       for (n=0; n < gcd_exponent.x; n++, dependencies.x>>=1)

	inc	edx
	sar	eax, 1
	cmp	edx, DWORD PTR _gcd_exponent$2$[ebp]
	jl	SHORT $LL10@copy_with_
$LN132@copy_with_:
	mov	edx, DWORD PTR _gcd_exponent$2$[ebp]
$LN9@copy_with_:

; 3280 :       for (n=0; n < gcd_exponent.y; n++, dependencies.y>>=1)

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN133@copy_with_
	npad	5
$LL13@copy_with_:

; 3281 :         if (dependencies.y & 1)

	test	cl, 1
	jne	$LN90@copy_with_

; 3280 :       for (n=0; n < gcd_exponent.y; n++, dependencies.y>>=1)

	inc	eax
	sar	ecx, 1
	cmp	eax, edi
	jl	SHORT $LL13@copy_with_
$LN133@copy_with_:
	mov	eax, DWORD PTR _canvas_y$1$[ebp]
$LN12@copy_with_:

; 3283 :     }
; 3284 : 
; 3285 :   canvas_x >>= gcd_exponent.x;       canvas_y >>= gcd_exponent.y;

	mov	ecx, edx
	sar	DWORD PTR _canvas_x$[ebp], cl
	mov	ecx, edi
	sar	eax, cl

; 3286 :   origin_x >>= gcd_exponent.x;       origin_y >>= gcd_exponent.y;

	mov	ecx, edx
	sar	DWORD PTR _origin_x$[ebp], cl
	mov	ecx, edi
	sar	DWORD PTR _origin_y$[ebp], cl

; 3287 :   tiles_x >>= gcd_exponent.x;        tiles_y >>= gcd_exponent.y;

	mov	ecx, edx
	sar	DWORD PTR _tiles_x$[ebp], cl
	mov	ecx, edi
	sar	DWORD PTR _tiles_y$[ebp], cl

; 3288 :   tile_origin_x >>= gcd_exponent.x;  tile_origin_y >>= gcd_exponent.y;

	mov	ecx, edx
	sar	DWORD PTR _tile_origin_x$[ebp], cl
	mov	ecx, edi
	mov	edx, DWORD PTR _tile_origin_y$[ebp]
	sar	edx, cl

; 3289 : 
; 3290 :   int tmp;
; 3291 :   if (hflip)

	mov	ecx, 1
	cmp	BYTE PTR _hflip$[ebp], 0
	mov	DWORD PTR _canvas_y$1$[ebp], eax
	mov	DWORD PTR _canvas_y$[ebp], eax
	mov	DWORD PTR _tile_origin_y$[ebp], edx
	je	SHORT $LN15@copy_with_

; 3292 :     {
; 3293 :       tmp = 1-canvas_x;  canvas_x = 1-origin_x;  origin_x = tmp;

	mov	eax, ecx
	mov	edx, ecx
	sub	eax, DWORD PTR _origin_x$[ebp]
	sub	edx, DWORD PTR _canvas_x$[ebp]
	mov	DWORD PTR _canvas_x$[ebp], eax

; 3294 :       tile_origin_x = 1-tile_origin_x;

	mov	eax, ecx
	sub	eax, DWORD PTR _tile_origin_x$[ebp]
	mov	DWORD PTR _origin_x$[ebp], edx
	mov	DWORD PTR _tile_origin_x$[ebp], eax

; 3295 :       while (tile_origin_x > origin_x)

	cmp	eax, edx
	jle	SHORT $LN135@copy_with_
	mov	edi, DWORD PTR _tiles_x$[ebp]
	npad	1
$LL14@copy_with_:

; 3296 :         tile_origin_x -= tiles_x;

	sub	eax, edi
	cmp	eax, edx
	jg	SHORT $LL14@copy_with_
	mov	DWORD PTR _tile_origin_x$[ebp], eax
$LN135@copy_with_:
	mov	edx, DWORD PTR _tile_origin_y$[ebp]
$LN15@copy_with_:

; 3297 :     }
; 3298 :   if (vflip)

	cmp	BYTE PTR _vflip$[ebp], 0
	je	SHORT $LN134@copy_with_

; 3299 :     {
; 3300 :       tmp = 1-canvas_y;  canvas_y = 1-origin_y;  origin_y = tmp;

	mov	eax, ecx
	mov	edi, ecx
	sub	eax, DWORD PTR _canvas_y$1$[ebp]

; 3301 :       tile_origin_y = 1-tile_origin_y;

	sub	ecx, edx
	sub	edi, DWORD PTR _origin_y$[ebp]
	mov	DWORD PTR _canvas_y$[ebp], edi
	mov	DWORD PTR _origin_y$[ebp], eax
	mov	DWORD PTR _tile_origin_y$[ebp], ecx

; 3302 :       while (tile_origin_y > origin_y)

	cmp	ecx, eax
	jle	SHORT $LN17@copy_with_
	mov	edx, DWORD PTR _tiles_y$[ebp]
	npad	2
$LL16@copy_with_:

; 3303 :         tile_origin_y -= tiles_y;

	sub	ecx, edx
	cmp	ecx, eax
	jg	SHORT $LL16@copy_with_
	mov	DWORD PTR _tile_origin_y$[ebp], ecx
	jmp	SHORT $LN17@copy_with_
$LN89@copy_with_:

; 3279 :           { gcd_exponent.x = n; break; }

	mov	DWORD PTR _gcd_exponent$2$[ebp], edx
	jmp	$LN9@copy_with_
$LN90@copy_with_:

; 3282 :           { gcd_exponent.y = n; break; }

	mov	edi, eax
	mov	DWORD PTR _gcd_exponent$1$[ebp], edi
	jmp	$LN133@copy_with_
$LN122@copy_with_:
	mov	eax, DWORD PTR _canvas_y$[ebp]
	xor	edi, edi
	jmp	$LN12@copy_with_
$LN134@copy_with_:
	mov	edi, DWORD PTR _canvas_y$1$[ebp]
$LN17@copy_with_:

; 3304 :     }
; 3305 :   set(Ssize,0,0,canvas_y);             set(Ssize,0,1,canvas_x);

	push	edi
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _canvas_x$[ebp]
	mov	ecx, edi
	push	1
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3306 :   set(Sorigin,0,0,origin_y);           set(Sorigin,0,1,origin_x);

	push	DWORD PTR _origin_y$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _origin_x$[ebp]
	mov	ecx, edi
	push	1
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3307 :   set(Stiles,0,0,tiles_y);             set(Stiles,0,1,tiles_x);

	push	DWORD PTR _tiles_y$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _tiles_x$[ebp]
	mov	ecx, edi
	push	1
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3308 :   set(Stile_origin,0,0,tile_origin_y); set(Stile_origin,0,1,tile_origin_x);

	push	DWORD PTR _tile_origin_y$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _tile_origin_x$[ebp]
	mov	ecx, edi
	push	1
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3309 : 
; 3310 :   bool is_signed;
; 3311 :   int precision, subs_x, subs_y;
; 3312 :   for (n=skip_components; n < num_components; n++)

	mov	edi, DWORD PTR _skip_components$[ebp]
	cmp	edi, DWORD PTR _num_components$[ebp]
	jge	$LN19@copy_with_

; 3304 :     }
; 3305 :   set(Ssize,0,0,canvas_y);             set(Ssize,0,1,canvas_x);

	xor	eax, eax
	mov	DWORD PTR tv873[ebp], 0

; 3320 :       if (source->get(Ssampling,n,(transpose)?1:0,subs_y) &&

	cmp	BYTE PTR _transpose$[ebp], al
	setne	al
	mov	DWORD PTR tv875[ebp], eax
$LL20@copy_with_:

; 3313 :     { /* Note that we deliberately do not copy the image dimensions since these
; 3314 :          should be automatically recomputed based on any discarded resolution
; 3315 :          levels. */
; 3316 :       if (source->get(Sprecision,n,0,precision))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _precision$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0L@BADPNFGK@Sprecision?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN47@copy_with_

; 3317 :         set(Sprecision,n-skip_components,0,precision);

	push	DWORD PTR _precision$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	0
	push	DWORD PTR tv873[ebp]
	push	OFFSET ??_C@_0L@BADPNFGK@Sprecision?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN47@copy_with_:

; 3318 :       if (source->get(Ssigned,n,0,is_signed))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _is_signed$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_07MGJMMJC@Ssigned?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN48@copy_with_

; 3319 :         set(Ssigned,n-skip_components,0,is_signed);

	push	DWORD PTR _is_signed$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	0
	push	DWORD PTR tv873[ebp]
	push	OFFSET ??_C@_07MGJMMJC@Ssigned?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN48@copy_with_:

; 3320 :       if (source->get(Ssampling,n,(transpose)?1:0,subs_y) &&

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _subs_y$[ebp]
	mov	ecx, ebx
	push	eax
	push	DWORD PTR tv875[ebp]
	push	edi
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN18@copy_with_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _subs_x$[ebp]
	mov	ecx, ebx
	push	eax
	xor	eax, eax
	cmp	BYTE PTR _transpose$[ebp], al
	sete	al
	push	eax
	push	edi
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN18@copy_with_

; 3325 :               ((source_coc=source_cod->access_relation(-1,n,0)) != NULL) &&

	mov	eax, DWORD PTR _source_cod$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	xor	edi, edi
	xor	ebx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3325 :               ((source_coc=source_cod->access_relation(-1,n,0)) != NULL) &&

	test	eax, eax
	je	$LN50@copy_with_
	push	ebx
	push	ebx
	push	DWORD PTR _skip_components$[ebp]
	mov	ecx, eax
	push	-1
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	DWORD PTR _source_coc$2$[ebp], eax
	test	eax, eax
	je	$LN50@copy_with_
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _decomp$[ebp]
	push	ecx
	push	ebx
	push	ebx
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN50@copy_with_

; 3326 :               source_coc->get(Cdecomp,0,0,decomp))
; 3327 :             { // Use decomposition information to compute downsampling
; 3328 :               for (d=0; d < discard_levels; d++)

	xor	esi, esi
	cmp	DWORD PTR _discard_levels$[ebp], ebx
	jle	SHORT $LN125@copy_with_
	npad	2
$LL23@copy_with_:

; 3329 :                 {
; 3330 :                   source_coc->get(Cdecomp,d,0,decomp);

	mov	ecx, DWORD PTR _source_coc$2$[ebp]
	lea	eax, DWORD PTR _decomp$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 3331 :                   exponent.x += (decomp & 1);

	mov	ecx, DWORD PTR _decomp$[ebp]
	inc	esi
	mov	eax, ecx

; 3332 :                   exponent.y += ((decomp & 2) >> 1);

	sar	ecx, 1
	and	eax, 1
	and	ecx, 1
	add	ebx, eax
	add	edi, ecx
	cmp	esi, DWORD PTR _discard_levels$[ebp]
	jl	SHORT $LL23@copy_with_
$LN125@copy_with_:
	mov	esi, DWORD PTR _discard_levels$[ebp]
$LN51@copy_with_:

; 3338 :             }
; 3339 :           if (transpose)

	cmp	BYTE PTR _transpose$[ebp], 0
	je	SHORT $LN52@copy_with_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, edi
	mov	edi, ebx
	mov	ebx, eax
$LN52@copy_with_:

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	sub	ebx, DWORD PTR _gcd_exponent$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3343 :           subs_x <<= exponent.x;

	mov	eax, DWORD PTR _subs_x$[ebp]
	mov	ecx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	sub	edi, DWORD PTR _gcd_exponent$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3344 :           subs_y <<= exponent.y;

	mov	edx, DWORD PTR _subs_y$[ebp]
	shl	eax, cl
	mov	ecx, edi
	shl	edx, cl
	mov	DWORD PTR _subs_x$[ebp], eax
	mov	DWORD PTR _subs_y$[ebp], edx

; 3345 :           if ((subs_x > 255) || (subs_y > 255))

	cmp	eax, 255				; 000000ffH
	jg	SHORT $LN54@copy_with_
	cmp	edx, 255				; 000000ffH
	jle	SHORT $LN53@copy_with_
$LN54@copy_with_:

; 3346 :             { KDU_ERROR(e,63); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0OO@EELGDABM@Cannot?5apply?5requested?5resolutio@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3346 :             { KDU_ERROR(e,63); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3352 :             }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	edx, DWORD PTR _subs_y$[ebp]
$LN53@copy_with_:

; 3353 :           set(Ssampling,n-skip_components,0,subs_y);

	mov	ebx, DWORD PTR tv873[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	edx
	push	0
	push	ebx
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3354 :           set(Ssampling,n-skip_components,1,subs_x);

	push	DWORD PTR _subs_x$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	1
	push	ebx
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	ebx, DWORD PTR _source$[ebp]
	mov	edi, DWORD PTR _skip_components$[ebp]
$LN18@copy_with_:

; 3309 : 
; 3310 :   bool is_signed;
; 3311 :   int precision, subs_x, subs_y;
; 3312 :   for (n=skip_components; n < num_components; n++)

	inc	DWORD PTR tv873[ebp]
	inc	edi
	mov	DWORD PTR _skip_components$[ebp], edi
	cmp	edi, DWORD PTR _num_components$[ebp]
	jl	$LL20@copy_with_
$LN19@copy_with_:

; 3355 :         }
; 3356 :     }
; 3357 : 
; 3358 :   for (n=0; (n < num_output_components) &&

	mov	eax, DWORD PTR _num_output_components$[ebp]
	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN25@copy_with_
	npad	1
$LL26@copy_with_:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _precision$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_0L@OMLPDKKH@Mprecision?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN123@copy_with_

; 3359 :              source->get(Mprecision,n,0,precision,false,false); n++)
; 3360 :     set(Mprecision,n,0,precision);

	push	DWORD PTR _precision$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	0
	push	esi
	push	OFFSET ??_C@_0L@OMLPDKKH@Mprecision?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	eax, DWORD PTR _num_output_components$[ebp]
	inc	esi
	cmp	esi, eax
	jl	SHORT $LL26@copy_with_

; 3355 :         }
; 3356 :     }
; 3357 : 
; 3358 :   for (n=0; (n < num_output_components) &&

	jmp	SHORT $LN25@copy_with_
$LN50@copy_with_:

; 3333 :                 }
; 3334 :             }
; 3335 :           else
; 3336 :             { // Just use `discard_levels' directly -- assume default DFS
; 3337 :               exponent.x = exponent.y = discard_levels;

	mov	edi, esi
	mov	ebx, esi
	jmp	$LN51@copy_with_
$LN123@copy_with_:

; 3355 :         }
; 3356 :     }
; 3357 : 
; 3358 :   for (n=0; (n < num_output_components) &&

	mov	eax, DWORD PTR _num_output_components$[ebp]
$LN25@copy_with_:

; 3361 :   for (n=0; (n < num_output_components) &&

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN28@copy_with_
	npad	4
$LL29@copy_with_:
	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _is_signed$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_07GFFIOPIL@Msigned?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN28@copy_with_

; 3362 :              source->get(Msigned,n,0,is_signed,false,false); n++)
; 3363 :     set(Msigned,n,0,is_signed);

	push	DWORD PTR _is_signed$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	0
	push	esi
	push	OFFSET ??_C@_07GFFIOPIL@Msigned?$AA@
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
	inc	esi
	cmp	esi, DWORD PTR _num_output_components$[ebp]
	jl	SHORT $LL29@copy_with_
$LN28@copy_with_:

; 3364 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z$1:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?copy_with_xforms@siz_params@@MAEXPAVkdu_params@@HH_N11@Z ENDP ; siz_params::copy_with_xforms
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?finalize@siz_params@@MAEX_N@Z
_TEXT	SEGMENT
_e$2 = -224						; size = 20
_num_output_components$ = -204				; size = 4
_pval$ = -200						; size = 4
tv2698 = -196						; size = 4
tv2687 = -196						; size = 4
_num_levels$ = -192					; size = 4
_tile_y$ = -188						; size = 4
_extensions$ = -184					; size = 4
_tile_x$ = -180						; size = 4
_tile_oy$ = -176					; size = 4
_tile_ox$ = -172					; size = 4
_use_caps$ = -165					; size = 1
_cod_root$1$ = -164					; size = 4
tv2711 = -164						; size = 4
tv2699 = -164						; size = 4
_sval$ = -160						; size = 4
_num_c$1$ = -156					; size = 4
tv2704 = -156						; size = 4
tv2700 = -156						; size = 4
tv2693 = -156						; size = 4
tv2692 = -156						; size = 4
_size_y$ = -152						; size = 4
_origin_y$ = -148					; size = 4
_origin_x$ = -144					; size = 4
_profile$ = -140					; size = 4
_size_x$ = -136						; size = 4
_sub_y$1$ = -132					; size = 4
_dim_y$1$ = -128					; size = 4
_dim_x$1$ = -124					; size = 4
_t$1$ = -120						; size = 4
_max_size$1$ = -120					; size = 4
tv2701 = -120						; size = 4
_this$GSCopy$1$ = -116					; size = 4
$T3 = -112						; size = 4
$T4 = -112						; size = 4
_c$1$ = -112						; size = 4
_n$7$ = -112						; size = 4
tv2714 = -112						; size = 4
tv2712 = -112						; size = 4
tv2705 = -112						; size = 4
tv2697 = -112						; size = 4
_num_t$1$ = -108					; size = 4
_n$4$ = -108						; size = 4
tv2703 = -108						; size = 4
tv2695 = -108						; size = 4
tv2691 = -108						; size = 4
tv2684 = -108						; size = 4
_tparts$5 = -108					; size = 4
_w$6 = -104						; size = 20
_e$7 = -104						; size = 20
_e$8 = -104						; size = 20
_e$9 = -104						; size = 20
_e$10 = -104						; size = 20
_e$11 = -104						; size = 20
_w$12 = -104						; size = 20
_e$13 = -104						; size = 20
_e$14 = -104						; size = 20
_e$15 = -104						; size = 20
_e$16 = -104						; size = 20
_e$17 = -104						; size = 20
_e$18 = -104						; size = 20
_e$19 = -104						; size = 20
_e$20 = -104						; size = 20
_e$21 = -104						; size = 20
_e$22 = -104						; size = 20
_e$23 = -104						; size = 20
_e$24 = -104						; size = 20
_e$25 = -104						; size = 20
_e$26 = -104						; size = 20
_have_sampling$1$ = -82					; size = 1
_existing_error$1$ = -81				; size = 1
_have_dims$1$ = -81					; size = 1
_components$ = -80					; size = 4
_val$ = -76						; size = 4
_new_profile$1$ = -72					; size = 4
_sub_x$1$ = -72						; size = 4
_have_size$1$ = -65					; size = 1
_b_val$27 = -65						; size = 1
_params_4k$ = -64					; size = 48
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_after_reading$ = 8					; size = 1
?finalize@siz_params@@MAEX_N@Z PROC			; siz_params::finalize, COMDAT
; _this$ = ecx

; 3731 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?finalize@siz_params@@MAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 212				; 000000d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], esi

; 3732 :   int components, val, n;
; 3733 :   bool have_sampling, have_dims, have_components, have_size;
; 3734 :   int size_x, size_y, origin_x, origin_y;
; 3735 : 
; 3736 :   // First collect some basic facts.
; 3737 :   have_components = get(Scomponents,0,0,components);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _components$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@LFKICJFJ@Scomponents?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 3738 :   have_sampling = get(Ssampling,0,0,val);

	push	1
	push	1
	push	1
	mov	bl, al
	mov	ecx, esi
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 3739 :   have_dims = get(Sdims,0,0,val);

	push	1
	push	1
	push	1
	mov	BYTE PTR _have_sampling$1$[ebp], al
	mov	ecx, esi
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_05KKKGDPEH@Sdims?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 3740 :   have_size = get(Ssize,0,0,size_y) && get(Ssize,0,1,size_x);

	push	1
	push	1
	push	1
	mov	bh, al
	mov	ecx, esi
	lea	eax, DWORD PTR _size_y$[ebp]
	mov	BYTE PTR _have_dims$1$[ebp], bh
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN154@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _size_x$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	BYTE PTR _have_size$1$[ebp], 1
	test	al, al
	jne	SHORT $LN155@finalize
$LN154@finalize:
	mov	BYTE PTR _have_size$1$[ebp], 0
$LN155@finalize:

; 3741 :   if (!(get(Sorigin,0,0,origin_y) && get(Sorigin,0,1,origin_x)))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _origin_y$[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN56@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _origin_x$[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN55@finalize
$LN56@finalize:

; 3742 :     { set(Sorigin,0,0,origin_y=0); set(Sorigin,0,1,origin_x=0); }

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	mov	ecx, esi
	mov	DWORD PTR _origin_y$[ebp], 0
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	0
	push	1
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	mov	ecx, esi
	mov	DWORD PTR _origin_x$[ebp], 0
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN55@finalize:

; 3743 :   if (have_sampling && !have_components)

	cmp	BYTE PTR _have_sampling$1$[ebp], 0
	je	SHORT $LN57@finalize
	test	bl, bl
	jne	SHORT $LN57@finalize

; 3744 :     {
; 3745 :       for (components=1;
; 3746 :            get(Ssampling,components,0,val,false,false);

	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _components$[ebp], 1
	push	eax
	push	0
	push	1
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN3@finalize
	npad	4
$LL4@finalize:

; 3747 :            components++);

	mov	eax, DWORD PTR _components$[ebp]
	lea	ecx, DWORD PTR _val$[ebp]
	push	1
	push	0
	push	0
	push	ecx
	inc	eax
	mov	ecx, esi
	push	0
	push	eax
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	mov	DWORD PTR _components$[ebp], eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL4@finalize
$LN3@finalize:

; 3748 :       have_components = true;

	mov	bl, 1
$LN57@finalize:

; 3749 :     }
; 3750 :   if (have_dims && !have_components)

	test	bh, bh
	je	SHORT $LN58@finalize
	test	bl, bl
	jne	$LN59@finalize

; 3751 :     {
; 3752 :       for (components=1;
; 3753 :            get(Sdims,components,0,val,false,false);

	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _components$[ebp], 1
	push	eax
	push	0
	push	1
	push	OFFSET ??_C@_05KKKGDPEH@Sdims?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN59@finalize
$LL7@finalize:

; 3754 :            components++);

	mov	eax, DWORD PTR _components$[ebp]
	lea	ecx, DWORD PTR _val$[ebp]
	push	1
	push	0
	push	0
	push	ecx
	inc	eax
	mov	ecx, esi
	push	0
	push	eax
	push	OFFSET ??_C@_05KKKGDPEH@Sdims?$AA@
	mov	DWORD PTR _components$[ebp], eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL7@finalize

; 3755 :       have_components = true;
; 3756 :     }
; 3757 :   if (!have_components)

	jmp	SHORT $LN59@finalize
$LN58@finalize:
	test	bl, bl
	jne	SHORT $LN59@finalize

; 3758 :     { KDU_ERROR(e,76); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$26[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$26[ebp]
	lea	ecx, DWORD PTR _e$26[ebp]
	push	OFFSET ??_C@_0JL@PLHBNPBC@Problem?5trying?5to?5finalize?5SIZ?5i@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3758 :     { KDU_ERROR(e,76); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3762 :       this->textualize_attributes(e); e << "\n";

	push	1
	lea	eax, DWORD PTR _e$26[ebp]
	mov	ecx, esi
	push	eax
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ; kdu_params::textualize_attributes
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$26[ebp]
	lea	ecx, DWORD PTR _e$26[ebp]
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3763 :     }

	lea	ecx, DWORD PTR _e$26[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN59@finalize:

; 3764 : 
; 3765 :   int *dim_x = new int[components]; int *dim_y = new int[components];

	mov	eax, DWORD PTR _components$[ebp]
	xor	ecx, ecx
	mov	esi, 4
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR _dim_x$1$[ebp], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR _components$[ebp]
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR _dim_y$1$[ebp], eax

; 3766 :   int *sub_x = new int[components]; int *sub_y = new int[components];

	xor	ecx, ecx
	mov	eax, DWORD PTR _components$[ebp]
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR _sub_x$1$[ebp], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR _components$[ebp]
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 3767 :   if (have_dims)
; 3768 :     for (n=0; n < components; n++)

	mov	esi, DWORD PTR _components$[ebp]
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR _sub_y$1$[ebp], edi
	test	bh, bh
	je	$LN9@finalize
	xor	edi, edi
	test	esi, esi
	jle	$LN568@finalize
	mov	eax, DWORD PTR _dim_y$1$[ebp]
	mov	ebx, DWORD PTR _dim_x$1$[ebp]
	sub	eax, ebx
	mov	DWORD PTR tv2714[ebp], eax
$LL10@finalize:

; 3769 :       if (!(get(Sdims,n,0,dim_y[n]) && get(Sdims,n,1,dim_x[n])))

	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	add	eax, ebx
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_05KKKGDPEH@Sdims?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN62@finalize
	push	1
	push	1
	push	1
	push	ebx
	push	1
	push	edi
	push	OFFSET ??_C@_05KKKGDPEH@Sdims?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN8@finalize
$LN62@finalize:

; 3770 :         { KDU_ERROR(e,77); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$25[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$25[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	OFFSET ??_C@_0FP@HBBHOMDC@Problem?5trying?5to?5finalize?5SIZ?5i@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3770 :         { KDU_ERROR(e,77); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3773 :           delete[] dim_x;  delete[] dim_y;  delete[] sub_x;  delete[] sub_y;

	push	DWORD PTR _dim_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _dim_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 3774 :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _e$25[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN8@finalize:

; 3767 :   if (have_dims)
; 3768 :     for (n=0; n < components; n++)

	mov	esi, DWORD PTR _components$[ebp]
	inc	edi
	mov	eax, DWORD PTR tv2714[ebp]
	add	ebx, 4
	cmp	edi, esi
	jl	$LL10@finalize
	mov	bh, BYTE PTR _have_dims$1$[ebp]
$LN568@finalize:
	mov	edi, DWORD PTR _sub_y$1$[ebp]
$LN9@finalize:

; 3775 :   if (have_sampling)

	mov	bl, BYTE PTR _have_sampling$1$[ebp]
	test	bl, bl
	je	$LN463@finalize

; 3776 :     for (n=0; n < components; n++)

	xor	ebx, ebx
	test	esi, esi
	jle	$LN69@finalize
	mov	esi, DWORD PTR _sub_x$1$[ebp]
	sub	esi, DWORD PTR _sub_y$1$[ebp]
	mov	DWORD PTR tv2712[ebp], esi
	jmp	SHORT $LN13@finalize
$LL560@finalize:
	mov	esi, DWORD PTR tv2712[ebp]
$LN13@finalize:

; 3777 :       if (!(get(Ssampling,n,0,sub_y[n]) && get(Ssampling,n,1,sub_x[n])))

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	1
	push	1
	push	1
	push	edi
	push	0
	push	ebx
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN66@finalize
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	add	esi, edi
	push	1
	push	1
	push	1
	push	esi
	push	1
	push	ebx
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN66@finalize

; 3783 :       else if ((sub_x[n] < 1) || (sub_y[n] < 1))

	cmp	DWORD PTR [esi], 1
	jl	SHORT $LN68@finalize
	cmp	DWORD PTR [edi], 1
	jge	SHORT $LN11@finalize
$LN68@finalize:

; 3784 :         { KDU_ERROR(e,79); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$23[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0EA@FCCPDFNF@Image?5component?5sub?9sampling?5fac@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3788 :         }

	jmp	SHORT $LN571@finalize
$LN66@finalize:

; 3778 :         { KDU_ERROR(e,78); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$24[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0GI@PICGKKPJ@Problem?5trying?5to?5finalize?5SIZ?5i@
$LN571@finalize:
	mov	eax, DWORD PTR _e$24[ebp]
	lea	ecx, DWORD PTR _e$24[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3781 :           delete[] dim_x;  delete[] dim_y;  delete[] sub_x;  delete[] sub_y;

	push	DWORD PTR _dim_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _dim_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 3782 :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _e$24[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN11@finalize:

; 3776 :     for (n=0; n < components; n++)

	mov	esi, DWORD PTR _components$[ebp]
	inc	ebx
	add	edi, 4
	cmp	ebx, esi
	jl	$LL560@finalize
$LN69@finalize:

; 3799 :   if (!have_dims)

	cmp	BYTE PTR _have_dims$1$[ebp], 0
	jne	$LN567@finalize
	mov	edi, DWORD PTR _sub_y$1$[ebp]
	mov	ebx, DWORD PTR _dim_y$1$[ebp]
	jmp	SHORT $LN476@finalize
$LN463@finalize:

; 3789 : 
; 3790 :   // Now for the information synthesis problem.
; 3791 : 
; 3792 :   if ((!have_sampling) && (!have_dims))

	test	bh, bh
	jne	$LN15@finalize

; 3793 :     { KDU_ERROR(e,80); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$22[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$22[ebp]
	lea	ecx, DWORD PTR _e$22[ebp]
	push	OFFSET ??_C@_0II@DHNDEJOJ@Problem?5trying?5to?5finalize?5SIZ?5i@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3793 :     { KDU_ERROR(e,80); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3797 :       delete[] dim_x;  delete[] dim_y;  delete[] sub_x;  delete[] sub_y;

	push	DWORD PTR _dim_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	ebx, DWORD PTR _dim_y$1$[ebp]
	push	ebx
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 3798 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _e$22[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	esi, DWORD PTR _components$[ebp]
$LN476@finalize:

; 3800 :     { // Have sub-sampling factors and need to synthesize dimensions.
; 3801 :       if (!have_size)

	cmp	BYTE PTR _have_size$1$[ebp], 0
	jne	SHORT $LN71@finalize

; 3802 :         { KDU_ERROR(e,81); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$21[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$21[ebp]
	lea	ecx, DWORD PTR _e$21[ebp]
	push	OFFSET ??_C@_0JH@NJJGGCNE@Problem?5trying?5to?5finalize?5SIZ?5i@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3802 :         { KDU_ERROR(e,81); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3806 :           this->textualize_attributes(e); e << "\n";

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _e$21[ebp]
	push	1
	push	eax
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ; kdu_params::textualize_attributes
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$21[ebp]
	lea	ecx, DWORD PTR _e$21[ebp]
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3807 :           delete[] dim_x;  delete[] dim_y;  delete[] sub_x;  delete[] sub_y;

	push	DWORD PTR _dim_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	ebx
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 3808 :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _e$21[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	esi, DWORD PTR _components$[ebp]
$LN71@finalize:

; 3809 :       for (n=0; n < components; n++)

	xor	ebx, ebx
	test	esi, esi
	jle	$LN567@finalize
	mov	edx, DWORD PTR _sub_y$1$[ebp]
	mov	ecx, DWORD PTR _dim_y$1$[ebp]
	mov	eax, DWORD PTR _sub_x$1$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv2705[ebp], ecx
	sub	eax, edx
	mov	ecx, DWORD PTR _dim_x$1$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv2711[ebp], eax
	mov	DWORD PTR tv2703[ebp], ecx
	npad	3
$LL16@finalize:

; 3811 :           dim_x[n] = ceil_ratio(size_x,sub_x[n])-ceil_ratio(origin_x,sub_x[n]);

	mov	esi, DWORD PTR [edi+eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _size_x$[ebp]
	test	eax, eax
	jg	SHORT $LN195@finalize

; 180  :     return -((-num)/den);

	cdq
	idiv	esi
	mov	ecx, eax
	jmp	SHORT $LN196@finalize
$LN195@finalize:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	esi
	lea	ecx, DWORD PTR [eax+1]
$LN196@finalize:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _origin_x$[ebp]
	test	eax, eax
	jg	SHORT $LN199@finalize

; 180  :     return -((-num)/den);

	cdq
	idiv	esi
	jmp	SHORT $LN200@finalize
$LN199@finalize:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	esi
	inc	eax
$LN200@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3811 :           dim_x[n] = ceil_ratio(size_x,sub_x[n])-ceil_ratio(origin_x,sub_x[n]);

	sub	ecx, eax
	mov	eax, DWORD PTR tv2703[ebp]
	mov	DWORD PTR [eax+edi], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _size_y$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3812 :           dim_y[n] = ceil_ratio(size_y,sub_y[n])-ceil_ratio(origin_y,sub_y[n]);

	mov	esi, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN203@finalize

; 180  :     return -((-num)/den);

	cdq
	idiv	esi
	mov	ecx, eax
	jmp	SHORT $LN204@finalize
$LN203@finalize:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	esi
	lea	ecx, DWORD PTR [eax+1]
$LN204@finalize:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _origin_y$[ebp]
	test	eax, eax
	jg	SHORT $LN207@finalize

; 180  :     return -((-num)/den);

	cdq
	idiv	esi
	jmp	SHORT $LN208@finalize
$LN207@finalize:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	esi
	inc	eax
$LN208@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3812 :           dim_y[n] = ceil_ratio(size_y,sub_y[n])-ceil_ratio(origin_y,sub_y[n]);

	sub	ecx, eax
	mov	eax, DWORD PTR tv2705[ebp]

; 3813 :           set(Sdims,n,0,dim_y[n]); set(Sdims,n,1,dim_x[n]);

	push	ecx
	push	0
	push	ebx
	mov	DWORD PTR [eax+edi], ecx
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	OFFSET ??_C@_05KKKGDPEH@Sdims?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	eax, DWORD PTR tv2703[ebp]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	DWORD PTR [eax+edi]
	push	1
	push	ebx
	push	OFFSET ??_C@_05KKKGDPEH@Sdims?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	esi, DWORD PTR _components$[ebp]
	inc	ebx
	mov	eax, DWORD PTR tv2711[ebp]
	add	edi, 4
	cmp	ebx, esi
	jl	$LL16@finalize
$LN567@finalize:
	mov	bl, BYTE PTR _have_sampling$1$[ebp]
$LN15@finalize:

; 3814 :         }
; 3815 :       have_dims = true;
; 3816 :     }
; 3817 : 
; 3818 :   if ((!have_size) && (!have_sampling))

	cmp	BYTE PTR _have_size$1$[ebp], 0
	jne	$LN72@finalize
	test	bl, bl
	jne	$LN477@finalize

; 3819 :     { // Synthesize a compatible canvas size.
; 3820 :       assert(have_dims);
; 3821 :       if (!(synthesize_canvas_size(components,dim_x,origin_x,size_x) &&

	lea	eax, DWORD PTR _size_x$[ebp]
	push	eax
	push	DWORD PTR _origin_x$[ebp]
	push	DWORD PTR _dim_x$1$[ebp]
	push	esi
	call	?synthesize_canvas_size@@YA_NHQAHHAAH@Z	; synthesize_canvas_size
	mov	edi, DWORD PTR _dim_y$1$[ebp]
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN74@finalize
	lea	eax, DWORD PTR _size_y$[ebp]
	push	eax
	push	DWORD PTR _origin_y$[ebp]
	push	edi
	push	esi
	call	?synthesize_canvas_size@@YA_NHQAHHAAH@Z	; synthesize_canvas_size
	add	esp, 16					; 00000010H
	test	al, al
	jne	SHORT $LN561@finalize
$LN74@finalize:

; 3823 :         { KDU_ERROR(e,82); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$20[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$20[ebp]
	lea	ecx, DWORD PTR _e$20[ebp]
	push	OFFSET ??_C@_0KE@JLIAOLIC@Problem?5trying?5to?5finalize?5SIZ?5i@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3823 :         { KDU_ERROR(e,82); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3828 :           this->textualize_attributes(e); e << "\n";

	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _e$20[ebp]
	push	1
	push	eax
	mov	ecx, ebx
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ; kdu_params::textualize_attributes
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$20[ebp]
	lea	ecx, DWORD PTR _e$20[ebp]
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3829 :           delete[] dim_x;  delete[] dim_y;  delete[] sub_x;  delete[] sub_y;

	push	DWORD PTR _dim_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 3830 :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _e$20[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	jmp	SHORT $LN73@finalize
$LN561@finalize:
	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
$LN73@finalize:

; 3831 :       set(Ssize,0,0,size_y); set(Ssize,0,1,size_x);

	push	DWORD PTR _size_y$[ebp]
	mov	ecx, ebx
	push	0
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _size_x$[ebp]
	mov	ecx, ebx
	push	1
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3832 :       have_size = true;
; 3833 :     }
; 3834 : 
; 3835 :   if (!have_sampling)

	mov	esi, DWORD PTR _components$[ebp]
	mov	BYTE PTR _have_size$1$[ebp], 1
	jmp	SHORT $LN478@finalize
$LN72@finalize:
	test	bl, bl
	jne	$LN564@finalize
	mov	edi, DWORD PTR _dim_y$1$[ebp]
$LN478@finalize:

; 3836 :     { // Synthesize sub-sampling factors from canvas size and image dimensions.
; 3837 :       assert(have_dims && have_size);
; 3838 :       for (n=0; n < components; n++)

	xor	eax, eax
	mov	DWORD PTR _n$4$[ebp], eax
	test	esi, esi
	jle	$LN564@finalize
	mov	eax, DWORD PTR _sub_y$1$[ebp]
	mov	ebx, edi
	mov	ecx, DWORD PTR _dim_x$1$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv2698[ebp], eax
	sub	ecx, edi
	mov	eax, DWORD PTR _sub_x$1$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv2701[ebp], edi
	mov	DWORD PTR tv2700[ebp], ecx
	mov	DWORD PTR tv2697[ebp], eax
	npad	12
$LL19@finalize:

; 3839 :         {
; 3840 :           val = (size_x - origin_x) / dim_x[n]; // Rough estimate.

	mov	edi, DWORD PTR _size_x$[ebp]
	add	ecx, ebx
	mov	ebx, DWORD PTR _origin_x$[ebp]
	mov	eax, edi
	sub	eax, ebx
	mov	DWORD PTR tv2699[ebp], ecx
	cdq
	idiv	DWORD PTR [ecx]
	mov	ecx, eax
	mov	DWORD PTR _val$[ebp], ecx

; 3841 :           if (val <= 0)

	test	ecx, ecx
	jg	SHORT $LN338@finalize

; 3842 :             val = 1;

	mov	ecx, 1
	mov	DWORD PTR _val$[ebp], ecx

; 3843 :           while ((val > 1) &&

	jmp	SHORT $LL22@finalize
$LN338@finalize:
	cmp	ecx, 1
	jle	SHORT $LL22@finalize
$LL20@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	edi, edi
	jg	SHORT $LN215@finalize

; 180  :     return -((-num)/den);

	mov	eax, edi
	cdq
	idiv	ecx
	mov	esi, eax
	jmp	SHORT $LN216@finalize
$LN215@finalize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [edi-1]
	cdq
	idiv	ecx
	lea	esi, DWORD PTR [eax+1]
$LN216@finalize:

; 179  :   if (num <= 0)

	test	ebx, ebx
	jg	SHORT $LN219@finalize

; 180  :     return -((-num)/den);

	mov	eax, ebx
	cdq
	idiv	ecx
	jmp	SHORT $LN220@finalize
$LN219@finalize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ebx-1]
	cdq
	idiv	ecx
	inc	eax
$LN220@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3843 :           while ((val > 1) &&

	sub	esi, eax
	mov	eax, DWORD PTR tv2699[ebp]
	cmp	esi, DWORD PTR [eax]
	jge	SHORT $LL22@finalize

; 3844 :                  ((ceil_ratio(size_x,val)-ceil_ratio(origin_x,val))<dim_x[n]))
; 3845 :             val--;

	dec	ecx
	mov	DWORD PTR _val$[ebp], ecx
	cmp	ecx, 1
	jg	SHORT $LL20@finalize
$LL22@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	edi, edi
	jg	SHORT $LN223@finalize

; 180  :     return -((-num)/den);

	mov	eax, edi
	cdq
	idiv	ecx
	mov	esi, eax
	jmp	SHORT $LN224@finalize
$LN223@finalize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [edi-1]
	cdq
	idiv	ecx
	lea	esi, DWORD PTR [eax+1]
$LN224@finalize:

; 179  :   if (num <= 0)

	test	ebx, ebx
	jg	SHORT $LN227@finalize

; 180  :     return -((-num)/den);

	mov	eax, ebx
	cdq
	idiv	ecx
	jmp	SHORT $LN228@finalize
$LN227@finalize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ebx-1]
	cdq
	idiv	ecx
	inc	eax
$LN228@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3846 :           while ((ceil_ratio(size_x,val)-ceil_ratio(origin_x,val)) > dim_x[n])

	sub	esi, eax
	mov	eax, DWORD PTR tv2699[ebp]
	cmp	esi, DWORD PTR [eax]
	jle	SHORT $LN23@finalize

; 3847 :             val++;

	inc	ecx
	mov	DWORD PTR _val$[ebp], ecx
	jmp	SHORT $LL22@finalize
$LN23@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	edi, edi
	jg	SHORT $LN231@finalize

; 180  :     return -((-num)/den);

	mov	eax, edi
	cdq
	idiv	ecx
	mov	esi, eax
	jmp	SHORT $LN232@finalize
$LN231@finalize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [edi-1]
	cdq
	idiv	ecx
	lea	esi, DWORD PTR [eax+1]
$LN232@finalize:

; 179  :   if (num <= 0)

	test	ebx, ebx
	jg	SHORT $LN235@finalize

; 180  :     return -((-num)/den);

	mov	eax, ebx
	cdq
	idiv	ecx
	jmp	SHORT $LN236@finalize
$LN235@finalize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ebx-1]
	cdq
	idiv	ecx
	inc	eax
$LN236@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3848 :           if ((ceil_ratio(size_x,val)-ceil_ratio(origin_x,val)) != dim_x[n])

	sub	esi, eax
	mov	eax, DWORD PTR tv2699[ebp]
	cmp	esi, DWORD PTR [eax]
	je	SHORT $LN77@finalize

; 3849 :             { KDU_ERROR(e,83); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$19[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$19[ebp]
	lea	ecx, DWORD PTR _e$19[ebp]
	push	OFFSET ??_C@_0JJ@NPLIAPKO@Problem?5trying?5to?5finalize?5SIZ?5i@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3849 :             { KDU_ERROR(e,83); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3853 :               this->textualize_attributes(e); e << "\n";

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _e$19[ebp]
	push	1
	push	eax
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ; kdu_params::textualize_attributes
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$19[ebp]
	lea	ecx, DWORD PTR _e$19[ebp]
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3854 :               delete[] dim_x; delete[] dim_y; delete[] sub_x; delete[] sub_y;

	push	DWORD PTR _dim_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _dim_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 3855 :             }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _e$19[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _val$[ebp]
$LN77@finalize:

; 3856 :           sub_x[n] = val;

	mov	esi, DWORD PTR tv2701[ebp]
	mov	eax, DWORD PTR tv2697[ebp]
	mov	DWORD PTR [eax+esi], ecx

; 3857 :           val = (size_y - origin_y) / dim_y[n]; // Rough estimate.

	mov	edi, DWORD PTR _size_y$[ebp]
	mov	eax, edi
	mov	ebx, DWORD PTR _origin_y$[ebp]
	sub	eax, ebx
	cdq
	idiv	DWORD PTR [esi]
	mov	ecx, eax
	mov	DWORD PTR _val$[ebp], ecx

; 3858 :           if (val <= 0)

	test	ecx, ecx
	jg	SHORT $LN340@finalize

; 3859 :             val = 1;

	mov	ecx, 1
	mov	DWORD PTR _val$[ebp], ecx

; 3860 :           while ((val > 1) &&

	jmp	SHORT $LL26@finalize
$LN340@finalize:
	cmp	ecx, 1
	jle	SHORT $LL26@finalize
$LL24@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	edi, edi
	jg	SHORT $LN243@finalize

; 180  :     return -((-num)/den);

	mov	eax, edi
	cdq
	idiv	ecx
	mov	esi, eax
	jmp	SHORT $LN244@finalize
$LN243@finalize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [edi-1]
	cdq
	idiv	ecx
	lea	esi, DWORD PTR [eax+1]
$LN244@finalize:

; 179  :   if (num <= 0)

	test	ebx, ebx
	jg	SHORT $LN247@finalize

; 180  :     return -((-num)/den);

	mov	eax, ebx
	cdq
	idiv	ecx
	jmp	SHORT $LN248@finalize
$LN247@finalize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ebx-1]
	cdq
	idiv	ecx
	inc	eax
$LN248@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3860 :           while ((val > 1) &&

	sub	esi, eax
	mov	eax, DWORD PTR tv2701[ebp]
	cmp	esi, DWORD PTR [eax]
	jge	SHORT $LL26@finalize

; 3861 :                  ((ceil_ratio(size_y,val)-ceil_ratio(origin_y,val))<dim_y[n]))
; 3862 :             val--;

	dec	ecx
	mov	DWORD PTR _val$[ebp], ecx
	cmp	ecx, 1
	jg	SHORT $LL24@finalize
$LL26@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	edi, edi
	jg	SHORT $LN251@finalize

; 180  :     return -((-num)/den);

	mov	eax, edi
	cdq
	idiv	ecx
	mov	esi, eax
	jmp	SHORT $LN252@finalize
$LN251@finalize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [edi-1]
	cdq
	idiv	ecx
	lea	esi, DWORD PTR [eax+1]
$LN252@finalize:

; 179  :   if (num <= 0)

	test	ebx, ebx
	jg	SHORT $LN255@finalize

; 180  :     return -((-num)/den);

	mov	eax, ebx
	cdq
	idiv	ecx
	jmp	SHORT $LN256@finalize
$LN255@finalize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ebx-1]
	cdq
	idiv	ecx
	inc	eax
$LN256@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3863 :           while ((ceil_ratio(size_y,val)-ceil_ratio(origin_y,val)) > dim_y[n])

	sub	esi, eax
	mov	eax, DWORD PTR tv2701[ebp]
	cmp	esi, DWORD PTR [eax]
	jle	SHORT $LN27@finalize

; 3864 :             val++;

	inc	ecx
	mov	DWORD PTR _val$[ebp], ecx
	jmp	SHORT $LL26@finalize
$LN27@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	edi, edi
	jg	SHORT $LN259@finalize

; 180  :     return -((-num)/den);

	mov	eax, edi
	cdq
	idiv	ecx
	mov	esi, eax
	jmp	SHORT $LN260@finalize
$LN259@finalize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [edi-1]
	cdq
	idiv	ecx
	lea	esi, DWORD PTR [eax+1]
$LN260@finalize:

; 179  :   if (num <= 0)

	test	ebx, ebx
	jg	SHORT $LN263@finalize

; 180  :     return -((-num)/den);

	mov	eax, ebx
	cdq
	idiv	ecx
	jmp	SHORT $LN264@finalize
$LN263@finalize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ebx-1]
	cdq
	idiv	ecx
	inc	eax
$LN264@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3865 :           if ((ceil_ratio(size_y,val)-ceil_ratio(origin_y,val)) != dim_y[n])

	mov	ebx, DWORD PTR tv2701[ebp]
	sub	esi, eax
	cmp	esi, DWORD PTR [ebx]
	je	SHORT $LN565@finalize

; 3866 :             { KDU_ERROR(e,84); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$18[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$18[ebp]
	lea	ecx, DWORD PTR _e$18[ebp]
	push	OFFSET ??_C@_0JH@IIBMOHD@Problem?5trying?5to?5finalize?5SIZ?5i@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3866 :             { KDU_ERROR(e,84); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3870 :               this->textualize_attributes(e); e << "\n";

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _e$18[ebp]
	push	1
	push	eax
	mov	ecx, edi
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ; kdu_params::textualize_attributes
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$18[ebp]
	lea	ecx, DWORD PTR _e$18[ebp]
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3871 :               delete[] dim_x; delete[] dim_y; delete[] sub_x; delete[] sub_y;

	push	DWORD PTR _dim_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _dim_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 3872 :             }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _e$18[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _val$[ebp]
	jmp	SHORT $LN79@finalize
$LN565@finalize:
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN79@finalize:

; 3873 :           sub_y[n] = val;

	mov	eax, DWORD PTR tv2698[ebp]

; 3874 :           set(Ssampling,n,0,sub_y[n]); set(Ssampling,n,1,sub_x[n]);

	mov	esi, DWORD PTR _n$4$[ebp]
	mov	DWORD PTR [eax+ebx], ecx
	mov	ecx, edi
	push	DWORD PTR _val$[ebp]
	push	0
	push	esi
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	eax, DWORD PTR tv2697[ebp]
	mov	ecx, edi
	push	DWORD PTR [eax+ebx]
	push	1
	push	esi
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	ecx, DWORD PTR tv2700[ebp]
	inc	esi
	mov	DWORD PTR _n$4$[ebp], esi
	add	ebx, 4
	mov	esi, DWORD PTR _components$[ebp]
	mov	DWORD PTR tv2701[ebp], ebx
	cmp	DWORD PTR _n$4$[ebp], esi
	jl	$LL19@finalize
	jmp	SHORT $LN18@finalize
$LN564@finalize:
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN18@finalize:

; 3875 :         }
; 3876 :       have_sampling = true;
; 3877 :     }
; 3878 : 
; 3879 :   if (!have_size)

	cmp	BYTE PTR _have_size$1$[ebp], 0
	jne	$LN80@finalize
$LN477@finalize:

; 3880 :     { // Synthesize canvas size from sub-sampling factors and image dimensions.
; 3881 :       assert(have_dims && have_sampling);
; 3882 :       int min_size=0, max_size=0, max, min;

	xor	eax, eax
	xor	ebx, ebx

; 3883 :       for (n=0; n < components; n++)

	xor	edi, edi
	mov	DWORD PTR _max_size$1$[ebp], eax
	test	esi, esi
	jle	$LN85@finalize
	mov	edx, DWORD PTR _sub_x$1$[ebp]
	mov	eax, DWORD PTR _dim_x$1$[ebp]
	sub	eax, edx
	mov	DWORD PTR tv2695[ebp], edx
	mov	DWORD PTR tv2693[ebp], eax
	npad	9
$LL396@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _origin_x$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3885 :           max = (ceil_ratio(origin_x,sub_x[n])+dim_x[n])*sub_x[n];

	mov	ecx, DWORD PTR [edx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN397@finalize

; 180  :     return -((-num)/den);

	cdq
	idiv	ecx
	jmp	SHORT $LN572@finalize
$LN397@finalize:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ecx
	inc	eax
$LN572@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3885 :           max = (ceil_ratio(origin_x,sub_x[n])+dim_x[n])*sub_x[n];

	mov	edx, DWORD PTR tv2695[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 182  :     return 1+((num-1)/den);

	mov	DWORD PTR $T4[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3885 :           max = (ceil_ratio(origin_x,sub_x[n])+dim_x[n])*sub_x[n];

	mov	eax, DWORD PTR tv2693[ebp]
	mov	eax, DWORD PTR [eax+edx]
	add	eax, DWORD PTR $T4[ebp]
	imul	eax, ecx

; 3886 :           min = max - sub_x[n] + 1;

	mov	ecx, eax
	sub	ecx, DWORD PTR [edx]
	inc	ecx

; 3887 :           if ((n==0) || (max < max_size)) max_size = max;

	test	edi, edi
	je	SHORT $LN399@finalize
	cmp	eax, DWORD PTR _max_size$1$[ebp]
	jge	SHORT $LN559@finalize
$LN399@finalize:
	mov	DWORD PTR _max_size$1$[ebp], eax
	jmp	SHORT $LN400@finalize
$LN559@finalize:
	mov	eax, DWORD PTR _max_size$1$[ebp]
$LN400@finalize:

; 3888 :           if ((n==0) || (min > min_size)) min_size = min;

	test	edi, edi
	je	SHORT $LN401@finalize
	cmp	ecx, ebx
	jle	SHORT $LN402@finalize
$LN401@finalize:
	mov	ebx, ecx
$LN402@finalize:

; 3883 :       for (n=0; n < components; n++)

	inc	edi
	add	edx, 4
	mov	DWORD PTR tv2695[ebp], edx
	cmp	edi, esi
	jl	SHORT $LL396@finalize

; 3889 :         }
; 3890 :       if (min_size > max_size)

	cmp	ebx, eax
	jle	SHORT $LN85@finalize

; 3891 :         { KDU_ERROR(e,85); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$17[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$17[ebp]
	lea	ecx, DWORD PTR _e$17[ebp]
	push	OFFSET ??_C@_0JO@OKOEKKHK@Problem?5trying?5to?5finalize?5SIZ?5i@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3891 :         { KDU_ERROR(e,85); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 9
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3895 :           this->textualize_attributes(e); e << "\n";

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _e$17[ebp]
	push	1
	push	eax
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ; kdu_params::textualize_attributes
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$17[ebp]
	lea	ecx, DWORD PTR _e$17[ebp]
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3896 :           delete[] dim_x;  delete[] dim_y;  delete[] sub_x;  delete[] sub_y;

	push	DWORD PTR _dim_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _dim_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 3897 :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _e$17[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	esi, DWORD PTR _components$[ebp]
	mov	eax, DWORD PTR _max_size$1$[ebp]
$LN85@finalize:

; 3898 :       size_x = min_size;
; 3899 :       for (n=0; n < components; n++)

	xor	edi, edi
	mov	DWORD PTR _size_x$[ebp], ebx
	test	esi, esi
	jle	SHORT $LN32@finalize
	mov	edx, DWORD PTR _sub_y$1$[ebp]
	mov	eax, DWORD PTR _dim_y$1$[ebp]
	sub	eax, edx
	mov	DWORD PTR tv2691[ebp], edx
	mov	DWORD PTR tv2704[ebp], eax
$LL404@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _origin_y$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3901 :           max = (ceil_ratio(origin_y,sub_y[n])+dim_y[n])*sub_y[n];

	mov	ecx, DWORD PTR [edx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN405@finalize

; 180  :     return -((-num)/den);

	cdq
	idiv	ecx
	jmp	SHORT $LN573@finalize
$LN405@finalize:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ecx
	inc	eax
$LN573@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3901 :           max = (ceil_ratio(origin_y,sub_y[n])+dim_y[n])*sub_y[n];

	mov	edx, DWORD PTR tv2691[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 182  :     return 1+((num-1)/den);

	mov	DWORD PTR $T3[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3901 :           max = (ceil_ratio(origin_y,sub_y[n])+dim_y[n])*sub_y[n];

	mov	eax, DWORD PTR tv2704[ebp]
	mov	eax, DWORD PTR [edx+eax]
	add	eax, DWORD PTR $T3[ebp]
	imul	eax, ecx

; 3902 :           min = max - sub_y[n] + 1;

	mov	ecx, eax
	sub	ecx, DWORD PTR [edx]
	inc	ecx

; 3903 :           if ((n==0) || (max < max_size)) max_size = max;

	test	edi, edi
	je	SHORT $LN407@finalize
	cmp	eax, DWORD PTR _max_size$1$[ebp]
	jge	SHORT $LN558@finalize
$LN407@finalize:
	mov	DWORD PTR _max_size$1$[ebp], eax
	jmp	SHORT $LN408@finalize
$LN558@finalize:
	mov	eax, DWORD PTR _max_size$1$[ebp]
$LN408@finalize:

; 3904 :           if ((n==0) || (min > min_size)) min_size = min;

	test	edi, edi
	je	SHORT $LN409@finalize
	cmp	ecx, ebx
	jle	SHORT $LN410@finalize
$LN409@finalize:
	mov	ebx, ecx
$LN410@finalize:

; 3898 :       size_x = min_size;
; 3899 :       for (n=0; n < components; n++)

	inc	edi
	add	edx, 4
	mov	DWORD PTR tv2691[ebp], edx
	cmp	edi, esi
	jl	SHORT $LL404@finalize
$LN32@finalize:

; 3905 :         }
; 3906 :       if (min_size > max_size)

	cmp	ebx, eax
	jle	SHORT $LN562@finalize

; 3907 :         { KDU_ERROR(e,86); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$16[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	OFFSET ??_C@_0JM@LALDBFDG@Problem?5trying?5to?5finalize?5SIZ?5i@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3907 :         { KDU_ERROR(e,86); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3911 :           this->textualize_attributes(e); e << "\n";

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _e$16[ebp]
	push	1
	push	eax
	mov	ecx, edi
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ; kdu_params::textualize_attributes
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3912 :           delete[] dim_x;  delete[] dim_y;  delete[] sub_x;  delete[] sub_y;

	push	DWORD PTR _dim_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _dim_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 3913 :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _e$16[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	jmp	SHORT $LN90@finalize
$LN562@finalize:
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN90@finalize:

; 3914 :       size_y = min_size;
; 3915 :       set(Ssize,0,0,size_y); set(Ssize,0,1,size_x);

	push	ebx
	push	0
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	mov	ecx, edi
	mov	DWORD PTR _size_y$[ebp], ebx
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _size_x$[ebp]
	mov	ecx, edi
	push	1
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	esi, DWORD PTR _components$[ebp]
$LN80@finalize:

; 3916 :       have_size = true;
; 3917 :     }
; 3918 :   
; 3919 :   // Now for the final verification that all quantities are consistent.
; 3920 :   // Here we set the tiling parameters if necessary.
; 3921 : 
; 3922 :   assert(have_sampling && have_dims && have_size);
; 3923 :   for (n=0; n < components; n++)

	mov	DWORD PTR _n$7$[ebp], 0
	test	esi, esi
	jle	$LN35@finalize
	mov	ecx, DWORD PTR _sub_x$1$[ebp]
	mov	edi, ecx
	mov	eax, DWORD PTR _dim_x$1$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv2692[ebp], eax
	mov	eax, DWORD PTR _sub_y$1$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv2687[ebp], eax
	mov	eax, DWORD PTR _dim_y$1$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv2684[ebp], eax
	npad	4
$LL36@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _size_x$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3926 :             ceil_ratio(origin_x,sub_x[n])) != dim_x[n]) ||

	mov	ebx, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN287@finalize

; 180  :     return -((-num)/den);

	cdq
	idiv	ebx
	mov	ecx, eax
	jmp	SHORT $LN288@finalize
$LN287@finalize:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ebx
	lea	ecx, DWORD PTR [eax+1]
$LN288@finalize:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _origin_x$[ebp]
	test	eax, eax
	jg	SHORT $LN291@finalize

; 180  :     return -((-num)/den);

	cdq
	idiv	ebx
	jmp	SHORT $LN292@finalize
$LN291@finalize:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ebx
	inc	eax
$LN292@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3926 :             ceil_ratio(origin_x,sub_x[n])) != dim_x[n]) ||

	sub	ecx, eax
	mov	eax, DWORD PTR tv2692[ebp]
	cmp	ecx, DWORD PTR [edi+eax]
	jne	SHORT $LN92@finalize
	mov	eax, DWORD PTR tv2687[ebp]
	mov	ebx, DWORD PTR [edi+eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _size_y$[ebp]
	test	eax, eax
	jg	SHORT $LN295@finalize

; 180  :     return -((-num)/den);

	cdq
	idiv	ebx
	mov	ecx, eax
	jmp	SHORT $LN296@finalize
$LN295@finalize:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ebx
	lea	ecx, DWORD PTR [eax+1]
$LN296@finalize:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _origin_y$[ebp]
	test	eax, eax
	jg	SHORT $LN299@finalize

; 180  :     return -((-num)/den);

	cdq
	idiv	ebx
	jmp	SHORT $LN300@finalize
$LN299@finalize:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ebx
	inc	eax
$LN300@finalize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3926 :             ceil_ratio(origin_x,sub_x[n])) != dim_x[n]) ||

	sub	ecx, eax
	mov	eax, DWORD PTR tv2684[ebp]
	cmp	ecx, DWORD PTR [edi+eax]
	je	SHORT $LN34@finalize
$LN92@finalize:

; 3929 :         { KDU_ERROR(e,87); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$15[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$15[ebp]
	lea	ecx, DWORD PTR _e$15[ebp]
	push	OFFSET ??_C@_0HB@GIGMGNIM@Problem?5trying?5to?5finalize?5SIZ?5i@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3929 :         { KDU_ERROR(e,87); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3933 :           this->textualize_attributes(e); e << "\n";

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _e$15[ebp]
	push	1
	push	eax
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ; kdu_params::textualize_attributes
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$15[ebp]
	lea	ecx, DWORD PTR _e$15[ebp]
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3934 :           delete[] dim_x;  delete[] dim_y;  delete[] sub_x;  delete[] sub_y;

	push	DWORD PTR _dim_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _dim_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 3935 :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _e$15[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	esi, DWORD PTR _components$[ebp]
$LN34@finalize:

; 3916 :       have_size = true;
; 3917 :     }
; 3918 :   
; 3919 :   // Now for the final verification that all quantities are consistent.
; 3920 :   // Here we set the tiling parameters if necessary.
; 3921 : 
; 3922 :   assert(have_sampling && have_dims && have_size);
; 3923 :   for (n=0; n < components; n++)

	mov	eax, DWORD PTR _n$7$[ebp]
	add	edi, 4
	inc	eax
	mov	DWORD PTR _n$7$[ebp], eax
	cmp	eax, esi
	jl	$LL36@finalize
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN35@finalize:

; 3936 :     }
; 3937 :   delete[] dim_x;  delete[] dim_y;  delete[] sub_x;  delete[] sub_y;

	push	DWORD PTR _dim_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _dim_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_x$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	DWORD PTR _sub_y$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 3938 :   
; 3939 :   int tile_x, tile_y, tile_ox, tile_oy;
; 3940 : 
; 3941 :   if (!(get(Stile_origin,0,0,tile_oy) && get(Stile_origin,0,1,tile_ox)))

	lea	eax, DWORD PTR _tile_oy$[ebp]
	mov	ecx, edi
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN94@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _tile_ox$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN93@finalize
$LN94@finalize:

; 3942 :     { set(Stile_origin,0,0,tile_oy=origin_y);

	mov	eax, DWORD PTR _origin_y$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	mov	DWORD PTR _tile_oy$[ebp], eax
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 3943 :       set(Stile_origin,0,1,tile_ox=origin_x); }

	mov	eax, DWORD PTR _origin_x$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	mov	DWORD PTR _tile_ox$[ebp], eax
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN93@finalize:

; 3944 :   if (!(get(Stiles,0,0,tile_y) && get(Stiles,0,1,tile_x)))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _tile_y$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN96@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _tile_x$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN95@finalize
$LN96@finalize:

; 3945 :     {
; 3946 :       tile_x = size_x - tile_ox;

	mov	eax, DWORD PTR _size_x$[ebp]

; 3947 :       tile_y = size_y - tile_oy;
; 3948 :       set(Stiles,0,0,tile_y); set(Stiles,0,1,tile_x);

	mov	ecx, edi
	sub	eax, DWORD PTR _tile_ox$[ebp]
	mov	DWORD PTR _tile_x$[ebp], eax
	mov	eax, DWORD PTR _size_y$[ebp]
	sub	eax, DWORD PTR _tile_oy$[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	mov	DWORD PTR _tile_y$[ebp], eax
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	push	DWORD PTR _tile_x$[ebp]
	mov	ecx, edi
	push	1
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN95@finalize:

; 3949 :     }
; 3950 :   if ((tile_ox > origin_x) || ((tile_ox+tile_x) <= origin_x) ||
; 3951 :       (tile_oy > origin_y) || ((tile_oy+tile_y) <= origin_y))

	mov	ecx, DWORD PTR _tile_ox$[ebp]
	mov	edx, DWORD PTR _origin_x$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN98@finalize
	mov	eax, DWORD PTR _tile_x$[ebp]
	add	eax, ecx
	cmp	eax, edx
	jle	SHORT $LN98@finalize
	mov	ecx, DWORD PTR _tile_oy$[ebp]
	mov	edx, DWORD PTR _origin_y$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN98@finalize
	mov	eax, DWORD PTR _tile_y$[ebp]
	add	eax, ecx
	cmp	eax, edx
	jg	SHORT $LN97@finalize
$LN98@finalize:

; 3952 :     { KDU_ERROR(e,88); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$14[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	OFFSET ??_C@_0MN@GGGLGLFK@Problems?5trying?5to?5finalize?5SIZ?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3952 :     { KDU_ERROR(e,88); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3957 :       this->textualize_attributes(e); e << "\n";

	push	1
	lea	eax, DWORD PTR _e$14[ebp]
	mov	ecx, edi
	push	eax
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ; kdu_params::textualize_attributes
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3958 :     }

	lea	ecx, DWORD PTR _e$14[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN97@finalize:

; 3959 : 
; 3960 :   // See if we need to set the profile and perform some basic checks
; 3961 :   bool use_caps;
; 3962 :   if (!get(Scap,0,0,use_caps))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _use_caps$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04JNHDNPF@Scap?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN99@finalize

; 3963 :     set(Scap,0,0,use_caps=false);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_04JNHDNPF@Scap?$AA@
	mov	ecx, edi
	mov	BYTE PTR _use_caps$[ebp], al
	call	?set@kdu_params@@QAEXPBDHH_N@Z		; kdu_params::set
$LN99@finalize:

; 3964 :   int extensions;
; 3965 :   if (!get(Sextensions,0,0,extensions))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _extensions$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@NJJFAENN@Sextensions?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN100@finalize

; 3966 :     set(Sextensions,0,0,extensions=0);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0M@NJJFAENN@Sextensions?$AA@
	mov	ecx, edi
	mov	DWORD PTR _extensions$[ebp], 0
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN100@finalize:

; 3967 :   int profile;
; 3968 :   if (!get(Sprofile,0,0,profile))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _profile$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN101@finalize

; 3969 :     set(Sprofile,0,0,profile=2);

	push	2
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	mov	ecx, edi
	mov	DWORD PTR _profile$[ebp], 2
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN101@finalize:

; 3970 :   if ((profile < 0) || (profile > 5))

	mov	esi, DWORD PTR _profile$[ebp]
	mov	DWORD PTR _new_profile$1$[ebp], esi
	test	esi, esi
	js	SHORT $LN103@finalize
	cmp	esi, 5
	jle	SHORT $LN102@finalize
$LN103@finalize:

; 3971 :     { KDU_ERROR(e,89); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$13[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	OFFSET ??_C@_0BFE@FLEIONEE@Illegal?5profile?5index?4?5?5?$CCSprofil@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3971 :     { KDU_ERROR(e,89); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 3978 :     }

	lea	ecx, DWORD PTR _e$13[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	esi, DWORD PTR _profile$[ebp]
	mov	DWORD PTR _new_profile$1$[ebp], esi
$LN102@finalize:

; 3979 : 
; 3980 :   if (after_reading)

	cmp	BYTE PTR _after_reading$[ebp], 0
	jne	$LN53@finalize

; 3981 :     return;
; 3982 : 
; 3983 :   // Prepare to check for Part-2 features
; 3984 :   int new_profile=profile, new_extensions=extensions;

	mov	ebx, DWORD PTR _extensions$[ebp]

; 3985 :   if ((extensions != 0) && (profile != Sprofile_PART2))

	test	ebx, ebx
	je	SHORT $LN105@finalize
	cmp	esi, 3
	je	SHORT $LN105@finalize

; 3986 :     set(Sprofile,0,0,profile=Sprofile_PART2);

	push	3
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	mov	ecx, edi
	mov	DWORD PTR _profile$[ebp], 3
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN105@finalize:

; 3987 : 
; 3988 :   // Finalize CBD information
; 3989 :   int num_output_components;
; 3990 :   if (get(Mcomponents,0,0,num_output_components) &&

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _num_output_components$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@FAIBBHLL@Mcomponents?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN106@finalize
	cmp	DWORD PTR _num_output_components$[ebp], 0
	jle	SHORT $LN106@finalize

; 3991 :       (num_output_components > 0))
; 3992 :     {
; 3993 :       new_profile = Sprofile_PART2;

	mov	esi, 3

; 3994 :       new_extensions |= Sextensions_MCT;

	or	ebx, 256				; 00000100H
	mov	DWORD PTR _new_profile$1$[ebp], esi

; 3995 :     }
; 3996 :   else

	jmp	SHORT $LN107@finalize
$LN106@finalize:

; 3997 :     new_extensions &= ~Sextensions_MCT;

	and	ebx, -257				; fffffeffH
$LN107@finalize:

; 3998 : 
; 3999 :   // Scan through the other attributes to see if there are
; 4000 :   // additional Part-2 extensions.
; 4001 :   kdu_params *cod, *cod_root = access_cluster(COD_params);

	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	mov	ecx, edi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	DWORD PTR _cod_root$1$[ebp], eax

; 4002 :   if (cod_root != NULL)

	test	eax, eax
	je	$LN38@finalize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 742  :     int get_num_tiles() { return num_tiles; }

	mov	ecx, DWORD PTR [eax+20]

; 732  :     int get_num_comps() { return num_comps; }

	mov	edx, DWORD PTR [eax+24]

; 742  :     int get_num_tiles() { return num_tiles; }

	mov	DWORD PTR _num_t$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4007 :       for (t=-1; t < num_t; t++)

	or	ecx, -1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 732  :     int get_num_comps() { return num_comps; }

	mov	DWORD PTR _num_c$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4007 :       for (t=-1; t < num_t; t++)

	mov	DWORD PTR _t$1$[ebp], ecx
	cmp	DWORD PTR _num_t$1$[ebp], ecx
	jle	$LN38@finalize
$LL39@finalize:

; 4008 :         for (c=-1; c < num_c; c++)

	or	eax, -1
	mov	DWORD PTR _c$1$[ebp], eax
	cmp	edx, eax
	jle	$LN37@finalize
$LL42@finalize:

; 4009 :           if ((cod = cod_root->access_unique(t,c,0)) != NULL)

	push	0
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _cod_root$1$[ebp]
	call	?access_unique@kdu_params@@QAEPAV1@HHH@Z ; kdu_params::access_unique
	mov	edi, eax
	test	edi, edi
	je	$LN40@finalize

; 4010 :             {
; 4011 :               if ((cod->get(Cads,0,0,val,false) && (val != 0)) ||

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04OONIPDNE@Cads?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN113@finalize
	cmp	DWORD PTR _val$[ebp], 0
	jne	SHORT $LN112@finalize
$LN113@finalize:
	cmp	DWORD PTR _t$1$[ebp], 0
	jge	SHORT $LN110@finalize
	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04NKICNHII@Cdfs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN110@finalize
	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN110@finalize
$LN112@finalize:

; 4012 :                   ((t < 0) && cod->get(Cdfs,0,0,val,false) && (val != 0)))
; 4013 :                 {
; 4014 :                   new_profile = Sprofile_PART2;

	mov	esi, 3

; 4015 :                   new_extensions |= Sextensions_DECOMP;

	or	ebx, 32					; 00000020H
	mov	DWORD PTR _new_profile$1$[ebp], esi

; 4016 :                 }
; 4017 :               else

	jmp	SHORT $LN44@finalize
$LN110@finalize:

; 4018 :                 for (int p=0; cod->get(Cdecomp,p,0,val,false,false); p++)

	push	1
	xor	esi, esi
	lea	eax, DWORD PTR _val$[ebp]
	push	esi
	push	esi
	push	eax
	push	esi
	push	esi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN557@finalize
$LL45@finalize:

; 4019 :                   if (val != 3)

	cmp	DWORD PTR _val$[ebp], 3
	jne	SHORT $LN112@finalize

; 4018 :                 for (int p=0; cod->get(Cdecomp,p,0,val,false,false); p++)

	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _val$[ebp]
	inc	esi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	mov	ecx, edi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL45@finalize
$LN557@finalize:
	mov	esi, DWORD PTR _new_profile$1$[ebp]
$LN44@finalize:

; 4020 :                     {
; 4021 :                       new_profile = Sprofile_PART2;
; 4022 :                       new_extensions |= Sextensions_DECOMP;
; 4023 :                       break;
; 4024 :                     }
; 4025 : 
; 4026 :               if (cod->get(Catk,0,0,val,false) && (val != 0))

	push	1
	push	1
	push	0
	lea	eax, DWORD PTR _val$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN117@finalize
	cmp	DWORD PTR _val$[ebp], 0
	je	SHORT $LN117@finalize

; 4027 :                 {
; 4028 :                   new_profile = Sprofile_PART2;
; 4029 :                   kdu_params *atk = access_cluster(ATK_params);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	esi, 3
	push	OFFSET ??_C@_03IFCLAPBJ@ATK?$AA@
	mov	DWORD PTR _new_profile$1$[ebp], esi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 4030 :                   if ((atk != NULL) &&
; 4031 :                       ((atk = atk->access_relation(t,-1,val,true)) != NULL) &&
; 4032 :                       atk->get(Ksymmetric,0,0,b_val) && b_val)

	test	eax, eax
	je	SHORT $LN116@finalize
	push	1
	push	DWORD PTR _val$[ebp]
	mov	ecx, eax
	push	-1
	push	DWORD PTR _t$1$[ebp]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	test	eax, eax
	je	SHORT $LN116@finalize
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _b_val$27[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0L@BNGLHLNI@Ksymmetric?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN116@finalize
	cmp	BYTE PTR _b_val$27[ebp], 0
	je	SHORT $LN116@finalize

; 4033 :                     new_extensions |= Sextensions_SYM_KNL;

	or	ebx, 128				; 00000080H

; 4034 :                   else

	jmp	SHORT $LN117@finalize
$LN116@finalize:

; 4035 :                     new_extensions |= Sextensions_ANY_KNL;

	or	ebx, 64					; 00000040H
$LN117@finalize:

; 4036 :                 }
; 4037 :               if ((cod->get(Calign_blk_last,0,0,b_val) && b_val) ||

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _b_val$27[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN120@finalize
	cmp	BYTE PTR _b_val$27[ebp], 0
	jne	SHORT $LN119@finalize
$LN120@finalize:
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _b_val$27[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN40@finalize
	cmp	BYTE PTR _b_val$27[ebp], 0
	je	SHORT $LN40@finalize
$LN119@finalize:

; 4038 :                   (cod->get(Calign_blk_last,0,1,b_val) && b_val))
; 4039 :                 new_profile = Sprofile_PART2;

	mov	esi, 3
	mov	DWORD PTR _new_profile$1$[ebp], esi
$LN40@finalize:

; 4008 :         for (c=-1; c < num_c; c++)

	mov	eax, DWORD PTR _c$1$[ebp]
	mov	edx, DWORD PTR _num_c$1$[ebp]
	inc	eax
	mov	ecx, DWORD PTR _t$1$[ebp]
	mov	DWORD PTR _c$1$[ebp], eax
	cmp	eax, edx
	jl	$LL42@finalize
$LN37@finalize:

; 4007 :       for (t=-1; t < num_t; t++)

	inc	ecx
	mov	DWORD PTR _t$1$[ebp], ecx
	cmp	ecx, DWORD PTR _num_t$1$[ebp]
	jl	$LL39@finalize
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN38@finalize:

; 4040 :             }
; 4041 :     }
; 4042 :   if (new_profile != profile)

	cmp	esi, DWORD PTR _profile$[ebp]
	je	SHORT $LN121@finalize

; 4043 :     set(Sprofile,0,0,new_profile);

	push	esi
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	mov	ecx, edi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN121@finalize:

; 4044 :   if (new_extensions != extensions)

	cmp	ebx, DWORD PTR _extensions$[ebp]
	je	SHORT $LN122@finalize

; 4045 :     set(Sextensions,0,0,new_extensions);

	push	ebx
	push	0
	push	0
	push	OFFSET ??_C@_0M@NJJFAENN@Sextensions?$AA@
	mov	ecx, edi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN122@finalize:

; 4046 :   
; 4047 :   // Perform some Digital Cinema checks
; 4048 :   if ((profile != Sprofile_CINEMA2K) && (profile != Sprofile_CINEMA4K))

	mov	eax, DWORD PTR _profile$[ebp]
	cmp	eax, 4
	je	SHORT $LN123@finalize
	cmp	eax, 5
	jne	$LN53@finalize
$LN123@finalize:

; 4049 :     return;
; 4050 :   if (profile != new_profile)

	cmp	DWORD PTR _profile$[ebp], esi
	je	SHORT $LN124@finalize

; 4051 :     { KDU_WARNING(w,0x11110810); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$12[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$12[ebp]
	lea	ecx, DWORD PTR _w$12[ebp]
	push	OFFSET ??_C@_0IJ@LMINEOIM@Code?9stream?5profile?5had?5to?5be?5ch@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4051 :     { KDU_WARNING(w,0x11110810); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4055 :       return;

	lea	ecx, DWORD PTR _w$12[ebp]
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
	jmp	$LN53@finalize
$LN124@finalize:

; 4056 :     }
; 4057 :   int sval=0;
; 4058 :   for (n=0; n < components; n++)

	mov	eax, DWORD PTR _components$[ebp]
	xor	esi, esi
	mov	DWORD PTR _sval$[ebp], 0
	test	eax, eax
	jle	$LN352@finalize
$LL48@finalize:

; 4059 :     if (!(get(Ssampling,n,0,sval) && (sval == 1) &&

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _sval$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN540@finalize
	cmp	DWORD PTR _sval$[ebp], 1
	jne	$LN540@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _sval$[ebp]
	mov	ecx, edi
	push	eax
	push	1
	push	esi
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN540@finalize
	cmp	DWORD PTR _sval$[ebp], 1
	jne	SHORT $LN540@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _sval$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_07MGJMMJC@Ssigned?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN540@finalize
	cmp	DWORD PTR _sval$[ebp], 0
	jne	SHORT $LN540@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _sval$[ebp]
	mov	ecx, edi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_0L@BADPNFGK@Sprecision?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN540@finalize
	cmp	DWORD PTR _sval$[ebp], 12		; 0000000cH
	jne	SHORT $LN540@finalize

; 4056 :     }
; 4057 :   int sval=0;
; 4058 :   for (n=0; n < components; n++)

	mov	eax, DWORD PTR _components$[ebp]
	inc	esi
	cmp	esi, eax
	jl	$LL48@finalize
	jmp	SHORT $LN352@finalize
$LN540@finalize:
	mov	eax, DWORD PTR _components$[ebp]
$LN352@finalize:

; 4060 :           get(Ssampling,n,1,sval) && (sval == 1) &&
; 4061 :           get(Ssigned,n,0,sval) && (sval == 0) &&
; 4062 :           get(Sprecision,n,0,sval) && (sval == 12)))
; 4063 :       break;
; 4064 :   if ((components != 3) || (n != 3))

	cmp	eax, 3
	jne	SHORT $LN128@finalize
	cmp	esi, eax
	je	SHORT $LN127@finalize
$LN128@finalize:

; 4065 :     { KDU_ERROR(e,0x11110811); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$11[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_0NP@LDCOLEKI@Profile?5violation?5detected?4?5?5Cod@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4065 :     { KDU_ERROR(e,0x11110811); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4070 :     }

	lea	ecx, DWORD PTR _e$11[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN127@finalize:

; 4071 :   if ((origin_x != 0) || (origin_y != 0) || (tile_ox != 0) || (tile_oy != 0))

	cmp	DWORD PTR _origin_x$[ebp], 0
	jne	SHORT $LN130@finalize
	cmp	DWORD PTR _origin_y$[ebp], 0
	jne	SHORT $LN130@finalize
	cmp	DWORD PTR _tile_ox$[ebp], 0
	jne	SHORT $LN130@finalize
	cmp	DWORD PTR _tile_oy$[ebp], 0
	je	SHORT $LN129@finalize
$LN130@finalize:

; 4072 :     { KDU_ERROR(e,0x11110812); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$10[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0KG@LAENILL@Profile?5violation?5detected?4?5?5Cod@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4072 :     { KDU_ERROR(e,0x11110812); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 16		; 00000010H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4076 :     }

	lea	ecx, DWORD PTR _e$10[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN129@finalize:

; 4077 :   if ((size_x < tile_x) || (size_y < tile_y))

	mov	eax, DWORD PTR _size_x$[ebp]
	cmp	eax, DWORD PTR _tile_x$[ebp]
	jl	SHORT $LN132@finalize
	mov	ecx, DWORD PTR _size_y$[ebp]
	cmp	ecx, DWORD PTR _tile_y$[ebp]
	jge	SHORT $LN131@finalize
$LN132@finalize:

; 4078 :     { KDU_ERROR(e,0x11110813); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$9[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0HP@KEPFIMCP@Profile?5violation?5detected?4?5?5Cod@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4078 :     { KDU_ERROR(e,0x11110813); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4082 :     }

	lea	ecx, DWORD PTR _e$9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _size_y$[ebp]
	mov	eax, DWORD PTR _size_x$[ebp]
$LN131@finalize:

; 4083 :   if (profile == Sprofile_CINEMA2K)

	cmp	DWORD PTR _profile$[ebp], 4
	jne	SHORT $LN133@finalize

; 4084 :     {
; 4085 :       if ((size_x > 2048) || (size_y > 1080))

	cmp	eax, 2048				; 00000800H
	jg	SHORT $LN136@finalize
	cmp	ecx, 1080				; 00000438H
	jle	SHORT $LN137@finalize
$LN136@finalize:

; 4086 :         { KDU_ERROR(e,0x11110814); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0JJ@ELMILGL@Profile?5violation?5detected?4?5?5Cod@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4092 :   else

	jmp	SHORT $LN574@finalize
$LN133@finalize:

; 4093 :     {
; 4094 :       if ((size_x > 4096) || (size_y > 2160))

	cmp	eax, 4096				; 00001000H
	jg	SHORT $LN138@finalize
	cmp	ecx, 2160				; 00000870H
	jle	SHORT $LN137@finalize
$LN138@finalize:

; 4095 :         { KDU_ERROR(e,0x11110815); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$7[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
	mov	DWORD PTR __$EHRec$[ebp+8], 19		; 00000013H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0JJ@DLDOMHMJ@Profile?5violation?5detected?4?5?5Cod@
$LN574@finalize:
	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4099 :         }

	lea	ecx, DWORD PTR _e$7[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN137@finalize:

; 4100 :     }
; 4101 :   kdu_params *org = access_cluster(ORG_params);

	push	OFFSET ??_C@_03MNMMELJE@ORG?$AA@
	mov	ecx, edi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	esi, eax

; 4102 :   if (org != NULL)

	test	esi, esi
	je	$LN542@finalize

; 4103 :     {
; 4104 :       org->set(ORGgen_tlm,0,0,(profile==Sprofile_CINEMA2K)?3:6);

	cmp	DWORD PTR _profile$[ebp], 4
	mov	eax, 3
	mov	ecx, 6
	cmove	ecx, eax
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0L@CIAEHHDE@ORGgen_tlm?$AA@
	mov	ecx, esi
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set

; 4105 :       int tparts = 0;
; 4106 :       if (!org->get(ORGtparts,0,0,tparts))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _tparts$5[ebp]
	mov	DWORD PTR _tparts$5[ebp], 0
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_09CNLDEMAK@ORGtparts?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN140@finalize

; 4107 :         org->set(ORGtparts,0,0,tparts=ORGtparts_C);

	push	4
	push	0
	push	0
	push	OFFSET ??_C@_09CNLDEMAK@ORGtparts?$AA@
	mov	ecx, esi
	mov	DWORD PTR _tparts$5[ebp], 4
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN140@finalize:

; 4108 :       if (tparts != ORGtparts_C)

	cmp	DWORD PTR _tparts$5[ebp], 4
	je	SHORT $LN542@finalize

; 4109 :         { KDU_WARNING(w,0x11110815); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$6[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$6[ebp]
	lea	ecx, DWORD PTR _w$6[ebp]
	push	OFFSET ??_C@_0BAO@JPIFODPP@Profile?5violation?5detected?4?5?5Cod@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4109 :         { KDU_WARNING(w,0x11110815); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 20		; 00000014H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4115 :         }

	lea	ecx, DWORD PTR _w$6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN542@finalize:

; 4116 :     }
; 4117 :   
; 4118 :   if (profile == Sprofile_CINEMA2K)

	cmp	DWORD PTR _profile$[ebp], 4
	je	$LN53@finalize

; 4119 :     return;
; 4120 :   int num_levels = 0;
; 4121 :   if (cod_root == NULL)

	mov	ebx, DWORD PTR _cod_root$1$[ebp]
	mov	DWORD PTR _num_levels$[ebp], 0
	test	ebx, ebx
	je	$LN53@finalize

; 4122 :     return;
; 4123 :   if (!cod_root->get(Clevels,0,0,num_levels))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _num_levels$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN144@finalize

; 4124 :     cod_root->set(Clevels,0,0,num_levels=6);

	push	6
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	mov	ecx, ebx
	mov	DWORD PTR _num_levels$[ebp], 6
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
$LN144@finalize:

; 4125 :   kdu_params *poc = access_cluster(POC_params);

	push	OFFSET ??_C@_03LFCEPJHK@POC?$AA@
	mov	ecx, edi
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	ebx, eax

; 4126 :   if (poc == NULL) 

	test	ebx, ebx
	je	$LN53@finalize

; 4127 :     return;
; 4128 :   int pval, params_4k[12] =
; 4129 :     { 0,0,1,num_levels,3,Corder_CPRL,

	mov	eax, DWORD PTR _num_levels$[ebp]
	mov	DWORD PTR _params_4k$[ebp+12], eax

; 4130 :       num_levels,0,1,num_levels+1,3,Corder_CPRL};

	mov	DWORD PTR _params_4k$[ebp+24], eax
	inc	eax
	mov	DWORD PTR _params_4k$[ebp], 0

; 4131 :   bool existing_error = false;
; 4132 :   for (n=0; n < 12; n++)

	xor	edi, edi
	mov	DWORD PTR _params_4k$[ebp+4], 0
	mov	DWORD PTR _params_4k$[ebp+8], 1
	mov	DWORD PTR _params_4k$[ebp+16], 3
	mov	DWORD PTR _params_4k$[ebp+20], 4
	mov	DWORD PTR _params_4k$[ebp+28], 0
	mov	DWORD PTR _params_4k$[ebp+32], 1
	mov	DWORD PTR _params_4k$[ebp+36], eax
	mov	DWORD PTR _params_4k$[ebp+40], 3
	mov	DWORD PTR _params_4k$[ebp+44], 4
	mov	BYTE PTR _existing_error$1$[ebp], 0
	npad	5
$LL51@finalize:

; 4133 :     if (!poc->get(Porder,n/6,n%6,pval))

	mov	eax, 715827883				; 2aaaaaabH
	imul	edi
	push	1
	mov	esi, edx
	lea	eax, DWORD PTR _pval$[ebp]
	push	1
	shr	esi, 31					; 0000001fH
	add	esi, edx
	push	1
	push	eax
	mov	eax, edi
	lea	ecx, DWORD PTR [esi+esi*2]
	add	ecx, ecx
	sub	eax, ecx
	mov	ecx, ebx
	push	eax
	push	esi
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN50@finalize

; 4134 :       break;
; 4135 :     else if (pval != params_4k[n])

	mov	eax, DWORD PTR _pval$[ebp]
	cmp	eax, DWORD PTR _params_4k$[ebp+edi*4]
	jne	SHORT $LN354@finalize

; 4131 :   bool existing_error = false;
; 4132 :   for (n=0; n < 12; n++)

	inc	edi
	cmp	edi, 12					; 0000000cH
	jl	SHORT $LL51@finalize

; 4134 :       break;
; 4135 :     else if (pval != params_4k[n])

	jmp	SHORT $LN50@finalize
$LN354@finalize:

; 4136 :       { existing_error = true; break; }

	mov	BYTE PTR _existing_error$1$[ebp], 1
$LN50@finalize:

; 4137 :   if ((n == 12) && poc->get(Porder,2,0,pval))

	cmp	edi, 12					; 0000000cH
	jne	SHORT $LN149@finalize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _pval$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	2
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN151@finalize
$LN149@finalize:

; 4138 :     existing_error = true;
; 4139 :   if (existing_error || ((n != 0) && (n != 12)))

	cmp	BYTE PTR _existing_error$1$[ebp], 0
	jne	SHORT $LN151@finalize
	test	edi, edi
	je	SHORT $LN462@finalize
	cmp	edi, 12					; 0000000cH
	je	SHORT $LN150@finalize
$LN151@finalize:

; 4140 :     { KDU_ERROR(e,0x11110832); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BAE@JMBBANBI@Profile?5violation?5detected?4?5?5You@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4140 :     { KDU_ERROR(e,0x11110832); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 21		; 00000015H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 4146 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN150@finalize:

; 4147 :   if (n == 0)

	test	edi, edi
	jne	SHORT $LN53@finalize
$LN462@finalize:

; 4148 :     for (n=0; n < 12; n++)

	xor	esi, esi
	npad	10
$LL54@finalize:

; 4149 :       poc->set(Porder,n/6,n%6,params_4k[n]);

	push	DWORD PTR _params_4k$[ebp+esi*4]
	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	eax, esi
	shr	edx, 2
	lea	ecx, DWORD PTR [edx+edx*2]
	add	ecx, ecx
	sub	eax, ecx
	mov	ecx, ebx
	push	eax
	push	edx
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	inc	esi
	cmp	esi, 12					; 0000000cH
	jl	SHORT $LL54@finalize
$LN53@finalize:

; 4150 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$0:
	lea	ecx, DWORD PTR _e$26[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$1:
	lea	ecx, DWORD PTR _e$25[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$3:
	lea	ecx, DWORD PTR _e$23[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$2:
	lea	ecx, DWORD PTR _e$24[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$4:
	lea	ecx, DWORD PTR _e$22[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$5:
	lea	ecx, DWORD PTR _e$21[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$6:
	lea	ecx, DWORD PTR _e$20[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$7:
	lea	ecx, DWORD PTR _e$19[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$8:
	lea	ecx, DWORD PTR _e$18[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$9:
	lea	ecx, DWORD PTR _e$17[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$10:
	lea	ecx, DWORD PTR _e$16[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$11:
	lea	ecx, DWORD PTR _e$15[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$12:
	lea	ecx, DWORD PTR _e$14[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$13:
	lea	ecx, DWORD PTR _e$13[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$14:
	lea	ecx, DWORD PTR _w$12[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$15:
	lea	ecx, DWORD PTR _e$11[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$16:
	lea	ecx, DWORD PTR _e$10[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$17:
	lea	ecx, DWORD PTR _e$9[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$18:
	lea	ecx, DWORD PTR _e$8[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$19:
	lea	ecx, DWORD PTR _e$7[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$20:
	lea	ecx, DWORD PTR _w$6[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?finalize@siz_params@@MAEX_N@Z$21:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?finalize@siz_params@@MAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-228]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?finalize@siz_params@@MAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?finalize@siz_params@@MAEX_N@Z ENDP			; siz_params::finalize
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?new_object@siz_params@@MAEPAVkdu_params@@XZ
_TEXT	SEGMENT
?new_object@siz_params@@MAEPAVkdu_params@@XZ PROC	; siz_params::new_object, COMDAT
; _this$ = ecx

; 2060 :     virtual kdu_params *new_object() { return NULL; }

	xor	eax, eax
	ret	0
?new_object@siz_params@@MAEPAVkdu_params@@XZ ENDP	; siz_params::new_object
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0siz_params@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0siz_params@@QAE@XZ PROC				; siz_params::siz_params, COMDAT
; _this$ = ecx

; 2995 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0siz_params@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 2994 :   : kdu_params(SIZ_params,false,false,false)

	push	0
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	call	??0kdu_params@@QAE@PBD_N1111@Z		; kdu_params::kdu_params

; 2996 :   define_attribute(Sprofile,

	push	0
	push	OFFSET ??_C@_0EB@MCBBIPAI@?$CIPROFILE0?$DN0?0PROFILE1?$DN1?0PROFILE2?$DN@
	push	OFFSET ??_C@_0GIB@OAPGMEGC@Restricted?5profile?5to?5which?5the?5@
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7siz_params@@6B@
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 2997 :           "Restricted profile to which the code-stream conforms.  The "
; 2998 :           "value must be an integer in the range 0 to 5, corresponding "
; 2999 :           "to the identifiers `PROFILE0', `PROFILE1', `PROFILE2', "
; 3000 :           "`PART2', `CINEMA2K' and `CINEMA4K'.  PROFILE0 is the most "
; 3001 :           "restrictive profile for Part 1 conforming codestreams.  PROFILE2 "
; 3002 :           "places no restrictions on the code-stream other than those "
; 3003 :           "restrictions defined in ISO/IEC 15444-1 (JPEG2000, Part 1).  A "
; 3004 :           "value of 3 (`PART2') means that the codestream requires support "
; 3005 :           "for one or more features defined in ISO/IEC 15444-2 (JPEG2000, "
; 3006 :           "Part 2).  If the system determines that support for Part 2 "
; 3007 :           "features is  required, the profile will be set automatically to "
; 3008 :           "3.  Otherwise, the profile is not adjusted by Kakadu's codestream "
; 3009 :           "creation machinery.  However, if the profile is found to be "
; 3010 :           "insufficient, the system will generate a warning at the point "
; 3011 :           "where it first encounters an inconsistency; this might not occur "
; 3012 :           "until near the end of the processing in certain rare "
; 3013 :           "circumstances.  The `CINEMA2K' (4) and `CINEMA4K' (5) profiles "
; 3014 :           "were added later via an ammendment to Part 1.  They are in fact "
; 3015 :           "highly restrictive subsets of the Part 1 standard, taylored for "
; 3016 :           "the needs of digital cinema projection equipment.  To be sure "
; 3017 :           "that you generate code-stream compatible with one of the digital "
; 3018 :           "cinema profiles, you should use the \"Creslengths\" attributes "
; 3019 :           "to explicitly constrain the compressed lengths of "
; 3020 :           "resolution/component subsets.  The actual constraints depend "
; 3021 :           "upon the intended frame-rate, as described in the standard.  "
; 3022 :           "Some suggestions are provided via a warning message if "
; 3023 :           "you fail to supply the `Creslengths' attribute yourself.\n"
; 3024 :           "\t\t[Defaults to Profile-2.]",
; 3025 :           "(PROFILE0=0,PROFILE1=1,PROFILE2=2,PART2=3,CINEMA2K=4,CINEMA4K=5)");
; 3026 :   define_attribute(Scap,

	push	0
	push	OFFSET ??_C@_01HMGJMAIH@B?$AA@
	push	OFFSET ??_C@_0ML@FCKJPFCA@Flag?5indicating?5whether?5or?5not?5c@
	push	OFFSET ??_C@_04JNHDNPF@Scap?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3027 :           "Flag indicating whether or not capabilities from "
; 3028 :           "additional parts (beyond parts 1 and 2) in the JPEG2000 "
; 3029 :           "family of standards are defined in a separate "
; 3030 :           "capabilities marker segment.\n"
; 3031 :           "\t\t[Defaults to false.]",
; 3032 :           "B");
; 3033 :   define_attribute(Sextensions,

	push	0
	push	OFFSET ??_C@_0GI@IJELGHMP@?$FLDC?$DN1?$HMVARQ?$DN2?$HMTCQ?$DN4?$HMPRECQ?$DN2048?$HMVI@
	push	OFFSET ??_C@_0DFB@NHCICMJL@Logical?5OR?5of?5any?5combination?5of@
	push	OFFSET ??_C@_0M@NJJFAENN@Sextensions?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3034 :           "Logical OR of any combination of a number of flags, "
; 3035 :           "indicating extended features from Part 2 of the JPEG2000 "
; 3036 :           "standard which may be found in this codestream.  Note "
; 3037 :           "that the Kakadu codestream generation machinery will "
; 3038 :           "set these flags automatically based on features which "
; 3039 :           "are detected in other parameter objects.  Explanation: "
; 3040 :           "DC means arbitrary DC offset; VARQ means variable "
; 3041 :           "quantization; TCQ means trellis-coded quantization; "
; 3042 :           "PRECQ means precinct-dependent quantization; "
; 3043 :           "VIS means visual masking; SSO means single-sample-overlap "
; 3044 :           "transform; DECOMP means arbitrary decomposition styles; "
; 3045 :           "ANY_KNL means arbitrary transform kernels; "
; 3046 :           "SYM_KNL means arbitrary whole sample symmetric transform "
; 3047 :           "kernels; MCT means multi-component transform; "
; 3048 :           "CURVE means arbitrary point-transformation; and "
; 3049 :           "ROI means extended region-of-interest signalling.\n"
; 3050 :           "\t\t[Defaults to 0.]",
; 3051 :           "[DC=1|VARQ=2|TCQ=4|PRECQ=2048|VIS=8|SSO=16|DECOMP=32"
; 3052 :           "|ANY_KNL=64|SYM_KNL=128|MCT=256|CURVE=512|ROI=1024]");
; 3053 :   define_attribute(Ssize,

	push	0
	push	OFFSET ??_C@_02FOEOGEOO@II?$AA@
	push	OFFSET ??_C@_0BDP@GFLEIBAO@Canvas?5dimensions?3?5vertical?5dime@
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3054 :           "Canvas dimensions: vertical dimension first.\n"
; 3055 :           "\t\t[For compressors, this will "
; 3056 :           "normally be derived from the dimensions of the individual "
; 3057 :           "image components. Explicitly supplying the canvas "
; 3058 :           "dimensions may be desirable if the source image files "
; 3059 :           "do not indicate their dimensions, or if custom "
; 3060 :           "sub-sampling factors are desired.]",
; 3061 :           "II");
; 3062 :   define_attribute(Sorigin,

	push	0
	push	OFFSET ??_C@_02FOEOGEOO@II?$AA@
	push	OFFSET ??_C@_0GN@LGNONLIP@Image?5origin?5on?5canvas?3?5vertical@
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3063 :           "Image origin on canvas: vertical coordinate first.\n"
; 3064 :           "\t\t[Defaults to {0,0}, or the tile origin if one "
; 3065 :           "is given]",
; 3066 :           "II");
; 3067 :   define_attribute(Stiles,

	push	0
	push	OFFSET ??_C@_02FOEOGEOO@II?$AA@
	push	OFFSET ??_C@_0EF@BCOJOGJB@Tile?5partition?5size?3?5vertical?5di@
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3068 :           "Tile partition size: vertical dimension first.\n"
; 3069 :           "\t\t[Defaults to {0,0}]",
; 3070 :           "II");
; 3071 :   define_attribute(Stile_origin,

	push	0
	push	OFFSET ??_C@_02FOEOGEOO@II?$AA@
	push	OFFSET ??_C@_0EM@GFLJDJGF@Tile?5origin?5on?5the?5canvas?3?5verti@
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3072 :           "Tile origin on the canvas: vertical coordinate first.\n"
; 3073 :           "\t\t[Defaults to {0,0}]",
; 3074 :           "II");
; 3075 :   define_attribute(Scomponents,

	push	0
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0CDM@NAGNLIBN@Number?5of?5codestream?5image?5compo@
	push	OFFSET ??_C@_0M@LFKICJFJ@Scomponents?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3076 :           "Number of codestream image components.\n"
; 3077 :           "\t\t[For compressors, this will normally be deduced from the "
; 3078 :           "number and type of image files supplied to the compressor.  Note "
; 3079 :           "carefully, however, that if a multi-component transform is used, "
; 3080 :           "the number of codestream image components might not be equal to "
; 3081 :           "the number of `output image components' given by `Mcomponents'.  "
; 3082 :           "In this case, the value of `Mcomponents' and the corresponding "
; 3083 :           "`Mprecision' and `Msigned' attributes should generally be "
; 3084 :           "associated with the image files being read (for compression) or "
; 3085 :           "written (for decompression).]",
; 3086 :           "I");
; 3087 :   define_attribute(Ssigned,

	push	3
	push	OFFSET ??_C@_01HMGJMAIH@B?$AA@
	push	OFFSET ??_C@_0DAJ@MODEBBAE@Indicates?5whether?5each?5codestrea@
	push	OFFSET ??_C@_07MGJMMJC@Ssigned?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3088 :           "Indicates whether each codestream image component contains "
; 3089 :           "signed or unsigned sample values.\n"
; 3090 :           "\t\t[For compressors, this will normally be deduced from the "
; 3091 :           "image files supplied to the compressor, but may be explicitly set "
; 3092 :           "if raw input files are to be used.  Also, if you happen to be "
; 3093 :           "using the Part-2 multi-component transform capabilities, the "
; 3094 :           "signed/unsigned attributes of the original image components "
; 3095 :           "should be expressed by `Msigned'; in this case, you will need "
; 3096 :           "to explicitly set `Ssigned' in a manner which reflects the "
; 3097 :           "signed/unsigned characteristics of the codestream image components "
; 3098 :           "produced after subjecting the original components to the forward "
; 3099 :           "multi-component transform.  Note that the last supplied identifier "
; 3100 :           "is repeated indefinitely for all remaining components.]",
; 3101 :           "B",MULTI_RECORD | CAN_EXTRAPOLATE);
; 3102 :   define_attribute(Sprecision,

	push	3
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0CLK@EPFPBPLL@Indicates?5the?5bit?9depth?5of?5each?5@
	push	OFFSET ??_C@_0L@BADPNFGK@Sprecision?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3103 :           "Indicates the bit-depth of each codestream image component.\n"
; 3104 :           "\t\t[For compressors, this will normally be deduced from the "
; 3105 :           "image files supplied to the compressor, but may need to be "
; 3106 :           "explicitly set if raw input files are to be used.  Also, if you "
; 3107 :           "happen to be using the Part-2 multi-component transform "
; 3108 :           "capabilities, the precision of the original image components "
; 3109 :           "should be expressed by `Mprecision'; in this case, you will need "
; 3110 :           "to explicitly set `Sprecision' to reflect the bit-depth "
; 3111 :           "of the codestream image components produced after subjecting "
; 3112 :           "the original components to the forward multi-component transform.  "
; 3113 :           "Note that the last supplied value is repeated indefinitely for "
; 3114 :           "all remaining components.]",
; 3115 :           "I",MULTI_RECORD | CAN_EXTRAPOLATE);
; 3116 :   define_attribute(Ssampling,

	push	3
	push	OFFSET ??_C@_02FOEOGEOO@II?$AA@
	push	OFFSET ??_C@_0BIA@NFIIFPMP@Indicates?5the?5sub?9sampling?5facto@
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3117 :           "Indicates the sub-sampling factors for each codestream image "
; 3118 :           "component. In each record, the vertical factor appears "
; 3119 :           "first, followed by the horizontal sub-sampling factor. "
; 3120 :           "The last supplied record is repeated indefinitely for "
; 3121 :           "all remaining components.\n"
; 3122 :           "\t\t[For compressors, a suitable set of sub-sampling "
; 3123 :           "factors will normally be deduced from the individual "
; 3124 :           "image component dimensions.]",
; 3125 :           "II",MULTI_RECORD | CAN_EXTRAPOLATE);
; 3126 :   define_attribute(Sdims,

	push	3
	push	OFFSET ??_C@_02FOEOGEOO@II?$AA@
	push	OFFSET ??_C@_0BGE@DJOJEOK@Indicates?5the?5dimensions?5?$CIvertic@
	push	OFFSET ??_C@_05KKKGDPEH@Sdims?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3127 :           "Indicates the dimensions (vertical, then horizontal) of "
; 3128 :           "each individual image component. The last supplied "
; 3129 :           "record is repeated indefinitely for all remaining "
; 3130 :           "components.\n"
; 3131 :           "\t\t[For compressors, the image component dimensions will "
; 3132 :           "normally be deduced from the image files supplied to the "
; 3133 :           "compressor, but may be explicitly set if raw input "
; 3134 :           "files are to be used.]",
; 3135 :           "II",MULTI_RECORD | CAN_EXTRAPOLATE);
; 3136 :   define_attribute(Mcomponents,

	push	0
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0FFB@NCBJOMEF@Number?5of?5image?5components?5produ@
	push	OFFSET ??_C@_0M@FAIBBHLL@Mcomponents?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3137 :           "Number of image components produced at the output of the inverse "
; 3138 :           "multi-component transform -- during compression, you may think of "
; 3139 :           "these as original image comonents.  In any event, we refer to "
; 3140 :           "them as \"MCT output components\", taking the perspective of "
; 3141 :           "the decompressor.  The value of `Mcomponents' may be smaller than "
; 3142 :           "or larger than the `Scomponents' value, which refers to the number "
; 3143 :           "of \"codestream image components\".  The codestream image "
; 3144 :           "components are supplied to the input of the inverse "
; 3145 :           "multi-component transform.  Note carefully, however, that "
; 3146 :           "for Kakadu to perform a forward multi-component transform on image "
; 3147 :           "data supplied to a compressor, the value of `Mcomponents' must be "
; 3148 :           "at least as large as `Scomponents' and the inverse multi-component "
; 3149 :           "transform must provide sufficient invertible transform blocks "
; 3150 :           "to derive the codestream components from the output image "
; 3151 :           "components.  In the special case where `Mcomponents' is 0, or not "
; 3152 :           "specified, there is no multi-component transform.  In this case, "
; 3153 :           "`Scomponents', `Ssigned' and `Sprecision' define the output image "
; 3154 :           "components."
; 3155 :           "\t\t[Defaults to 0.  You must explicitly set a non-zero value for "
; 3156 :           "this attribute if you want to use Part-2 multi-component "
; 3157 :           "transforms.  Compressors might be able to deduce this information "
; 3158 :           "from the input files, if they are aware that you want to perform "
; 3159 :           "a multi-component transform.]",
; 3160 :           "I");
; 3161 :   define_attribute(Msigned,

	push	3
	push	OFFSET ??_C@_01HMGJMAIH@B?$AA@
	push	OFFSET ??_C@_0BHF@DJPMMPEM@Indicates?5whether?5each?5MCT?5outpu@
	push	OFFSET ??_C@_07GFFIOPIL@Msigned?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3162 :           "Indicates whether each MCT output component (see `Mcomponents' for "
; 3163 :           "a definition of \"MCT output components\") contains signed "
; 3164 :           "or unsigned sample values.  If fewer than `Mcomponents' values are "
; 3165 :           "provided, the last supplied identifier is repeated indefinitely for "
; 3166 :           "all remaining components.\n"
; 3167 :           "\t\t[Compressors might be able to deduce this information from "
; 3168 :           "the image files supplied.]",
; 3169 :           "B",MULTI_RECORD | CAN_EXTRAPOLATE);
; 3170 :   define_attribute(Mprecision,

	push	3
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	push	OFFSET ??_C@_0BFE@NNIAEAJM@Indicates?5the?5bit?9depth?5of?5each?5@
	push	OFFSET ??_C@_0L@OMLPDKKH@Mprecision?$AA@
	mov	ecx, esi
	call	?define_attribute@kdu_params@@IAEXPBD00H@Z ; kdu_params::define_attribute

; 3171 :           "Indicates the bit-depth of each MCT output component (see "
; 3172 :           "`Mcomponents' for a definition of \"MCT output components\").  "
; 3173 :           "If fewer than `Mcomponents' values are provided, the last supplied "
; 3174 :           "identifier is repeated indefinitely for all remaining components.\n"
; 3175 :           "\t\t[Compressors might be able to deduce this information from "
; 3176 :           "the image files supplied.]",
; 3177 :           "I",MULTI_RECORD | CAN_EXTRAPOLATE);
; 3178 : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0siz_params@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
__ehhandler$??0siz_params@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0siz_params@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0siz_params@@QAE@XZ ENDP				; siz_params::siz_params
; Function compile flags: /Ogtp
;	COMDAT ??_Ekdu_params@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekdu_params@@UAEPAXI@Z PROC				; kdu_params::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekdu_params@@UAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kdu_params@@UAE@XZ		; kdu_params::~kdu_params
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	88					; 00000058H
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	imul	ecx, DWORD PTR [edi], 88
	add	ecx, 4
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
	test	bl, 1
	je	SHORT $LN4@vector
	push	88					; 00000058H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Ekdu_params@@UAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekdu_params@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekdu_params@@UAEPAXI@Z ENDP				; kdu_params::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?finalize_all@kdu_params@@QAEXH_N@Z
_TEXT	SEGMENT
_which_tile$ = 8					; size = 4
_after_reading$ = 12					; size = 1
?finalize_all@kdu_params@@QAEXH_N@Z PROC		; kdu_params::finalize_all, COMDAT
; _this$ = ecx

; 2931 : {

	push	ebp
	mov	ebp, esp

; 2932 :   kdu_params *scan;
; 2933 : 
; 2934 :   if (tile_idx == which_tile)

	mov	edx, DWORD PTR _which_tile$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _after_reading$[ebp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, edx
	jne	$LN11@finalize_a

; 2935 :     {
; 2936 :       finalize(after_reading);

	mov	eax, DWORD PTR [esi]
	push	edi
	push	ebx
	call	DWORD PTR [eax+32]

; 2937 :       if (this == first_inst)

	cmp	esi, DWORD PTR [esi+52]
	jne	SHORT $LN3@finalize_a

; 2938 :         for (scan=next_inst; scan != NULL; scan=scan->next_inst)

	mov	edi, DWORD PTR [esi+56]
	test	edi, edi
	je	SHORT $LN3@finalize_a
	npad	5
$LL4@finalize_a:

; 2939 :           scan->finalize(after_reading);

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	ebx
	call	DWORD PTR [eax+32]
	mov	edi, DWORD PTR [edi+56]
	test	edi, edi
	jne	SHORT $LL4@finalize_a
$LN3@finalize_a:

; 2940 :       if (comp_idx < 0)

	cmp	DWORD PTR [esi+12], 0
	jge	SHORT $LN33@finalize_a

; 2941 :         {
; 2942 :           for (int c=0; c < num_comps; c++)

	mov	eax, DWORD PTR [esi+24]
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN33@finalize_a
	npad	2
$LL7@finalize_a:

; 2943 :             {
; 2944 :               scan = refs[(tile_idx+1)*(num_comps+1)+c+1];

	mov	edx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+1]
	lea	eax, DWORD PTR [edx+1]
	imul	ecx, eax
	mov	eax, DWORD PTR [esi+44]
	add	ecx, edi
	mov	ecx, DWORD PTR [eax+ecx*4+4]

; 2945 :               if ((scan->comp_idx == c) && (scan->tile_idx == tile_idx))

	cmp	DWORD PTR [ecx+12], edi
	jne	SHORT $LN5@finalize_a
	cmp	DWORD PTR [ecx+8], edx
	jne	SHORT $LN5@finalize_a

; 2946 :                 scan->finalize_all(after_reading);

	push	ebx
	call	?finalize_all@kdu_params@@QAEX_N@Z	; kdu_params::finalize_all
$LN5@finalize_a:

; 2941 :         {
; 2942 :           for (int c=0; c < num_comps; c++)

	mov	eax, DWORD PTR [esi+24]
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL7@finalize_a
$LN33@finalize_a:
	pop	edi
$LN35@finalize_a:
	mov	edx, DWORD PTR _which_tile$[ebp]
$LN17@finalize_a:

; 2955 :     }
; 2956 : 
; 2957 :   if (this == first_cluster)

	cmp	esi, DWORD PTR [esi+36]
	jne	SHORT $LN9@finalize_a

; 2958 :     for (scan=next_cluster; scan != NULL; scan=scan->next_cluster)

	mov	esi, DWORD PTR [esi+40]
	test	esi, esi
	je	SHORT $LN9@finalize_a
	npad	3
$LL10@finalize_a:

; 2959 :       scan->finalize_all(which_tile,after_reading);

	push	ebx
	push	edx
	mov	ecx, esi
	call	?finalize_all@kdu_params@@QAEXH_N@Z	; kdu_params::finalize_all
	mov	esi, DWORD PTR [esi+40]
	mov	edx, DWORD PTR _which_tile$[ebp]
	test	esi, esi
	jne	SHORT $LL10@finalize_a
$LN9@finalize_a:
	pop	esi
	pop	ebx

; 2960 : }

	pop	ebp
	ret	8
$LN11@finalize_a:

; 2947 :             }
; 2948 :         }
; 2949 :     }
; 2950 :   else if ((tile_idx < 0) && (comp_idx < 0) && (which_tile < num_tiles))

	test	eax, eax
	jns	SHORT $LN17@finalize_a
	cmp	DWORD PTR [esi+12], 0
	jge	SHORT $LN17@finalize_a
	cmp	edx, DWORD PTR [esi+20]
	jge	SHORT $LN17@finalize_a

; 2951 :     {
; 2952 :       scan = refs[(which_tile+1)*(num_comps+1)];

	mov	ecx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [edx+1]
	inc	ecx
	imul	ecx, eax
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [eax+ecx*4]

; 2953 :       if ((scan != NULL) && (scan->tile_idx == which_tile))

	test	ecx, ecx
	je	SHORT $LN17@finalize_a
	cmp	DWORD PTR [ecx+8], edx
	jne	SHORT $LN17@finalize_a

; 2954 :         scan->finalize_all(after_reading);

	push	ebx
	call	?finalize_all@kdu_params@@QAEX_N@Z	; kdu_params::finalize_all
	jmp	SHORT $LN35@finalize_a
?finalize_all@kdu_params@@QAEXH_N@Z ENDP		; kdu_params::finalize_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?finalize_all@kdu_params@@QAEX_N@Z
_TEXT	SEGMENT
_after_reading$ = 8					; size = 1
?finalize_all@kdu_params@@QAEX_N@Z PROC			; kdu_params::finalize_all, COMDAT
; _this$ = ecx

; 2890 : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 2891 :   kdu_params *scan;
; 2892 : 
; 2893 :   finalize(after_reading);

	mov	ebx, DWORD PTR _after_reading$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	push	ebx
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+32]

; 2894 : 
; 2895 :   if (this == first_inst)

	cmp	esi, DWORD PTR [esi+52]
	jne	SHORT $LN3@finalize_a

; 2896 :     for (scan=next_inst; scan != NULL; scan=scan->next_inst)

	mov	edi, DWORD PTR [esi+56]
	test	edi, edi
	je	SHORT $LN3@finalize_a
	npad	3
$LL4@finalize_a:

; 2897 :       scan->finalize(after_reading);

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	ebx
	call	DWORD PTR [eax+32]
	mov	edi, DWORD PTR [edi+56]
	test	edi, edi
	jne	SHORT $LL4@finalize_a
$LN3@finalize_a:

; 2898 : 
; 2899 :   if (comp_idx >= 0)

	cmp	DWORD PTR [esi+12], 0
	jge	$LN12@finalize_a

; 2900 :     return; // Not a tile head
; 2901 : 
; 2902 :   // Must be at least a tile head; finalize all components in the tile
; 2903 :   for (int c=0; c < num_comps; c++)

	mov	eax, DWORD PTR [esi+24]
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN6@finalize_a
$LL7@finalize_a:

; 2904 :     {
; 2905 :       scan = refs[(tile_idx+1)*(num_comps+1)+c+1];

	mov	edx, DWORD PTR [esi+8]
	inc	eax
	lea	ecx, DWORD PTR [edx+1]
	imul	ecx, eax
	mov	eax, DWORD PTR [esi+44]
	add	ecx, edi
	mov	ecx, DWORD PTR [eax+ecx*4+4]

; 2906 :       if ((scan->comp_idx == c) && (scan->tile_idx == tile_idx))

	cmp	DWORD PTR [ecx+12], edi
	jne	SHORT $LN5@finalize_a
	cmp	DWORD PTR [ecx+8], edx
	jne	SHORT $LN5@finalize_a

; 2907 :         scan->finalize_all(after_reading);

	push	ebx
	call	?finalize_all@kdu_params@@QAEX_N@Z	; kdu_params::finalize_all
$LN5@finalize_a:

; 2900 :     return; // Not a tile head
; 2901 : 
; 2902 :   // Must be at least a tile head; finalize all components in the tile
; 2903 :   for (int c=0; c < num_comps; c++)

	mov	eax, DWORD PTR [esi+24]
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL7@finalize_a
$LN6@finalize_a:

; 2908 :     }
; 2909 : 
; 2910 :   if (tile_idx < 0)

	cmp	DWORD PTR [esi+8], 0
	jge	SHORT $LN9@finalize_a

; 2911 :     { // Finalize all tiles in the cluster
; 2912 :       for (int t=0; t < num_tiles; t++)

	xor	edx, edx
	cmp	DWORD PTR [esi+20], edx
	jle	SHORT $LN9@finalize_a
	npad	6
$LL10@finalize_a:

; 2913 :         {
; 2914 :           scan = refs[(t+1)*(num_comps+1)];

	mov	ecx, DWORD PTR [esi+24]
	lea	edi, DWORD PTR [edx+1]
	mov	eax, DWORD PTR [esi+44]
	inc	ecx
	imul	ecx, edi
	mov	ecx, DWORD PTR [eax+ecx*4]

; 2915 :           if (scan->tile_idx == t)

	cmp	DWORD PTR [ecx+8], edx
	jne	SHORT $LN8@finalize_a

; 2916 :             scan->finalize_all(after_reading);

	push	ebx
	call	?finalize_all@kdu_params@@QAEX_N@Z	; kdu_params::finalize_all
$LN8@finalize_a:

; 2911 :     { // Finalize all tiles in the cluster
; 2912 :       for (int t=0; t < num_tiles; t++)

	mov	edx, edi
	cmp	edx, DWORD PTR [esi+20]
	jl	SHORT $LL10@finalize_a
$LN9@finalize_a:

; 2917 :         }
; 2918 :     }
; 2919 : 
; 2920 :   if (this == first_cluster)

	cmp	esi, DWORD PTR [esi+36]
	jne	SHORT $LN12@finalize_a

; 2921 :     for (scan=next_cluster; scan != NULL; scan=scan->next_cluster)

	mov	esi, DWORD PTR [esi+40]
	test	esi, esi
	je	SHORT $LN12@finalize_a
	npad	2
$LL13@finalize_a:

; 2922 :       scan->finalize_all(after_reading);

	push	ebx
	mov	ecx, esi
	call	?finalize_all@kdu_params@@QAEX_N@Z	; kdu_params::finalize_all
	mov	esi, DWORD PTR [esi+40]
	test	esi, esi
	jne	SHORT $LL13@finalize_a
$LN12@finalize_a:
	pop	edi
	pop	esi
	pop	ebx

; 2923 : }

	pop	ebp
	ret	4
?finalize_all@kdu_params@@QAEX_N@Z ENDP			; kdu_params::finalize_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?finalize@kdu_params@@UAEX_N@Z
_TEXT	SEGMENT
_after_reading$ = 8					; size = 1
?finalize@kdu_params@@UAEX_N@Z PROC			; kdu_params::finalize, COMDAT
; _this$ = ecx

; 1685 :     virtual void finalize(bool after_reading=false) {return; }

	ret	4
?finalize@kdu_params@@UAEX_N@Z ENDP			; kdu_params::finalize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z
_TEXT	SEGMENT
_output$ = 8						; size = 4
_name$ = 12						; size = 4
_field_idx$ = 16					; size = 4
_val$ = 20						; size = 4
?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z PROC ; kdu_params::custom_textualize_field, COMDAT
; _this$ = ecx

; 1664 :         { return; }

	ret	16					; 00000010H
?custom_textualize_field@kdu_params@@UAEXAAVkdu_message@@PBDHH@Z ENDP ; kdu_params::custom_textualize_field
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
_name$ = 12						; size = 4
_field_idx$ = 16					; size = 4
_val$ = 20						; size = 4
?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z PROC	; kdu_params::custom_parse_field, COMDAT
; _this$ = ecx

; 1637 :         { return 0; }

	xor	eax, eax
	ret	16					; 00000010H
?custom_parse_field@kdu_params@@UAEHPBD0HAAH@Z ENDP	; kdu_params::custom_parse_field
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z
_TEXT	SEGMENT
_e$2 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z PROC	; kdu_params::delete_unparsed_attribute, COMDAT
; _this$ = ecx

; 2694 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 2695 :   kd_attribute *ap;
; 2696 : 
; 2697 :   if ((ap=match_attribute(attributes,name)) == NULL)

	mov	ebx, DWORD PTR _name$[ebp]
	push	ebx
	push	DWORD PTR [esi+60]
	call	?match_attribute@@YAPAUkd_attribute@@PAU1@PBD@Z ; match_attribute
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $LN14@delete_unp

; 2698 :     { KDU_ERROR_DEV(e,60); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0FM@CALBKEL@Attempting?5to?5delete?5a?5non?9exist@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2698 :     { KDU_ERROR_DEV(e,60); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2701 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN14@delete_unp:

; 2702 :   if (!ap->parsed)

	cmp	BYTE PTR [edi+29], 0
	jne	SHORT $LN15@delete_unp

; 2703 :     {
; 2704 :       int num_fields = ap->num_records * ap->num_fields;

	mov	ecx, DWORD PTR [edi+16]
	imul	ecx, DWORD PTR [edi+20]

; 2705 :       if (num_fields && !changed)

	test	ecx, ecx
	je	SHORT $LN3@delete_unp
	cmp	BYTE PTR [esi+64], 0
	jne	SHORT $LN16@delete_unp

; 2706 :         {
; 2707 :           kdu_params *scan = this; scan->changed = true;
; 2708 :           scan = scan->first_inst; scan->changed = true;

	mov	eax, DWORD PTR [esi+52]
	mov	BYTE PTR [esi+64], 1
	mov	BYTE PTR [eax+64], 1

; 2709 :           scan = scan->refs[0]; scan->changed = true;

	mov	eax, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [eax]
	mov	BYTE PTR [eax+64], 1

; 2710 :           scan = scan->first_cluster; scan->changed = true;

	mov	eax, DWORD PTR [eax+36]
	mov	BYTE PTR [eax+64], 1
$LN16@delete_unp:

; 2711 :         }
; 2712 :       for (int n=0; n < num_fields; n++)

	test	ecx, ecx
	jle	SHORT $LN3@delete_unp
	xor	edx, edx
$LL4@delete_unp:

; 2713 :         ap->values[n].is_set = false;

	mov	eax, DWORD PTR [edi+24]
	lea	edx, DWORD PTR [edx+12]
	mov	BYTE PTR [eax+edx-4], 0
	sub	ecx, 1
	jne	SHORT $LL4@delete_unp
$LN3@delete_unp:

; 2714 :       ap->num_records = 0;

	mov	DWORD PTR [edi+20], 0
$LN15@delete_unp:

; 2715 :     }
; 2716 : 
; 2717 :   kdu_params *scan;
; 2718 :   if (this != first_inst)

	cmp	esi, DWORD PTR [esi+52]
	jne	$LN12@delete_unp

; 2719 :     return;
; 2720 : 
; 2721 :   for (scan=next_inst; scan != NULL; scan=scan->next_inst)

	mov	edi, DWORD PTR [esi+56]
	test	edi, edi
	je	SHORT $LN6@delete_unp
	npad	5
$LL7@delete_unp:

; 2722 :     scan->delete_unparsed_attribute(name);

	push	ebx
	mov	ecx, edi
	call	?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z ; kdu_params::delete_unparsed_attribute
	mov	edi, DWORD PTR [edi+56]
	test	edi, edi
	jne	SHORT $LL7@delete_unp
$LN6@delete_unp:

; 2723 :   
; 2724 :   if (comp_idx >= 0)

	cmp	DWORD PTR [esi+12], 0
	jge	SHORT $LN12@delete_unp

; 2725 :     return;
; 2726 : 
; 2727 :   // Must be at least a tile head; scan all components in the tile
; 2728 :   int n;
; 2729 :   kdu_params **rp;
; 2730 :   for (rp=refs+(tile_idx+1)*(num_comps+1)+1, n=num_comps; n > 0; n--, rp++)

	mov	edi, DWORD PTR [esi+24]
	mov	ebx, DWORD PTR [esi+8]
	inc	ebx
	lea	eax, DWORD PTR [edi+1]
	imul	ebx, eax
	mov	eax, DWORD PTR [esi+44]
	add	eax, 4
	lea	ebx, DWORD PTR [eax+ebx*4]
	test	edi, edi
	jle	SHORT $LN9@delete_unp
	npad	1
$LL10@delete_unp:

; 2731 :     if (((scan = *rp) != NULL) && (scan != this))

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN8@delete_unp
	cmp	ecx, esi
	je	SHORT $LN8@delete_unp

; 2732 :       scan->delete_unparsed_attribute(name);

	push	DWORD PTR _name$[ebp]
	call	?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z ; kdu_params::delete_unparsed_attribute
$LN8@delete_unp:

; 2725 :     return;
; 2726 : 
; 2727 :   // Must be at least a tile head; scan all components in the tile
; 2728 :   int n;
; 2729 :   kdu_params **rp;
; 2730 :   for (rp=refs+(tile_idx+1)*(num_comps+1)+1, n=num_comps; n > 0; n--, rp++)

	dec	edi
	add	ebx, 4
	test	edi, edi
	jg	SHORT $LL10@delete_unp
$LN9@delete_unp:

; 2733 : 
; 2734 :   if (tile_idx < 0)

	cmp	DWORD PTR [esi+8], 0
	jge	SHORT $LN12@delete_unp

; 2735 :     { // Scan all tiles in the cluster
; 2736 :       for (rp=refs+(num_comps+1), n=num_tiles; n > 0; n--, rp+=(num_comps+1))

	mov	ebx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+44]
	inc	ebx
	mov	edi, DWORD PTR [esi+20]
	lea	ebx, DWORD PTR [eax+ebx*4]
	test	edi, edi
	jle	SHORT $LN12@delete_unp
$LL13@delete_unp:

; 2737 :         if (((scan = *rp) != NULL) && (scan != this))

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN11@delete_unp
	cmp	ecx, esi
	je	SHORT $LN11@delete_unp

; 2738 :           scan->delete_unparsed_attribute(name);

	push	DWORD PTR _name$[ebp]
	call	?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z ; kdu_params::delete_unparsed_attribute
$LN11@delete_unp:

; 2735 :     { // Scan all tiles in the cluster
; 2736 :       for (rp=refs+(num_comps+1), n=num_tiles; n > 0; n--, rp+=(num_comps+1))

	mov	eax, DWORD PTR [esi+24]
	dec	edi
	lea	ebx, DWORD PTR [ebx+eax*4]
	add	ebx, 4
	test	edi, edi
	jg	SHORT $LL13@delete_unp
$LN12@delete_unp:

; 2739 :     }
; 2740 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z ENDP	; kdu_params::delete_unparsed_attribute
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?find_string@kdu_params@@QAEPAV1@PADAAPBD@Z
_TEXT	SEGMENT
_target_comp$1$ = -8					; size = 4
_delim$ = -4						; size = 4
_string$ = 8						; size = 4
_name$ = 12						; size = 4
?find_string@kdu_params@@QAEPAV1@PADAAPBD@Z PROC	; kdu_params::find_string, COMDAT
; _this$ = ecx

; 2611 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx

; 2612 :   kd_attribute *ap;
; 2613 :   char *delim;
; 2614 :   size_t name_len;
; 2615 : 
; 2616 :   for (delim=string; *delim != '\0'; delim++)

	mov	ecx, DWORD PTR _string$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _delim$[ebp], esi
	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN3@find_strin
$LL4@find_strin:

; 2617 :     if ((*delim == ' ') || (*delim == '\t') || (*delim == '\n'))

	cmp	al, 32					; 00000020H
	je	SHORT $LN15@find_strin
	cmp	al, 9
	je	SHORT $LN15@find_strin
	cmp	al, 10					; 0000000aH
	je	SHORT $LN15@find_strin

; 2619 :     else if ((*delim == ':') || (*delim == '='))

	cmp	al, 58					; 0000003aH
	je	SHORT $LN3@find_strin
	cmp	al, 61					; 0000003dH
	je	SHORT $LN3@find_strin

; 2612 :   kd_attribute *ap;
; 2613 :   char *delim;
; 2614 :   size_t name_len;
; 2615 : 
; 2616 :   for (delim=string; *delim != '\0'; delim++)

	inc	esi
	mov	DWORD PTR _delim$[ebp], esi
	mov	al, BYTE PTR [esi]
	test	al, al
	jne	SHORT $LL4@find_strin
$LN3@find_strin:
	push	edi

; 2620 :       break;
; 2621 :   name_len = (size_t)(delim - string);
; 2622 :   for (ap=attributes; ap != NULL; ap=ap->next)

	mov	edi, DWORD PTR [ebx+60]
	sub	esi, ecx
$LN69@find_strin:
	test	edi, edi
	je	$LN63@find_strin

; 2623 :     if ((strncmp(ap->name,string,name_len)==0) && (strlen(ap->name)==name_len))

	push	esi
	push	ecx
	push	DWORD PTR [edi]
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@find_strin
	mov	ecx, DWORD PTR [edi]
	lea	edx, DWORD PTR [ecx+1]
	npad	6
$LL65@find_strin:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL65@find_strin
	sub	ecx, edx
	cmp	ecx, esi
	je	SHORT $LN19@find_strin
$LN5@find_strin:

; 2620 :       break;
; 2621 :   name_len = (size_t)(delim - string);
; 2622 :   for (ap=attributes; ap != NULL; ap=ap->next)

	mov	edi, DWORD PTR [edi+32]
	mov	ecx, DWORD PTR _string$[ebp]
	jmp	SHORT $LN69@find_strin
$LN15@find_strin:
	pop	esi

; 2618 :       return NULL;

	xor	eax, eax
	pop	ebx

; 2684 :     }
; 2685 :   return this;
; 2686 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN19@find_strin:

; 2636 :     }
; 2637 :   assert(ap != NULL);
; 2638 :   name = ap->name;

	mov	ecx, DWORD PTR _name$[ebp]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax

; 2639 :   if (*delim == '\0')

	mov	ecx, DWORD PTR _delim$[ebp]
	mov	al, BYTE PTR [ecx]
	test	al, al
	je	$LN72@find_strin

; 2640 :     return this;
; 2641 : 
; 2642 :   int target_tile = -2;

	mov	edi, -2					; fffffffeH

; 2643 :   int target_comp = -2;
; 2644 :   int target_inst = -1;

	or	esi, -1
	mov	edx, edi
	mov	DWORD PTR _target_comp$1$[ebp], edx

; 2645 : 
; 2646 :   if (*delim == ':')

	cmp	al, 58					; 0000003aH
	jne	$LN64@find_strin

; 2647 :     {
; 2648 :       delim++;

	inc	ecx
	mov	DWORD PTR _delim$[ebp], ecx

; 2649 :       while (*delim != '=')

	mov	al, BYTE PTR [ecx]
	cmp	al, 61					; 0000003dH
	je	SHORT $LN64@find_strin
$LL11@find_strin:

; 2650 :         if (*delim == '\0')

	test	al, al
	je	SHORT $LN12@find_strin

; 2651 :           break;
; 2652 :         else if ((*delim == 'T') && (target_tile < -1))

	cmp	al, 84					; 00000054H
	jne	SHORT $LN26@find_strin
	cmp	edi, -1
	jge	SHORT $LN26@find_strin

; 2653 :           target_tile = (int) strtol(delim+1,&delim,10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _delim$[ebp]
	push	eax
	lea	eax, DWORD PTR [ecx+1]
	push	eax
	call	DWORD PTR __imp__strtol
	mov	edi, eax
	jmp	SHORT $LN70@find_strin
$LN26@find_strin:

; 2654 :         else if ((*delim == 'C') && (target_comp < -1))

	cmp	al, 67					; 00000043H
	jne	SHORT $LN28@find_strin
	cmp	edx, -1
	jge	SHORT $LN28@find_strin

; 2655 :           target_comp = (int) strtol(delim+1,&delim,10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _delim$[ebp]
	push	eax
	lea	eax, DWORD PTR [ecx+1]
	push	eax
	call	DWORD PTR __imp__strtol
	mov	edx, eax
	mov	DWORD PTR _target_comp$1$[ebp], edx
	jmp	SHORT $LN71@find_strin
$LN28@find_strin:

; 2656 :         else if ((*delim == 'I') && (target_inst < 0))

	cmp	al, 73					; 00000049H
	jne	$LN9@find_strin
	test	esi, esi
	jns	$LN9@find_strin

; 2657 :           target_inst = (int) strtol(delim+1,&delim,10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _delim$[ebp]
	push	eax
	lea	eax, DWORD PTR [ecx+1]
	push	eax
	call	DWORD PTR __imp__strtol
	mov	esi, eax
$LN70@find_strin:
	mov	edx, DWORD PTR _target_comp$1$[ebp]
$LN71@find_strin:

; 2649 :       while (*delim != '=')

	mov	ecx, DWORD PTR _delim$[ebp]

; 2657 :           target_inst = (int) strtol(delim+1,&delim,10);

	add	esp, 12					; 0000000cH
	mov	al, BYTE PTR [ecx]
	cmp	al, 61					; 0000003dH
	jne	SHORT $LL11@find_strin
$LN12@find_strin:

; 2658 :         else
; 2659 :           return NULL;
; 2660 :     }
; 2661 :   if (target_tile < -1)

	cmp	edi, -1
	jge	SHORT $LN32@find_strin
$LN64@find_strin:

; 2662 :     target_tile = this->tile_idx;

	mov	edi, DWORD PTR [ebx+8]
$LN32@find_strin:

; 2663 :   if (target_comp < -1)

	cmp	edx, -1
	jge	SHORT $LN33@find_strin

; 2664 :     target_comp = this->comp_idx;

	mov	edx, DWORD PTR [ebx+12]
$LN33@find_strin:

; 2665 :   if (target_inst < 0)

	test	esi, esi
	jns	SHORT $LN38@find_strin

; 2666 :     {
; 2667 :       if ((target_tile == this->tile_idx) && (target_comp == this->comp_idx))

	cmp	edi, DWORD PTR [ebx+8]
	jne	SHORT $LN35@find_strin
	cmp	edx, DWORD PTR [ebx+12]
	jne	SHORT $LN35@find_strin

; 2668 :         target_inst = this->inst_idx;

	mov	esi, DWORD PTR [ebx+16]
	jmp	SHORT $LN38@find_strin
$LN35@find_strin:

; 2669 :       else if (!treat_instances_like_components)

	cmp	BYTE PTR [ebx+34], 0
	jne	SHORT $LN9@find_strin

; 2670 :         target_inst = 0;

	xor	esi, esi
$LN38@find_strin:

; 2671 :       else
; 2672 :         return NULL;
; 2673 :     }
; 2674 : 
; 2675 :   // Locate the object to which the attribute belongs.
; 2676 :   if ((this->tile_idx != target_tile) || (this->comp_idx != target_comp) ||

	cmp	DWORD PTR [ebx+8], edi
	jne	SHORT $LN40@find_strin
	cmp	DWORD PTR [ebx+12], edx
	jne	SHORT $LN40@find_strin
	cmp	DWORD PTR [ebx+16], esi
	je	SHORT $LN72@find_strin
$LN40@find_strin:

; 2677 :       (this->inst_idx != target_inst))
; 2678 :     {
; 2679 :       kdu_params *target;
; 2680 :       target = access_relation(target_tile,target_comp,target_inst,false);

	push	0
	push	esi
	push	edx
	push	edi
	mov	ecx, ebx
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 2681 :       if (target == NULL)

	test	eax, eax
	jne	SHORT $LN41@find_strin
$LN72@find_strin:
	pop	edi
	pop	esi

; 2682 :         return this;

	mov	eax, ebx
	pop	ebx

; 2684 :     }
; 2685 :   return this;
; 2686 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN41@find_strin:

; 2683 :       return target->find_string(string,name);

	push	DWORD PTR _name$[ebp]
	mov	ecx, eax
	push	DWORD PTR _string$[ebp]
	call	?find_string@kdu_params@@QAEPAV1@PADAAPBD@Z ; kdu_params::find_string
	pop	edi
	pop	esi
	pop	ebx

; 2684 :     }
; 2685 :   return this;
; 2686 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN63@find_strin:

; 2624 :       break;
; 2625 :   if (ap == NULL)
; 2626 :     {
; 2627 :       if (this == first_cluster)

	cmp	ebx, DWORD PTR [ebx+36]
	jne	SHORT $LN9@find_strin

; 2628 :         {
; 2629 :           kdu_params *scan, *result;
; 2630 : 
; 2631 :           for (scan=this->next_cluster; scan != NULL; scan=scan->next_cluster)

	mov	esi, DWORD PTR [ebx+40]
	test	esi, esi
	je	SHORT $LN9@find_strin
	mov	edi, DWORD PTR _name$[ebp]
	npad	2
$LL10@find_strin:

; 2632 :             if ((result = scan->find_string(string,name)) != NULL)

	push	edi
	push	ecx
	mov	ecx, esi
	call	?find_string@kdu_params@@QAEPAV1@PADAAPBD@Z ; kdu_params::find_string
	test	eax, eax
	jne	SHORT $LN67@find_strin

; 2628 :         {
; 2629 :           kdu_params *scan, *result;
; 2630 : 
; 2631 :           for (scan=this->next_cluster; scan != NULL; scan=scan->next_cluster)

	mov	esi, DWORD PTR [esi+40]
	mov	ecx, DWORD PTR _string$[ebp]
	test	esi, esi
	jne	SHORT $LL10@find_strin
$LN9@find_strin:

; 2633 :               return(result);
; 2634 :         }
; 2635 :       return NULL;

	xor	eax, eax
$LN67@find_strin:
	pop	edi
	pop	esi
	pop	ebx

; 2684 :     }
; 2685 :   return this;
; 2686 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?find_string@kdu_params@@QAEPAV1@PADAAPBD@Z ENDP	; kdu_params::find_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?describe_attribute@kdu_params@@QAEXPBDAAVkdu_message@@_N@Z
_TEXT	SEGMENT
_e$2 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_output$ = 12						; size = 4
_include_comments$ = 16					; size = 1
?describe_attribute@kdu_params@@QAEXPBDAAVkdu_message@@_N@Z PROC ; kdu_params::describe_attribute, COMDAT
; _this$ = ecx

; 2592 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?describe_attribute@kdu_params@@QAEXPBDAAVkdu_message@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 2593 :   kd_attribute *ap;
; 2594 : 
; 2595 :   if ((ap=match_attribute(attributes,name)) == NULL)

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [esi+60]
	call	?match_attribute@@YAPAUkd_attribute@@PAU1@PBD@Z ; match_attribute
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $LN2@describe_a

; 2596 :     { KDU_ERROR_DEV(e,59); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EO@MMDBDEFI@?$CCkdu_params?3?3describe_attribute?$CC@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2596 :     { KDU_ERROR_DEV(e,59); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	DWORD PTR _name$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2600 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@describe_a:

; 2601 :   ap->describe(output,allow_tiles,allow_comps,

	push	DWORD PTR _include_comments$[ebp]
	movzx	eax, BYTE PTR [esi+34]
	mov	ecx, edi
	push	eax
	movzx	eax, BYTE PTR [esi+31]
	push	eax
	movzx	eax, BYTE PTR [esi+30]
	push	eax
	push	DWORD PTR _output$[ebp]
	call	?describe@kd_attribute@@QAEXAAVkdu_message@@_N111@Z ; kd_attribute::describe

; 2602 :                treat_instances_like_components,include_comments);
; 2603 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?describe_attribute@kdu_params@@QAEXPBDAAVkdu_message@@_N@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?describe_attribute@kdu_params@@QAEXPBDAAVkdu_message@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?describe_attribute@kdu_params@@QAEXPBDAAVkdu_message@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?describe_attribute@kdu_params@@QAEXPBDAAVkdu_message@@_N@Z ENDP ; kdu_params::describe_attribute
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?describe_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z
_TEXT	SEGMENT
_output$ = 8						; size = 4
_include_comments$ = 12					; size = 1
?describe_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z PROC ; kdu_params::describe_attributes, COMDAT
; _this$ = ecx

; 2577 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx

; 2578 :   kd_attribute *ap;
; 2579 : 
; 2580 :   for (ap=attributes; ap != NULL; ap=ap->next)

	mov	esi, DWORD PTR [edi+60]
	test	esi, esi
	je	SHORT $LN3@describe_a
	push	ebx
	mov	ebx, DWORD PTR _output$[ebp]
$LL4@describe_a:

; 2581 :     ap->describe(output,allow_tiles,allow_comps,

	push	DWORD PTR _include_comments$[ebp]
	movzx	eax, BYTE PTR [edi+34]
	mov	ecx, esi
	push	eax
	movzx	eax, BYTE PTR [edi+31]
	push	eax
	movzx	eax, BYTE PTR [edi+30]
	push	eax
	push	ebx
	call	?describe@kd_attribute@@QAEXAAVkdu_message@@_N111@Z ; kd_attribute::describe
	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL4@describe_a
	pop	ebx
$LN3@describe_a:
	pop	edi
	pop	esi

; 2582 :                  treat_instances_like_components,include_comments);
; 2583 : }

	pop	ebp
	ret	8
?describe_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ENDP ; kdu_params::describe_attributes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@HH_N@Z
_TEXT	SEGMENT
_this$1$ = -24						; size = 4
_rpp$1$ = -20						; size = 4
_max_c$1$ = -16						; size = 4
_max_t$1$ = -12						; size = 4
_t$1$ = -8						; size = 4
_min_c$1$ = -4						; size = 4
_rp$1$ = 8						; size = 4
_output$ = 8						; size = 4
_min_tile$ = 12						; size = 4
_max_tile$ = 16						; size = 4
_skip_derived$ = 20					; size = 1
?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@HH_N@Z PROC ; kdu_params::textualize_attributes, COMDAT
; _this$ = ecx

; 2536 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2537 :   int min_t = (min_tile < -1)?-1:min_tile;

	mov	edx, DWORD PTR _min_tile$[ebp]
	push	ebx
	push	edi
	mov	edi, ecx
	or	ecx, -1
	cmp	edx, ecx
	mov	DWORD PTR _this$1$[ebp], edi
	cmovl	edx, ecx

; 2538 :   int max_t = (max_tile >= num_tiles)?(num_tiles-1):max_tile;

	mov	ecx, DWORD PTR _max_tile$[ebp]
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _t$1$[ebp], edx
	cmp	ecx, eax
	jl	SHORT $LN23@textualize
	lea	ebx, DWORD PTR [eax-1]
	mov	DWORD PTR _max_t$1$[ebp], ebx
	jmp	SHORT $LN24@textualize
$LN23@textualize:
	mov	ebx, ecx
	mov	DWORD PTR _max_t$1$[ebp], ecx
$LN24@textualize:

; 2539 :   if (tile_idx >= 0)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	js	SHORT $LN14@textualize

; 2540 :     { // One tile only
; 2541 :       if ((tile_idx < min_t) || (tile_idx > max_t))

	cmp	eax, edx
	jl	$LN12@textualize
	cmp	eax, ebx
	jg	$LN12@textualize

; 2542 :         return;
; 2543 :       min_t = max_t = tile_idx;

	mov	ebx, eax
	mov	DWORD PTR _max_t$1$[ebp], ebx
	mov	edx, ebx
	mov	DWORD PTR _t$1$[ebp], ebx
$LN14@textualize:

; 2544 :     }
; 2545 :   if (inst_idx != 0)

	cmp	DWORD PTR [edi+16], 0
	je	SHORT $LN17@textualize

; 2546 :     {
; 2547 :       textualize_attributes(output,skip_derived);

	push	DWORD PTR _skip_derived$[ebp]
	mov	ecx, edi
	push	DWORD PTR _output$[ebp]
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ; kdu_params::textualize_attributes
	pop	edi
	pop	ebx

; 2569 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN17@textualize:

; 2548 :       return;
; 2549 :     }
; 2550 :   int min_c = -1;
; 2551 :   int max_c = num_comps-1;

	mov	ecx, DWORD PTR [edi+24]

; 2552 :   if (comp_idx >= 0)

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR _min_c$1$[ebp], -1
	push	esi
	lea	esi, DWORD PTR [ecx-1]
	mov	DWORD PTR _max_c$1$[ebp], esi
	test	eax, eax
	js	SHORT $LN18@textualize

; 2553 :     min_c = max_c = comp_idx;

	mov	esi, eax
	mov	DWORD PTR _max_c$1$[ebp], eax
	mov	DWORD PTR _min_c$1$[ebp], esi
$LN18@textualize:

; 2554 : 
; 2555 :   int t, c;
; 2556 :   kdu_params *scan, **rp, **rpp = refs+(min_t+1)*(num_comps+1)+(min_c+1);

	inc	ecx
	lea	eax, DWORD PTR [edx+1]
	imul	ecx, eax
	mov	eax, DWORD PTR [edi+44]
	add	eax, 4
	add	ecx, DWORD PTR _min_c$1$[ebp]

; 2557 :   for (t=min_t; t <= max_t; t++, rpp+=num_comps+1)

	cmp	edx, ebx
	mov	ebx, DWORD PTR _output$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _skip_derived$[ebp]
	mov	DWORD PTR _rpp$1$[ebp], ecx
	jg	SHORT $LN3@textualize
	npad	2
$LL4@textualize:

; 2558 :     for (rp=rpp, c=min_c; c <= max_c; c++, rp++)

	mov	edi, DWORD PTR _min_c$1$[ebp]
	mov	DWORD PTR _rp$1$[ebp], ecx
	cmp	edi, esi
	jg	SHORT $LN2@textualize
	npad	6
$LL7@textualize:

; 2559 :       {
; 2560 :         scan = *rp;

	mov	esi, DWORD PTR [ecx]

; 2561 :         if ((scan->comp_idx != c)  || (scan->tile_idx != t))

	cmp	DWORD PTR [esi+12], edi
	jne	SHORT $LN5@textualize
	cmp	DWORD PTR [esi+8], edx
	jne	SHORT $LN5@textualize
	npad	4
$LL10@textualize:

; 2562 :           continue; // Whole object is not unique
; 2563 :         for (; scan != NULL; scan=scan->next_inst)
; 2564 :           scan->textualize_attributes(output,skip_derived);

	push	eax
	push	ebx
	mov	ecx, esi
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ; kdu_params::textualize_attributes
	mov	esi, DWORD PTR [esi+56]
	mov	eax, DWORD PTR _skip_derived$[ebp]
	test	esi, esi
	jne	SHORT $LL10@textualize
	mov	ecx, DWORD PTR _rp$1$[ebp]
	mov	edx, DWORD PTR _t$1$[ebp]
$LN5@textualize:

; 2558 :     for (rp=rpp, c=min_c; c <= max_c; c++, rp++)

	mov	esi, DWORD PTR _max_c$1$[ebp]
	inc	edi
	add	ecx, 4
	mov	DWORD PTR _rp$1$[ebp], ecx
	cmp	edi, esi
	jle	SHORT $LL7@textualize
$LN2@textualize:

; 2557 :   for (t=min_t; t <= max_t; t++, rpp+=num_comps+1)

	mov	edi, DWORD PTR _this$1$[ebp]
	inc	edx
	mov	ecx, DWORD PTR _rpp$1$[ebp]
	mov	DWORD PTR _t$1$[ebp], edx
	mov	eax, DWORD PTR [edi+24]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _skip_derived$[ebp]
	add	ecx, 4
	mov	DWORD PTR _rpp$1$[ebp], ecx
	cmp	edx, DWORD PTR _max_t$1$[ebp]
	jle	SHORT $LL4@textualize
$LN3@textualize:

; 2565 :       }
; 2566 :   if (this == first_cluster)

	cmp	edi, DWORD PTR [edi+36]
	jne	SHORT $LN41@textualize

; 2567 :     for (scan=this->next_cluster; scan != NULL; scan=scan->next_cluster)

	mov	esi, DWORD PTR [edi+40]
	test	esi, esi
	je	SHORT $LN41@textualize
	mov	edi, DWORD PTR _max_tile$[ebp]
$LL13@textualize:

; 2568 :       scan->textualize_attributes(output,min_tile,max_tile,skip_derived);

	push	eax
	push	edi
	push	DWORD PTR _min_tile$[ebp]
	mov	ecx, esi
	push	ebx
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@HH_N@Z ; kdu_params::textualize_attributes
	mov	esi, DWORD PTR [esi+40]
	mov	eax, DWORD PTR _skip_derived$[ebp]
	test	esi, esi
	jne	SHORT $LL13@textualize
$LN41@textualize:
	pop	esi
$LN12@textualize:
	pop	edi
	pop	ebx

; 2569 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@HH_N@Z ENDP ; kdu_params::textualize_attributes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z
_TEXT	SEGMENT
_val$2 = -268						; size = 4
_val$3 = -264						; size = 4
tv634 = -260						; size = 4
_acc$1$ = -256						; size = 4
_output$GSCopy$1$ = -252				; size = 4
_e$4 = -248						; size = 20
_rec$1$ = -228						; size = 4
_fld$1$ = -224						; size = 4
tv546 = -220						; size = 4
_text$5 = -216						; size = 2
_text$6 = -212						; size = 2
_text$7 = -208						; size = 2
_text$8 = -204						; size = 2
_text$9 = -200						; size = 2
_text$10 = -196						; size = 2
_text$11 = -192						; size = 2
_text$12 = -188						; size = 2
_this$GSCopy$1$ = -184					; size = 4
_ap$1$ = -180						; size = 4
_text$13 = -176						; size = 80
_text$14 = -176						; size = 80
_text$15 = -176						; size = 80
_text$16 = -176						; size = 80
_buf$17 = -176						; size = 80
_text$18 = -96						; size = 80
_text$19 = -96						; size = 80
_text$20 = -96						; size = 80
_text$21 = -96						; size = 80
_buf$22 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_output$ = 8						; size = 4
_skip_derived$ = 12					; size = 1
?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z PROC ; kdu_params::textualize_attributes, COMDAT
; _this$ = ecx

; 2432 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx

; 2436 :   for (ap=attributes; ap != NULL; ap=ap->next)

	mov	ecx, DWORD PTR [ebx+60]
	mov	esi, DWORD PTR _output$[ebp]
	mov	DWORD PTR _output$GSCopy$1$[ebp], esi
	mov	DWORD PTR _ap$1$[ebp], ecx
	test	ecx, ecx
	je	$LN3@textualize
	mov	edi, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
$LL4@textualize:

; 2437 :     {
; 2438 :       if (ap->num_records == 0)

	cmp	DWORD PTR [ecx+20], 0
	je	$LN2@textualize

; 2439 :         continue;
; 2440 :       if (ap->derived && skip_derived)

	cmp	BYTE PTR [ecx+28], 0
	je	SHORT $LN18@textualize
	cmp	BYTE PTR _skip_derived$[ebp], 0
	jne	$LN2@textualize
$LN18@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [ecx]
	mov	ecx, esi
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2443 :       if ((comp_idx >= 0) || (tile_idx >= 0) ||

	cmp	DWORD PTR [ebx+12], 0
	jge	SHORT $LN20@textualize
	cmp	DWORD PTR [ebx+8], 0
	jge	SHORT $LN20@textualize
	cmp	BYTE PTR [ebx+34], 0
	je	$LN23@textualize
$LN20@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$12[ebp]
	push	ecx
	mov	ecx, esi
	mov	WORD PTR _text$12[ebp], 58		; 0000003aH
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2447 :           if (tile_idx >= 0)

	cmp	DWORD PTR [ebx+8], 0
	jl	SHORT $LN21@textualize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_01GAPBHFFA@T?$AA@
	call	DWORD PTR [eax+8]

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR [esi+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	DWORD PTR [ebx+8]
	cmove	eax, edi
	push	eax
	lea	eax, DWORD PTR _text$21[ebp]
	push	eax
	call	_sprintf

; 263  :         put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$21[ebp]
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]
$LN21@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2449 :           if (comp_idx >= 0)

	cmp	DWORD PTR [ebx+12], 0
	jl	SHORT $LN22@textualize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_01GFHCPBMG@C?$AA@
	call	DWORD PTR [eax+8]

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR [esi+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	DWORD PTR [ebx+12]
	cmove	eax, edi
	push	eax
	lea	eax, DWORD PTR _text$20[ebp]
	push	eax
	call	_sprintf

; 263  :         put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$20[ebp]
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]
$LN22@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2451 :           if (treat_instances_like_components)

	cmp	BYTE PTR [ebx+34], 0
	je	SHORT $LN23@textualize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_01JPJNBJEM@I?$AA@
	call	DWORD PTR [eax+8]

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR [esi+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	DWORD PTR [ebx+16]
	cmove	eax, edi
	push	eax
	lea	eax, DWORD PTR _text$19[ebp]
	push	eax
	call	_sprintf

; 263  :         put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$19[ebp]
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]
$LN23@textualize:

; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$11[ebp]
	push	ecx
	mov	ecx, esi
	mov	WORD PTR _text$11[ebp], 61		; 0000003dH
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2455 :       for (rec=0; rec < ap->num_records; rec++)

	mov	ecx, DWORD PTR _ap$1$[ebp]
	xor	edi, edi
	mov	DWORD PTR _rec$1$[ebp], edi
	cmp	DWORD PTR [ecx+20], edi
	jle	$LN6@textualize
	npad	2
$LL7@textualize:

; 2456 :         {
; 2457 :           if (rec > 0)

	test	edi, edi
	jle	SHORT $LN71@textualize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$10[ebp]
	push	ecx
	mov	ecx, esi
	mov	WORD PTR _text$10[ebp], 44		; 0000002cH
	call	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _ap$1$[ebp]
$LN71@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2459 :           if (ap->num_fields > 1)

	cmp	DWORD PTR [ecx+16], 1
	jle	SHORT $LN75@textualize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$9[ebp]
	push	ecx
	mov	ecx, esi
	mov	WORD PTR _text$9[ebp], 123		; 0000007bH
	call	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _ap$1$[ebp]
$LN75@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2461 :           for (fld=0; fld < ap->num_fields; fld++)

	mov	eax, DWORD PTR [ecx+16]
	xor	edx, edx
	mov	DWORD PTR _fld$1$[ebp], edx
	test	eax, eax
	jle	$LN9@textualize
	npad	9
$LL10@textualize:

; 2462 :             {
; 2463 :               att_val *att = ap->values + rec*ap->num_fields + fld;

	mov	ecx, DWORD PTR [ecx+24]
	imul	eax, edi
	mov	DWORD PTR tv546[ebp], ecx
	add	eax, edx
	mov	DWORD PTR tv634[ebp], eax
	lea	edi, DWORD PTR [eax+eax*2]

; 2464 :               char const *cp;
; 2465 :                 
; 2466 :               if (fld > 0)

	test	edx, edx
	jle	SHORT $LN79@textualize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$8[ebp]
	push	ecx
	mov	ecx, esi
	mov	WORD PTR _text$8[ebp], 44		; 0000002cH
	call	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR tv546[ebp]
$LN79@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2468 :               if (!att->is_set)

	cmp	BYTE PTR [ecx+edi*4+8], 0
	jne	$LN27@textualize

; 2469 :                 { KDU_ERROR_DEV(e,58); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0HL@JPCGMMAG@Attempting?5to?5textualize?5a?5code?9@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2469 :                 { KDU_ERROR_DEV(e,58); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _ap$1$[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR _e$4[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_02KOPDJAMB@?$CC?5?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_09GBLFFAMG@in?5field?5?$AA@
	call	DWORD PTR [eax+8]

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$4[ebp+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	DWORD PTR _fld$1$[ebp]
	mov	ebx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmove	eax, ebx
	push	eax
	lea	eax, DWORD PTR _text$18[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$18[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	eax
	mov	eax, DWORD PTR _e$4[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0M@LIKKDBIM@?5of?5record?5?$AA@
	call	DWORD PTR [eax+8]

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$4[ebp+4], 0
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	push	DWORD PTR _rec$1$[ebp]
	cmove	eax, ebx
	push	eax
	lea	eax, DWORD PTR _text$16[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$16[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	eax
	mov	eax, DWORD PTR _e$4[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2476 :                 }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR tv546[ebp]
$LN27@textualize:

; 2477 :               cp = att->pattern;

	mov	ebx, DWORD PTR [ecx+edi*4+4]

; 2478 :               if (*cp == 'F')

	mov	al, BYTE PTR [ebx]
	cmp	al, 70					; 00000046H
	jne	SHORT $LN28@textualize
	movss	xmm0, DWORD PTR [ecx+edi*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 291  :       { char text[80]; sprintf(text,"%f",val); put_text(text); return *this; }

	lea	eax, DWORD PTR _text$15[ebp]
	cvtps2pd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	push	eax
	call	_sprintf
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$15[ebp]
	add	esp, 16					; 00000010H
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]
	jmp	$LN152@textualize
$LN28@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2480 :               else if (*cp == 'I')

	cmp	al, 73					; 00000049H
	jne	SHORT $LN30@textualize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	push	DWORD PTR [ecx+edi*4]
	cmp	BYTE PTR [esi+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$14[ebp]
	push	eax
	call	_sprintf

; 263  :         put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$14[ebp]
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]
	jmp	$LN152@textualize
$LN30@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2482 :               else if (*cp == 'B')

	cmp	al, 66					; 00000042H
	jne	SHORT $LN32@textualize

; 2483 :                 output << ((att->ival)?"yes":"no");

	cmp	DWORD PTR [ecx+edi*4], 0
	mov	eax, OFFSET ??_C@_03ICICOMAL@yes?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	edx, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2483 :                 output << ((att->ival)?"yes":"no");

	mov	ecx, OFFSET ??_C@_02KAJCLHKP@no?$AA@
	cmove	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	ecx, esi
	push	eax
	call	DWORD PTR [edx+8]
	jmp	$LN152@textualize
$LN32@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2484 :               else if (*cp == 'C')

	cmp	al, 67					; 00000043H
	jne	SHORT $LN34@textualize

; 2485 :                 custom_textualize_field(output,ap->name,fld,att->ival);

	push	DWORD PTR [ecx+edi*4]
	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR _ap$1$[ebp]
	push	DWORD PTR _fld$1$[ebp]
	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR [ecx]
	mov	ecx, ebx
	push	esi
	call	DWORD PTR [eax+28]
	jmp	$LN15@textualize
$LN34@textualize:

; 2486 :               else if (*cp == '(')

	cmp	al, 40					; 00000028H
	jne	SHORT $LN36@textualize
	mov	esi, DWORD PTR tv546[ebp]
$LL13@textualize:

; 2487 :                 {
; 2488 :                   char buf[80];
; 2489 :                   int val;
; 2490 :                   
; 2491 :                   do {
; 2492 :                       cp = parse_translator_entry(cp+1,',',buf,80,val);

	lea	eax, DWORD PTR _val$3[ebp]
	push	eax
	push	80					; 00000050H
	lea	eax, DWORD PTR _buf$17[ebp]
	push	eax
	lea	eax, DWORD PTR [ebx+1]
	push	44					; 0000002cH
	push	eax
	call	?parse_translator_entry@@YAPBDPBDDQADHAAH@Z ; parse_translator_entry

; 2493 :                       if (val == att->ival)

	mov	ecx, DWORD PTR _val$3[ebp]
	add	esp, 20					; 00000014H
	mov	ebx, eax
	cmp	ecx, DWORD PTR [esi+edi*4]
	je	SHORT $LN12@textualize

; 2494 :                         break;
; 2495 :                     } while (*cp == ',');

	cmp	BYTE PTR [ebx], 44			; 0000002cH
	je	SHORT $LL13@textualize
$LN12@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	esi, DWORD PTR _output$GSCopy$1$[ebp]
	lea	ecx, DWORD PTR _buf$17[ebp]
	push	ecx
	mov	ecx, esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]
	jmp	$LN152@textualize
$LN36@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2499 :               else if (*cp == '[')

	cmp	al, 91					; 0000005bH
	jne	$LN152@textualize

; 2500 :                 {
; 2501 :                   char buf[80];
; 2502 :                   int val, acc=0;
; 2503 :                   
; 2504 :                   if (att->ival == 0)

	cmp	DWORD PTR [ecx+edi*4], 0
	mov	DWORD PTR _acc$1$[ebp], 0
	jne	SHORT $LL16@textualize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR [esi+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	0
	push	eax
	lea	eax, DWORD PTR _text$13[ebp]
	push	eax
	call	_sprintf

; 263  :         put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$13[ebp]
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]
	npad	8
$LL16@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2507 :                       cp = parse_translator_entry(cp+1,'|',buf,80,val);

	lea	eax, DWORD PTR _val$2[ebp]
	push	eax
	push	80					; 00000050H
	lea	eax, DWORD PTR _buf$22[ebp]
	push	eax
	lea	eax, DWORD PTR [ebx+1]
	push	124					; 0000007cH
	push	eax
	call	?parse_translator_entry@@YAPBDPBDDQADHAAH@Z ; parse_translator_entry

; 2508 :                       if (((att->ival & val) == val) && ((acc | val) > acc))

	mov	esi, DWORD PTR tv634[ebp]
	mov	ebx, eax
	mov	edx, DWORD PTR tv546[ebp]
	add	esp, 20					; 00000014H
	mov	edi, DWORD PTR _val$2[ebp]
	mov	eax, edi
	lea	ecx, DWORD PTR [esi+esi*2]
	mov	esi, DWORD PTR _output$GSCopy$1$[ebp]
	and	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, edi
	jne	SHORT $LN14@textualize
	or	edi, DWORD PTR _acc$1$[ebp]
	cmp	edi, DWORD PTR _acc$1$[ebp]
	jle	SHORT $LN14@textualize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _buf$22[ebp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2512 :                           if (acc == att->ival)

	mov	ecx, DWORD PTR tv546[ebp]
	mov	edx, edi
	mov	edi, DWORD PTR tv634[ebp]
	mov	DWORD PTR _acc$1$[ebp], edx
	lea	eax, DWORD PTR [edi+edi*2]
	cmp	edx, DWORD PTR [ecx+eax*4]
	je	SHORT $LN152@textualize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$7[ebp]
	push	ecx
	mov	ecx, esi
	mov	WORD PTR _text$7[ebp], 44		; 0000002cH
	call	DWORD PTR [eax+8]
$LN14@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2516 :                     } while (*cp == '|');

	cmp	BYTE PTR [ebx], 124			; 0000007cH
	je	$LL16@textualize
$LN152@textualize:
	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
$LN15@textualize:

; 2461 :           for (fld=0; fld < ap->num_fields; fld++)

	mov	ecx, DWORD PTR _ap$1$[ebp]
	mov	edx, DWORD PTR _fld$1$[ebp]
	mov	edi, DWORD PTR _rec$1$[ebp]
	inc	edx
	mov	DWORD PTR _fld$1$[ebp], edx
	mov	eax, DWORD PTR [ecx+16]
	cmp	edx, eax
	jl	$LL10@textualize
$LN9@textualize:

; 2517 :                   assert(acc == att->ival);
; 2518 :                 }
; 2519 :               else
; 2520 :                 assert(0);
; 2521 :             }
; 2522 :           if (ap->num_fields > 1)

	cmp	DWORD PTR [ecx+16], 1
	jle	SHORT $LN5@textualize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$6[ebp]
	push	ecx
	mov	ecx, esi
	mov	WORD PTR _text$6[ebp], 125		; 0000007dH
	call	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _ap$1$[ebp]
$LN5@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2455 :       for (rec=0; rec < ap->num_records; rec++)

	inc	edi
	mov	DWORD PTR _rec$1$[ebp], edi
	cmp	edi, DWORD PTR [ecx+20]
	jl	$LL7@textualize
$LN6@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$5[ebp]
	push	ecx
	mov	ecx, esi
	mov	WORD PTR _text$5[ebp], 10		; 0000000aH
	call	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _ap$1$[ebp]
	mov	edi, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
$LN2@textualize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2436 :   for (ap=attributes; ap != NULL; ap=ap->next)

	mov	ecx, DWORD PTR [ecx+32]
	mov	DWORD PTR _ap$1$[ebp], ecx
	test	ecx, ecx
	jne	$LL4@textualize
$LN3@textualize:

; 2523 :             output << '}';
; 2524 :         }
; 2525 :       output << '\n';
; 2526 :     }
; 2527 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@_N@Z ENDP ; kdu_params::textualize_attributes
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?parse_string@kdu_params@@QAE_NPBDH@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
_which_tile$ = 12					; size = 4
?parse_string@kdu_params@@QAE_NPBDH@Z PROC		; kdu_params::parse_string, COMDAT
; _this$ = ecx

; 2410 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h

; 519  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

	push	58					; 0000003aH
	push	DWORD PTR _string$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2410 : {

	mov	ebx, ecx

; 2411 :   int target_tile = -1;

	or	esi, -1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h

; 519  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

	call	DWORD PTR __imp__strchr
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2412 :   char *delim = strchr((char *) string,':'); // Need (char *) cast for Solaris

	mov	edx, eax
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h

; 519  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

	add	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2413 :   if (delim != NULL)

	test	edx, edx
	je	SHORT $LN5@parse_stri

; 2414 :     {
; 2415 :       delim++;
; 2416 :       while ((*delim != 'T') && (*delim != '=') && (*delim != '\0'))

	mov	al, BYTE PTR [edx+1]
	inc	edx
	cmp	al, 84					; 00000054H
	je	SHORT $LN14@parse_stri
$LL2@parse_stri:
	cmp	al, 61					; 0000003dH
	je	SHORT $LN3@parse_stri
	test	al, al
	je	SHORT $LN3@parse_stri
	mov	al, BYTE PTR [edx+1]

; 2417 :         delim++;

	inc	edx
	cmp	al, 84					; 00000054H
	jne	SHORT $LL2@parse_stri

; 2418 :       if (*delim == 'T')

	jmp	SHORT $LN14@parse_stri
$LN3@parse_stri:
	cmp	BYTE PTR [edx], 84			; 00000054H
	jne	SHORT $LN5@parse_stri
$LN14@parse_stri:

; 2419 :         target_tile = (int) strtol(delim+1,NULL,10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR [edx+1]
	push	0
	push	eax
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	mov	esi, eax
$LN5@parse_stri:

; 2420 :     }
; 2421 :   if (target_tile != which_tile)

	cmp	esi, DWORD PTR _which_tile$[ebp]
	je	SHORT $LN6@parse_stri

; 2422 :     return false;

	pop	esi
	xor	al, al
	pop	ebx

; 2424 : }

	pop	ebp
	ret	8
$LN6@parse_stri:

; 2423 :   return parse_string(string);

	push	DWORD PTR _string$[ebp]
	mov	ecx, ebx
	call	?parse_string@kdu_params@@QAE_NPBD@Z	; kdu_params::parse_string
	pop	esi
	pop	ebx

; 2424 : }

	pop	ebp
	ret	8
?parse_string@kdu_params@@QAE_NPBDH@Z ENDP		; kdu_params::parse_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?parse_string@kdu_params@@QAE_NPBD@Z
_TEXT	SEGMENT
_val$2 = -192						; size = 4
_parsed_ival$3 = -188					; size = 4
_val$4 = -184						; size = 4
_e$5 = -180						; size = 20
_old_val$1$ = -160					; size = 4
_parsed_fval$6 = -160					; size = 4
_rec$1$ = -156						; size = 4
_ap$1$ = -152						; size = 4
_fld$1$ = -148						; size = 4
tv1076 = -144						; size = 4
_open_record$1$ = -137					; size = 1
tv1075 = -136						; size = 4
_this$GSCopy$1$ = -132					; size = 4
_string$GSCopy$1$ = -128				; size = 4
_delim$ = -124						; size = 4
_new_change$1$ = -117					; size = 1
_e$7 = -116						; size = 20
_e$8 = -116						; size = 20
_e$9 = -116						; size = 20
_e$10 = -116						; size = 20
_e$11 = -116						; size = 20
_e$12 = -116						; size = 20
_e$13 = -116						; size = 20
_e$14 = -116						; size = 20
_e$15 = -116						; size = 20
_e$16 = -116						; size = 20
_e$17 = -116						; size = 20
_e$18 = -116						; size = 20
_e$19 = -116						; size = 20
_e$20 = -116						; size = 20
_e$21 = -116						; size = 20
_e$22 = -116						; size = 20
_e$23 = -116						; size = 20
_e$24 = -116						; size = 20
_e$25 = -116						; size = 20
_e$26 = -116						; size = 20
_buf$27 = -96						; size = 80
_buf$28 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_string$ = 8						; size = 4
?parse_string@kdu_params@@QAE_NPBD@Z PROC		; kdu_params::parse_string, COMDAT
; _this$ = ecx

; 2023 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?parse_string@kdu_params@@QAE_NPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	edi, DWORD PTR _string$[ebp]

; 2024 :   kd_attribute *ap;
; 2025 :   char *delim;
; 2026 :   size_t name_len;
; 2027 : 
; 2028 :   for (delim=(char *) string; *delim != '\0'; delim++)

	mov	esi, edi
	mov	DWORD PTR _delim$[ebp], esi
	mov	DWORD PTR _string$GSCopy$1$[ebp], edi
	cmp	BYTE PTR [edi], 0
	je	$LN37@parse_stri
$LL4@parse_stri:

; 2029 :     if ((*delim == ' ') || (*delim == '\t') || (*delim == '\n'))

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN35@parse_stri
	cmp	al, 9
	je	SHORT $LN35@parse_stri
	cmp	al, 10					; 0000000aH
	je	SHORT $LN35@parse_stri

; 2035 :     else if ((*delim == ':') || (*delim == '='))

	cmp	al, 58					; 0000003aH
	je	SHORT $LN504@parse_stri
	cmp	al, 61					; 0000003dH
	je	SHORT $LN504@parse_stri
	jmp	SHORT $LN2@parse_stri
$LN35@parse_stri:

; 2030 :       { KDU_ERROR(e,40); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$26[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$26[ebp]
	lea	ecx, DWORD PTR _e$26[ebp]
	push	OFFSET ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2030 :       { KDU_ERROR(e,40); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$26[ebp]
	lea	ecx, DWORD PTR _e$26[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$26[ebp]
	lea	ecx, DWORD PTR _e$26[ebp]
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$26[ebp]
	lea	ecx, DWORD PTR _e$26[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$26[ebp]
	lea	ecx, DWORD PTR _e$26[ebp]
	push	OFFSET ??_C@_0CE@NNLGGFEF@White?5space?5characters?5are?5illeg@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2034 :       }

	lea	ecx, DWORD PTR _e$26[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	esi, DWORD PTR _delim$[ebp]
$LN2@parse_stri:

; 2024 :   kd_attribute *ap;
; 2025 :   char *delim;
; 2026 :   size_t name_len;
; 2027 : 
; 2028 :   for (delim=(char *) string; *delim != '\0'; delim++)

	inc	esi
	mov	DWORD PTR _delim$[ebp], esi
	cmp	BYTE PTR [esi], 0
	jne	$LL4@parse_stri
$LN504@parse_stri:
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
$LN37@parse_stri:

; 2036 :       break;
; 2037 :   name_len = (size_t)(delim - string);
; 2038 :   for (ap=attributes; ap != NULL; ap=ap->next)

	mov	ebx, DWORD PTR [ecx+60]
	sub	esi, edi
	mov	DWORD PTR _ap$1$[ebp], ebx
	test	ebx, ebx
	je	SHORT $LN480@parse_stri
	npad	6
$LL7@parse_stri:

; 2039 :     if ((strncmp(ap->name,string,name_len)==0) && (strlen(ap->name)==name_len))

	push	esi
	push	edi
	push	DWORD PTR [ebx]
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@parse_stri
	mov	ecx, DWORD PTR [ebx]
	lea	edx, DWORD PTR [ecx+1]
$LL493@parse_stri:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL493@parse_stri
	sub	ecx, edx
	cmp	ecx, esi
	je	SHORT $LN39@parse_stri
$LN5@parse_stri:

; 2036 :       break;
; 2037 :   name_len = (size_t)(delim - string);
; 2038 :   for (ap=attributes; ap != NULL; ap=ap->next)

	mov	ebx, DWORD PTR [ebx+32]
	mov	DWORD PTR _ap$1$[ebp], ebx
	test	ebx, ebx
	jne	SHORT $LL7@parse_stri
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
$LN480@parse_stri:

; 2040 :       break;
; 2041 :   if (ap == NULL)
; 2042 :     {
; 2043 :       if (this == first_cluster)

	cmp	ecx, DWORD PTR [ecx+36]
	jne	SHORT $LN9@parse_stri

; 2044 :         {
; 2045 :           kdu_params *scan;
; 2046 : 
; 2047 :           for (scan=this->next_cluster; scan != NULL; scan=scan->next_cluster)

	mov	esi, DWORD PTR [ecx+40]
	test	esi, esi
	je	SHORT $LN9@parse_stri
$LL10@parse_stri:

; 2048 :             if (scan->parse_string(string))

	push	edi
	mov	ecx, esi
	call	?parse_string@kdu_params@@QAE_NPBD@Z	; kdu_params::parse_string
	test	al, al
	jne	$LN441@parse_stri

; 2044 :         {
; 2045 :           kdu_params *scan;
; 2046 : 
; 2047 :           for (scan=this->next_cluster; scan != NULL; scan=scan->next_cluster)

	mov	esi, DWORD PTR [esi+40]
	test	esi, esi
	jne	SHORT $LL10@parse_stri
$LN9@parse_stri:

; 2049 :               return(true);
; 2050 :         }
; 2051 :       return false;

	xor	al, al
$LN1@parse_stri:

; 2402 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN39@parse_stri:

; 2052 :     }
; 2053 :   assert(ap != NULL);
; 2054 :   if (*delim == '\0')

	mov	eax, DWORD PTR _delim$[ebp]
	cmp	BYTE PTR [eax], 0
	jne	$LN42@parse_stri

; 2055 :     { KDU_ERROR(e,41); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$25[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$25[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	OFFSET ??_C@_09EIDFECNJ@Attribute?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2055 :     { KDU_ERROR(e,41); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$25[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$25[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	DWORD PTR [ebx]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$25[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	OFFSET ??_C@_02KOPDJAMB@?$CC?5?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$25[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	OFFSET ??_C@_0BK@DEPOJPCI@is?5missing?5parameters?3?6?6?7?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2059 :       ap->describe(e,allow_tiles,allow_comps,

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	1
	movzx	eax, BYTE PTR [ecx+34]
	push	eax
	movzx	eax, BYTE PTR [ecx+31]
	push	eax
	movzx	eax, BYTE PTR [ecx+30]
	mov	ecx, ebx
	push	eax
	lea	eax, DWORD PTR _e$25[ebp]
	push	eax
	call	?describe@kd_attribute@@QAEXAAVkdu_message@@_N111@Z ; kd_attribute::describe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$25[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	OFFSET ??_C@_0GO@DPHCDBCK@?6Parameter?5values?5must?5be?5separa@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2063 :     }

	lea	ecx, DWORD PTR _e$25[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _delim$[ebp]
$LN42@parse_stri:

; 2064 : 
; 2065 :   int target_tile = -2;
; 2066 :   int target_comp = -2;
; 2067 :   int target_inst = -1;
; 2068 : 
; 2069 :   if (*delim == ':')

	mov	edx, DWORD PTR __imp__strtol
	mov	edi, -2					; fffffffeH
	or	esi, -1
	mov	ebx, edi
	cmp	BYTE PTR [eax], 58			; 0000003aH
	jne	$LN483@parse_stri

; 2070 :     {
; 2071 :       delim++;

	inc	eax
	mov	DWORD PTR _delim$[ebp], eax

; 2072 :       while (*delim != '=')

	mov	cl, BYTE PTR [eax]
	cmp	cl, 61					; 0000003dH
	je	$LN483@parse_stri
$LL11@parse_stri:

; 2073 :         if (*delim == '\0')

	test	cl, cl
	je	$LN442@parse_stri

; 2074 :           break;
; 2075 :         else if ((*delim == 'T') && (target_tile < -1))

	cmp	cl, 84					; 00000054H
	jne	SHORT $LN46@parse_stri
	cmp	edi, -1
	jge	SHORT $LN46@parse_stri

; 2076 :           target_tile = (int) strtol(delim+1,&delim,10);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _delim$[ebp]
	inc	eax
	push	ecx
	push	eax
	call	edx
	add	esp, 12					; 0000000cH
	mov	edi, eax
	jmp	$LN51@parse_stri
$LN46@parse_stri:

; 2077 :         else if ((*delim == 'C') && (target_comp < -1))

	cmp	cl, 67					; 00000043H
	jne	SHORT $LN48@parse_stri
	cmp	ebx, -1
	jge	SHORT $LN48@parse_stri

; 2078 :           target_comp = (int) strtol(delim+1,&delim,10);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _delim$[ebp]
	inc	eax
	push	ecx
	push	eax
	call	edx
	add	esp, 12					; 0000000cH
	mov	ebx, eax
	jmp	$LN51@parse_stri
$LN48@parse_stri:

; 2079 :         else if ((*delim == 'I') && (target_inst < 0))

	cmp	cl, 73					; 00000049H
	jne	SHORT $LN50@parse_stri
	test	esi, esi
	jns	SHORT $LN50@parse_stri

; 2080 :           target_inst = (int) strtol(delim+1,&delim,10);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _delim$[ebp]
	inc	eax
	push	ecx
	push	eax
	call	edx
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 2081 :         else

	jmp	SHORT $LN51@parse_stri
$LN50@parse_stri:

; 2082 :           { KDU_ERROR(e,42); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$24[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$24[ebp]
	lea	ecx, DWORD PTR _e$24[ebp]
	push	OFFSET ??_C@_0DN@JMPBALKA@Malformed?5location?5specifier?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2082 :           { KDU_ERROR(e,42); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$24[ebp]
	lea	ecx, DWORD PTR _e$24[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$24[ebp]
	lea	ecx, DWORD PTR _e$24[ebp]
	push	DWORD PTR _string$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$24[ebp]
	lea	ecx, DWORD PTR _e$24[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$24[ebp]
	lea	ecx, DWORD PTR _e$24[ebp]
	push	OFFSET ??_C@_0NA@FLKOAPNM@Tile?5specifiers?5following?5the?5th@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2090 :           }

	lea	ecx, DWORD PTR _e$24[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN51@parse_stri:

; 2072 :       while (*delim != '=')

	mov	eax, DWORD PTR _delim$[ebp]
	mov	edx, DWORD PTR __imp__strtol
	mov	cl, BYTE PTR [eax]
	cmp	cl, 61					; 0000003dH
	jne	$LL11@parse_stri
$LN442@parse_stri:

; 2091 :     }
; 2092 :   if (target_tile < -1)

	cmp	edi, -1
	jge	SHORT $LN514@parse_stri
$LN483@parse_stri:

; 2093 :     target_tile = this->tile_idx;

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	edi, DWORD PTR [ecx+8]
	jmp	SHORT $LN52@parse_stri
$LN514@parse_stri:
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
$LN52@parse_stri:

; 2094 :   if (target_comp < -1)

	cmp	ebx, -1
	jge	SHORT $LN53@parse_stri

; 2095 :     target_comp = this->comp_idx;

	mov	ebx, DWORD PTR [ecx+12]
$LN53@parse_stri:

; 2096 :   if (target_inst < 0)

	test	esi, esi
	jns	SHORT $LN54@parse_stri

; 2097 :     {
; 2098 :       if ((target_tile == this->tile_idx) && (target_comp == this->comp_idx))

	cmp	edi, DWORD PTR [ecx+8]
	jne	SHORT $LN56@parse_stri
	cmp	ebx, DWORD PTR [ecx+12]
	jne	SHORT $LN56@parse_stri

; 2099 :         target_inst = this->inst_idx;

	mov	esi, DWORD PTR [ecx+16]
	jmp	$LN60@parse_stri
$LN56@parse_stri:

; 2100 :       else if (!treat_instances_like_components)

	cmp	BYTE PTR [ecx+34], 0
	jne	SHORT $LN58@parse_stri

; 2101 :         target_inst = 0;

	xor	esi, esi

; 2102 :       else

	jmp	$LN60@parse_stri
$LN58@parse_stri:

; 2103 :         { KDU_ERROR(e,0x21040500); e << // Unique error # = day/month/year/idx

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$23[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$23[ebp]
	lea	ecx, DWORD PTR _e$23[ebp]
	push	OFFSET ??_C@_0DN@JMPBALKA@Malformed?5location?5specifier?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2103 :         { KDU_ERROR(e,0x21040500); e << // Unique error # = day/month/year/idx

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$23[ebp]
	lea	ecx, DWORD PTR _e$23[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$23[ebp]
	lea	ecx, DWORD PTR _e$23[ebp]
	push	DWORD PTR _string$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$23[ebp]
	lea	ecx, DWORD PTR _e$23[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0FE@PMHLCCDF@You?5must?5supply?5an?5index?5specifi@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2109 :           }

	jmp	SHORT $LN516@parse_stri
$LN54@parse_stri:

; 2110 :     }
; 2111 :   else if (!treat_instances_like_components)

	cmp	BYTE PTR [ecx+34], 0
	jne	SHORT $LN60@parse_stri

; 2112 :     { KDU_ERROR(e,0x21040501); e << // Unique error # = day/month/year/idx

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$22[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$22[ebp]
	lea	ecx, DWORD PTR _e$22[ebp]
	push	OFFSET ??_C@_0DN@JMPBALKA@Malformed?5location?5specifier?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2112 :     { KDU_ERROR(e,0x21040501); e << // Unique error # = day/month/year/idx

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$22[ebp]
	lea	ecx, DWORD PTR _e$22[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$22[ebp]
	lea	ecx, DWORD PTR _e$22[ebp]
	push	DWORD PTR _string$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$22[ebp]
	lea	ecx, DWORD PTR _e$22[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0GI@IAODNOI@This?5type?5of?5parameter?5cannot?5be@
$LN516@parse_stri:
	mov	eax, DWORD PTR _e$22[ebp]
	lea	ecx, DWORD PTR _e$22[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2118 :     }

	lea	ecx, DWORD PTR _e$22[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR _delim$[ebp]
$LN60@parse_stri:

; 2119 : 
; 2120 :   // Locate the object to which the attribute belongs.
; 2121 :   if ((this->tile_idx != target_tile) || (this->comp_idx != target_comp) ||

	cmp	DWORD PTR [ecx+8], edi
	jne	$LN62@parse_stri
	cmp	DWORD PTR [ecx+12], ebx
	jne	$LN62@parse_stri
	cmp	DWORD PTR [ecx+16], esi
	jne	$LN62@parse_stri

; 2134 :     }
; 2135 : 
; 2136 :   // Perform accessibility checks
; 2137 :   if (marked)

	cmp	BYTE PTR [ecx+29], 0
	je	SHORT $LN64@parse_stri

; 2138 :     { KDU_ERROR_DEV(e,44); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$20[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$20[ebp]
	lea	ecx, DWORD PTR _e$20[ebp]
	push	OFFSET ??_C@_0EP@FFHPHGIF@Illegal?5attempt?5to?5modify?5a?5?$GAkdu@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2138 :     { KDU_ERROR_DEV(e,44); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2141 :     }

	lea	ecx, DWORD PTR _e$20[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _delim$[ebp]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
$LN64@parse_stri:

; 2142 : 
; 2143 :   if ((ap->flags & ALL_COMPONENTS) && (comp_idx != -1))

	mov	ebx, DWORD PTR _ap$1$[ebp]
	test	BYTE PTR [ebx+8], 4
	je	SHORT $LN510@parse_stri
	cmp	DWORD PTR [ecx+12], -1
	je	SHORT $LN510@parse_stri

; 2144 :     { KDU_ERROR(e,45);  e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$19[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$19[ebp]
	lea	ecx, DWORD PTR _e$19[ebp]
	push	OFFSET ??_C@_0IG@JNAPNKGG@Attempt?5to?5set?5a?5non?9tile?9specif@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2144 :     { KDU_ERROR(e,45);  e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$19[ebp]
	lea	ecx, DWORD PTR _e$19[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$19[ebp]
	lea	ecx, DWORD PTR _e$19[ebp]
	mov	esi, DWORD PTR _string$GSCopy$1$[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$19[ebp]
	lea	ecx, DWORD PTR _e$19[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2149 :     }

	lea	ecx, DWORD PTR _e$19[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _delim$[ebp]
	jmp	SHORT $LN65@parse_stri
$LN510@parse_stri:
	mov	esi, DWORD PTR _string$GSCopy$1$[ebp]
$LN65@parse_stri:

; 2150 : 
; 2151 :   if (*delim != '=')

	cmp	BYTE PTR [eax], 61			; 0000003dH
	je	SHORT $LN66@parse_stri

; 2152 :     { KDU_ERROR(e,46); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$18[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$18[ebp]
	lea	ecx, DWORD PTR _e$18[ebp]
	push	OFFSET ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2152 :     { KDU_ERROR(e,46); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$18[ebp]
	lea	ecx, DWORD PTR _e$18[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$18[ebp]
	lea	ecx, DWORD PTR _e$18[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$18[ebp]
	lea	ecx, DWORD PTR _e$18[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$18[ebp]
	lea	ecx, DWORD PTR _e$18[ebp]
	push	OFFSET ??_C@_0GM@BCPIKDJF@Parameter?5values?5must?5be?5separat@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2157 :     }

	lea	ecx, DWORD PTR _e$18[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN66@parse_stri:

; 2158 : 
; 2159 :   if ((ap->num_records > 0) && ap->parsed)

	cmp	DWORD PTR [ebx+20], 0
	jle	$LN67@parse_stri
	cmp	BYTE PTR [ebx+29], 0
	je	$LN67@parse_stri

; 2160 :     { // Attribute already set by parsing.
; 2161 :       if ((!allow_insts) || treat_instances_like_components ||

	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	cmp	BYTE PTR [ebx+32], 0
	je	SHORT $LN69@parse_stri
	cmp	BYTE PTR [ebx+34], 0
	jne	SHORT $LN69@parse_stri
	cmp	DWORD PTR [ebx+56], 0
	jne	SHORT $LN68@parse_stri
	mov	ecx, ebx
	call	?new_instance@kdu_params@@QAEPAV1@XZ	; kdu_params::new_instance
	test	eax, eax
	jne	SHORT $LN68@parse_stri
$LN69@parse_stri:

; 2163 :         { KDU_ERROR(e,47); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$17[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$17[ebp]
	lea	ecx, DWORD PTR _e$17[ebp]
	push	OFFSET ??_C@_0BO@NIAMPCJJ@The?5supplied?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2163 :         { KDU_ERROR(e,47); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 9
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$17[ebp]
	lea	ecx, DWORD PTR _e$17[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$17[ebp]
	lea	ecx, DWORD PTR _e$17[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$17[ebp]
	lea	ecx, DWORD PTR _e$17[ebp]
	push	OFFSET ??_C@_03HAFDNMHA@?$CC?0?5?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$17[ebp]
	lea	ecx, DWORD PTR _e$17[ebp]
	push	OFFSET ??_C@_0JM@LMPOLJGM@refers?5to?5code?9stream?5parameters@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2169 :         }

	lea	ecx, DWORD PTR _e$17[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN68@parse_stri:

; 2170 :       assert(next_inst != NULL);
; 2171 :       return next_inst->parse_string(string);

	mov	ecx, DWORD PTR [ebx+56]
	push	esi
	call	?parse_string@kdu_params@@QAE_NPBD@Z	; kdu_params::parse_string
	jmp	$LN1@parse_stri
$LN67@parse_stri:

; 2172 :     }
; 2173 : 
; 2174 :   delete_unparsed_attribute(ap->name);

	push	DWORD PTR [ebx]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	call	?delete_unparsed_attribute@kdu_params@@QAEXPBD@Z ; kdu_params::delete_unparsed_attribute

; 2175 :   ap->parsed = true;
; 2176 : 
; 2177 :   // Finally, we get around to parsing the parameter values.
; 2178 :   bool new_change = false;

	xor	al, al
	mov	BYTE PTR [ebx+29], 1
	mov	BYTE PTR _new_change$1$[ebp], al

; 2179 :   bool open_record;
; 2180 :   int fld, rec = 0;

	xor	ecx, ecx

; 2181 :   char *cp = delim + 1;

	mov	eax, DWORD PTR _delim$[ebp]
	mov	DWORD PTR _rec$1$[ebp], ecx
	lea	edi, DWORD PTR [eax+1]

; 2182 :   while (*cp != '\0')

	mov	al, BYTE PTR [edi]
	test	al, al
	je	$LN511@parse_stri
$LL13@parse_stri:

; 2183 :     { // Process a record.
; 2184 :       if (rec > 0)

	test	ecx, ecx
	jle	$LN72@parse_stri

; 2185 :         {
; 2186 :           if (*cp != ',')

	cmp	al, 44					; 0000002cH
	je	$LN71@parse_stri

; 2187 :             { KDU_ERROR(e,48); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$16[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	OFFSET ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2187 :             { KDU_ERROR(e,48); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	OFFSET ??_C@_0BH@DPGABFPI@Problem?5encountered?5at?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$16[ebp]
	lea	ecx, DWORD PTR _e$16[ebp]
	push	OFFSET ??_C@_0CF@KHIJHBHP@Records?5must?5be?5separated?5by?5com@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2193 :             }

	lea	ecx, DWORD PTR _e$16[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN71@parse_stri:

; 2194 :           cp++; // Skip over the inter-record comma.

	inc	edi

; 2195 :         }
; 2196 :       if ((rec > 0) && !(ap->flags & MULTI_RECORD))

	test	BYTE PTR [ebx+8], 1
	jne	SHORT $LN72@parse_stri

; 2197 :         { KDU_ERROR(e,49); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$15[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$15[ebp]
	lea	ecx, DWORD PTR _e$15[ebp]
	push	OFFSET ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2197 :         { KDU_ERROR(e,49); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$15[ebp]
	lea	ecx, DWORD PTR _e$15[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$15[ebp]
	lea	ecx, DWORD PTR _e$15[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$15[ebp]
	lea	ecx, DWORD PTR _e$15[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$15[ebp]
	lea	ecx, DWORD PTR _e$15[ebp]
	push	OFFSET ??_C@_0DH@MBMGHEML@Attribute?5does?5not?5support?5multi@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2202 :         }

	lea	ecx, DWORD PTR _e$15[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN72@parse_stri:

; 2203 :       open_record = false;
; 2204 :       if (*cp == '{')

	cmp	BYTE PTR [edi], 123			; 0000007bH
	mov	BYTE PTR _open_record$1$[ebp], 0
	jne	SHORT $LN73@parse_stri

; 2205 :         { cp++; open_record = true; }

	inc	edi
	mov	BYTE PTR _open_record$1$[ebp], 1
	jmp	$LN75@parse_stri
$LN73@parse_stri:

; 2206 :       else if (ap->num_fields > 1)

	cmp	DWORD PTR [ebx+16], 1
	jle	$LN75@parse_stri

; 2207 :         { KDU_ERROR(e,50);  e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$14[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	OFFSET ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2207 :         { KDU_ERROR(e,50);  e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	OFFSET ??_C@_0BH@DPGABFPI@Problem?5encountered?5at?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$14[ebp]
	lea	ecx, DWORD PTR _e$14[ebp]
	push	OFFSET ??_C@_0DN@ONBLBBIB@Records?5must?5be?5enclosed?5by?5curl@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2214 :         }

	lea	ecx, DWORD PTR _e$14[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN75@parse_stri:

; 2215 :       if (ap->num_records <= rec)

	mov	eax, DWORD PTR _rec$1$[ebp]
	cmp	DWORD PTR [ebx+20], eax
	jg	SHORT $LN76@parse_stri

; 2216 :         {
; 2217 :           new_change = true;
; 2218 :           ap->augment_records(rec+1);

	inc	eax
	mov	BYTE PTR _new_change$1$[ebp], 1
	push	eax
	mov	ecx, ebx
	call	?augment_records@kd_attribute@@QAEXH@Z	; kd_attribute::augment_records
$LN76@parse_stri:

; 2219 :         }
; 2220 :       for (fld=0; fld < ap->num_fields; fld++)

	xor	edx, edx
	mov	DWORD PTR _fld$1$[ebp], edx
	cmp	DWORD PTR [ebx+16], edx
	jle	$LN16@parse_stri
$LL17@parse_stri:

; 2221 :         {
; 2222 :           if (fld > 0)

	test	edx, edx
	jle	$LN77@parse_stri

; 2223 :             {
; 2224 :               if (*cp != ',')

	cmp	BYTE PTR [edi], 44			; 0000002cH
	je	$LN78@parse_stri

; 2225 :                 { KDU_ERROR(e,51); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$13[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	OFFSET ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2225 :                 { KDU_ERROR(e,51); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	OFFSET ??_C@_0BH@DPGABFPI@Problem?5encountered?5at?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$13[ebp]
	lea	ecx, DWORD PTR _e$13[ebp]
	push	OFFSET ??_C@_0CE@EELOEALG@Fields?5must?5be?5separated?5by?5comm@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2231 :                 }

	lea	ecx, DWORD PTR _e$13[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	edx, DWORD PTR _fld$1$[ebp]
$LN78@parse_stri:

; 2232 :               cp++; // Skip over the inter-field comma.

	inc	edi
$LN77@parse_stri:

; 2233 :             }
; 2234 :           att_val *att = ap->values + rec*ap->num_fields + fld;

	mov	eax, DWORD PTR [ebx+16]
	imul	eax, DWORD PTR _rec$1$[ebp]
	mov	ebx, DWORD PTR [ebx+24]
	mov	DWORD PTR tv1076[ebp], ebx
	add	eax, edx
	lea	edx, DWORD PTR [eax+eax*2]

; 2235 :           char const *pp = att->pattern;

	mov	ebx, DWORD PTR [ebx+edx*4+4]
	mov	DWORD PTR tv1075[ebp], edx

; 2236 :           if (*pp == 'F')

	mov	al, BYTE PTR [ebx]
	cmp	al, 70					; 00000046H
	jne	$LN79@parse_stri

; 2237 :             {
; 2238 :               float parsed_fval = (float) strtod(cp,&delim);

	lea	eax, DWORD PTR _delim$[ebp]
	push	eax
	push	edi
	call	DWORD PTR __imp__strtod

; 2239 :               if (!(att->is_set && (att->fval == parsed_fval)))

	mov	edx, DWORD PTR tv1075[ebp]
	add	esp, 8
	mov	ebx, DWORD PTR tv1076[ebp]
	fstp	DWORD PTR _parsed_fval$6[ebp]
	movss	xmm1, DWORD PTR _parsed_fval$6[ebp]
	cmp	BYTE PTR [ebx+edx*4+8], 0
	je	SHORT $LN82@parse_stri
	movss	xmm0, DWORD PTR [ebx+edx*4]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN81@parse_stri
$LN82@parse_stri:

; 2240 :                 new_change = true;

	mov	BYTE PTR _new_change$1$[ebp], 1
$LN81@parse_stri:

; 2241 :               att->fval = parsed_fval;

	movss	DWORD PTR [ebx+edx*4], xmm1

; 2242 :               if (delim == cp)

	mov	eax, DWORD PTR _delim$[ebp]
	cmp	eax, edi
	jne	$LN88@parse_stri

; 2243 :                 { KDU_ERROR(e,52); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$12[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2243 :                 { KDU_ERROR(e,52); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_0BH@DPGABFPI@Problem?5encountered?5at?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0CB@KHDANEEK@Expected?5a?5floating?5point?5field?4@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2250 :               cp = delim;

	jmp	$LN518@parse_stri
$LN79@parse_stri:

; 2251 :             }
; 2252 :           else if (*pp == 'I')

	cmp	al, 73					; 00000049H
	jne	$LN84@parse_stri

; 2253 :             {
; 2254 :               int parsed_ival = (int) strtol(cp,&delim,10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _delim$[ebp]
	push	eax
	push	edi
	call	DWORD PTR __imp__strtol

; 2255 :               if (!(att->is_set && (att->ival == parsed_ival)))

	mov	edx, DWORD PTR tv1075[ebp]
	add	esp, 12					; 0000000cH
	mov	ebx, DWORD PTR tv1076[ebp]
	cmp	BYTE PTR [ebx+edx*4+8], 0
	je	SHORT $LN87@parse_stri
	cmp	DWORD PTR [ebx+edx*4], eax
	je	SHORT $LN86@parse_stri
$LN87@parse_stri:

; 2256 :                 new_change = true;

	mov	BYTE PTR _new_change$1$[ebp], 1
$LN86@parse_stri:

; 2257 :               att->ival = parsed_ival;

	mov	DWORD PTR [ebx+edx*4], eax

; 2258 :               if (delim == cp)

	mov	eax, DWORD PTR _delim$[ebp]
	cmp	eax, edi
	jne	$LN88@parse_stri

; 2259 :                 { KDU_ERROR(e,53); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$11[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2259 :                 { KDU_ERROR(e,53); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_0BH@DPGABFPI@Problem?5encountered?5at?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	push	OFFSET ??_C@_0BL@KODNALJB@Expected?5an?5integer?5field?4?$AA@
$LN518@parse_stri:
	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2265 :                 }

	lea	ecx, DWORD PTR _e$11[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _delim$[ebp]
	mov	edx, DWORD PTR tv1075[ebp]
$LN88@parse_stri:

; 2266 :               cp = delim;

	mov	edi, eax
	jmp	$LN117@parse_stri
$LN84@parse_stri:

; 2267 :             }
; 2268 :           else if (*pp == 'C')

	cmp	al, 67					; 00000043H
	jne	$LN89@parse_stri

; 2269 :             {
; 2270 :               int parsed_chars, parsed_ival;
; 2271 :               parsed_chars = custom_parse_field(cp,ap->name,fld,parsed_ival);

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	edx, DWORD PTR _parsed_ival$3[ebp]
	mov	ebx, DWORD PTR _ap$1$[ebp]
	push	edx
	push	DWORD PTR _fld$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ebx]
	push	edi
	call	DWORD PTR [eax+24]

; 2272 :               if (!(att->is_set && (att->ival == parsed_ival)))

	mov	edx, DWORD PTR tv1075[ebp]
	mov	esi, eax
	mov	ebx, DWORD PTR tv1076[ebp]
	mov	ecx, DWORD PTR _parsed_ival$3[ebp]
	cmp	BYTE PTR [ebx+edx*4+8], 0
	je	SHORT $LN92@parse_stri
	cmp	DWORD PTR [ebx+edx*4], ecx
	je	SHORT $LN91@parse_stri
$LN92@parse_stri:

; 2273 :                 new_change = true;

	mov	BYTE PTR _new_change$1$[ebp], 1
$LN91@parse_stri:

; 2274 :               att->ival = parsed_ival;

	mov	DWORD PTR [ebx+edx*4], ecx

; 2275 :               if (parsed_chars <= 0)

	test	esi, esi
	jg	$LN93@parse_stri

; 2276 :                 { KDU_ERROR(e,0x26040500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$10[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2276 :                 { KDU_ERROR(e,0x26040500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 16		; 00000010H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	DWORD PTR _string$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0BH@DPGABFPI@Problem?5encountered?5at?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0FJ@PANFLKHK@Attempt?5to?5parse?5custom?5string?5r@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2283 :                 }

	lea	ecx, DWORD PTR _e$10[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	edx, DWORD PTR tv1075[ebp]
$LN93@parse_stri:

; 2284 :               cp += parsed_chars;

	add	edi, esi
	jmp	$LN117@parse_stri
$LN89@parse_stri:

; 2285 :             }
; 2286 :           else if (*pp == 'B')

	cmp	al, 66					; 00000042H
	jne	$LN94@parse_stri

; 2287 :             {
; 2288 :               int old_ival = att->ival;

	mov	ebx, DWORD PTR tv1076[ebp]

; 2289 :               if (strncmp(cp,"yes",3) == 0)

	push	3
	push	OFFSET ??_C@_03ICICOMAL@yes?$AA@
	push	edi
	mov	esi, DWORD PTR [ebx+edx*4]
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN96@parse_stri

; 2290 :                 { att->ival = 1; cp += 3; }

	mov	edx, DWORD PTR tv1075[ebp]
	add	edi, 3
	mov	DWORD PTR [ebx+edx*4], 1
	jmp	$LN99@parse_stri
$LN96@parse_stri:

; 2291 :               else if (strncmp(cp,"no",2) == 0)

	push	2
	push	OFFSET ??_C@_02KAJCLHKP@no?$AA@
	push	edi
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN98@parse_stri

; 2292 :                 { att->ival = 0; cp += 2; }

	mov	edx, DWORD PTR tv1075[ebp]
	add	edi, 2
	mov	DWORD PTR [ebx+edx*4], eax

; 2293 :               else

	jmp	$LN99@parse_stri
$LN98@parse_stri:

; 2294 :                 { KDU_ERROR(e,54); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$9[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2294 :                 { KDU_ERROR(e,54); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	DWORD PTR _string$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0BH@DPGABFPI@Problem?5encountered?5at?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0EB@EHIGLBBC@Expected?5a?5boolean?5field?5identif@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2301 :                 }

	lea	ecx, DWORD PTR _e$9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	edx, DWORD PTR tv1075[ebp]
$LN99@parse_stri:

; 2302 :               if (!(att->is_set && (old_ival == att->ival)))

	cmp	BYTE PTR [ebx+edx*4+8], 0
	je	$LN118@parse_stri
	cmp	esi, DWORD PTR [ebx+edx*4]

; 2303 :                 new_change = true;
; 2304 :             }

	jmp	$LN519@parse_stri
$LN94@parse_stri:

; 2305 :           else if (*pp == '(')

	cmp	al, 40					; 00000028H
	jne	$LN102@parse_stri
	npad	2
$LL20@parse_stri:

; 2306 :             {
; 2307 :               char buf[80], *bp, *dp;
; 2308 :               int val;
; 2309 :               bool success = false;
; 2310 : 
; 2311 :               do {
; 2312 :                   pp = parse_translator_entry(pp+1,',',buf,80,val);

	lea	eax, DWORD PTR _val$2[ebp]
	push	eax
	push	80					; 00000050H
	lea	eax, DWORD PTR _buf$28[ebp]
	push	eax
	lea	eax, DWORD PTR [ebx+1]
	push	44					; 0000002cH
	push	eax
	call	?parse_translator_entry@@YAPBDPBDDQADHAAH@Z ; parse_translator_entry

; 2313 :                   for (bp=buf, dp=cp; *bp != '\0'; bp++, dp++)

	mov	cl, BYTE PTR _buf$28[ebp]
	lea	edx, DWORD PTR _buf$28[ebp]
	add	esp, 20					; 00000014H
	mov	ebx, eax
	mov	esi, edi
	test	cl, cl
	je	SHORT $LN443@parse_stri
	npad	7
$LL23@parse_stri:

; 2314 :                     if (*bp != *dp)

	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN443@parse_stri

; 2313 :                   for (bp=buf, dp=cp; *bp != '\0'; bp++, dp++)

	mov	cl, BYTE PTR [edx+1]
	inc	edx
	inc	esi
	test	cl, cl
	jne	SHORT $LL23@parse_stri

; 2315 :                       break;
; 2316 :                     success = (*bp == '\0') &&

	jmp	SHORT $LN484@parse_stri
$LN443@parse_stri:
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN125@parse_stri
$LN484@parse_stri:
	mov	al, BYTE PTR [esi]
	cmp	al, 44					; 0000002cH
	je	SHORT $LN124@parse_stri
	cmp	al, 125					; 0000007dH
	je	SHORT $LN124@parse_stri
	test	al, al
	jne	SHORT $LN125@parse_stri
$LN124@parse_stri:
	mov	al, 1
	jmp	SHORT $LN126@parse_stri
$LN125@parse_stri:
	xor	al, al
$LN126@parse_stri:

; 2317 :                       ((*dp==',') || (*dp=='}') || (*dp=='\0'));
; 2318 :                 } while ((*pp == ',') && !success);

	cmp	BYTE PTR [ebx], 44			; 0000002cH
	jne	SHORT $LN105@parse_stri
	test	al, al
	je	SHORT $LL20@parse_stri
$LN105@parse_stri:

; 2319 :               if (!success)

	test	al, al
	jne	$LN507@parse_stri

; 2320 :                 { KDU_ERROR(e,55);  e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2320 :                 { KDU_ERROR(e,55);  e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	DWORD PTR _string$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0BH@DPGABFPI@Problem?5encountered?5at?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2325 :                     display_options(att->pattern,e);

	mov	ebx, DWORD PTR tv1076[ebp]
	lea	eax, DWORD PTR _e$8[ebp]
	push	eax
	mov	eax, DWORD PTR tv1075[ebp]
	push	DWORD PTR [ebx+eax*4+4]
	call	?display_options@@YAXPBDAAVkdu_message@@@Z ; display_options
	add	esp, 8

; 2326 :                 }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	jmp	SHORT $LN106@parse_stri
$LN507@parse_stri:
	mov	ebx, DWORD PTR tv1076[ebp]
$LN106@parse_stri:

; 2327 :               if (!(att->is_set && (att->ival == val)))

	mov	edx, DWORD PTR tv1075[ebp]
	mov	eax, DWORD PTR _val$2[ebp]
	cmp	BYTE PTR [ebx+edx*4+8], 0
	je	SHORT $LN108@parse_stri
	cmp	DWORD PTR [ebx+edx*4], eax
	je	SHORT $LN107@parse_stri
$LN108@parse_stri:

; 2328 :                 new_change = true;

	mov	BYTE PTR _new_change$1$[ebp], 1
$LN107@parse_stri:

; 2329 :               att->ival = val;

	mov	DWORD PTR [ebx+edx*4], eax

; 2330 :               cp = dp;

	mov	edi, esi
	jmp	$LN117@parse_stri
$LN102@parse_stri:

; 2331 :             }
; 2332 :           else if (*pp == '[')
; 2333 :             {
; 2334 :               int old_val = att->ival;

	mov	ebx, DWORD PTR tv1076[ebp]
	cmp	al, 91					; 0000005bH
	jne	$LN117@parse_stri
	mov	eax, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR _old_val$1$[ebp], eax

; 2335 :               att->ival = 0;

	mov	DWORD PTR [ebx+edx*4], 0
	npad	2
$LL26@parse_stri:

; 2336 :               do {
; 2337 :                   char buf[80], *bp, *dp;
; 2338 :                   int val;
; 2339 :                   bool success = false;
; 2340 :                   
; 2341 :                   pp = att->pattern;
; 2342 :                   if (*cp == '|')

	cmp	BYTE PTR [edi], 124			; 0000007cH
	mov	ebx, DWORD PTR [ebx+edx*4+4]
	jne	SHORT $LL29@parse_stri

; 2343 :                     cp++;

	inc	edi
	npad	6
$LL29@parse_stri:

; 2344 :                   do {
; 2345 :                       pp = parse_translator_entry(pp+1,'|',buf,80,val);

	lea	eax, DWORD PTR _val$4[ebp]
	push	eax
	push	80					; 00000050H
	lea	eax, DWORD PTR _buf$27[ebp]
	push	eax
	lea	eax, DWORD PTR [ebx+1]
	push	124					; 0000007cH
	push	eax
	call	?parse_translator_entry@@YAPBDPBDDQADHAAH@Z ; parse_translator_entry

; 2346 :                       for (bp=buf, dp=cp; *bp != '\0'; bp++, dp++)

	mov	cl, BYTE PTR _buf$27[ebp]
	lea	edx, DWORD PTR _buf$27[ebp]
	add	esp, 20					; 00000014H
	mov	ebx, eax
	mov	esi, edi
	test	cl, cl
	je	SHORT $LN444@parse_stri
	npad	7
$LL32@parse_stri:

; 2347 :                         if (*bp != *dp)

	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN444@parse_stri

; 2346 :                       for (bp=buf, dp=cp; *bp != '\0'; bp++, dp++)

	mov	cl, BYTE PTR [edx+1]
	inc	edx
	inc	esi
	test	cl, cl
	jne	SHORT $LL32@parse_stri

; 2348 :                           break;
; 2349 :                         success = (*bp == '\0') &&

	jmp	SHORT $LN485@parse_stri
$LN444@parse_stri:
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN128@parse_stri
$LN485@parse_stri:
	mov	al, BYTE PTR [esi]
	cmp	al, 44					; 0000002cH
	je	SHORT $LN127@parse_stri
	cmp	al, 125					; 0000007dH
	je	SHORT $LN127@parse_stri
	cmp	al, 124					; 0000007cH
	je	SHORT $LN127@parse_stri
	test	al, al
	jne	SHORT $LN128@parse_stri
$LN127@parse_stri:
	mov	al, 1
	jmp	SHORT $LN129@parse_stri
$LN128@parse_stri:
	xor	al, al
$LN129@parse_stri:

; 2350 :                           ((*dp==',')||(*dp=='}')||(*dp=='|')||(*dp=='\0'));
; 2351 :                     } while ((*pp == '|') && !success);

	cmp	BYTE PTR [ebx], 124			; 0000007cH
	jne	SHORT $LN113@parse_stri
	test	al, al
	je	SHORT $LL29@parse_stri

; 2352 :                   if ((!success) && (*cp == '0') &&

	jmp	SHORT $LN500@parse_stri
$LN113@parse_stri:
	test	al, al
	jne	$LN506@parse_stri
	cmp	BYTE PTR [edi], 48			; 00000030H
	jne	SHORT $LN500@parse_stri
	mov	cl, BYTE PTR [edi+1]
	cmp	cl, 44					; 0000002cH
	je	SHORT $LN115@parse_stri
	cmp	cl, 125					; 0000007dH
	je	SHORT $LN115@parse_stri
	cmp	cl, 124					; 0000007cH
	je	SHORT $LN115@parse_stri
	test	cl, cl
	jne	SHORT $LN500@parse_stri
$LN115@parse_stri:

; 2353 :                       ((cp[1]==',') || (cp[1]=='}') ||
; 2354 :                        (cp[1]=='|') || (cp[1]=='\0')))
; 2355 :                     {
; 2356 :                       success = true;

	mov	al, 1

; 2357 :                       val = 0;

	mov	DWORD PTR _val$4[ebp], 0

; 2358 :                       dp = cp+1;

	lea	esi, DWORD PTR [edi+1]
$LN500@parse_stri:

; 2359 :                     }
; 2360 :                   if (!success)

	test	al, al
	jne	$LN506@parse_stri

; 2361 :                     { KDU_ERROR(e,56); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$7[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2361 :                     { KDU_ERROR(e,56); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 19		; 00000013H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	DWORD PTR _string$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_0BH@DPGABFPI@Problem?5encountered?5at?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2366 :                       display_options(att->pattern,e);

	mov	ebx, DWORD PTR tv1076[ebp]
	lea	eax, DWORD PTR _e$7[ebp]
	push	eax
	mov	eax, DWORD PTR tv1075[ebp]
	push	DWORD PTR [ebx+eax*4+4]
	call	?display_options@@YAXPBDAAVkdu_message@@@Z ; display_options
	add	esp, 8

; 2367 :                     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _e$7[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	jmp	SHORT $LN116@parse_stri
$LN506@parse_stri:
	mov	ebx, DWORD PTR tv1076[ebp]
$LN116@parse_stri:

; 2368 :                   att->ival |= val;

	mov	edx, DWORD PTR tv1075[ebp]

; 2369 :                   cp = dp;

	mov	edi, esi
	mov	eax, DWORD PTR _val$4[ebp]
	or	DWORD PTR [ebx+edx*4], eax

; 2370 :                 } while (*cp == '|');

	cmp	BYTE PTR [esi], 124			; 0000007cH
	je	$LL26@parse_stri

; 2371 :               if (!(att->is_set && (old_val == att->ival)))

	cmp	BYTE PTR [ebx+edx*4+8], 0
	je	SHORT $LN118@parse_stri
	mov	eax, DWORD PTR _old_val$1$[ebp]
	cmp	eax, DWORD PTR [ebx+edx*4]
$LN519@parse_stri:
	je	SHORT $LN117@parse_stri
$LN118@parse_stri:

; 2372 :                 new_change = true;

	mov	BYTE PTR _new_change$1$[ebp], 1
$LN117@parse_stri:

; 2219 :         }
; 2220 :       for (fld=0; fld < ap->num_fields; fld++)

	mov	esi, DWORD PTR _string$GSCopy$1$[ebp]

; 2373 :             }
; 2374 :           else
; 2375 :             assert(0);
; 2376 :           att->is_set = true;

	mov	BYTE PTR [ebx+edx*4+8], 1
	mov	edx, DWORD PTR _fld$1$[ebp]
	mov	ebx, DWORD PTR _ap$1$[ebp]
	inc	edx
	mov	DWORD PTR _fld$1$[ebp], edx
	cmp	edx, DWORD PTR [ebx+16]
	jl	$LL17@parse_stri
$LN16@parse_stri:

; 2377 :         }
; 2378 :       if (*cp == '}')

	cmp	BYTE PTR [edi], 125			; 0000007dH
	jne	SHORT $LN119@parse_stri

; 2379 :         cp++;

	inc	edi
$LN508@parse_stri:
	mov	esi, DWORD PTR _string$GSCopy$1$[ebp]
$LN121@parse_stri:

; 2389 :       rec++;

	mov	ecx, DWORD PTR _rec$1$[ebp]
	mov	al, BYTE PTR [edi]
	inc	ecx
	mov	DWORD PTR _rec$1$[ebp], ecx
	test	al, al
	jne	$LL13@parse_stri

; 2390 :     }
; 2391 : 
; 2392 :   if (new_change && !changed)

	mov	al, BYTE PTR _new_change$1$[ebp]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	test	al, al
	je	$LN122@parse_stri
	cmp	BYTE PTR [ecx+64], 0
	jne	$LN122@parse_stri

; 2393 :     {
; 2394 :       kdu_params *scan = this; scan->changed = true;
; 2395 :       scan = scan->first_inst; scan->changed = true;

	mov	eax, DWORD PTR [ecx+52]
	mov	BYTE PTR [ecx+64], 1
	mov	BYTE PTR [eax+64], 1

; 2396 :       scan = scan->refs[0]; scan->changed = true;

	mov	eax, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [eax]
	mov	BYTE PTR [eax+64], 1

; 2397 :       scan = scan->first_cluster; scan->changed = true;

	mov	eax, DWORD PTR [eax+36]
	mov	BYTE PTR [eax+64], 1

; 2401 :   return true;

	mov	al, 1
	mov	BYTE PTR [ecx+28], 0
	jmp	$LN1@parse_stri
$LN119@parse_stri:

; 2380 :       else if (open_record)

	cmp	BYTE PTR _open_record$1$[ebp], 0
	je	SHORT $LN508@parse_stri

; 2381 :         { KDU_ERROR(e,57); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0BL@HMOBPPGB@Malformed?5attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2381 :         { KDU_ERROR(e,57); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 20		; 00000014H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	mov	esi, DWORD PTR _string$GSCopy$1$[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_03BHOAIDAL@?$CC?$CB?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0BH@DPGABFPI@Problem?5encountered?5at?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0DM@ODMOHKAB@Opening?5brace?5for?5record?5is?5not?5@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2388 :         }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	jmp	$LN121@parse_stri
$LN511@parse_stri:
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
$LN122@parse_stri:

; 2398 :     }
; 2399 : 
; 2400 :   this->empty = false;

	mov	BYTE PTR [ecx+28], 0
$LN441@parse_stri:

; 2401 :   return true;

	mov	al, 1
	jmp	$LN1@parse_stri
$LN62@parse_stri:

; 2122 :       (this->inst_idx != target_inst))
; 2123 :     {
; 2124 :       kdu_params *target;
; 2125 : 
; 2126 :       target = access_relation(target_tile,target_comp,target_inst,false);

	push	0
	push	esi
	push	ebx
	push	edi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	esi, eax

; 2127 :       if (target == NULL)

	test	esi, esi
	jne	SHORT $LN63@parse_stri

; 2128 :         { KDU_ERROR(e,43); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$21[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$21[ebp]
	lea	ecx, DWORD PTR _e$21[ebp]
	push	OFFSET ??_C@_0BB@FCCGFNIO@Attribute?5string?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2128 :         { KDU_ERROR(e,43); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$21[ebp]
	lea	ecx, DWORD PTR _e$21[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$21[ebp]
	lea	ecx, DWORD PTR _e$21[ebp]
	push	DWORD PTR _string$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$21[ebp]
	lea	ecx, DWORD PTR _e$21[ebp]
	push	OFFSET ??_C@_03HAFDNMHA@?$CC?0?5?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$21[ebp]
	lea	ecx, DWORD PTR _e$21[ebp]
	push	OFFSET ??_C@_0CJ@BPCCBEIL@refers?5to?5a?5non?9existent?5tile?9co@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2132 :         }

	lea	ecx, DWORD PTR _e$21[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN63@parse_stri:

; 2133 :       return target->parse_string(string);

	push	DWORD PTR _string$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?parse_string@kdu_params@@QAE_NPBD@Z	; kdu_params::parse_string
	jmp	$LN1@parse_stri
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$0:
	lea	ecx, DWORD PTR _e$26[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$1:
	lea	ecx, DWORD PTR _e$25[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$2:
	lea	ecx, DWORD PTR _e$24[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$3:
	lea	ecx, DWORD PTR _e$23[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$4:
	lea	ecx, DWORD PTR _e$22[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$6:
	lea	ecx, DWORD PTR _e$20[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$7:
	lea	ecx, DWORD PTR _e$19[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$8:
	lea	ecx, DWORD PTR _e$18[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$9:
	lea	ecx, DWORD PTR _e$17[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$10:
	lea	ecx, DWORD PTR _e$16[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$11:
	lea	ecx, DWORD PTR _e$15[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$12:
	lea	ecx, DWORD PTR _e$14[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$13:
	lea	ecx, DWORD PTR _e$13[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$14:
	lea	ecx, DWORD PTR _e$12[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$15:
	lea	ecx, DWORD PTR _e$11[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$16:
	lea	ecx, DWORD PTR _e$10[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$17:
	lea	ecx, DWORD PTR _e$9[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$18:
	lea	ecx, DWORD PTR _e$8[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$19:
	lea	ecx, DWORD PTR _e$7[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$20:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?parse_string@kdu_params@@QAE_NPBD@Z$5:
	lea	ecx, DWORD PTR _e$21[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?parse_string@kdu_params@@QAE_NPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-196]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?parse_string@kdu_params@@QAE_NPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?parse_string@kdu_params@@QAE_NPBD@Z ENDP		; kdu_params::parse_string
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?set_derived@kdu_params@@QAEXPBD@Z
_TEXT	SEGMENT
_e$2 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
?set_derived@kdu_params@@QAEXPBD@Z PROC			; kdu_params::set_derived, COMDAT
; _this$ = ecx

; 2005 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?set_derived@kdu_params@@QAEXPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2006 :   kd_attribute *ap;
; 2007 : 
; 2008 :   if ((ap=match_attribute(attributes,name)) == NULL)

	push	DWORD PTR _name$[ebp]
	push	DWORD PTR [ecx+60]
	call	?match_attribute@@YAPAUkd_attribute@@PAU1@PBD@Z ; match_attribute
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN15@set_derive

; 2009 :     { KDU_ERROR_DEV(e,39); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BH@HIFAHFHM@Invalid?5attribute?5name?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2009 :     { KDU_ERROR_DEV(e,39); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	DWORD PTR _name$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_03HAFDNMHA@?$CC?0?5?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0DE@NFMHJCHA@supplied?5to?5the?5?$GAkdu_params?3?3set@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2013 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN15@set_derive:

; 2014 :   ap->derived = true;

	mov	BYTE PTR [esi+28], 1

; 2015 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?set_derived@kdu_params@@QAEXPBD@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?set_derived@kdu_params@@QAEXPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?set_derived@kdu_params@@QAEXPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?set_derived@kdu_params@@QAEXPBD@Z ENDP			; kdu_params::set_derived
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?set@kdu_params@@QAEXPBDHHN@Z
_TEXT	SEGMENT
_e$2 = -148						; size = 20
_record_idx$GSCopy$1$ = -128				; size = 4
_name$GSCopy$1$ = -124					; size = 4
_e$3 = -120						; size = 20
_e$4 = -120						; size = 20
_e$5 = -120						; size = 20
_new_change$1$ = -97					; size = 1
_text$6 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_record_idx$ = 12					; size = 4
_field_idx$ = 16					; size = 4
_value$ = 20						; size = 8
?set@kdu_params@@QAEXPBDHHN@Z PROC			; kdu_params::set, COMDAT
; _this$ = ecx

; 1943 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?set@kdu_params@@QAEXPBDHHN@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR _name$[ebp]
	mov	ecx, DWORD PTR _record_idx$[ebp]
	mov	ebx, DWORD PTR _field_idx$[ebp]

; 1944 :   kd_attribute *ap;
; 1945 :   char const *cp;
; 1946 : 
; 1947 :   assert((record_idx >= 0) && (field_idx >= 0));
; 1948 :   if ((ap=match_attribute(attributes,name)) == NULL)

	push	eax
	push	DWORD PTR [edi+60]
	mov	DWORD PTR _name$GSCopy$1$[ebp], eax
	mov	DWORD PTR _record_idx$GSCopy$1$[ebp], ecx
	call	?match_attribute@@YAPAUkd_attribute@@PAU1@PBD@Z ; match_attribute
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN2@set

; 1949 :     { KDU_ERROR_DEV(e,35); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0DO@JOGJAIGA@Attempt?5to?5set?5a?5code?9stream?5att@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1949 :     { KDU_ERROR_DEV(e,35); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_02LHOIKBIA@?$CC?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1953 :     }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@set:

; 1954 :   if ((ap->flags & ALL_COMPONENTS) && (comp_idx != -1))

	test	BYTE PTR [esi+8], 4
	je	SHORT $LN3@set
	cmp	DWORD PTR [edi+12], -1
	je	SHORT $LN3@set

; 1955 :     { KDU_ERROR_DEV(e,36); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0GI@PNBMMBJE@Attempt?5to?5set?5a?5non?9tile?9specif@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1955 :     { KDU_ERROR_DEV(e,36); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1960 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN3@set:

; 1961 :   if (field_idx >= ap->num_fields)

	cmp	ebx, DWORD PTR [esi+16]
	jl	$LN4@set

; 1962 :     { KDU_ERROR_DEV(e,37); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0FL@DIDANAGC@Attempt?5to?5set?5a?5code?9stream?5att@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1962 :     { KDU_ERROR_DEV(e,37); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BE@NMPECGEH@The?5field?5index?5is?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$3[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	ebx
	push	eax
	lea	eax, DWORD PTR _text$6[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$6[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1968 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN4@set:

; 1969 :   cp = ap->values[field_idx].pattern;

	mov	eax, DWORD PTR [esi+24]
	lea	ecx, DWORD PTR [ebx+ebx*2]
	mov	eax, DWORD PTR [eax+ecx*4+4]

; 1970 :   if (*cp != 'F')

	cmp	BYTE PTR [eax], 70			; 00000046H
	je	SHORT $LN5@set

; 1971 :     { KDU_ERROR_DEV(e,38); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0IA@DFMOHAGA@Attempting?5to?5set?5an?5integer?5cod@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1971 :     { KDU_ERROR_DEV(e,38); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1976 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN5@set:

; 1977 :   bool new_change = false;
; 1978 :   if (record_idx >= ap->num_records)

	mov	eax, DWORD PTR _record_idx$GSCopy$1$[ebp]
	mov	BYTE PTR _new_change$1$[ebp], 0
	cmp	eax, DWORD PTR [esi+20]
	jl	SHORT $LN6@set

; 1979 :     {
; 1980 :       ap->augment_records(record_idx+1);

	inc	eax
	mov	ecx, esi
	push	eax
	call	?augment_records@kd_attribute@@QAEXH@Z	; kd_attribute::augment_records

; 1981 :       new_change = true;

	mov	BYTE PTR _new_change$1$[ebp], 1
$LN6@set:

; 1982 :     }
; 1983 :   assert((record_idx >= 0) && (record_idx < ap->num_records));
; 1984 :   att_val *av = ap->values + field_idx+ap->num_fields*record_idx;

	mov	eax, DWORD PTR [esi+16]
	imul	eax, DWORD PTR _record_idx$GSCopy$1$[ebp]
	mov	edx, DWORD PTR [esi+24]

; 1985 :   if (!(av->is_set && (av->fval == (float) value)))

	movsd	xmm2, QWORD PTR _value$[ebp]
	add	eax, ebx
	lea	ecx, DWORD PTR [eax+eax*2]
	cmp	BYTE PTR [edx+ecx*4+8], 0
	je	SHORT $LN53@set
	movss	xmm0, DWORD PTR [edx+ecx*4]
	cvtpd2ps xmm1, xmm2
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN53@set

; 1986 :     new_change = true;
; 1987 :   if (new_change && !changed)

	cmp	BYTE PTR _new_change$1$[ebp], 0
	je	SHORT $LN9@set
$LN53@set:
	cmp	BYTE PTR [edi+64], 0
	jne	SHORT $LN9@set

; 1988 :     {
; 1989 :       kdu_params *scan = this; scan->changed = true;
; 1990 :       scan = scan->first_inst; scan->changed = true;

	mov	eax, DWORD PTR [edi+52]
	mov	BYTE PTR [edi+64], 1
	mov	BYTE PTR [eax+64], 1

; 1991 :       scan = scan->refs[0]; scan->changed = true;

	mov	eax, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [eax]
	mov	BYTE PTR [eax+64], 1

; 1992 :       scan = scan->first_cluster; scan->changed = true;

	mov	eax, DWORD PTR [eax+36]
	mov	BYTE PTR [eax+64], 1
$LN9@set:

; 1993 :     }
; 1994 :   av->is_set = true;
; 1995 :   av->fval = (float) value;

	cvtpd2ps xmm0, xmm2
	mov	BYTE PTR [edx+ecx*4+8], 1
	movss	DWORD PTR [edx+ecx*4], xmm0

; 1996 :   this->empty = false;

	mov	BYTE PTR [edi+28], 0

; 1997 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?set@kdu_params@@QAEXPBDHHN@Z$0:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?set@kdu_params@@QAEXPBDHHN@Z$1:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?set@kdu_params@@QAEXPBDHHN@Z$2:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?set@kdu_params@@QAEXPBDHHN@Z$3:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?set@kdu_params@@QAEXPBDHHN@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?set@kdu_params@@QAEXPBDHHN@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?set@kdu_params@@QAEXPBDHHN@Z ENDP			; kdu_params::set
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?set@kdu_params@@QAEXPBDHH_N@Z
_TEXT	SEGMENT
_e$2 = -144						; size = 20
_record_idx$GSCopy$1$ = -124				; size = 4
_name$GSCopy$1$ = -120					; size = 4
_e$3 = -116						; size = 20
_e$4 = -116						; size = 20
_e$5 = -116						; size = 20
_text$6 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_record_idx$ = 12					; size = 4
_field_idx$ = 16					; size = 4
_value$ = 20						; size = 1
?set@kdu_params@@QAEXPBDHH_N@Z PROC			; kdu_params::set, COMDAT
; _this$ = ecx

; 1881 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?set@kdu_params@@QAEXPBDHH_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR _name$[ebp]
	mov	ecx, DWORD PTR _record_idx$[ebp]
	mov	ebx, DWORD PTR _field_idx$[ebp]

; 1882 :   kd_attribute *ap;
; 1883 :   char const *cp;
; 1884 : 
; 1885 :   assert((record_idx >= 0) && (field_idx >= 0));
; 1886 :   if ((ap=match_attribute(attributes,name)) == NULL)

	push	eax
	push	DWORD PTR [edi+60]
	mov	DWORD PTR _name$GSCopy$1$[ebp], eax
	mov	DWORD PTR _record_idx$GSCopy$1$[ebp], ecx
	call	?match_attribute@@YAPAUkd_attribute@@PAU1@PBD@Z ; match_attribute
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN2@set

; 1887 :     { KDU_ERROR_DEV(e,31);  e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0DO@JOGJAIGA@Attempt?5to?5set?5a?5code?9stream?5att@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1887 :     { KDU_ERROR_DEV(e,31);  e <<

	mov	DWORD PTR __$EHRec$[ebp+8], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_02LHOIKBIA@?$CC?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1891 :     }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@set:

; 1892 :   if ((ap->flags & ALL_COMPONENTS) && (comp_idx != -1))

	test	BYTE PTR [esi+8], 4
	je	SHORT $LN3@set
	cmp	DWORD PTR [edi+12], -1
	je	SHORT $LN3@set

; 1893 :     { KDU_ERROR_DEV(e,32); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0GI@PNBMMBJE@Attempt?5to?5set?5a?5non?9tile?9specif@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1893 :     { KDU_ERROR_DEV(e,32); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1898 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN3@set:

; 1899 :   if (field_idx >= ap->num_fields)

	cmp	ebx, DWORD PTR [esi+16]
	jl	$LN4@set

; 1900 :     { KDU_ERROR_DEV(e,33);  e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0FL@DIDANAGC@Attempt?5to?5set?5a?5code?9stream?5att@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1900 :     { KDU_ERROR_DEV(e,33);  e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BE@NMPECGEH@The?5field?5index?5is?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$3[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	ebx
	push	eax
	lea	eax, DWORD PTR _text$6[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$6[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1906 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN4@set:

; 1907 :   cp = ap->values[field_idx].pattern;

	mov	eax, DWORD PTR [esi+24]
	lea	ecx, DWORD PTR [ebx+ebx*2]
	mov	eax, DWORD PTR [eax+ecx*4+4]

; 1908 :   if (*cp != 'B')

	cmp	BYTE PTR [eax], 66			; 00000042H
	je	SHORT $LN5@set

; 1909 :     { KDU_ERROR_DEV(e,34); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0HM@KMNJIEPO@Attempting?5to?5set?5a?5non?9boolean?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1909 :     { KDU_ERROR_DEV(e,34); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1914 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN5@set:

; 1915 :   bool new_change = false;
; 1916 :   if (record_idx >= ap->num_records)

	mov	eax, DWORD PTR _record_idx$GSCopy$1$[ebp]
	xor	dl, dl
	cmp	eax, DWORD PTR [esi+20]
	jl	SHORT $LN6@set

; 1917 :     {
; 1918 :       ap->augment_records(record_idx+1);

	inc	eax
	mov	ecx, esi
	push	eax
	call	?augment_records@kd_attribute@@QAEXH@Z	; kd_attribute::augment_records

; 1919 :       new_change = true;

	mov	dl, 1
$LN6@set:

; 1920 :     }
; 1921 :   assert((record_idx >= 0) && (record_idx < ap->num_records));
; 1922 :   att_val *av = ap->values + field_idx+ap->num_fields*record_idx;

	mov	eax, DWORD PTR [esi+16]
	imul	eax, DWORD PTR _record_idx$GSCopy$1$[ebp]
	add	eax, ebx

; 1923 :   if (!(av->is_set && (av->ival == ((value)?1:0))))

	mov	bl, BYTE PTR _value$[ebp]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+24]
	cmp	BYTE PTR [eax+ecx*4+8], 0
	lea	ecx, DWORD PTR [eax+ecx*4]
	je	SHORT $LN53@set
	xor	eax, eax
	test	bl, bl
	setne	al
	cmp	DWORD PTR [ecx], eax
	jne	SHORT $LN53@set

; 1924 :     new_change = true;
; 1925 :   if (new_change && !changed)

	test	dl, dl
	je	SHORT $LN9@set
$LN53@set:
	cmp	BYTE PTR [edi+64], 0
	jne	SHORT $LN9@set

; 1926 :     {
; 1927 :       kdu_params *scan = this; scan->changed = true;
; 1928 :       scan = scan->first_inst; scan->changed = true;

	mov	eax, DWORD PTR [edi+52]
	mov	BYTE PTR [edi+64], 1
	mov	BYTE PTR [eax+64], 1

; 1929 :       scan = scan->refs[0]; scan->changed = true;

	mov	eax, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [eax]
	mov	BYTE PTR [eax+64], 1

; 1930 :       scan = scan->first_cluster; scan->changed = true;

	mov	eax, DWORD PTR [eax+36]
	mov	BYTE PTR [eax+64], 1
$LN9@set:

; 1931 :     }
; 1932 :   av->is_set = true;
; 1933 :   av->ival = (value)?1:0;

	xor	eax, eax
	mov	BYTE PTR [ecx+8], 1
	test	bl, bl
	setne	al
	mov	DWORD PTR [ecx], eax

; 1934 :   this->empty = false;

	mov	BYTE PTR [edi+28], 0

; 1935 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?set@kdu_params@@QAEXPBDHH_N@Z$0:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?set@kdu_params@@QAEXPBDHH_N@Z$1:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?set@kdu_params@@QAEXPBDHH_N@Z$2:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?set@kdu_params@@QAEXPBDHH_N@Z$3:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?set@kdu_params@@QAEXPBDHH_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-148]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?set@kdu_params@@QAEXPBDHH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?set@kdu_params@@QAEXPBDHH_N@Z ENDP			; kdu_params::set
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?set@kdu_params@@QAEXPBDHHH@Z
_TEXT	SEGMENT
_e$2 = -156						; size = 20
_val$3 = -136						; size = 4
_record_idx$GSCopy$1$ = -132				; size = 4
_field_idx$GSCopy$1$ = -128				; size = 4
_name$GSCopy$1$ = -124					; size = 4
_this$GSCopy$1$ = -120					; size = 4
_val$4 = -120						; size = 4
_e$5 = -116						; size = 20
_e$6 = -116						; size = 20
_e$7 = -116						; size = 20
_e$8 = -116						; size = 20
_e$9 = -116						; size = 20
_e$10 = -116						; size = 20
_text$11 = -96						; size = 80
_buf$12 = -96						; size = 80
_buf$13 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_record_idx$ = 12					; size = 4
_field_idx$ = 16					; size = 4
_value$ = 20						; size = 4
?set@kdu_params@@QAEXPBDHHH@Z PROC			; kdu_params::set, COMDAT
; _this$ = ecx

; 1773 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?set@kdu_params@@QAEXPBDHHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi
	mov	esi, DWORD PTR _name$[ebp]
	mov	ecx, DWORD PTR _record_idx$[ebp]

; 1774 :   kd_attribute *ap;
; 1775 :   char const *cp;
; 1776 : 
; 1777 :   assert((record_idx >= 0) && (field_idx >= 0));
; 1778 :   if ((ap=match_attribute(attributes,name)) == NULL)

	push	esi
	push	DWORD PTR [edi+60]
	mov	DWORD PTR _record_idx$GSCopy$1$[ebp], ecx
	mov	ecx, DWORD PTR _field_idx$[ebp]
	mov	DWORD PTR _name$GSCopy$1$[ebp], esi
	mov	DWORD PTR _field_idx$GSCopy$1$[ebp], ecx
	call	?match_attribute@@YAPAUkd_attribute@@PAU1@PBD@Z ; match_attribute
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	jne	SHORT $LN8@set

; 1779 :     { KDU_ERROR_DEV(e,24); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$10[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0DO@JOGJAIGA@Attempt?5to?5set?5a?5code?9stream?5att@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1779 :     { KDU_ERROR_DEV(e,24); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_02LHOIKBIA@?$CC?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1783 :     }

	lea	ecx, DWORD PTR _e$10[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN8@set:

; 1784 :   if ((ap->flags & ALL_COMPONENTS) && (comp_idx != -1))

	test	BYTE PTR [ebx+8], 4
	je	SHORT $LN9@set
	cmp	DWORD PTR [edi+12], -1
	je	SHORT $LN9@set

; 1785 :     { KDU_ERROR_DEV(e,25); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$9[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0GI@PNBMMBJE@Attempt?5to?5set?5a?5non?9tile?9specif@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1785 :     { KDU_ERROR_DEV(e,25); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1789 :     }

	lea	ecx, DWORD PTR _e$9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN9@set:

; 1790 :   if (field_idx >= ap->num_fields)

	mov	eax, DWORD PTR _field_idx$GSCopy$1$[ebp]
	cmp	eax, DWORD PTR [ebx+16]
	jl	$LN10@set

; 1791 :     { KDU_ERROR_DEV(e,26); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0FL@DIDANAGC@Attempt?5to?5set?5a?5code?9stream?5att@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1791 :     { KDU_ERROR_DEV(e,26); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0BE@NMPECGEH@The?5field?5index?5is?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	mov	ecx, DWORD PTR _field_idx$GSCopy$1$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmp	BYTE PTR _e$8[ebp+4], 0
	push	ecx
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$11[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$11[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	eax
	mov	eax, DWORD PTR _e$8[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1796 :     }

	lea	ecx, DWORD PTR _e$8[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _field_idx$GSCopy$1$[ebp]
$LN10@set:

; 1797 :   cp = ap->values[field_idx].pattern;
; 1798 :   if (*cp == 'F')

	mov	esi, DWORD PTR _value$[ebp]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ebx+24]
	mov	ecx, DWORD PTR [eax+ecx*4+4]
	mov	al, BYTE PTR [ecx]
	cmp	al, 70					; 00000046H
	jne	SHORT $LN11@set

; 1799 :     { KDU_ERROR_DEV(e,27);  e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$7[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_0HP@BOHKEADG@Attempting?5to?5set?5a?5floating?5poi@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1799 :     { KDU_ERROR_DEV(e,27);  e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1804 :     }

	lea	ecx, DWORD PTR _e$7[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	jmp	$LN23@set
$LN11@set:

; 1805 :   else if (*cp == 'B')

	cmp	al, 66					; 00000042H
	jne	SHORT $LN13@set

; 1806 :     {
; 1807 :       if ((value & 1) != value)

	mov	eax, esi
	and	eax, 1
	cmp	eax, esi
	je	$LN23@set

; 1808 :         { KDU_ERROR_DEV(e,28); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$6[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	OFFSET ??_C@_0HN@MGKBDNAF@Attempting?5to?5set?5a?5boolean?5code@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1808 :         { KDU_ERROR_DEV(e,28); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1813 :         }

	lea	ecx, DWORD PTR _e$6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error

; 1814 :     }

	jmp	$LN23@set
$LN13@set:

; 1815 :   else if (*cp == '(')

	cmp	al, 40					; 00000028H
	jne	$LN16@set
	npad	7
$LL4@set:

; 1816 :     {
; 1817 :       char buf[80];
; 1818 :       int val;
; 1819 : 
; 1820 :       do {
; 1821 :           cp = parse_translator_entry(cp+1,',',buf,80,val);

	lea	eax, DWORD PTR _val$4[ebp]
	push	eax
	push	80					; 00000050H
	lea	eax, DWORD PTR _buf$13[ebp]
	push	eax
	lea	eax, DWORD PTR [ecx+1]
	push	44					; 0000002cH
	push	eax
	call	?parse_translator_entry@@YAPBDPBDDQADHAAH@Z ; parse_translator_entry
	mov	ecx, eax
	add	esp, 20					; 00000014H

; 1822 :         } while ((*cp == ',') && (val != value));

	cmp	BYTE PTR [ecx], 44			; 0000002cH
	jne	SHORT $LN18@set
	cmp	DWORD PTR _val$4[ebp], esi
	jne	SHORT $LL4@set

; 1823 :       if (val != value)

	jmp	$LN23@set
$LN18@set:
	cmp	DWORD PTR _val$4[ebp], esi
	je	$LN23@set

; 1824 :         { KDU_ERROR_DEV(e,29); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0KH@JEELPMNH@Attempting?5to?5set?5a?5code?9stream?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1824 :         { KDU_ERROR_DEV(e,29); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1830 :         }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error

; 1831 :     }

	jmp	$LN23@set
$LN16@set:

; 1832 :   else if (*cp == '[')

	cmp	al, 91					; 0000005bH
	jne	$LN23@set

; 1833 :     {
; 1834 :       char buf[80];
; 1835 :       int val, tmp=0;

	xor	edi, edi
	npad	6
$LL7@set:

; 1836 : 
; 1837 :       do {
; 1838 :           cp = parse_translator_entry(cp+1,'|',buf,80,val);

	lea	eax, DWORD PTR _val$3[ebp]
	push	eax
	push	80					; 00000050H
	lea	eax, DWORD PTR _buf$12[ebp]
	push	eax
	lea	eax, DWORD PTR [ecx+1]
	push	124					; 0000007cH
	push	eax
	call	?parse_translator_entry@@YAPBDPBDDQADHAAH@Z ; parse_translator_entry

; 1839 :           if ((value & val) == val)

	mov	edx, DWORD PTR _val$3[ebp]
	mov	ecx, eax
	mov	eax, edx
	add	esp, 20					; 00000014H
	and	eax, esi
	cmp	eax, edx
	jne	SHORT $LN5@set

; 1840 :             tmp |= val; // Word contains this flag (or this set of flags).

	or	edi, edx
$LN5@set:

; 1841 :         } while (*cp == '|');

	cmp	BYTE PTR [ecx], 124			; 0000007cH
	je	SHORT $LL7@set

; 1842 :       if (tmp != value)

	cmp	edi, esi
	je	SHORT $LN105@set

; 1843 :         { KDU_ERROR_DEV(e,30);  e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0JJ@BKCJHECD@Attempting?5to?5set?5a?5code?9stream?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1843 :         { KDU_ERROR_DEV(e,30);  e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1849 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN105@set:
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN23@set:

; 1850 :     }
; 1851 :   else
; 1852 :     assert((*cp == 'I') || (*cp == 'C'));
; 1853 :   bool new_change = false;
; 1854 :   if (record_idx >= ap->num_records)

	mov	eax, DWORD PTR _record_idx$GSCopy$1$[ebp]
	xor	dl, dl
	cmp	eax, DWORD PTR [ebx+20]
	jl	SHORT $LN24@set

; 1855 :     {
; 1856 :       ap->augment_records(record_idx+1);

	inc	eax
	mov	ecx, ebx
	push	eax
	call	?augment_records@kd_attribute@@QAEXH@Z	; kd_attribute::augment_records

; 1857 :       new_change = true;

	mov	dl, 1
$LN24@set:

; 1858 :     }
; 1859 :   assert((record_idx >= 0) && (record_idx < ap->num_records));
; 1860 :   att_val *av = ap->values + field_idx+ap->num_fields*record_idx;

	mov	eax, DWORD PTR [ebx+16]
	imul	eax, DWORD PTR _record_idx$GSCopy$1$[ebp]
	add	eax, DWORD PTR _field_idx$GSCopy$1$[ebp]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ebx+24]

; 1861 :   if (!(av->is_set && (av->ival == value)))

	cmp	BYTE PTR [eax+ecx*4+8], 0
	lea	ecx, DWORD PTR [eax+ecx*4]
	je	SHORT $LN104@set
	cmp	DWORD PTR [ecx], esi
	jne	SHORT $LN104@set

; 1862 :     new_change = true;
; 1863 :   if (new_change && !changed)

	test	dl, dl
	je	SHORT $LN27@set
$LN104@set:
	cmp	BYTE PTR [edi+64], 0
	jne	SHORT $LN27@set

; 1864 :     {
; 1865 :       kdu_params *scan = this; scan->changed = true;
; 1866 :       scan = scan->first_inst; scan->changed = true;

	mov	eax, DWORD PTR [edi+52]
	mov	BYTE PTR [edi+64], 1
	mov	BYTE PTR [eax+64], 1

; 1867 :       scan = scan->refs[0]; scan->changed = true;

	mov	eax, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [eax]
	mov	BYTE PTR [eax+64], 1

; 1868 :       scan = scan->first_cluster; scan->changed = true;

	mov	eax, DWORD PTR [eax+36]
	mov	BYTE PTR [eax+64], 1
$LN27@set:

; 1869 :     }
; 1870 :   av->is_set = true;

	mov	BYTE PTR [ecx+8], 1

; 1871 :   av->ival = value;

	mov	DWORD PTR [ecx], esi

; 1872 :   this->empty = false;

	mov	BYTE PTR [edi+28], 0

; 1873 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$0:
	lea	ecx, DWORD PTR _e$10[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$1:
	lea	ecx, DWORD PTR _e$9[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$2:
	lea	ecx, DWORD PTR _e$8[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$3:
	lea	ecx, DWORD PTR _e$7[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$4:
	lea	ecx, DWORD PTR _e$6[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$5:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?set@kdu_params@@QAEXPBDHHH@Z$6:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?set@kdu_params@@QAEXPBDHHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?set@kdu_params@@QAEXPBDHHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?set@kdu_params@@QAEXPBDHHH@Z ENDP			; kdu_params::set
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?compare@kdu_params@@QAE_NPBDHHM@Z
_TEXT	SEGMENT
_val$ = -4						; size = 4
_name$ = 8						; size = 4
_record_idx$ = 12					; size = 4
_field_idx$ = 16					; size = 4
_value$ = 20						; size = 4
?compare@kdu_params@@QAE_NPBDHHM@Z PROC			; kdu_params::compare, COMDAT
; _this$ = ecx

; 1242 :       { float val;

	push	ebp
	mov	ebp, esp
	push	ecx

; 1243 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	DWORD PTR _field_idx$[ebp]
	push	DWORD PTR _record_idx$[ebp]
	push	DWORD PTR _name$[ebp]
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN3@compare
	movss	xmm0, DWORD PTR _val$[ebp]
	ucomiss	xmm0, DWORD PTR _value$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@compare
	mov	al, 1
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@compare:
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?compare@kdu_params@@QAE_NPBDHHM@Z ENDP			; kdu_params::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?compare@kdu_params@@QAE_NPBDHH_N@Z
_TEXT	SEGMENT
_val$ = -1						; size = 1
_name$ = 8						; size = 4
_record_idx$ = 12					; size = 4
_field_idx$ = 16					; size = 4
_value$ = 20						; size = 1
?compare@kdu_params@@QAE_NPBDHH_N@Z PROC		; kdu_params::compare, COMDAT
; _this$ = ecx

; 1236 :       { bool val;

	push	ebp
	mov	ebp, esp
	push	ecx

; 1237 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	DWORD PTR _field_idx$[ebp]
	push	DWORD PTR _record_idx$[ebp]
	push	DWORD PTR _name$[ebp]
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN3@compare
	mov	al, BYTE PTR _val$[ebp]
	cmp	al, BYTE PTR _value$[ebp]
	jne	SHORT $LN3@compare
	mov	al, 1
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@compare:
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?compare@kdu_params@@QAE_NPBDHH_N@Z ENDP		; kdu_params::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?compare@kdu_params@@QAE_NPBDHHH@Z
_TEXT	SEGMENT
_val$ = -4						; size = 4
_name$ = 8						; size = 4
_record_idx$ = 12					; size = 4
_field_idx$ = 16					; size = 4
_value$ = 20						; size = 4
?compare@kdu_params@@QAE_NPBDHHH@Z PROC			; kdu_params::compare, COMDAT
; _this$ = ecx

; 1217 :       { int val;

	push	ebp
	mov	ebp, esp
	push	ecx

; 1218 :         return (get(name,record_idx,field_idx,val) && (val==value)); }

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	DWORD PTR _field_idx$[ebp]
	push	DWORD PTR _record_idx$[ebp]
	push	DWORD PTR _name$[ebp]
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN3@compare
	mov	eax, DWORD PTR _val$[ebp]
	cmp	eax, DWORD PTR _value$[ebp]
	jne	SHORT $LN3@compare
	mov	al, 1
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@compare:
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?compare@kdu_params@@QAE_NPBDHHH@Z ENDP			; kdu_params::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?get@kdu_params@@QAE_NPBDHHAAM_N22@Z
_TEXT	SEGMENT
_e$2 = -152						; size = 20
_att_ptr$1$ = -132					; size = 4
_value$GSCopy$1$ = -128					; size = 4
_e$3 = -124						; size = 20
_e$4 = -124						; size = 20
_name$GSCopy$1$ = -104					; size = 4
_field_idx$GSCopy$1$ = -100				; size = 4
_text$5 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_record_idx$ = 12					; size = 4
_field_idx$ = 16					; size = 4
_value$ = 20						; size = 4
_allow_inherit$ = 24					; size = 1
_allow_extend$ = 28					; size = 1
_allow_derived$ = 32					; size = 1
?get@kdu_params@@QAE_NPBDHHAAM_N22@Z PROC		; kdu_params::get, COMDAT
; _this$ = ecx

; 1706 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get@kdu_params@@QAE_NPBDHHAAM_N22@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ecx, DWORD PTR _name$[ebp]
	mov	eax, DWORD PTR _field_idx$[ebp]
	mov	edi, DWORD PTR _record_idx$[ebp]

; 1707 :   kd_attribute *ap;
; 1708 :   att_val *att_ptr;
; 1709 : 
; 1710 :   assert((record_idx >= 0) && (field_idx >= 0));
; 1711 :   if ((ap=match_attribute(attributes,name)) == NULL)

	push	ecx
	push	DWORD PTR [esi+60]
	mov	DWORD PTR _field_idx$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _name$GSCopy$1$[ebp], ecx
	mov	DWORD PTR _value$GSCopy$1$[ebp], eax
	call	?match_attribute@@YAPAUkd_attribute@@PAU1@PBD@Z ; match_attribute
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	jne	SHORT $LN2@get

; 1712 :     { KDU_ERROR_DEV(e,21); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0EB@JLDBDJJO@Attempt?5to?5access?5a?5code?9stream?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1712 :     { KDU_ERROR_DEV(e,21); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_02LHOIKBIA@?$CC?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1716 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@get:

; 1717 :   if (field_idx >= ap->num_fields)

	mov	eax, DWORD PTR _field_idx$GSCopy$1$[ebp]
	cmp	eax, DWORD PTR [ebx+16]
	jl	$LN3@get

; 1718 :     { KDU_ERROR_DEV(e,22); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0FO@BDPPHOIA@Attempt?5to?5access?5a?5code?9stream?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1718 :     { KDU_ERROR_DEV(e,22); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BE@NMPECGEH@The?5field?5index?5is?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$3[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _field_idx$GSCopy$1$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$5[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$5[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1724 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _field_idx$GSCopy$1$[ebp]
$LN3@get:

; 1725 :   att_ptr = ap->values + field_idx;

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ebx+24]
	lea	edx, DWORD PTR [eax+ecx*4]

; 1726 :   if (att_ptr->pattern[0] != 'F')

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _att_ptr$1$[ebp], edx
	cmp	BYTE PTR [eax], 70			; 00000046H
	je	SHORT $LN4@get

; 1727 :     { KDU_ERROR_DEV(e,23); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0ID@NIKNNMAJ@Attempting?5to?5access?5an?5integer?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1727 :     { KDU_ERROR_DEV(e,23); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1732 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	edx, DWORD PTR _att_ptr$1$[ebp]
$LN4@get:

; 1733 : 
; 1734 :   bool have_attribute = (ap->num_records > 0);

	mov	ecx, DWORD PTR [ebx+20]
	test	ecx, ecx
	setg	al

; 1735 :   if (ap->derived && !allow_derived)

	cmp	BYTE PTR [ebx+28], 0
	je	SHORT $LN5@get
	cmp	BYTE PTR _allow_derived$[ebp], 0
	je	SHORT $LN48@get
$LN5@get:

; 1736 :     have_attribute = false;
; 1737 : 
; 1738 :   if ((!have_attribute) && allow_inherit &&

	test	al, al
	jne	$LN10@get
$LN48@get:
	cmp	BYTE PTR _allow_inherit$[ebp], 0
	je	$LN13@get
	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN7@get
	cmp	BYTE PTR [esi+34], 0
	je	SHORT $LN13@get
$LN7@get:

; 1739 :       ((inst_idx == 0) || treat_instances_like_components))
; 1740 :     { // Try inheritance.
; 1741 :       kdu_params *summary;
; 1742 :       if ((comp_idx >= 0) &&
; 1743 :           ((summary = access_relation(tile_idx,-1,0,true)) != NULL) &&
; 1744 :           (summary->tile_idx == tile_idx) &&

	cmp	DWORD PTR [esi+12], 0
	jl	SHORT $LN52@get
	push	1
	push	0
	push	-1
	push	DWORD PTR [esi+8]
	mov	ecx, esi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	test	eax, eax
	je	SHORT $LN52@get
	mov	ecx, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR _field_idx$GSCopy$1$[ebp]
	cmp	ecx, DWORD PTR [esi+8]
	jne	SHORT $LN8@get
	push	DWORD PTR _allow_derived$[ebp]
	mov	ecx, DWORD PTR _value$GSCopy$1$[ebp]
	push	DWORD PTR _allow_extend$[ebp]
	push	0
	push	ecx
	push	ebx
	push	edi
	push	DWORD PTR _name$GSCopy$1$[ebp]
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN8@get

; 1745 :           summary->get(name,record_idx,field_idx,value,false,
; 1746 :                        allow_extend,allow_derived))
; 1747 :         return true;

	mov	al, 1
	jmp	SHORT $LN1@get
$LN52@get:
	mov	ebx, DWORD PTR _field_idx$GSCopy$1$[ebp]
$LN8@get:

; 1748 :       if ((tile_idx >= 0) &&
; 1749 :           ((summary = access_relation(-1,comp_idx,inst_idx,true)) != NULL) &&

	cmp	DWORD PTR [esi+8], 0
	jl	SHORT $LN13@get
	push	1
	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	DWORD PTR [esi+12]
	push	-1
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	test	eax, eax
	je	SHORT $LN13@get
	push	DWORD PTR _allow_derived$[ebp]
	mov	ecx, eax
	push	DWORD PTR _allow_extend$[ebp]
	push	1
	push	DWORD PTR _value$GSCopy$1$[ebp]
	push	ebx
	push	edi
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN54@get
$LN13@get:

; 1762 :     return false;

	xor	al, al
$LN1@get:

; 1765 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN10@get:

; 1750 :           summary->get(name,record_idx,field_idx,value,true,
; 1751 :                        allow_extend,allow_derived))
; 1752 :         return true;
; 1753 :     }
; 1754 :   if (!have_attribute)
; 1755 :     return false;
; 1756 : 
; 1757 :   if ((ap->num_records <= record_idx) && allow_extend &&

	cmp	ecx, edi
	jg	SHORT $LN11@get
	cmp	BYTE PTR _allow_extend$[ebp], 0
	je	SHORT $LN11@get
	test	BYTE PTR [ebx+8], 2
	je	SHORT $LN11@get

; 1758 :       (ap->flags & this->CAN_EXTRAPOLATE))
; 1759 :     record_idx = ap->num_records - 1;

	lea	edi, DWORD PTR [ecx-1]
$LN11@get:

; 1760 :   att_ptr += ap->num_fields*record_idx;

	mov	eax, DWORD PTR [ebx+16]
	imul	eax, edi
	lea	eax, DWORD PTR [eax+eax*2]

; 1761 :   if ((record_idx < 0) || (record_idx >= ap->num_records) || !att_ptr->is_set)

	test	edi, edi
	js	SHORT $LN13@get
	cmp	edi, ecx
	jge	SHORT $LN13@get
	cmp	BYTE PTR [edx+eax*4+8], 0
	je	SHORT $LN13@get

; 1763 :   value = att_ptr->fval;

	mov	ecx, DWORD PTR _value$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], eax
$LN54@get:

; 1764 :   return true;

	mov	al, 1
	jmp	SHORT $LN1@get
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAAM_N22@Z$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAAM_N22@Z$1:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAAM_N22@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?get@kdu_params@@QAE_NPBDHHAAM_N22@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?get@kdu_params@@QAE_NPBDHHAAM_N22@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?get@kdu_params@@QAE_NPBDHHAAM_N22@Z ENDP		; kdu_params::get
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z
_TEXT	SEGMENT
_e$2 = -152						; size = 20
_att_ptr$1$ = -132					; size = 4
_value$GSCopy$1$ = -128					; size = 4
_e$3 = -124						; size = 20
_e$4 = -124						; size = 20
_name$GSCopy$1$ = -104					; size = 4
_field_idx$GSCopy$1$ = -100				; size = 4
_text$5 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_record_idx$ = 12					; size = 4
_field_idx$ = 16					; size = 4
_value$ = 20						; size = 4
_allow_inherit$ = 24					; size = 1
_allow_extend$ = 28					; size = 1
_allow_derived$ = 32					; size = 1
?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z PROC		; kdu_params::get, COMDAT
; _this$ = ecx

; 1637 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ecx, DWORD PTR _name$[ebp]
	mov	eax, DWORD PTR _field_idx$[ebp]
	mov	edi, DWORD PTR _record_idx$[ebp]

; 1638 :   kd_attribute *ap;
; 1639 :   att_val *att_ptr;
; 1640 : 
; 1641 :   assert((record_idx >= 0) && (field_idx >= 0));
; 1642 :   if ((ap=match_attribute(attributes,name)) == NULL)

	push	ecx
	push	DWORD PTR [esi+60]
	mov	DWORD PTR _field_idx$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _name$GSCopy$1$[ebp], ecx
	mov	DWORD PTR _value$GSCopy$1$[ebp], eax
	call	?match_attribute@@YAPAUkd_attribute@@PAU1@PBD@Z ; match_attribute
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	jne	SHORT $LN2@get

; 1643 :     { KDU_ERROR_DEV(e,18); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0EB@JLDBDJJO@Attempt?5to?5access?5a?5code?9stream?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1643 :     { KDU_ERROR_DEV(e,18); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_02LHOIKBIA@?$CC?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1647 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@get:

; 1648 :   if (field_idx >= ap->num_fields)

	mov	eax, DWORD PTR _field_idx$GSCopy$1$[ebp]
	cmp	eax, DWORD PTR [ebx+16]
	jl	$LN3@get

; 1649 :     { KDU_ERROR_DEV(e,19); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0FO@BDPPHOIA@Attempt?5to?5access?5a?5code?9stream?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1649 :     { KDU_ERROR_DEV(e,19); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BE@NMPECGEH@The?5field?5index?5is?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$3[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _field_idx$GSCopy$1$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$5[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$5[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1655 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _field_idx$GSCopy$1$[ebp]
$LN3@get:

; 1656 :   att_ptr = ap->values + field_idx;

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ebx+24]
	lea	edx, DWORD PTR [eax+ecx*4]

; 1657 :   if (att_ptr->pattern[0] != 'B')

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _att_ptr$1$[ebp], edx
	cmp	BYTE PTR [eax], 66			; 00000042H
	je	SHORT $LN4@get

; 1658 :     { KDU_ERROR_DEV(e,20);  e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0HF@JLGEHIN@Attempting?5to?5access?5a?5non?9boole@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1658 :     { KDU_ERROR_DEV(e,20);  e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1663 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	edx, DWORD PTR _att_ptr$1$[ebp]
$LN4@get:

; 1664 :  
; 1665 :   bool have_attribute = (ap->num_records > 0);

	mov	ecx, DWORD PTR [ebx+20]
	test	ecx, ecx
	setg	al

; 1666 :   if (ap->derived && !allow_derived)

	cmp	BYTE PTR [ebx+28], 0
	je	SHORT $LN5@get
	cmp	BYTE PTR _allow_derived$[ebp], 0
	je	SHORT $LN48@get
$LN5@get:

; 1667 :     have_attribute = false;
; 1668 : 
; 1669 :   if ((!have_attribute) && allow_inherit &&

	test	al, al
	jne	$LN10@get
$LN48@get:
	cmp	BYTE PTR _allow_inherit$[ebp], 0
	je	$LN13@get
	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN7@get
	cmp	BYTE PTR [esi+34], 0
	je	SHORT $LN13@get
$LN7@get:

; 1670 :       ((inst_idx == 0) || treat_instances_like_components))
; 1671 :     { // Try inheritance.
; 1672 :       kdu_params *summary;
; 1673 :       if ((comp_idx >= 0) &&
; 1674 :           ((summary = access_relation(tile_idx,-1,0,true)) != NULL) &&
; 1675 :           (summary->tile_idx == tile_idx) &&

	cmp	DWORD PTR [esi+12], 0
	jl	SHORT $LN52@get
	push	1
	push	0
	push	-1
	push	DWORD PTR [esi+8]
	mov	ecx, esi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	test	eax, eax
	je	SHORT $LN52@get
	mov	ecx, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR _field_idx$GSCopy$1$[ebp]
	cmp	ecx, DWORD PTR [esi+8]
	jne	SHORT $LN8@get
	push	DWORD PTR _allow_derived$[ebp]
	mov	ecx, DWORD PTR _value$GSCopy$1$[ebp]
	push	DWORD PTR _allow_extend$[ebp]
	push	0
	push	ecx
	push	ebx
	push	edi
	push	DWORD PTR _name$GSCopy$1$[ebp]
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN8@get

; 1676 :           summary->get(name,record_idx,field_idx,value,false,
; 1677 :                        allow_extend,allow_derived))
; 1678 :         return true;

	mov	al, 1
	jmp	SHORT $LN1@get
$LN52@get:
	mov	ebx, DWORD PTR _field_idx$GSCopy$1$[ebp]
$LN8@get:

; 1679 :       if ((tile_idx >= 0) &&
; 1680 :           ((summary = access_relation(-1,comp_idx,inst_idx,true)) != NULL) &&

	cmp	DWORD PTR [esi+8], 0
	jl	SHORT $LN13@get
	push	1
	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	DWORD PTR [esi+12]
	push	-1
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	test	eax, eax
	je	SHORT $LN13@get
	push	DWORD PTR _allow_derived$[ebp]
	mov	ecx, eax
	push	DWORD PTR _allow_extend$[ebp]
	push	1
	push	DWORD PTR _value$GSCopy$1$[ebp]
	push	ebx
	push	edi
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN54@get
$LN13@get:

; 1693 :     return false;

	xor	al, al
$LN1@get:

; 1696 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN10@get:

; 1681 :           summary->get(name,record_idx,field_idx,value,true,
; 1682 :                        allow_extend,allow_derived))
; 1683 :         return true;
; 1684 :     }
; 1685 :   if (!have_attribute)
; 1686 :     return false;
; 1687 : 
; 1688 :   if ((ap->num_records <= record_idx) && allow_extend &&

	cmp	ecx, edi
	jg	SHORT $LN11@get
	cmp	BYTE PTR _allow_extend$[ebp], 0
	je	SHORT $LN11@get
	test	BYTE PTR [ebx+8], 2
	je	SHORT $LN11@get

; 1689 :       (ap->flags & this->CAN_EXTRAPOLATE))
; 1690 :     record_idx = ap->num_records - 1;

	lea	edi, DWORD PTR [ecx-1]
$LN11@get:

; 1691 :   att_ptr += ap->num_fields*record_idx;

	mov	eax, DWORD PTR [ebx+16]
	imul	eax, edi
	lea	eax, DWORD PTR [eax+eax*2]

; 1692 :   if ((record_idx < 0) || (record_idx >= ap->num_records) || !att_ptr->is_set)

	test	edi, edi
	js	SHORT $LN13@get
	cmp	edi, ecx
	jge	SHORT $LN13@get
	cmp	BYTE PTR [edx+eax*4+8], 0
	je	SHORT $LN13@get

; 1694 :   value = (att_ptr->ival)?true:false;

	cmp	DWORD PTR [edx+eax*4], 0
	mov	ecx, DWORD PTR _value$GSCopy$1$[ebp]
	setne	al
	mov	BYTE PTR [ecx], al
$LN54@get:

; 1695 :   return true;

	mov	al, 1
	jmp	SHORT $LN1@get
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z$1:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z ENDP		; kdu_params::get
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?get@kdu_params@@QAE_NPBDHHAAH_N22@Z
_TEXT	SEGMENT
_e$2 = -152						; size = 20
_att_ptr$1$ = -132					; size = 4
_value$GSCopy$1$ = -128					; size = 4
_e$3 = -124						; size = 20
_e$4 = -124						; size = 20
_name$GSCopy$1$ = -104					; size = 4
_field_idx$GSCopy$1$ = -100				; size = 4
_text$5 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_record_idx$ = 12					; size = 4
_field_idx$ = 16					; size = 4
_value$ = 20						; size = 4
_allow_inherit$ = 24					; size = 1
_allow_extend$ = 28					; size = 1
_allow_derived$ = 32					; size = 1
?get@kdu_params@@QAE_NPBDHHAAH_N22@Z PROC		; kdu_params::get, COMDAT
; _this$ = ecx

; 1569 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get@kdu_params@@QAE_NPBDHHAAH_N22@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ecx, DWORD PTR _name$[ebp]
	mov	eax, DWORD PTR _field_idx$[ebp]
	mov	edi, DWORD PTR _record_idx$[ebp]

; 1570 :   kd_attribute *ap;
; 1571 :   att_val *att_ptr;
; 1572 : 
; 1573 :   assert((record_idx >= 0) && (field_idx >= 0));
; 1574 :   if ((ap=match_attribute(attributes,name)) == NULL)

	push	ecx
	push	DWORD PTR [esi+60]
	mov	DWORD PTR _field_idx$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _name$GSCopy$1$[ebp], ecx
	mov	DWORD PTR _value$GSCopy$1$[ebp], eax
	call	?match_attribute@@YAPAUkd_attribute@@PAU1@PBD@Z ; match_attribute
	mov	ebx, eax
	add	esp, 8
	test	ebx, ebx
	jne	SHORT $LN2@get

; 1575 :     { KDU_ERROR_DEV(e,15); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0EB@JLDBDJJO@Attempt?5to?5access?5a?5code?9stream?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1575 :     { KDU_ERROR_DEV(e,15); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_03KLKADAKF@?0?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_02LHOIKBIA@?$CC?$CB?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1579 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@get:

; 1580 :   if (field_idx >= ap->num_fields)

	mov	eax, DWORD PTR _field_idx$GSCopy$1$[ebp]
	cmp	eax, DWORD PTR [ebx+16]
	jl	$LN3@get

; 1581 :     { KDU_ERROR_DEV(e,16); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0FO@BDPPHOIA@Attempt?5to?5access?5a?5code?9stream?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1581 :     { KDU_ERROR_DEV(e,16); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_03BMLMMEDG@?$CC?4?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BE@NMPECGEH@The?5field?5index?5is?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$3[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _field_idx$GSCopy$1$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$5[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$5[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1587 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _field_idx$GSCopy$1$[ebp]
$LN3@get:

; 1588 :   att_ptr = ap->values + field_idx;

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ebx+24]
	lea	edx, DWORD PTR [eax+ecx*4]

; 1589 :   if (att_ptr->pattern[0] == 'F')

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _att_ptr$1$[ebp], edx
	cmp	BYTE PTR [eax], 70			; 00000046H
	jne	SHORT $LN4@get

; 1590 :     { KDU_ERROR_DEV(e,17); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0HI@GBKDDDEC@Attempting?5to?5access?5a?5floating?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1590 :     { KDU_ERROR_DEV(e,17); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02DAHALNEP@?$CC?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1595 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	edx, DWORD PTR _att_ptr$1$[ebp]
$LN4@get:

; 1596 :  
; 1597 :   bool have_attribute = (ap->num_records > 0);

	mov	ecx, DWORD PTR [ebx+20]
	test	ecx, ecx
	setg	al

; 1598 :   if (ap->derived && !allow_derived)

	cmp	BYTE PTR [ebx+28], 0
	je	SHORT $LN5@get
	cmp	BYTE PTR _allow_derived$[ebp], 0
	je	SHORT $LN48@get
$LN5@get:

; 1599 :     have_attribute = false;
; 1600 : 
; 1601 :   if ((!have_attribute) && allow_inherit &&

	test	al, al
	jne	$LN10@get
$LN48@get:
	cmp	BYTE PTR _allow_inherit$[ebp], 0
	je	$LN13@get
	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN7@get
	cmp	BYTE PTR [esi+34], 0
	je	SHORT $LN13@get
$LN7@get:

; 1602 :       ((inst_idx == 0) || treat_instances_like_components))
; 1603 :     { // Try inheritance.
; 1604 :       kdu_params *summary;
; 1605 :       if ((comp_idx >= 0) &&
; 1606 :           ((summary = access_relation(tile_idx,-1,0,true)) != NULL) &&
; 1607 :           (summary->tile_idx == tile_idx) &&

	cmp	DWORD PTR [esi+12], 0
	jl	SHORT $LN52@get
	push	1
	push	0
	push	-1
	push	DWORD PTR [esi+8]
	mov	ecx, esi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	test	eax, eax
	je	SHORT $LN52@get
	mov	ecx, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR _field_idx$GSCopy$1$[ebp]
	cmp	ecx, DWORD PTR [esi+8]
	jne	SHORT $LN8@get
	push	DWORD PTR _allow_derived$[ebp]
	mov	ecx, DWORD PTR _value$GSCopy$1$[ebp]
	push	DWORD PTR _allow_extend$[ebp]
	push	0
	push	ecx
	push	ebx
	push	edi
	push	DWORD PTR _name$GSCopy$1$[ebp]
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN8@get

; 1608 :           summary->get(name,record_idx,field_idx,value,false,
; 1609 :                        allow_extend,allow_derived))
; 1610 :         return true;

	mov	al, 1
	jmp	SHORT $LN1@get
$LN52@get:
	mov	ebx, DWORD PTR _field_idx$GSCopy$1$[ebp]
$LN8@get:

; 1611 :       if ((tile_idx >= 0) &&
; 1612 :           ((summary = access_relation(-1,comp_idx,inst_idx,true)) != NULL) &&

	cmp	DWORD PTR [esi+8], 0
	jl	SHORT $LN13@get
	push	1
	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	DWORD PTR [esi+12]
	push	-1
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	test	eax, eax
	je	SHORT $LN13@get
	push	DWORD PTR _allow_derived$[ebp]
	mov	ecx, eax
	push	DWORD PTR _allow_extend$[ebp]
	push	1
	push	DWORD PTR _value$GSCopy$1$[ebp]
	push	ebx
	push	edi
	push	DWORD PTR _name$GSCopy$1$[ebp]
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN54@get
$LN13@get:

; 1625 :     return false;

	xor	al, al
$LN1@get:

; 1628 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN10@get:

; 1613 :           summary->get(name,record_idx,field_idx,value,true,
; 1614 :                        allow_extend,allow_derived))
; 1615 :         return true;
; 1616 :     }
; 1617 :   if (!have_attribute)
; 1618 :     return false;
; 1619 : 
; 1620 :   if ((ap->num_records <= record_idx) && allow_extend &&

	cmp	ecx, edi
	jg	SHORT $LN11@get
	cmp	BYTE PTR _allow_extend$[ebp], 0
	je	SHORT $LN11@get
	test	BYTE PTR [ebx+8], 2
	je	SHORT $LN11@get

; 1621 :       (ap->flags & this->CAN_EXTRAPOLATE))
; 1622 :     record_idx = ap->num_records - 1;

	lea	edi, DWORD PTR [ecx-1]
$LN11@get:

; 1623 :   att_ptr += ap->num_fields*record_idx;

	mov	eax, DWORD PTR [ebx+16]
	imul	eax, edi
	lea	eax, DWORD PTR [eax+eax*2]

; 1624 :   if ((record_idx < 0) || (record_idx >= ap->num_records) || !att_ptr->is_set)

	test	edi, edi
	js	SHORT $LN13@get
	cmp	edi, ecx
	jge	SHORT $LN13@get
	cmp	BYTE PTR [edx+eax*4+8], 0
	je	SHORT $LN13@get

; 1626 :   value = att_ptr->ival;

	mov	ecx, DWORD PTR _value$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], eax
$LN54@get:

; 1627 :   return true;

	mov	al, 1
	jmp	SHORT $LN1@get
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAAH_N22@Z$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAAH_N22@Z$1:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?get@kdu_params@@QAE_NPBDHHAAH_N22@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?get@kdu_params@@QAE_NPBDHHAAH_N22@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?get@kdu_params@@QAE_NPBDHHAAH_N22@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?get@kdu_params@@QAE_NPBDHHAAH_N22@Z ENDP		; kdu_params::get
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?write_marker_segment@kdu_params@@MAEHPAVkdu_output@@PAV1@H@Z
_TEXT	SEGMENT
_out$ = 8						; size = 4
_last_marked$ = 12					; size = 4
_tpart_idx$ = 16					; size = 4
?write_marker_segment@kdu_params@@MAEHPAVkdu_output@@PAV1@H@Z PROC ; kdu_params::write_marker_segment, COMDAT
; _this$ = ecx

; 1007 :       { return 0; }

	xor	eax, eax
	ret	12					; 0000000cH
?write_marker_segment@kdu_params@@MAEHPAVkdu_output@@PAV1@H@Z ENDP ; kdu_params::write_marker_segment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?generate_marker_segments@kdu_params@@QAEHPAVkdu_output@@HH@Z
_TEXT	SEGMENT
_tile$1$ = -12						; size = 4
tv402 = -8						; size = 4
_c$1$ = -4						; size = 4
_out$ = 8						; size = 4
_which_tile$ = 12					; size = 4
_tpart_idx$ = 16					; size = 4
?generate_marker_segments@kdu_params@@QAEHPAVkdu_output@@HH@Z PROC ; kdu_params::generate_marker_segments, COMDAT
; _this$ = ecx

; 2810 : {

	push	ebp
	mov	ebp, esp

; 2811 :   int total_bytes, new_bytes;
; 2812 :   kdu_params *cluster = refs[0]->first_cluster;

	mov	eax, DWORD PTR [ecx+44]
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [eax]
	push	ebx
	push	edi

; 2813 : 
; 2814 :   total_bytes = 0;

	xor	ebx, ebx
	mov	edi, DWORD PTR [eax+36]

; 2815 :   for (; cluster != NULL; cluster=cluster->next_cluster)

	test	edi, edi
	je	$LN48@generate_m
	push	esi
	mov	esi, DWORD PTR _which_tile$[ebp]
	npad	2
$LL4@generate_m:

; 2816 :     {
; 2817 :       if (which_tile >= cluster->num_tiles)

	cmp	esi, DWORD PTR [edi+20]
	jge	$LN2@generate_m

; 2818 :         continue;
; 2819 :       int c, ref_idx = (which_tile+1)*(cluster->num_comps+1);

	mov	edx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR [esi+1]
	lea	ecx, DWORD PTR [edx+1]
	imul	ecx, eax

; 2820 :       kdu_params *tile = cluster->refs[ref_idx];

	mov	eax, DWORD PTR [edi+44]
	shl	ecx, 2
	mov	DWORD PTR tv402[ebp], ecx
	mov	eax, DWORD PTR [ecx+eax]

; 2821 :       for (c=-1; c < cluster->num_comps; c++, ref_idx++)

	or	ecx, -1
	mov	DWORD PTR _tile$1$[ebp], eax
	mov	DWORD PTR _c$1$[ebp], ecx
	cmp	edx, ecx
	jle	$LN2@generate_m
$LL7@generate_m:

; 2822 :         {
; 2823 :           kdu_params *last_marked, *inst;
; 2824 :           kdu_params *comp = cluster->refs[ref_idx];

	mov	eax, DWORD PTR [edi+44]
	mov	esi, DWORD PTR tv402[ebp]

; 2825 :           if ((comp->tile_idx != which_tile) &&

	mov	edx, DWORD PTR _which_tile$[ebp]
	mov	esi, DWORD PTR [esi+eax]
	cmp	DWORD PTR [esi+8], edx
	je	SHORT $LN15@generate_m
	mov	eax, DWORD PTR _tile$1$[ebp]
	cmp	DWORD PTR [eax+8], edx
	jne	$LN5@generate_m
	cmp	BYTE PTR [eax+29], 0
	je	$LN5@generate_m
$LN15@generate_m:

; 2826 :               ((tile->tile_idx != which_tile) || !tile->marked))
; 2827 :             continue; // All parameters inherited from main header default
; 2828 :                       // (global, or component-specific) and there is no
; 2829 :                       // separate tile header, from which parameters would
; 2830 :                       // otherwise be inherited.
; 2831 :           if (comp->comp_idx != c)

	cmp	DWORD PTR [esi+12], ecx
	je	SHORT $LN17@generate_m

; 2832 :             {
; 2833 :               if (!comp->force_comps)

	cmp	BYTE PTR [esi+33], 0
	je	$LN5@generate_m

; 2834 :                 continue; // All params inherited from tile or cluster default
; 2835 :               assert((comp->comp_idx == -1) && (c >= 0));
; 2836 :               comp = comp->access_relation(which_tile,c,0,false);

	push	0
	push	0
	push	ecx
	push	edx
	mov	ecx, esi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	ecx, DWORD PTR _c$1$[ebp]
	mov	esi, eax
	mov	edx, DWORD PTR _which_tile$[ebp]
$LN17@generate_m:

; 2837 :               assert((comp==cluster->refs[ref_idx]) && (comp->comp_idx==c));
; 2838 :             }
; 2839 :           if ((c >= 0) && (tile->tile_idx==which_tile) && tile->marked)

	test	ecx, ecx
	js	SHORT $LN19@generate_m
	mov	eax, DWORD PTR _tile$1$[ebp]
	cmp	DWORD PTR [eax+8], edx
	jne	SHORT $LN19@generate_m
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN21@generate_m
$LN19@generate_m:

; 2840 :             last_marked = tile; // Defaults derived from tile header
; 2841 :           else
; 2842 :             { // Defaults derived from main header
; 2843 :               last_marked = cluster->refs[c+1];

	mov	eax, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [eax+ecx*4+4]

; 2844 :               if (!last_marked->marked)

	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN21@generate_m

; 2845 :                 last_marked = (cluster->marked)?cluster:NULL;

	xor	eax, eax
	cmp	BYTE PTR [edi+29], al
	cmovne	eax, edi
$LN21@generate_m:

; 2846 :             }
; 2847 :           if (last_marked == comp)

	xor	edx, edx
	cmp	eax, esi
	cmove	eax, edx

; 2848 :             last_marked = NULL;
; 2849 : 
; 2850 :           for (inst=comp; inst != NULL; inst=inst->next_inst)

	test	esi, esi
	je	SHORT $LN5@generate_m
	npad	1
$LL10@generate_m:

; 2851 :             {
; 2852 :               if (inst->treat_instances_like_components)

	cmp	BYTE PTR [esi+34], 0
	je	SHORT $LN27@generate_m

; 2853 :                 { // Find `last_marked' object from main header entry with
; 2854 :                   // same instance number, if one exists
; 2855 :                   if (inst->tile_idx < 0)

	cmp	DWORD PTR [esi+8], 0
	jl	SHORT $LN28@generate_m

; 2860 :                            last_marked=last_marked->next_inst)
; 2861 :                         if (last_marked->inst_idx >= inst->inst_idx)

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, edi
$LL13@generate_m:
	cmp	DWORD PTR [eax+16], ecx
	jge	SHORT $LN49@generate_m

; 2856 :                     last_marked = NULL;
; 2857 :                   else
; 2858 :                     {
; 2859 :                       for (last_marked=cluster; last_marked != NULL;

	mov	eax, DWORD PTR [eax+56]
	test	eax, eax
	jne	SHORT $LL13@generate_m

; 2862 :                           break;
; 2863 :                       if ((last_marked == NULL) ||
; 2864 :                           (last_marked->inst_idx != inst->inst_idx) ||

	jmp	SHORT $LN28@generate_m
$LN49@generate_m:
	jne	SHORT $LN28@generate_m
	cmp	BYTE PTR [eax+29], 0
	jne	SHORT $LN27@generate_m
$LN28@generate_m:

; 2865 :                           !last_marked->marked)
; 2866 :                         last_marked = NULL;

	xor	eax, eax
$LN27@generate_m:

; 2867 :                     }
; 2868 :                 }
; 2869 :               new_bytes =

	push	DWORD PTR _tpart_idx$[ebp]
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	push	eax
	push	DWORD PTR _out$[ebp]
	call	DWORD PTR [edx+12]

; 2870 :                 inst->write_marker_segment(out,last_marked,tpart_idx);
; 2871 :               if (new_bytes > 0)

	test	eax, eax
	jle	SHORT $LN29@generate_m

; 2872 :                 {
; 2873 :                   assert(new_bytes >= 4);
; 2874 :                   total_bytes += new_bytes;

	add	ebx, eax

; 2875 :                   inst->marked = true;

	mov	BYTE PTR [esi+29], 1
$LN29@generate_m:

; 2876 :                 }
; 2877 :               last_marked = (inst->marked)?inst:NULL;

	xor	eax, eax
	cmp	BYTE PTR [esi+29], al
	cmovne	eax, esi
	mov	esi, DWORD PTR [esi+56]
	test	esi, esi
	jne	SHORT $LL10@generate_m
	mov	ecx, DWORD PTR _c$1$[ebp]
$LN5@generate_m:

; 2821 :       for (c=-1; c < cluster->num_comps; c++, ref_idx++)

	add	DWORD PTR tv402[ebp], 4
	inc	ecx
	mov	DWORD PTR _c$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+24]
	jl	$LL7@generate_m
	mov	esi, DWORD PTR _which_tile$[ebp]
$LN2@generate_m:

; 2815 :   for (; cluster != NULL; cluster=cluster->next_cluster)

	mov	edi, DWORD PTR [edi+40]
	test	edi, edi
	jne	$LL4@generate_m
	pop	esi
$LN48@generate_m:
	pop	edi

; 2878 :             }
; 2879 :         }
; 2880 :     }
; 2881 :   return(total_bytes);

	mov	eax, ebx
	pop	ebx

; 2882 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?generate_marker_segments@kdu_params@@QAEHPAVkdu_output@@HH@Z ENDP ; kdu_params::generate_marker_segments
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z
_TEXT	SEGMENT
_which_tile$GSCopy$1$ = -208				; size = 4
_bytes$GSCopy$1$ = -204					; size = 4
_e$2 = -200						; size = 20
_c_idx$ = -180						; size = 4
_text$3 = -176						; size = 80
_text$4 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_code$ = 8						; size = 2
_num_bytes$ = 12					; size = 4
_bytes$ = 16						; size = 4
_which_tile$ = 20					; size = 4
_tpart_idx$ = 24					; size = 4
?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z PROC ; kdu_params::translate_marker_segment, COMDAT
; _this$ = ecx

; 2750 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 196				; 000000c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2751 :   int c_idx=-1, i_idx=0;
; 2752 :   kdu_params *target, *cluster = refs[0]->first_cluster;

	mov	eax, DWORD PTR [ecx+44]
	xor	esi, esi
	mov	edx, DWORD PTR _bytes$[ebp]
	mov	ebx, DWORD PTR _which_tile$[ebp]
	mov	DWORD PTR _c_idx$[ebp], -1
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _bytes$GSCopy$1$[ebp], edx
	mov	DWORD PTR _which_tile$GSCopy$1$[ebp], ebx
	mov	edi, DWORD PTR [eax+36]

; 2753 :   for (; cluster != NULL; cluster = cluster->next_cluster)

	test	edi, edi
	je	SHORT $LN57@translate_
$LL4@translate_:

; 2754 :     {
; 2755 :       if (cluster->num_tiles <= which_tile)

	cmp	DWORD PTR [edi+20], ebx
	jle	SHORT $LN2@translate_

; 2756 :         continue;
; 2757 :       if (cluster->check_marker_segment(code,num_bytes,bytes,c_idx))

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR _c_idx$[ebp]
	push	ecx
	push	edx
	push	DWORD PTR _num_bytes$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, edi
	push	DWORD PTR _code$[ebp]
	call	eax
	test	al, al
	jne	SHORT $LN10@translate_
	mov	edx, DWORD PTR _bytes$GSCopy$1$[ebp]
$LN2@translate_:

; 2753 :   for (; cluster != NULL; cluster = cluster->next_cluster)

	mov	edi, DWORD PTR [edi+40]
	test	edi, edi
	jne	SHORT $LL4@translate_
$LN57@translate_:

; 2758 :         break;
; 2759 :     }
; 2760 :   if (cluster == NULL)
; 2761 :     return false;

	xor	al, al
$LN1@translate_:

; 2799 :     }
; 2800 :   return false;
; 2801 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN10@translate_:

; 2762 :   if (cluster->treat_instances_like_components)

	cmp	BYTE PTR [edi+34], 0
	je	SHORT $LN58@translate_

; 2763 :     {
; 2764 :       i_idx = c_idx;

	mov	esi, DWORD PTR _c_idx$[ebp]

; 2765 :       c_idx = -1;

	or	eax, -1
	mov	DWORD PTR _c_idx$[ebp], eax
	jmp	SHORT $LN11@translate_
$LN58@translate_:
	mov	eax, DWORD PTR _c_idx$[ebp]
$LN11@translate_:

; 2766 :     }
; 2767 :   target = cluster->access_relation(which_tile,c_idx,i_idx,false);

	push	0
	push	esi
	push	eax
	push	ebx
	mov	ecx, edi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	esi, eax

; 2768 :       // The above call creates a unique target object, if necessary
; 2769 : 
; 2770 :   if (target == NULL)

	test	esi, esi
	jne	$LN12@translate_

; 2771 :     { KDU_ERROR(e,0x25100601); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0HA@MENEFAMH@Codestream?5contains?5a?5parameter?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2771 :     { KDU_ERROR(e,0x25100601); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02JPEBCGCN@?5?$CC?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	DWORD PTR [edi+4]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_03GJDKGJIF@?$CC?$DL?5?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0P@DOHDMGMJ@tile?5number?5is?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$2[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	ebx
	mov	ebx, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	eax, ebx
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$4[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$4[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	eax
	mov	eax, DWORD PTR _e$2[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2781 :           << ".";

	cmp	DWORD PTR _which_tile$GSCopy$1$[ebp], esi
	mov	edi, OFFSET ??_C@_0BA@MNKEPDKJ@?5?$FLi?4e?4?0?5global?$FN?$AA@
	mov	ecx, OFFSET ??_C@_0BD@MMGLAGCF@?5?$CIstarting?5from?50?$CJ?$AA@
	mov	eax, edi
	cmovge	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	lea	ecx, DWORD PTR _e$2[ebp]
	push	eax
	mov	eax, DWORD PTR _e$2[ebp]
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_02LNAEAIDO@?$DL?5?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BD@PIKIAENG@component?5index?5is?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$2[ebp+4], 0
	mov	eax, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _c_idx$[ebp]
	cmove	ebx, eax
	lea	eax, DWORD PTR _text$3[ebp]
	push	ebx
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$3[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	eax
	mov	eax, DWORD PTR _e$2[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2781 :           << ".";

	cmp	DWORD PTR _c_idx$[ebp], esi
	mov	eax, OFFSET ??_C@_0BD@MMGLAGCF@?5?$CIstarting?5from?50?$CJ?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	lea	ecx, DWORD PTR _e$2[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2781 :           << ".";

	cmovge	edi, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	push	edi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 2782 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN12@translate_:

; 2783 : 
; 2784 : 
; 2785 :   if (target->allow_insts && !target->treat_instances_like_components)

	cmp	BYTE PTR [esi+32], 0
	je	SHORT $LN50@translate_
	cmp	BYTE PTR [esi+34], 0
	jne	SHORT $LN50@translate_
$LL7@translate_:

; 2788 :         if (!target->marked)

	cmp	BYTE PTR [esi+29], 0
	je	SHORT $LN50@translate_

; 2786 :     { // Skip over already marked instances
; 2787 :       for (; target != NULL; target=target->next_inst)

	mov	esi, DWORD PTR [esi+56]
	test	esi, esi
	jne	SHORT $LL7@translate_

; 2789 :           break;
; 2790 :     }
; 2791 :   if ((target != NULL) &&

	jmp	$LN57@translate_
$LN50@translate_:
	push	DWORD PTR _tpart_idx$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	DWORD PTR _bytes$GSCopy$1$[ebp]
	push	DWORD PTR _num_bytes$[ebp]
	mov	eax, DWORD PTR [eax+20]
	push	DWORD PTR _code$[ebp]
	call	eax
	test	al, al
	je	$LN57@translate_

; 2792 :       target->read_marker_segment(code,num_bytes,bytes,tpart_idx))
; 2793 :     {
; 2794 :       target->marked = true;
; 2795 :       if (target->allow_insts && !target->treat_instances_like_components)

	cmp	BYTE PTR [esi+32], 0
	mov	BYTE PTR [esi+29], 1
	je	SHORT $LN16@translate_
	cmp	BYTE PTR [esi+34], 0
	jne	SHORT $LN16@translate_

; 2796 :         target->new_instance();

	mov	ecx, esi
	call	?new_instance@kdu_params@@QAEPAV1@XZ	; kdu_params::new_instance
$LN16@translate_:

; 2797 :       target->empty = false;

	mov	BYTE PTR [esi+28], 0

; 2798 :       return true;

	mov	al, 1
	jmp	$LN1@translate_
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z ENDP ; kdu_params::translate_marker_segment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?check_typical_tile@kdu_params@@QAE_NHPBD@Z
_TEXT	SEGMENT
_e$2 = -56						; size = 20
_tc_ref$1$ = -36					; size = 4
_c$1$ = -32						; size = 4
tv622 = -28						; size = 4
tv617 = -24						; size = 4
_ap_global$1$ = -20					; size = 4
_cluster$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_tile_idx$ = 8						; size = 4
_excluded_clusters$ = 12				; size = 4
?check_typical_tile@kdu_params@@QAE_NHPBD@Z PROC	; kdu_params::check_typical_tile, COMDAT
; _this$ = ecx

; 1484 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?check_typical_tile@kdu_params@@QAE_NHPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1485 :   int c;
; 1486 :   kdu_params **tc_ref, *cluster = refs[0]->first_cluster;

	mov	eax, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+36]
	mov	DWORD PTR _cluster$1$[ebp], edi

; 1487 :   for (; cluster != NULL; cluster=cluster->next_cluster)

	test	edi, edi
	je	$LN74@check_typi
	npad	5
$LL4@check_typi:

; 1488 :     {
; 1489 :       if (cluster->num_tiles <= 0)

	mov	esi, DWORD PTR [edi+20]
	test	esi, esi
	jle	$LN2@check_typi

; 1490 :         continue;
; 1491 :       if (excluded_clusters != NULL)

	mov	ecx, DWORD PTR _excluded_clusters$[ebp]
	test	ecx, ecx
	je	SHORT $LN22@check_typi

; 1492 :         {
; 1493 :           bool match_found = false;

	xor	dl, dl

; 1494 :           const char *cp, *xp=excluded_clusters;

	mov	eax, ecx

; 1495 :           while ((*xp != '\0') && !match_found)

	cmp	BYTE PTR [ecx], dl
	je	SHORT $LN22@check_typi
	npad	6
$LL5@check_typi:
	test	dl, dl
	jne	$LN2@check_typi

; 1496 :             {
; 1497 :               for (cp=cluster->cluster_name; *xp != '\0'; cp++, xp++)

	mov	cl, BYTE PTR [eax]
	mov	edx, DWORD PTR [edi+4]
	test	cl, cl
	je	SHORT $LN75@check_typi
$LL9@check_typi:

; 1498 :                 if (*cp != *xp)

	cmp	BYTE PTR [edx], cl
	jne	SHORT $LN75@check_typi

; 1496 :             {
; 1497 :               for (cp=cluster->cluster_name; *xp != '\0'; cp++, xp++)

	mov	cl, BYTE PTR [eax+1]
	inc	eax
	inc	edx
	test	cl, cl
	jne	SHORT $LL9@check_typi
$LN75@check_typi:

; 1499 :                   break;
; 1500 :               match_found = (*cp == '\0');

	cmp	BYTE PTR [edx], 0

; 1501 :               while ((*xp != ':') && (*xp != '\0'))

	mov	cl, BYTE PTR [eax]
	sete	dl
	cmp	cl, 58					; 0000003aH
	je	SHORT $LN73@check_typi
	npad	5
$LL10@check_typi:
	test	cl, cl
	je	SHORT $LN11@check_typi
	mov	cl, BYTE PTR [eax+1]

; 1502 :                 { xp++; match_found=false; }

	inc	eax
	xor	dl, dl
	cmp	cl, 58					; 0000003aH
	jne	SHORT $LL10@check_typi

; 1503 :               if (*xp == ':')

	jmp	SHORT $LN73@check_typi
$LN11@check_typi:
	cmp	BYTE PTR [eax], 58			; 0000003aH
	jne	SHORT $LN21@check_typi
$LN73@check_typi:

; 1504 :                 xp++;

	inc	eax
$LN21@check_typi:

; 1495 :           while ((*xp != '\0') && !match_found)

	cmp	BYTE PTR [eax], 0
	jne	SHORT $LL5@check_typi

; 1505 :             }
; 1506 :           if (match_found)

	test	dl, dl
	jne	$LN2@check_typi
$LN22@check_typi:

; 1507 :             continue; // This is an excluded cluster
; 1508 :         }
; 1509 : 
; 1510 :       if ((tile_idx < 0) || (tile_idx >= cluster->num_tiles))

	mov	eax, DWORD PTR _tile_idx$[ebp]
	test	eax, eax
	js	SHORT $LN24@check_typi
	cmp	eax, esi
	jl	SHORT $LN23@check_typi
$LN24@check_typi:

; 1511 :         { KDU_ERROR_DEV(e,14); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EB@KNIJAOBN@Invalid?5?$GAtile_idx?8?5supplied?5to?5?$GA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1511 :         { KDU_ERROR_DEV(e,14); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1514 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _tile_idx$[ebp]
$LN23@check_typi:

; 1515 :       tc_ref = cluster->refs + (cluster->num_comps+1)*(tile_idx+1);

	mov	edx, DWORD PTR [edi+24]
	inc	eax
	mov	ebx, DWORD PTR [edi+44]
	mov	DWORD PTR tv622[ebp], ebx

; 1516 :       for (c=0; c <= cluster->num_comps; c++, tc_ref++)

	mov	DWORD PTR _c$1$[ebp], 0
	lea	ecx, DWORD PTR [edx+1]
	imul	ecx, eax
	lea	esi, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR _tc_ref$1$[ebp], esi
	test	edx, edx
	js	$LN2@check_typi

; 1521 :             { // Tile-specific object found; rough check of actual parameters
; 1522 :               // ensues.
; 1523 :               kd_attribute *ap_tc = (tc_ref[0])->attributes;
; 1524 :               kd_attribute *ap_global = (cluster->refs[0])->attributes;

	mov	eax, DWORD PTR _cluster$1$[ebp]
	xor	edi, edi
	mov	DWORD PTR tv617[ebp], edi
$LL14@check_typi:

; 1517 :         {
; 1518 :           if (*tc_ref == NULL)

	mov	edx, DWORD PTR [esi]
	test	edx, edx
	je	$LN12@check_typi

; 1519 :             continue;
; 1520 :           if ((*tc_ref)->tile_idx >= 0)

	cmp	DWORD PTR [edx+8], 0
	jl	$LN12@check_typi

; 1521 :             { // Tile-specific object found; rough check of actual parameters
; 1522 :               // ensues.
; 1523 :               kd_attribute *ap_tc = (tc_ref[0])->attributes;
; 1524 :               kd_attribute *ap_global = (cluster->refs[0])->attributes;

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR [eax+60]

; 1525 :               kd_attribute *ap_comp = (cluster->refs[c])->attributes;

	mov	eax, DWORD PTR [edi+ebx]
	mov	DWORD PTR _ap_global$1$[ebp], ecx
	mov	ebx, DWORD PTR [eax+60]

; 1526 :               kd_attribute *ap_tile =
; 1527 :                 ((tc_ref[-c])->tile_idx >= 0)?((tc_ref[-c])->attributes):ap_tc;

	mov	eax, esi
	sub	eax, edi
	mov	edi, DWORD PTR [eax]
	cmp	DWORD PTR [edi+8], 0
	jl	SHORT $LN40@check_typi
	mov	edi, DWORD PTR [edi+60]
	jmp	SHORT $LN41@check_typi
$LN40@check_typi:
	mov	edi, edx
$LN41@check_typi:

; 1528 :               for (; ap_tc != NULL;

	test	edx, edx
	je	$LN76@check_typi
$LL17@check_typi:

; 1531 :                 {
; 1532 :                   kd_attribute *ap = ap_tc;
; 1533 :                   if (ap->num_records == 0)

	cmp	DWORD PTR [edx+20], 0
	mov	eax, edx

; 1534 :                     ap = ap_tile; // Default to the tile value if possible
; 1535 :                   kd_attribute *ap_ref = ap_comp;
; 1536 :                   if (ap_ref->num_records == 0)

	mov	esi, ebx
	cmove	eax, edi
	cmp	DWORD PTR [ebx+20], 0
	cmove	esi, ecx

; 1537 :                     ap_ref = ap_global; // Main header defaults to global value
; 1538 :                   if ((ap == ap_ref) || (ap->num_records == 0))

	cmp	eax, esi
	je	SHORT $LN15@check_typi
	mov	ecx, DWORD PTR [eax+20]
	test	ecx, ecx
	je	SHORT $LN15@check_typi

; 1539 :                     continue; // Using the main header reference value
; 1540 :                   if ((ap->num_fields > 1) || (ap->num_records != 1) ||

	cmp	DWORD PTR [eax+16], 1
	jg	SHORT $LN32@check_typi
	cmp	ecx, 1
	jne	SHORT $LN32@check_typi
	cmp	DWORD PTR [esi+20], ecx
	jne	SHORT $LN32@check_typi

; 1543 :                   if (!(ap->values[0].is_set && ap_ref->values[0].is_set))

	mov	ecx, DWORD PTR [eax+24]
	cmp	BYTE PTR [ecx+8], 0
	je	SHORT $LN32@check_typi
	mov	esi, DWORD PTR [esi+24]
	cmp	BYTE PTR [esi+8], 0
	je	SHORT $LN32@check_typi

; 1544 :                     return false; // No testing of unset values
; 1545 :                   if (ap->values[0].pattern[0] == 'F')

	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax], 70			; 00000046H
	jne	SHORT $LN35@check_typi

; 1546 :                     {
; 1547 :                       if (ap->values[0].fval != ap_ref->values[0].fval)

	movss	xmm0, DWORD PTR [ecx]
	ucomiss	xmm0, DWORD PTR [esi]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN15@check_typi
$LN32@check_typi:

; 1541 :                       (ap_ref->num_records != 1))
; 1542 :                     return false; // No testing of multi-valued attributes

	xor	al, al

; 1560 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN35@check_typi:

; 1548 :                         return false; // Values differ
; 1549 :                     }
; 1550 :                   else
; 1551 :                     {
; 1552 :                       if (ap->values[0].ival != ap_ref->values[0].ival)

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN32@check_typi
$LN15@check_typi:

; 1529 :                    ap_tc=ap_tc->next,      ap_tile=ap_tile->next,
; 1530 :                    ap_comp=ap_comp->next,  ap_global=ap_global->next)

	mov	eax, DWORD PTR _ap_global$1$[ebp]
	mov	edx, DWORD PTR [edx+32]
	mov	edi, DWORD PTR [edi+32]
	mov	ebx, DWORD PTR [ebx+32]
	mov	eax, DWORD PTR [eax+32]
	mov	ecx, eax
	mov	DWORD PTR _ap_global$1$[ebp], eax
	test	edx, edx
	jne	$LL17@check_typi
	mov	esi, DWORD PTR _tc_ref$1$[ebp]
$LN76@check_typi:
	mov	eax, DWORD PTR _cluster$1$[ebp]
	mov	ebx, DWORD PTR tv622[ebp]
	mov	edi, DWORD PTR tv617[ebp]
$LN12@check_typi:

; 1516 :       for (c=0; c <= cluster->num_comps; c++, tc_ref++)

	mov	edx, DWORD PTR _c$1$[ebp]
	add	edi, 4
	inc	edx
	mov	DWORD PTR tv617[ebp], edi
	add	esi, 4
	mov	DWORD PTR _c$1$[ebp], edx
	mov	DWORD PTR _tc_ref$1$[ebp], esi
	cmp	edx, DWORD PTR [eax+24]
	jle	$LL14@check_typi
	mov	edi, DWORD PTR _cluster$1$[ebp]
$LN2@check_typi:

; 1487 :   for (; cluster != NULL; cluster=cluster->next_cluster)

	mov	edi, DWORD PTR [edi+40]
	mov	DWORD PTR _cluster$1$[ebp], edi
	test	edi, edi
	jne	$LL4@check_typi
$LN74@check_typi:

; 1553 :                         return false; // Values differ
; 1554 :                     }
; 1555 :                 }
; 1556 :             }
; 1557 :         }
; 1558 :     }
; 1559 :   return true;

	mov	al, 1

; 1560 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?check_typical_tile@kdu_params@@QAE_NHPBD@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?check_typical_tile@kdu_params@@QAE_NHPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?check_typical_tile@kdu_params@@QAE_NHPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?check_typical_tile@kdu_params@@QAE_NHPBD@Z ENDP	; kdu_params::check_typical_tile
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?any_changes@kdu_params@@QAE_NXZ
_TEXT	SEGMENT
?any_changes@kdu_params@@QAE_NXZ PROC			; kdu_params::any_changes, COMDAT
; _this$ = ecx

; 1474 :   kdu_params *head = refs[0]->first_cluster;

	mov	eax, DWORD PTR [ecx+44]

; 1475 :   return head->changed;

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+36]
	mov	al, BYTE PTR [eax+64]

; 1476 : }

	ret	0
?any_changes@kdu_params@@QAE_NXZ ENDP			; kdu_params::any_changes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?clear_marks@kdu_params@@QAEXXZ
_TEXT	SEGMENT
?clear_marks@kdu_params@@QAEXXZ PROC			; kdu_params::clear_marks, COMDAT
; _this$ = ecx

; 1449 :   kdu_params *cluster = refs[0]->first_cluster;

	mov	eax, DWORD PTR [ecx+44]
	push	esi
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+36]

; 1450 : 
; 1451 :   int c, t;
; 1452 :   kdu_params *par, **rp;
; 1453 :   for (; cluster != NULL; cluster=cluster->next_cluster)

	test	esi, esi
	je	SHORT $LN3@clear_mark
	push	edi
	npad	2
$LL4@clear_mark:

; 1454 :     {
; 1455 :       for (rp=cluster->refs, t=-1; t < cluster->num_tiles; t++)

	mov	edx, DWORD PTR [esi+44]
	or	edi, -1
	cmp	DWORD PTR [esi+20], edi
	jle	SHORT $LN2@clear_mark
	npad	5
$LL7@clear_mark:

; 1456 :         for (c=-1; c < cluster->num_comps; c++, rp++)

	or	ecx, -1
	cmp	DWORD PTR [esi+24], ecx
	jle	SHORT $LN5@clear_mark
$LL10@clear_mark:

; 1457 :           {
; 1458 :             par = *rp;

	mov	eax, DWORD PTR [edx]

; 1459 :             if ((par==NULL) || (par->tile_idx != t) || (par->comp_idx != c))

	test	eax, eax
	je	SHORT $LN8@clear_mark
	cmp	DWORD PTR [eax+8], edi
	jne	SHORT $LN8@clear_mark
	cmp	DWORD PTR [eax+12], ecx
	jne	SHORT $LN8@clear_mark
	npad	8
$LL13@clear_mark:

; 1460 :               continue; // Already done this one
; 1461 :             for (; par != NULL; par=par->next_inst)
; 1462 :               par->changed = par->marked = false;

	mov	BYTE PTR [eax+29], 0
	mov	BYTE PTR [eax+64], 0
	mov	eax, DWORD PTR [eax+56]
	test	eax, eax
	jne	SHORT $LL13@clear_mark
$LN8@clear_mark:

; 1456 :         for (c=-1; c < cluster->num_comps; c++, rp++)

	inc	ecx
	add	edx, 4
	cmp	ecx, DWORD PTR [esi+24]
	jl	SHORT $LL10@clear_mark
$LN5@clear_mark:

; 1454 :     {
; 1455 :       for (rp=cluster->refs, t=-1; t < cluster->num_tiles; t++)

	inc	edi
	cmp	edi, DWORD PTR [esi+20]
	jl	SHORT $LL7@clear_mark
$LN2@clear_mark:

; 1450 : 
; 1451 :   int c, t;
; 1452 :   kdu_params *par, **rp;
; 1453 :   for (; cluster != NULL; cluster=cluster->next_cluster)

	mov	esi, DWORD PTR [esi+40]
	test	esi, esi
	jne	SHORT $LL4@clear_mark
	pop	edi
$LN3@clear_mark:
	pop	esi

; 1463 :           }
; 1464 :     }
; 1465 : }

	ret	0
?clear_marks@kdu_params@@QAEXXZ ENDP			; kdu_params::clear_marks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?define_attribute@kdu_params@@IAEXPBD00H@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_comment$ = 12						; size = 4
_pattern$ = 16						; size = 4
_flags$ = 20						; size = 4
?define_attribute@kdu_params@@IAEXPBD00H@Z PROC		; kdu_params::define_attribute, COMDAT
; _this$ = ecx

; 2971 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?define_attribute@kdu_params@@IAEXPBD00H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 2972 :   kd_attribute *att, *scan;
; 2973 : 
; 2974 :   att = new kd_attribute(name,comment,flags,pattern);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN7@define_att
	push	DWORD PTR _pattern$[ebp]
	mov	ecx, eax
	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _comment$[ebp]
	push	DWORD PTR _name$[ebp]
	call	??0kd_attribute@@QAE@PBD0H0@Z		; kd_attribute::kd_attribute
	mov	edx, eax
	jmp	SHORT $LN8@define_att
$LN7@define_att:
	xor	edx, edx
$LN8@define_att:

; 2975 :   if ((scan = attributes) != NULL)

	mov	ecx, DWORD PTR [esi+60]
	test	ecx, ecx
	je	SHORT $LN4@define_att

; 2976 :     {
; 2977 :       while (scan->next != NULL)

	cmp	DWORD PTR [ecx+32], 0
	lea	eax, DWORD PTR [ecx+32]
	je	SHORT $LN3@define_att
$LL2@define_att:

; 2978 :         scan = scan->next;

	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+32], 0
	lea	eax, DWORD PTR [ecx+32]
	jne	SHORT $LL2@define_att
$LN3@define_att:

; 2979 :       scan->next = att;

	mov	DWORD PTR [ecx+32], edx

; 2983 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN4@define_att:

; 2980 :     }
; 2981 :   else
; 2982 :     attributes = att;

	mov	DWORD PTR [esi+60], edx

; 2983 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?define_attribute@kdu_params@@IAEXPBD00H@Z$0:
	push	40					; 00000028H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?define_attribute@kdu_params@@IAEXPBD00H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?define_attribute@kdu_params@@IAEXPBD00H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?define_attribute@kdu_params@@IAEXPBD00H@Z ENDP		; kdu_params::define_attribute
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?access_next_inst@kdu_params@@QAEPAV1@XZ
_TEXT	SEGMENT
?access_next_inst@kdu_params@@QAEPAV1@XZ PROC		; kdu_params::access_next_inst, COMDAT
; _this$ = ecx

; 807  :       access_next_inst() { return next_inst; }

	mov	eax, DWORD PTR [ecx+56]
	ret	0
?access_next_inst@kdu_params@@QAEPAV1@XZ ENDP		; kdu_params::access_next_inst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?access_unique@kdu_params@@QAEPAV1@HHH@Z
_TEXT	SEGMENT
_tile_idx$ = 8						; size = 4
_comp_idx$ = 12						; size = 4
_inst_idx$ = 16						; size = 4
?access_unique@kdu_params@@QAEPAV1@HHH@Z PROC		; kdu_params::access_unique, COMDAT
; _this$ = ecx

; 1429 : {

	push	ebp
	mov	ebp, esp

; 1430 :   if ((tile_idx >= num_tiles) || (comp_idx >= num_comps))

	mov	edx, DWORD PTR _tile_idx$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	cmp	edx, DWORD PTR [esi+20]
	jge	SHORT $LN5@access_uni
	mov	ecx, DWORD PTR [esi+24]
	mov	edi, DWORD PTR _comp_idx$[ebp]
	cmp	edi, ecx
	jge	SHORT $LN5@access_uni

; 1432 :   int ref_idx = (comp_idx+1)+(tile_idx+1)*(num_comps+1);
; 1433 :   kdu_params *result = refs[ref_idx];

	inc	ecx
	lea	eax, DWORD PTR [edx+1]
	imul	ecx, eax
	mov	eax, DWORD PTR [esi+44]
	add	ecx, edi
	mov	eax, DWORD PTR [eax+ecx*4+4]

; 1434 :   if ((result == NULL) ||
; 1435 :       (result->tile_idx != tile_idx) || (result->comp_idx != comp_idx))

	test	eax, eax
	je	SHORT $LN5@access_uni
	cmp	DWORD PTR [eax+8], edx
	jne	SHORT $LN5@access_uni
	cmp	DWORD PTR [eax+12], edi
	jne	SHORT $LN5@access_uni
	mov	ecx, DWORD PTR _inst_idx$[ebp]
	npad	6
$LL2@access_uni:

; 1436 :     return NULL;
; 1437 :   while ((result != NULL) && (result->inst_idx != inst_idx))

	cmp	DWORD PTR [eax+16], ecx
	je	SHORT $LN1@access_uni

; 1438 :     result = result->next_inst;

	mov	eax, DWORD PTR [eax+56]
	test	eax, eax
	jne	SHORT $LL2@access_uni
	pop	edi
	pop	esi

; 1439 :   return(result);
; 1440 : }

	pop	ebp
	ret	12					; 0000000cH
$LN5@access_uni:

; 1431 :     return NULL;

	xor	eax, eax
$LN1@access_uni:
	pop	edi
	pop	esi

; 1439 :   return(result);
; 1440 : }

	pop	ebp
	ret	12					; 0000000cH
?access_unique@kdu_params@@QAEPAV1@HHH@Z ENDP		; kdu_params::access_unique
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?access_relation@kdu_params@@QAEPAV1@HHH_N@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
_result$1$ = -4						; size = 4
_tile_idx$ = 8						; size = 4
_comp_idx$ = 12						; size = 4
_inst_idx$ = 16						; size = 4
_read_only$ = 20					; size = 1
?access_relation@kdu_params@@QAEPAV1@HHH_N@Z PROC	; kdu_params::access_relation, COMDAT
; _this$ = ecx

; 1310 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	edx, ecx
	push	ebx
	push	esi

; 1311 :   if ((tile_idx >= num_tiles) || (comp_idx >= num_comps))

	mov	esi, DWORD PTR _tile_idx$[ebp]
	mov	DWORD PTR _this$1$[ebp], edx
	cmp	esi, DWORD PTR [edx+20]
	jge	$LN20@access_rel
	mov	ecx, DWORD PTR [edx+24]
	mov	ebx, DWORD PTR _comp_idx$[ebp]
	cmp	ebx, ecx
	jge	$LN20@access_rel

; 1313 :   int ref_idx = (comp_idx+1)+(tile_idx+1)*(num_comps+1);

	inc	ecx
	lea	eax, DWORD PTR [esi+1]
	imul	ecx, eax

; 1314 :   kdu_params *result = refs[ref_idx];

	mov	eax, DWORD PTR [edx+44]
	push	edi
	lea	edi, DWORD PTR [ebx+1]
	add	edi, ecx
	lea	ebx, DWORD PTR [edi*4]
	mov	ecx, DWORD PTR [ebx+eax]
	mov	DWORD PTR _result$1$[ebp], ecx

; 1315 :   if (result == NULL)

	test	ecx, ecx
	je	$LN58@access_rel

; 1316 :     return NULL;
; 1317 :   if ((!read_only) &&

	cmp	BYTE PTR _read_only$[ebp], 0
	jne	$LN88@access_rel
	cmp	DWORD PTR [ecx+8], esi
	jne	SHORT $LN23@access_rel
	mov	eax, DWORD PTR _comp_idx$[ebp]
	cmp	DWORD PTR [ecx+12], eax
	je	$LN88@access_rel
$LN23@access_rel:

; 1318 :       ((result->tile_idx != tile_idx) || (result->comp_idx != comp_idx)))
; 1319 :     { // Need to return a unique result
; 1320 :       if ((inst_idx != 0) && !treat_instances_like_components)

	cmp	DWORD PTR _inst_idx$[ebp], 0
	je	SHORT $LN24@access_rel
	cmp	BYTE PTR [edx+34], 0
	je	$LN58@access_rel
$LN24@access_rel:

; 1321 :         return NULL;
; 1322 : 
; 1323 :       result = new_object();

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax]

; 1324 :       result->refs = refs;

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _result$1$[ebp], eax
	mov	ecx, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+44], ecx

; 1325 :       result->tile_idx = tile_idx;
; 1326 :       result->comp_idx = comp_idx;

	mov	ecx, DWORD PTR _comp_idx$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+8], esi

; 1327 :       result->num_tiles = num_tiles;

	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], ecx

; 1328 :       result->num_comps = num_comps;

	mov	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR [eax+24], ecx

; 1329 :       result->first_cluster = NULL;

	mov	ecx, eax
	mov	DWORD PTR [ecx+36], 0

; 1330 :       refs[ref_idx] = result;

	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ebx+eax], ecx

; 1331 : 
; 1332 :       if (comp_idx < 0)

	mov	eax, DWORD PTR _comp_idx$[ebp]
	test	eax, eax
	jns	SHORT $LN25@access_rel

; 1333 :         { // Check each component in the current tile to see if we need to
; 1334 :           // modify a link to a default object
; 1335 :           assert(tile_idx >= 0);
; 1336 :           for (int c=0; c < num_comps; c++)

	xor	esi, esi
	cmp	DWORD PTR [edx+24], esi
	jle	$LN35@access_rel
	npad	1
$LL4@access_rel:

; 1337 :             {
; 1338 :               ref_idx++;
; 1339 :               if (refs[ref_idx] == refs[0])

	mov	eax, DWORD PTR [edx+44]
	lea	ebx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx+eax]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN27@access_rel

; 1340 :                 refs[ref_idx] = result;

	mov	ecx, DWORD PTR _result$1$[ebp]
	mov	DWORD PTR [ebx+eax], ecx
	jmp	SHORT $LN2@access_rel
$LN27@access_rel:

; 1341 :               else if (refs[ref_idx]->tile_idx < 0)

	cmp	DWORD PTR [ecx+8], 0
	jge	SHORT $LN93@access_rel

; 1342 :                 access_relation(tile_idx,c,0,false); // Create unique object

	push	0
	push	0
	push	esi
	push	DWORD PTR _tile_idx$[ebp]
	mov	ecx, edx
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	edx, DWORD PTR _this$1$[ebp]
$LN93@access_rel:
	mov	ecx, DWORD PTR _result$1$[ebp]
$LN2@access_rel:

; 1333 :         { // Check each component in the current tile to see if we need to
; 1334 :           // modify a link to a default object
; 1335 :           assert(tile_idx >= 0);
; 1336 :           for (int c=0; c < num_comps; c++)

	inc	esi
	cmp	esi, DWORD PTR [edx+24]
	jl	SHORT $LL4@access_rel

; 1343 :             }
; 1344 :         }
; 1345 :       else if (tile_idx < 0)

	jmp	SHORT $LN35@access_rel
$LN25@access_rel:
	test	esi, esi
	jns	SHORT $LN30@access_rel

; 1346 :         { // Check each tile at the current component to see if we need to
; 1347 :           // modify a link to a default object
; 1348 :           for (int t=0; t < num_tiles; t++)

	xor	esi, esi
	cmp	DWORD PTR [edx+20], esi
	jle	SHORT $LN35@access_rel
$LL7@access_rel:

; 1349 :             {
; 1350 :               ref_idx += (num_comps+1);

	mov	eax, DWORD PTR [edx+24]
	inc	eax
	add	edi, eax

; 1351 :               if (refs[ref_idx] == refs[0])

	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax+edi*4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN32@access_rel

; 1352 :                 refs[ref_idx] = result;

	mov	ecx, DWORD PTR _result$1$[ebp]
	mov	DWORD PTR [eax+edi*4], ecx
	jmp	SHORT $LN5@access_rel
$LN32@access_rel:

; 1353 :               else if (refs[ref_idx]->comp_idx < 0)

	cmp	DWORD PTR [ecx+12], 0
	jge	SHORT $LN92@access_rel

; 1354 :                 access_relation(t,comp_idx,0,false); // Create unique object

	push	0
	push	0
	push	DWORD PTR _comp_idx$[ebp]
	mov	ecx, edx
	push	esi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	edx, DWORD PTR _this$1$[ebp]
$LN92@access_rel:
	mov	ecx, DWORD PTR _result$1$[ebp]
$LN5@access_rel:

; 1346 :         { // Check each tile at the current component to see if we need to
; 1347 :           // modify a link to a default object
; 1348 :           for (int t=0; t < num_tiles; t++)

	inc	esi
	cmp	esi, DWORD PTR [edx+20]
	jl	SHORT $LL7@access_rel

; 1355 :             }
; 1356 :         }
; 1357 :       else

	jmp	SHORT $LN35@access_rel
$LN30@access_rel:

; 1358 :         { // Create a tile head for the current tile-component if necessary,
; 1359 :           // since otherwise functions which scan by cluster, by tile and
; 1360 :           // then by tile-component will not find this new unique
; 1361 :           // tile-component object
; 1362 :           ref_idx -= (comp_idx+1);
; 1363 :           if (refs[ref_idx] == refs[0])

	mov	ecx, DWORD PTR [edx+44]
	sub	edi, eax
	mov	eax, DWORD PTR [ecx+edi*4-4]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN91@access_rel

; 1364 :             access_relation(tile_idx,-1,0,false); // Create unique object

	push	0
	push	0
	push	-1
	push	esi
	mov	ecx, edx
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	edx, DWORD PTR _this$1$[ebp]
$LN91@access_rel:
	mov	ecx, DWORD PTR _result$1$[ebp]
$LN35@access_rel:

; 1365 :         }
; 1366 : 
; 1367 :       // See if we need to create a unique instance in another cluster on
; 1368 :       // whose dependency list we reside
; 1369 :       int n;
; 1370 :       kdu_params *scan;
; 1371 :       for (scan=refs[0]->first_cluster; scan != NULL; scan=scan->next_cluster)

	mov	eax, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+36]
	test	edi, edi
	je	$LN88@access_rel
	npad	1
$LL10@access_rel:

; 1372 :         {
; 1373 :           for (n=0; n < KD_MAX_PARAM_DEPENDENCIES; n++)

	xor	ebx, ebx
	lea	esi, DWORD PTR [edi+68]
$LL13@access_rel:

; 1374 :             if (scan->dependencies[n] == NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@access_rel

; 1375 :               break;
; 1376 :             else if (strcmp(scan->dependencies[n],this->cluster_name) == 0)

	mov	ecx, DWORD PTR [edx+4]
	npad	2
$LL82@access_rel:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN83@access_rel
	test	dl, dl
	je	SHORT $LN84@access_rel
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN83@access_rel
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL82@access_rel
$LN84@access_rel:
	xor	eax, eax
	jmp	SHORT $LN85@access_rel
$LN83@access_rel:
	sbb	eax, eax
	or	eax, 1
$LN85@access_rel:
	test	eax, eax
	je	SHORT $LN57@access_rel

; 1372 :         {
; 1373 :           for (n=0; n < KD_MAX_PARAM_DEPENDENCIES; n++)

	mov	edx, DWORD PTR _this$1$[ebp]
	inc	ebx
	add	esi, 4
	cmp	ebx, 4
	jl	SHORT $LL13@access_rel

; 1394 :           else if (read_only && (result->tile_idx < 0))

	jmp	SHORT $LN8@access_rel
$LN57@access_rel:

; 1377 :               {
; 1378 :                 scan->access_relation(tile_idx,comp_idx,0,false);

	mov	ebx, DWORD PTR _tile_idx$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	DWORD PTR _comp_idx$[ebp]
	push	ebx
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 1379 :                 if ((tile_idx >= 0) && scan->allow_comps && !this->allow_comps)

	mov	edx, DWORD PTR _this$1$[ebp]
	test	ebx, ebx
	js	SHORT $LN8@access_rel
	cmp	BYTE PTR [edi+31], 0
	je	SHORT $LN8@access_rel
	cmp	BYTE PTR [edx+31], 0
	jne	SHORT $LN8@access_rel

; 1380 :                   for (int c=0; c < scan->num_comps; c++)

	xor	esi, esi
	cmp	DWORD PTR [edi+24], esi
	jle	SHORT $LN8@access_rel
$LL16@access_rel:

; 1381 :                     scan->access_relation(tile_idx,c,0,false);

	push	0
	push	0
	push	esi
	push	ebx
	mov	ecx, edi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	inc	esi
	cmp	esi, DWORD PTR [edi+24]
	jl	SHORT $LL16@access_rel
	mov	edx, DWORD PTR _this$1$[ebp]
$LN8@access_rel:

; 1365 :         }
; 1366 : 
; 1367 :       // See if we need to create a unique instance in another cluster on
; 1368 :       // whose dependency list we reside
; 1369 :       int n;
; 1370 :       kdu_params *scan;
; 1371 :       for (scan=refs[0]->first_cluster; scan != NULL; scan=scan->next_cluster)

	mov	edi, DWORD PTR [edi+40]
	test	edi, edi
	jne	$LL10@access_rel
	mov	ecx, DWORD PTR _result$1$[ebp]
$LN88@access_rel:
	mov	edi, DWORD PTR _tile_idx$[ebp]
	mov	ebx, DWORD PTR _inst_idx$[ebp]
	npad	3
$LL17@access_rel:

; 1382 :                 break;
; 1383 :               }
; 1384 :         }
; 1385 :     }
; 1386 : 
; 1387 :   while ((result != NULL) && (result->inst_idx != inst_idx))

	cmp	DWORD PTR [ecx+16], ebx
	je	SHORT $LN18@access_rel

; 1388 :     {
; 1389 :       if ((result->next_inst == NULL) ||

	mov	eax, DWORD PTR [ecx+56]
	lea	esi, DWORD PTR [ecx+56]
	test	eax, eax
	je	SHORT $LN41@access_rel
	cmp	DWORD PTR [eax+16], ebx
	jle	SHORT $LN47@access_rel
$LN41@access_rel:

; 1390 :           (result->next_inst->inst_idx > inst_idx))
; 1391 :         { // We will not be finding the desired instance in the existing list
; 1392 :           if (!result->treat_instances_like_components)

	cmp	BYTE PTR [ecx+34], 0
	je	SHORT $LN58@access_rel

; 1394 :           else if (read_only && (result->tile_idx < 0))

	cmp	BYTE PTR _read_only$[ebp], 0
	je	SHORT $LN46@access_rel
	cmp	DWORD PTR [ecx+8], 0
	jl	SHORT $LN58@access_rel

; 1395 :             return NULL; // Nowhere to inherit from
; 1396 :           else if (read_only)
; 1397 :             {
; 1398 :               assert(result->num_comps == 0);
; 1399 :               result = refs[0]; // Jump to cluster head

	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax]

; 1400 :               continue; // Try again with the cluster head's instance list

	jmp	SHORT $LN95@access_rel
$LN46@access_rel:

; 1401 :             }
; 1402 :           else
; 1403 :             { // Creation of a new object is required
; 1404 :               kdu_params *new_obj = new_object();

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax]
	mov	edx, eax

; 1405 :               new_obj->refs = refs;

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+44], ecx

; 1406 :               new_obj->tile_idx = tile_idx;
; 1407 :               new_obj->comp_idx = comp_idx;

	mov	ecx, DWORD PTR _comp_idx$[ebp]
	mov	DWORD PTR [edx+8], edi
	mov	DWORD PTR [edx+12], ecx

; 1408 :               new_obj->num_tiles = num_tiles;

	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx

; 1409 :               new_obj->num_comps = num_comps;

	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx

; 1410 :               new_obj->first_cluster = NULL;

	mov	DWORD PTR [edx+36], 0

; 1411 :               new_obj->next_inst = result->next_inst;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+56], eax

; 1412 :               result->next_inst = new_obj;
; 1413 :               new_obj->first_inst = result->first_inst;

	mov	eax, DWORD PTR _result$1$[ebp]
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+52], eax

; 1414 :               new_obj->inst_idx = inst_idx;

	mov	DWORD PTR [edx+16], ebx
$LN47@access_rel:

; 1415 :             }
; 1416 :         }
; 1417 :       result = result->next_inst;

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _this$1$[ebp]
$LN95@access_rel:
	mov	DWORD PTR _result$1$[ebp], ecx
	test	ecx, ecx
	jne	SHORT $LL17@access_rel
$LN18@access_rel:
	pop	edi
	pop	esi

; 1418 :     }
; 1419 : 
; 1420 :   return(result);

	mov	eax, ecx
	pop	ebx

; 1421 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN58@access_rel:
	pop	edi
	pop	esi

; 1393 :             return NULL; // Inhertiance and creation disallowed

	xor	eax, eax
	pop	ebx

; 1421 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN20@access_rel:
	pop	esi

; 1312 :     return NULL;

	xor	eax, eax
	pop	ebx

; 1421 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ENDP	; kdu_params::access_relation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?get_num_tiles@kdu_params@@QAEHXZ
_TEXT	SEGMENT
?get_num_tiles@kdu_params@@QAEHXZ PROC			; kdu_params::get_num_tiles, COMDAT
; _this$ = ecx

; 742  :     int get_num_tiles() { return num_tiles; }

	mov	eax, DWORD PTR [ecx+20]
	ret	0
?get_num_tiles@kdu_params@@QAEHXZ ENDP			; kdu_params::get_num_tiles
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?get_num_comps@kdu_params@@QAEHXZ
_TEXT	SEGMENT
?get_num_comps@kdu_params@@QAEHXZ PROC			; kdu_params::get_num_comps, COMDAT
; _this$ = ecx

; 732  :     int get_num_comps() { return num_comps; }

	mov	eax, DWORD PTR [ecx+24]
	ret	0
?get_num_comps@kdu_params@@QAEHXZ ENDP			; kdu_params::get_num_comps
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?get_instance@kdu_params@@QAEHXZ
_TEXT	SEGMENT
?get_instance@kdu_params@@QAEHXZ PROC			; kdu_params::get_instance, COMDAT
; _this$ = ecx

; 725  :     int get_instance() { return inst_idx; }

	mov	eax, DWORD PTR [ecx+16]
	ret	0
?get_instance@kdu_params@@QAEHXZ ENDP			; kdu_params::get_instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?access_cluster@kdu_params@@QAEPAV1@H@Z
_TEXT	SEGMENT
_seq$ = 8						; size = 4
?access_cluster@kdu_params@@QAEPAV1@H@Z PROC		; kdu_params::access_cluster, COMDAT
; _this$ = ecx

; 1296 : {

	push	ebp
	mov	ebp, esp

; 1297 :   kdu_params *scan = refs[0]->first_cluster;

	mov	eax, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+36]

; 1298 :   while ((scan != NULL) && (seq > 0))

	test	eax, eax
	je	SHORT $LN3@access_clu
	mov	ecx, DWORD PTR _seq$[ebp]
$LL2@access_clu:
	test	ecx, ecx
	jle	SHORT $LN3@access_clu

; 1299 :     { scan = scan->next_cluster; seq--; }

	mov	eax, DWORD PTR [eax+40]
	dec	ecx
	test	eax, eax
	jne	SHORT $LL2@access_clu
$LN3@access_clu:

; 1300 :   return(scan);
; 1301 : }

	pop	ebp
	ret	4
?access_cluster@kdu_params@@QAEPAV1@H@Z ENDP		; kdu_params::access_cluster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?access_cluster@kdu_params@@QAEPAV1@PBD@Z
_TEXT	SEGMENT
_name$ = 8						; size = 4
?access_cluster@kdu_params@@QAEPAV1@PBD@Z PROC		; kdu_params::access_cluster, COMDAT
; _this$ = ecx

; 1281 : {

	push	ebp
	mov	ebp, esp

; 1282 :   kdu_params *scan = refs[0]->first_cluster;

	mov	eax, DWORD PTR [ecx+44]
	push	esi
	push	edi

; 1283 :   if (name == NULL)

	mov	edi, DWORD PTR _name$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+36]
	test	edi, edi
	je	SHORT $LN14@access_clu

; 1284 :     return(scan);
; 1285 :   while ((scan != NULL) && (strcmp(scan->cluster_name,name) != 0))

	test	esi, esi
	je	SHORT $LN14@access_clu
$LL2@access_clu:
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, edi
	npad	3
$LL10@access_clu:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN11@access_clu
	test	dl, dl
	je	SHORT $LN12@access_clu
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN11@access_clu
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL10@access_clu
$LN12@access_clu:
	xor	eax, eax
	jmp	SHORT $LN13@access_clu
$LN11@access_clu:
	sbb	eax, eax
	or	eax, 1
$LN13@access_clu:
	test	eax, eax
	je	SHORT $LN14@access_clu

; 1286 :     scan = scan->next_cluster;

	mov	esi, DWORD PTR [esi+40]
	test	esi, esi
	jne	SHORT $LL2@access_clu
$LN14@access_clu:
	pop	edi

; 1287 :   return(scan);

	mov	eax, esi
	pop	esi

; 1288 : }

	pop	ebp
	ret	4
?access_cluster@kdu_params@@QAEPAV1@PBD@Z ENDP		; kdu_params::access_cluster
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z
_TEXT	SEGMENT
_e$2 = -84						; size = 20
_e$3 = -64						; size = 20
_e$4 = -64						; size = 20
_this$1$ = -44						; size = 4
_src_t$1$ = -40						; size = 4
_src_c$1$ = -36						; size = 4
_target$1$ = -32					; size = 4
_tile_target$1$ = -28					; size = 4
_tgt_t$1$ = -24						; size = 4
_tgt_c$1$ = -20						; size = 4
_source$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_source_ref$ = 8					; size = 4
_skip_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_transpose$ = 20					; size = 1
_vflip$ = 24						; size = 1
_hflip$ = 28						; size = 1
?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z PROC		; kdu_params::copy_all, COMDAT
; _this$ = ecx

; 1152 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 1153 :   if (source_ref->cluster_name != this->cluster_name)

	mov	esi, DWORD PTR _source_ref$[ebp]
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN16@copy_all

; 1154 :     { KDU_ERROR_DEV(e,11); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0GC@FAEHIHF@Trying?5to?5use?5?$GAkdu_params?3?3copy_@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1154 :     { KDU_ERROR_DEV(e,11); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1157 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN16@copy_all:

; 1158 : 
; 1159 :   kdu_params *source = source_ref;  // Keep `source_ref' for cluster navigation
; 1160 :   kdu_params *target = this;
; 1161 :   if ((source->tile_idx >= 0) || (source->comp_idx >= 0) ||
; 1162 :       (target->tile_idx >= 0) || (target->comp_idx >= 0))

	cmp	DWORD PTR [esi+8], 0
	mov	edx, esi
	mov	ebx, edi
	mov	DWORD PTR _source$1$[ebp], edx
	mov	DWORD PTR _target$1$[ebp], ebx
	jge	SHORT $LN18@copy_all
	cmp	DWORD PTR [esi+12], 0
	jge	SHORT $LN18@copy_all
	cmp	DWORD PTR [edi+8], 0
	jge	SHORT $LN18@copy_all
	cmp	DWORD PTR [edi+12], 0
	jl	SHORT $LN17@copy_all
$LN18@copy_all:

; 1163 :     { KDU_ERROR_DEV(e,12); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0JH@PHOILHHH@Trying?5to?5use?5?$GAkdu_params?3?3copy_@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1163 :     { KDU_ERROR_DEV(e,12); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1167 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	edx, DWORD PTR _source$1$[ebp]
$LN17@copy_all:

; 1168 : 
; 1169 :   int src_t = 0;
; 1170 :   int tgt_t = 0;

	xor	esi, esi
	mov	DWORD PTR _src_t$1$[ebp], 0
	mov	DWORD PTR _tgt_t$1$[ebp], esi
	npad	5
$LL2@copy_all:

; 1171 :   while ((source != NULL) && (target != NULL))

	test	ebx, ebx
	je	$LN3@copy_all

; 1172 :     {
; 1173 :       // Start by copying all components of `source' to `target'
; 1174 :       int src_c = skip_components;

	mov	eax, DWORD PTR _skip_components$[ebp]

; 1175 :       int tgt_c = 0;

	xor	ecx, ecx
	mov	DWORD PTR _src_c$1$[ebp], eax

; 1176 :       kdu_params *tile_source = source;
; 1177 :       kdu_params *tile_target = target;

	mov	eax, ebx
	mov	DWORD PTR _tgt_c$1$[ebp], ecx
	mov	edi, edx
	mov	DWORD PTR _tile_target$1$[ebp], eax

; 1178 :       while ((tile_source != NULL) && (tile_target != NULL))

	test	edx, edx
	je	$LN86@copy_all
$LL4@copy_all:
	test	eax, eax
	je	$LN86@copy_all

; 1179 :         {
; 1180 :           // Start by copying all instances of `tile_source' to `tile_target'.
; 1181 :           kdu_params *src = tile_source;
; 1182 :           kdu_params *dst = tile_target;

	mov	esi, eax

; 1183 :           while ((src != NULL) && (dst != NULL))

	test	edi, edi
	je	$LN57@copy_all
$LL6@copy_all:
	test	esi, esi
	je	$LN88@copy_all

; 1184 :             {
; 1185 :               if (dst->treat_instances_like_components)

	cmp	BYTE PTR [esi+34], 0
	je	SHORT $LN19@copy_all

; 1186 :                 { // Instance indices need not be contiguous
; 1187 :                   dst =

	push	0
	push	DWORD PTR [edi+16]
	mov	ecx, eax
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	esi, eax
$LN19@copy_all:

; 1188 :                     tile_target->access_relation(dst->tile_idx,dst->comp_idx,
; 1189 :                                                  src->inst_idx,false);
; 1190 :                   assert(dst != NULL); // Above function will create missing
; 1191 :                                        // instance if necessary.
; 1192 :                 }
; 1193 :               if (dst->marked)

	cmp	BYTE PTR [esi+29], 0
	je	SHORT $LN20@copy_all

; 1194 :                 { KDU_ERROR_DEV(e,13); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EP@FFHPHGIF@Illegal?5attempt?5to?5modify?5a?5?$GAkdu@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1194 :                 { KDU_ERROR_DEV(e,13); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1197 :                 }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN20@copy_all:

; 1198 :               if (dst->empty)

	cmp	BYTE PTR [esi+28], 0
	je	SHORT $LN21@copy_all

; 1199 :                 dst->copy_with_xforms(src,skip_components,discard_levels,

	push	DWORD PTR _hflip$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	DWORD PTR _vflip$[ebp]
	push	DWORD PTR _transpose$[ebp]
	push	DWORD PTR _discard_levels$[ebp]
	push	DWORD PTR _skip_components$[ebp]
	push	edi
	call	DWORD PTR [eax+8]
$LN21@copy_all:

; 1200 :                                       transpose,vflip,hflip);
; 1201 :               if (!dst->allow_insts)

	cmp	BYTE PTR [esi+32], 0
	je	SHORT $LN88@copy_all

; 1202 :                 break;
; 1203 :               src = src->next_inst;
; 1204 :               if (!dst->treat_instances_like_components)

	cmp	BYTE PTR [esi+34], 0
	mov	edi, DWORD PTR [edi+56]
	jne	SHORT $LN23@copy_all

; 1205 :                 { // Advance destination instance to match source instance;
; 1206 :                   // even if there is no further source instance, we should
; 1207 :                   // always have one empty instance at the end of the
; 1208 :                   // destination list, in case we need to write to it later.
; 1209 :                   if (dst->next_inst == NULL)

	cmp	DWORD PTR [esi+56], 0
	jne	SHORT $LN24@copy_all

; 1210 :                     dst->new_instance();

	mov	ecx, esi
	call	?new_instance@kdu_params@@QAEPAV1@XZ	; kdu_params::new_instance
$LN24@copy_all:

; 1211 :                   dst = dst->next_inst;

	mov	esi, DWORD PTR [esi+56]
$LN23@copy_all:

; 1183 :           while ((src != NULL) && (dst != NULL))

	mov	eax, DWORD PTR _tile_target$1$[ebp]
	test	edi, edi
	jne	$LL6@copy_all
$LN88@copy_all:
	mov	ebx, DWORD PTR _target$1$[ebp]
	mov	edx, DWORD PTR _source$1$[ebp]
	mov	ecx, DWORD PTR _tgt_c$1$[ebp]
$LN57@copy_all:

; 1212 :                 }
; 1213 :             }
; 1214 : 
; 1215 :           // Now advance the component indices
; 1216 :           do {
; 1217 :               if (src_c >= source->num_comps)

	mov	edx, DWORD PTR [edx+24]

; 1221 :                   source->refs[(src_t+1)*(source->num_comps+1)+src_c+1];
; 1222 :               if (tgt_c >= target->num_comps)

	mov	esi, DWORD PTR [ebx+24]
$LL10@copy_all:

; 1212 :                 }
; 1213 :             }
; 1214 : 
; 1215 :           // Now advance the component indices
; 1216 :           do {
; 1217 :               if (src_c >= source->num_comps)

	mov	edi, DWORD PTR _src_c$1$[ebp]
	cmp	edi, edx
	jl	SHORT $LN25@copy_all

; 1218 :                 tile_source = NULL; // No more sources

	xor	edi, edi

; 1219 :               else

	jmp	SHORT $LN26@copy_all
$LN25@copy_all:

; 1220 :                 tile_source =

	mov	eax, DWORD PTR _src_t$1$[ebp]
	lea	ecx, DWORD PTR [edx+1]
	inc	eax
	imul	ecx, eax
	mov	eax, DWORD PTR _source$1$[ebp]
	mov	eax, DWORD PTR [eax+44]
	add	ecx, edi
	mov	edi, DWORD PTR [eax+ecx*4+4]
	mov	ecx, DWORD PTR _tgt_c$1$[ebp]
$LN26@copy_all:

; 1221 :                   source->refs[(src_t+1)*(source->num_comps+1)+src_c+1];
; 1222 :               if (tgt_c >= target->num_comps)

	cmp	ecx, esi
	jl	SHORT $LN27@copy_all

; 1223 :                 tile_target = NULL;

	xor	eax, eax

; 1224 :               else

	jmp	SHORT $LN94@copy_all
$LN27@copy_all:

; 1225 :                 tile_target =

	mov	eax, DWORD PTR _tgt_t$1$[ebp]
	lea	ecx, DWORD PTR [esi+1]
	inc	eax
	imul	ecx, eax
	mov	eax, DWORD PTR [ebx+44]
	add	ecx, DWORD PTR _tgt_c$1$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4+4]
	mov	ecx, DWORD PTR _tgt_c$1$[ebp]
$LN94@copy_all:

; 1226 :                   target->refs[(tgt_t+1)*(target->num_comps+1)+tgt_c+1];
; 1227 :               src_c++;

	inc	DWORD PTR _src_c$1$[ebp]

; 1228 :               tgt_c++;

	inc	ecx
	mov	DWORD PTR _tile_target$1$[ebp], eax
	mov	DWORD PTR _tgt_c$1$[ebp], ecx

; 1229 :             } while ((tile_target == target) && (tile_source == source));

	cmp	eax, ebx
	jne	SHORT $LN92@copy_all
	cmp	edi, DWORD PTR _source$1$[ebp]
	je	SHORT $LL10@copy_all

; 1230 :               // Loops over those components for which both the source and
; 1231 :               // target are identical to their defaults
; 1232 :           if ((tile_target == target) && (tile_source != NULL))
; 1233 :             tile_target = target->access_relation(tgt_t-1,tgt_c-1,0,false);

	mov	esi, DWORD PTR _tgt_t$1$[ebp]
	test	edi, edi
	je	SHORT $LN91@copy_all
	push	0
	lea	eax, DWORD PTR [ecx-1]
	mov	ecx, ebx
	push	0
	push	eax
	lea	eax, DWORD PTR [esi-1]
	push	eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	ecx, DWORD PTR _tgt_c$1$[ebp]
	mov	DWORD PTR _tile_target$1$[ebp], eax
	jmp	SHORT $LN30@copy_all
$LN92@copy_all:
	mov	esi, DWORD PTR _tgt_t$1$[ebp]
$LN30@copy_all:

; 1178 :       while ((tile_source != NULL) && (tile_target != NULL))

	mov	edx, DWORD PTR _source$1$[ebp]
	test	edi, edi
	jne	$LL4@copy_all
	jmp	SHORT $LN86@copy_all
$LN91@copy_all:
	mov	edx, DWORD PTR _source$1$[ebp]
$LN86@copy_all:
	mov	edi, DWORD PTR _src_t$1$[ebp]
$LL13@copy_all:

; 1234 :               // Creates a unique entry for this tile to be copied
; 1235 :         }
; 1236 : 
; 1237 :       // Now advance the tile indices
; 1238 :       do {
; 1239 :           if (src_t >= source->num_tiles)

	cmp	edi, DWORD PTR [edx+20]
	jl	SHORT $LN31@copy_all

; 1240 :             source = NULL; // No more sources

	xor	edx, edx

; 1241 :           else

	jmp	SHORT $LN95@copy_all
$LN31@copy_all:

; 1242 :             source=source->refs[(src_t+1)*(source->num_comps+1)];

	mov	ecx, DWORD PTR [edx+24]
	lea	eax, DWORD PTR [edi+1]
	inc	ecx
	imul	ecx, eax
	mov	eax, DWORD PTR [edx+44]
	mov	edx, DWORD PTR [eax+ecx*4]
$LN95@copy_all:
	mov	DWORD PTR _source$1$[ebp], edx

; 1243 :           if (tgt_t >= target->num_tiles)

	cmp	esi, DWORD PTR [ebx+20]
	jl	SHORT $LN33@copy_all

; 1244 :             target = NULL;

	xor	ebx, ebx

; 1245 :           else

	jmp	SHORT $LN96@copy_all
$LN33@copy_all:

; 1246 :             target=target->refs[(tgt_t+1)*(target->num_comps+1)];

	mov	ecx, DWORD PTR [ebx+24]
	lea	eax, DWORD PTR [esi+1]
	inc	ecx
	imul	ecx, eax
	mov	eax, DWORD PTR [ebx+44]
	mov	ebx, DWORD PTR [eax+ecx*4]
$LN96@copy_all:

; 1247 :           src_t++;

	inc	edi
	mov	DWORD PTR _target$1$[ebp], ebx

; 1248 :           tgt_t++;

	inc	esi
	mov	DWORD PTR _src_t$1$[ebp], edi
	mov	DWORD PTR _tgt_t$1$[ebp], esi

; 1249 :         } while ((target != NULL) && (target->tile_idx == -1) &&
; 1250 :                  (source != NULL) && (source->tile_idx == -1));

	test	ebx, ebx
	je	SHORT $LN36@copy_all
	cmp	DWORD PTR [ebx+8], -1
	jne	SHORT $LN35@copy_all
	test	edx, edx
	je	SHORT $LN3@copy_all
	cmp	DWORD PTR [edx+8], -1
	je	SHORT $LL13@copy_all
$LN35@copy_all:

; 1251 :             // Loops over those tiles for which both the source and
; 1252 :             // target are identical to their defaults
; 1253 :       if ((target != NULL) && (source != NULL) && (target->tile_idx == -1))

	test	edx, edx
	je	SHORT $LN3@copy_all
	cmp	DWORD PTR [ebx+8], -1
	jne	SHORT $LN36@copy_all

; 1254 :         target = target->access_relation(tgt_t-1,-1,0,false);

	push	0
	push	0
	push	-1
	lea	eax, DWORD PTR [esi-1]
	mov	ecx, ebx
	push	eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	edx, DWORD PTR _source$1$[ebp]
	mov	ebx, eax
	mov	DWORD PTR _target$1$[ebp], ebx
$LN36@copy_all:

; 1171 :   while ((source != NULL) && (target != NULL))

	test	edx, edx
	jne	$LL2@copy_all
$LN3@copy_all:

; 1255 :            // Creates a unique entry for this tile to be copied
; 1256 :     }
; 1257 : 
; 1258 :   // Now see if we need to copy other clusters
; 1259 :   source = source_ref;
; 1260 :   target = this;
; 1261 :   if ((source != source->first_cluster) ||

	mov	esi, DWORD PTR _source_ref$[ebp]
	cmp	esi, DWORD PTR [esi+36]
	jne	SHORT $LN38@copy_all
	mov	edi, DWORD PTR _this$1$[ebp]
	cmp	edi, DWORD PTR [edi+36]
	jne	SHORT $LN38@copy_all

; 1262 :       (target != target->first_cluster))
; 1263 :     return;
; 1264 :   source = source->next_cluster;

	mov	esi, DWORD PTR [esi+40]

; 1265 :   target = target->next_cluster;

	mov	edi, DWORD PTR [edi+40]

; 1266 :   while ((source != NULL) && (target != NULL))

	test	esi, esi
	je	SHORT $LN38@copy_all
	npad	6
$LL14@copy_all:
	test	edi, edi
	je	SHORT $LN38@copy_all

; 1267 :     {
; 1268 :       target->copy_all(source,skip_components,discard_levels,

	push	DWORD PTR _hflip$[ebp]
	mov	ecx, edi
	push	DWORD PTR _vflip$[ebp]
	push	DWORD PTR _transpose$[ebp]
	push	DWORD PTR _discard_levels$[ebp]
	push	DWORD PTR _skip_components$[ebp]
	push	esi
	call	?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z	; kdu_params::copy_all

; 1269 :                        transpose,vflip,hflip);
; 1270 :       source = source->next_cluster;

	mov	esi, DWORD PTR [esi+40]

; 1271 :       target = target->next_cluster;

	mov	edi, DWORD PTR [edi+40]
	test	esi, esi
	jne	SHORT $LL14@copy_all
$LN38@copy_all:

; 1272 :     }
; 1273 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z$1:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?copy_all@kdu_params@@QAEXPAV1@HH_N11@Z ENDP		; kdu_params::copy_all
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z
_TEXT	SEGMENT
_e$2 = -76						; size = 20
_e$3 = -56						; size = 20
_e$4 = -56						; size = 20
_this$1$ = -36						; size = 4
_tgt_c$1$ = -32						; size = 4
_src_c$1$ = -28						; size = 4
tv667 = -24						; size = 4
_source$1$ = -20					; size = 4
_src$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_source_ref$ = 8					; size = 4
_source_tile$ = 12					; size = 4
_target_tile$ = 16					; size = 4
_instance$ = 20						; size = 4
_skip_components$ = 24					; size = 4
_discard_levels$ = 28					; size = 4
_transpose$ = 32					; size = 1
_vflip$ = 36						; size = 1
_hflip$ = 40						; size = 1
?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z PROC	; kdu_params::copy_from, COMDAT
; _this$ = ecx

; 1021 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 1022 :   if (source_ref->cluster_name != this->cluster_name)

	mov	esi, DWORD PTR _source_ref$[ebp]
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [edi+4]
	je	SHORT $LN11@copy_from

; 1023 :     { KDU_ERROR_DEV(e,8); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0GD@HANNBBLP@Trying?5to?5use?5?$GAkdu_params?3?3copy_@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1023 :     { KDU_ERROR_DEV(e,8); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1026 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN11@copy_from:

; 1027 : 
; 1028 :   kdu_params *source = source_ref;  // Keep `source_ref' for cluster navigation
; 1029 :   kdu_params *target = this;
; 1030 :   if ((source->tile_idx >= 0) || (source->comp_idx >= 0) ||
; 1031 :       (target->tile_idx >= 0) || (target->comp_idx >= 0))

	cmp	DWORD PTR [esi+8], 0
	jge	SHORT $LN13@copy_from
	cmp	DWORD PTR [esi+12], 0
	jge	SHORT $LN13@copy_from
	cmp	DWORD PTR [edi+8], 0
	jge	SHORT $LN13@copy_from
	cmp	DWORD PTR [edi+12], 0
	jl	SHORT $LN12@copy_from
$LN13@copy_from:

; 1032 :     { KDU_ERROR_DEV(e,9); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0JI@GAIBBJLH@Trying?5to?5use?5?$GAkdu_params?3?3copy_@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1032 :     { KDU_ERROR_DEV(e,9); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1036 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN12@copy_from:

; 1037 : 
; 1038 :   if (source_tile < source->num_tiles)

	mov	eax, DWORD PTR _source_tile$[ebp]
	cmp	eax, DWORD PTR [esi+20]
	jge	SHORT $LN14@copy_from

; 1039 :     source = source->refs[(source_tile+1)*(source->num_comps+1)];

	mov	ecx, DWORD PTR [esi+24]
	inc	eax
	inc	ecx
	imul	ecx, eax
	mov	eax, DWORD PTR [esi+44]
	mov	ebx, DWORD PTR [eax+ecx*4]

; 1040 :   else

	jmp	SHORT $LN84@copy_from
$LN14@copy_from:

; 1041 :     source = NULL; // Can't copy anything in this cluster

	xor	ebx, ebx
$LN84@copy_from:

; 1042 : 
; 1043 :   if (target_tile < target->num_tiles)

	mov	edx, DWORD PTR _target_tile$[ebp]
	mov	DWORD PTR _source$1$[ebp], ebx
	cmp	edx, DWORD PTR [edi+20]
	jge	SHORT $LN16@copy_from

; 1044 :     {
; 1045 :       target = target->refs[(target_tile+1)*(target->num_comps+1)];

	mov	ecx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR [edx+1]
	inc	ecx
	imul	ecx, eax
	mov	eax, DWORD PTR [edi+44]
	mov	edi, DWORD PTR [eax+ecx*4]

; 1046 :       if ((target != NULL) && (target->tile_idx == -1) && (target_tile >= 0))

	test	edi, edi
	je	SHORT $LN17@copy_from
	cmp	DWORD PTR [edi+8], -1
	jne	SHORT $LN17@copy_from
	test	edx, edx
	js	SHORT $LN17@copy_from

; 1047 :         { // See if we need to create a new target object
; 1048 :           if ((source != NULL) && (source->tile_idx >= 0))

	test	ebx, ebx
	je	SHORT $LN16@copy_from
	cmp	DWORD PTR [ebx+8], 0
	jl	SHORT $LN16@copy_from

; 1049 :             {
; 1050 :               target = target->access_relation(target_tile,-1,0,false);

	push	0
	push	0
	push	-1
	push	edx
	mov	ecx, edi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	edi, eax

; 1051 :               assert(target->tile_idx == target_tile);
; 1052 :             }
; 1053 :           else

	jmp	SHORT $LN17@copy_from
$LN16@copy_from:

; 1054 :             target = NULL; // No need to copy anything in this cluster
; 1055 :         }
; 1056 :     }
; 1057 :   else
; 1058 :     target = NULL; // Can't copy anything in this cluster

	xor	edi, edi
$LN17@copy_from:

; 1059 : 
; 1060 : 
; 1061 :   int src_c = skip_components;

	mov	eax, DWORD PTR _skip_components$[ebp]
	mov	DWORD PTR _src_c$1$[ebp], eax

; 1062 :   int tgt_c = 0;

	mov	DWORD PTR _tgt_c$1$[ebp], 0

; 1063 :   while ((source != NULL) && (target != NULL))

	test	ebx, ebx
	je	$LN3@copy_from
$LL2@copy_from:
	test	edi, edi
	je	$LN81@copy_from

; 1064 :     {
; 1065 :       // Start by copying `source' to `target'
; 1066 :       kdu_params *src = source;
; 1067 :       kdu_params *dst = target;
; 1068 :       bool matched_all_instances = false;

	xor	dl, dl
	mov	ecx, ebx
	mov	DWORD PTR _src$1$[ebp], ecx
	mov	esi, edi
	mov	DWORD PTR tv667[ebp], edx

; 1069 :       while ((src != NULL) && (dst != NULL) && !matched_all_instances)

	test	ebx, ebx
	je	$LN78@copy_from
$LL4@copy_from:
	test	esi, esi
	je	$LN80@copy_from
	test	dl, dl
	jne	$LN80@copy_from

; 1070 :         {
; 1071 :           if ((src->inst_idx == instance) || (instance < 0))

	mov	eax, DWORD PTR [ecx+16]
	mov	ebx, DWORD PTR _instance$[ebp]
	cmp	eax, ebx
	je	SHORT $LN22@copy_from
	test	ebx, ebx
	jns	$LN26@copy_from
$LN22@copy_from:

; 1072 :             { // Can copy this instance
; 1073 :               if (dst->treat_instances_like_components)

	cmp	BYTE PTR [esi+34], 0
	je	SHORT $LN23@copy_from

; 1074 :                 { // Instance indices need not be contiguous
; 1075 :                   dst = target->access_relation(dst->tile_idx,dst->comp_idx,

	push	0
	push	eax
	push	DWORD PTR [esi+12]
	mov	ecx, edi
	push	DWORD PTR [esi+8]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	esi, eax
$LN23@copy_from:

; 1076 :                                                 src->inst_idx,false);
; 1077 :                   assert(dst != NULL); // Above function will create missing
; 1078 :                                        // instance if necessary.
; 1079 :                 }
; 1080 :               if (dst->marked)

	cmp	BYTE PTR [esi+29], 0
	je	SHORT $LN24@copy_from

; 1081 :                 { KDU_ERROR_DEV(e,10); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EP@FFHPHGIF@Illegal?5attempt?5to?5modify?5a?5?$GAkdu@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1081 :                 { KDU_ERROR_DEV(e,10); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 1084 :                 }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN24@copy_from:

; 1085 :               if (dst->empty)

	cmp	BYTE PTR [esi+28], 0
	je	SHORT $LN25@copy_from

; 1086 :                 dst->copy_with_xforms(src,skip_components,discard_levels,

	push	DWORD PTR _hflip$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	DWORD PTR _vflip$[ebp]
	push	DWORD PTR _transpose$[ebp]
	push	DWORD PTR _discard_levels$[ebp]
	push	DWORD PTR _skip_components$[ebp]
	push	DWORD PTR _src$1$[ebp]
	call	DWORD PTR [eax+8]
$LN25@copy_from:

; 1087 :                                       transpose,vflip,hflip);
; 1088 :               if (instance >= 0)

	mov	edx, DWORD PTR tv667[ebp]
	test	ebx, ebx
	mov	ecx, DWORD PTR _src$1$[ebp]
	mov	eax, 1
	movzx	edx, dl
	cmovns	edx, eax
	mov	DWORD PTR tv667[ebp], edx
$LN26@copy_from:

; 1089 :                 matched_all_instances = true;
; 1090 :             }
; 1091 :           if (!dst->allow_insts)

	cmp	BYTE PTR [esi+32], 0
	je	SHORT $LN80@copy_from

; 1092 :             break;
; 1093 : 
; 1094 :           src = src->next_inst;
; 1095 :           if (!dst->treat_instances_like_components)

	cmp	BYTE PTR [esi+34], 0
	mov	ecx, DWORD PTR [ecx+56]
	mov	DWORD PTR _src$1$[ebp], ecx
	jne	SHORT $LN28@copy_from

; 1096 :             { // Advance destination instance to match source instance;
; 1097 :               // even if there is no further source instance, we should
; 1098 :               // always have one empty instance at the end of the
; 1099 :               // destination list, in case we need to write to it later.
; 1100 :               if (dst->next_inst == NULL)

	cmp	DWORD PTR [esi+56], 0
	jne	SHORT $LN29@copy_from

; 1101 :                 dst->new_instance();

	mov	ecx, esi
	call	?new_instance@kdu_params@@QAEPAV1@XZ	; kdu_params::new_instance
	mov	ecx, DWORD PTR _src$1$[ebp]
$LN29@copy_from:

; 1102 :               dst = dst->next_inst;

	mov	esi, DWORD PTR [esi+56]
$LN28@copy_from:

; 1069 :       while ((src != NULL) && (dst != NULL) && !matched_all_instances)

	mov	edx, DWORD PTR tv667[ebp]
	test	ecx, ecx
	jne	$LL4@copy_from
$LN80@copy_from:
	mov	ebx, DWORD PTR _source$1$[ebp]
$LN78@copy_from:
	mov	edx, DWORD PTR _tgt_c$1$[ebp]
	mov	esi, DWORD PTR _src_c$1$[ebp]
$LL8@copy_from:

; 1103 :             }
; 1104 :         }
; 1105 : 
; 1106 :       // Find the next `source' and `target' objects to copy
; 1107 :       do {
; 1108 :           if (src_c >= source->num_comps)

	mov	ecx, DWORD PTR [ebx+24]
	cmp	esi, ecx
	jl	SHORT $LN30@copy_from

; 1109 :             source = NULL; // No more sources

	xor	ebx, ebx

; 1110 :           else

	jmp	SHORT $LN85@copy_from
$LN30@copy_from:

; 1111 :             source=source->refs[(source_tile+1)*(source->num_comps+1)+src_c+1];

	mov	eax, DWORD PTR _source_tile$[ebp]
	inc	ecx
	inc	eax
	imul	ecx, eax
	mov	eax, DWORD PTR [ebx+44]
	add	ecx, esi
	mov	ebx, DWORD PTR [eax+ecx*4+4]
$LN85@copy_from:

; 1112 :           if (tgt_c >= target->num_comps)

	mov	ecx, DWORD PTR [edi+24]
	mov	DWORD PTR _source$1$[ebp], ebx
	cmp	edx, ecx
	jl	SHORT $LN32@copy_from

; 1113 :             target = NULL;

	xor	edi, edi

; 1114 :           else

	jmp	SHORT $LN33@copy_from
$LN32@copy_from:

; 1115 :             target=target->refs[(target_tile+1)*(target->num_comps+1)+tgt_c+1];

	mov	eax, DWORD PTR _target_tile$[ebp]
	inc	ecx
	inc	eax
	imul	ecx, eax
	mov	eax, DWORD PTR [edi+44]
	add	ecx, edx
	mov	edi, DWORD PTR [eax+ecx*4+4]
$LN33@copy_from:

; 1116 :           src_c++;

	inc	esi

; 1117 :           tgt_c++;

	inc	edx
	mov	DWORD PTR _src_c$1$[ebp], esi
	mov	DWORD PTR _tgt_c$1$[ebp], edx

; 1118 :         } while ((target != NULL) && (target->comp_idx == -1) &&
; 1119 :                  (source != NULL) && (source->comp_idx == -1));

	test	edi, edi
	je	SHORT $LN35@copy_from
	cmp	DWORD PTR [edi+12], -1
	jne	SHORT $LN35@copy_from
	test	ebx, ebx
	je	SHORT $LN34@copy_from
	cmp	DWORD PTR [ebx+12], -1
	je	SHORT $LL8@copy_from
$LN34@copy_from:

; 1120 :             // Loops over those components for which both the source and
; 1121 :             // target are identical to their defaults
; 1122 :       if ((target != NULL) && (target->comp_idx == -1))

	cmp	DWORD PTR [edi+12], -1
	jne	SHORT $LN35@copy_from

; 1123 :         target = target->access_relation(target_tile,tgt_c-1,0,false);

	push	0
	push	0
	lea	eax, DWORD PTR [edx-1]
	mov	ecx, edi
	push	eax
	push	DWORD PTR _target_tile$[ebp]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	edi, eax
$LN35@copy_from:

; 1063 :   while ((source != NULL) && (target != NULL))

	test	ebx, ebx
	jne	$LL2@copy_from
$LN81@copy_from:
	mov	eax, DWORD PTR _skip_components$[ebp]
	mov	esi, DWORD PTR _source_ref$[ebp]
$LN3@copy_from:

; 1124 :            // Creates a unique entry for this tile-component to be copied
; 1125 :     }
; 1126 : 
; 1127 :   // Now see if we need to copy other clusters
; 1128 :   source = source_ref;
; 1129 :   target = this;
; 1130 :   if ((source != source->first_cluster) ||

	cmp	esi, DWORD PTR [esi+36]
	jne	SHORT $LN37@copy_from
	mov	edi, DWORD PTR _this$1$[ebp]
	cmp	edi, DWORD PTR [edi+36]
	jne	SHORT $LN37@copy_from

; 1131 :       (target != target->first_cluster))
; 1132 :     return;
; 1133 :   source = source->next_cluster;

	mov	esi, DWORD PTR [esi+40]

; 1134 :   target = target->next_cluster;

	mov	edi, DWORD PTR [edi+40]

; 1135 :   while ((source != NULL) && (target != NULL))

	test	esi, esi
	je	SHORT $LN37@copy_from
	npad	7
$LL9@copy_from:
	test	edi, edi
	je	SHORT $LN37@copy_from

; 1136 :     {
; 1137 :       target->copy_from(source,source_tile,target_tile,instance,

	push	DWORD PTR _hflip$[ebp]
	mov	ecx, edi
	push	DWORD PTR _vflip$[ebp]
	push	DWORD PTR _transpose$[ebp]
	push	DWORD PTR _discard_levels$[ebp]
	push	eax
	push	DWORD PTR _instance$[ebp]
	push	DWORD PTR _target_tile$[ebp]
	push	DWORD PTR _source_tile$[ebp]
	push	esi
	call	?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z ; kdu_params::copy_from

; 1138 :                         skip_components,discard_levels,transpose,vflip,hflip);
; 1139 :       source = source->next_cluster;

	mov	esi, DWORD PTR [esi+40]

; 1140 :       target = target->next_cluster;

	mov	edi, DWORD PTR [edi+40]
	mov	eax, DWORD PTR _skip_components$[ebp]
	test	esi, esi
	jne	SHORT $LL9@copy_from
$LN37@copy_from:

; 1141 :     }
; 1142 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z$1:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z ENDP	; kdu_params::copy_from
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?new_instance@kdu_params@@QAEPAV1@XZ
_TEXT	SEGMENT
?new_instance@kdu_params@@QAEPAV1@XZ PROC		; kdu_params::new_instance, COMDAT
; _this$ = ecx

; 986  : {

	push	esi
	mov	esi, ecx

; 987  :   if (!allow_insts)

	cmp	BYTE PTR [esi+32], 0
	jne	SHORT $LN7@new_instan
$LN24@new_instan:

; 988  :     return NULL; // Multiple instances not allowed

	xor	eax, eax
	pop	esi

; 1010 : }

	ret	0
$LN7@new_instan:

; 989  :   if ((comp_idx < 0) && (num_comps > 0))

	cmp	DWORD PTR [esi+12], 0
	jge	SHORT $LN8@new_instan
	cmp	DWORD PTR [esi+24], 0
	jg	SHORT $LN24@new_instan
$LN8@new_instan:

; 990  :     return NULL; // Can't build instance list on potentially shared default
; 991  :   if ((tile_idx < 0) && (num_tiles > 0) && !treat_instances_like_components)

	cmp	DWORD PTR [esi+8], 0
	jge	SHORT $LN9@new_instan
	cmp	DWORD PTR [esi+20], 0
	jle	SHORT $LN9@new_instan
	cmp	BYTE PTR [esi+34], 0
	je	SHORT $LN24@new_instan
$LN9@new_instan:

; 992  :     return NULL; // Can't build instance list on potentially shared default
; 993  : 
; 994  :   kdu_params *result = new_object();

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax]

; 995  :   kdu_params *scan = this;
; 996  :   result->refs = refs;

	mov	ecx, DWORD PTR [esi+44]
	mov	edx, eax
	mov	DWORD PTR [edx+44], ecx

; 997  :   result->tile_idx = tile_idx;

	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [edx+8], ecx

; 998  :   result->comp_idx = comp_idx;

	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [edx+12], ecx

; 999  :   result->num_tiles = num_tiles;

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [edx+20], ecx

; 1000 :   result->num_comps = num_comps;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edx+24], eax

; 1001 :   result->first_cluster = NULL;
; 1002 :   while (scan->next_inst != NULL)

	lea	eax, DWORD PTR [esi+56]
	mov	DWORD PTR [edx+36], 0
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@new_instan
	npad	2
$LL2@new_instan:

; 1003 :     scan = scan->next_inst;

	mov	esi, DWORD PTR [eax]
	cmp	DWORD PTR [esi+56], 0
	lea	eax, DWORD PTR [esi+56]
	jne	SHORT $LL2@new_instan
$LN3@new_instan:

; 1004 :   scan->next_inst = result;
; 1005 :   result->first_inst = scan->first_inst;

	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+56], edx
	mov	DWORD PTR [edx+52], eax

; 1006 :   result->inst_idx = scan->inst_idx+1;

	mov	eax, DWORD PTR [esi+16]
	inc	eax
	mov	DWORD PTR [edx+16], eax

; 1007 :   for (int i=0; i <= KD_MAX_PARAM_DEPENDENCIES; i++)
; 1008 :     result->dependencies[i] = scan->dependencies[i];

	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [edx+68], eax
	mov	eax, DWORD PTR [esi+72]
	mov	DWORD PTR [edx+72], eax
	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR [edx+76], eax
	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [edx+80], eax
	mov	eax, DWORD PTR [esi+84]
	mov	DWORD PTR [edx+84], eax

; 1009 :   return result;

	mov	eax, edx
	pop	esi

; 1010 : }

	ret	0
?new_instance@kdu_params@@QAEPAV1@XZ ENDP		; kdu_params::new_instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z
_TEXT	SEGMENT
_e$2 = -52						; size = 20
_e$3 = -32						; size = 20
_e$4 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_existing$ = 8						; size = 4
tv476 = 12						; size = 4
_tile_idx$ = 12						; size = 4
_comp_idx$ = 16						; size = 4
_num_refs$1$ = 20					; size = 4
_num_tiles$ = 20					; size = 4
_num_comps$ = 24					; size = 4
?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z PROC		; kdu_params::link, COMDAT
; _this$ = ecx

; 883  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 884  :   kdu_params *cluster, *prev_cluster;
; 885  : 
; 886  :   assert((this->tile_idx == -1) && (this->comp_idx == -1) &&
; 887  :          (this->inst_idx == 0) && (this->refs == &this->dummy_ref) &&
; 888  :          (tile_idx < num_tiles) && (comp_idx < num_comps) &&
; 889  :          (tile_idx >= -1) && (comp_idx >= -1));
; 890  :   this->tile_idx = tile_idx;
; 891  :   this->comp_idx = comp_idx;
; 892  :   this->num_tiles = num_tiles;
; 893  :   this->num_comps = num_comps;
; 894  :   this->first_cluster = NULL; // May set a non-trivial value later
; 895  : 
; 896  :   if (((!allow_tiles) && (num_tiles > 0)) ||

	cmp	BYTE PTR [ebx+30], 0
	mov	eax, DWORD PTR _comp_idx$[ebp]
	mov	ecx, DWORD PTR _tile_idx$[ebp]
	mov	edi, DWORD PTR _num_comps$[ebp]
	mov	DWORD PTR [ebx+12], eax
	mov	eax, DWORD PTR _num_tiles$[ebp]
	mov	DWORD PTR [ebx+8], ecx
	mov	DWORD PTR [ebx+20], eax
	mov	DWORD PTR [ebx+24], edi
	mov	DWORD PTR [ebx+36], 0
	jne	SHORT $LN12@link
	test	eax, eax
	jg	SHORT $LN11@link
$LN12@link:
	cmp	BYTE PTR [ebx+31], 0
	jne	SHORT $LN10@link
	test	edi, edi
	jle	SHORT $LN10@link
$LN11@link:

; 898  :     { KDU_ERROR_DEV(e,5); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0OO@BFNLONCD@Illegal?5tile?5or?5component?5indice@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 898  :     { KDU_ERROR_DEV(e,5); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 903  :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN10@link:

; 904  : 
; 905  :   cluster = existing->first_inst->first_cluster;

	mov	eax, DWORD PTR _existing$[ebp]
	mov	eax, DWORD PTR [eax+52]
	mov	esi, DWORD PTR [eax+36]

; 906  :   for (prev_cluster=NULL;
; 907  :        cluster != NULL;

	test	esi, esi
	je	$LN15@link
	npad	1
$LL4@link:

; 909  :     if (strcmp(cluster->cluster_name,this->cluster_name) == 0)

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [esi+4]
$LL51@link:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN52@link
	test	dl, dl
	je	SHORT $LN53@link
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN52@link
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL51@link
$LN53@link:
	xor	eax, eax
	jmp	SHORT $LN54@link
$LN52@link:
	sbb	eax, eax
	or	eax, 1
$LN54@link:
	test	eax, eax
	je	SHORT $LN14@link

; 908  :        prev_cluster=cluster, cluster=cluster->next_cluster)

	mov	ecx, esi
	mov	esi, DWORD PTR [esi+40]
	test	esi, esi
	jne	SHORT $LL4@link

; 910  :       break;
; 911  :   if (cluster == NULL)
; 912  :     { /* Link as head of new cluster. */
; 913  :       assert((tile_idx == -1) && (comp_idx == -1));
; 914  :             /* Cluster head must have component and tile indices of -1. */
; 915  :       if (prev_cluster != NULL)

	test	ecx, ecx
	je	$LN15@link

; 916  :         {
; 917  :           this->first_cluster = prev_cluster->first_cluster;

	mov	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR [ebx+36], eax

; 918  :           prev_cluster->next_cluster = this;

	mov	DWORD PTR [ecx+40], ebx

; 919  :         }
; 920  :       else

	jmp	$LN16@link
$LN14@link:

; 929  :     }
; 930  : 
; 931  :   if ((cluster->num_comps != num_comps) || (cluster->num_tiles != num_tiles))

	cmp	DWORD PTR [esi+24], edi
	jne	SHORT $LN18@link
	mov	eax, DWORD PTR _num_tiles$[ebp]
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN17@link
$LN18@link:

; 932  :     { KDU_ERROR_DEV(e,6); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0KB@EJFHGKHN@Call?5to?5?$GAkdu_params?3?3link?8?5speci@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 932  :     { KDU_ERROR_DEV(e,6); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 936  :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN17@link:

; 937  : 
; 938  :   refs = cluster->refs;
; 939  :   assert(refs != &dummy_ref);
; 940  :   int ref_idx = (num_comps+1)*(tile_idx+1) + (comp_idx+1);

	mov	ecx, DWORD PTR _tile_idx$[ebp]
	lea	eax, DWORD PTR [edi+1]
	mov	edi, DWORD PTR _comp_idx$[ebp]
	inc	ecx
	mov	edx, DWORD PTR [esi+44]
	imul	ecx, eax
	mov	DWORD PTR [ebx+44], edx
	lea	eax, DWORD PTR [edi+1]
	add	eax, ecx

; 941  :   kdu_params *rf = refs[ref_idx];

	mov	esi, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [edx+eax*4]

; 942  :   if ((rf != NULL) && (rf != this) &&
; 943  :       (rf->comp_idx == comp_idx) && (rf->tile_idx == tile_idx))

	test	esi, esi
	je	SHORT $LN19@link
	cmp	esi, ebx
	je	SHORT $LN19@link
	cmp	DWORD PTR [esi+12], edi
	jne	SHORT $LN19@link
	mov	ecx, DWORD PTR _tile_idx$[ebp]
	cmp	DWORD PTR [esi+8], ecx
	jne	SHORT $LN19@link

; 944  :     { // Linking a new instance of current tile-component
; 945  :       if (!allow_insts)

	cmp	BYTE PTR [ebx+32], 0
	jne	SHORT $LN34@link

; 946  :         { KDU_ERROR_DEV(e,7); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0KA@FKBGPIEK@Call?5to?5?$GAkdu_params?3?3link?8?5speci@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 946  :         { KDU_ERROR_DEV(e,7); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 950  :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN34@link:

; 951  :       while (rf->next_inst != NULL)

	cmp	DWORD PTR [esi+56], 0
	lea	eax, DWORD PTR [esi+56]
	je	SHORT $LN9@link
	npad	8
$LL8@link:

; 952  :         rf = rf->next_inst;

	mov	esi, DWORD PTR [eax]
	cmp	DWORD PTR [esi+56], 0
	lea	eax, DWORD PTR [esi+56]
	jne	SHORT $LL8@link
$LN9@link:

; 953  :       this->first_inst = rf->first_inst;

	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [ebx+52], eax

; 954  :       rf->next_inst = this;
; 955  :       this->inst_idx = rf->inst_idx + 1;

	mov	eax, DWORD PTR [esi+16]
	inc	eax
	mov	DWORD PTR [esi+56], ebx
	mov	DWORD PTR [ebx+16], eax

; 956  :     }
; 957  :   else

	jmp	$LN6@link
$LN19@link:

; 958  :     refs[ref_idx] = this;

	mov	DWORD PTR [eax], ebx

; 959  : 
; 960  :   return this;

	jmp	$LN6@link
$LN15@link:

; 921  :         this->first_cluster = this;

	mov	DWORD PTR [ebx+36], ebx
$LN16@link:

; 922  :       next_cluster = NULL;
; 923  :       int n, num_refs = (num_tiles+1)*(num_comps+1);

	mov	edi, DWORD PTR _num_tiles$[ebp]

; 924  :       refs = NULL;
; 925  :       refs = new kdu_params *[num_refs];

	xor	ecx, ecx
	mov	eax, DWORD PTR _num_comps$[ebp]
	inc	edi
	inc	eax
	mov	DWORD PTR [ebx+40], 0
	imul	edi, eax
	mov	edx, 4
	mov	DWORD PTR [ebx+44], 0
	mov	eax, edi
	mov	DWORD PTR _num_refs$1$[ebp], edi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, eax
	add	esp, 4
	lea	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR tv476[ebp], ecx

; 926  :       for (n=0; n < num_refs; n++)

	xor	esi, esi
	mov	DWORD PTR [eax], ecx
	test	edi, edi
	jle	SHORT $LN6@link
	cmp	edi, 4
	jb	SHORT $LN40@link
	lea	edx, DWORD PTR [edi-1]
	lea	edx, DWORD PTR [ecx+edx*4]
	cmp	ecx, eax
	ja	SHORT $LN41@link
	cmp	edx, eax
	jae	SHORT $LN40@link
$LN41@link:
	mov	eax, edi
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN56@link
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN56@link:
	sub	edi, eax
$LL7@link:
	add	esi, 4
	cmp	esi, edi
	jl	SHORT $LL7@link

; 927  :         refs[n] = this;

	lea	eax, DWORD PTR [edi+3]
	mov	edi, DWORD PTR tv476[ebp]
	cdq
	and	edx, 3
	lea	ecx, DWORD PTR [edx+eax]
	mov	eax, ebx
	sar	ecx, 2
	shl	ecx, 4
	shr	ecx, 2
	rep stosd
	mov	edi, DWORD PTR _num_refs$1$[ebp]
	lea	eax, DWORD PTR [ebx+44]
$LN40@link:

; 926  :       for (n=0; n < num_refs; n++)

	cmp	esi, edi
	jge	SHORT $LN6@link
	npad	1
$LL39@link:

; 927  :         refs[n] = this;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+esi*4], ebx
	inc	esi
	lea	eax, DWORD PTR [ebx+44]
	cmp	esi, edi
	jl	SHORT $LL39@link
$LN6@link:

; 928  :       return this;

	mov	eax, ebx

; 961  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z$1:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z ENDP		; kdu_params::link
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??1kdu_params@@UAE@XZ
_TEXT	SEGMENT
_ref_idx$1$ = -4					; size = 4
??1kdu_params@@UAE@XZ PROC				; kdu_params::~kdu_params, COMDAT
; _this$ = ecx

; 784  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi

; 788  :   while ((att=attributes) != NULL)

	mov	edi, DWORD PTR [esi+60]
	mov	DWORD PTR [esi], OFFSET ??_7kdu_params@@6B@
	test	edi, edi
	je	SHORT $LN3@kdu_params
$LL2@kdu_params:

; 789  :     {
; 790  :       attributes = att->next;

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+60], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params_local.h

; 91   :       { delete[](values); }

	push	DWORD PTR [edi+24]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	40					; 00000028H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp

; 788  :   while ((att=attributes) != NULL)

	mov	edi, DWORD PTR [esi+60]
	add	esp, 12					; 0000000cH
	test	edi, edi
	jne	SHORT $LL2@kdu_params
$LN3@kdu_params:

; 791  :       delete(att);
; 792  :     }
; 793  : 
; 794  :   // Process instance list
; 795  :   if (first_inst == NULL)

	mov	ecx, DWORD PTR [esi+52]
	test	ecx, ecx
	je	$LN34@kdu_params

; 796  :     return; // Function being used to delete all elements of instance list.
; 797  :   if (this != first_inst)

	cmp	esi, ecx
	je	SHORT $LN58@kdu_params

; 798  :     { // Relink instance list.
; 799  :       for (csp=first_inst; this != csp->next_inst; csp=csp->next_inst);

	mov	eax, DWORD PTR [ecx+56]
	cmp	esi, eax
	je	SHORT $LN5@kdu_params
	npad	5
$LL6@kdu_params:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+56]
	cmp	esi, eax
	jne	SHORT $LL6@kdu_params
$LN5@kdu_params:

; 800  :       csp->next_inst = this->next_inst;

	mov	eax, DWORD PTR [esi+56]
	pop	edi
	mov	DWORD PTR [ecx+56], eax
	pop	esi

; 873  :     }
; 874  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN58@kdu_params:

; 801  :       return;
; 802  :     }
; 803  :   while ((csp=next_inst) != NULL)

	mov	ecx, DWORD PTR [esi+56]
	test	ecx, ecx
	je	SHORT $LN8@kdu_params
	npad	4
$LL7@kdu_params:

; 804  :     { // Delete rest of instance list.
; 805  :       next_inst = csp->next_inst;

	mov	eax, DWORD PTR [ecx+56]
	mov	DWORD PTR [esi+56], eax

; 806  :       csp->first_inst = NULL; // Prevent further instance list processing.

	mov	DWORD PTR [ecx+52], 0

; 807  :       delete csp;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [esi+56]
	test	ecx, ecx
	jne	SHORT $LL7@kdu_params
$LN8@kdu_params:

; 808  :     }
; 809  : 
; 810  :   // Update `refs' entry
; 811  :   assert(this == first_inst);
; 812  :   kdu_params **sref;
; 813  :   int n, ref_idx = (tile_idx+1)*(num_comps+1)+(comp_idx+1);

	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+8]
	inc	ecx
	mov	edx, DWORD PTR [esi+12]
	inc	eax
	imul	ecx, eax
	inc	edx
	push	ebx
	add	edx, ecx

; 814  :   if (refs != NULL)

	mov	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _ref_idx$1$[ebp], edx
	test	ecx, ecx
	je	SHORT $LN10@kdu_params

; 815  :     { // Otherwise, we have already visited the components columnwise
; 816  :       assert(refs[ref_idx] == this);
; 817  :       refs[ref_idx] = NULL;

	lea	eax, DWORD PTR [edx*4]
	mov	DWORD PTR [eax+ecx], 0

; 818  : 
; 819  :       // Process components
; 820  :       if (comp_idx < 0)

	cmp	DWORD PTR [esi+12], 0
	jge	SHORT $LN10@kdu_params

; 821  :         {
; 822  :           for (sref=refs+ref_idx, n=num_comps; n > 0; n--)

	mov	edi, DWORD PTR [esi+44]
	mov	ebx, DWORD PTR [esi+24]
	add	edi, eax
	test	ebx, ebx
	jle	SHORT $LN10@kdu_params
$LL11@kdu_params:

; 823  :             {
; 824  :               sref++;
; 825  :               if (*sref == this)

	mov	ecx, DWORD PTR [edi+4]
	lea	edi, DWORD PTR [edi+4]
	cmp	ecx, esi
	jne	SHORT $LN25@kdu_params

; 826  :                 *sref = NULL;

	mov	DWORD PTR [edi], 0
	jmp	SHORT $LN9@kdu_params
$LN25@kdu_params:

; 827  :               else if (*sref != NULL)

	test	ecx, ecx
	je	SHORT $LN9@kdu_params

; 828  :                 delete *sref;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+4]
$LN9@kdu_params:

; 821  :         {
; 822  :           for (sref=refs+ref_idx, n=num_comps; n > 0; n--)

	dec	ebx
	test	ebx, ebx
	jg	SHORT $LL11@kdu_params
	mov	edx, DWORD PTR _ref_idx$1$[ebp]
$LN10@kdu_params:

; 829  :             }
; 830  :         }
; 831  :     }
; 832  :   else
; 833  :     assert((comp_idx < 0) && (tile_idx >= 0));
; 834  : 
; 835  :   // Process tiles
; 836  :   if (tile_idx < 0)

	cmp	DWORD PTR [esi+8], 0
	jge	SHORT $LN81@kdu_params

; 837  :     {
; 838  :       for (sref=refs+ref_idx, n=num_tiles; n > 0; n--)

	mov	eax, DWORD PTR [esi+44]
	mov	ebx, DWORD PTR [esi+20]
	lea	edi, DWORD PTR [eax+edx*4]
	test	ebx, ebx
	jle	SHORT $LN13@kdu_params
	npad	1
$LL14@kdu_params:

; 839  :         {
; 840  :           sref += num_comps+1;

	mov	eax, DWORD PTR [esi+24]
	lea	edi, DWORD PTR [edi+eax*4]

; 841  :           if (*sref == this)

	mov	eax, DWORD PTR [edi+4]
	lea	edi, DWORD PTR [edi+4]
	cmp	eax, esi
	jne	SHORT $LN29@kdu_params

; 842  :             *sref = NULL;

	mov	DWORD PTR [edi], 0
	jmp	SHORT $LN12@kdu_params
$LN29@kdu_params:

; 843  :           else if (*sref != NULL)

	test	eax, eax
	je	SHORT $LN12@kdu_params

; 844  :             {
; 845  :               if (comp_idx < 0)

	cmp	DWORD PTR [esi+12], 0
	jge	SHORT $LN32@kdu_params

; 846  :                 (*sref)->refs = NULL; // So don't delete columns over again

	mov	DWORD PTR [eax+44], 0
$LN32@kdu_params:

; 847  :               delete *sref;

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN12@kdu_params
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+4]
$LN12@kdu_params:

; 837  :     {
; 838  :       for (sref=refs+ref_idx, n=num_tiles; n > 0; n--)

	dec	ebx
	test	ebx, ebx
	jg	SHORT $LL14@kdu_params
$LN13@kdu_params:

; 848  :             }
; 849  :         }
; 850  :     }
; 851  : 
; 852  :   // Delete references array, if appropriate
; 853  :   if ((tile_idx >= 0) || (comp_idx >= 0))

	cmp	DWORD PTR [esi+8], 0
$LN81@kdu_params:
	pop	ebx
	jge	SHORT $LN34@kdu_params
	cmp	DWORD PTR [esi+12], 0
	jge	SHORT $LN34@kdu_params

; 854  :     return;
; 855  : 
; 856  :   if (refs != &dummy_ref)

	mov	ecx, DWORD PTR [esi+44]
	lea	eax, DWORD PTR [esi+48]
	cmp	ecx, eax
	je	SHORT $LN35@kdu_params

; 857  :     delete[] refs;

	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN35@kdu_params:

; 858  : 
; 859  :   // Process cluster list
; 860  :   if (first_cluster == NULL)

	mov	ecx, DWORD PTR [esi+36]
	test	ecx, ecx
	je	SHORT $LN34@kdu_params

; 861  :     return; // Function being used to delete all elements of the cluster list.
; 862  :   if (this != first_cluster)

	cmp	esi, ecx
	je	SHORT $LN62@kdu_params

; 863  :     { // Relink cluster list.
; 864  :       for (csp=first_cluster; this!=csp->next_cluster; csp=csp->next_cluster);

	mov	eax, DWORD PTR [ecx+40]
	cmp	esi, eax
	je	SHORT $LN16@kdu_params
	npad	3
$LL17@kdu_params:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+40]
	cmp	esi, eax
	jne	SHORT $LL17@kdu_params
$LN16@kdu_params:

; 865  :       csp->next_cluster = this->next_cluster;

	mov	eax, DWORD PTR [esi+40]
	pop	edi
	mov	DWORD PTR [ecx+40], eax
	pop	esi

; 873  :     }
; 874  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@kdu_params:

; 866  :       return;
; 867  :     }
; 868  :   while ((csp=next_cluster) != NULL)

	mov	ecx, DWORD PTR [esi+40]
	test	ecx, ecx
	je	SHORT $LN34@kdu_params
	npad	4
$LL18@kdu_params:

; 869  :     { // Delete entire cluster list.
; 870  :       next_cluster = csp->next_cluster;

	mov	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR [esi+40], eax

; 871  :       csp->first_cluster = NULL; // Prevent further cluster list processing.

	mov	DWORD PTR [ecx+36], 0

; 872  :       delete csp;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [esi+40]
	test	ecx, ecx
	jne	SHORT $LL18@kdu_params
$LN34@kdu_params:
	pop	edi
	pop	esi

; 873  :     }
; 874  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1kdu_params@@UAE@XZ ENDP				; kdu_params::~kdu_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?add_dependency@kdu_params@@IAEXPBD@Z
_TEXT	SEGMENT
_cname$ = 8						; size = 4
?add_dependency@kdu_params@@IAEXPBD@Z PROC		; kdu_params::add_dependency, COMDAT
; _this$ = ecx

; 969  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 970  :   int i;
; 971  :   for (i=0; i < KD_MAX_PARAM_DEPENDENCIES; i++)

	mov	edi, DWORD PTR _cname$[ebp]
	lea	edx, DWORD PTR [ecx+68]
	xor	eax, eax
	npad	3
$LL4@add_depend:

; 972  :     if (dependencies[i] == cname)

	mov	esi, DWORD PTR [edx]
	cmp	esi, edi
	je	SHORT $LN3@add_depend

; 973  :       return; // Already exists
; 974  :     else if (dependencies[i] == NULL)

	test	esi, esi
	je	SHORT $LN11@add_depend

; 970  :   int i;
; 971  :   for (i=0; i < KD_MAX_PARAM_DEPENDENCIES; i++)

	inc	eax
	add	edx, 4
	cmp	eax, 4
	jl	SHORT $LL4@add_depend
	pop	edi
	pop	esi

; 976  : 
; 977  :   assert(0); // Array is too small to accommodate required dependencies
; 978  : }

	pop	ebp
	ret	4
$LN11@add_depend:

; 975  :       { dependencies[i] = cname; dependencies[i+1] = NULL; return; }

	mov	DWORD PTR [ecx+eax*4+68], edi
	mov	DWORD PTR [ecx+eax*4+72], 0
$LN3@add_depend:
	pop	edi
	pop	esi

; 976  : 
; 977  :   assert(0); // Array is too small to accommodate required dependencies
; 978  : }

	pop	ebp
	ret	4
?add_dependency@kdu_params@@IAEXPBD@Z ENDP		; kdu_params::add_dependency
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ??0kdu_params@@QAE@PBD_N1111@Z
_TEXT	SEGMENT
_cluster_name$ = 8					; size = 4
_allow_tiles$ = 12					; size = 1
_allow_comps$ = 16					; size = 1
_allow_insts$ = 20					; size = 1
_force_comps$ = 24					; size = 1
_treat_instances_like_components$ = 28			; size = 1
??0kdu_params@@QAE@PBD_N1111@Z PROC			; kdu_params::kdu_params, COMDAT
; _this$ = ecx

; 752  : {

	push	ebp
	mov	ebp, esp

; 753  :   assert(!(treat_instances_like_components && allow_comps));
; 754  : 
; 755  :   this->cluster_name = cluster_name;

	mov	eax, DWORD PTR _cluster_name$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 756  :   this->tile_idx = -1;
; 757  :   this->comp_idx = -1;
; 758  :   this->inst_idx = 0;
; 759  :   this->num_comps = 0;
; 760  :   this->num_tiles = 0;
; 761  :   this->allow_tiles = allow_tiles;

	mov	al, BYTE PTR _allow_tiles$[ebp]
	mov	BYTE PTR [ecx+30], al

; 762  :   this->allow_comps = allow_comps;

	mov	al, BYTE PTR _allow_comps$[ebp]
	mov	BYTE PTR [ecx+31], al

; 763  :   this->allow_insts = allow_insts;

	mov	al, BYTE PTR _allow_insts$[ebp]
	mov	BYTE PTR [ecx+32], al

; 764  :   this->force_comps = force_comps;

	mov	al, BYTE PTR _force_comps$[ebp]
	mov	BYTE PTR [ecx+33], al

; 765  :   this->treat_instances_like_components = treat_instances_like_components;

	mov	al, BYTE PTR _treat_instances_like_components$[ebp]
	mov	BYTE PTR [ecx+34], al

; 766  : 
; 767  :   first_cluster = this; next_cluster = NULL;
; 768  :   refs = &dummy_ref; dummy_ref = this;

	lea	eax, DWORD PTR [ecx+48]
	mov	DWORD PTR [ecx+44], eax
	mov	DWORD PTR [eax], ecx

; 769  :   first_inst = this; next_inst = NULL;
; 770  : 
; 771  :   attributes = NULL;
; 772  :   empty = true;
; 773  :   changed = false;
; 774  :   marked = false;
; 775  : 
; 776  :   dependencies[0] = NULL;
; 777  : }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kdu_params@@6B@
	mov	DWORD PTR [ecx+8], -1
	mov	DWORD PTR [ecx+12], -1
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+36], ecx
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+52], ecx
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 0
	mov	WORD PTR [ecx+28], 1
	mov	BYTE PTR [ecx+64], 0
	mov	DWORD PTR [ecx+68], 0
	pop	ebp
	ret	24					; 00000018H
??0kdu_params@@QAE@PBD_N1111@Z ENDP			; kdu_params::kdu_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?put@kdu_output@@QAEHM@Z
_TEXT	SEGMENT
_both$ = 8						; size = 4
_val$ = 8						; size = 4
?put@kdu_output@@QAEHM@Z PROC				; kdu_output::put, COMDAT
; _this$ = ecx

; 165  :       {

	push	ebp
	mov	ebp, esp

; 166  :         union {
; 167  :           kdu_uint32 ival;
; 168  :           float fval;
; 169  :           } both;
; 170  :         both.fval = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR _both$[ebp], xmm0

; 171  :         put(both.ival);

	push	DWORD PTR _both$[ebp]
	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put

; 172  :         return 4;

	mov	eax, 4

; 173  :       }

	pop	ebp
	ret	4
?put@kdu_output@@QAEHM@Z ENDP				; kdu_output::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?put@kdu_output@@QAEHI@Z
_TEXT	SEGMENT
_word$ = 8						; size = 4
?put@kdu_output@@QAEHI@Z PROC				; kdu_output::put, COMDAT
; _this$ = ecx

; 155  :       {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN4@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
$LN4@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 156  :       /* [SYNOPSIS] Writes a 4-byte word in big-endian order.
; 157  :          [RETURNS] Always returns 4. */
; 158  :         put((kdu_byte)(word>>24));

	mov	ebx, DWORD PTR _word$[ebp]
	mov	ecx, ebx
	shr	ecx, 24					; 00000018H

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN7@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN7@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 159  :         put((kdu_byte)(word>>16));

	mov	ecx, ebx
	shr	ecx, 16					; 00000010H

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN10@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN10@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 160  :         put((kdu_byte)(word>>8));

	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN13@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN13@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl

; 161  :         put((kdu_byte)(word>>0));
; 162  :         return 4;

	mov	eax, 4

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
	pop	esi
	pop	ebx

; 163  :       }

	pop	ebp
	ret	4
?put@kdu_output@@QAEHI@Z ENDP				; kdu_output::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?put@kdu_output@@QAEHG@Z
_TEXT	SEGMENT
_word$ = 8						; size = 2
?put@kdu_output@@QAEHG@Z PROC				; kdu_output::put, COMDAT
; _this$ = ecx

; 147  :       {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN4@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
$LN4@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ebx, DWORD PTR _word$[ebp]
	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN7@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN7@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl

; 151  :         put((kdu_byte)(word>>0));
; 152  :         return 2;

	mov	eax, 2

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
	pop	esi
	pop	ebx

; 153  :       }

	pop	ebp
	ret	4
?put@kdu_output@@QAEHG@Z ENDP				; kdu_output::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?put@kdu_output@@QAEHE@Z
_TEXT	SEGMENT
_byte$ = 8						; size = 1
?put@kdu_output@@QAEHE@Z PROC				; kdu_output::put, COMDAT
; _this$ = ecx

; 138  :       {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 139  :       /* [SYNOPSIS] Writes a single byte.
; 140  :          [RETURNS] Always returns 1. */
; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN2@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
$LN2@put:

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
	mov	al, BYTE PTR _byte$[ebp]
	mov	BYTE PTR [ecx], al

; 144  :         return 1;

	mov	eax, 1
	inc	DWORD PTR [esi+516]
	pop	esi

; 145  :       }

	pop	ebp
	ret	4
?put@kdu_output@@QAEHE@Z ENDP				; kdu_output::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
;	COMDAT ?ceil_ratio@@YAHHH@Z
_TEXT	SEGMENT
_num$ = 8						; size = 4
_den$ = 12						; size = 4
?ceil_ratio@@YAHHH@Z PROC				; ceil_ratio, COMDAT

; 171  : { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 172  :        Returns the ceiling function of the ratio `num' / `den', where
; 173  :        the denominator is required to be strictly positive.
; 174  :      [RETURNS] Non-negative ratio.
; 175  :      [ARG: num] Non-negative numerator.
; 176  :      [ARG: den] Non-negative denomenator.
; 177  :   */
; 178  :   assert(den > 0);
; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _num$[ebp]
	test	eax, eax
	jg	SHORT $LN2@ceil_ratio

; 180  :     return -((-num)/den);

	cdq
	idiv	DWORD PTR _den$[ebp]

; 183  : }

	pop	ebp
	ret	0
$LN2@ceil_ratio:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	DWORD PTR _den$[ebp]
	inc	eax

; 183  : }

	pop	ebp
	ret	0
?ceil_ratio@@YAHHH@Z ENDP				; ceil_ratio
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
;	COMDAT ?kdu_read_double@@YANAAPAEPAE@Z
_TEXT	SEGMENT
_val$ = -8						; size = 8
_machine_uses_big_endian$ = 8				; size = 4
$T1 = 8							; size = 4
_bp$ = 8						; size = 4
_end$ = 12						; size = 4
?kdu_read_double@@YANAAPAEPAE@Z PROC			; kdu_read_double, COMDAT

; 146  : { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 147  :        Same as `kdu_read_float', but reads an 8-byte double-precision
; 148  :        quantity from the `bp' array.
; 149  :   */
; 150  :   if ((end-bp) < 8)

	mov	edx, DWORD PTR _bp$[ebp]
	sub	esp, 8
	mov	eax, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	eax, ecx
	cmp	eax, 8
	jl	$LN38@kdu_read_d

; 152  :   double val;
; 153  :   kdu_byte *val_p = (kdu_byte *) &val;
; 154  :   int n, machine_uses_big_endian = 1;
; 155  :   ((kdu_byte *) &machine_uses_big_endian)[0] = 0;
; 156  :   if (machine_uses_big_endian)
; 157  :     for (n=0; n < 8; n++)
; 158  :       val_p[n] = *(bp++);

	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR _machine_uses_big_endian$[ebp], 1
	mov	BYTE PTR _machine_uses_big_endian$[ebp], 0
	cmp	DWORD PTR _machine_uses_big_endian$[ebp], 0
	mov	DWORD PTR [edx], ecx
	je	SHORT $LN9@kdu_read_d
	mov	BYTE PTR _val$[ebp], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx], ecx
	mov	BYTE PTR _val$[ebp+1], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx], ecx
	mov	BYTE PTR _val$[ebp+2], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx], ecx
	mov	BYTE PTR _val$[ebp+3], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx], ecx
	mov	BYTE PTR _val$[ebp+4], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx], ecx
	mov	BYTE PTR _val$[ebp+5], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR _val$[ebp+6], al
	mov	DWORD PTR [edx], ecx
	movzx	eax, BYTE PTR [ecx]
	mov	BYTE PTR _val$[ebp+7], al

; 159  :   else
; 160  :     for (n=7; n >= 0; n--)
; 161  :       val_p[n] = *(bp++);

	lea	eax, DWORD PTR [ecx+1]

; 162  :   return val;

	fld	QWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 163  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@kdu_read_d:

; 159  :   else
; 160  :     for (n=7; n >= 0; n--)
; 161  :       val_p[n] = *(bp++);

	mov	BYTE PTR _val$[ebp+7], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx], ecx
	mov	BYTE PTR _val$[ebp+6], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx], ecx
	mov	BYTE PTR _val$[ebp+5], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx], ecx
	mov	BYTE PTR _val$[ebp+4], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx], ecx
	mov	BYTE PTR _val$[ebp+3], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx], ecx
	mov	BYTE PTR _val$[ebp+2], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR _val$[ebp+1], al
	mov	DWORD PTR [edx], ecx
	movzx	eax, BYTE PTR [ecx]
	mov	BYTE PTR _val$[ebp], al
	lea	eax, DWORD PTR [ecx+1]

; 162  :   return val;

	fld	QWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 163  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@kdu_read_d:

; 151  :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	push	eax
	call	__CxxThrowException@8
$LN40@kdu_read_d:
$LN36@kdu_read_d:
	int	3
?kdu_read_double@@YANAAPAEPAE@Z ENDP			; kdu_read_double
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
;	COMDAT ?kdu_read_float@@YAMAAPAEPAE@Z
_TEXT	SEGMENT
_machine_uses_big_endian$ = 8				; size = 4
_val$ = 8						; size = 4
$T1 = 8							; size = 4
_bp$ = 8						; size = 4
_end$ = 12						; size = 4
?kdu_read_float@@YAMAAPAEPAE@Z PROC			; kdu_read_float, COMDAT

; 108  : { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 109  :        Reads a 4-byte single-precision floating point quantity from the
; 110  :        array identified by `bp'.  During the process, `bp' is advanced
; 111  :        4 bytes.  If this pushes it up to or past the `end' pointer, the
; 112  :        function throws an exception of type `kdu_byte *'.
; 113  :        [//]
; 114  :        The byte order is assumed to be big-endian.  If the local machine
; 115  :        architecture is little-endian, the input bytes are reversed.
; 116  :      [RETURNS]
; 117  :        The value of the floating point quantity recovered from the first
; 118  :        4 bytes of the buffer.
; 119  :      [ARG: bp]
; 120  :        Pointer to the first byte in the buffer from which the integer is
; 121  :        to be recovered.
; 122  :      [ARG: end]
; 123  :        Points immediately beyond the last valid entry in the buffer.
; 124  :   */
; 125  :   if ((end-bp) < 4)

	mov	edx, DWORD PTR _bp$[ebp]
	mov	eax, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	eax, ecx
	cmp	eax, 4
	jl	SHORT $LN30@kdu_read_f

; 127  :   float val;
; 128  :   kdu_byte *val_p = (kdu_byte *) &val;
; 129  :   int n, machine_uses_big_endian = 1;
; 130  :   ((kdu_byte *) &machine_uses_big_endian)[0] = 0;
; 131  :   if (machine_uses_big_endian)
; 132  :     for (n=0; n < 4; n++)
; 133  :       val_p[n] = *(bp++);

	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR _machine_uses_big_endian$[ebp], 1
	mov	BYTE PTR _machine_uses_big_endian$[ebp], 0
	cmp	DWORD PTR _machine_uses_big_endian$[ebp], 0
	mov	DWORD PTR [edx], ecx
	je	SHORT $LN9@kdu_read_f
	mov	BYTE PTR _val$[ebp], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx], ecx
	mov	BYTE PTR _val$[ebp+1], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR _val$[ebp+2], al
	mov	DWORD PTR [edx], ecx
	movzx	eax, BYTE PTR [ecx]
	mov	BYTE PTR _val$[ebp+3], al

; 134  :   else
; 135  :     for (n=3; n >= 0; n--)
; 136  :       val_p[n] = *(bp++);

	lea	eax, DWORD PTR [ecx+1]

; 137  :   return val;

	fld	DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 138  : }

	pop	ebp
	ret	0
$LN9@kdu_read_f:

; 134  :   else
; 135  :     for (n=3; n >= 0; n--)
; 136  :       val_p[n] = *(bp++);

	mov	BYTE PTR _val$[ebp+3], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx], ecx
	mov	BYTE PTR _val$[ebp+2], al
	movzx	eax, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR _val$[ebp+1], al
	mov	DWORD PTR [edx], ecx
	movzx	eax, BYTE PTR [ecx]
	mov	BYTE PTR _val$[ebp], al
	lea	eax, DWORD PTR [ecx+1]

; 137  :   return val;

	fld	DWORD PTR _val$[ebp]
	mov	DWORD PTR [edx], eax

; 138  : }

	pop	ebp
	ret	0
$LN30@kdu_read_f:

; 126  :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	push	eax
	call	__CxxThrowException@8
$LN32@kdu_read_f:
$LN28@kdu_read_f:
	int	3
?kdu_read_float@@YAMAAPAEPAE@Z ENDP			; kdu_read_float
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
;	COMDAT ?kdu_read@@YAHAAPAEPAEH@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
_bp$ = 8						; size = 4
_end$ = 12						; size = 4
_nbytes$ = 16						; size = 4
?kdu_read@@YAHAAPAEPAEH@Z PROC				; kdu_read, COMDAT

; 66   : { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 67   :        Reads an integer quantity having an `nbytes' bigendian
; 68   :        representation from the array identified by `bp'.  During the process,
; 69   :        `bp' is advanced `nbytes' positions.  If this pushes it up to or past
; 70   :        the `end' pointer, the function throws an exception of type
; 71   :        `kdu_byte *'.
; 72   :        [//]
; 73   :        The byte order is assumed to be big-endian.  If the local machine
; 74   :        architecture is little-endian, the input bytes are reversed.
; 75   :      [RETURNS]
; 76   :        The value of the integer recovered from the first `nbytes' bytes of
; 77   :        the buffer.
; 78   :      [ARG: bp]
; 79   :        Pointer to the first byte in the buffer from which the integer is
; 80   :        to be recovered.
; 81   :      [ARG: end]
; 82   :        Points immediately beyond the last valid entry in the buffer.
; 83   :      [ARG: nbytes]
; 84   :        Number of bytes from the buffer which are to be converted into a
; 85   :        big-endian integer.  Must be one of 1, 2, 3 or 4.
; 86   :   */
; 87   :   int val;
; 88   : 
; 89   :   assert(nbytes <= 4);
; 90   :   if ((end-bp) < nbytes)

	mov	eax, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR _nbytes$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _bp$[ebp]
	mov	ecx, DWORD PTR [edi]
	sub	eax, ecx
	cmp	eax, edx
	jl	SHORT $LN8@kdu_read

; 92   :   val = *(bp++);

	movzx	esi, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edi], ecx

; 93   :   if (nbytes > 1)

	cmp	edx, 1
	jle	SHORT $LN3@kdu_read

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [ecx]
	shl	esi, 8
	add	esi, eax
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [edi], eax
$LN3@kdu_read:

; 95   :   if (nbytes > 2)

	cmp	edx, 2
	jle	SHORT $LN4@kdu_read

; 96   :     val = (val<<8) + *(bp++);

	mov	ecx, DWORD PTR [edi]
	shl	esi, 8
	movzx	eax, BYTE PTR [ecx]
	add	esi, eax
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [edi], eax
$LN4@kdu_read:

; 97   :   if (nbytes > 3)

	cmp	edx, 3
	jle	SHORT $LN5@kdu_read

; 98   :     val = (val<<8) + *(bp++);

	mov	edx, DWORD PTR [edi]
	shl	esi, 8
	movzx	ecx, BYTE PTR [edx]
	add	esi, ecx
	lea	ecx, DWORD PTR [edx+1]
	mov	DWORD PTR [edi], ecx
$LN5@kdu_read:

; 99   :   return val;

	pop	edi
	mov	eax, esi
	pop	esi

; 100  : }

	pop	ebp
	ret	0
$LN8@kdu_read:

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	push	eax
	call	__CxxThrowException@8
$LN10@kdu_read:
$LN7@kdu_read:
	int	3
?kdu_read@@YAHAAPAEPAEH@Z ENDP				; kdu_read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@M@Z
_TEXT	SEGMENT
_text$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_val$ = 8						; size = 4
??6kdu_message@@QAEAAV0@M@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 291  :       { char text[80]; sprintf(text,"%f",val); put_text(text); return *this; }

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	movss	xmm0, DWORD PTR _val$[ebp]
	lea	eax, DWORD PTR _text$[ebp]
	push	esi
	cvtps2pd xmm0, xmm0
	sub	esp, 8
	mov	esi, ecx
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
	push	eax
	call	_sprintf
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _text$[ebp]
	add	esp, 16					; 00000010H
	mov	ecx, esi
	push	eax
	call	DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@M@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@H@Z
_TEXT	SEGMENT
_text$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_val$ = 8						; size = 4
??6kdu_message@@QAEAAV0@H@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 261  :       { char text[80];

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	push	DWORD PTR _val$[ebp]
	mov	esi, ecx
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	BYTE PTR [esi+4], 0
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_sprintf

; 263  :         put_text(text); return *this; }

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _text$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, esi
	push	eax
	call	DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@H@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@D@Z
_TEXT	SEGMENT
_text$ = 8						; size = 2
_ch$ = 8						; size = 1
??6kdu_message@@QAEAAV0@D@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }

	push	ebp
	mov	ebp, esp
	mov	al, BYTE PTR _ch$[ebp]
	push	esi
	mov	esi, ecx
	mov	BYTE PTR _text$[ebp], al
	lea	ecx, DWORD PTR _text$[ebp]
	mov	BYTE PTR _text$[ebp+1], 0
	push	ecx
	mov	ecx, esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@D@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
??6kdu_message@@QAEAAV0@PBD@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 257  :       { put_text(string); return *this; }

	push	ebp
	mov	ebp, esp
	push	esi
	push	DWORD PTR _string$[ebp]
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@PBD@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?set_hex_mode@kdu_message@@QAE_N_N@Z
_TEXT	SEGMENT
_new_mode$ = 8						; size = 1
?set_hex_mode@kdu_message@@QAE_N_N@Z PROC		; kdu_message::set_hex_mode, COMDAT
; _this$ = ecx

; 247  :       { bool old_mode = mode_hex; mode_hex = new_mode; return old_mode; }

	push	ebp
	mov	ebp, esp
	mov	dl, BYTE PTR _new_mode$[ebp]
	mov	al, BYTE PTR [ecx+4]
	mov	BYTE PTR [ecx+4], dl
	pop	ebp
	ret	4
?set_hex_mode@kdu_message@@QAE_N_N@Z ENDP		; kdu_message::set_hex_mode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1391 : }

	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\visual studio\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ?strchr@@YAPADQADH@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADQADH@Z PROC				; strchr, COMDAT

; 518  :     {

	push	ebp
	mov	ebp, esp

; 520  :     }

	pop	ebp

; 519  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

	jmp	DWORD PTR __imp__strchr
?strchr@@YAPADQADH@Z ENDP				; strchr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\parameters\params.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
