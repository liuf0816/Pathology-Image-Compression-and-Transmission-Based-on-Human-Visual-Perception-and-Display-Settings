; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\transform\colour.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	?kdu_convert_rgb_to_ycc@@YAXAAVkdu_line_buf@@00@Z ; kdu_convert_rgb_to_ycc
PUBLIC	?kdu_convert_ycc_to_rgb@@YAXAAVkdu_line_buf@@00H@Z ; kdu_convert_ycc_to_rgb
PUBLIC	?simd_ict@@YA_NPAF00H@Z				; simd_ict
PUBLIC	?simd_inverse_ict@@YA_NPAF00H@Z			; simd_inverse_ict
PUBLIC	?simd_rct@@YA_NPAF00H@Z				; simd_rct
PUBLIC	?simd_inverse_rct@@YA_NPAF00H@Z			; simd_inverse_rct
PUBLIC	__real@3fbd2f1a9fbe76c9
PUBLIC	__real@3fd322d0e5604189
PUBLIC	__real@3fd6065433a66b18
PUBLIC	__real@3fe20f065b4e0378
PUBLIC	__real@3fe2c8b439581062
PUBLIC	__real@3fe6d314d0e3e152
PUBLIC	__real@3fe6da345743d963
PUBLIC	__real@3ff66e978d4fdf3c
PUBLIC	__real@3ffc5a1cac083127
EXTRN	?kdu_mmx_level@@3HA:DWORD			; kdu_mmx_level
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?_vec_store@@3PAFA DW 047H DUP (?)			; _vec_store
	ALIGN	4

?vec_aligned@@3PAFA DD 01H DUP (?)			; vec_aligned
?vec_alphaR@@3PAFA DD 01H DUP (?)			; vec_alphaR
?vec_alphaB@@3PAFA DD 01H DUP (?)			; vec_alphaB
?vec_CBfact@@3PAFA DD 01H DUP (?)			; vec_CBfact
?vec_CRfact@@3PAFA DD 01H DUP (?)			; vec_CRfact
?vec_CRfactR@@3PAFA DD 01H DUP (?)			; vec_CRfactR
?vec_CBfactB@@3PAFA DD 01H DUP (?)			; vec_CBfactB
?vec_CRfactG@@3PAFA DD 01H DUP (?)			; vec_CRfactG
?vec_CBfactG@@3PAFA DD 01H DUP (?)			; vec_CBfactG
_BSS	ENDS
CRT$XCU	SEGMENT
?vec_aligned$initializer$@@3P6AXXZA DD FLAT:??__Evec_aligned@@YAXXZ ; vec_aligned$initializer$
CRT$XCU	ENDS
;	COMDAT __real@3ffc5a1cac083127
CONST	SEGMENT
__real@3ffc5a1cac083127 DQ 03ffc5a1cac083127r	; 1.772
CONST	ENDS
;	COMDAT __real@3ff66e978d4fdf3c
CONST	SEGMENT
__real@3ff66e978d4fdf3c DQ 03ff66e978d4fdf3cr	; 1.402
CONST	ENDS
;	COMDAT __real@3fe6da345743d963
CONST	SEGMENT
__real@3fe6da345743d963 DQ 03fe6da345743d963r	; 0.714136
CONST	ENDS
;	COMDAT __real@3fe6d314d0e3e152
CONST	SEGMENT
__real@3fe6d314d0e3e152 DQ 03fe6d314d0e3e152r	; 0.713267
CONST	ENDS
;	COMDAT __real@3fe2c8b439581062
CONST	SEGMENT
__real@3fe2c8b439581062 DQ 03fe2c8b439581062r	; 0.587
CONST	ENDS
;	COMDAT __real@3fe20f065b4e0378
CONST	SEGMENT
__real@3fe20f065b4e0378 DQ 03fe20f065b4e0378r	; 0.564334
CONST	ENDS
;	COMDAT __real@3fd6065433a66b18
CONST	SEGMENT
__real@3fd6065433a66b18 DQ 03fd6065433a66b18r	; 0.344136
CONST	ENDS
;	COMDAT __real@3fd322d0e5604189
CONST	SEGMENT
__real@3fd322d0e5604189 DQ 03fd322d0e5604189r	; 0.299
CONST	ENDS
;	COMDAT __real@3fbd2f1a9fbe76c9
CONST	SEGMENT
__real@3fbd2f1a9fbe76c9 DQ 03fbd2f1a9fbe76c9r	; 0.114
CONST	ENDS
CRT$XCU	SEGMENT
?vec_alphaR$initializer$@@3P6AXXZA DD FLAT:??__Evec_alphaR@@YAXXZ ; vec_alphaR$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?vec_alphaB$initializer$@@3P6AXXZA DD FLAT:??__Evec_alphaB@@YAXXZ ; vec_alphaB$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?vec_CBfact$initializer$@@3P6AXXZA DD FLAT:??__Evec_CBfact@@YAXXZ ; vec_CBfact$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?vec_CRfact$initializer$@@3P6AXXZA DD FLAT:??__Evec_CRfact@@YAXXZ ; vec_CRfact$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?vec_CRfactR$initializer$@@3P6AXXZA DD FLAT:??__Evec_CRfactR@@YAXXZ ; vec_CRfactR$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?vec_CBfactB$initializer$@@3P6AXXZA DD FLAT:??__Evec_CBfactB@@YAXXZ ; vec_CBfactB$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?vec_CRfactG$initializer$@@3P6AXXZA DD FLAT:??__Evec_CRfactG@@YAXXZ ; vec_CRfactG$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?vec_CBfactG$initializer$@@3P6AXXZA DD FLAT:??__Evec_CBfactG@@YAXXZ ; vec_CBfactG$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ?simd_inverse_rct@@YA_NPAH00H@Z
_TEXT	SEGMENT
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_src3$ = 16						; size = 4
_samples$ = 20						; size = 4
?simd_inverse_rct@@YA_NPAH00H@Z PROC			; simd_inverse_rct, COMDAT

; 441  :   return false;

	xor	al, al

; 442  : }

	ret	0
?simd_inverse_rct@@YA_NPAH00H@Z ENDP			; simd_inverse_rct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ?simd_rct@@YA_NPAH00H@Z
_TEXT	SEGMENT
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_src3$ = 16						; size = 4
_samples$ = 20						; size = 4
?simd_rct@@YA_NPAH00H@Z PROC				; simd_rct, COMDAT

; 429  :   return false;

	xor	al, al

; 430  : }

	ret	0
?simd_rct@@YA_NPAH00H@Z ENDP				; simd_rct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ?simd_inverse_ict@@YA_NPAM00H@Z
_TEXT	SEGMENT
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_src3$ = 16						; size = 4
_samples$ = 20						; size = 4
?simd_inverse_ict@@YA_NPAM00H@Z PROC			; simd_inverse_ict, COMDAT

; 418  :   return false;

	xor	al, al

; 419  : }

	ret	0
?simd_inverse_ict@@YA_NPAM00H@Z ENDP			; simd_inverse_ict
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ?simd_ict@@YA_NPAM00H@Z
_TEXT	SEGMENT
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_src3$ = 16						; size = 4
_samples$ = 20						; size = 4
?simd_ict@@YA_NPAM00H@Z PROC				; simd_ict, COMDAT

; 407  :   return false;

	xor	al, al

; 408  : }

	ret	0
?simd_ict@@YA_NPAM00H@Z ENDP				; simd_ict
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ?simd_inverse_rct@@YA_NPAF00H@Z
_TEXT	SEGMENT
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_src3$ = 16						; size = 4
_samples$ = 20						; size = 4
?simd_inverse_rct@@YA_NPAF00H@Z PROC			; simd_inverse_rct, COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp

; 336  :   if (kdu_mmx_level < 1)

	mov	eax, DWORD PTR ?kdu_mmx_level@@3HA	; kdu_mmx_level
	cmp	eax, 1
	jge	SHORT $LN2@simd_inver

; 337  :     return false;

	xor	al, al

; 397  : }

	pop	ebp
	ret	0
$LN2@simd_inver:

; 338  :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN7@simd_inver

; 339  :     return true;
; 340  : 
; 341  : #ifndef KDU_NO_SSE
; 342  :   if (kdu_mmx_level >= 2)

	push	ebx
	push	edi
	cmp	eax, 2
	jl	SHORT $LN4@simd_inver

; 345  :           XOR EDI,EDI        // Initialize sample counter to 0

	xor	edi, edi

; 346  :           MOV EDX,samples      // Set upper bound for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 347  :           MOV EAX,src1

	mov	eax, DWORD PTR _src1$[ebp]

; 348  :           MOV EBX,src2

	mov	ebx, DWORD PTR _src2$[ebp]

; 349  :           MOV ECX,src3

	mov	ecx, DWORD PTR _src3$[ebp]
$loop_inverse_rct128$9:

; 350  : loop_inverse_rct128:
; 351  :           MOVDQA XMM1,[EBX+2*EDI] // Load chrominance (Db)

	movdqa	xmm1, XMMWORD PTR [ebx+edi*2]

; 352  :           MOVDQA XMM2,[ECX+2*EDI] // Load chrominance (Dr)

	movdqa	xmm2, XMMWORD PTR [ecx+edi*2]

; 353  :           MOVDQA XMM3,XMM1

	movdqa	xmm3, xmm1

; 354  :           PADDSW XMM3,XMM2

	paddsw	xmm3, xmm2

; 355  :           PSRAW XMM3,2            // Forms (Db+DR)>>2

	psraw	xmm3, 2

; 356  :           MOVDQA XMM0,[EAX+2*EDI] // Load luminance (Y).

	movdqa	xmm0, XMMWORD PTR [eax+edi*2]

; 357  :           PSUBSW XMM0,XMM3        // Convert Y to Green channel

	psubsw	xmm0, xmm3

; 358  :           MOVDQA [EBX+2*EDI],XMM0

	movdqa	XMMWORD PTR [ebx+edi*2], xmm0

; 359  :           PADDSW XMM2,XMM0        // Convert Dr to Red channel

	paddsw	xmm2, xmm0

; 360  :           MOVDQA [EAX+2*EDI],XMM2

	movdqa	XMMWORD PTR [eax+edi*2], xmm2

; 361  :           PADDSW XMM1,XMM0        // Convert Db to Blue channel

	paddsw	xmm1, xmm0

; 362  :           MOVDQA [ECX+2*EDI],XMM1

	movdqa	XMMWORD PTR [ecx+edi*2], xmm1

; 363  :           ADD EDI,8

	add	edi, 8

; 364  :           CMP EDI,EDX

	cmp	edi, edx

; 365  :           JL loop_inverse_rct128

	jl	SHORT $loop_inverse_rct128$9

; 343  :     { // 128-bit implementation using SSE/SSE2 instructions
; 344  :       __asm {

	pop	edi
	pop	ebx

; 394  :         }
; 395  :     }
; 396  :   return true;

	mov	al, 1

; 397  : }

	pop	ebp
	ret	0
$LN4@simd_inver:

; 372  :           XOR EDI,EDI        // Initialize sample counter to 0

	xor	edi, edi

; 373  :           MOV EDX,samples      // Set upper bound for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 374  :           MOV EAX,src1

	mov	eax, DWORD PTR _src1$[ebp]

; 375  :           MOV EBX,src2

	mov	ebx, DWORD PTR _src2$[ebp]

; 376  :           MOV ECX,src3

	mov	ecx, DWORD PTR _src3$[ebp]
$loop_inverse_rct64$10:

; 377  : loop_inverse_rct64:
; 378  :           MOVQ MM1,[EBX+2*EDI] // Load chrominance (Db)

	movq	mm1, MMWORD PTR [ebx+edi*2]

; 379  :           MOVQ MM2,[ECX+2*EDI] // Load chrominance (Dr)

	movq	mm2, MMWORD PTR [ecx+edi*2]

; 380  :           MOVQ MM3,MM1

	movq	mm3, mm1

; 381  :           PADDSW MM3,MM2

	paddsw	mm3, mm2

; 382  :           PSRAW MM3,2          // Forms (Db+DR)>>2

	psraw	mm3, 2

; 383  :           MOVQ MM0,[EAX+2*EDI] // Load luminance (Y).

	movq	mm0, MMWORD PTR [eax+edi*2]

; 384  :           PSUBSW MM0,MM3       // Convert Y to Green channel

	psubsw	mm0, mm3

; 385  :           MOVQ [EBX+2*EDI],MM0

	movq	MMWORD PTR [ebx+edi*2], mm0

; 386  :           PADDSW MM2,MM0       // Convert Dr to Red channel

	paddsw	mm2, mm0

; 387  :           MOVQ [EAX+2*EDI],MM2

	movq	MMWORD PTR [eax+edi*2], mm2

; 388  :           PADDSW MM1,MM0       // Convert Db to Blue channel

	paddsw	mm1, mm0

; 389  :           MOVQ [ECX+2*EDI],MM1

	movq	MMWORD PTR [ecx+edi*2], mm1

; 390  :           ADD EDI,4

	add	edi, 4

; 391  :           CMP EDI,EDX

	cmp	edi, edx

; 392  :           JL loop_inverse_rct64

	jl	SHORT $loop_inverse_rct64$10

; 393  :           EMMS // Clear MMX registers for use by FPU

	emms

; 366  :         }
; 367  :     }
; 368  :   else
; 369  : #endif // !KDU_NO_SSE
; 370  :     { // 64-bit implementation using only MMX instructions
; 371  :       __asm {

	pop	edi
	pop	ebx
$LN7@simd_inver:

; 394  :         }
; 395  :     }
; 396  :   return true;

	mov	al, 1

; 397  : }

	pop	ebp
	ret	0
?simd_inverse_rct@@YA_NPAF00H@Z ENDP			; simd_inverse_rct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ?simd_rct@@YA_NPAF00H@Z
_TEXT	SEGMENT
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_src3$ = 16						; size = 4
_samples$ = 20						; size = 4
?simd_rct@@YA_NPAF00H@Z PROC				; simd_rct, COMDAT

; 293  : {

	push	ebp
	mov	ebp, esp

; 294  :   if (kdu_mmx_level < 1)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 1	; kdu_mmx_level
	jge	SHORT $LN2@simd_rct

; 295  :     return false;

	xor	al, al

; 326  : }

	pop	ebp
	ret	0
$LN2@simd_rct:

; 296  :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	SHORT $LN5@simd_rct

; 297  :     return true;
; 298  : 
; 299  :   __asm

	push	ebx
	push	edi

; 300  :     {
; 301  :       XOR EDI,EDI          // Initialize sample counter to 0

	xor	edi, edi

; 302  :       MOV EDX,samples      // Upper bound for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 303  :       MOV EAX,src1

	mov	eax, DWORD PTR _src1$[ebp]

; 304  :       MOV EBX,src2

	mov	ebx, DWORD PTR _src2$[ebp]

; 305  :       MOV ECX,src3

	mov	ecx, DWORD PTR _src3$[ebp]
$loop_rct$7:

; 306  : loop_rct:
; 307  :       MOVQ MM1,[EAX+2*EDI] // Load red (R)

	movq	mm1, MMWORD PTR [eax+edi*2]

; 308  :       MOVQ MM2,[EBX+2*EDI] // Load green (G)

	movq	mm2, MMWORD PTR [ebx+edi*2]

; 309  :       MOVQ MM3,[ECX+2*EDI] // Load blue (B)

	movq	mm3, MMWORD PTR [ecx+edi*2]

; 310  :       MOVQ MM0,MM1         // Get R to MM0

	movq	mm0, mm1

; 311  :       PADDSW MM0,MM3       // Add B to MM0

	paddsw	mm0, mm3

; 312  :       PADDSW MM0,MM2

	paddsw	mm0, mm2

; 313  :       PADDSW MM0,MM2       // Add 2*G to MM0

	paddsw	mm0, mm2

; 314  :       PSRAW MM0,2          // Forms (R+2*G+B)>>2

	psraw	mm0, 2

; 315  :       MOVQ [EAX+2*EDI],MM0 // Write out Y channel

	movq	MMWORD PTR [eax+edi*2], mm0

; 316  :       PSUBSW MM3,MM2       // Subtract G from B

	psubsw	mm3, mm2

; 317  :       MOVQ [EBX+2*EDI],MM3 // Write out Db channel

	movq	MMWORD PTR [ebx+edi*2], mm3

; 318  :       PSUBSW MM1,MM2       // Subtract G from R

	psubsw	mm1, mm2

; 319  :       MOVQ [ECX+2*EDI],MM1 // Write out Dr channel

	movq	MMWORD PTR [ecx+edi*2], mm1

; 320  :       ADD EDI,4

	add	edi, 4

; 321  :       CMP EDI,EDX

	cmp	edi, edx

; 322  :       JL loop_rct

	jl	SHORT $loop_rct$7

; 323  :       EMMS // Clear MMX registers for use by FPU

	emms

; 297  :     return true;
; 298  : 
; 299  :   __asm

	pop	edi
	pop	ebx
$LN5@simd_rct:

; 324  :     }
; 325  :   return true;

	mov	al, 1

; 326  : }

	pop	ebp
	ret	0
?simd_rct@@YA_NPAF00H@Z ENDP				; simd_rct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ?simd_inverse_ict@@YA_NPAF00H@Z
_TEXT	SEGMENT
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_src3$ = 16						; size = 4
_samples$ = 20						; size = 4
?simd_inverse_ict@@YA_NPAF00H@Z PROC			; simd_inverse_ict, COMDAT

; 177  : {

	push	ebp
	mov	ebp, esp

; 178  :   if (kdu_mmx_level < 1)

	mov	eax, DWORD PTR ?kdu_mmx_level@@3HA	; kdu_mmx_level
	cmp	eax, 1
	jge	SHORT $LN2@simd_inver

; 179  :     return false;

	xor	al, al

; 285  : }

	pop	ebp
	ret	0
$LN2@simd_inver:

; 180  :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN7@simd_inver

; 181  :     return true;
; 182  : 
; 183  :   assert(vec_CBfactG==(vec_CRfactG+8)); // Assumed for the code below to work
; 184  : 
; 185  : #ifndef KDU_NO_SSE
; 186  :   if (kdu_mmx_level >= 2)

	push	ebx
	push	esi
	push	edi
	cmp	eax, 2
	jl	$LN4@simd_inver

; 189  :           XOR EDI,EDI          // Zero sample counter

	xor	edi, edi

; 190  :           MOV EDX,samples      // Sample counter limit

	mov	edx, DWORD PTR _samples$[ebp]

; 191  :           MOV EAX,src1

	mov	eax, DWORD PTR _src1$[ebp]

; 192  :           MOV EBX,src2

	mov	ebx, DWORD PTR _src2$[ebp]

; 193  :           MOV ECX,src3

	mov	ecx, DWORD PTR _src3$[ebp]

; 194  :           PCMPEQW XMM4,XMM4      // Fill XMM4 with 1's

	pcmpeqw	xmm4, xmm4

; 195  :           PSRLW XMM4,15          // Set each word in XMM4 equal to 1

	psrlw	xmm4, 15				; 0000000fH

; 196  :           MOVQ XMM5,XMM4

	movq	xmm5, xmm4

; 197  :           PADDW XMM5,XMM5        // Set each word in XMM5 equal to 2

	paddw	xmm5, xmm5

; 198  :           MOV ESI,vec_CRfactR

	mov	esi, DWORD PTR ?vec_CRfactR@@3PAFA

; 199  :           MOVDQA XMM6,[ESI]

	movdqa	xmm6, XMMWORD PTR [esi]

; 200  :           MOV ESI,vec_CBfactB

	mov	esi, DWORD PTR ?vec_CBfactB@@3PAFA

; 201  :           MOVDQA XMM7,[ESI]

	movdqa	xmm7, XMMWORD PTR [esi]

; 202  :           MOV ESI,vec_CRfactG

	mov	esi, DWORD PTR ?vec_CRfactG@@3PAFA
$loop_inverse_ict128$9:

; 203  : loop_inverse_ict128:
; 204  :           MOVDQA XMM0,[EAX+2*EDI]  // Load luminance (Y)

	movdqa	xmm0, XMMWORD PTR [eax+edi*2]

; 205  :           MOVDQA XMM1,[ECX+2*EDI]  // Load chrominance (Cr)

	movdqa	xmm1, XMMWORD PTR [ecx+edi*2]

; 206  :           MOVDQA XMM2,XMM1         // Prepare to form Red output in XMM2

	movdqa	xmm2, xmm1

; 207  :           PADDSW XMM2,XMM4         // +1 here approximates add 2^15 then divide by 2^16

	paddsw	xmm2, xmm4

; 208  :           PMULHW XMM2,XMM6         // Multiply by 0.402*2^16 (CRfactR) & divide by 2^16

	pmulhw	xmm2, xmm6

; 209  :           PADDSW XMM2,XMM1         // Add Cr again to make factor equivalent to 1.402

	paddsw	xmm2, xmm1

; 210  :           PADDSW XMM2,XMM0         // Add in luminance to get Red

	paddsw	xmm2, xmm0

; 211  :           MOVDQA [EAX+2*EDI],XMM2  // Save Red channel

	movdqa	XMMWORD PTR [eax+edi*2], xmm2

; 212  :           MOVDQA XMM2,XMM1         // Prepare to form Cr*(-0.714136) in XMM2

	movdqa	xmm2, xmm1

; 213  :           PADDSW XMM2,XMM5         // +2 here approximates add 2^15 then divide by 2^16

	paddsw	xmm2, xmm5

; 214  :           PMULHW XMM2,[ESI]        // Multiply by 0.285864*2^16 (CRfactG) & divide by 2^16

	pmulhw	xmm2, XMMWORD PTR [esi]

; 215  :           PSUBSW XMM2,XMM1         // Subtract Cr leaves us with the desired result

	psubsw	xmm2, xmm1

; 216  :           PADDSW XMM2,XMM0         // Add Y to scaled Cr forms most of Green in MM2

	paddsw	xmm2, xmm0

; 217  :           MOVDQA XMM1,[EBX+2*EDI]  // Load chrominance (Cb)

	movdqa	xmm1, XMMWORD PTR [ebx+edi*2]

; 218  :           MOVDQA XMM3,XMM1         // Prepare to form Blue output in XMM3

	movdqa	xmm3, xmm1

; 219  :           PSUBSW XMM3,XMM5         // +2 here approximates add 2^15 then divide by 2^16

	psubsw	xmm3, xmm5

; 220  :           PMULHW XMM3,XMM7         // Multiply by -0.228*2^16 (CBfactB) & divide by 2^16

	pmulhw	xmm3, xmm7

; 221  :           PADDSW XMM3,XMM1         // Gets 0.772*Cb to XMM3

	paddsw	xmm3, xmm1

; 222  :           PADDSW XMM3,XMM1         // Gets 1.772*Cb to XMM3

	paddsw	xmm3, xmm1

; 223  :           PADDSW XMM3,XMM0         // Add in luminance to get Blue

	paddsw	xmm3, xmm0

; 224  :           MOVDQA [ECX+2*EDI],XMM3  // Save Blue channel

	movdqa	XMMWORD PTR [ecx+edi*2], xmm3

; 225  :           PSUBSW XMM1,XMM5         // +2 here approximates add 2^15 then divide by 2^16

	psubsw	xmm1, xmm5

; 226  :           PMULHW XMM1,[ESI+16]     // Multiply by -0.344136*2^16 (CBfactG) and divide by 2^16

	pmulhw	xmm1, XMMWORD PTR [esi+16]

; 227  :           PADDSW XMM2,XMM1         // Completes the Green channel in XMM2

	paddsw	xmm2, xmm1

; 228  :           MOVDQA [EBX+2*EDI],XMM2

	movdqa	XMMWORD PTR [ebx+edi*2], xmm2

; 229  :           ADD EDI,8

	add	edi, 8

; 230  :           CMP EDI,EDX

	cmp	edi, edx

; 231  :           JL loop_inverse_ict128

	jl	SHORT $loop_inverse_ict128$9

; 187  :     { // 128-bit implementation, using SSE/SSE2 instructions
; 188  :       __asm {

	pop	edi
	pop	esi
	pop	ebx

; 282  :         }
; 283  :     }
; 284  :   return true;

	mov	al, 1

; 285  : }

	pop	ebp
	ret	0
$LN4@simd_inver:

; 238  :           XOR EDI,EDI          // Zero sample counter

	xor	edi, edi

; 239  :           MOV EDX,samples      // Sample counter limit

	mov	edx, DWORD PTR _samples$[ebp]

; 240  :           MOV EAX,src1

	mov	eax, DWORD PTR _src1$[ebp]

; 241  :           MOV EBX,src2

	mov	ebx, DWORD PTR _src2$[ebp]

; 242  :           MOV ECX,src3

	mov	ecx, DWORD PTR _src3$[ebp]

; 243  :           PCMPEQW MM4,MM4      // Fill MM4 with 1's

	pcmpeqw	mm4, mm4

; 244  :           PSRLW MM4,15         // Set each word in MM4 equal to 1

	psrlw	mm4, 15					; 0000000fH

; 245  :           MOVQ MM5,MM4

	movq	mm5, mm4

; 246  :           PADDW MM5,MM5        // Set each word in MM5 equal to 2

	paddw	mm5, mm5

; 247  :           MOV ESI,vec_CRfactR

	mov	esi, DWORD PTR ?vec_CRfactR@@3PAFA

; 248  :           MOVQ MM6,[ESI]

	movq	mm6, MMWORD PTR [esi]

; 249  :           MOV ESI,vec_CBfactB

	mov	esi, DWORD PTR ?vec_CBfactB@@3PAFA

; 250  :           MOVQ MM7,[ESI]

	movq	mm7, MMWORD PTR [esi]

; 251  :           MOV ESI,vec_CRfactG

	mov	esi, DWORD PTR ?vec_CRfactG@@3PAFA
$loop_inverse_ict64$10:

; 252  : loop_inverse_ict64:
; 253  :           MOVQ MM0,[EAX+2*EDI] // Load luminance (Y)

	movq	mm0, MMWORD PTR [eax+edi*2]

; 254  :           MOVQ MM1,[ECX+2*EDI] // Load chrominance (Cr)

	movq	mm1, MMWORD PTR [ecx+edi*2]

; 255  :           MOVQ MM2,MM1         // Prepare to form Red output in MM2

	movq	mm2, mm1

; 256  :           PADDSW MM2,MM4       // +1 here approximates add 2^15 then divide by 2^16

	paddsw	mm2, mm4

; 257  :           PMULHW MM2,MM6       // Multiply by 0.402*2^16 (CRfactR) & divide by 2^16

	pmulhw	mm2, mm6

; 258  :           PADDSW MM2,MM1       // Add Cr again to make factor equivalent to 1.402

	paddsw	mm2, mm1

; 259  :           PADDSW MM2,MM0       // Add in luminance to get Red

	paddsw	mm2, mm0

; 260  :           MOVQ [EAX+2*EDI],MM2 // Save Red channel

	movq	MMWORD PTR [eax+edi*2], mm2

; 261  :           MOVQ MM2,MM1         // Prepare to form Cr*(-0.714136) in MM2

	movq	mm2, mm1

; 262  :           PADDSW MM2,MM5       // +2 here approximates add 2^15 then divide by 2^16

	paddsw	mm2, mm5

; 263  :           PMULHW MM2,[ESI]     // Multiply by 0.285864*2^16 (CRfactG) & divide by 2^16

	pmulhw	mm2, MMWORD PTR [esi]

; 264  :           PSUBSW MM2,MM1       // Subtract Cr leaves us with the desired result

	psubsw	mm2, mm1

; 265  :           PADDSW MM2,MM0       // Add Y to scaled Cr forms most of Green in MM2

	paddsw	mm2, mm0

; 266  :           MOVQ MM1,[EBX+2*EDI] // Load chrominance (Cb)

	movq	mm1, MMWORD PTR [ebx+edi*2]

; 267  :           MOVQ MM3,MM1         // Prepare to form Blue output in MM3

	movq	mm3, mm1

; 268  :           PSUBSW MM3,MM5       // +2 here approximates add 2^15 then divide by 2^16

	psubsw	mm3, mm5

; 269  :           PMULHW MM3,MM7       // Multiply by -0.228*2^16 (CBfactB) & divide by 2^16

	pmulhw	mm3, mm7

; 270  :           PADDSW MM3,MM1       // Gets 0.772*Cb to MM3

	paddsw	mm3, mm1

; 271  :           PADDSW MM3,MM1       // Gets 1.772*Cb to MM3

	paddsw	mm3, mm1

; 272  :           PADDSW MM3,MM0       // Add in luminance to get Blue

	paddsw	mm3, mm0

; 273  :           MOVQ [ECX+2*EDI],MM3 // Save Blue channel

	movq	MMWORD PTR [ecx+edi*2], mm3

; 274  :           PSUBSW MM1,MM5       // +2 here approximates add 2^15 then divide by 2^16

	psubsw	mm1, mm5

; 275  :           PMULHW MM1,[ESI+16]  // Multiply by -0.344136*2^16 (CBfactG) and divide by 2^16

	pmulhw	mm1, MMWORD PTR [esi+16]

; 276  :           PADDSW MM2,MM1       // Completes the Green channel in MM2

	paddsw	mm2, mm1

; 277  :           MOVQ [EBX+2*EDI],MM2

	movq	MMWORD PTR [ebx+edi*2], mm2

; 278  :           ADD EDI,4

	add	edi, 4

; 279  :           CMP EDI,EDX

	cmp	edi, edx

; 280  :           JL loop_inverse_ict64

	jl	SHORT $loop_inverse_ict64$10

; 281  :           EMMS // Clear MMX registers for use by FPU

	emms

; 232  :         }
; 233  :     }
; 234  :   else
; 235  : #endif // !KDU_NO_SSE
; 236  :     { // 64-bit implementation, using only MMX instructions
; 237  :       __asm {

	pop	edi
	pop	esi
	pop	ebx
$LN7@simd_inver:

; 282  :         }
; 283  :     }
; 284  :   return true;

	mov	al, 1

; 285  : }

	pop	ebp
	ret	0
?simd_inverse_ict@@YA_NPAF00H@Z ENDP			; simd_inverse_ict
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ?simd_ict@@YA_NPAF00H@Z
_TEXT	SEGMENT
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_src3$ = 16						; size = 4
_samples$ = 20						; size = 4
?simd_ict@@YA_NPAF00H@Z PROC				; simd_ict, COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp

; 108  :   if (kdu_mmx_level < 1)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 1	; kdu_mmx_level
	jge	SHORT $LN2@simd_ict

; 109  :     return false;

	xor	al, al

; 168  : }

	pop	ebp
	ret	0
$LN2@simd_ict:

; 110  :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN5@simd_ict

; 111  :     return true;
; 112  : 
; 113  :   assert(vec_CRfact==(vec_CBfact+8)); // Assumed for the code below to work
; 114  :   __asm

	push	ebx
	push	esi
	push	edi

; 115  :     {
; 116  :       XOR EDI,EDI      // Zero sample counter

	xor	edi, edi

; 117  :       MOV EDX,samples  // Upper limit for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 118  :       MOV EAX,src1

	mov	eax, DWORD PTR _src1$[ebp]

; 119  :       MOV EBX,src2

	mov	ebx, DWORD PTR _src2$[ebp]

; 120  :       MOV ECX,src3

	mov	ecx, DWORD PTR _src3$[ebp]

; 121  :       MOV ESI,vec_alphaR;

	mov	esi, DWORD PTR ?vec_alphaR@@3PAFA

; 122  :       MOVQ MM5,[ESI]

	movq	mm5, MMWORD PTR [esi]

; 123  :       MOV ESI,vec_alphaB

	mov	esi, DWORD PTR ?vec_alphaB@@3PAFA

; 124  :       MOVQ MM6,[ESI]

	movq	mm6, MMWORD PTR [esi]

; 125  :       MOV ESI,vec_CBfact

	mov	esi, DWORD PTR ?vec_CBfact@@3PAFA

; 126  :       PCMPEQW MM7,MM7  // Fill MM7 with 1's

	pcmpeqw	mm7, mm7

; 127  :       PSRLW MM7,15     // Leaves each word in MM7 equal to 1

	psrlw	mm7, 15					; 0000000fH
$loop_ict$7:

; 128  : loop_ict:
; 129  :       MOVQ MM1,[EAX+2*EDI] // Load red; need to use this multiple times

	movq	mm1, MMWORD PTR [eax+edi*2]

; 130  :       MOVQ MM2,[ECX+2*EDI] // Load blue; need to use this multiple times

	movq	mm2, MMWORD PTR [ecx+edi*2]

; 131  :       MOVQ MM3,MM7         // Load a quad-word of 1's

	movq	mm3, mm7

; 132  :       PADDW MM3,MM3        // Double to get a quad-word of 2's

	paddw	mm3, mm3

; 133  :       MOVQ MM0,MM3         // Move the pre-offset of 2 into MM0

	movq	mm0, mm3

; 134  :       PADDSW MM0,MM1       // Form the pre-offset red channel in MM0

	paddsw	mm0, mm1

; 135  :       PMULHW MM0,MM5       // Form red contribution to Y in MM0

	pmulhw	mm0, mm5

; 136  :       PADDW MM3,MM3        // 4 is good pre-offset for multiplication by alphaB

	paddw	mm3, mm3

; 137  :       PADDSW MM3,MM2       // Form the pre-offset blue channel in MM3

	paddsw	mm3, mm2

; 138  :       PMULHW MM3,MM6       // Form blue contribution to Y in MM0

	pmulhw	mm3, mm6

; 139  :       PADDSW MM0,MM3       // Add blue contribution to red contribution

	paddsw	mm0, mm3

; 140  :       MOVQ MM3,MM5

	movq	mm3, mm5

; 141  :       PADDW MM3,MM6        // Gets alphaR+alphaB to MM3

	paddw	mm3, mm6

; 142  :       MOVQ MM4,[EBX+2*EDI] // Load green channel to MM4; we only need it once

	movq	mm4, MMWORD PTR [ebx+edi*2]

; 143  :       PADDSW MM4,MM7       // Pre-offset the green channel by 1

	paddsw	mm4, mm7

; 144  :       PMULHW MM3,MM4       // Creates green * (alphaR+alphaB) in MM3

	pmulhw	mm3, mm4

; 145  :       PSUBSW MM4,MM7       // Remove the pre-offset from the green channel

	psubsw	mm4, mm7

; 146  :       PSUBSW MM4,MM3       // Forms green * (1-alphaR-alphaB) in MM4

	psubsw	mm4, mm3

; 147  :       PADDSW MM0,MM4       // Forms luminance in MM0

	paddsw	mm0, mm4

; 148  :       MOVQ [EAX+2*EDI],MM0 // Write out luminance

	movq	MMWORD PTR [eax+edi*2], mm0

; 149  :       PSUBSW MM1,MM0       // Forms R-Y in MM1

	psubsw	mm1, mm0

; 150  :       PSUBSW MM2,MM0       // Forms B-Y in MM2

	psubsw	mm2, mm0

; 151  :       MOVQ MM0,MM1         // Copy R-Y to MM0

	movq	mm0, mm1

; 152  :       PADDSW MM1,MM7       // Add a pre-offset of 1

	paddsw	mm1, mm7

; 153  :       PADDSW MM1,MM7       // Make the pre-offset 2

	paddsw	mm1, mm7

; 154  :       PMULHW MM1,[ESI+16]  // Loads `q_CRfact'

	pmulhw	mm1, MMWORD PTR [esi+16]

; 155  :       PSUBSW MM0,MM1       // Forms (1-CRfact)*(R-Y) in MM0

	psubsw	mm0, mm1

; 156  :       MOVQ [ECX+2*EDI],MM0 // Write out the CR channel

	movq	MMWORD PTR [ecx+edi*2], mm0

; 157  :       MOVQ MM0,MM2         // Copy B-Y to MM0

	movq	mm0, mm2

; 158  :       PADDSW MM2,MM7       // Add a pre-offset of 1

	paddsw	mm2, mm7

; 159  :       PMULHW MM2,[ESI]     // Loads `q_CBfact'

	pmulhw	mm2, MMWORD PTR [esi]

; 160  :       PSUBSW MM0,MM2       // Forms (1-CBfact)*(B-Y) in MM0

	psubsw	mm0, mm2

; 161  :       MOVQ [EBX+2*EDI],MM0 // Write out the CB channel

	movq	MMWORD PTR [ebx+edi*2], mm0

; 162  :       ADD EDI,4

	add	edi, 4

; 163  :       CMP EDI,EDX

	cmp	edi, edx

; 164  :       JL loop_ict

	jl	SHORT $loop_ict$7

; 165  :       EMMS // Clear MMX registers for use by FPU

	emms

; 111  :     return true;
; 112  : 
; 113  :   assert(vec_CRfact==(vec_CBfact+8)); // Assumed for the code below to work
; 114  :   __asm

	pop	edi
	pop	esi
	pop	ebx
$LN5@simd_ict:

; 166  :     }
; 167  :   return true;

	mov	al, 1

; 168  : }

	pop	ebp
	ret	0
?simd_ict@@YA_NPAF00H@Z ENDP				; simd_ict
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ??__Evec_CBfactG@@YAXXZ
text$di	SEGMENT
??__Evec_CBfactG@@YAXXZ PROC				; `dynamic initializer for 'vec_CBfactG'', COMDAT

; 66   : static kdu_int16 *vec_CBfactG = vec_aligned+56;

	mov	eax, DWORD PTR ?vec_aligned@@3PAFA
	add	eax, 112				; 00000070H
	mov	DWORD PTR ?vec_CBfactG@@3PAFA, eax
	ret	0
??__Evec_CBfactG@@YAXXZ ENDP				; `dynamic initializer for 'vec_CBfactG''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ??__Evec_CRfactG@@YAXXZ
text$di	SEGMENT
??__Evec_CRfactG@@YAXXZ PROC				; `dynamic initializer for 'vec_CRfactG'', COMDAT

; 65   : static kdu_int16 *vec_CRfactG = vec_aligned+48;

	mov	eax, DWORD PTR ?vec_aligned@@3PAFA
	add	eax, 96					; 00000060H
	mov	DWORD PTR ?vec_CRfactG@@3PAFA, eax
	ret	0
??__Evec_CRfactG@@YAXXZ ENDP				; `dynamic initializer for 'vec_CRfactG''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ??__Evec_CBfactB@@YAXXZ
text$di	SEGMENT
??__Evec_CBfactB@@YAXXZ PROC				; `dynamic initializer for 'vec_CBfactB'', COMDAT

; 64   : static kdu_int16 *vec_CBfactB = vec_aligned+40;

	mov	eax, DWORD PTR ?vec_aligned@@3PAFA
	add	eax, 80					; 00000050H
	mov	DWORD PTR ?vec_CBfactB@@3PAFA, eax
	ret	0
??__Evec_CBfactB@@YAXXZ ENDP				; `dynamic initializer for 'vec_CBfactB''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ??__Evec_CRfactR@@YAXXZ
text$di	SEGMENT
??__Evec_CRfactR@@YAXXZ PROC				; `dynamic initializer for 'vec_CRfactR'', COMDAT

; 63   : static kdu_int16 *vec_CRfactR = vec_aligned+32;

	mov	eax, DWORD PTR ?vec_aligned@@3PAFA
	add	eax, 64					; 00000040H
	mov	DWORD PTR ?vec_CRfactR@@3PAFA, eax
	ret	0
??__Evec_CRfactR@@YAXXZ ENDP				; `dynamic initializer for 'vec_CRfactR''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ??__Evec_CRfact@@YAXXZ
text$di	SEGMENT
??__Evec_CRfact@@YAXXZ PROC				; `dynamic initializer for 'vec_CRfact'', COMDAT

; 62   : static kdu_int16 *vec_CRfact  = vec_aligned+24;

	mov	eax, DWORD PTR ?vec_aligned@@3PAFA
	add	eax, 48					; 00000030H
	mov	DWORD PTR ?vec_CRfact@@3PAFA, eax
	ret	0
??__Evec_CRfact@@YAXXZ ENDP				; `dynamic initializer for 'vec_CRfact''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ??__Evec_CBfact@@YAXXZ
text$di	SEGMENT
??__Evec_CBfact@@YAXXZ PROC				; `dynamic initializer for 'vec_CBfact'', COMDAT

; 61   : static kdu_int16 *vec_CBfact  = vec_aligned+16;

	mov	eax, DWORD PTR ?vec_aligned@@3PAFA
	add	eax, 32					; 00000020H
	mov	DWORD PTR ?vec_CBfact@@3PAFA, eax
	ret	0
??__Evec_CBfact@@YAXXZ ENDP				; `dynamic initializer for 'vec_CBfact''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ??__Evec_alphaB@@YAXXZ
text$di	SEGMENT
??__Evec_alphaB@@YAXXZ PROC				; `dynamic initializer for 'vec_alphaB'', COMDAT

; 60   : static kdu_int16 *vec_alphaB  = vec_aligned+8;

	mov	eax, DWORD PTR ?vec_aligned@@3PAFA
	add	eax, 16					; 00000010H
	mov	DWORD PTR ?vec_alphaB@@3PAFA, eax
	ret	0
??__Evec_alphaB@@YAXXZ ENDP				; `dynamic initializer for 'vec_alphaB''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ??__Evec_alphaR@@YAXXZ
text$di	SEGMENT
??__Evec_alphaR@@YAXXZ PROC				; `dynamic initializer for 'vec_alphaR'', COMDAT

; 59   : static kdu_int16 *vec_alphaR  = vec_aligned+0;

	mov	eax, DWORD PTR ?vec_aligned@@3PAFA
	mov	DWORD PTR ?vec_alphaR@@3PAFA, eax
	ret	0
??__Evec_alphaR@@YAXXZ ENDP				; `dynamic initializer for 'vec_alphaR''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ??__Evec_aligned@@YAXXZ
text$di	SEGMENT
??__Evec_aligned@@YAXXZ PROC				; `dynamic initializer for 'vec_aligned'', COMDAT

; 58   : static kdu_int16 *vec_aligned = create_vector_constants();

	call	?create_vector_constants@@YAPAFXZ	; create_vector_constants
	mov	DWORD PTR ?vec_aligned@@3PAFA, eax
	ret	0
??__Evec_aligned@@YAXXZ ENDP				; `dynamic initializer for 'vec_aligned''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_colour_mmx_local.h
;	COMDAT ?create_vector_constants@@YAPAFXZ
_TEXT	SEGMENT
_buf$1$ = -4						; size = 4
?create_vector_constants@@YAPAFXZ PROC			; create_vector_constants, COMDAT

; 70   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 71   :   kdu_int16 alphaR = (kdu_int16)(0.299 * (1<<16));
; 72   :   kdu_int16 alphaB = (kdu_int16)(0.114 * (1<<16));
; 73   :   kdu_int16 CBfact = (kdu_int16)(0.4356659 * (1<<16)); // Actual value is 1-0.4356659
; 74   :   kdu_int16 CRfact = (kdu_int16)(0.2867332 * (1<<16)); // Actual value is 1-0.2867332
; 75   :   
; 76   :   kdu_int16 CRfactR = (kdu_int16)(0.402 * (1<<16)); // Actual factor is 1.402
; 77   :   kdu_int16 CBfactB = (kdu_int16)(-0.228 * (1<<16)); // Actual factor is 1.772
; 78   :   kdu_int16 CRfactG = (kdu_int16)(0.285864 * (1<<16)); // Actual factor is -0.714136
; 79   :   kdu_int16 CBfactG = (kdu_int16)(-0.344136 * (1<<16)); // Actual factor is -0.344136
; 80   : 
; 81   :   kdu_int16 *buf = _vec_store;
; 82   :   int k, alignment = _addr_to_kdu_int32(buf) & 0x0F;
; 83   :   assert((alignment & 1) == 0);
; 84   :   alignment >>= 1; // Convert to words
; 85   :   buf += ((8-alignment) & 7);

	mov	eax, OFFSET ?_vec_store@@3PAFA
	mov	edx, 8
	sar	eax, 1
	neg	eax
	and	eax, 7
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR ?_vec_store@@3PAFA[eax*2]
	mov	esi, 19595				; 00004c8bH
	mov	DWORD PTR _buf$1$[ebp], eax
	lea	ecx, DWORD PTR [eax+32]
	mov	edi, 7471				; 00001d2fH
	mov	ebx, 28551				; 00006f87H
	mov	eax, 18791				; 00004967H
	npad	7
$LL8@create_vec:

; 86   :   
; 87   :   for (k=0; k < 8; k++)
; 88   :     {
; 89   :       buf[k] = alphaR;      buf[k+8] = alphaB;

	mov	WORD PTR [ecx-32], si

; 90   :       buf[k+16] = CBfact;   buf[k+24] = CRfact;
; 91   :       buf[k+32] = CRfactR;  buf[k+40] = CBfactB;

	mov	esi, 26345				; 000066e9H
	mov	WORD PTR [ecx+32], si
	mov	esi, -14942				; ffffc5a2H
	mov	WORD PTR [ecx+48], si

; 92   :       buf[k+48] = CRfactG;  buf[k+56] = CBfactG;

	mov	esi, 18734				; 0000492eH
	mov	WORD PTR [ecx+64], si
	mov	esi, -22553				; ffffa7e7H
	mov	WORD PTR [ecx+80], si
	lea	ecx, DWORD PTR [ecx+2]
	mov	WORD PTR [ecx-18], di
	mov	esi, 19595				; 00004c8bH
	mov	WORD PTR [ecx-2], bx
	mov	WORD PTR [ecx+14], ax
	sub	edx, 1
	jne	SHORT $LL8@create_vec

; 93   :     }
; 94   :   return buf;

	mov	eax, DWORD PTR _buf$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 95   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?create_vector_constants@@YAPAFXZ ENDP			; create_vector_constants
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp
;	COMDAT ?kdu_convert_ycc_to_rgb@@YAXAAVkdu_line_buf@@00H@Z
_TEXT	SEGMENT
_x_cb$1$ = -4						; size = 4
_sp3$1$ = 8						; size = 4
_sp3$1$ = 8						; size = 4
_c1$ = 8						; size = 4
_c2$ = 12						; size = 4
_c3$ = 16						; size = 4
_sp2$1$ = 20						; size = 4
_sp2$1$ = 20						; size = 4
_width$ = 20						; size = 4
?kdu_convert_ycc_to_rgb@@YAXAAVkdu_line_buf@@00H@Z PROC	; kdu_convert_ycc_to_rgb, COMDAT

; 217  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 218  :   int n = width;
; 219  :   if (n < 0)

	mov	eax, DWORD PTR _c1$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _width$[ebp]
	push	esi
	push	edi
	test	ebx, ebx
	jns	SHORT $LN14@kdu_conver
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 544  :         return width;

	mov	ebx, DWORD PTR [eax]
$LN14@kdu_conver:

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	dl, BYTE PTR [eax+6]
	mov	cl, dl
	and	cl, 2
	jne	$LN15@kdu_conver
	mov	edi, DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp

; 226  :   if (c1.get_buf32() != NULL)

	test	edi, edi
	je	$LN15@kdu_conver
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	eax, DWORD PTR _c2$[ebp]
	test	BYTE PTR [eax+6], 2
	je	SHORT $LN38@kdu_conver
	xor	eax, eax
	jmp	SHORT $LN39@kdu_conver
$LN38@kdu_conver:
	mov	eax, DWORD PTR [eax+8]
$LN39@kdu_conver:
	mov	ecx, DWORD PTR _c3$[ebp]
	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN42@kdu_conver
	xor	ecx, ecx
	jmp	SHORT $LN43@kdu_conver
$LN42@kdu_conver:
	mov	ecx, DWORD PTR [ecx+8]
$LN43@kdu_conver:

; 546  :     bool is_absolute() { return ((flags & KD_LINE_BUF_ABSOLUTE) != 0); }

	test	dl, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp

; 233  :       if (!c1.is_absolute())

	jne	$LN17@kdu_conver

; 234  :         { // Irreversible transform (YCbCr to RGB)
; 235  : #ifdef KDU_SIMD_OPTIMIZATIONS
; 236  :           if (!simd_inverse_ict(&(sp1->fval),&(sp2->fval),&(sp3->fval),n))
; 237  : #endif // KDU_SIMD_OPTIMIZATIONS
; 238  :             {
; 239  :               double x_y, x_cb, x_cr;
; 240  :               double x_r, x_g, x_b;
; 241  :               for (; n > 0; n--, sp1++, sp2++, sp3++)

	test	ebx, ebx
	jle	$LN12@kdu_conver
	movsd	xmm5, QWORD PTR __real@3ff66e978d4fdf3c
	sub	edi, eax
	movsd	xmm6, QWORD PTR __real@3fe6da345743d963
	sub	ecx, eax
	movsd	xmm7, QWORD PTR __real@3fd6065433a66b18
	npad	7
$LL4@kdu_conver:
	movss	xmm2, DWORD PTR [ecx+eax]
	dec	ebx
	movss	xmm4, DWORD PTR [edi+eax]
	movss	xmm3, DWORD PTR [eax]

; 242  :                 {
; 243  :                   x_y = sp1->fval;  x_cb = sp2->fval;  x_cr = sp3->fval;

	cvtps2pd xmm2, xmm2
	cvtps2pd xmm4, xmm4

; 244  :                   x_r = x_y + CR_FACT_R*x_cr;

	movaps	xmm0, xmm2

; 245  :                   x_b = x_y + CB_FACT_B*x_cb;
; 246  :                   x_g = x_y - CR_FACT_G*x_cr - CB_FACT_G*x_cb;

	mulsd	xmm2, xmm6
	mulsd	xmm0, xmm5
	movaps	xmm1, xmm4
	cvtps2pd xmm3, xmm3
	addsd	xmm0, xmm4
	subsd	xmm1, xmm2

; 247  :                   sp1->fval = (float) x_r;

	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [edi+eax], xmm0
	movaps	xmm0, xmm3
	mulsd	xmm3, QWORD PTR __real@3ffc5a1cac083127
	mulsd	xmm0, xmm7
	addsd	xmm3, xmm4
	subsd	xmm1, xmm0

; 248  :                   sp2->fval = (float) x_g;

	cvtpd2ps xmm0, xmm1
	movss	DWORD PTR [eax], xmm0

; 249  :                   sp3->fval = (float) x_b;

	cvtpd2ps xmm0, xmm3
	movss	DWORD PTR [ecx+eax], xmm0
	add	eax, 4
	test	ebx, ebx
	jg	SHORT $LL4@kdu_conver
	pop	edi
	pop	esi
	pop	ebx

; 322  :                 }
; 323  :             }
; 324  :         }
; 325  :     }
; 326  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@kdu_conver:

; 250  :                 }
; 251  :             }
; 252  :         }
; 253  :       else
; 254  :         { // 32-bit absolute integers, so use RCT.
; 255  : #ifdef KDU_SIMD_OPTIMIZATIONS
; 256  :           if (!simd_inverse_rct(&(sp1->ival),&(sp2->ival),&(sp3->ival),n))
; 257  : #endif // KDU_SIMD_OPTIMIZATIONS
; 258  :             {
; 259  :               kdu_int32 x_y, x_db, x_dr;
; 260  :               kdu_int32 x_r, x_g, x_b;
; 261  :               for (; n > 0; n--, sp1++, sp2++, sp3++)

	test	ebx, ebx
	jle	$LN12@kdu_conver
	sub	eax, edi
	sub	ecx, edi
	mov	DWORD PTR _sp2$1$[ebp], eax
	mov	DWORD PTR _sp3$1$[ebp], ecx
	npad	1
$LL7@kdu_conver:

; 262  :                 {
; 263  :                   x_y = sp1->ival;  x_db = sp2->ival;  x_dr = sp3->ival;

	mov	esi, DWORD PTR [eax+edi]
	lea	edi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ecx+edi-4]
	dec	ebx

; 264  :                   x_g = x_y - ((x_db+x_dr) >> 2);

	mov	edx, DWORD PTR [edi-4]
	lea	eax, DWORD PTR [ecx+esi]
	sar	eax, 2
	sub	edx, eax

; 265  :                   x_r = x_g + x_dr;

	lea	eax, DWORD PTR [edx+ecx]

; 266  :                   x_b = x_g + x_db;
; 267  :                   sp1->ival = x_r;  sp2->ival = x_g;  sp3->ival = x_b;

	mov	ecx, DWORD PTR _sp3$1$[ebp]
	mov	DWORD PTR [edi-4], eax
	mov	eax, DWORD PTR _sp2$1$[ebp]
	mov	DWORD PTR [eax+edi-4], edx
	lea	eax, DWORD PTR [edx+esi]
	mov	DWORD PTR [ecx+edi-4], eax
	mov	eax, DWORD PTR _sp2$1$[ebp]
	test	ebx, ebx
	jg	SHORT $LL7@kdu_conver
	pop	edi
	pop	esi
	pop	ebx

; 322  :                 }
; 323  :             }
; 324  :         }
; 325  :     }
; 326  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@kdu_conver:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	cl, cl
	je	SHORT $LN52@kdu_conver
	mov	edi, DWORD PTR [eax+8]
	jmp	SHORT $LN53@kdu_conver
$LN52@kdu_conver:
	xor	edi, edi
$LN53@kdu_conver:
	mov	esi, DWORD PTR _c2$[ebp]
	test	BYTE PTR [esi+6], 2
	je	SHORT $LN56@kdu_conver
	mov	esi, DWORD PTR [esi+8]
	jmp	SHORT $LN80@kdu_conver
$LN56@kdu_conver:
	xor	esi, esi
$LN80@kdu_conver:
	mov	ecx, DWORD PTR _c3$[ebp]
	mov	DWORD PTR _sp2$1$[ebp], esi
	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN60@kdu_conver
	mov	ecx, DWORD PTR [ecx+8]
	jmp	SHORT $LN81@kdu_conver
$LN60@kdu_conver:
	xor	ecx, ecx
$LN81@kdu_conver:
	mov	DWORD PTR _sp3$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp

; 283  :           if (!simd_inverse_ict(&(sp1->ival),&(sp2->ival),&(sp3->ival),n))

	push	ebx
	push	ecx
	push	esi
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 546  :     bool is_absolute() { return ((flags & KD_LINE_BUF_ABSOLUTE) != 0); }

	test	dl, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp

; 280  :       if (!c1.is_absolute())

	jne	$LN21@kdu_conver

; 283  :           if (!simd_inverse_ict(&(sp1->ival),&(sp2->ival),&(sp3->ival),n))

	call	?simd_inverse_ict@@YA_NPAF00H@Z		; simd_inverse_ict
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN12@kdu_conver

; 284  : #endif // KDU_SIMD_OPTIMIZATIONS
; 285  :             {
; 286  :               kdu_int32 x_y, x_cb, x_cr;
; 287  :               kdu_int32 x_r, x_g, x_b;
; 288  : #define CR_FACT_R14 ((kdu_int32)(0.5 + CR_FACT_R*(1<<14)))
; 289  : #define CB_FACT_B14 ((kdu_int32)(0.5 + CB_FACT_B*(1<<14)))
; 290  : #define CR_FACT_G14 ((kdu_int32)(0.5 + CR_FACT_G*(1<<14)))
; 291  : #define CB_FACT_G14 ((kdu_int32)(0.5 + CB_FACT_G*(1<<14)))
; 292  : 
; 293  :               for (; n > 0; n--, sp1++, sp2++, sp3++)

	test	ebx, ebx
	jle	$LN12@kdu_conver
	mov	ecx, DWORD PTR _sp3$1$[ebp]
	sub	edi, esi
	sub	ecx, esi
	mov	DWORD PTR _sp3$1$[ebp], ecx
	npad	5
$LL10@kdu_conver:

; 294  :                 {
; 295  :                   x_y = sp1->ival;  x_cb = sp2->ival; x_cr = sp3->ival;

	mov	eax, DWORD PTR _sp2$1$[ebp]
	dec	ebx
	movsx	esi, WORD PTR [esi]
	mov	DWORD PTR _x_cb$1$[ebp], esi

; 296  :                   x_y <<= 14;
; 297  :                   x_r = x_y + CR_FACT_R14*x_cr;
; 298  :                   x_b = x_y + CB_FACT_B14*x_cb;
; 299  :                   x_g = x_y - CR_FACT_G14*x_cr - CB_FACT_G14*x_cb;
; 300  :                   sp1->ival = (kdu_int16)((x_r + (1<<13))>>14);

	mov	esi, DWORD PTR _sp2$1$[ebp]
	movsx	ecx, WORD PTR [ecx+eax]
	movsx	edx, WORD PTR [edi+eax]
	imul	eax, ecx, 22970
	shl	edx, 14					; 0000000eH
	add	eax, 8192				; 00002000H
	add	eax, edx
	sar	eax, 14					; 0000000eH
	mov	WORD PTR [edi+esi], ax
	imul	eax, ecx, 11700
	imul	ecx, DWORD PTR _x_cb$1$[ebp], -5638

; 301  :                   sp2->ival = (kdu_int16)((x_g + (1<<13))>>14);

	sub	ecx, eax
	lea	eax, DWORD PTR [ecx+8192]
	mov	ecx, esi
	add	eax, edx
	sar	eax, 14					; 0000000eH
	mov	WORD PTR [ecx], ax
	imul	eax, DWORD PTR _x_cb$1$[ebp], 29032

; 302  :                   sp3->ival = (kdu_int16)((x_b + (1<<13))>>14);

	mov	ecx, DWORD PTR _sp3$1$[ebp]
	add	eax, 8192				; 00002000H
	add	eax, edx
	sar	eax, 14					; 0000000eH
	mov	WORD PTR [ecx+esi], ax
	add	esi, 2
	mov	DWORD PTR _sp2$1$[ebp], esi
	test	ebx, ebx
	jg	SHORT $LL10@kdu_conver
	pop	edi
	pop	esi
	pop	ebx

; 322  :                 }
; 323  :             }
; 324  :         }
; 325  :     }
; 326  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@kdu_conver:

; 303  :                 }
; 304  :             }
; 305  :         }
; 306  :       else
; 307  :         { // 16-bit absolute integers, so use RCT
; 308  : #ifdef KDU_SIMD_OPTIMIZATIONS
; 309  :           if (!simd_inverse_rct(&(sp1->ival),&(sp2->ival),&(sp3->ival),n))

	call	?simd_inverse_rct@@YA_NPAF00H@Z		; simd_inverse_rct
	add	esp, 16					; 00000010H
	test	al, al
	jne	SHORT $LN12@kdu_conver

; 310  : #endif // KDU_SIMD_OPTIMIZATIONS
; 311  :             {
; 312  :               kdu_int16 x_y, x_db, x_dr;
; 313  :               kdu_int16 x_r, x_g, x_b;
; 314  :           
; 315  :               for (; n > 0; n--, sp1++, sp2++, sp3++)

	test	ebx, ebx
	jle	SHORT $LN12@kdu_conver
	mov	eax, DWORD PTR _sp3$1$[ebp]
	sub	esi, edi
	sub	eax, edi
	mov	DWORD PTR _sp2$1$[ebp], esi
	mov	DWORD PTR _sp3$1$[ebp], eax
$LL13@kdu_conver:

; 316  :                 {
; 317  :                   x_y = sp1->ival;  x_db = sp2->ival;  x_dr = sp3->ival;

	movzx	edx, WORD PTR [eax+edi]
	lea	edi, DWORD PTR [edi+2]
	movzx	esi, WORD PTR [esi+edi-2]
	dec	ebx

; 318  :                   x_g = x_y - ((x_db+x_dr) >> 2);

	movsx	eax, si
	movsx	ecx, dx
	add	ecx, eax
	mov	ax, WORD PTR [edi-2]
	sar	ecx, 2
	sub	ax, cx
	movzx	ecx, ax

; 319  :                   x_r = x_g + x_dr;

	lea	eax, DWORD PTR [ecx+edx]

; 320  :                   x_b = x_g + x_db;
; 321  :                   sp1->ival = x_r;  sp2->ival = x_g; sp3->ival = x_b;

	mov	WORD PTR [edi-2], ax
	mov	eax, DWORD PTR _sp2$1$[ebp]
	mov	WORD PTR [eax+edi-2], cx
	lea	eax, DWORD PTR [ecx+esi]
	mov	ecx, DWORD PTR _sp3$1$[ebp]
	mov	esi, DWORD PTR _sp2$1$[ebp]
	mov	WORD PTR [ecx+edi-2], ax
	mov	eax, ecx
	test	ebx, ebx
	jg	SHORT $LL13@kdu_conver
$LN12@kdu_conver:
	pop	edi
	pop	esi
	pop	ebx

; 322  :                 }
; 323  :             }
; 324  :         }
; 325  :     }
; 326  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?kdu_convert_ycc_to_rgb@@YAXAAVkdu_line_buf@@00H@Z ENDP	; kdu_convert_ycc_to_rgb
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp
;	COMDAT ?kdu_convert_rgb_to_ycc@@YAXAAVkdu_line_buf@@00@Z
_TEXT	SEGMENT
_sp3$1$ = -8						; size = 4
_n$1$ = -8						; size = 4
_sp3$1$ = -4						; size = 4
_sp2$1$ = 8						; size = 4
_sp2$1$ = 8						; size = 4
_c1$ = 8						; size = 4
_c2$ = 12						; size = 4
_c3$ = 16						; size = 4
?kdu_convert_rgb_to_ycc@@YAXAAVkdu_line_buf@@00@Z PROC	; kdu_convert_rgb_to_ycc, COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 544  :         return width;

	mov	eax, DWORD PTR _c1$[ebp]
	push	ebx
	push	esi
	push	edi

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	dl, BYTE PTR [eax+6]

; 544  :         return width;

	mov	edi, DWORD PTR [eax]

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	cl, dl

; 544  :         return width;

	mov	DWORD PTR _n$1$[ebp], edi

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	and	cl, 2
	jne	$LN14@kdu_conver
	mov	ebx, DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp

; 108  :   if (c1.get_buf32() != NULL)

	test	ebx, ebx
	je	$LN14@kdu_conver
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	eax, DWORD PTR _c2$[ebp]
	test	BYTE PTR [eax+6], 2
	je	SHORT $LN37@kdu_conver
	xor	eax, eax
	jmp	SHORT $LN38@kdu_conver
$LN37@kdu_conver:
	mov	eax, DWORD PTR [eax+8]
$LN38@kdu_conver:
	mov	ecx, DWORD PTR _c3$[ebp]
	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN41@kdu_conver
	xor	ecx, ecx
	jmp	SHORT $LN42@kdu_conver
$LN41@kdu_conver:
	mov	ecx, DWORD PTR [ecx+8]
$LN42@kdu_conver:

; 546  :     bool is_absolute() { return ((flags & KD_LINE_BUF_ABSOLUTE) != 0); }

	test	dl, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp

; 115  :       if (!c1.is_absolute())

	jne	$LN16@kdu_conver

; 116  :         { // Irreversible transform (YCbCr to RGB)
; 117  : #ifdef KDU_SIMD_OPTIMIZATIONS
; 118  :           if (!simd_ict(&(sp1->fval),&(sp2->fval),&(sp3->fval),n))
; 119  : #endif // KDU_SIMD_OPTIMIZATIONS
; 120  :             {
; 121  :               double x_y, x_cb, x_cr;
; 122  :               double x_r, x_g, x_b;
; 123  :               for (; n > 0; n--, sp1++, sp2++, sp3++)

	test	edi, edi
	jle	$LN12@kdu_conver
	movsd	xmm4, QWORD PTR __real@3fe2c8b439581062
	sub	ebx, eax
	movsd	xmm5, QWORD PTR __real@3fd322d0e5604189
	sub	ecx, eax
	movsd	xmm6, QWORD PTR __real@3fbd2f1a9fbe76c9
	movsd	xmm7, QWORD PTR __real@3fe20f065b4e0378
	npad	1
$LL4@kdu_conver:
	movss	xmm3, DWORD PTR [ebx+eax]
	dec	edi
	movss	xmm2, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [ecx+eax]

; 124  :                 {
; 125  :                   x_r = sp1->fval;  x_g = sp2->fval;  x_b = sp3->fval;

	cvtps2pd xmm3, xmm3
	cvtps2pd xmm2, xmm2

; 126  :                   x_y = ALPHA_R*x_r + ALPHA_G*x_g + ALPHA_B*x_b;

	movaps	xmm0, xmm3
	mulsd	xmm0, xmm5
	cvtps2pd xmm1, xmm1
	mulsd	xmm2, xmm4
	addsd	xmm2, xmm0
	movaps	xmm0, xmm1
	mulsd	xmm0, xmm6
	addsd	xmm2, xmm0

; 127  :                   x_cb = CB_FACT*(x_b-x_y);

	subsd	xmm1, xmm2

; 128  :                   x_cr = CR_FACT*(x_r-x_y);
; 129  :                   sp1->fval = (float) x_y;

	cvtpd2ps xmm0, xmm2
	mulsd	xmm1, xmm7
	subsd	xmm3, xmm2
	movss	DWORD PTR [ebx+eax], xmm0
	mulsd	xmm3, QWORD PTR __real@3fe6d314d0e3e152

; 130  :                   sp2->fval = (float) x_cb;

	cvtpd2ps xmm0, xmm1
	movss	DWORD PTR [eax], xmm0

; 131  :                   sp3->fval = (float) x_cr;

	cvtpd2ps xmm0, xmm3
	movss	DWORD PTR [ecx+eax], xmm0
	add	eax, 4
	test	edi, edi
	jg	SHORT $LL4@kdu_conver
	pop	edi
	pop	esi
	pop	ebx

; 204  :                 }
; 205  :             }
; 206  :         }
; 207  :     }
; 208  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@kdu_conver:

; 132  :                 }
; 133  :             }
; 134  :         }
; 135  :       else
; 136  :         { // Must be 32-bit absolute integers, so use RCT.
; 137  : #ifdef KDU_SIMD_OPTIMIZATIONS
; 138  :           if (!simd_rct(&(sp1->ival),&(sp2->ival),&(sp3->ival),n))
; 139  : #endif // KDU_SIMD_OPTIMIZATIONS
; 140  :             {
; 141  :               kdu_int32 x_y, x_db, x_dr;
; 142  :               kdu_int32 x_r, x_g, x_b;
; 143  :               for (; n > 0; n--, sp1++, sp2++, sp3++)

	test	edi, edi
	jle	$LN12@kdu_conver
	sub	eax, ebx
	sub	ecx, ebx
	mov	DWORD PTR _sp2$1$[ebp], eax
	mov	DWORD PTR _sp3$1$[ebp], ecx
$LL7@kdu_conver:

; 144  :                 {
; 145  :                   x_r = sp1->ival;  x_g = sp2->ival;  x_b = sp3->ival;

	mov	edx, DWORD PTR [eax+ebx]
	lea	ebx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ecx+ebx-4]
	dec	edi
	mov	esi, DWORD PTR [ebx-4]

; 146  :                   x_y = (x_r + x_g+x_g + x_b) >> 2;

	lea	eax, DWORD PTR [ecx+edx*2]

; 147  :                   x_db = x_b - x_g;

	sub	ecx, edx
	add	eax, esi

; 148  :                   x_dr = x_r - x_g;

	sub	esi, edx
	sar	eax, 2

; 149  :                   sp1->ival = x_y;  sp2->ival = x_db;  sp3->ival = x_dr;

	mov	DWORD PTR [ebx-4], eax
	mov	eax, DWORD PTR _sp2$1$[ebp]
	mov	DWORD PTR [eax+ebx-4], ecx
	mov	ecx, DWORD PTR _sp3$1$[ebp]
	mov	DWORD PTR [ecx+ebx-4], esi
	test	edi, edi
	jg	SHORT $LL7@kdu_conver
	pop	edi
	pop	esi
	pop	ebx

; 204  :                 }
; 205  :             }
; 206  :         }
; 207  :     }
; 208  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@kdu_conver:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	cl, cl
	je	SHORT $LN51@kdu_conver
	mov	ebx, DWORD PTR [eax+8]
	jmp	SHORT $LN52@kdu_conver
$LN51@kdu_conver:
	xor	ebx, ebx
$LN52@kdu_conver:
	mov	esi, DWORD PTR _c2$[ebp]
	test	BYTE PTR [esi+6], 2
	je	SHORT $LN55@kdu_conver
	mov	esi, DWORD PTR [esi+8]
	jmp	SHORT $LN79@kdu_conver
$LN55@kdu_conver:
	xor	esi, esi
$LN79@kdu_conver:
	mov	eax, DWORD PTR _c3$[ebp]
	mov	DWORD PTR _sp2$1$[ebp], esi
	test	BYTE PTR [eax+6], 2
	je	SHORT $LN59@kdu_conver
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN80@kdu_conver
$LN59@kdu_conver:
	xor	eax, eax
$LN80@kdu_conver:
	mov	DWORD PTR _sp3$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp

; 165  :           if (!simd_ict(&(sp1->ival),&(sp2->ival),&(sp3->ival),n))

	push	edi
	push	eax
	push	esi
	push	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 546  :     bool is_absolute() { return ((flags & KD_LINE_BUF_ABSOLUTE) != 0); }

	test	dl, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp

; 162  :       if (!c1.is_absolute())

	jne	$LN20@kdu_conver

; 165  :           if (!simd_ict(&(sp1->ival),&(sp2->ival),&(sp3->ival),n))

	call	?simd_ict@@YA_NPAF00H@Z			; simd_ict
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN12@kdu_conver

; 166  : #endif // KDU_SIMD_OPTIMIZATIONS
; 167  :             {
; 168  :               kdu_int32 x_y, x_cb, x_cr;
; 169  :               kdu_int32 x_r, x_g, x_b;
; 170  : #define ALPHA_R14 ((kdu_int32)(0.5+ALPHA_R*(1<<14)))
; 171  : #define ALPHA_G14 ((kdu_int32)(0.5+ALPHA_G*(1<<14)))
; 172  : #define ALPHA_B14 ((kdu_int32)(0.5+ALPHA_B*(1<<14)))
; 173  : #define CB_FACT14 ((kdu_int32)(0.5 + CB_FACT*(1<<14)))
; 174  : #define CR_FACT14 ((kdu_int32)(0.5 + CR_FACT*(1<<14)))
; 175  : 
; 176  :               for (; n > 0; n--, sp1++, sp2++, sp3++)

	test	edi, edi
	jle	$LN12@kdu_conver
	mov	ecx, DWORD PTR _sp3$1$[ebp]
	sub	ebx, esi
	sub	ecx, esi
	mov	DWORD PTR _sp3$1$[ebp], ecx
$LL10@kdu_conver:

; 177  :                 {
; 178  :                   x_r = sp1->ival;  x_g = sp2->ival;  x_b = sp3->ival;

	mov	eax, DWORD PTR _sp2$1$[ebp]
	dec	edi
	movsx	esi, WORD PTR [ebx+esi]
	movsx	edx, WORD PTR [ecx+eax]
	movsx	eax, WORD PTR [eax]

; 179  :                   x_y=(ALPHA_R14*x_r+ALPHA_G14*x_g+ALPHA_B14*x_b+(1<<13))>>14;

	imul	ecx, eax, 9617
	imul	eax, esi, 4899
	add	ecx, eax
	imul	eax, edx, 1868
	add	eax, 8192				; 00002000H
	add	ecx, eax

; 180  :                   x_cb = (CB_FACT14*(x_b-x_y) + (1<<13)) >> 14;
; 181  :                   x_cr = (CR_FACT14*(x_r-x_y) + (1<<13)) >> 14;
; 182  :                   sp1->ival = (kdu_int16) x_y;

	mov	eax, DWORD PTR _sp2$1$[ebp]
	sar	ecx, 14					; 0000000eH

; 183  :                   sp2->ival = (kdu_int16) x_cb;

	sub	edx, ecx

; 184  :                   sp3->ival = (kdu_int16) x_cr;

	sub	esi, ecx
	mov	WORD PTR [ebx+eax], cx
	mov	ecx, DWORD PTR _sp3$1$[ebp]
	imul	eax, edx, 9246
	mov	edx, DWORD PTR _sp2$1$[ebp]
	add	eax, 8192				; 00002000H
	sar	eax, 14					; 0000000eH
	mov	WORD PTR [edx], ax
	imul	eax, esi, 11686
	mov	esi, edx
	add	eax, 8192				; 00002000H
	sar	eax, 14					; 0000000eH
	mov	WORD PTR [ecx+esi], ax
	add	esi, 2
	mov	DWORD PTR _sp2$1$[ebp], esi
	test	edi, edi
	jg	SHORT $LL10@kdu_conver
	pop	edi
	pop	esi
	pop	ebx

; 204  :                 }
; 205  :             }
; 206  :         }
; 207  :     }
; 208  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@kdu_conver:

; 185  :                 }
; 186  :             }
; 187  :         }
; 188  :       else
; 189  :         { // 16-bit absolute integers, so use RCT.
; 190  : #ifdef KDU_SIMD_OPTIMIZATIONS
; 191  :           if (!simd_rct(&(sp1->ival),&(sp2->ival),&(sp3->ival),n))

	call	?simd_rct@@YA_NPAF00H@Z			; simd_rct
	add	esp, 16					; 00000010H
	test	al, al
	jne	SHORT $LN12@kdu_conver

; 192  : #endif // KDU_SIMD_OPTIMIZATIONS
; 193  :             {
; 194  :               kdu_int16 x_y, x_db, x_dr;
; 195  :               kdu_int16 x_r, x_g, x_b;
; 196  : 
; 197  :               for (; n > 0; n--, sp1++, sp2++, sp3++)

	test	edi, edi
	jle	SHORT $LN12@kdu_conver
	mov	eax, DWORD PTR _sp3$1$[ebp]
	sub	esi, ebx
	sub	eax, ebx
	mov	DWORD PTR _sp2$1$[ebp], esi
	mov	DWORD PTR _sp3$1$[ebp], eax
	npad	9
$LL13@kdu_conver:

; 198  :                 {
; 199  :                   x_r = sp1->ival;  x_g = sp2->ival;  x_b = sp3->ival;

	movzx	edx, WORD PTR [eax+ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movzx	esi, WORD PTR [esi+ebx-2]
	movzx	edi, WORD PTR [ebx-2]

; 200  :                   x_y = (x_r + x_g+x_g + x_b) >> 2;

	movsx	eax, dx

; 201  :                   x_db = x_b - x_g;

	sub	edx, esi
	movsx	ecx, si
	lea	ecx, DWORD PTR [eax+ecx*2]
	movsx	eax, di
	add	ecx, eax

; 202  :                   x_dr = x_r - x_g;

	sub	edi, esi

; 203  :                   sp1->ival = x_y;  sp2->ival = x_db;  sp3->ival = x_dr;

	mov	eax, DWORD PTR _sp2$1$[ebp]
	mov	esi, DWORD PTR _sp2$1$[ebp]
	sar	ecx, 2
	mov	WORD PTR [ebx-2], cx
	mov	WORD PTR [eax+ebx-2], dx
	mov	eax, DWORD PTR _sp3$1$[ebp]
	mov	WORD PTR [eax+ebx-2], di
	mov	eax, DWORD PTR _n$1$[ebp]
	dec	eax
	mov	DWORD PTR _n$1$[ebp], eax
	test	eax, eax
	mov	eax, DWORD PTR _sp3$1$[ebp]
	jg	SHORT $LL13@kdu_conver
$LN12@kdu_conver:
	pop	edi
	pop	esi
	pop	ebx

; 204  :                 }
; 205  :             }
; 206  :         }
; 207  :     }
; 208  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?kdu_convert_rgb_to_ycc@@YAXAAVkdu_line_buf@@00@Z ENDP	; kdu_convert_rgb_to_ycc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?is_absolute@kdu_line_buf@@QAE_NXZ
_TEXT	SEGMENT
?is_absolute@kdu_line_buf@@QAE_NXZ PROC			; kdu_line_buf::is_absolute, COMDAT
; _this$ = ecx

; 546  :     bool is_absolute() { return ((flags & KD_LINE_BUF_ABSOLUTE) != 0); }

	movzx	eax, BYTE PTR [ecx+6]
	and	eax, 1
	ret	0
?is_absolute@kdu_line_buf@@QAE_NXZ ENDP			; kdu_line_buf::is_absolute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_width@kdu_line_buf@@QAEHXZ
_TEXT	SEGMENT
?get_width@kdu_line_buf@@QAEHXZ PROC			; kdu_line_buf::get_width, COMDAT
; _this$ = ecx

; 537  :       /* [SYNOPSIS]
; 538  :            Returns 0 if the object has not been created.  Otherwise, returns
; 539  :            the nominal width of the line.  Remember that the arrays returned
; 540  :            by `get_buf16' and `get_buf32' are typically larger than the actual
; 541  :            line width, as explained in the comments appearing with the
; 542  :            `pre_create' function.
; 543  :       */
; 544  :         return width;

	mov	eax, DWORD PTR [ecx]

; 545  :       }

	ret	0
?get_width@kdu_line_buf@@QAEHXZ ENDP			; kdu_line_buf::get_width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ
_TEXT	SEGMENT
?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ PROC	; kdu_line_buf::get_buf16, COMDAT
; _this$ = ecx

; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN3@get_buf16
	mov	eax, DWORD PTR [ecx+8]

; 414  :       }

	ret	0
$LN3@get_buf16:

; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	xor	eax, eax

; 414  :       }

	ret	0
?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ ENDP	; kdu_line_buf::get_buf16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ
_TEXT	SEGMENT
?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ PROC	; kdu_line_buf::get_buf32, COMDAT
; _this$ = ecx

; 393  :       /* [SYNOPSIS]
; 394  :            Returns NULL if the sample values are of type `kdu_sample16'
; 395  :            instead of `kdu_sample32', or the buffer has not yet been
; 396  :            created.  Otherwise, returns an array which supports accesses
; 397  :            at least with indices in the range 0 to `width'-1, but typically
; 398  :            beyond these bounds -- see `pre_create' for an explanation of
; 399  :            extended access bounds.
; 400  :       */
; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN3@get_buf32
	xor	eax, eax

; 402  :       }

	ret	0
$LN3@get_buf32:

; 393  :       /* [SYNOPSIS]
; 394  :            Returns NULL if the sample values are of type `kdu_sample16'
; 395  :            instead of `kdu_sample32', or the buffer has not yet been
; 396  :            created.  Otherwise, returns an array which supports accesses
; 397  :            at least with indices in the range 0 to `width'-1, but typically
; 398  :            beyond these bounds -- see `pre_create' for an explanation of
; 399  :            extended access bounds.
; 400  :       */
; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	eax, DWORD PTR [ecx+8]

; 402  :       }

	ret	0
?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ ENDP	; kdu_line_buf::get_buf32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\colour.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
