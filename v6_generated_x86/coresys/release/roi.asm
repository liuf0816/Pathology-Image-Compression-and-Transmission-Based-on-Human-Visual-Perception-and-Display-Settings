; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\roi\roi.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	??0kdu_coords@@QAE@XZ				; kdu_coords::kdu_coords
PUBLIC	??1kdu_roi_node@@UAE@XZ				; kdu_roi_node::~kdu_roi_node
PUBLIC	?release@kdu_roi_node@@UAEXXZ			; kdu_roi_node::release
PUBLIC	??_Gkdu_roi_node@@UAEPAXI@Z			; kdu_roi_node::`scalar deleting destructor'
PUBLIC	?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z ; kdu_roi_level::create
PUBLIC	?destroy@kdu_roi_level@@QAEXXZ			; kdu_roi_level::destroy
PUBLIC	?acquire_node@kdu_roi_level@@QAEPAVkdu_roi_node@@H@Z ; kdu_roi_level::acquire_node
PUBLIC	??1kd_roi_level_node@@UAE@XZ			; kd_roi_level_node::~kd_roi_level_node
PUBLIC	?pull@kd_roi_level_node@@UAEXQAEH@Z		; kd_roi_level_node::pull
PUBLIC	?advance@kd_roi_level_node@@QAEPAEXZ		; kd_roi_level_node::advance
PUBLIC	?release@kd_roi_level_node@@UAEXXZ		; kd_roi_level_node::release
PUBLIC	??_Gkd_roi_level_node@@UAEPAXI@Z		; kd_roi_level_node::`scalar deleting destructor'
PUBLIC	??0kd_roi_level@@QAE@XZ				; kd_roi_level::kd_roi_level
PUBLIC	??1kd_roi_level@@QAE@XZ				; kd_roi_level::~kd_roi_level
PUBLIC	?init@kd_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z ; kd_roi_level::init
PUBLIC	?advance@kd_roi_level@@QAEXXZ			; kd_roi_level::advance
PUBLIC	?notify_release@kd_roi_level@@QAEXPAVkd_roi_level_node@@@Z ; kd_roi_level::notify_release
PUBLIC	??_7kdu_roi_node@@6B@				; kdu_roi_node::`vftable'
PUBLIC	??_7kd_roi_level_node@@6B@			; kd_roi_level_node::`vftable'
PUBLIC	??_R4kdu_roi_node@@6B@				; kdu_roi_node::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_roi_node@@@8			; kdu_roi_node `RTTI Type Descriptor'
PUBLIC	??_R3kdu_roi_node@@8				; kdu_roi_node::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_roi_node@@8				; kdu_roi_node::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_roi_node@@8			; kdu_roi_node::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_roi_level_node@@6B@			; kd_roi_level_node::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_roi_level_node@@@8			; kd_roi_level_node `RTTI Type Descriptor'
PUBLIC	??_R3kd_roi_level_node@@8			; kd_roi_level_node::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_roi_level_node@@8			; kd_roi_level_node::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_roi_level_node@@8		; kd_roi_level_node::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	?access_child@kdu_node@@QAE?AV1@H@Z:PROC	; kdu_node::access_child
EXTRN	?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z:PROC	; kdu_node::get_dims
EXTRN	?get_kernel_info@kdu_node@@QAEPBUkdu_kernel_step_info@@AAHAAM1AA_N20000_N@Z:PROC ; kdu_node::get_kernel_info
EXTRN	??_Ekdu_roi_node@@UAEPAXI@Z:PROC		; kdu_roi_node::`vector deleting destructor'
EXTRN	??_Ekd_roi_level_node@@UAEPAXI@Z:PROC		; kd_roi_level_node::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@kd_roi_level_node@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_roi_level_node@@8 DD FLAT:??_R0?AVkd_roi_level_node@@@8 ; kd_roi_level_node::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_roi_level_node@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_roi_level_node@@8
rdata$r	SEGMENT
??_R2kd_roi_level_node@@8 DD FLAT:??_R1A@?0A@EA@kd_roi_level_node@@8 ; kd_roi_level_node::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_roi_node@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_roi_level_node@@8
rdata$r	SEGMENT
??_R3kd_roi_level_node@@8 DD 00H			; kd_roi_level_node::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_roi_level_node@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_roi_level_node@@@8
data$r	SEGMENT
??_R0?AVkd_roi_level_node@@@8 DD FLAT:??_7type_info@@6B@ ; kd_roi_level_node `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_roi_level_node@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_roi_level_node@@6B@
rdata$r	SEGMENT
??_R4kd_roi_level_node@@6B@ DD 00H			; kd_roi_level_node::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_roi_level_node@@@8
	DD	FLAT:??_R3kd_roi_level_node@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_roi_node@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_roi_node@@8 DD FLAT:??_R0?AVkdu_roi_node@@@8 ; kdu_roi_node::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_roi_node@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_roi_node@@8
rdata$r	SEGMENT
??_R2kdu_roi_node@@8 DD FLAT:??_R1A@?0A@EA@kdu_roi_node@@8 ; kdu_roi_node::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_roi_node@@8
rdata$r	SEGMENT
??_R3kdu_roi_node@@8 DD 00H				; kdu_roi_node::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_roi_node@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_roi_node@@@8
data$r	SEGMENT
??_R0?AVkdu_roi_node@@@8 DD FLAT:??_7type_info@@6B@	; kdu_roi_node `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_roi_node@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_roi_node@@6B@
rdata$r	SEGMENT
??_R4kdu_roi_node@@6B@ DD 00H				; kdu_roi_node::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_roi_node@@@8
	DD	FLAT:??_R3kdu_roi_node@@8
rdata$r	ENDS
;	COMDAT ??_7kd_roi_level_node@@6B@
CONST	SEGMENT
??_7kd_roi_level_node@@6B@ DD FLAT:??_R4kd_roi_level_node@@6B@ ; kd_roi_level_node::`vftable'
	DD	FLAT:??_Ekd_roi_level_node@@UAEPAXI@Z
	DD	FLAT:?release@kd_roi_level_node@@UAEXXZ
	DD	FLAT:?pull@kd_roi_level_node@@UAEXQAEH@Z
CONST	ENDS
;	COMDAT ??_7kdu_roi_node@@6B@
CONST	SEGMENT
??_7kdu_roi_node@@6B@ DD FLAT:??_R4kdu_roi_node@@6B@	; kdu_roi_node::`vftable'
	DD	FLAT:??_Ekdu_roi_node@@UAEPAXI@Z
	DD	FLAT:?release@kdu_roi_node@@UAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kd_roi_level@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z$0
__unwindtable$?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z$4
__ehfuncinfo$?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_roi_level@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_roi_level@@QAEPAXI@Z PROC			; kd_roi_level::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_roi_level@@QAE@XZ			; kd_roi_level::~kd_roi_level
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	108					; 0000006cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_roi_level@@QAEPAXI@Z ENDP			; kd_roi_level::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
;	COMDAT ?notify_release@kd_roi_level@@QAEXPAVkd_roi_level_node@@@Z
_TEXT	SEGMENT
_caller$ = 8						; size = 4
?notify_release@kd_roi_level@@QAEXPAVkd_roi_level_node@@@Z PROC ; kd_roi_level::notify_release, COMDAT
; _this$ = ecx

; 424  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 425  :   int n;
; 426  : 
; 427  :   for (n=0; n < 4; n++)

	xor	eax, eax
	mov	ecx, DWORD PTR _caller$[ebp]
	lea	edx, DWORD PTR [esi+4]
	npad	2
$LL4@notify_rel:

; 428  :     if (nodes[n] == caller)

	cmp	DWORD PTR [edx], ecx
	je	SHORT $LN9@notify_rel

; 425  :   int n;
; 426  : 
; 427  :   for (n=0; n < 4; n++)

	inc	eax
	add	edx, 4
	cmp	eax, 4
	jl	SHORT $LL4@notify_rel
$LN9@notify_rel:

; 429  :       break;
; 430  :   assert((n < 4) && !node_released[n]);
; 431  :   node_released[n] = true;

	mov	BYTE PTR [eax+esi+20], 1

; 432  :   num_nodes_released++;

	inc	DWORD PTR [esi+24]

; 433  :   if (num_nodes_released == 4)

	cmp	DWORD PTR [esi+24], 4
	jne	SHORT $LN6@notify_rel

; 434  :     {
; 435  :       source->release();

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]

; 436  :       source = NULL;

	mov	DWORD PTR [esi], 0
$LN6@notify_rel:
	pop	esi

; 437  :     }
; 438  : }

	pop	ebp
	ret	4
?notify_release@kd_roi_level@@QAEXPAVkd_roi_level_node@@@Z ENDP ; kd_roi_level::notify_release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
;	COMDAT ?advance@kd_roi_level@@QAEXXZ
_TEXT	SEGMENT
_left$1$ = -40						; size = 4
tv1170 = -40						; size = 4
tv1168 = -40						; size = 4
_width$1$ = -36						; size = 4
tv1138 = -36						; size = 4
_this$1$ = -32						; size = 4
tv1171 = -28						; size = 4
_min_row$2$ = -28					; size = 4
_dp$3$ = -24						; size = 4
_min$1$ = -20						; size = 4
_max_row$1$ = -20					; size = 4
tv1167 = -16						; size = 4
tv1159 = -12						; size = 4
tv1158 = -8						; size = 4
_band$1$ = -4						; size = 4
?advance@kd_roi_level@@QAEXXZ PROC			; kd_roi_level::advance, COMDAT
; _this$ = ecx

; 306  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	DWORD PTR _this$1$[ebp], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	edx, DWORD PTR [ebx+36]
	add	edx, DWORD PTR [ebx+28]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp

; 313  :   if (split_vertically)

	cmp	BYTE PTR [ebx+88], 0
	mov	esi, DWORD PTR [ebx+44]
	mov	DWORD PTR _max_row$1$[ebp], esi
	mov	DWORD PTR _min_row$2$[ebp], esi
	je	SHORT $LN53@advance

; 314  :     {
; 315  :       min_row += support_min[next_row_loc & 1].y;

	mov	eax, esi
	and	eax, 1
	mov	ecx, DWORD PTR [ebx+eax*8+56]
	add	ecx, esi

; 316  :       max_row += support_max[next_row_loc & 1].y;

	add	esi, DWORD PTR [ebx+eax*8+72]

; 317  :       if (min_row < dims.pos.y)

	cmp	ecx, DWORD PTR [ebx+28]
	mov	DWORD PTR _max_row$1$[ebp], esi
	cmovl	ecx, DWORD PTR [ebx+28]
	mov	DWORD PTR _min_row$2$[ebp], ecx

; 318  :         min_row = dims.pos.y;
; 319  :       if (max_row >= lim.y)

	cmp	esi, edx
	jl	SHORT $LN53@advance

; 320  :         max_row = lim.y-1;

	lea	esi, DWORD PTR [edx-1]
	mov	DWORD PTR _max_row$1$[ebp], esi
$LN53@advance:

; 321  :       assert((max_row+1-min_row) <= num_row_buffers);
; 322  :     }
; 323  : 
; 324  :   while (max_row >= (first_valid_row_loc+num_valid_rows))

	mov	eax, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ebx+52]
	add	eax, edx
	cmp	esi, eax
	jl	SHORT $LN3@advance
	mov	ecx, DWORD PTR [ebx+92]
$LL2@advance:

; 325  :     { // Load a new row.
; 326  :       r = first_buffer_idx+num_valid_rows;

	mov	esi, DWORD PTR [ebx+96]
	add	esi, edx

; 327  :       if (r >= num_row_buffers)

	cmp	esi, ecx
	jl	SHORT $LN34@advance

; 328  :         r -= num_row_buffers;

	sub	esi, ecx
$LN34@advance:

; 329  :       source->pull(row_buffers[r],dims.size.x);

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+100]
	push	DWORD PTR [ebx+40]
	mov	edx, DWORD PTR [ecx]
	push	DWORD PTR [eax+esi*4]
	call	DWORD PTR [edx+8]

; 330  :       if (num_valid_rows == num_row_buffers)

	mov	ecx, DWORD PTR [ebx+92]
	mov	eax, DWORD PTR [ebx+52]
	cmp	eax, ecx
	jne	SHORT $LN35@advance

; 331  :         {
; 332  :           first_buffer_idx++; first_valid_row_loc++;

	inc	DWORD PTR [ebx+96]
	inc	DWORD PTR [ebx+48]

; 333  :           if (first_buffer_idx == num_row_buffers)

	cmp	DWORD PTR [ebx+96], ecx
	jne	SHORT $LN36@advance

; 334  :             first_buffer_idx = 0;

	mov	DWORD PTR [ebx+96], 0

; 335  :         }
; 336  :       else

	jmp	SHORT $LN36@advance
$LN35@advance:

; 337  :         num_valid_rows++;

	inc	eax
	mov	DWORD PTR [ebx+52], eax
$LN36@advance:

; 321  :       assert((max_row+1-min_row) <= num_row_buffers);
; 322  :     }
; 323  : 
; 324  :   while (max_row >= (first_valid_row_loc+num_valid_rows))

	mov	eax, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ebx+52]
	add	eax, edx
	mov	esi, DWORD PTR _max_row$1$[ebp]
	cmp	esi, eax
	jge	SHORT $LL2@advance
$LN3@advance:

; 338  :     }
; 339  : 
; 340  :   // Now for the vertical processing
; 341  :   int c;
; 342  :   kdu_byte *sp, *dp;
; 343  : 
; 344  :   r = min_row - first_valid_row_loc + first_buffer_idx;
; 345  :   assert(r >= first_buffer_idx);
; 346  :   if (r >= num_row_buffers)

	mov	eax, DWORD PTR [ebx+92]
	push	edi
	mov	edi, DWORD PTR [ebx+96]
	sub	edi, DWORD PTR [ebx+48]
	add	edi, DWORD PTR _min_row$2$[ebp]
	cmp	edi, eax
	jl	SHORT $LN38@advance

; 347  :     r -= num_row_buffers;

	sub	edi, eax
$LN38@advance:

; 348  :   memcpy(out_buf,row_buffers[r],(size_t)(dims.size.x));

	mov	eax, DWORD PTR [ebx+100]
	push	DWORD PTR [ebx+40]
	push	DWORD PTR [eax+edi*4]
	push	DWORD PTR [ebx+104]
	call	_memcpy

; 349  :   for (min_row++, r++; min_row <= max_row; min_row++, r++)

	mov	eax, DWORD PTR _min_row$2$[ebp]
	add	esp, 12					; 0000000cH
	inc	eax
	inc	edi
	cmp	eax, esi
	jg	SHORT $LN5@advance

; 348  :   memcpy(out_buf,row_buffers[r],(size_t)(dims.size.x));

	sub	esi, eax
	inc	esi
	mov	DWORD PTR _max_row$1$[ebp], esi
	npad	7
$LL6@advance:

; 350  :     {
; 351  :       if (r == num_row_buffers)
; 352  :         r = 0;
; 353  :       for (sp=row_buffers[r], dp=out_buf, c=dims.size.x; c > 0; c--)

	mov	edx, DWORD PTR [ebx+40]
	xor	eax, eax
	cmp	edi, DWORD PTR [ebx+92]
	mov	ecx, DWORD PTR [ebx+104]
	cmove	edi, eax
	mov	eax, DWORD PTR [ebx+100]
	mov	esi, DWORD PTR [eax+edi*4]
	test	edx, edx
	jle	SHORT $LN4@advance
$LL9@advance:

; 354  :         *(dp++) |= *(sp++);

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	or	BYTE PTR [ecx], al
	lea	ecx, DWORD PTR [ecx+1]
	dec	edx
	test	edx, edx
	jg	SHORT $LL9@advance
$LN4@advance:

; 349  :   for (min_row++, r++; min_row <= max_row; min_row++, r++)

	inc	edi
	sub	DWORD PTR _max_row$1$[ebp], 1
	jne	SHORT $LL6@advance
$LN5@advance:

; 355  :     }
; 356  : 
; 357  :   // Finally, time for the horizontal processing
; 358  :   int node_idx = (split_vertically)?(next_row_loc & 1):0;

	cmp	BYTE PTR [ebx+88], 0
	je	SHORT $LN47@advance
	mov	eax, DWORD PTR [ebx+44]
	and	eax, 1
	jmp	SHORT $LN48@advance
$LN47@advance:
	xor	eax, eax
$LN48@advance:

; 359  :   node_idx += node_idx;

	add	eax, eax

; 360  :   if (!split_horizontally)

	cmp	BYTE PTR [ebx+89], 0
	jne	SHORT $LN40@advance

; 361  :     {
; 362  :       kd_roi_level_node *node = nodes[node_idx];
; 363  :       assert(node != NULL);
; 364  :       dp = node->advance();

	mov	ecx, DWORD PTR [ebx+eax*4+4]
	call	?advance@kd_roi_level_node@@QAEPAEXZ	; kd_roi_level_node::advance

; 365  :       if (dp != NULL)

	test	eax, eax
	je	$LN11@advance

; 366  :         memcpy(dp,out_buf,(size_t)(dims.size.x));

	push	DWORD PTR [ebx+40]
	push	DWORD PTR [ebx+104]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 367  :     }
; 368  :   else

	jmp	$LN11@advance
$LN40@advance:

; 369  :     {
; 370  :       for (int band=0; band < 2; band++, node_idx++)

	lea	esi, DWORD PTR [ebx+20]
	xor	ecx, ecx
	add	esi, eax
	mov	DWORD PTR _band$1$[ebp], ecx
	inc	eax
	mov	DWORD PTR tv1167[ebp], esi
	mov	edi, esi
	lea	esi, DWORD PTR [ebx+76]
	mov	DWORD PTR tv1159[ebp], esi
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv1158[ebp], eax
	xor	eax, eax
	mov	ecx, DWORD PTR tv1158[ebp]
	npad	4
$LL12@advance:

; 371  :         {
; 372  :           if (node_released[node_idx])

	cmp	BYTE PTR [edi], 0
	jne	$LN10@advance

; 373  :             continue;
; 374  :           kd_roi_level_node *node = nodes[node_idx];
; 375  :           assert(node != NULL);
; 376  :           dp = node->advance();

	mov	ecx, DWORD PTR [ecx]
	call	?advance@kd_roi_level_node@@QAEPAEXZ	; kd_roi_level_node::advance
	mov	DWORD PTR _dp$3$[ebp], eax

; 377  :           if (dp == NULL)

	test	eax, eax
	je	$LN107@advance

; 378  :             continue; // Released but `notify_release' not called; never mind
; 379  :           int min = support_min[band].x;

	mov	ecx, DWORD PTR tv1159[ebp]

; 380  :           int max = support_max[band].x;
; 381  :           int left = (dims.pos.x + band) & 1; // Samples to left of current loc
; 382  :           int right = dims.size.x-left-1; // Samples to right of current loc

	mov	edx, DWORD PTR [ebx+40]
	mov	eax, DWORD PTR [ecx-16]
	mov	esi, DWORD PTR [ecx]

; 383  :           int width = 1 + (right>>1);
; 384  : 
; 385  :           sp = out_buf+left;

	mov	ecx, DWORD PTR [ebx+104]
	mov	DWORD PTR _min$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+32]
	add	eax, DWORD PTR _band$1$[ebp]
	and	eax, 1
	sub	edx, eax
	mov	DWORD PTR _left$1$[ebp], eax
	dec	edx
	add	ecx, eax
	mov	edi, edx
	sar	edi, 1
	inc	edi
	mov	DWORD PTR _width$1$[ebp], edi

; 386  :           kdu_byte val;
; 387  :           for (; (width > 0) && ((left+min) < 0);

	test	edi, edi
	jle	$LN106@advance

; 378  :             continue; // Released but `notify_release' not called; never mind
; 379  :           int min = support_min[band].x;

	mov	ebx, DWORD PTR _left$1$[ebp]
	neg	eax
	add	ebx, DWORD PTR _min$1$[ebp]
	mov	DWORD PTR tv1171[ebp], eax
	mov	DWORD PTR tv1170[ebp], ebx
	npad	5
$LL15@advance:

; 386  :           kdu_byte val;
; 387  :           for (; (width > 0) && ((left+min) < 0);

	test	ebx, ebx
	jns	SHORT $LN14@advance

; 388  :                width--, left+=2, right-=2, sp+=2, dp++)
; 389  :             { // Initial samples treated specially to deal with boundaries.
; 390  :               for (val=0, c=-left; (c <= max) && (c <= right); c++)

	xor	bl, bl
	cmp	DWORD PTR tv1171[ebp], esi
	jg	SHORT $LN102@advance
	npad	5
$LL18@advance:
	cmp	eax, edx
	jg	SHORT $LN102@advance

; 391  :                 val |= sp[c];

	or	bl, BYTE PTR [eax+ecx]
	inc	eax
	cmp	eax, esi
	jle	SHORT $LL18@advance
$LN102@advance:

; 392  :               *dp = val;

	mov	eax, DWORD PTR _dp$3$[ebp]
	dec	edi
	sub	DWORD PTR tv1171[ebp], 2
	sub	edx, 2
	add	ecx, 2
	mov	DWORD PTR _width$1$[ebp], edi
	mov	BYTE PTR [eax], bl
	inc	eax
	mov	ebx, DWORD PTR tv1170[ebp]
	add	ebx, 2
	mov	DWORD PTR _dp$3$[ebp], eax
	mov	eax, DWORD PTR tv1171[ebp]
	mov	DWORD PTR tv1170[ebp], ebx
	test	edi, edi
	jg	SHORT $LL15@advance

; 393  :             }
; 394  :           for (; (width > 0) && (right >= max);

	jmp	$LN103@advance
$LN14@advance:
	test	edi, edi
	jle	$LN103@advance
$LL21@advance:
	cmp	edx, esi
	jl	$LN20@advance

; 395  :                width--, left+=2, right-=2, sp+=2, dp++)
; 396  :             {
; 397  :               for (val=0, c=min; c <= max; c++)

	mov	eax, DWORD PTR _min$1$[ebp]
	mov	edi, esi
	sub	edi, eax
	xor	bl, bl
	inc	edi
	cmp	eax, esi
	jg	SHORT $LN23@advance
	cmp	edi, 32					; 00000020H
	jb	SHORT $LN73@advance
	and	edi, -2147483617			; 8000001fH
	jns	SHORT $LN108@advance
	dec	edi
	or	edi, -32				; ffffffe0H
	inc	edi
$LN108@advance:
	mov	ebx, esi
	xorps	xmm2, xmm2
	sub	ebx, edi
	movaps	xmm1, xmm2
$LL24@advance:

; 398  :                 val |= sp[c];

	movups	xmm0, XMMWORD PTR [eax+ecx]
	por	xmm2, xmm0
	movups	xmm0, XMMWORD PTR [eax+ecx+16]
	add	eax, 32					; 00000020H
	por	xmm1, xmm0
	cmp	eax, ebx
	jle	SHORT $LL24@advance
	por	xmm1, xmm2
	movaps	xmm0, xmm1
	psrldq	xmm0, 8
	por	xmm1, xmm0
	movaps	xmm0, xmm1
	psrldq	xmm0, 4
	por	xmm1, xmm0
	movaps	xmm0, xmm1
	psrldq	xmm0, 2
	por	xmm1, xmm0
	movaps	xmm0, xmm1
	psrldq	xmm0, 1
	por	xmm1, xmm0
	movd	ebx, xmm1
$LN73@advance:

; 395  :                width--, left+=2, right-=2, sp+=2, dp++)
; 396  :             {
; 397  :               for (val=0, c=min; c <= max; c++)

	cmp	eax, esi
	jg	SHORT $LN23@advance
$LL72@advance:

; 398  :                 val |= sp[c];

	or	bl, BYTE PTR [eax+ecx]
	inc	eax
	cmp	eax, esi
	jle	SHORT $LL72@advance
$LN23@advance:

; 399  :               *dp = val;

	mov	eax, DWORD PTR _dp$3$[ebp]
	sub	edx, 2
	mov	edi, DWORD PTR _width$1$[ebp]
	add	ecx, 2
	dec	edi
	mov	DWORD PTR _width$1$[ebp], edi
	mov	BYTE PTR [eax], bl
	inc	eax
	mov	DWORD PTR _dp$3$[ebp], eax
	test	edi, edi
	jg	$LL21@advance

; 400  :             }
; 401  :           for (; width > 0; width--, left+=2, right-=2, sp+=2, dp++)

	jmp	$LN103@advance
$LN20@advance:
	test	edi, edi
	jle	$LN103@advance
	mov	esi, DWORD PTR _min$1$[ebp]
	mov	eax, 1
	sub	eax, esi
	mov	DWORD PTR tv1168[ebp], eax
$LL27@advance:

; 402  :             {
; 403  :               for (val=0, c=min; c <= right; c++)

	xor	bl, bl
	mov	eax, esi
	cmp	esi, edx
	jg	$LN29@advance
	mov	esi, DWORD PTR tv1168[ebp]
	add	esi, edx
	cmp	esi, 32					; 00000020H
	jb	SHORT $LN75@advance
	and	esi, -2147483617			; 8000001fH
	jns	SHORT $LN109@advance
	dec	esi
	or	esi, -32				; ffffffe0H
	inc	esi
$LN109@advance:
	mov	DWORD PTR tv1138[ebp], esi
	xorps	xmm2, xmm2
	mov	esi, edx
	movaps	xmm1, xmm2
	sub	esi, DWORD PTR tv1138[ebp]
	npad	9
$LL30@advance:

; 404  :                 val |= sp[c];

	movups	xmm0, XMMWORD PTR [eax+ecx]
	por	xmm2, xmm0
	movups	xmm0, XMMWORD PTR [eax+ecx+16]
	add	eax, 32					; 00000020H
	por	xmm1, xmm0
	cmp	eax, esi
	jle	SHORT $LL30@advance
	por	xmm1, xmm2
	movaps	xmm0, xmm1
	psrldq	xmm0, 8
	por	xmm1, xmm0
	movaps	xmm0, xmm1
	psrldq	xmm0, 4
	por	xmm1, xmm0
	movaps	xmm0, xmm1
	psrldq	xmm0, 2
	por	xmm1, xmm0
	movaps	xmm0, xmm1
	psrldq	xmm0, 1
	por	xmm1, xmm0
	movd	ebx, xmm1
$LN75@advance:

; 402  :             {
; 403  :               for (val=0, c=min; c <= right; c++)

	cmp	eax, edx
	jg	SHORT $LN105@advance
$LL74@advance:

; 404  :                 val |= sp[c];

	or	bl, BYTE PTR [eax+ecx]
	inc	eax
	cmp	eax, edx
	jle	SHORT $LL74@advance
$LN105@advance:
	mov	esi, DWORD PTR _min$1$[ebp]
$LN29@advance:

; 405  :               *dp = val;

	mov	eax, DWORD PTR _dp$3$[ebp]
	dec	edi
	sub	edx, 2
	add	ecx, 2
	mov	BYTE PTR [eax], bl
	inc	eax
	mov	DWORD PTR _dp$3$[ebp], eax
	test	edi, edi
	jg	$LL27@advance
$LN103@advance:
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN106@advance:
	mov	edi, DWORD PTR tv1167[ebp]
	mov	esi, DWORD PTR tv1159[ebp]
$LN107@advance:
	mov	eax, DWORD PTR _band$1$[ebp]
	mov	ecx, DWORD PTR tv1158[ebp]
$LN10@advance:

; 369  :     {
; 370  :       for (int band=0; band < 2; band++, node_idx++)

	inc	eax
	add	esi, 8
	inc	edi
	mov	DWORD PTR _band$1$[ebp], eax
	add	ecx, 4
	mov	DWORD PTR tv1159[ebp], esi
	mov	DWORD PTR tv1167[ebp], edi
	mov	DWORD PTR tv1158[ebp], ecx
	cmp	eax, 2
	jl	$LL12@advance
$LN11@advance:

; 406  :             }
; 407  :         }
; 408  :     }
; 409  : 
; 410  :   next_row_loc++;

	inc	DWORD PTR [ebx+44]

; 411  :   if (num_nodes_released == 4)

	cmp	DWORD PTR [ebx+24], 4
	pop	edi
	jne	SHORT $LN45@advance

; 412  :     {
; 413  :       source->release();

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]

; 414  :       source = NULL;

	mov	DWORD PTR [ebx], 0
$LN45@advance:
	pop	esi
	pop	ebx

; 415  :     }
; 416  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?advance@kd_roi_level@@QAEXXZ ENDP			; kd_roi_level::advance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
;	COMDAT ?init@kd_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z
_TEXT	SEGMENT
_child_dims$1 = -40					; size = 16
$T2 = -24						; size = 4
_sval$ = -20						; size = 4
_lval$ = -16						; size = 4
_hval$ = -12						; size = 4
_child$3 = -8						; size = 4
_sym$ = -1						; size = 1
_node$ = 8						; size = 4
_source$ = 12						; size = 4
_sym_ext$ = 15						; size = 1
?init@kd_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z PROC ; kd_roi_level::init, COMDAT
; _this$ = ecx

; 234  : {

	push	ebp
	mov	ebp, esp

; 235  :   this->source = source;

	mov	eax, DWORD PTR _source$[ebp]
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	mov	esi, ecx

; 236  :   node.get_dims(dims);

	lea	ecx, DWORD PTR _node$[ebp]
	push	edi
	mov	DWORD PTR [esi], eax
	lea	eax, DWORD PTR [esi+28]
	push	eax
	call	?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z	; kdu_node::get_dims

; 237  :   num_nodes_released = 0;

	mov	DWORD PTR [esi+24], 0
	lea	ebx, DWORD PTR [esi+4]

; 238  :   for (int b=0; b < 4; b++)

	xor	edi, edi
$LL4@init:

; 239  :     {
; 240  :       kdu_node child = node.access_child(b);

	push	edi
	lea	eax, DWORD PTR _child$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?access_child@kdu_node@@QAE?AV1@H@Z	; kdu_node::access_child
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4994 :     bool operator!() { return (state==NULL)?true:false; }

	cmp	DWORD PTR _child$3[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp

; 241  :       if (!child)

	jne	SHORT $LN14@init

; 242  :         {
; 243  :           nodes[b] = NULL;

	mov	DWORD PTR [ebx], 0

; 244  :           node_released[b] = true;

	mov	BYTE PTR [esi+edi+20], 1

; 245  :           num_nodes_released++;

	inc	DWORD PTR [esi+24]

; 246  :           continue;

	jmp	SHORT $LN2@init
$LN14@init:

; 247  :         }
; 248  : 
; 249  :       kdu_dims child_dims;  child.get_dims(child_dims);

	lea	eax, DWORD PTR _child_dims$1[ebp]
	xorps	xmm0, xmm0
	push	eax
	lea	ecx, DWORD PTR _child$3[ebp]
	movups	XMMWORD PTR _child_dims$1[ebp], xmm0
	call	?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z	; kdu_node::get_dims

; 250  :       nodes[b] = new kd_roi_level_node(this,child_dims.size);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	test	eax, eax
	je	SHORT $LN20@init
	mov	edx, DWORD PTR _child_dims$1[ebp+8]
	mov	ecx, DWORD PTR _child_dims$1[ebp+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi_local.h

; 67   :       {

	mov	DWORD PTR [eax], OFFSET ??_7kd_roi_level_node@@6B@

; 68   :         this->owner = owner; available = true; active = false;

	mov	DWORD PTR [eax+4], esi
	mov	WORD PTR [eax+8], 1

; 69   :         cols = size.x; remaining_rows = size.y;

	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx

; 70   :         num_row_buffers = first_valid_row_buffer = num_valid_row_buffers = 0;

	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+20], 0

; 71   :         row_buffers = NULL;

	mov	DWORD PTR [eax+32], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp

; 250  :       nodes[b] = new kd_roi_level_node(this,child_dims.size);

	jmp	SHORT $LN21@init
$LN20@init:
	xor	eax, eax
$LN21@init:
	mov	DWORD PTR [ebx], eax

; 251  :       node_released[b] = false;

	mov	BYTE PTR [esi+edi+20], 0
$LN2@init:

; 238  :   for (int b=0; b < 4; b++)

	inc	edi
	add	ebx, 4
	cmp	edi, 4
	jl	$LL4@init

; 252  :     }
; 253  : 
; 254  :   split_horizontally = (nodes[HL_BAND] != NULL);

	cmp	DWORD PTR [esi+8], 0
	setne	cl
	mov	BYTE PTR [esi+89], cl

; 255  :   split_vertically = (nodes[LH_BAND] != NULL);

	cmp	DWORD PTR [esi+12], 0
	setne	al

; 256  : 
; 257  :   // Determine the synthesis impulse response supports
; 258  :   int n, sval, max_vert_extent = 0;

	xor	edx, edx
	mov	BYTE PTR [esi+88], al

; 259  :   float lval, hval;
; 260  :   bool sym, sym_ext;
; 261  :   if (split_horizontally)

	test	cl, cl
	je	SHORT $LN15@init

; 262  :     node.get_kernel_info(sval,lval,hval,sym,sym_ext,

	push	edx
	lea	eax, DWORD PTR [esi+84]
	push	eax
	lea	eax, DWORD PTR [esi+68]
	push	eax
	lea	eax, DWORD PTR [esi+76]
	push	eax
	lea	eax, DWORD PTR [esi+60]
	push	eax
	lea	eax, DWORD PTR _sym_ext$[ebp]
	push	eax
	lea	eax, DWORD PTR _sym$[ebp]
	push	eax
	lea	eax, DWORD PTR _hval$[ebp]
	push	eax
	lea	eax, DWORD PTR _lval$[ebp]
	push	eax
	lea	eax, DWORD PTR _sval$[ebp]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?get_kernel_info@kdu_node@@QAEPBUkdu_kernel_step_info@@AAHAAM1AA_N20000_N@Z ; kdu_node::get_kernel_info
	xor	edx, edx
$LN15@init:

; 263  :                          support_min[0].x,support_max[0].x,
; 264  :                          support_min[1].x,support_max[1].x,false);
; 265  :   if (split_vertically)

	cmp	BYTE PTR [esi+88], 0
	je	SHORT $LN54@init

; 266  :     {
; 267  :       node.get_kernel_info(sval,lval,hval,sym,sym_ext,

	push	1
	lea	eax, DWORD PTR [esi+80]
	push	eax
	lea	ecx, DWORD PTR [esi+64]
	push	ecx
	lea	edi, DWORD PTR [esi+72]
	push	edi
	lea	ebx, DWORD PTR [esi+56]
	push	ebx
	lea	eax, DWORD PTR _sym_ext$[ebp]
	push	eax
	lea	eax, DWORD PTR _sym$[ebp]
	push	eax
	lea	eax, DWORD PTR _hval$[ebp]
	push	eax
	lea	eax, DWORD PTR _lval$[ebp]
	push	eax
	lea	eax, DWORD PTR _sval$[ebp]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?get_kernel_info@kdu_node@@QAEPBUkdu_kernel_step_info@@AAHAAM1AA_N20000_N@Z ; kdu_node::get_kernel_info

; 268  :                            support_min[0].y,support_max[0].y,
; 269  :                            support_min[1].y,support_max[1].y,true);
; 270  :       for (n=0; n < 2; n++)
; 271  :         {
; 272  :           if (max_vert_extent < support_max[n].y)

	mov	eax, DWORD PTR [edi]
	xor	edx, edx
	test	eax, eax
	cmovg	edx, eax

; 273  :             max_vert_extent = support_max[n].y;
; 274  :           if (max_vert_extent < -support_min[n].y)

	mov	eax, DWORD PTR [ebx]
	neg	eax
	cmp	edx, eax
	cmovl	edx, eax
	mov	eax, DWORD PTR [esi+64]
	cmp	edx, DWORD PTR [esi+80]
	cmovl	edx, DWORD PTR [esi+80]
	neg	eax
	cmp	edx, eax
	cmovl	edx, eax
$LN54@init:

; 275  :             max_vert_extent = -support_min[n].y;
; 276  :         }
; 277  :     }
; 278  : 
; 279  :   // Create the buffer.
; 280  :   num_row_buffers = 1+2*max_vert_extent;

	lea	eax, DWORD PTR [edx*2+1]

; 281  :   row_buffers = new kdu_byte *[num_row_buffers];

	xor	ecx, ecx
	mov	DWORD PTR [esi+92], eax
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 282  :   for (n=0; n < num_row_buffers; n++)

	xor	ecx, ecx
	mov	DWORD PTR [esi+100], eax
	add	esp, 4
	cmp	DWORD PTR [esi+92], ecx
	jle	SHORT $LN9@init
	npad	5
$LL10@init:

; 283  :     row_buffers[n] = NULL; // In case memory allocation fails later.

	mov	eax, DWORD PTR [esi+100]
	mov	DWORD PTR [eax+ecx*4], 0
	inc	ecx
	cmp	ecx, DWORD PTR [esi+92]
	jl	SHORT $LL10@init
$LN9@init:

; 284  :   for (n=0; n < num_row_buffers; n++)

	xor	edi, edi
	cmp	DWORD PTR [esi+92], edi
	jle	SHORT $LN12@init
$LL13@init:

; 285  :     row_buffers[n] = new kdu_byte[dims.size.x];

	push	DWORD PTR [esi+40]
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR [esi+100]
	add	esp, 4
	mov	DWORD PTR [ecx+edi*4], eax
	inc	edi
	cmp	edi, DWORD PTR [esi+92]
	jl	SHORT $LL13@init
$LN12@init:

; 286  :   out_buf = new kdu_byte[dims.size.x];

	push	DWORD PTR [esi+40]
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+104], eax

; 287  : 
; 288  :   // Initialize state variables
; 289  :   first_buffer_idx = 0;
; 290  :   num_valid_rows = 0;
; 291  :   first_valid_row_loc = dims.pos.y;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+52], 0
	pop	edi
	mov	DWORD PTR [esi+48], eax

; 292  :   next_row_loc = dims.pos.y;

	mov	DWORD PTR [esi+44], eax
	pop	esi
	pop	ebx

; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?init@kd_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z ENDP ; kd_roi_level::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
;	COMDAT ??1kd_roi_level@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_roi_level@@QAE@XZ PROC				; kd_roi_level::~kd_roi_level, COMDAT
; _this$ = ecx

; 211  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_roi_level@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 212  :   for (int b=0; b < 4; b++)

	lea	esi, DWORD PTR [edi+4]
	mov	ebx, 4
	npad	1
$LL4@kd_roi_lev:

; 213  :     if (nodes[b] != NULL)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@kd_roi_lev

; 214  :       delete nodes[b];

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN2@kd_roi_lev:

; 212  :   for (int b=0; b < 4; b++)

	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL4@kd_roi_lev

; 215  :   if (row_buffers != NULL)

	cmp	DWORD PTR [edi+100], ebx
	je	SHORT $LN9@kd_roi_lev

; 216  :     {
; 217  :       for (int n=0; n < num_row_buffers; n++)

	xor	esi, esi
	cmp	DWORD PTR [edi+92], esi
	jle	SHORT $LN6@kd_roi_lev
$LL7@kd_roi_lev:

; 218  :         if (row_buffers[n] != NULL)

	mov	eax, DWORD PTR [edi+100]
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, eax
	je	SHORT $LN5@kd_roi_lev

; 219  :           delete[] row_buffers[n];

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@kd_roi_lev:

; 216  :     {
; 217  :       for (int n=0; n < num_row_buffers; n++)

	inc	esi
	cmp	esi, DWORD PTR [edi+92]
	jl	SHORT $LL7@kd_roi_lev
$LN6@kd_roi_lev:

; 220  :       delete[] row_buffers;

	push	DWORD PTR [edi+100]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN9@kd_roi_lev:

; 221  :     }
; 222  :   if (out_buf != NULL)

	mov	eax, DWORD PTR [edi+104]
	test	eax, eax
	je	SHORT $LN11@kd_roi_lev

; 223  :     delete[] out_buf;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN11@kd_roi_lev:

; 224  :   if (source != NULL)

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN12@kd_roi_lev

; 225  :     source->release();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN12@kd_roi_lev:

; 226  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kd_roi_level@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_roi_level@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_roi_level@@QAE@XZ ENDP				; kd_roi_level::~kd_roi_level
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi_local.h
;	COMDAT ??0kd_roi_level@@QAE@XZ
_TEXT	SEGMENT
??0kd_roi_level@@QAE@XZ PROC				; kd_roi_level::kd_roi_level, COMDAT
; _this$ = ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+28], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi_local.h

; 126  :         num_row_buffers = 0; row_buffers = NULL; out_buf = NULL; }

	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+64], 0
	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+72], 0
	mov	DWORD PTR [ecx+76], 0
	mov	DWORD PTR [ecx+80], 0
	mov	DWORD PTR [ecx+84], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi_local.h

; 125  :       { source = NULL; nodes[0]=nodes[1]=nodes[2]=nodes[3]=NULL;

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+4], 0

; 126  :         num_row_buffers = 0; row_buffers = NULL; out_buf = NULL; }

	mov	DWORD PTR [ecx+92], 0
	mov	DWORD PTR [ecx+100], 0
	mov	DWORD PTR [ecx+104], 0
	ret	0
??0kd_roi_level@@QAE@XZ ENDP				; kd_roi_level::kd_roi_level
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_roi_level_node@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_roi_level_node@@UAEPAXI@Z PROC			; kd_roi_level_node::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_roi_level_node@@UAE@XZ		; kd_roi_level_node::~kd_roi_level_node
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	36					; 00000024H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_roi_level_node@@UAEPAXI@Z ENDP			; kd_roi_level_node::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
;	COMDAT ?release@kd_roi_level_node@@UAEXXZ
_TEXT	SEGMENT
?release@kd_roi_level_node@@UAEXXZ PROC			; kd_roi_level_node::release, COMDAT
; _this$ = ecx

; 148  :   available = active = false;

	mov	WORD PTR [ecx+8], 0

; 149  :   owner->notify_release(this);

	push	ecx
	mov	ecx, DWORD PTR [ecx+4]
	call	?notify_release@kd_roi_level@@QAEXPAVkd_roi_level_node@@@Z ; kd_roi_level::notify_release

; 150  : }

	ret	0
?release@kd_roi_level_node@@UAEXXZ ENDP			; kd_roi_level_node::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi_local.h
;	COMDAT ?acquire@kd_roi_level_node@@QAEXXZ
_TEXT	SEGMENT
?acquire@kd_roi_level_node@@QAEXXZ PROC			; kd_roi_level_node::acquire, COMDAT
; _this$ = ecx

; 84   :       { assert(available); available = false; active = true; }

	mov	WORD PTR [ecx+8], 256			; 00000100H
	ret	0
?acquire@kd_roi_level_node@@QAEXXZ ENDP			; kd_roi_level_node::acquire
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
;	COMDAT ?advance@kd_roi_level_node@@QAEPAEXZ
_TEXT	SEGMENT
tv236 = -12						; size = 4
_new_buffers$1$ = -8					; size = 4
_n$1$ = -4						; size = 4
?advance@kd_roi_level_node@@QAEPAEXZ PROC		; kd_roi_level_node::advance, COMDAT
; _this$ = ecx

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	edi
	mov	edi, ecx

; 103  :   if (!active)

	cmp	BYTE PTR [edi+9], 0
	jne	SHORT $LN8@advance

; 104  :     {
; 105  :       available = false; // If not already acquired, client missed its chance.

	mov	BYTE PTR [edi+8], 0

; 106  :       return NULL;

	xor	eax, eax
	pop	edi

; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@advance:

; 107  :     }
; 108  :   assert(remaining_rows > num_valid_row_buffers);
; 109  :   if (num_valid_row_buffers == num_row_buffers)

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR tv236[ebp], eax
	cmp	DWORD PTR [edi+28], eax
	jne	$LN6@advance

; 110  :     { // Need to augment buffer.
; 111  :       int n, r1, r2, num_new_buffers = num_row_buffers + 2;

	push	ebx
	lea	ebx, DWORD PTR [eax+2]

; 112  :       kdu_byte **new_buffers = new kdu_byte *[num_new_buffers];

	xor	ecx, ecx
	mov	eax, ebx
	mov	edx, 4
	mul	edx
	push	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 113  :       memset(new_buffers,0,sizeof(kdu_byte *)*(size_t)num_new_buffers);

	lea	ecx, DWORD PTR [ebx*4]
	mov	DWORD PTR _new_buffers$1$[ebp], eax
	push	ecx
	push	0
	push	eax
	call	_memset

; 114  :       r1 = r2 = first_valid_row_buffer;

	mov	esi, DWORD PTR [edi+24]

; 115  :       for (n=0; n < num_row_buffers; n++, r1++, r2++)

	xor	edx, edx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _n$1$[ebp], edx
	mov	ecx, esi
	cmp	DWORD PTR [edi+20], edx
	jle	SHORT $LN3@advance
	npad	5
$LL4@advance:

; 116  :         {
; 117  :           if (r1 == num_row_buffers)
; 118  :             r1 = 0;
; 119  :           if (r2 == num_new_buffers)
; 120  :             r2 = 0;
; 121  :           new_buffers[r2] = row_buffers[r1];

	mov	edx, DWORD PTR _new_buffers$1$[ebp]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edi+20]
	cmove	ecx, eax
	cmp	esi, ebx
	cmove	esi, eax
	mov	eax, DWORD PTR [edi+32]
	mov	eax, DWORD PTR [eax+ecx*4]
	inc	ecx
	mov	DWORD PTR [edx+esi*4], eax
	inc	esi
	mov	edx, DWORD PTR _n$1$[ebp]
	inc	edx
	mov	DWORD PTR _n$1$[ebp], edx
	cmp	edx, DWORD PTR [edi+20]
	jl	SHORT $LL4@advance
$LN3@advance:

; 122  :         }
; 123  :       if (row_buffers == NULL)

	cmp	DWORD PTR [edi+32], 0
	jne	SHORT $LN12@advance

; 124  :         delete[] row_buffers;

	push	0
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	edx, DWORD PTR _n$1$[ebp]
	add	esp, 4
$LN12@advance:

; 125  :       row_buffers = new_buffers;

	mov	eax, DWORD PTR _new_buffers$1$[ebp]
	mov	DWORD PTR [edi+32], eax

; 126  :       num_row_buffers = num_new_buffers;

	mov	DWORD PTR [edi+20], ebx

; 127  :       for (; n < num_new_buffers; n++, r2++)

	cmp	edx, ebx
	jge	SHORT $LN24@advance

; 125  :       row_buffers = new_buffers;

	sub	ebx, edx
	npad	7
$LL7@advance:

; 128  :         {
; 129  :           if (r2 == num_new_buffers)

	mov	eax, DWORD PTR tv236[ebp]
	xor	edx, edx

; 130  :             r2 = 0;
; 131  :           new_buffers[r2] = new kdu_byte[cols];

	push	DWORD PTR [edi+12]
	add	eax, 2
	cmp	esi, eax
	cmove	esi, edx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR _new_buffers$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [ecx+esi*4], eax
	inc	esi
	sub	ebx, 1
	jne	SHORT $LL7@advance
$LN24@advance:
	pop	esi
	pop	ebx
$LN6@advance:

; 132  :         }
; 133  :     }
; 134  :   int r = num_valid_row_buffers + first_valid_row_buffer;

	mov	edx, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edi+28]
	add	edx, ecx

; 135  :   if (r >= num_row_buffers)

	mov	eax, DWORD PTR [edi+20]
	cmp	edx, eax
	jl	SHORT $LN14@advance

; 136  :     r -= num_row_buffers;

	sub	edx, eax
$LN14@advance:

; 137  :   num_valid_row_buffers++;
; 138  :   return row_buffers[r];

	mov	eax, DWORD PTR [edi+32]
	inc	ecx
	mov	DWORD PTR [edi+28], ecx
	pop	edi
	mov	eax, DWORD PTR [eax+edx*4]

; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?advance@kd_roi_level_node@@QAEPAEXZ ENDP		; kd_roi_level_node::advance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
;	COMDAT ?pull@kd_roi_level_node@@UAEXQAEH@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_width$ = 12						; size = 4
?pull@kd_roi_level_node@@UAEXQAEH@Z PROC		; kd_roi_level_node::pull, COMDAT
; _this$ = ecx

; 84   : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 85   :   assert(active && (width == cols) && (remaining_rows > 0));
; 86   :   while (num_valid_row_buffers == 0)

	cmp	DWORD PTR [esi+28], 0
	jne	SHORT $LN3@pull
	npad	4
$LL2@pull:

; 87   :     owner->advance();

	mov	ecx, DWORD PTR [esi+4]
	call	?advance@kd_roi_level@@QAEXXZ		; kd_roi_level::advance
	cmp	DWORD PTR [esi+28], 0
	je	SHORT $LL2@pull
$LN3@pull:

; 88   :   memcpy(buf,row_buffers[first_valid_row_buffer],(size_t) width);

	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+32]
	push	DWORD PTR _width$[ebp]
	push	DWORD PTR [eax+ecx*4]
	push	DWORD PTR _buf$[ebp]
	call	_memcpy

; 89   :   num_valid_row_buffers--;
; 90   :   first_valid_row_buffer++;

	inc	DWORD PTR [esi+24]
	add	esp, 12					; 0000000cH
	dec	DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi+24]

; 93   :   remaining_rows--;

	dec	DWORD PTR [esi+16]
	cmp	eax, DWORD PTR [esi+20]
	jne	SHORT $LN4@pull

; 91   :   if (first_valid_row_buffer == num_row_buffers)
; 92   :     first_valid_row_buffer = 0;

	mov	DWORD PTR [esi+24], 0
$LN4@pull:
	pop	esi

; 94   : }

	pop	ebp
	ret	8
?pull@kd_roi_level_node@@UAEXQAEH@Z ENDP		; kd_roi_level_node::pull
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_roi_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
;	COMDAT ??1kd_roi_level_node@@UAE@XZ
_TEXT	SEGMENT
??1kd_roi_level_node@@UAE@XZ PROC			; kd_roi_level_node::~kd_roi_level_node, COMDAT
; _this$ = ecx

; 69   : {

	push	esi
	mov	esi, ecx

; 70   :   assert(!active); // Insist on acquired objects being released first.
; 71   :   if (row_buffers == NULL)

	cmp	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7kd_roi_level_node@@6B@
	je	SHORT $LN14@kd_roi_lev

; 72   :     return;
; 73   :   for (int n=0; n < num_row_buffers; n++)

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+20], edi
	jle	SHORT $LN3@kd_roi_lev
	npad	9
$LL4@kd_roi_lev:

; 74   :     delete[] row_buffers[n];

	mov	eax, DWORD PTR [esi+32]
	push	DWORD PTR [eax+edi*4]
	call	??_V@YAXPAX@Z				; operator delete[]
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR [esi+20]
	jl	SHORT $LL4@kd_roi_lev
$LN3@kd_roi_lev:

; 75   :   delete[] row_buffers;

	push	DWORD PTR [esi+32]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	edi
$LN14@kd_roi_lev:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_roi_processing.h

; 80   :     virtual ~kdu_roi_node() { return; } // Prevent compiler warnings

	mov	DWORD PTR [esi], OFFSET ??_7kdu_roi_node@@6B@
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp

; 76   : }

	ret	0
??1kd_roi_level_node@@UAE@XZ ENDP			; kd_roi_level_node::~kd_roi_level_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi_local.h
;	COMDAT ??0kd_roi_level_node@@QAE@PAVkd_roi_level@@Ukdu_coords@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_owner$ = 8						; size = 4
_size$ = 12						; size = 8
??0kd_roi_level_node@@QAE@PAVkd_roi_level@@Ukdu_coords@@@Z PROC ; kd_roi_level_node::kd_roi_level_node, COMDAT
; _this$ = ecx

; 66   :     kd_roi_level_node(kd_roi_level *owner, kdu_coords size)

	push	ebp
	mov	ebp, esp
	push	ecx

; 67   :       {
; 68   :         this->owner = owner; available = true; active = false;

	mov	eax, DWORD PTR _owner$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 69   :         cols = size.x; remaining_rows = size.y;

	mov	eax, DWORD PTR _size$[ebp+4]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 70   :         num_row_buffers = first_valid_row_buffer = num_valid_row_buffers = 0;
; 71   :         row_buffers = NULL;
; 72   :       }

	mov	eax, ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kd_roi_level_node@@6B@
	mov	WORD PTR [ecx+8], 1
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+32], 0
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0kd_roi_level_node@@QAE@PAVkd_roi_level@@Ukdu_coords@@@Z ENDP ; kd_roi_level_node::kd_roi_level_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
;	COMDAT ?acquire_node@kdu_roi_level@@QAEPAVkdu_roi_node@@H@Z
_TEXT	SEGMENT
_child_idx$ = 8						; size = 4
?acquire_node@kdu_roi_level@@QAEPAVkdu_roi_node@@H@Z PROC ; kdu_roi_level::acquire_node, COMDAT
; _this$ = ecx

; 193  : {

	push	ebp
	mov	ebp, esp

; 194  :   assert((child_idx >= 0) && (child_idx < 4));
; 195  :   kd_roi_level_node *result = state->nodes[child_idx];

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _child_idx$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+4]

; 196  :   if (result != NULL)

	test	eax, eax
	je	SHORT $LN2@acquire_no
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi_local.h

; 84   :       { assert(available); available = false; active = true; }

	mov	WORD PTR [eax+8], 256			; 00000100H
$LN2@acquire_no:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp

; 199  : }

	pop	ebp
	ret	4
?acquire_node@kdu_roi_level@@QAEPAVkdu_roi_node@@H@Z ENDP ; kdu_roi_level::acquire_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
;	COMDAT ?destroy@kdu_roi_level@@QAEXXZ
_TEXT	SEGMENT
?destroy@kdu_roi_level@@QAEXXZ PROC			; kdu_roi_level::destroy, COMDAT
; _this$ = ecx

; 181  : {

	push	esi
	mov	esi, ecx
	push	edi

; 182  :   if (state != NULL)

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN10@destroy
	mov	ecx, edi
	call	??1kd_roi_level@@QAE@XZ			; kd_roi_level::~kd_roi_level
	push	108					; 0000006cH
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@destroy:
	pop	edi

; 183  :     delete state;
; 184  :   state = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 185  : }

	ret	0
?destroy@kdu_roi_level@@QAEXXZ ENDP			; kdu_roi_level::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
;	COMDAT ?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z
_TEXT	SEGMENT
$T2 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_node$ = 8						; size = 4
_source$ = 12						; size = 4
?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z PROC ; kdu_roi_level::create, COMDAT
; _this$ = ecx

; 163  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 164  :   state = new kd_roi_level();

	push	108					; 0000006cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	test	eax, eax
	je	SHORT $LN4@create
	mov	ecx, eax
	call	??0kd_roi_level@@QAE@XZ			; kd_roi_level::kd_roi_level
	jmp	SHORT $LN5@create
$LN4@create:
	xor	eax, eax
$LN5@create:

; 165  :   try {
; 166  :     state->init(node,source);

	push	DWORD PTR _source$[ebp]
	mov	ecx, eax
	mov	DWORD PTR [esi], eax
	push	DWORD PTR _node$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?init@kd_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z ; kd_roi_level::init

; 172  :     }
; 173  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z$0:

; 167  :     }
; 168  :   catch(...) {
; 169  :       delete state;

	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN14@create
	mov	ecx, esi
	call	??1kd_roi_level@@QAE@XZ			; kd_roi_level::~kd_roi_level
	push	108					; 0000006cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN14@create:

; 170  :       state = NULL;
; 171  :       throw; // Rethrow the exception to be handled higher up the stack frame.

	push	0
	push	0
	mov	DWORD PTR [edi], 0
	call	__CxxThrowException@8
$LN19@create:
$LN18@create:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z ENDP ; kdu_roi_level::create
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_roi_processing.h
;	COMDAT ??_Gkdu_roi_node@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkdu_roi_node@@UAEPAXI@Z PROC			; kdu_roi_node::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 80   :     virtual ~kdu_roi_node() { return; } // Prevent compiler warnings

	mov	DWORD PTR [esi], OFFSET ??_7kdu_roi_node@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkdu_roi_node@@UAEPAXI@Z ENDP			; kdu_roi_node::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0kdu_roi_node@@QAE@XZ
_TEXT	SEGMENT
??0kdu_roi_node@@QAE@XZ PROC				; kdu_roi_node::kdu_roi_node, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kdu_roi_node@@6B@
	mov	eax, ecx
	ret	0
??0kdu_roi_node@@QAE@XZ ENDP				; kdu_roi_node::kdu_roi_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_roi_processing.h
;	COMDAT ?release@kdu_roi_node@@UAEXXZ
_TEXT	SEGMENT
?release@kdu_roi_node@@UAEXXZ PROC			; kdu_roi_node::release, COMDAT
; _this$ = ecx

; 81   :     virtual void release() { return; }

	ret	0
?release@kdu_roi_node@@UAEXXZ ENDP			; kdu_roi_node::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_roi_processing.h
;	COMDAT ??1kdu_roi_node@@UAE@XZ
_TEXT	SEGMENT
??1kdu_roi_node@@UAE@XZ PROC				; kdu_roi_node::~kdu_roi_node, COMDAT
; _this$ = ecx

; 80   :     virtual ~kdu_roi_node() { return; } // Prevent compiler warnings

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_roi_node@@6B@
	ret	0
??1kdu_roi_node@@UAE@XZ ENDP				; kdu_roi_node::~kdu_roi_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??7kdu_node@@QAE_NXZ
_TEXT	SEGMENT
??7kdu_node@@QAE_NXZ PROC				; kdu_node::operator!, COMDAT
; _this$ = ecx

; 4994 :     bool operator!() { return (state==NULL)?true:false; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
??7kdu_node@@QAE_NXZ ENDP				; kdu_node::operator!
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_dims@@QAE@XZ
_TEXT	SEGMENT
??0kdu_dims@@QAE@XZ PROC				; kdu_dims::kdu_dims, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0

; 304  :     kdu_dims() {};

	mov	eax, ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0

; 304  :     kdu_dims() {};

	ret	0
??0kdu_dims@@QAE@XZ ENDP				; kdu_dims::kdu_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??Hkdu_coords@@QAE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??Hkdu_coords@@QAE?AU0@ABU0@@Z PROC			; kdu_coords::operator+, COMDAT
; _this$ = ecx

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	esi
	mov	esi, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [esi+4]
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	pop	esi
	pop	ebp
	ret	8
??Hkdu_coords@@QAE?AU0@ABU0@@Z ENDP			; kdu_coords::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_coords@@QAE@XZ
_TEXT	SEGMENT
??0kdu_coords@@QAE@XZ PROC				; kdu_coords::kdu_coords, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kdu_coords@@QAE@XZ ENDP				; kdu_coords::kdu_coords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\roi\roi.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
