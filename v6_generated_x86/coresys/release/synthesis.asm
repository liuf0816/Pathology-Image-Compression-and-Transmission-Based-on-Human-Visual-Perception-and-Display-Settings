; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\transform\synthesis.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	??0kdu_line_buf@@QAE@XZ				; kdu_line_buf::kdu_line_buf
PUBLIC	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create
PUBLIC	?create@kdu_line_buf@@QAEXXZ			; kdu_line_buf::create
PUBLIC	??1kdu_pull_ifc_base@@MAE@XZ			; kdu_pull_ifc_base::~kdu_pull_ifc_base
PUBLIC	??_Gkdu_pull_ifc_base@@MAEPAXI@Z		; kdu_pull_ifc_base::`scalar deleting destructor'
PUBLIC	??0kdu_pull_ifc@@QAE@XZ				; kdu_pull_ifc::kdu_pull_ifc
PUBLIC	??0kdu_synthesis@@QAE@Vkdu_node@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_synthesis::kdu_synthesis
PUBLIC	??0kdu_synthesis@@QAE@Vkdu_resolution@@PAVkdu_sample_allocator@@_NMPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_synthesis::kdu_synthesis
PUBLIC	??0kd_vlift_line@@QAE@XZ			; kd_vlift_line::kd_vlift_line
PUBLIC	?push_line@kd_vlift_queue@@QAEXHPAUkd_vlift_line@@AAPAU2@@Z ; kd_vlift_queue::push_line
PUBLIC	?access_update@kd_vlift_queue@@QAEPAUkd_vlift_line@@HAAPAU2@@Z ; kd_vlift_queue::access_update
PUBLIC	?access_source@kd_vlift_queue@@QAE_NHHQAPAUkd_vlift_line@@AAPAU2@@Z ; kd_vlift_queue::access_source
PUBLIC	?simulate_access_source@kd_vlift_queue@@QAE_NHHAAH@Z ; kd_vlift_queue::simulate_access_source
PUBLIC	?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z ; perform_synthesis_lifting_step
PUBLIC	?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z ; perform_synthesis_lifting_step
PUBLIC	??0kd_synthesis@@QAE@XZ				; kd_synthesis::kd_synthesis
PUBLIC	?init@kd_synthesis@@QAEXVkdu_node@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kd_synthesis::init
PUBLIC	??1kd_synthesis@@MAE@XZ				; kd_synthesis::~kd_synthesis
PUBLIC	?start@kd_synthesis@@MAEXPAVkdu_thread_env@@@Z	; kd_synthesis::start
PUBLIC	?pull@kd_synthesis@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z ; kd_synthesis::pull
PUBLIC	?simulate_vertical_lifting@kd_synthesis@@IAEHH@Z ; kd_synthesis::simulate_vertical_lifting
PUBLIC	?horizontal_synthesis@kd_synthesis@@IAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z ; kd_synthesis::horizontal_synthesis
PUBLIC	??_Gkd_synthesis@@MAEPAXI@Z			; kd_synthesis::`scalar deleting destructor'
PUBLIC	__TI1H
PUBLIC	__CTA1H
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
PUBLIC	__CT??_R0H@84
PUBLIC	??_7kdu_pull_ifc_base@@6B@			; kdu_pull_ifc_base::`vftable'
PUBLIC	??_7kd_synthesis@@6B@				; kd_synthesis::`vftable'
PUBLIC	??_R4kdu_pull_ifc_base@@6B@			; kdu_pull_ifc_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_pull_ifc_base@@@8			; kdu_pull_ifc_base `RTTI Type Descriptor'
PUBLIC	??_R3kdu_pull_ifc_base@@8			; kdu_pull_ifc_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_pull_ifc_base@@8			; kdu_pull_ifc_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_pull_ifc_base@@8		; kdu_pull_ifc_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_synthesis@@6B@				; kd_synthesis::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_synthesis@@@8			; kd_synthesis `RTTI Type Descriptor'
PUBLIC	??_R3kd_synthesis@@8				; kd_synthesis::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_synthesis@@8				; kd_synthesis::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_synthesis@@8			; kd_synthesis::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	___isa_available_default
PUBLIC	__real@3ecccccd
PUBLIC	__real@3eff7cee
PUBLIC	__real@3f000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ffa09bdc981b97a
PUBLIC	__real@3ffb5477208894d9
PUBLIC	__real@4000000000000000
PUBLIC	__real@401e666666666666
PUBLIC	__real@40da7ce680000000
PUBLIC	__real@40dc628aa0000000
PUBLIC	__real@c00e297d9a2f0174
PUBLIC	__real@c0bdf90a00000000
PUBLIC	__real@c0db2015c0000000
PUBLIC	__xmm@3f0000003f0000003f0000003f000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	?access_node@kdu_resolution@@QAE?AVkdu_node@@XZ:PROC ; kdu_resolution::access_node
EXTRN	?get_reversible@kdu_resolution@@QAE_NXZ:PROC	; kdu_resolution::get_reversible
EXTRN	?access_child@kdu_node@@QAE?AV1@H@Z:PROC	; kdu_node::access_child
EXTRN	?access_subband@kdu_node@@QAE?AVkdu_subband@@XZ:PROC ; kdu_node::access_subband
EXTRN	?access_resolution@kdu_node@@QAE?AVkdu_resolution@@XZ:PROC ; kdu_node::access_resolution
EXTRN	?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z:PROC	; kdu_node::get_dims
EXTRN	?get_kernel_id@kdu_node@@QAEHXZ:PROC		; kdu_node::get_kernel_id
EXTRN	?get_kernel_info@kdu_node@@QAEPBUkdu_kernel_step_info@@AAHAAM1AA_N20000_N@Z:PROC ; kdu_node::get_kernel_info
EXTRN	?get_kernel_coefficients@kdu_node@@QAEPBM_N@Z:PROC ; kdu_node::get_kernel_coefficients
EXTRN	?get_bibo_gains@kdu_node@@QAEPBMAAH_N@Z:PROC	; kdu_node::get_bibo_gains
EXTRN	??_Ekdu_pull_ifc_base@@MAEPAXI@Z:PROC		; kdu_pull_ifc_base::`vector deleting destructor'
EXTRN	??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z:PROC ; kdu_decoder::kdu_decoder
EXTRN	??_Ekd_synthesis@@MAEPAXI@Z:PROC		; kd_synthesis::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_floor:PROC
EXTRN	_memcpy:PROC
EXTRN	?kdu_mmx_level@@3HA:DWORD			; kdu_mmx_level
EXTRN	?kdu_sparcvis_exists@@3_NA:BYTE			; kdu_sparcvis_exists
EXTRN	?kdu_altivec_exists@@3_NA:BYTE			; kdu_altivec_exists
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___isa_available:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?simd_w97_rem@@3PAFA DW 04H DUP (?)			; simd_w97_rem
?simd_w97_preoff@@3PAFA DW 04H DUP (?)			; simd_w97_preoff
_BSS	ENDS
;	COMDAT ___isa_available_default
_BSS	SEGMENT
___isa_available_default DD 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
?simd_w97_rem$initializer$@@3P6AXXZA DD FLAT:??__Esimd_w97_rem@@YAXXZ ; simd_w97_rem$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@3f0000003f0000003f0000003f000000
CONST	SEGMENT
__xmm@3f0000003f0000003f0000003f000000 DB 00H, 00H, 00H, '?', 00H, 00H, 00H
	DB	'?', 00H, 00H, 00H, '?', 00H, 00H, 00H, '?'
CONST	ENDS
;	COMDAT __real@c0db2015c0000000
CONST	SEGMENT
__real@c0db2015c0000000 DQ 0c0db2015c0000000r	; -27776.3
CONST	ENDS
;	COMDAT __real@c0bdf90a00000000
CONST	SEGMENT
__real@c0bdf90a00000000 DQ 0c0bdf90a00000000r	; -7673.04
CONST	ENDS
;	COMDAT __real@c00e297d9a2f0174
CONST	SEGMENT
__real@c00e297d9a2f0174 DQ 0c00e297d9a2f0174r	; -3.77026
CONST	ENDS
;	COMDAT __real@40dc628aa0000000
CONST	SEGMENT
__real@40dc628aa0000000 DQ 040dc628aa0000000r	; 29066.2
CONST	ENDS
;	COMDAT __real@40da7ce680000000
CONST	SEGMENT
__real@40da7ce680000000 DQ 040da7ce680000000r	; 27123.6
CONST	ENDS
;	COMDAT __real@401e666666666666
CONST	SEGMENT
__real@401e666666666666 DQ 0401e666666666666r	; 7.6
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ffb5477208894d9
CONST	SEGMENT
__real@3ffb5477208894d9 DQ 03ffb5477208894d9r	; 1.70812
CONST	ENDS
;	COMDAT __real@3ffa09bdc981b97a
CONST	SEGMENT
__real@3ffa09bdc981b97a DQ 03ffa09bdc981b97ar	; 1.62738
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3eff7cee
CONST	SEGMENT
__real@3eff7cee DD 03eff7ceer			; 0.499
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_synthesis@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_synthesis@@8 DD FLAT:??_R0?AVkd_synthesis@@@8 ; kd_synthesis::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_synthesis@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_synthesis@@8
rdata$r	SEGMENT
??_R2kd_synthesis@@8 DD FLAT:??_R1A@?0A@EA@kd_synthesis@@8 ; kd_synthesis::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_pull_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_synthesis@@8
rdata$r	SEGMENT
??_R3kd_synthesis@@8 DD 00H				; kd_synthesis::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_synthesis@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_synthesis@@@8
data$r	SEGMENT
??_R0?AVkd_synthesis@@@8 DD FLAT:??_7type_info@@6B@	; kd_synthesis `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_synthesis@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_synthesis@@6B@
rdata$r	SEGMENT
??_R4kd_synthesis@@6B@ DD 00H				; kd_synthesis::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_synthesis@@@8
	DD	FLAT:??_R3kd_synthesis@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_pull_ifc_base@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_pull_ifc_base@@8 DD FLAT:??_R0?AVkdu_pull_ifc_base@@@8 ; kdu_pull_ifc_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_pull_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_pull_ifc_base@@8
rdata$r	SEGMENT
??_R2kdu_pull_ifc_base@@8 DD FLAT:??_R1A@?0A@EA@kdu_pull_ifc_base@@8 ; kdu_pull_ifc_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_pull_ifc_base@@8
rdata$r	SEGMENT
??_R3kdu_pull_ifc_base@@8 DD 00H			; kdu_pull_ifc_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_pull_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_pull_ifc_base@@@8
data$r	SEGMENT
??_R0?AVkdu_pull_ifc_base@@@8 DD FLAT:??_7type_info@@6B@ ; kdu_pull_ifc_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_pull_ifc_base@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_pull_ifc_base@@6B@
rdata$r	SEGMENT
??_R4kdu_pull_ifc_base@@6B@ DD 00H			; kdu_pull_ifc_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_pull_ifc_base@@@8
	DD	FLAT:??_R3kdu_pull_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_7kd_synthesis@@6B@
CONST	SEGMENT
??_7kd_synthesis@@6B@ DD FLAT:??_R4kd_synthesis@@6B@	; kd_synthesis::`vftable'
	DD	FLAT:??_Ekd_synthesis@@MAEPAXI@Z
	DD	FLAT:?start@kd_synthesis@@MAEXPAVkdu_thread_env@@@Z
	DD	FLAT:?pull@kd_synthesis@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z
CONST	ENDS
;	COMDAT ??_7kdu_pull_ifc_base@@6B@
CONST	SEGMENT
??_7kdu_pull_ifc_base@@6B@ DD FLAT:??_R4kdu_pull_ifc_base@@6B@ ; kdu_pull_ifc_base::`vftable'
	DD	FLAT:??_Ekdu_pull_ifc_base@@MAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0H@8
data$r	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
data$r	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
CRT$XCU	SEGMENT
?simd_w97_preoff$initializer$@@3P6AXXZA DD FLAT:??__Esimd_w97_preoff@@YAXXZ ; simd_w97_preoff$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_interleave@@YA_NPAH00H@Z
_TEXT	SEGMENT
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_dst$ = 16						; size = 4
_pairs$ = 20						; size = 4
?simd_interleave@@YA_NPAH00H@Z PROC			; simd_interleave, COMDAT

; 2175 : {

	push	ebp
	mov	ebp, esp

; 2176 : #ifndef KDU_NO_SSE
; 2177 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	jge	SHORT $LN2@simd_inter
$LN5@simd_inter:

; 2178 :     return false;

	xor	al, al

; 2224 : #endif // !KDU_NO_SSE
; 2225 :   return false;
; 2226 : }

	pop	ebp
	ret	0
$LN2@simd_inter:

; 2179 :   if (pairs <= 8)

	cmp	DWORD PTR _pairs$[ebp], 8
	jle	SHORT $LN5@simd_inter

; 2180 :     return false;
; 2181 : 
; 2182 :   __asm {

	push	ebx

; 2183 :       MOV ECX,pairs      // Set up counter used for looping

	mov	ecx, DWORD PTR _pairs$[ebp]

; 2184 :       MOV EAX,src1

	mov	eax, DWORD PTR _src1$[ebp]

; 2185 :       MOV EBX,src2

	mov	ebx, DWORD PTR _src2$[ebp]

; 2186 :       MOV EDX,dst

	mov	edx, DWORD PTR _dst$[ebp]

; 2187 : 
; 2188 :       // If we get here, we can use the implementation based on 128-bit
; 2189 :       // operands, using SSE/SSE2 instructions
; 2190 :       SUB ECX,2 // Halts full dqword processing when 2 or less pairs remain

	sub	ecx, 2

; 2191 :       TEST EAX,8 // See if source address is 16-byte aligned

	test	eax, 8

; 2192 :       JZ loop_full  // If not, source words must be 8-byte aligned

	je	SHORT $loop_full$7

; 2193 :         MOVDQA XMM0,[EAX-8]

	movdqa	xmm0, XMMWORD PTR [eax-8]

; 2194 :         MOVDQA XMM1,[EBX-8]

	movdqa	xmm1, XMMWORD PTR [ebx-8]

; 2195 :         PUNPCKHDQ XMM0,XMM1

	punpckhdq xmm0, xmm1

; 2196 :         MOVDQA [EDX],XMM0

	movdqa	XMMWORD PTR [edx], xmm0

; 2197 :         ADD EAX,8

	add	eax, 8

; 2198 :         ADD EBX,8

	add	ebx, 8

; 2199 :         ADD EDX,16

	add	edx, 16					; 00000010H

; 2200 :         SUB ECX,2

	sub	ecx, 2
$loop_full$7:

; 2201 : loop_full:
; 2202 :       MOVDQA XMM0,[EAX]

	movdqa	xmm0, XMMWORD PTR [eax]

; 2203 :       MOVDQA XMM2,XMM0

	movdqa	xmm2, xmm0

; 2204 :       MOVDQA XMM1,[EBX]

	movdqa	xmm1, XMMWORD PTR [ebx]

; 2205 :       PUNPCKLDQ XMM2,XMM1

	punpckldq xmm2, xmm1

; 2206 :       MOVDQA [EDX],XMM2

	movdqa	XMMWORD PTR [edx], xmm2

; 2207 :       PUNPCKHDQ XMM0,XMM1

	punpckhdq xmm0, xmm1

; 2208 :       MOVDQA [EDX+16],XMM0

	movdqa	XMMWORD PTR [edx+16], xmm0

; 2209 :       ADD EAX,16

	add	eax, 16					; 00000010H

; 2210 :       ADD EBX,16

	add	ebx, 16					; 00000010H

; 2211 :       ADD EDX,32

	add	edx, 32					; 00000020H

; 2212 :       SUB ECX,4

	sub	ecx, 4

; 2213 :       JG loop_full

	jg	SHORT $loop_full$7

; 2214 :       ADD ECX,2

	add	ecx, 2

; 2215 :       TEST ECX, ECX

	test	ecx, ecx

; 2216 :       JLE done

	jle	SHORT $done$8

; 2217 :       MOVDQA XMM0,[EAX]

	movdqa	xmm0, XMMWORD PTR [eax]

; 2218 :       MOVDQA XMM1,[EBX]

	movdqa	xmm1, XMMWORD PTR [ebx]

; 2219 :       PUNPCKLDQ XMM0,XMM1

	punpckldq xmm0, xmm1

; 2220 :       MOVDQA [EDX],XMM0

	movdqa	XMMWORD PTR [edx], xmm0
$done$8:

; 2221 : done:
; 2222 :     }
; 2223 :   return true;

	mov	al, 1
	pop	ebx

; 2224 : #endif // !KDU_NO_SSE
; 2225 :   return false;
; 2226 : }

	pop	ebp
	ret	0
?simd_interleave@@YA_NPAH00H@Z ENDP			; simd_interleave
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_W5X3_v_synth32@@YA_NPAH000HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_int_coeff$ = -44					; size = 4
_downshift$ = -40					; size = 4
_dst_out$GSCopy$ = -36					; size = 4
_dst_in$GSCopy$ = -32					; size = 4
_src2$GSCopy$ = -28					; size = 4
_src1$GSCopy$ = -24					; size = 4
_vec_offset$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_dst_in$ = 16						; size = 4
_dst_out$ = 20						; size = 4
_samples$ = 24						; size = 4
_step$ = 28						; size = 4
?simd_W5X3_v_synth32@@YA_NPAH000HPAUkd_lifting_step@@@Z PROC ; simd_W5X3_v_synth32, COMDAT

; 2113 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2114 :   assert((step->support_length == 2) && (step->icoeffs[0]==step->icoeffs[1]));
; 2115 : #ifndef KDU_NO_SSE
; 2116 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	mov	eax, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR _step$[ebp]
	mov	DWORD PTR _src1$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _src2$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst_in$[ebp]
	mov	DWORD PTR _dst_in$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst_out$[ebp]
	mov	DWORD PTR _dst_out$GSCopy$[ebp], eax
	jge	SHORT $LN5@simd_W5X3_

; 2117 :     return false;

	xor	al, al

; 2163 : done:
; 2164 :     }
; 2165 : #endif KDU_NO_SSE
; 2166 :   return true;
; 2167 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@simd_W5X3_:

; 2118 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN15@simd_W5X3_

; 2119 :     return true;
; 2120 : 
; 2121 :   kdu_int32 vec_offset[4];
; 2122 :   vec_offset[0] = (kdu_int32)((1<<step->downshift)>>1);

	movzx	ecx, BYTE PTR [edx+2]
	mov	eax, 1
	shl	eax, cl
	sar	eax, 1
	mov	DWORD PTR _vec_offset$[ebp], eax

; 2123 :   for (int k=1; k < 4; k++)
; 2124 :     vec_offset[k] = vec_offset[0];

	mov	DWORD PTR _vec_offset$[ebp+4], eax
	mov	DWORD PTR _vec_offset$[ebp+8], eax
	mov	DWORD PTR _vec_offset$[ebp+12], eax

; 2125 :   int int_coeff = step->icoeffs[0];

	mov	eax, DWORD PTR [edx+12]
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _int_coeff$[ebp], eax

; 2126 :   int downshift = step->downshift;

	mov	DWORD PTR _downshift$[ebp], ecx

; 2129 :       MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 2130 :       MOV EAX,src1

	mov	eax, DWORD PTR _src1$GSCopy$[ebp]

; 2131 :       MOV EBX,src2

	mov	ebx, DWORD PTR _src2$GSCopy$[ebp]

; 2132 :       MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$GSCopy$[ebp]

; 2133 :       MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$GSCopy$[ebp]

; 2134 :       MOVDQU XMM0,vec_offset

	movdqu	xmm0, XMMWORD PTR _vec_offset$[ebp]

; 2135 :       MOVD XMM1,downshift

	movd	xmm1, DWORD PTR _downshift$[ebp]

; 2136 :       MOV ECX,int_coeff

	mov	ecx, DWORD PTR _int_coeff$[ebp]

; 2137 :       CMP ECX,1

	cmp	ecx, 1

; 2138 :       MOV ECX,0  // Set up sample counter, without altering status flags

	mov	ecx, 0

; 2139 :       JNE loop_minus1

	jne	SHORT $loop_minus1$17
$loop_plus1$18:

; 2140 : loop_plus1:
; 2141 :       MOVDQA XMM2,XMM0         // start with the offset

	movdqa	xmm2, xmm0

; 2142 :       PADDD XMM2,[EAX+4*ECX]   // add 1'st source sample

	paddd	xmm2, XMMWORD PTR [eax+ecx*4]

; 2143 :       PADDD XMM2,[EBX+4*ECX]   // add 2'nd source sample

	paddd	xmm2, XMMWORD PTR [ebx+ecx*4]

; 2144 :       MOVDQA XMM3,[ESI+4*ECX]

	movdqa	xmm3, XMMWORD PTR [esi+ecx*4]

; 2145 :       PSRAD XMM2,XMM1          // shift rigth by the `downshift' value

	psrad	xmm2, xmm1

; 2146 :       PSUBD XMM3,XMM2          // subtract from dest sample

	psubd	xmm3, xmm2

; 2147 :       MOVDQA [EDI+4*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*4], xmm3

; 2148 :       ADD ECX,4

	add	ecx, 4

; 2149 :       CMP ECX,EDX

	cmp	ecx, edx

; 2150 :       JL loop_plus1

	jl	SHORT $loop_plus1$18

; 2151 :       JMP done

	jmp	SHORT $done$19
$loop_minus1$17:

; 2152 : loop_minus1:
; 2153 :       MOVDQA XMM2,XMM0         // start with the offset

	movdqa	xmm2, xmm0

; 2154 :       PSUBD XMM2,[EAX+4*ECX]   // subtract 1'st source sample

	psubd	xmm2, XMMWORD PTR [eax+ecx*4]

; 2155 :       PSUBD XMM2,[EBX+4*ECX]   // subtract 2'nd source sample

	psubd	xmm2, XMMWORD PTR [ebx+ecx*4]

; 2156 :       MOVDQA XMM3,[ESI+4*ECX]

	movdqa	xmm3, XMMWORD PTR [esi+ecx*4]

; 2157 :       PSRAD XMM2,XMM1          // shift rigth by the `downshift' value

	psrad	xmm2, xmm1

; 2158 :       PSUBD XMM3,XMM2          // subtract from dest sample

	psubd	xmm3, xmm2

; 2159 :       MOVDQA [EDI+4*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*4], xmm3

; 2160 :       ADD ECX,4

	add	ecx, 4

; 2161 :       CMP ECX,EDX

	cmp	ecx, edx

; 2162 :       JL loop_minus1

	jl	SHORT $loop_minus1$17
$done$19:

; 2127 :   assert((int_coeff == 1) || (int_coeff == -1));
; 2128 :   __asm {

	pop	edi
	pop	esi
	pop	ebx
$LN15@simd_W5X3_:

; 2163 : done:
; 2164 :     }
; 2165 : #endif KDU_NO_SSE
; 2166 :   return true;
; 2167 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_W5X3_v_synth32@@YA_NPAH000HPAUkd_lifting_step@@@Z ENDP ; simd_W5X3_v_synth32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_W5X3_h_synth32@@YA_NPAH0HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_int_coeff$ = -36					; size = 4
_src$GSCopy$ = -32					; size = 4
_dst$GSCopy$ = -28					; size = 4
_downshift$ = -24					; size = 4
_vec_offset$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_samples$ = 16						; size = 4
_step$ = 20						; size = 4
?simd_W5X3_h_synth32@@YA_NPAH0HPAUkd_lifting_step@@@Z PROC ; simd_W5X3_h_synth32, COMDAT

; 1965 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1966 :   assert((step->support_length == 2) && (step->icoeffs[0]==step->icoeffs[1]));
; 1967 : #ifndef KDU_NO_SSE
; 1968 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	mov	eax, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _step$[ebp]
	mov	DWORD PTR _src$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _dst$GSCopy$[ebp], eax
	jge	SHORT $LN5@simd_W5X3_

; 1969 :     return false;

	xor	al, al

; 2033 : end_synth128:
; 2034 :     }
; 2035 : #endif // KDU_NO_SSE
; 2036 :   return true;
; 2037 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@simd_W5X3_:

; 1970 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN15@simd_W5X3_

; 1971 :     return true;
; 1972 : 
; 1973 :   kdu_int32 vec_offset[4];
; 1974 :   vec_offset[0] = (kdu_int32)((1<<step->downshift)>>1);

	movzx	ecx, BYTE PTR [edx+2]
	mov	eax, 1
	shl	eax, cl
	sar	eax, 1
	mov	DWORD PTR _vec_offset$[ebp], eax

; 1975 :   for (int k=1; k < 4; k++)
; 1976 :     vec_offset[k] = vec_offset[0];

	mov	DWORD PTR _vec_offset$[ebp+4], eax
	mov	DWORD PTR _vec_offset$[ebp+8], eax
	mov	DWORD PTR _vec_offset$[ebp+12], eax

; 1977 :   int int_coeff = step->icoeffs[0];

	mov	eax, DWORD PTR [edx+12]
	push	ebx
	push	edi

; 1978 :   int downshift = step->downshift;

	mov	DWORD PTR _downshift$[ebp], ecx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _int_coeff$[ebp], eax

; 1981 :     {
; 1982 :       MOVDQU XMM0,vec_offset

	movdqu	xmm0, XMMWORD PTR _vec_offset$[ebp]

; 1983 :       MOVD XMM1,downshift

	movd	xmm1, DWORD PTR _downshift$[ebp]

; 1984 :       MOV EDX,samples // Set limit for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 1985 :       MOV EDI,dst

	mov	edi, DWORD PTR _dst$GSCopy$[ebp]

; 1986 :       MOV EAX,src     // EAX points to first source sample

	mov	eax, DWORD PTR _src$GSCopy$[ebp]

; 1987 :       MOV EBX,EAX

	mov	ebx, eax

; 1988 :       ADD EBX,4       // EBX points to second source sample

	add	ebx, 4

; 1989 :       TEST EAX,0Fh    // See if EAX is 16-byte aligned

	test	eax, 15					; 0000000fH

; 1990 :       JZ eax_aligned

	je	SHORT $eax_aligned$17

; 1991 :       XCHG EAX,EBX    // Make sure EAX is the aligned address

	xchg	eax, ebx
$eax_aligned$17:

; 1992 : eax_aligned:
; 1993 :       MOV ECX,int_coeff

	mov	ecx, DWORD PTR _int_coeff$[ebp]

; 1994 :       CMP ECX,1

	cmp	ecx, 1

; 1995 :       JNE start_minus1_synth128

	jne	SHORT $start_minus1_synth128$18

; 1996 : 
; 1997 :       XOR ECX,ECX     // Initialize the sample counter

	xor	ecx, ecx

; 1998 :       MOVDQA XMM2,[EAX+4*ECX]    // Load initial 4 source 1 samples

	movdqa	xmm2, XMMWORD PTR [eax+ecx*4]

; 1999 :       MOVDQU XMM5,[EBX+4*ECX]    // Get initial 4 source 2 samples

	movdqu	xmm5, XMMWORD PTR [ebx+ecx*4]
$loop_plus1_synth128$19:

; 2000 : loop_plus1_synth128:
; 2001 :       MOVDQA XMM7,XMM0             // Start with the offset

	movdqa	xmm7, xmm0

; 2002 :       PADDD XMM7,XMM2

	paddd	xmm7, xmm2

; 2003 :       MOVDQA XMM2,[EAX+4*ECX+16]  // Pre-load aligned dqword

	movdqa	xmm2, XMMWORD PTR [eax+ecx*4+16]

; 2004 :       PADDD XMM7,XMM5

	paddd	xmm7, xmm5

; 2005 :       MOVDQU XMM5,[EBX+4*ECX+16]

	movdqu	xmm5, XMMWORD PTR [ebx+ecx*4+16]

; 2006 :       MOVDQA XMM3,[EDI+4*ECX]

	movdqa	xmm3, XMMWORD PTR [edi+ecx*4]

; 2007 :       PSRAD XMM7,XMM1

	psrad	xmm7, xmm1

; 2008 :       PSUBD XMM3,XMM7

	psubd	xmm3, xmm7

; 2009 :       MOVDQA [EDI+4*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*4], xmm3

; 2010 :       ADD ECX,4

	add	ecx, 4

; 2011 :       CMP ECX,EDX

	cmp	ecx, edx

; 2012 :       JL loop_plus1_synth128

	jl	SHORT $loop_plus1_synth128$19

; 2013 :       JMP end_synth128

	jmp	SHORT $end_synth128$20
$start_minus1_synth128$18:

; 2014 : 
; 2015 : start_minus1_synth128:
; 2016 :       // Invert Lifting Step 1
; 2017 :       XOR ECX,ECX                // Zero sample counter

	xor	ecx, ecx

; 2018 :       MOVDQA XMM2,[EAX+4*ECX]    // Load initial 4 source 1 samples

	movdqa	xmm2, XMMWORD PTR [eax+ecx*4]

; 2019 :       MOVDQU XMM5,[EBX+4*ECX]    // Get initial 4 source 2 samples

	movdqu	xmm5, XMMWORD PTR [ebx+ecx*4]
$loop_minus1_synth128$21:

; 2020 : loop_minus1_synth128:
; 2021 :       MOVDQA XMM7,XMM0             // Start with the offset

	movdqa	xmm7, xmm0

; 2022 :       PSUBD XMM7,XMM2

	psubd	xmm7, xmm2

; 2023 :       MOVDQA XMM2,[EAX+4*ECX+16]  // Pre-load aligned octet

	movdqa	xmm2, XMMWORD PTR [eax+ecx*4+16]

; 2024 :       PSUBD XMM7,XMM5

	psubd	xmm7, xmm5

; 2025 :       MOVDQU XMM5,[EBX+4*ECX+16]

	movdqu	xmm5, XMMWORD PTR [ebx+ecx*4+16]

; 2026 :       MOVDQA XMM3,[EDI+4*ECX]

	movdqa	xmm3, XMMWORD PTR [edi+ecx*4]

; 2027 :       PSRAD XMM7,XMM1

	psrad	xmm7, xmm1

; 2028 :       PSUBD XMM3,XMM7

	psubd	xmm3, xmm7

; 2029 :       MOVDQA [EDI+4*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*4], xmm3

; 2030 :       ADD ECX,4

	add	ecx, 4

; 2031 :       CMP ECX,EDX

	cmp	ecx, edx

; 2032 :       JL loop_minus1_synth128

	jl	SHORT $loop_minus1_synth128$21
$end_synth128$20:

; 1979 :   assert((int_coeff == 1) || (int_coeff == -1));
; 1980 :   __asm

	pop	edi
	pop	ebx
$LN15@simd_W5X3_:

; 2033 : end_synth128:
; 2034 :     }
; 2035 : #endif // KDU_NO_SSE
; 2036 :   return true;
; 2037 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_W5X3_h_synth32@@YA_NPAH0HPAUkd_lifting_step@@@Z ENDP ; simd_W5X3_h_synth32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_4tap_v_irrev32@@YA_NPAM00000HPAUkd_lifting_step@@_N@Z
_TEXT	SEGMENT
_lambda2$ = -64						; size = 4
_lambda1$ = -48						; size = 4
_lambda0$ = -32						; size = 4
_lambda3$ = -16						; size = 4
_src0$ = 8						; size = 4
_src1$ = 12						; size = 4
_src2$ = 16						; size = 4
_src3$ = 20						; size = 4
_dst_in$ = 24						; size = 4
_dst_out$ = 28						; size = 4
_samples$ = 32						; size = 4
_step$ = 36						; size = 4
_synthesis$ = 40					; size = 1
?simd_4tap_v_irrev32@@YA_NPAM00000HPAUkd_lifting_step@@_N@Z PROC ; simd_4tap_v_irrev32, COMDAT

; 1814 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1815 : #ifdef KDU_NO_SSE
; 1816 :   return false;
; 1817 : #else
; 1818 :   assert((step->support_length >= 3) || (step->support_length <= 4));
; 1819 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	push	ebx
	jge	SHORT $LN2@simd_4tap_

; 1820 :     return false;

	xor	al, al

; 1872 : #endif // !KDU_NO_SSE
; 1873 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_4tap_:

; 1821 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN8@simd_4tap_

; 1822 :     return true;
; 1823 : 
; 1824 :   float lambda0 = step->coeffs[0];

	mov	eax, DWORD PTR _step$[ebp]

; 1825 :   float lambda1 = step->coeffs[1];
; 1826 :   float lambda2 = step->coeffs[2];
; 1827 :   float lambda3 = (step->support_length==4)?(step->coeffs[3]):0.0F;

	cmp	BYTE PTR [eax+1], 4
	mov	ecx, DWORD PTR [eax+8]
	movss	xmm2, DWORD PTR [ecx]
	movss	xmm3, DWORD PTR [ecx+4]
	movss	xmm4, DWORD PTR [ecx+8]
	movss	DWORD PTR _lambda0$[ebp], xmm2
	movss	DWORD PTR _lambda1$[ebp], xmm3
	movss	DWORD PTR _lambda2$[ebp], xmm4
	jne	SHORT $LN6@simd_4tap_
	movss	xmm1, DWORD PTR [ecx+12]
	jmp	SHORT $LN9@simd_4tap_
$LN6@simd_4tap_:
	xorps	xmm1, xmm1
$LN9@simd_4tap_:

; 1828 :   if (synthesis)

	cmp	BYTE PTR _synthesis$[ebp], 0
	movss	DWORD PTR _lambda3$[ebp], xmm1
	je	SHORT $LN4@simd_4tap_

; 1829 :     { lambda0 = -lambda0;  lambda1 = -lambda1;

	movss	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm2, xmm0
	xorps	xmm3, xmm0

; 1830 :       lambda2 = -lambda2;  lambda3 = -lambda3; }

	xorps	xmm4, xmm0
	movss	DWORD PTR _lambda0$[ebp], xmm2
	xorps	xmm1, xmm0
	movss	DWORD PTR _lambda1$[ebp], xmm3
	movss	DWORD PTR _lambda2$[ebp], xmm4
	movss	DWORD PTR _lambda3$[ebp], xmm1
$LN4@simd_4tap_:

; 1831 :   __asm {

	push	esi
	push	edi

; 1832 :       MOVSS XMM0, lambda0

	movss	xmm0, XMMWORD PTR _lambda0$[ebp]

; 1833 :       MOVSS XMM1, lambda1

	movss	xmm1, XMMWORD PTR _lambda1$[ebp]

; 1834 :       MOVSS XMM2, lambda2

	movss	xmm2, XMMWORD PTR _lambda2$[ebp]

; 1835 :       MOVSS XMM3, lambda3

	movss	xmm3, XMMWORD PTR _lambda3$[ebp]

; 1836 :       PUNPCKLDQ XMM0,XMM0

	punpckldq xmm0, xmm0

; 1837 :       PUNPCKLDQ XMM1,XMM1

	punpckldq xmm1, xmm1

; 1838 :       PUNPCKLDQ XMM2,XMM2

	punpckldq xmm2, xmm2

; 1839 :       PUNPCKLDQ XMM3,XMM3

	punpckldq xmm3, xmm3

; 1840 :       PUNPCKLQDQ XMM0,XMM0

	punpcklqdq xmm0, xmm0

; 1841 :       PUNPCKLQDQ XMM1,XMM1

	punpcklqdq xmm1, xmm1

; 1842 :       PUNPCKLQDQ XMM2,XMM2

	punpcklqdq xmm2, xmm2

; 1843 :       PUNPCKLQDQ XMM3,XMM3

	punpcklqdq xmm3, xmm3

; 1844 :       XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx

; 1845 :       MOV EAX,src0

	mov	eax, DWORD PTR _src0$[ebp]

; 1846 :       MOV EBX,src1

	mov	ebx, DWORD PTR _src1$[ebp]

; 1847 :       MOV EDX, src2

	mov	edx, DWORD PTR _src2$[ebp]

; 1848 :       MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$[ebp]

; 1849 :       MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$[ebp]
$loop_dqword$11:

; 1850 : loop_dqword:
; 1851 :       MOVUPS XMM4, [EAX+4*ECX]

	movups	xmm4, XMMWORD PTR [eax+ecx*4]

; 1852 :       MOVUPS XMM5, [EBX+4*ECX]

	movups	xmm5, XMMWORD PTR [ebx+ecx*4]

; 1853 :       MOVUPS XMM6, [EDX+4*ECX]

	movups	xmm6, XMMWORD PTR [edx+ecx*4]

; 1854 :       MOV EDX, src3

	mov	edx, DWORD PTR _src3$[ebp]

; 1855 :       MULPS XMM4, XMM0

	mulps	xmm4, xmm0

; 1856 :       MULPS XMM5, XMM1

	mulps	xmm5, xmm1

; 1857 :       MULPS XMM6, XMM2

	mulps	xmm6, xmm2

; 1858 :       MOVUPS XMM7, [EDX+4*ECX]

	movups	xmm7, XMMWORD PTR [edx+ecx*4]

; 1859 :       ADDPS XMM5, XMM4

	addps	xmm5, xmm4

; 1860 :       MOVAPS XMM4, [ESI+4*ECX]

	movaps	xmm4, XMMWORD PTR [esi+ecx*4]

; 1861 :       MULPS XMM7, XMM3

	mulps	xmm7, xmm3

; 1862 :       ADDPS XMM6, XMM5

	addps	xmm6, xmm5

; 1863 :       ADDPS XMM6, XMM4

	addps	xmm6, xmm4

; 1864 :       ADDPS XMM7, XMM6

	addps	xmm7, xmm6

; 1865 :       MOVAPS [EDI+4*ECX], XMM7

	movaps	XMMWORD PTR [edi+ecx*4], xmm7

; 1866 :       ADD ECX,4

	add	ecx, 4

; 1867 :       MOV EDX, src2

	mov	edx, DWORD PTR _src2$[ebp]

; 1868 :       CMP ECX,samples

	cmp	ecx, DWORD PTR _samples$[ebp]

; 1869 :       JL loop_dqword

	jl	SHORT $loop_dqword$11

; 1831 :   __asm {

	pop	edi
	pop	esi
$LN8@simd_4tap_:

; 1870 :     }
; 1871 :   return true;

	mov	al, 1

; 1872 : #endif // !KDU_NO_SSE
; 1873 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_4tap_v_irrev32@@YA_NPAM00000HPAUkd_lifting_step@@_N@Z ENDP ; simd_4tap_v_irrev32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_2tap_v_irrev32@@YA_NPAM000HPAUkd_lifting_step@@_N@Z
_TEXT	SEGMENT
_lambda0$ = -32						; size = 4
_lambda1$ = -16						; size = 4
_src0$ = 8						; size = 4
_src1$ = 12						; size = 4
_dst_in$ = 16						; size = 4
_dst_out$ = 20						; size = 4
_samples$ = 24						; size = 4
_step$ = 28						; size = 4
_synthesis$ = 32					; size = 1
?simd_2tap_v_irrev32@@YA_NPAM000HPAUkd_lifting_step@@_N@Z PROC ; simd_2tap_v_irrev32, COMDAT

; 1757 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1758 : #ifdef KDU_NO_SSE
; 1759 :   return false;
; 1760 : #else
; 1761 :   assert((step->support_length == 1) || (step->support_length == 2));
; 1762 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	push	ebx
	jge	SHORT $LN2@simd_2tap_

; 1763 :     return false;

	xor	al, al

; 1799 : #endif // !KDU_NO_SSE
; 1800 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_2tap_:

; 1764 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN8@simd_2tap_

; 1765 :     return true;
; 1766 :   float lambda0 = step->coeffs[0];

	mov	eax, DWORD PTR _step$[ebp]

; 1767 :   float lambda1 = (step->support_length==2)?(step->coeffs[1]):0.0F;

	cmp	BYTE PTR [eax+1], 2
	mov	ecx, DWORD PTR [eax+8]
	movss	xmm2, DWORD PTR [ecx]
	movss	DWORD PTR _lambda0$[ebp], xmm2
	jne	SHORT $LN6@simd_2tap_
	movss	xmm1, DWORD PTR [ecx+4]
	jmp	SHORT $LN9@simd_2tap_
$LN6@simd_2tap_:
	xorps	xmm1, xmm1
$LN9@simd_2tap_:

; 1768 :   if (synthesis)

	cmp	BYTE PTR _synthesis$[ebp], 0
	movss	DWORD PTR _lambda1$[ebp], xmm1
	je	SHORT $LN4@simd_2tap_

; 1769 :     { lambda0 = -lambda0;  lambda1 = -lambda1; }

	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _lambda0$[ebp], xmm2
	movss	DWORD PTR _lambda1$[ebp], xmm1
$LN4@simd_2tap_:

; 1770 :   __asm {

	push	esi
	push	edi

; 1771 :       MOVSS XMM0, lambda0

	movss	xmm0, XMMWORD PTR _lambda0$[ebp]

; 1772 :       MOVSS XMM1, lambda1

	movss	xmm1, XMMWORD PTR _lambda1$[ebp]

; 1773 :       PUNPCKLDQ XMM0,XMM0

	punpckldq xmm0, xmm0

; 1774 :       PUNPCKLDQ XMM1,XMM1

	punpckldq xmm1, xmm1

; 1775 :       PUNPCKLQDQ XMM0,XMM0

	punpcklqdq xmm0, xmm0

; 1776 :       PUNPCKLQDQ XMM1,XMM1

	punpcklqdq xmm1, xmm1

; 1777 :       XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx

; 1778 :       MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 1779 :       MOV EAX,src0

	mov	eax, DWORD PTR _src0$[ebp]

; 1780 :       MOV EBX,src1

	mov	ebx, DWORD PTR _src1$[ebp]

; 1781 :       MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$[ebp]

; 1782 :       MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$[ebp]

; 1783 :       MOVAPS XMM4,[EAX]

	movaps	xmm4, XMMWORD PTR [eax]

; 1784 :       MOVAPS XMM5,[EBX]

	movaps	xmm5, XMMWORD PTR [ebx]
$loop_dqword$11:

; 1785 : loop_dqword:
; 1786 :       MULPS XMM4, XMM0

	mulps	xmm4, xmm0

; 1787 :       MULPS XMM5, XMM1

	mulps	xmm5, xmm1

; 1788 :       MOVAPS XMM2, [ESI+4*ECX]

	movaps	xmm2, XMMWORD PTR [esi+ecx*4]

; 1789 :       ADDPS XMM5, XMM4

	addps	xmm5, xmm4

; 1790 :       MOVAPS XMM4, [EAX+4*ECX+16]

	movaps	xmm4, XMMWORD PTR [eax+ecx*4+16]

; 1791 :       ADDPS XMM2, XMM5

	addps	xmm2, xmm5

; 1792 :       MOVAPS XMM5, [EBX+4*ECX+16]

	movaps	xmm5, XMMWORD PTR [ebx+ecx*4+16]

; 1793 :       MOVAPS [EDI+4*ECX], XMM2

	movaps	XMMWORD PTR [edi+ecx*4], xmm2

; 1794 :       ADD ECX,4

	add	ecx, 4

; 1795 :       CMP ECX,EDX

	cmp	ecx, edx

; 1796 :       JL loop_dqword

	jl	SHORT $loop_dqword$11

; 1770 :   __asm {

	pop	edi
	pop	esi
$LN8@simd_2tap_:

; 1797 :     }
; 1798 :   return true;

	mov	al, 1

; 1799 : #endif // !KDU_NO_SSE
; 1800 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_2tap_v_irrev32@@YA_NPAM000HPAUkd_lifting_step@@_N@Z ENDP ; simd_2tap_v_irrev32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_4tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z
_TEXT	SEGMENT
_lambda2$ = -64						; size = 4
_lambda1$ = -48						; size = 4
_lambda0$ = -32						; size = 4
_lambda3$ = -16						; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_samples$ = 16						; size = 4
_step$ = 20						; size = 4
_synthesis$ = 24					; size = 1
?simd_4tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z PROC ; simd_4tap_h_irrev32, COMDAT

; 1685 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1686 : #ifdef KDU_NO_SSE
; 1687 :   return false;
; 1688 : #else
; 1689 :   assert((step->support_length >= 3) && (step->support_length <= 4));
; 1690 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	jge	SHORT $LN2@simd_4tap_

; 1691 :     return false;

	xor	al, al

; 1743 : #endif // !KDU_NO_SSE
; 1744 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_4tap_:

; 1692 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN8@simd_4tap_

; 1693 :     return true;
; 1694 : 
; 1695 :   float lambda0 = step->coeffs[0];

	mov	eax, DWORD PTR _step$[ebp]

; 1696 :   float lambda1 = step->coeffs[1];
; 1697 :   float lambda2 = step->coeffs[2];
; 1698 :   float lambda3 = (step->support_length==4)?(step->coeffs[3]):0.0F;

	cmp	BYTE PTR [eax+1], 4
	mov	ecx, DWORD PTR [eax+8]
	movss	xmm2, DWORD PTR [ecx]
	movss	xmm3, DWORD PTR [ecx+4]
	movss	xmm4, DWORD PTR [ecx+8]
	movss	DWORD PTR _lambda0$[ebp], xmm2
	movss	DWORD PTR _lambda1$[ebp], xmm3
	movss	DWORD PTR _lambda2$[ebp], xmm4
	jne	SHORT $LN6@simd_4tap_
	movss	xmm1, DWORD PTR [ecx+12]
	jmp	SHORT $LN9@simd_4tap_
$LN6@simd_4tap_:
	xorps	xmm1, xmm1
$LN9@simd_4tap_:

; 1699 :   if (synthesis)

	cmp	BYTE PTR _synthesis$[ebp], 0
	movss	DWORD PTR _lambda3$[ebp], xmm1
	je	SHORT $LN4@simd_4tap_

; 1700 :     { lambda0 = -lambda0;  lambda1 = -lambda1;

	movss	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm2, xmm0
	xorps	xmm3, xmm0

; 1701 :       lambda2 = -lambda2;  lambda3 = -lambda3; }

	xorps	xmm4, xmm0
	movss	DWORD PTR _lambda0$[ebp], xmm2
	xorps	xmm1, xmm0
	movss	DWORD PTR _lambda1$[ebp], xmm3
	movss	DWORD PTR _lambda2$[ebp], xmm4
	movss	DWORD PTR _lambda3$[ebp], xmm1
$LN4@simd_4tap_:

; 1702 :   __asm {

	push	esi
	push	edi

; 1703 :       MOVSS XMM0, lambda0

	movss	xmm0, XMMWORD PTR _lambda0$[ebp]

; 1704 :       MOVSS XMM1, lambda1

	movss	xmm1, XMMWORD PTR _lambda1$[ebp]

; 1705 :       MOVSS XMM2, lambda2

	movss	xmm2, XMMWORD PTR _lambda2$[ebp]

; 1706 :       MOVSS XMM3, lambda3

	movss	xmm3, XMMWORD PTR _lambda3$[ebp]

; 1707 :       PUNPCKLDQ XMM0,XMM0

	punpckldq xmm0, xmm0

; 1708 :       PUNPCKLDQ XMM1,XMM1

	punpckldq xmm1, xmm1

; 1709 :       PUNPCKLDQ XMM2,XMM2

	punpckldq xmm2, xmm2

; 1710 :       PUNPCKLDQ XMM3,XMM3

	punpckldq xmm3, xmm3

; 1711 :       PUNPCKLQDQ XMM0,XMM0

	punpcklqdq xmm0, xmm0

; 1712 :       PUNPCKLQDQ XMM1,XMM1

	punpcklqdq xmm1, xmm1

; 1713 :       PUNPCKLQDQ XMM2,XMM2

	punpcklqdq xmm2, xmm2

; 1714 :       PUNPCKLQDQ XMM3,XMM3

	punpcklqdq xmm3, xmm3

; 1715 :       MOV ESI,src

	mov	esi, DWORD PTR _src$[ebp]

; 1716 :       MOV EDI,dst

	mov	edi, DWORD PTR _dst$[ebp]

; 1717 :       MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 1718 :       XOR ECX,ECX        // Zero sample counter

	xor	ecx, ecx

; 1719 :       MOVUPS XMM4,[ESI]

	movups	xmm4, XMMWORD PTR [esi]

; 1720 :       MOVUPS XMM5,[ESI+4]

	movups	xmm5, XMMWORD PTR [esi+4]

; 1721 :       MOVUPS XMM6,[ESI+8]

	movups	xmm6, XMMWORD PTR [esi+8]

; 1722 :       MOVUPS XMM7,[ESI+12]

	movups	xmm7, XMMWORD PTR [esi+12]
$loop_dqword$11:

; 1723 : loop_dqword:
; 1724 :       MULPS XMM4, XMM0

	mulps	xmm4, xmm0

; 1725 :       MULPS XMM5, XMM1

	mulps	xmm5, xmm1

; 1726 :       ADDPS XMM4, XMM5

	addps	xmm4, xmm5

; 1727 :       MOVAPS XMM5, [EDI+4*ECX]

	movaps	xmm5, XMMWORD PTR [edi+ecx*4]

; 1728 :       MULPS XMM6, XMM2

	mulps	xmm6, xmm2

; 1729 :       ADDPS XMM5, XMM4

	addps	xmm5, xmm4

; 1730 :       MOVUPS XMM4, [ESI+4*ECX+16]

	movups	xmm4, XMMWORD PTR [esi+ecx*4+16]

; 1731 :       MULPS XMM7, XMM3

	mulps	xmm7, xmm3

; 1732 :       ADDPS XMM6, XMM5

	addps	xmm6, xmm5

; 1733 :       MOVUPS XMM5, [ESI+4*ECX+20]

	movups	xmm5, XMMWORD PTR [esi+ecx*4+20]

; 1734 :       ADDPS XMM7, XMM6

	addps	xmm7, xmm6

; 1735 :       MOVUPS XMM6, [ESI+4*ECX+24]

	movups	xmm6, XMMWORD PTR [esi+ecx*4+24]

; 1736 :       MOVAPS [EDI+4*ECX], XMM7

	movaps	XMMWORD PTR [edi+ecx*4], xmm7

; 1737 :       MOVUPS XMM7, [ESI+4*ECX+28]

	movups	xmm7, XMMWORD PTR [esi+ecx*4+28]

; 1738 :       ADD ECX,4

	add	ecx, 4

; 1739 :       CMP ECX,EDX

	cmp	ecx, edx

; 1740 :       JL loop_dqword

	jl	SHORT $loop_dqword$11

; 1702 :   __asm {

	pop	edi
	pop	esi
$LN8@simd_4tap_:

; 1741 :     }
; 1742 :   return true;

	mov	al, 1

; 1743 : #endif // !KDU_NO_SSE
; 1744 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?simd_4tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z ENDP ; simd_4tap_h_irrev32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_2tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z
_TEXT	SEGMENT
_lambda0$ = -32						; size = 4
_lambda1$ = -16						; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_samples$ = 16						; size = 4
_step$ = 20						; size = 4
_synthesis$ = 24					; size = 1
?simd_2tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z PROC ; simd_2tap_h_irrev32, COMDAT

; 1629 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1630 : #ifdef KDU_NO_SSE
; 1631 :   return false;
; 1632 : #else
; 1633 :   assert((step->support_length == 1) || (step->support_length == 2));
; 1634 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	jge	SHORT $LN2@simd_2tap_

; 1635 :     return false;

	xor	al, al

; 1671 : #endif // !KDU_NO_SSE
; 1672 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_2tap_:

; 1636 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN8@simd_2tap_

; 1637 :     return true;
; 1638 : 
; 1639 :   float lambda0 = step->coeffs[0];

	mov	eax, DWORD PTR _step$[ebp]

; 1640 :   float lambda1 = (step->support_length==2)?(step->coeffs[1]):0.0F;

	cmp	BYTE PTR [eax+1], 2
	mov	ecx, DWORD PTR [eax+8]
	movss	xmm2, DWORD PTR [ecx]
	movss	DWORD PTR _lambda0$[ebp], xmm2
	jne	SHORT $LN6@simd_2tap_
	movss	xmm1, DWORD PTR [ecx+4]
	jmp	SHORT $LN9@simd_2tap_
$LN6@simd_2tap_:
	xorps	xmm1, xmm1
$LN9@simd_2tap_:

; 1641 :   if (synthesis)

	cmp	BYTE PTR _synthesis$[ebp], 0
	movss	DWORD PTR _lambda1$[ebp], xmm1
	je	SHORT $LN4@simd_2tap_

; 1642 :     { lambda0 = -lambda0;  lambda1 = -lambda1; }

	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _lambda0$[ebp], xmm2
	movss	DWORD PTR _lambda1$[ebp], xmm1
$LN4@simd_2tap_:

; 1643 :   __asm {

	push	esi
	push	edi

; 1644 :       MOVSS XMM0, lambda0

	movss	xmm0, XMMWORD PTR _lambda0$[ebp]

; 1645 :       MOVSS XMM1, lambda1

	movss	xmm1, XMMWORD PTR _lambda1$[ebp]

; 1646 :       PUNPCKLDQ XMM0,XMM0

	punpckldq xmm0, xmm0

; 1647 :       PUNPCKLDQ XMM1,XMM1

	punpckldq xmm1, xmm1

; 1648 :       PUNPCKLQDQ XMM0,XMM0

	punpcklqdq xmm0, xmm0

; 1649 :       PUNPCKLQDQ XMM1,XMM1

	punpcklqdq xmm1, xmm1

; 1650 :       MOV ESI,src

	mov	esi, DWORD PTR _src$[ebp]

; 1651 :       MOV EDI,dst

	mov	edi, DWORD PTR _dst$[ebp]

; 1652 : 
; 1653 :       MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 1654 :       XOR ECX,ECX        // Zero sample counter

	xor	ecx, ecx

; 1655 :       MOVUPS XMM4,[ESI]

	movups	xmm4, XMMWORD PTR [esi]

; 1656 :       MOVUPS XMM5,[ESI+4]

	movups	xmm5, XMMWORD PTR [esi+4]
$loop_dqword$11:

; 1657 : loop_dqword:
; 1658 :       MULPS XMM4, XMM0

	mulps	xmm4, xmm0

; 1659 :       MULPS XMM5, XMM1

	mulps	xmm5, xmm1

; 1660 :       MOVAPS XMM2, [EDI+4*ECX]

	movaps	xmm2, XMMWORD PTR [edi+ecx*4]

; 1661 :       ADDPS XMM5, XMM4

	addps	xmm5, xmm4

; 1662 :       MOVUPS XMM4, [ESI+4*ECX+16]

	movups	xmm4, XMMWORD PTR [esi+ecx*4+16]

; 1663 :       ADDPS XMM2, XMM5

	addps	xmm2, xmm5

; 1664 :       MOVUPS XMM5, [ESI+4*ECX+20]

	movups	xmm5, XMMWORD PTR [esi+ecx*4+20]

; 1665 :       MOVAPS [EDI+4*ECX],XMM2

	movaps	XMMWORD PTR [edi+ecx*4], xmm2

; 1666 :       ADD ECX,4

	add	ecx, 4

; 1667 :       CMP ECX,EDX

	cmp	ecx, edx

; 1668 :       JL loop_dqword

	jl	SHORT $loop_dqword$11

; 1643 :   __asm {

	pop	edi
	pop	esi
$LN8@simd_2tap_:

; 1669 :     }
; 1670 :   return true;

	mov	al, 1

; 1671 : #endif // !KDU_NO_SSE
; 1672 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?simd_2tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z ENDP ; simd_2tap_h_irrev32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_upshifted_interleave@@YA_NPAF00HH@Z
_TEXT	SEGMENT
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_dst$ = 16						; size = 4
_pairs$ = 20						; size = 4
_upshift$ = 24						; size = 4
?simd_upshifted_interleave@@YA_NPAF00HH@Z PROC		; simd_upshifted_interleave, COMDAT

; 1540 : {

	push	ebp
	mov	ebp, esp

; 1541 :   if (kdu_mmx_level < 1)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 1	; kdu_mmx_level
	jge	SHORT $LN2@simd_upshi

; 1542 :     return false;

	xor	al, al

; 1611 : }

	pop	ebp
	ret	0
$LN2@simd_upshi:

; 1543 :   if (pairs <= 0)

	cmp	DWORD PTR _pairs$[ebp], 0
	jle	$LN5@simd_upshi

; 1544 :     return true;
; 1545 : 
; 1546 :   __asm

	push	ebx
	push	edi

; 1547 :     {
; 1548 :       MOV ECX,pairs      // Set up counter used for looping

	mov	ecx, DWORD PTR _pairs$[ebp]

; 1549 :       MOV EAX,src1

	mov	eax, DWORD PTR _src1$[ebp]

; 1550 :       MOV EBX,src2

	mov	ebx, DWORD PTR _src2$[ebp]

; 1551 :       MOV EDX,dst

	mov	edx, DWORD PTR _dst$[ebp]

; 1552 :       MOVD MM3,upshift

	movd	mm3, DWORD PTR _upshift$[ebp]

; 1553 : #ifndef KDU_NO_SSE
; 1554 :       MOV EDI,kdu_mmx_level

	mov	edi, DWORD PTR ?kdu_mmx_level@@3HA	; kdu_mmx_level

; 1555 :       CMP EDI,2

	cmp	edi, 2

; 1556 :       JL loop_shift_ilv64

	jl	SHORT $loop_shift_ilv64$7

; 1557 :       CMP ECX,32 // 128-bit processing not worthwhile unless >= 32 pairs exist

	cmp	ecx, 32					; 00000020H

; 1558 :       JL loop_shift_ilv64

	jl	SHORT $loop_shift_ilv64$7

; 1559 : 
; 1560 :       // If we get here, we can use the implementation based on 128-bit
; 1561 :       // operands, using SSE/SSE2 instructions
; 1562 :       MOVD XMM3,upshift

	movd	xmm3, DWORD PTR _upshift$[ebp]

; 1563 :       SUB ECX,8 // Halts 128-bit processing when <= 8 pairs are left

	sub	ecx, 8

; 1564 :       TEST EAX,8 // See if source address is 16-byte aligned

	test	eax, 8

; 1565 :       JZ loop_shift_ilv128  // If not, source words must be 8-byte aligned

	je	SHORT $loop_shift_ilv128$8

; 1566 :         MOVDQA XMM0,[EAX-8]

	movdqa	xmm0, XMMWORD PTR [eax-8]

; 1567 :         PSLLW XMM0,XMM3

	psllw	xmm0, xmm3

; 1568 :         MOVDQA XMM1,[EBX-8]

	movdqa	xmm1, XMMWORD PTR [ebx-8]

; 1569 :         PSLLW XMM1,XMM3

	psllw	xmm1, xmm3

; 1570 :         PUNPCKHWD XMM0,XMM1

	punpckhwd xmm0, xmm1

; 1571 :         MOVDQA [EDX],XMM0

	movdqa	XMMWORD PTR [edx], xmm0

; 1572 :         ADD EAX,8

	add	eax, 8

; 1573 :         ADD EBX,8

	add	ebx, 8

; 1574 :         ADD EDX,16

	add	edx, 16					; 00000010H

; 1575 :         SUB ECX,4

	sub	ecx, 4
$loop_shift_ilv128$8:

; 1576 : loop_shift_ilv128:
; 1577 :       MOVDQA XMM0,[EAX]

	movdqa	xmm0, XMMWORD PTR [eax]

; 1578 :       PSLLW XMM0,XMM3

	psllw	xmm0, xmm3

; 1579 :       MOVDQA XMM2,XMM0

	movdqa	xmm2, xmm0

; 1580 :       MOVDQA XMM1,[EBX]

	movdqa	xmm1, XMMWORD PTR [ebx]

; 1581 :       PSLLW XMM1,XMM3

	psllw	xmm1, xmm3

; 1582 :       PUNPCKLWD XMM2,XMM1

	punpcklwd xmm2, xmm1

; 1583 :       MOVDQA [EDX],XMM2

	movdqa	XMMWORD PTR [edx], xmm2

; 1584 :       PUNPCKHWD XMM0,XMM1

	punpckhwd xmm0, xmm1

; 1585 :       MOVDQA [EDX+16],XMM0

	movdqa	XMMWORD PTR [edx+16], xmm0

; 1586 :       ADD EAX,16

	add	eax, 16					; 00000010H

; 1587 :       ADD EBX,16

	add	ebx, 16					; 00000010H

; 1588 :       ADD EDX,32

	add	edx, 32					; 00000020H

; 1589 :       SUB ECX,8

	sub	ecx, 8

; 1590 :       JG loop_shift_ilv128

	jg	SHORT $loop_shift_ilv128$8

; 1591 :       ADD ECX,8  // Restore the amount that we subtracted earlier

	add	ecx, 8
$loop_shift_ilv64$7:

; 1592 : #endif // !KDU_NO_SSE
; 1593 : loop_shift_ilv64:
; 1594 :       MOVQ MM0,[EAX]

	movq	mm0, MMWORD PTR [eax]

; 1595 :       PSLLW MM0,MM3

	psllw	mm0, mm3

; 1596 :       MOVQ MM2,MM0

	movq	mm2, mm0

; 1597 :       MOVQ MM1,[EBX]

	movq	mm1, MMWORD PTR [ebx]

; 1598 :       PSLLW MM1,MM3

	psllw	mm1, mm3

; 1599 :       PUNPCKLWD MM2,MM1

	punpcklwd mm2, mm1

; 1600 :       MOVQ [EDX],MM2

	movq	MMWORD PTR [edx], mm2

; 1601 :       PUNPCKHWD MM0,MM1

	punpckhwd mm0, mm1

; 1602 :       MOVQ [EDX+8],MM0

	movq	MMWORD PTR [edx+8], mm0

; 1603 :       ADD EAX,8

	add	eax, 8

; 1604 :       ADD EBX,8

	add	ebx, 8

; 1605 :       ADD EDX,16

	add	edx, 16					; 00000010H

; 1606 :       SUB ECX,4

	sub	ecx, 4

; 1607 :       JG loop_shift_ilv64

	jg	SHORT $loop_shift_ilv64$7

; 1608 :       EMMS // Clear MMX registers for use by FPU

	emms

; 1544 :     return true;
; 1545 : 
; 1546 :   __asm

	pop	edi
	pop	ebx
$LN5@simd_upshi:

; 1609 :     }
; 1610 :   return true;

	mov	al, 1

; 1611 : }

	pop	ebp
	ret	0
?simd_upshifted_interleave@@YA_NPAF00HH@Z ENDP		; simd_upshifted_interleave
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_interleave@@YA_NPAF00H@Z
_TEXT	SEGMENT
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_dst$ = 16						; size = 4
_pairs$ = 20						; size = 4
?simd_interleave@@YA_NPAF00H@Z PROC			; simd_interleave, COMDAT

; 1413 : {

	push	ebp
	mov	ebp, esp

; 1414 :   if (kdu_mmx_level < 1)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 1	; kdu_mmx_level
	jge	SHORT $LN2@simd_inter

; 1415 :     return false;

	xor	al, al

; 1476 : }

	pop	ebp
	ret	0
$LN2@simd_inter:

; 1416 :   if (pairs <= 0)

	cmp	DWORD PTR _pairs$[ebp], 0
	jle	$LN5@simd_inter

; 1417 :     return true;
; 1418 : 
; 1419 :   __asm

	push	ebx
	push	edi

; 1420 :     {
; 1421 :       MOV ECX,pairs      // Set up counter used for looping

	mov	ecx, DWORD PTR _pairs$[ebp]

; 1422 :       MOV EAX,src1

	mov	eax, DWORD PTR _src1$[ebp]

; 1423 :       MOV EBX,src2

	mov	ebx, DWORD PTR _src2$[ebp]

; 1424 :       MOV EDX,dst

	mov	edx, DWORD PTR _dst$[ebp]

; 1425 : #ifndef KDU_NO_SSE
; 1426 :       MOV EDI,kdu_mmx_level

	mov	edi, DWORD PTR ?kdu_mmx_level@@3HA	; kdu_mmx_level

; 1427 :       CMP EDI,2

	cmp	edi, 2

; 1428 :       JL loop_ilv64

	jl	SHORT $loop_ilv64$7

; 1429 :       CMP ECX,32 // 128-bit processing not worthwhile unless >= 32 pairs exist

	cmp	ecx, 32					; 00000020H

; 1430 :       JL loop_ilv64

	jl	SHORT $loop_ilv64$7

; 1431 : 
; 1432 :       // If we get here, we can use the implementation based on 128-bit
; 1433 :       // operands, using SSE/SSE2 instructions
; 1434 :       SUB ECX,8 // Halts 128-bit processing when 1 to 8 pairs are left

	sub	ecx, 8

; 1435 :       TEST EAX,8 // See if source address is 16-byte aligned

	test	eax, 8

; 1436 :       JZ loop_ilv128  // If not, source words must be 8-byte aligned

	je	SHORT $loop_ilv128$8

; 1437 :         MOVDQA XMM0,[EAX-8]

	movdqa	xmm0, XMMWORD PTR [eax-8]

; 1438 :         MOVDQA XMM1,[EBX-8]

	movdqa	xmm1, XMMWORD PTR [ebx-8]

; 1439 :         PUNPCKHWD XMM0,XMM1

	punpckhwd xmm0, xmm1

; 1440 :         MOVDQA [EDX],XMM0

	movdqa	XMMWORD PTR [edx], xmm0

; 1441 :         ADD EAX,8

	add	eax, 8

; 1442 :         ADD EBX,8

	add	ebx, 8

; 1443 :         ADD EDX,16

	add	edx, 16					; 00000010H

; 1444 :         SUB ECX,4

	sub	ecx, 4
$loop_ilv128$8:

; 1445 : loop_ilv128:
; 1446 :       MOVDQA XMM0,[EAX]

	movdqa	xmm0, XMMWORD PTR [eax]

; 1447 :       MOVDQA XMM2,XMM0

	movdqa	xmm2, xmm0

; 1448 :       MOVDQA XMM1,[EBX]

	movdqa	xmm1, XMMWORD PTR [ebx]

; 1449 :       PUNPCKLWD XMM2,XMM1

	punpcklwd xmm2, xmm1

; 1450 :       MOVDQA [EDX],XMM2

	movdqa	XMMWORD PTR [edx], xmm2

; 1451 :       PUNPCKHWD XMM0,XMM1

	punpckhwd xmm0, xmm1

; 1452 :       MOVDQA [EDX+16],XMM0

	movdqa	XMMWORD PTR [edx+16], xmm0

; 1453 :       ADD EAX,16

	add	eax, 16					; 00000010H

; 1454 :       ADD EBX,16

	add	ebx, 16					; 00000010H

; 1455 :       ADD EDX,32

	add	edx, 32					; 00000020H

; 1456 :       SUB ECX,8

	sub	ecx, 8

; 1457 :       JG loop_ilv128

	jg	SHORT $loop_ilv128$8

; 1458 :       ADD ECX,8

	add	ecx, 8
$loop_ilv64$7:

; 1459 : #endif // !KDU_NO_SSE
; 1460 : loop_ilv64:
; 1461 :       MOVQ MM0,[EAX]

	movq	mm0, MMWORD PTR [eax]

; 1462 :       MOVQ MM2,MM0

	movq	mm2, mm0

; 1463 :       MOVQ MM1,[EBX]

	movq	mm1, MMWORD PTR [ebx]

; 1464 :       PUNPCKLWD MM2,MM1

	punpcklwd mm2, mm1

; 1465 :       MOVQ [EDX],MM2

	movq	MMWORD PTR [edx], mm2

; 1466 :       PUNPCKHWD MM0,MM1

	punpckhwd mm0, mm1

; 1467 :       MOVQ [EDX+8],MM0

	movq	MMWORD PTR [edx+8], mm0

; 1468 :       ADD EAX,8

	add	eax, 8

; 1469 :       ADD EBX,8

	add	ebx, 8

; 1470 :       ADD EDX,16

	add	edx, 16					; 00000010H

; 1471 :       SUB ECX,4

	sub	ecx, 4

; 1472 :       JG loop_ilv64

	jg	SHORT $loop_ilv64$7

; 1473 :       EMMS // Clear MMX registers for use by FPU

	emms

; 1417 :     return true;
; 1418 : 
; 1419 :   __asm

	pop	edi
	pop	ebx
$LN5@simd_inter:

; 1474 :     }
; 1475 :   return true;

	mov	al, 1

; 1476 : }

	pop	ebp
	ret	0
?simd_interleave@@YA_NPAF00H@Z ENDP			; simd_interleave
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_W9X7_v_synth@@YA_NPAF000HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_step_idx$ = -56					; size = 4
_dst_out$GSCopy$ = -52					; size = 4
_dst_in$GSCopy$ = -48					; size = 4
_src2$GSCopy$ = -44					; size = 4
_src1$GSCopy$ = -40					; size = 4
_vec_preoff$ = -36					; size = 16
_vec_lambda$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_dst_in$ = 16						; size = 4
_dst_out$ = 20						; size = 4
_samples$ = 24						; size = 4
_step$ = 28						; size = 4
?simd_W9X7_v_synth@@YA_NPAF000HPAUkd_lifting_step@@@Z PROC ; simd_W9X7_v_synth, COMDAT

; 1152 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _src1$[ebp]

; 1153 :   if (kdu_mmx_level < 1)

	mov	edx, DWORD PTR ?kdu_mmx_level@@3HA	; kdu_mmx_level
	mov	DWORD PTR _src1$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _src2$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst_in$[ebp]
	mov	DWORD PTR _dst_in$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst_out$[ebp]
	mov	DWORD PTR _dst_out$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _step$[ebp]
	cmp	edx, 1
	jge	SHORT $LN5@simd_W9X7_

; 1154 :     return false;

	xor	al, al

; 1361 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@simd_W9X7_:

; 1155 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN21@simd_W9X7_

; 1156 :     return true;
; 1157 :   int step_idx = step->step_idx;

	movzx	eax, BYTE PTR [eax]
	mov	DWORD PTR _step_idx$[ebp], eax
	push	ebx
	push	esi

; 1158 :   assert((step_idx >= 0) && (step_idx < 4));
; 1159 :   kdu_int16 vec_lambda[8], vec_preoff[8];
; 1160 :   vec_lambda[0] = simd_w97_rem[step_idx];

	mov	cx, WORD PTR ?simd_w97_rem@@3PAFA[eax*2]

; 1161 :   vec_preoff[0] = simd_w97_preoff[step_idx];

	mov	ax, WORD PTR ?simd_w97_preoff@@3PAFA[eax*2]
	mov	WORD PTR _vec_lambda$[ebp], cx
	mov	WORD PTR _vec_preoff$[ebp], ax

; 1162 :   for (int k=1; k < 8; k++)
; 1163 :     {
; 1164 :       vec_lambda[k] = vec_lambda[0];

	mov	WORD PTR _vec_lambda$[ebp+2], cx

; 1165 :       vec_preoff[k] = vec_preoff[0];

	mov	WORD PTR _vec_preoff$[ebp+2], ax
	mov	WORD PTR _vec_lambda$[ebp+4], cx
	mov	WORD PTR _vec_preoff$[ebp+4], ax
	mov	WORD PTR _vec_lambda$[ebp+6], cx
	mov	WORD PTR _vec_preoff$[ebp+6], ax
	mov	WORD PTR _vec_lambda$[ebp+8], cx
	mov	WORD PTR _vec_preoff$[ebp+8], ax
	mov	WORD PTR _vec_lambda$[ebp+10], cx
	mov	WORD PTR _vec_preoff$[ebp+10], ax
	mov	WORD PTR _vec_lambda$[ebp+12], cx
	mov	WORD PTR _vec_preoff$[ebp+12], ax
	mov	WORD PTR _vec_lambda$[ebp+14], cx
	mov	WORD PTR _vec_preoff$[ebp+14], ax
	push	edi

; 1166 :     }
; 1167 : 
; 1168 : #ifndef KDU_NO_SSE
; 1169 :   if (kdu_mmx_level >= 2)

	cmp	edx, 2
	jl	$LN7@simd_W9X7_

; 1172 :         {         
; 1173 :           MOV EDX,samples // Set limit for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 1174 :           MOV EAX,src1

	mov	eax, DWORD PTR _src1$GSCopy$[ebp]

; 1175 :           MOV EBX,src2

	mov	ebx, DWORD PTR _src2$GSCopy$[ebp]

; 1176 :           MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$GSCopy$[ebp]

; 1177 :           MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$GSCopy$[ebp]

; 1178 :           MOVDQU XMM0,vec_lambda

	movdqu	xmm0, XMMWORD PTR _vec_lambda$[ebp]

; 1179 :           MOVDQU XMM1,vec_preoff

	movdqu	xmm1, XMMWORD PTR _vec_preoff$[ebp]

; 1180 :           MOV ECX,step_idx

	mov	ecx, DWORD PTR _step_idx$[ebp]

; 1181 :           CMP ECX,3

	cmp	ecx, 3

; 1182 :           JZ start_step3_synth128

	je	$start_step3_synth128$23

; 1183 :           CMP ECX,2

	cmp	ecx, 2

; 1184 :           JZ start_step2_synth128

	je	$start_step2_synth128$24

; 1185 :           CMP ECX,1

	cmp	ecx, 1

; 1186 :           JZ start_step1_synth128

	je	SHORT $start_step1_synth128$25

; 1187 : 
; 1188 :           XOR ECX,ECX   // Not really necessary

	xor	ecx, ecx

; 1189 :           MOVDQA XMM2,[EAX]    // Load initial 8 source 1 samples

	movdqa	xmm2, XMMWORD PTR [eax]

; 1190 :           PADDW XMM2,[EBX]    // Add in initial 8 source 2 samples

	paddw	xmm2, XMMWORD PTR [ebx]
$loop_step0_synth128$26:

; 1191 : loop_step0_synth128:
; 1192 :           MOVDQA XMM3,[ESI+2*ECX]

	movdqa	xmm3, XMMWORD PTR [esi+ecx*2]

; 1193 :           PADDW XMM3,XMM2     // Here is a -1 contribution

	paddw	xmm3, xmm2

; 1194 :           PADDW XMM3,XMM2     // Here is another -1 contribution

	paddw	xmm3, xmm2

; 1195 :           PADDW XMM2,XMM1     // Add pre-offset for rounding

	paddw	xmm2, xmm1

; 1196 :           PMULHW XMM2,XMM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	xmm2, xmm0

; 1197 :           PSUBW XMM3,XMM2     // Final contribution

	psubw	xmm3, xmm2

; 1198 :           MOVDQA XMM2,[EAX+2*ECX+16]   // Load 8 source 1 samples ahead

	movdqa	xmm2, XMMWORD PTR [eax+ecx*2+16]

; 1199 :           PADDW XMM2,[EBX+2*ECX+16]   // Add 8 source 2 samples ahead

	paddw	xmm2, XMMWORD PTR [ebx+ecx*2+16]

; 1200 :           MOVDQA [EDI+2*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*2], xmm3

; 1201 :           ADD ECX,8

	add	ecx, 8

; 1202 :           CMP ECX,EDX

	cmp	ecx, edx

; 1203 :           JL loop_step0_synth128

	jl	SHORT $loop_step0_synth128$26

; 1204 :           JMP end_synth128

	jmp	$end_synth128$27
$start_step1_synth128$25:

; 1205 : 
; 1206 : start_step1_synth128:
; 1207 :           XOR ECX,ECX       // Zero sample counter

	xor	ecx, ecx

; 1208 :           PXOR XMM6,XMM6    // Set XMM6 to 0's

	pxor	xmm6, xmm6

; 1209 :           PCMPEQW XMM7,XMM7 // Set XMM7 to 1's

	pcmpeqw	xmm7, xmm7

; 1210 :           PSUBW XMM6,XMM7   // Leaves each word in MM6 equal to 1

	psubw	xmm6, xmm7

; 1211 :           PSLLW XMM6,2      // Leave each word in XMM6 = 4 (rounding offset)

	psllw	xmm6, 2

; 1212 :           PXOR XMM4,XMM4

	pxor	xmm4, xmm4

; 1213 :           PSUBW XMM4,[EBX] // Load 8 negated source 2 samples

	psubw	xmm4, XMMWORD PTR [ebx]
$loop_step1_synth128$28:

; 1214 : loop_step1_synth128:
; 1215 :           PMULHW XMM4,XMM0  // -src2 samples times lambda, discarding 16 LSBs

	pmulhw	xmm4, xmm0

; 1216 :           MOVDQA XMM2,[EAX+2*ECX] // Load 8 source 1 samples

	movdqa	xmm2, XMMWORD PTR [eax+ecx*2]

; 1217 :           PMULHW XMM2,XMM0  // src1 samples times lambda, discarding 16 LSBs

	pmulhw	xmm2, xmm0

; 1218 :           MOVDQA XMM3,[ESI+2*ECX]

	movdqa	xmm3, XMMWORD PTR [esi+ecx*2]

; 1219 :           PSUBW XMM2,XMM4  // Subtract neg product from non-negated product

	psubw	xmm2, xmm4

; 1220 :           PXOR XMM4,XMM4

	pxor	xmm4, xmm4

; 1221 :           PSUBW XMM4,[EBX+2*ECX+16] // Load 8 negated source 2 samples ahead

	psubw	xmm4, XMMWORD PTR [ebx+ecx*2+16]

; 1222 :           PADDW XMM2,XMM6  // Add post-offset for rounding

	paddw	xmm2, xmm6

; 1223 :           PSRAW XMM2,3      // Shift result to the right by 3

	psraw	xmm2, 3

; 1224 :           PSUBW XMM3,XMM2  // Update destination samples

	psubw	xmm3, xmm2

; 1225 :           MOVDQA [EDI+2*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*2], xmm3

; 1226 :           ADD ECX,8

	add	ecx, 8

; 1227 :           CMP ECX,EDX

	cmp	ecx, edx

; 1228 :           JL loop_step1_synth128

	jl	SHORT $loop_step1_synth128$28

; 1229 :           JMP end_synth128

	jmp	SHORT $end_synth128$27
$start_step2_synth128$24:

; 1230 : 
; 1231 : start_step2_synth128:
; 1232 :           XOR ECX,ECX          // Zero sample counter

	xor	ecx, ecx

; 1233 :           MOVDQA XMM2,[EAX]    // Load initial 8 source 1 samples

	movdqa	xmm2, XMMWORD PTR [eax]

; 1234 :           PADDW XMM2,[EBX]    // Add in initial 8 source 2 samples

	paddw	xmm2, XMMWORD PTR [ebx]
$loop_step2_synth128$29:

; 1235 : loop_step2_synth128:
; 1236 :           MOVDQA XMM3,[ESI+2*ECX]

	movdqa	xmm3, XMMWORD PTR [esi+ecx*2]

; 1237 :           PSUBW XMM3,XMM2     // Here is a +1 contribution

	psubw	xmm3, xmm2

; 1238 :           PADDW XMM2,XMM1     // Add pre-offset for rounding

	paddw	xmm2, xmm1

; 1239 :           PMULHW XMM2,XMM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	xmm2, xmm0

; 1240 :           PSUBW XMM3,XMM2     // Final contribution

	psubw	xmm3, xmm2

; 1241 :           MOVDQA XMM2,[EAX+2*ECX+16]   // Load next 8 source 1 words ahead

	movdqa	xmm2, XMMWORD PTR [eax+ecx*2+16]

; 1242 :           PADDW XMM2,[EBX+2*ECX+16]   // Add in next 8 source 2 words ahead

	paddw	xmm2, XMMWORD PTR [ebx+ecx*2+16]

; 1243 :           MOVDQA [EDI+2*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*2], xmm3

; 1244 :           ADD ECX,8

	add	ecx, 8

; 1245 :           CMP ECX,EDX

	cmp	ecx, edx

; 1246 :           JL loop_step2_synth128

	jl	SHORT $loop_step2_synth128$29

; 1247 :           JMP end_synth128

	jmp	SHORT $end_synth128$27
$start_step3_synth128$23:

; 1248 : 
; 1249 : start_step3_synth128:
; 1250 :           XOR ECX,ECX           // Zero sample counter

	xor	ecx, ecx

; 1251 :           MOVDQA XMM2,[EAX]     // Load initial 8 source 1 samples

	movdqa	xmm2, XMMWORD PTR [eax]

; 1252 :           PADDW XMM2,[EBX]     // Add in initial 8 source 2 samples

	paddw	xmm2, XMMWORD PTR [ebx]
$loop_step3_synth128$30:

; 1253 : loop_step3_synth128:
; 1254 :           MOVDQA XMM3,[ESI+2*ECX]

	movdqa	xmm3, XMMWORD PTR [esi+ecx*2]

; 1255 :           PADDW XMM2,XMM1      // Add pre-offset for rounding

	paddw	xmm2, xmm1

; 1256 :           PMULHW XMM2,XMM0      // Multiply by lambda and discard 16 LSB's

	pmulhw	xmm2, xmm0

; 1257 :           PSUBW XMM3,XMM2      // Final contribution

	psubw	xmm3, xmm2

; 1258 :           MOVDQA XMM2,[EAX+2*ECX+16]   // Load next 8 source 1 words ahead

	movdqa	xmm2, XMMWORD PTR [eax+ecx*2+16]

; 1259 :           PADDW XMM2,[EBX+2*ECX+16]   // Add in next 8 source 2 words ahead

	paddw	xmm2, XMMWORD PTR [ebx+ecx*2+16]

; 1260 :           MOVDQA [EDI+2*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*2], xmm3

; 1261 :           ADD ECX,8

	add	ecx, 8

; 1262 :           CMP ECX,EDX

	cmp	ecx, edx

; 1263 :           JL loop_step3_synth128

	jl	SHORT $loop_step3_synth128$30
$end_synth128$27:

; 1170 :     { // Implementation based on 128-bit operands, using SSE/SSE2 instructions
; 1171 :       __asm

	pop	edi
	pop	esi
	pop	ebx

; 1358 :         }
; 1359 :     }
; 1360 :   return true;

	mov	al, 1

; 1361 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@simd_W9X7_:

; 1271 :         {         
; 1272 :           MOV EDX,samples // Set limit for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 1273 :           MOV EAX,src1

	mov	eax, DWORD PTR _src1$GSCopy$[ebp]

; 1274 :           MOV EBX,src2

	mov	ebx, DWORD PTR _src2$GSCopy$[ebp]

; 1275 :           MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$GSCopy$[ebp]

; 1276 :           MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$GSCopy$[ebp]

; 1277 :           MOVQ MM0,vec_lambda

	movq	mm0, MMWORD PTR _vec_lambda$[ebp]

; 1278 :           MOVQ MM1,vec_preoff

	movq	mm1, MMWORD PTR _vec_preoff$[ebp]

; 1279 :           MOV ECX,step_idx

	mov	ecx, DWORD PTR _step_idx$[ebp]

; 1280 :           CMP ECX,3

	cmp	ecx, 3

; 1281 :           JZ start_step3_synth64

	je	$start_step3_synth64$31

; 1282 :           CMP ECX,2

	cmp	ecx, 2

; 1283 :           JZ start_step2_synth64

	je	SHORT $start_step2_synth64$32

; 1284 :           CMP ECX,1

	cmp	ecx, 1

; 1285 :           JZ start_step1_synth64

	je	SHORT $start_step1_synth64$33

; 1286 : 
; 1287 :           XOR ECX,ECX   // Not really necessary

	xor	ecx, ecx
$loop_step0_synth64$34:

; 1288 : loop_step0_synth64:
; 1289 :           MOVQ MM2,[EAX+2*ECX]     // Start with source sample 1

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 1290 :           PADDW MM2,[EBX+2*ECX]   // Add source sample 2

	paddw	mm2, MMWORD PTR [ebx+ecx*2]

; 1291 :           MOVQ MM3,[ESI+2*ECX]

	movq	mm3, MMWORD PTR [esi+ecx*2]

; 1292 :           PADDW MM3,MM2     // Here is a -1 contribution

	paddw	mm3, mm2

; 1293 :           PADDW MM3,MM2     // Here is another -1 contribution

	paddw	mm3, mm2

; 1294 :           PADDW MM2,MM1     // Add pre-offset for rounding

	paddw	mm2, mm1

; 1295 :           PMULHW MM2,MM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 1296 :           PSUBW MM3,MM2     // Final contribution

	psubw	mm3, mm2

; 1297 :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 1298 :           ADD ECX,4

	add	ecx, 4

; 1299 :           CMP ECX,EDX

	cmp	ecx, edx

; 1300 :           JL loop_step0_synth64

	jl	SHORT $loop_step0_synth64$34

; 1301 :           JMP end_synth64

	jmp	$end_synth64$35
$start_step1_synth64$33:

; 1302 : 
; 1303 : start_step1_synth64:
; 1304 :           XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx

; 1305 :           PXOR MM6,MM6    // Set MM6 to 0's

	pxor	mm6, mm6

; 1306 :           PCMPEQW MM7,MM7 // Set MM7 to 1's

	pcmpeqw	mm7, mm7

; 1307 :           PSUBW MM6,MM7   // Leaves each word in MM6 equal to 1

	psubw	mm6, mm7

; 1308 :           PSLLW MM6,2     // Leave each word in MM6 = 4 (rounding offset)

	psllw	mm6, 2
$loop_step1_synth64$36:

; 1309 : loop_step1_synth64:
; 1310 :           MOVQ MM2,[EAX+2*ECX]   // Get source samples 1 to MM2

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 1311 :           PMULHW MM2,MM0         // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 1312 :           PXOR MM4,MM4

	pxor	mm4, mm4

; 1313 :           PSUBW MM4,[EBX+2*ECX] // Get -ve source samples 2 to MM4

	psubw	mm4, MMWORD PTR [ebx+ecx*2]

; 1314 :           PMULHW MM4,MM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	mm4, mm0

; 1315 :           MOVQ MM3,[ESI+2*ECX]

	movq	mm3, MMWORD PTR [esi+ecx*2]

; 1316 :           PSUBW MM2,MM4     // Subtract from non-negated scaled source samples

	psubw	mm2, mm4

; 1317 :           PADDW MM2,MM6     // Add post-offset for rounding

	paddw	mm2, mm6

; 1318 :           PSRAW MM2,3        // Shift result to the right by 3

	psraw	mm2, 3

; 1319 :           PSUBW MM3,MM2     // Update destination samples

	psubw	mm3, mm2

; 1320 :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 1321 :           ADD ECX,4

	add	ecx, 4

; 1322 :           CMP ECX,EDX

	cmp	ecx, edx

; 1323 :           JL loop_step1_synth64

	jl	SHORT $loop_step1_synth64$36

; 1324 :           JMP end_synth64

	jmp	SHORT $end_synth64$35
$start_step2_synth64$32:

; 1325 : 
; 1326 : start_step2_synth64:
; 1327 :           XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx
$loop_step2_synth64$37:

; 1328 : loop_step2_synth64:
; 1329 :           MOVQ MM2,[EAX+2*ECX]     // Start with source sample 1

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 1330 :           PADDW MM2,[EBX+2*ECX]   // Add source sample 2

	paddw	mm2, MMWORD PTR [ebx+ecx*2]

; 1331 :           MOVQ MM3,[ESI+2*ECX]

	movq	mm3, MMWORD PTR [esi+ecx*2]

; 1332 :           PSUBW MM3,MM2     // Here is a +1 contribution

	psubw	mm3, mm2

; 1333 :           PADDW MM2,MM1     // Add pre-offset for rounding

	paddw	mm2, mm1

; 1334 :           PMULHW MM2,MM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 1335 :           PSUBW MM3,MM2     // Final contribution

	psubw	mm3, mm2

; 1336 :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 1337 :           ADD ECX,4

	add	ecx, 4

; 1338 :           CMP ECX,EDX

	cmp	ecx, edx

; 1339 :           JL loop_step2_synth64

	jl	SHORT $loop_step2_synth64$37

; 1340 :           JMP end_synth64

	jmp	SHORT $end_synth64$35
$start_step3_synth64$31:

; 1341 : 
; 1342 : start_step3_synth64:
; 1343 :           XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx
$loop_step3_synth64$38:

; 1344 : loop_step3_synth64:
; 1345 :           MOVQ MM2,[EAX+2*ECX]     // Start with source sample 1

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 1346 :           PADDW MM2,[EBX+2*ECX]   // Add source sample 2

	paddw	mm2, MMWORD PTR [ebx+ecx*2]

; 1347 :           MOVQ MM3,[ESI+2*ECX]

	movq	mm3, MMWORD PTR [esi+ecx*2]

; 1348 :           PADDW MM2,MM1           // Add pre-offset for rounding

	paddw	mm2, mm1

; 1349 :           PMULHW MM2,MM0           // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 1350 :           PSUBW MM3,MM2           // Final contribution

	psubw	mm3, mm2

; 1351 :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 1352 :           ADD ECX,4

	add	ecx, 4

; 1353 :           CMP ECX,EDX

	cmp	ecx, edx

; 1354 :           JL loop_step3_synth64

	jl	SHORT $loop_step3_synth64$38
$end_synth64$35:

; 1355 : 
; 1356 : end_synth64:
; 1357 :           EMMS               // Clear MMX registers for use by FPU

	emms

; 1264 : end_synth128:
; 1265 :         }
; 1266 :     }
; 1267 :   else
; 1268 : #endif // !KDU_NO_SSE
; 1269 :     { // Implementation based on 64-bit operands, using only MMX instructions
; 1270 :       __asm

	pop	edi
	pop	esi
	pop	ebx
$LN21@simd_W9X7_:

; 1361 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_W9X7_v_synth@@YA_NPAF000HPAUkd_lifting_step@@@Z ENDP ; simd_W9X7_v_synth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_W9X7_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_step_idx$ = -48					; size = 4
_dst$GSCopy$ = -44					; size = 4
_src$GSCopy$ = -40					; size = 4
_vec_preoff$ = -36					; size = 16
_vec_lambda$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_samples$ = 16						; size = 4
_step$ = 20						; size = 4
?simd_W9X7_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z PROC ; simd_W9X7_h_synth, COMDAT

; 806  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _src$[ebp]

; 807  :   if (kdu_mmx_level < 1)

	mov	edx, DWORD PTR ?kdu_mmx_level@@3HA	; kdu_mmx_level
	mov	DWORD PTR _src$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _dst$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _step$[ebp]
	cmp	edx, 1
	jge	SHORT $LN5@simd_W9X7_

; 808  :     return false;

	xor	al, al

; 1024 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@simd_W9X7_:

; 809  :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN21@simd_W9X7_

; 810  :     return true;
; 811  :   int step_idx = step->step_idx;

	movzx	eax, BYTE PTR [eax]
	mov	DWORD PTR _step_idx$[ebp], eax
	push	edi

; 812  :   assert((step_idx >= 0) && (step_idx < 4));
; 813  :   kdu_int16 vec_lambda[8], vec_preoff[8];
; 814  :   vec_lambda[0] = simd_w97_rem[step_idx];

	mov	cx, WORD PTR ?simd_w97_rem@@3PAFA[eax*2]

; 815  :   vec_preoff[0] = simd_w97_preoff[step_idx];

	mov	ax, WORD PTR ?simd_w97_preoff@@3PAFA[eax*2]
	mov	WORD PTR _vec_lambda$[ebp], cx
	mov	WORD PTR _vec_preoff$[ebp], ax

; 816  :   for (int k=1; k < 8; k++)
; 817  :     {
; 818  :       vec_lambda[k] = vec_lambda[0];

	mov	WORD PTR _vec_lambda$[ebp+2], cx

; 819  :       vec_preoff[k] = vec_preoff[0];

	mov	WORD PTR _vec_preoff$[ebp+2], ax
	mov	WORD PTR _vec_lambda$[ebp+4], cx
	mov	WORD PTR _vec_preoff$[ebp+4], ax
	mov	WORD PTR _vec_lambda$[ebp+6], cx
	mov	WORD PTR _vec_preoff$[ebp+6], ax
	mov	WORD PTR _vec_lambda$[ebp+8], cx
	mov	WORD PTR _vec_preoff$[ebp+8], ax
	mov	WORD PTR _vec_lambda$[ebp+10], cx
	mov	WORD PTR _vec_preoff$[ebp+10], ax
	mov	WORD PTR _vec_lambda$[ebp+12], cx
	mov	WORD PTR _vec_preoff$[ebp+12], ax
	mov	WORD PTR _vec_lambda$[ebp+14], cx
	mov	WORD PTR _vec_preoff$[ebp+14], ax

; 820  :     }
; 821  : 
; 822  : #ifndef KDU_NO_SSE
; 823  :   if (kdu_mmx_level >= 2)

	cmp	edx, 2
	jl	$LN7@simd_W9X7_

; 824  :     { // Implementation based on 128-bit operands, using SSE/SSE2 instructions
; 825  :       __asm

	push	ebx

; 826  :         {         
; 827  :           MOV EDX,samples // Set limit for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 828  :           MOV EAX,src     // EAX points to first source sample

	mov	eax, DWORD PTR _src$GSCopy$[ebp]

; 829  :           MOV EBX,EAX

	mov	ebx, eax

; 830  :           ADD EBX,2       // EBX points to second source sample

	add	ebx, 2

; 831  :           TEST EAX,0Fh    // See if EAX is 16-byte aligned

	test	eax, 15					; 0000000fH

; 832  :           JZ eax_aligned

	je	SHORT $eax_aligned$23

; 833  :           XCHG EAX,EBX    // Make sure EAX is the aligned address

	xchg	eax, ebx
$eax_aligned$23:

; 834  : eax_aligned:
; 835  :           MOV EDI,dst

	mov	edi, DWORD PTR _dst$GSCopy$[ebp]

; 836  :           MOVDQU XMM0,vec_lambda

	movdqu	xmm0, XMMWORD PTR _vec_lambda$[ebp]

; 837  :           MOVDQU XMM1,vec_preoff

	movdqu	xmm1, XMMWORD PTR _vec_preoff$[ebp]

; 838  :           MOV ECX,step_idx

	mov	ecx, DWORD PTR _step_idx$[ebp]

; 839  :           CMP ECX,3

	cmp	ecx, 3

; 840  :           JZ start_step3_synth128

	je	$start_step3_synth128$24

; 841  :           CMP ECX,2

	cmp	ecx, 2

; 842  :           JZ start_step2_synth128

	je	$start_step2_synth128$25

; 843  :           CMP ECX,1

	cmp	ecx, 1

; 844  :           JZ start_step1_synth128

	je	SHORT $start_step1_synth128$26

; 845  : 
; 846  :           // Invert Lifting Step 0
; 847  :           XOR ECX,ECX                // Not really necessary

	xor	ecx, ecx

; 848  :           MOVDQA XMM2,[EAX]          // Load initial 8 source 1 samples

	movdqa	xmm2, XMMWORD PTR [eax]

; 849  :           MOVDQU XMM5,[EBX]          // Get initial 8 source 2 samples

	movdqu	xmm5, XMMWORD PTR [ebx]
$loop_step0_synth128$27:

; 850  : loop_step0_synth128:
; 851  :           PADDW XMM2,XMM5

	paddw	xmm2, xmm5

; 852  :           MOVDQA XMM3,[EDI+2*ECX]

	movdqa	xmm3, XMMWORD PTR [edi+ecx*2]

; 853  :           PADDW XMM3,XMM2           // Here is a -1 contribution

	paddw	xmm3, xmm2

; 854  :           PADDW XMM3,XMM2           // Here is another -1 contribution

	paddw	xmm3, xmm2

; 855  :           MOVDQU XMM5,[EBX+2*ECX+16] // Load 8 source 2 samples ahead

	movdqu	xmm5, XMMWORD PTR [ebx+ecx*2+16]

; 856  :           PADDW XMM2,XMM1           // Add pre-offset for rounding

	paddw	xmm2, xmm1

; 857  :           PMULHW XMM2,XMM0           // Multiply by lambda and discard 16 LSB's

	pmulhw	xmm2, xmm0

; 858  :           PSUBW XMM3,XMM2           // Final contribution

	psubw	xmm3, xmm2

; 859  :           MOVDQA XMM2,[EAX+2*ECX+16] // Load next 8 source 1 samples ahead

	movdqa	xmm2, XMMWORD PTR [eax+ecx*2+16]

; 860  :           MOVDQA [EDI+2*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*2], xmm3

; 861  :           ADD ECX,8

	add	ecx, 8

; 862  :           CMP ECX,EDX

	cmp	ecx, edx

; 863  :           JL loop_step0_synth128

	jl	SHORT $loop_step0_synth128$27

; 864  :           JMP end_synth128

	jmp	$end_synth128$28
$start_step1_synth128$26:

; 865  : 
; 866  : start_step1_synth128:
; 867  :           // Invert Lifting Step 1
; 868  :           XOR ECX,ECX                // Zero sample counter

	xor	ecx, ecx

; 869  :           PXOR XMM6,XMM6             // Set XMM6 to 0's

	pxor	xmm6, xmm6

; 870  :           PCMPEQW XMM7,XMM7          // Set XMM7 to 1's

	pcmpeqw	xmm7, xmm7

; 871  :           PSUBW XMM6,XMM7            // Leaves each word in XMM6 equal to 1

	psubw	xmm6, xmm7

; 872  :           PSLLW XMM6,2               // Leave each word in XMM6=4 (round offset)

	psllw	xmm6, 2

; 873  :           MOVDQU XMM5,[EBX]          // Get initial 8 source 2 samples

	movdqu	xmm5, XMMWORD PTR [ebx]
$loop_step1_synth128$29:

; 874  : loop_step1_synth128:
; 875  :           PXOR XMM2,XMM2

	pxor	xmm2, xmm2

; 876  :           MOVDQA XMM4,[EAX+2*ECX]    // Get 8 source 1 samples to XMM4

	movdqa	xmm4, XMMWORD PTR [eax+ecx*2]

; 877  :           PSUBW XMM2,XMM5           // Get -ve source 2 samples in XMM2

	psubw	xmm2, xmm5

; 878  :           MOVDQA XMM3,[EDI+2*ECX]

	movdqa	xmm3, XMMWORD PTR [edi+ecx*2]

; 879  :           PMULHW XMM2,XMM0           // x lambda and discard 16 LSB's

	pmulhw	xmm2, xmm0

; 880  :           PMULHW XMM4,XMM0           // x lambda and discard 16 LSB's

	pmulhw	xmm4, xmm0

; 881  :           MOVDQU XMM5,[EBX+2*ECX+16] // Load next 8 source 2 samples ahead

	movdqu	xmm5, XMMWORD PTR [ebx+ecx*2+16]

; 882  :           PSUBW XMM4,XMM2           // Subtract neg from non-negated product

	psubw	xmm4, xmm2

; 883  :           PADDW XMM4,XMM6           // Add post-offset for rounding

	paddw	xmm4, xmm6

; 884  :           PSRAW XMM4,3               // Shift result to the right by 3

	psraw	xmm4, 3

; 885  :           PSUBW XMM3,XMM4           // Update destination samples

	psubw	xmm3, xmm4

; 886  :           MOVDQA [EDI+2*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*2], xmm3

; 887  :           ADD ECX,8

	add	ecx, 8

; 888  :           CMP ECX,EDX

	cmp	ecx, edx

; 889  :           JL loop_step1_synth128

	jl	SHORT $loop_step1_synth128$29

; 890  :           JMP end_synth128

	jmp	SHORT $end_synth128$28
$start_step2_synth128$25:

; 891  : 
; 892  : start_step2_synth128:
; 893  :           // Invert Lifting Step 2
; 894  :           XOR ECX,ECX                // Zero sample counter

	xor	ecx, ecx

; 895  :           MOVDQA XMM2,[EAX]          // Load initial 8 source 1 samples

	movdqa	xmm2, XMMWORD PTR [eax]

; 896  :           MOVDQU XMM5,[EBX]          // Load initial 8 source 2 samples

	movdqu	xmm5, XMMWORD PTR [ebx]
$loop_step2_synth128$30:

; 897  : loop_step2_synth128:
; 898  :           PADDW XMM2,XMM5

	paddw	xmm2, xmm5

; 899  :           MOVDQA XMM3,[EDI+2*ECX]

	movdqa	xmm3, XMMWORD PTR [edi+ecx*2]

; 900  :           PSUBW XMM3,XMM2           // Here is a +1 contribution

	psubw	xmm3, xmm2

; 901  :           PADDW XMM2,XMM1           // Add pre-offset for rounding

	paddw	xmm2, xmm1

; 902  :           MOVDQU XMM5,[EBX+2*ECX+16] // Load next 8 source 2 samples ahead

	movdqu	xmm5, XMMWORD PTR [ebx+ecx*2+16]

; 903  :           PMULHW XMM2,XMM0           // Multiply by lambda and discard 16 LSB's

	pmulhw	xmm2, xmm0

; 904  :           PSUBW XMM3,XMM2           // Final contribution

	psubw	xmm3, xmm2

; 905  :           MOVDQA XMM2,[EAX+2*ECX+16] // Load next 8 source 1 samples ahead

	movdqa	xmm2, XMMWORD PTR [eax+ecx*2+16]

; 906  :           MOVDQA [EDI+2*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*2], xmm3

; 907  :           ADD ECX,8

	add	ecx, 8

; 908  :           CMP ECX,EDX

	cmp	ecx, edx

; 909  :           JL loop_step2_synth128

	jl	SHORT $loop_step2_synth128$30

; 910  :           JMP end_synth128

	jmp	SHORT $end_synth128$28
$start_step3_synth128$24:

; 911  : 
; 912  : start_step3_synth128:
; 913  :           // Invert Lifting Step 3
; 914  :           XOR ECX,ECX                // Zero sample counter

	xor	ecx, ecx

; 915  :           MOVDQA XMM2,[EAX]          // Load initial 8 source 1 samples

	movdqa	xmm2, XMMWORD PTR [eax]

; 916  :           MOVDQU XMM5,[EBX]          // Load initial 8 source 2 samples

	movdqu	xmm5, XMMWORD PTR [ebx]
$loop_step3_synth128$31:

; 917  : loop_step3_synth128:
; 918  :           PADDW XMM2,XMM5

	paddw	xmm2, xmm5

; 919  :           MOVDQA XMM3,[EDI+2*ECX]

	movdqa	xmm3, XMMWORD PTR [edi+ecx*2]

; 920  :           PADDW XMM2,XMM1           // Add pre-offset for rounding

	paddw	xmm2, xmm1

; 921  :           MOVDQU XMM5,[EBX+2*ECX+16] // Load next 8 source 2 samples ahead

	movdqu	xmm5, XMMWORD PTR [ebx+ecx*2+16]

; 922  :           PMULHW XMM2,XMM0           // Multiply by lambda and discard 16 LSB's

	pmulhw	xmm2, xmm0

; 923  :           PSUBW XMM3,XMM2           // Final contribution

	psubw	xmm3, xmm2

; 924  :           MOVDQA XMM2,[EAX+2*ECX+16] // Load next 8 source 1 samples ahead

	movdqa	xmm2, XMMWORD PTR [eax+ecx*2+16]

; 925  :           MOVDQA [EDI+2*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*2], xmm3

; 926  :           ADD ECX,8

	add	ecx, 8

; 927  :           CMP ECX,EDX

	cmp	ecx, edx

; 928  :           JL loop_step3_synth128

	jl	SHORT $loop_step3_synth128$31
$end_synth128$28:

; 824  :     { // Implementation based on 128-bit operands, using SSE/SSE2 instructions
; 825  :       __asm

	pop	ebx
	pop	edi

; 1021 :         }
; 1022 :     }
; 1023 :   return true;

	mov	al, 1

; 1024 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@simd_W9X7_:

; 936  :         {         
; 937  :           MOV EDX,samples // Set limit for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 938  :           MOV EAX,src

	mov	eax, DWORD PTR _src$GSCopy$[ebp]

; 939  :           MOV EDI,dst

	mov	edi, DWORD PTR _dst$GSCopy$[ebp]

; 940  :           MOVQ MM0,vec_lambda

	movq	mm0, MMWORD PTR _vec_lambda$[ebp]

; 941  :           MOVQ MM1,vec_preoff

	movq	mm1, MMWORD PTR _vec_preoff$[ebp]

; 942  :           MOV ECX,step_idx

	mov	ecx, DWORD PTR _step_idx$[ebp]

; 943  :           CMP ECX,3

	cmp	ecx, 3

; 944  :           JZ start_step3_synth64

	je	$start_step3_synth64$32

; 945  :           CMP ECX,2

	cmp	ecx, 2

; 946  :           JZ start_step2_synth64

	je	SHORT $start_step2_synth64$33

; 947  :           CMP ECX,1

	cmp	ecx, 1

; 948  :           JZ start_step1_synth64

	je	SHORT $start_step1_synth64$34

; 949  : 
; 950  :           XOR ECX,ECX   // Not really necessary

	xor	ecx, ecx
$loop_step0_synth64$35:

; 951  : loop_step0_synth64:
; 952  :           MOVQ MM2,[EAX+2*ECX]     // Start with source sample 1

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 953  :           PADDW MM2,[EAX+2*ECX+2]   // Add source sample 2

	paddw	mm2, MMWORD PTR [eax+ecx*2+2]

; 954  :           MOVQ MM3,[EDI+2*ECX]

	movq	mm3, MMWORD PTR [edi+ecx*2]

; 955  :           PADDW MM3,MM2     // Here is a -1 contribution

	paddw	mm3, mm2

; 956  :           PADDW MM3,MM2     // Here is another -1 contribution

	paddw	mm3, mm2

; 957  :           PADDW MM2,MM1     // Add pre-offset for rounding

	paddw	mm2, mm1

; 958  :           PMULHW MM2,MM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 959  :           PSUBW MM3,MM2     // Final contribution

	psubw	mm3, mm2

; 960  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 961  :           ADD ECX,4

	add	ecx, 4

; 962  :           CMP ECX,EDX

	cmp	ecx, edx

; 963  :           JL loop_step0_synth64

	jl	SHORT $loop_step0_synth64$35

; 964  :           JMP end_synth64

	jmp	$end_synth64$36
$start_step1_synth64$34:

; 965  : 
; 966  : start_step1_synth64:
; 967  :           XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx

; 968  :           PXOR MM6,MM6    // Set MM6 to 0's

	pxor	mm6, mm6

; 969  :           PCMPEQW MM7,MM7 // Set MM7 to 1's

	pcmpeqw	mm7, mm7

; 970  :           PSUBW MM6,MM7   // Leaves each word in MM6 equal to 1

	psubw	mm6, mm7

; 971  :           PSLLW MM6,2     // Leave each word in MM6 = 4 (rounding offset)

	psllw	mm6, 2
$loop_step1_synth64$37:

; 972  : loop_step1_synth64:
; 973  :           MOVQ MM2,[EAX+2*ECX]   // Get source samples 1 to MM2

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 974  :           PMULHW MM2,MM0         // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 975  :           PXOR MM4,MM4

	pxor	mm4, mm4

; 976  :           PSUBW MM4,[EAX+2*ECX+2] // Get -ve source samples 2 to MM4

	psubw	mm4, MMWORD PTR [eax+ecx*2+2]

; 977  :           PMULHW MM4,MM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	mm4, mm0

; 978  :           MOVQ MM3,[EDI+2*ECX]

	movq	mm3, MMWORD PTR [edi+ecx*2]

; 979  :           PSUBW MM2,MM4     // Subtract from non-negated scaled source samples

	psubw	mm2, mm4

; 980  :           PADDW MM2,MM6     // Add post-offset for rounding

	paddw	mm2, mm6

; 981  :           PSRAW MM2,3        // Shift result to the right by 3

	psraw	mm2, 3

; 982  :           PSUBW MM3,MM2     // Update destination samples

	psubw	mm3, mm2

; 983  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 984  :           ADD ECX,4

	add	ecx, 4

; 985  :           CMP ECX,EDX

	cmp	ecx, edx

; 986  :           JL loop_step1_synth64

	jl	SHORT $loop_step1_synth64$37

; 987  :           JMP end_synth64

	jmp	SHORT $end_synth64$36
$start_step2_synth64$33:

; 988  : 
; 989  : start_step2_synth64:
; 990  :           XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx
$loop_step2_synth64$38:

; 991  : loop_step2_synth64:
; 992  :           MOVQ MM2,[EAX+2*ECX]     // Start with source sample 1

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 993  :           PADDW MM2,[EAX+2*ECX+2]   // Add source sample 2

	paddw	mm2, MMWORD PTR [eax+ecx*2+2]

; 994  :           MOVQ MM3,[EDI+2*ECX]

	movq	mm3, MMWORD PTR [edi+ecx*2]

; 995  :           PSUBW MM3,MM2     // Here is a +1 contribution

	psubw	mm3, mm2

; 996  :           PADDW MM2,MM1     // Add pre-offset for rounding

	paddw	mm2, mm1

; 997  :           PMULHW MM2,MM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 998  :           PSUBW MM3,MM2     // Final contribution

	psubw	mm3, mm2

; 999  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 1000 :           ADD ECX,4

	add	ecx, 4

; 1001 :           CMP ECX,EDX

	cmp	ecx, edx

; 1002 :           JL loop_step2_synth64

	jl	SHORT $loop_step2_synth64$38

; 1003 :           JMP end_synth64

	jmp	SHORT $end_synth64$36
$start_step3_synth64$32:

; 1004 : 
; 1005 : start_step3_synth64:
; 1006 :           XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx
$loop_step3_synth64$39:

; 1007 : loop_step3_synth64:
; 1008 :           MOVQ MM2,[EAX+2*ECX]     // Start with source sample 1

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 1009 :           PADDW MM2,[EAX+2*ECX+2]   // Add source sample 2

	paddw	mm2, MMWORD PTR [eax+ecx*2+2]

; 1010 :           MOVQ MM3,[EDI+2*ECX]

	movq	mm3, MMWORD PTR [edi+ecx*2]

; 1011 :           PADDW MM2,MM1           // Add pre-offset for rounding

	paddw	mm2, mm1

; 1012 :           PMULHW MM2,MM0           // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 1013 :           PSUBW MM3,MM2           // Final contribution

	psubw	mm3, mm2

; 1014 :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 1015 :           ADD ECX,4

	add	ecx, 4

; 1016 :           CMP ECX,EDX

	cmp	ecx, edx

; 1017 :           JL loop_step3_synth64

	jl	SHORT $loop_step3_synth64$39
$end_synth64$36:

; 1018 : 
; 1019 : end_synth64:
; 1020 :           EMMS               // Clear MMX registers for use by FPU

	emms

; 929  : end_synth128:
; 930  :         }
; 931  :     }
; 932  :   else
; 933  : #endif // !KDU_NO_SSE
; 934  :     { // Implementation based on 64-bit operands using only MMX instructions
; 935  :       __asm

	pop	edi
$LN21@simd_W9X7_:

; 1024 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_W9X7_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z ENDP ; simd_W9X7_h_synth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_W5X3_v_synth@@YA_NPAF000HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_int_coeff$ = -44					; size = 4
_downshift$ = -40					; size = 4
_dst_out$GSCopy$ = -36					; size = 4
_dst_in$GSCopy$ = -32					; size = 4
_src2$GSCopy$ = -28					; size = 4
_src1$GSCopy$ = -24					; size = 4
_vec_offset$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_dst_in$ = 16						; size = 4
_dst_out$ = 20						; size = 4
_samples$ = 24						; size = 4
_step$ = 28						; size = 4
?simd_W5X3_v_synth@@YA_NPAF000HPAUkd_lifting_step@@@Z PROC ; simd_W5X3_v_synth, COMDAT

; 583  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _src1$[ebp]

; 584  :   assert((step->support_length == 2) && (step->icoeffs[0]==step->icoeffs[1]));
; 585  :   if (kdu_mmx_level < 1)

	mov	edx, DWORD PTR ?kdu_mmx_level@@3HA	; kdu_mmx_level
	mov	DWORD PTR _src1$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _src2$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst_in$[ebp]
	mov	DWORD PTR _dst_in$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst_out$[ebp]
	mov	DWORD PTR _dst_out$GSCopy$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _step$[ebp]
	cmp	edx, 1
	jge	SHORT $LN5@simd_W5X3_

; 586  :     return false;

	xor	al, al
	pop	esi

; 682  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@simd_W5X3_:

; 587  :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN21@simd_W5X3_

; 588  :     return true;
; 589  : 
; 590  :   kdu_int16 vec_offset[8];
; 591  :   vec_offset[0] = (kdu_int16)((1<<step->downshift)>>1);

	movzx	ecx, BYTE PTR [esi+2]
	mov	eax, 1
	shl	eax, cl
	sar	eax, 1
	mov	WORD PTR _vec_offset$[ebp], ax

; 592  :   for (int k=1; k < 8; k++)
; 593  :     vec_offset[k] = vec_offset[0];

	mov	WORD PTR _vec_offset$[ebp+2], ax
	mov	WORD PTR _vec_offset$[ebp+4], ax
	mov	WORD PTR _vec_offset$[ebp+6], ax
	mov	WORD PTR _vec_offset$[ebp+8], ax
	mov	WORD PTR _vec_offset$[ebp+10], ax
	mov	WORD PTR _vec_offset$[ebp+12], ax
	mov	WORD PTR _vec_offset$[ebp+14], ax

; 594  :   int int_coeff = step->icoeffs[0];

	mov	eax, DWORD PTR [esi+12]

; 595  :   int downshift = step->downshift;

	mov	DWORD PTR _downshift$[ebp], ecx
	push	ebx
	push	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _int_coeff$[ebp], eax

; 596  :   assert((int_coeff == 1) || (int_coeff == -1));
; 597  : 
; 598  : #ifndef KDU_NO_SSE
; 599  :   if (kdu_mmx_level >= 2)

	cmp	edx, 2
	jl	$LN7@simd_W5X3_

; 602  :         MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 603  :         MOV EAX,src1

	mov	eax, DWORD PTR _src1$GSCopy$[ebp]

; 604  :         MOV EBX,src2

	mov	ebx, DWORD PTR _src2$GSCopy$[ebp]

; 605  :         MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$GSCopy$[ebp]

; 606  :         MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$GSCopy$[ebp]

; 607  :         MOVDQU XMM0,vec_offset

	movdqu	xmm0, XMMWORD PTR _vec_offset$[ebp]

; 608  :         MOVD XMM1,downshift

	movd	xmm1, DWORD PTR _downshift$[ebp]

; 609  :         MOV ECX,int_coeff

	mov	ecx, DWORD PTR _int_coeff$[ebp]

; 610  :         CMP ECX,1

	cmp	ecx, 1

; 611  :         MOV ECX,0  // Set up sample counter, without altering status flags

	mov	ecx, 0

; 612  :         JNE loop_minus1_synth128

	jne	SHORT $loop_minus1_synth128$23
$loop_plus1_synth128$24:

; 613  : loop_plus1_synth128:
; 614  :           MOVDQA XMM2,XMM0          // start with the offset

	movdqa	xmm2, xmm0

; 615  :           PADDW XMM2,[EAX+2*ECX]   // add 1'st source sample

	paddw	xmm2, XMMWORD PTR [eax+ecx*2]

; 616  :           PADDW XMM2,[EBX+2*ECX]   // add 2'nd source sample

	paddw	xmm2, XMMWORD PTR [ebx+ecx*2]

; 617  :           MOVDQA XMM3,[ESI+2*ECX]

	movdqa	xmm3, XMMWORD PTR [esi+ecx*2]

; 618  :           PSRAW XMM2,XMM1           // shift rigth by the `downshift' value

	psraw	xmm2, xmm1

; 619  :           PSUBW XMM3,XMM2          // subtract from dest sample

	psubw	xmm3, xmm2

; 620  :           MOVDQA [EDI+2*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*2], xmm3

; 621  :           ADD ECX,8

	add	ecx, 8

; 622  :           CMP ECX,EDX

	cmp	ecx, edx

; 623  :           JL loop_plus1_synth128

	jl	SHORT $loop_plus1_synth128$24

; 624  :         JMP end_synth128

	jmp	SHORT $end_synth128$25
$loop_minus1_synth128$23:

; 625  : loop_minus1_synth128:
; 626  :           MOVDQA XMM2,XMM0          // start with the offset

	movdqa	xmm2, xmm0

; 627  :           PSUBW XMM2,[EAX+2*ECX]   // subtract 1'st source sample

	psubw	xmm2, XMMWORD PTR [eax+ecx*2]

; 628  :           PSUBW XMM2,[EBX+2*ECX]   // subtract 2'nd source sample

	psubw	xmm2, XMMWORD PTR [ebx+ecx*2]

; 629  :           MOVDQA XMM3,[ESI+2*ECX]

	movdqa	xmm3, XMMWORD PTR [esi+ecx*2]

; 630  :           PSRAW XMM2,XMM1           // shift rigth by the `downshift' value

	psraw	xmm2, xmm1

; 631  :           PSUBW XMM3,XMM2          // subtract from dest sample

	psubw	xmm3, xmm2

; 632  :           MOVDQA [EDI+2*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*2], xmm3

; 633  :           ADD ECX,8

	add	ecx, 8

; 634  :           CMP ECX,EDX

	cmp	ecx, edx

; 635  :           JL loop_minus1_synth128

	jl	SHORT $loop_minus1_synth128$23
$end_synth128$25:

; 600  :     { // Implementation based on 128-bit operands using SSE/SSE2 instructions
; 601  :       __asm {

	pop	edi
	pop	ebx

; 679  :       }
; 680  :     }
; 681  :   return true;

	mov	al, 1
	pop	esi

; 682  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@simd_W5X3_:

; 643  :         MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 644  :         MOV EAX,src1

	mov	eax, DWORD PTR _src1$GSCopy$[ebp]

; 645  :         MOV EBX,src2

	mov	ebx, DWORD PTR _src2$GSCopy$[ebp]

; 646  :         MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$GSCopy$[ebp]

; 647  :         MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$GSCopy$[ebp]

; 648  :         MOVQ MM0,vec_offset

	movq	mm0, MMWORD PTR _vec_offset$[ebp]

; 649  :         MOVD MM1,downshift

	movd	mm1, DWORD PTR _downshift$[ebp]

; 650  :         MOV ECX,int_coeff

	mov	ecx, DWORD PTR _int_coeff$[ebp]

; 651  :         CMP ECX,1

	cmp	ecx, 1

; 652  :         MOV ECX,0  // Set up sample counter, without altering status flags

	mov	ecx, 0

; 653  :         JNE loop_minus1_synth64

	jne	SHORT $loop_minus1_synth64$26
$loop_plus1_synth64$27:

; 654  : loop_plus1_synth64:
; 655  :           MOVQ MM2,MM0             // start with the offset

	movq	mm2, mm0

; 656  :           PADDW MM2,[EAX+2*ECX]   // add 1'st source sample

	paddw	mm2, MMWORD PTR [eax+ecx*2]

; 657  :           PADDW MM2,[EBX+2*ECX]   // add 2'nd source sample

	paddw	mm2, MMWORD PTR [ebx+ecx*2]

; 658  :           MOVQ MM3,[ESI+2*ECX]

	movq	mm3, MMWORD PTR [esi+ecx*2]

; 659  :           PSRAW MM2,MM1            // shift rigth by the `downshift' value

	psraw	mm2, mm1

; 660  :           PSUBW MM3,MM2           // subtract from dest sample

	psubw	mm3, mm2

; 661  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 662  :           ADD ECX,4

	add	ecx, 4

; 663  :           CMP ECX,EDX

	cmp	ecx, edx

; 664  :           JL loop_plus1_synth64

	jl	SHORT $loop_plus1_synth64$27

; 665  :         JMP end_synth64

	jmp	SHORT $end_synth64$28
$loop_minus1_synth64$26:

; 666  : loop_minus1_synth64:
; 667  :           MOVQ MM2,MM0             // start with the offset

	movq	mm2, mm0

; 668  :           PSUBW MM2,[EAX+2*ECX]   // subtract 1'st source sample

	psubw	mm2, MMWORD PTR [eax+ecx*2]

; 669  :           PSUBW MM2,[EBX+2*ECX]   // subtract 2'nd source sample

	psubw	mm2, MMWORD PTR [ebx+ecx*2]

; 670  :           MOVQ MM3,[ESI+2*ECX]

	movq	mm3, MMWORD PTR [esi+ecx*2]

; 671  :           PSRAW MM2,MM1            // shift rigth by the `downshift' value

	psraw	mm2, mm1

; 672  :           PSUBW MM3,MM2           // subtract from dest sample

	psubw	mm3, mm2

; 673  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 674  :           ADD ECX,4

	add	ecx, 4

; 675  :           CMP ECX,EDX

	cmp	ecx, edx

; 676  :           JL loop_minus1_synth64

	jl	SHORT $loop_minus1_synth64$26
$end_synth64$28:

; 677  : end_synth64:
; 678  :         EMMS // Clear MMX registers for use by FPU

	emms

; 636  : end_synth128:
; 637  :       }
; 638  :     }
; 639  :   else
; 640  : #endif // !KDU_NO_SSE
; 641  :     { // Implementation based on 64-bit operands using only MMX instructions
; 642  :       __asm {

	pop	edi
	pop	ebx
$LN21@simd_W5X3_:

; 682  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_W5X3_v_synth@@YA_NPAF000HPAUkd_lifting_step@@@Z ENDP ; simd_W5X3_v_synth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_W5X3_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_vec_offset$ = -16					; size = 8
_int_coeff$ = -8					; size = 4
_downshift$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_samples$ = 16						; size = 4
_step$ = 20						; size = 4
?simd_W5X3_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z PROC ; simd_W5X3_h_synth, COMDAT

; 454  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 455  :   assert((step->support_length == 2) && (step->icoeffs[0]==step->icoeffs[1]));
; 456  :   if (kdu_mmx_level < 1)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 1	; kdu_mmx_level
	jge	SHORT $LN2@simd_W5X3_

; 457  :     return false;

	xor	al, al

; 506  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_W5X3_:

; 458  :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN5@simd_W5X3_

; 459  :     return true;
; 460  : 
; 461  :   kdu_int16 vec_offset[4];
; 462  :   vec_offset[0] = vec_offset[1] = vec_offset[2] =

	mov	edx, DWORD PTR _step$[ebp]
	mov	eax, 1
	push	ebx
	push	edi
	movzx	ecx, BYTE PTR [edx+2]
	shl	eax, cl
	sar	eax, 1
	mov	WORD PTR _vec_offset$[ebp+6], ax
	mov	WORD PTR _vec_offset$[ebp+4], ax
	mov	WORD PTR _vec_offset$[ebp+2], ax
	mov	WORD PTR _vec_offset$[ebp], ax

; 463  :     vec_offset[3] = (kdu_int16)((1<<step->downshift)>>1);
; 464  :   int int_coeff = step->icoeffs[0];

	mov	eax, DWORD PTR [edx+12]

; 465  :   int downshift = step->downshift;

	mov	DWORD PTR _downshift$[ebp], ecx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _int_coeff$[ebp], eax

; 470  :         XOR ECX,ECX     // Zero out sample counter

	xor	ecx, ecx

; 471  :         MOV EDX,samples // Limit for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 472  :         MOV EAX,src

	mov	eax, DWORD PTR _src$[ebp]

; 473  :         MOV EDI,dst

	mov	edi, DWORD PTR _dst$[ebp]

; 474  :         MOVQ MM0,vec_offset

	movq	mm0, MMWORD PTR _vec_offset$[ebp]

; 475  :         MOVD MM1,downshift

	movd	mm1, DWORD PTR _downshift$[ebp]

; 476  :         MOV EBX,int_coeff

	mov	ebx, DWORD PTR _int_coeff$[ebp]

; 477  :         CMP EBX,1

	cmp	ebx, 1

; 478  :         JNE loop_minus1_synth64

	jne	SHORT $loop_minus1_synth64$7
$loop_plus1_synth64$8:

; 479  : loop_plus1_synth64:
; 480  :           MOVQ MM2,MM0               // start with the offset

	movq	mm2, mm0

; 481  :           PADDW MM2,[EAX+2*ECX]     // add 1'st source sample

	paddw	mm2, MMWORD PTR [eax+ecx*2]

; 482  :           PADDW MM2,[EAX+2*ECX+2]   // add 2'nd source sample

	paddw	mm2, MMWORD PTR [eax+ecx*2+2]

; 483  :           MOVQ MM3,[EDI+2*ECX]

	movq	mm3, MMWORD PTR [edi+ecx*2]

; 484  :           PSRAW MM2,MM1              // shift rigth by the `downshift' value

	psraw	mm2, mm1

; 485  :           PSUBW MM3,MM2             // subtract from dest sample

	psubw	mm3, mm2

; 486  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 487  :           ADD ECX,4

	add	ecx, 4

; 488  :           CMP ECX,EDX

	cmp	ecx, edx

; 489  :           JL loop_plus1_synth64

	jl	SHORT $loop_plus1_synth64$8

; 490  :         JMP end_synth64

	jmp	SHORT $end_synth64$9
$loop_minus1_synth64$7:

; 491  : loop_minus1_synth64:
; 492  :           MOVQ MM2,MM0               // start with the offset

	movq	mm2, mm0

; 493  :           PSUBW MM2,[EAX+2*ECX]     // subtract 1'st source sample

	psubw	mm2, MMWORD PTR [eax+ecx*2]

; 494  :           PSUBW MM2,[EAX+2*ECX+2]   // subtract 2'nd source sample

	psubw	mm2, MMWORD PTR [eax+ecx*2+2]

; 495  :           MOVQ MM3,[EDI+2*ECX]

	movq	mm3, MMWORD PTR [edi+ecx*2]

; 496  :           PSRAW MM2,MM1              // shift rigth by the `downshift' value

	psraw	mm2, mm1

; 497  :           PSUBW MM3,MM2             // subtract from dest sample

	psubw	mm3, mm2

; 498  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 499  :           ADD ECX,4

	add	ecx, 4

; 500  :           CMP ECX,EDX

	cmp	ecx, edx

; 501  :           JL loop_minus1_synth64

	jl	SHORT $loop_minus1_synth64$7
$end_synth64$9:

; 502  : end_synth64:
; 503  :         EMMS // Clear MMX registers for use by FPU

	emms

; 466  :   assert((int_coeff == 1) || (int_coeff == -1));
; 467  : 
; 468  :   // Implementation based on 64-bit operands using only MMX instructions
; 469  :   __asm {

	pop	edi
	pop	ebx
$LN5@simd_W5X3_:

; 504  :     }
; 505  :   return true;

	mov	al, 1

; 506  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?simd_W5X3_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z ENDP ; simd_W5X3_h_synth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_4tap_v_synth@@YA_NPAF00000HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_vec_offset$ = -52					; size = 16
_vec_lambda2$ = -36					; size = 16
_vec_lambda1$ = -20					; size = 16
_downshift$ = -4					; size = 4
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_src3$ = 16						; size = 4
_src4$ = 20						; size = 4
_dst_in$ = 24						; size = 4
_dst_out$ = 28						; size = 4
_samples$ = 32						; size = 4
_step$ = 36						; size = 4
?simd_4tap_v_synth@@YA_NPAF00000HPAUkd_lifting_step@@@Z PROC ; simd_4tap_v_synth, COMDAT

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 309  : #ifdef KDU_NO_SSE
; 310  :   return false;
; 311  : #else
; 312  :   assert((step->support_length >= 3) || (step->support_length <= 4));
; 313  :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	jge	SHORT $LN2@simd_4tap_

; 314  :     return false;

	xor	al, al

; 381  : #endif // !KDU_NO_SSE
; 382  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_4tap_:

; 315  :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN7@simd_4tap_

; 316  :     return true;
; 317  : 
; 318  :   union {
; 319  :       kdu_int16 word[8];
; 320  :       kdu_int32 dword[4];
; 321  :     } vec_lambda1, vec_lambda2;
; 322  : 
; 323  :   kdu_int32 vec_offset[4];
; 324  :   int downshift = step->downshift;

	mov	edx, DWORD PTR _step$[ebp]

; 325  :   vec_lambda1.word[0] = step->icoeffs[0];
; 326  :   vec_lambda1.word[1] = step->icoeffs[1];
; 327  :   vec_lambda2.word[0] = step->icoeffs[2];
; 328  :   vec_lambda2.word[1] = (step->support_length==4)?(step->icoeffs[3]):0;

	cmp	BYTE PTR [edx+1], 4
	mov	ecx, DWORD PTR [edx+12]
	movzx	eax, BYTE PTR [edx+2]
	mov	DWORD PTR _downshift$[ebp], eax
	movzx	eax, WORD PTR [ecx]
	mov	WORD PTR _vec_lambda1$[ebp], ax
	movzx	eax, WORD PTR [ecx+4]
	mov	WORD PTR _vec_lambda1$[ebp+2], ax
	movzx	eax, WORD PTR [ecx+8]
	mov	WORD PTR _vec_lambda2$[ebp], ax
	jne	SHORT $LN5@simd_4tap_
	mov	eax, DWORD PTR [ecx+12]
	jmp	SHORT $LN6@simd_4tap_
$LN5@simd_4tap_:
	xor	eax, eax
$LN6@simd_4tap_:

; 329  :   vec_offset[0] = step->rounding_offset;

	movsx	ecx, WORD PTR [edx+6]
	push	ebx
	mov	WORD PTR _vec_lambda2$[ebp+2], ax

; 330  :   vec_lambda1.dword[3] = vec_lambda1.dword[2] =

	mov	eax, DWORD PTR _vec_lambda1$[ebp]
	push	esi
	mov	DWORD PTR _vec_lambda1$[ebp+4], eax
	mov	DWORD PTR _vec_lambda1$[ebp+8], eax
	mov	DWORD PTR _vec_lambda1$[ebp+12], eax

; 331  :     vec_lambda1.dword[1] = vec_lambda1.dword[0];
; 332  :   vec_lambda2.dword[3] = vec_lambda2.dword[2] =

	mov	eax, DWORD PTR _vec_lambda2$[ebp]
	push	edi
	mov	DWORD PTR _vec_offset$[ebp], ecx
	mov	DWORD PTR _vec_lambda2$[ebp+4], eax
	mov	DWORD PTR _vec_lambda2$[ebp+8], eax
	mov	DWORD PTR _vec_lambda2$[ebp+12], eax

; 333  :     vec_lambda2.dword[1] = vec_lambda2.dword[0];
; 334  :   vec_offset[3] = vec_offset[2] = vec_offset[1] = vec_offset[0];

	mov	DWORD PTR _vec_offset$[ebp+4], ecx
	mov	DWORD PTR _vec_offset$[ebp+8], ecx
	mov	DWORD PTR _vec_offset$[ebp+12], ecx

; 337  :       XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx

; 338  :       MOV EAX,src1

	mov	eax, DWORD PTR _src1$[ebp]

; 339  :       MOV EBX,src2

	mov	ebx, DWORD PTR _src2$[ebp]

; 340  :       MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$[ebp]

; 341  :       MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$[ebp]

; 342  :       MOVDQU XMM0,vec_lambda1

	movdqu	xmm0, XMMWORD PTR _vec_lambda1$[ebp]

; 343  :       MOVDQU XMM1,vec_lambda2

	movdqu	xmm1, XMMWORD PTR _vec_lambda2$[ebp]

; 344  :       MOVDQU XMM2,vec_offset

	movdqu	xmm2, XMMWORD PTR _vec_offset$[ebp]
$loop_4tap_synth128$9:

; 345  : loop_4tap_synth128:
; 346  :       MOVDQA XMM3,[EAX+2*ECX]

	movdqa	xmm3, XMMWORD PTR [eax+ecx*2]

; 347  :       MOVDQA XMM4,[EBX+2*ECX]

	movdqa	xmm4, XMMWORD PTR [ebx+ecx*2]

; 348  :       MOVDQA XMM5,XMM3

	movdqa	xmm5, xmm3

; 349  :       PUNPCKHWD XMM3,XMM4

	punpckhwd xmm3, xmm4

; 350  :       PUNPCKLWD XMM5,XMM4

	punpcklwd xmm5, xmm4

; 351  :       mov EDX,src3

	mov	edx, DWORD PTR _src3$[ebp]

; 352  :       PMADDWD XMM3,XMM0

	pmaddwd	xmm3, xmm0

; 353  :       MOVDQA XMM6,[EDX+2*ECX]

	movdqa	xmm6, XMMWORD PTR [edx+ecx*2]

; 354  :       PMADDWD XMM5,XMM0

	pmaddwd	xmm5, xmm0

; 355  : 
; 356  :       mov EDX,src4

	mov	edx, DWORD PTR _src4$[ebp]

; 357  :       MOVDQA XMM7,[EDX+2*ECX]

	movdqa	xmm7, XMMWORD PTR [edx+ecx*2]

; 358  :       MOVDQA XMM4,XMM6

	movdqa	xmm4, xmm6

; 359  :       PUNPCKHWD XMM6,XMM7

	punpckhwd xmm6, xmm7

; 360  :       PUNPCKLWD XMM4,XMM7

	punpcklwd xmm4, xmm7

; 361  :       PMADDWD XMM6,XMM1

	pmaddwd	xmm6, xmm1

; 362  :       PMADDWD XMM4,XMM1

	pmaddwd	xmm4, xmm1

; 363  :       MOVD XMM7,downshift

	movd	xmm7, DWORD PTR _downshift$[ebp]

; 364  :       PADDD XMM3,XMM6  // Form first sum of products

	paddd	xmm3, xmm6

; 365  :       PADDD XMM5,XMM4  // Form second sum of products

	paddd	xmm5, xmm4

; 366  : 
; 367  :       MOVDQA XMM6,[ESI+2*ECX]

	movdqa	xmm6, XMMWORD PTR [esi+ecx*2]

; 368  :       PADDD XMM3,XMM2  // Add offset

	paddd	xmm3, xmm2

; 369  :       PADDD XMM5,XMM2  // Add offset

	paddd	xmm5, xmm2

; 370  :       PSRAD XMM3,XMM7  // Downshift

	psrad	xmm3, xmm7

; 371  :       PSRAD XMM5,XMM7  // Downshift

	psrad	xmm5, xmm7

; 372  : 
; 373  :       PACKSSDW XMM5,XMM3

	packssdw xmm5, xmm3

; 374  :       PSUBW XMM6,XMM5

	psubw	xmm6, xmm5

; 375  :       MOVDQA [EDI+2*ECX],XMM6

	movdqa	XMMWORD PTR [edi+ecx*2], xmm6

; 376  :       ADD ECX,8

	add	ecx, 8

; 377  :       CMP ECX,samples

	cmp	ecx, DWORD PTR _samples$[ebp]

; 378  :       JL loop_4tap_synth128

	jl	SHORT $loop_4tap_synth128$9

; 335  : 
; 336  :   __asm {

	pop	edi
	pop	esi
	pop	ebx
$LN7@simd_4tap_:

; 379  :     }
; 380  :   return true;

	mov	al, 1

; 381  : #endif // !KDU_NO_SSE
; 382  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?simd_4tap_v_synth@@YA_NPAF00000HPAUkd_lifting_step@@@Z ENDP ; simd_4tap_v_synth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_2tap_v_synth@@YA_NPAF000HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_vec_offset$ = -36					; size = 16
_vec_lambda$ = -20					; size = 16
_downshift$ = -4					; size = 4
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_dst_in$ = 16						; size = 4
_dst_out$ = 20						; size = 4
_samples$ = 24						; size = 4
_step$ = 28						; size = 4
?simd_2tap_v_synth@@YA_NPAF000HPAUkd_lifting_step@@@Z PROC ; simd_2tap_v_synth, COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 240  : #ifdef KDU_NO_SSE
; 241  :   return false;
; 242  : #else
; 243  :   assert((step->support_length == 1) || (step->support_length == 2));
; 244  :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	jge	SHORT $LN2@simd_2tap_

; 245  :     return false;

	xor	al, al

; 296  : #endif // !KDU_NO_SSE
; 297  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_2tap_:

; 246  :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN7@simd_2tap_

; 247  :     return true;
; 248  : 
; 249  :   union {
; 250  :       kdu_int16 word[8];
; 251  :       kdu_int32 dword[4];
; 252  :     } vec_lambda;
; 253  :   kdu_int32 vec_offset[4];
; 254  :   int downshift = step->downshift;

	mov	ecx, DWORD PTR _step$[ebp]

; 255  :   vec_lambda.word[0] = step->icoeffs[0];
; 256  :   vec_lambda.word[1] = (step->support_length==2)?(step->icoeffs[1]):0;

	cmp	BYTE PTR [ecx+1], 2
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, BYTE PTR [ecx+2]
	mov	DWORD PTR _downshift$[ebp], eax
	mov	ax, WORD PTR [edx]
	mov	WORD PTR _vec_lambda$[ebp], ax
	jne	SHORT $LN5@simd_2tap_
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $LN6@simd_2tap_
$LN5@simd_2tap_:
	xor	eax, eax
$LN6@simd_2tap_:

; 257  :   vec_offset[0] = step->rounding_offset;

	movsx	ecx, WORD PTR [ecx+6]
	push	ebx
	push	esi
	mov	WORD PTR _vec_lambda$[ebp+2], ax

; 258  :   vec_lambda.dword[3] = vec_lambda.dword[2] =

	mov	eax, DWORD PTR _vec_lambda$[ebp]
	push	edi
	mov	DWORD PTR _vec_offset$[ebp], ecx
	mov	DWORD PTR _vec_lambda$[ebp+4], eax
	mov	DWORD PTR _vec_lambda$[ebp+8], eax
	mov	DWORD PTR _vec_lambda$[ebp+12], eax

; 259  :     vec_lambda.dword[1] = vec_lambda.dword[0];
; 260  :   vec_offset[3] = vec_offset[2] = vec_offset[1] = vec_offset[0];

	mov	DWORD PTR _vec_offset$[ebp+4], ecx
	mov	DWORD PTR _vec_offset$[ebp+8], ecx
	mov	DWORD PTR _vec_offset$[ebp+12], ecx

; 263  :       XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx

; 264  :       MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 265  :       MOV EAX,src1

	mov	eax, DWORD PTR _src1$[ebp]

; 266  :       MOV EBX,src2

	mov	ebx, DWORD PTR _src2$[ebp]

; 267  :       MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$[ebp]

; 268  :       MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$[ebp]

; 269  :       MOVDQU XMM0,vec_lambda

	movdqu	xmm0, XMMWORD PTR _vec_lambda$[ebp]

; 270  :       MOVDQU XMM1,vec_offset

	movdqu	xmm1, XMMWORD PTR _vec_offset$[ebp]

; 271  :       MOVD XMM2,downshift

	movd	xmm2, DWORD PTR _downshift$[ebp]

; 272  :       MOVDQA XMM3,[EAX]

	movdqa	xmm3, XMMWORD PTR [eax]

; 273  :       MOVDQA XMM4,[EBX]

	movdqa	xmm4, XMMWORD PTR [ebx]

; 274  :       MOVDQA XMM5,XMM3

	movdqa	xmm5, xmm3
$loop_2tap_synth128$9:

; 275  : loop_2tap_synth128:
; 276  :       MOVDQA XMM6,[ESI+2*ECX]

	movdqa	xmm6, XMMWORD PTR [esi+ecx*2]

; 277  :       PUNPCKHWD XMM3,XMM4

	punpckhwd xmm3, xmm4

; 278  :       PUNPCKLWD XMM5,XMM4

	punpcklwd xmm5, xmm4

; 279  :       PMADDWD XMM3,XMM0

	pmaddwd	xmm3, xmm0

; 280  :       PMADDWD XMM5,XMM0

	pmaddwd	xmm5, xmm0

; 281  :       PADDD XMM3,XMM1

	paddd	xmm3, xmm1

; 282  :       PADDD XMM5,XMM1

	paddd	xmm5, xmm1

; 283  :       PSRAD XMM3,XMM2

	psrad	xmm3, xmm2

; 284  :       PSRAD XMM5,XMM2

	psrad	xmm5, xmm2

; 285  :       MOVDQA XMM4,[EBX+2*ECX+16] // Read ahead next 8 source 1 words

	movdqa	xmm4, XMMWORD PTR [ebx+ecx*2+16]

; 286  :       PACKSSDW XMM5,XMM3

	packssdw xmm5, xmm3

; 287  :       MOVDQA XMM3,[EAX+2*ECX+16] // Read ahead next 8 source 2 words

	movdqa	xmm3, XMMWORD PTR [eax+ecx*2+16]

; 288  :       PSUBW XMM6,XMM5

	psubw	xmm6, xmm5

; 289  :       MOVDQA [EDI+2*ECX],XMM6

	movdqa	XMMWORD PTR [edi+ecx*2], xmm6

; 290  :       MOVDQA XMM5,XMM3

	movdqa	xmm5, xmm3

; 291  :       ADD ECX,8

	add	ecx, 8

; 292  :       CMP ECX,EDX

	cmp	ecx, edx

; 293  :       JL loop_2tap_synth128

	jl	SHORT $loop_2tap_synth128$9

; 261  : 
; 262  :   __asm {

	pop	edi
	pop	esi
	pop	ebx
$LN7@simd_2tap_:

; 294  :     }
; 295  :   return true;

	mov	al, 1

; 296  : #endif // !KDU_NO_SSE
; 297  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?simd_2tap_v_synth@@YA_NPAF000HPAUkd_lifting_step@@@Z ENDP ; simd_2tap_v_synth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_4tap_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_vec_offset$ = -52					; size = 16
_vec_lambda2$ = -36					; size = 16
_vec_lambda1$ = -20					; size = 16
_downshift$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_samples$ = 16						; size = 4
_step$ = 20						; size = 4
?simd_4tap_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z PROC ; simd_4tap_h_synth, COMDAT

; 156  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 157  : #ifdef KDU_NO_SSE
; 158  :   return false;
; 159  : #else
; 160  :   assert((step->support_length >= 3) || (step->support_length <= 4));
; 161  :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	jge	SHORT $LN2@simd_4tap_

; 162  :     return false;

	xor	al, al

; 221  : #endif // !KDU_NO_SSE
; 222  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_4tap_:

; 163  :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN7@simd_4tap_

; 164  :     return true;
; 165  : 
; 166  :   union {
; 167  :       kdu_int16 word[8];
; 168  :       kdu_int32 dword[4];
; 169  :     } vec_lambda1, vec_lambda2;
; 170  : 
; 171  :   kdu_int32 vec_offset[4];
; 172  :   int downshift = step->downshift;

	mov	edx, DWORD PTR _step$[ebp]

; 173  :   vec_lambda1.word[0] = step->icoeffs[0];
; 174  :   vec_lambda1.word[1] = step->icoeffs[1];
; 175  :   vec_lambda2.word[0] = step->icoeffs[2];
; 176  :   vec_lambda2.word[1] = (step->support_length==4)?(step->icoeffs[3]):0;

	cmp	BYTE PTR [edx+1], 4
	mov	ecx, DWORD PTR [edx+12]
	movzx	eax, BYTE PTR [edx+2]
	mov	DWORD PTR _downshift$[ebp], eax
	movzx	eax, WORD PTR [ecx]
	mov	WORD PTR _vec_lambda1$[ebp], ax
	movzx	eax, WORD PTR [ecx+4]
	mov	WORD PTR _vec_lambda1$[ebp+2], ax
	movzx	eax, WORD PTR [ecx+8]
	mov	WORD PTR _vec_lambda2$[ebp], ax
	jne	SHORT $LN5@simd_4tap_
	mov	eax, DWORD PTR [ecx+12]
	jmp	SHORT $LN6@simd_4tap_
$LN5@simd_4tap_:
	xor	eax, eax
$LN6@simd_4tap_:

; 177  :   vec_offset[0] = step->rounding_offset;

	movsx	ecx, WORD PTR [edx+6]
	mov	WORD PTR _vec_lambda2$[ebp+2], ax

; 178  :   vec_lambda1.dword[3] = vec_lambda1.dword[2] =

	mov	eax, DWORD PTR _vec_lambda1$[ebp]
	mov	DWORD PTR _vec_lambda1$[ebp+4], eax
	mov	DWORD PTR _vec_lambda1$[ebp+8], eax
	mov	DWORD PTR _vec_lambda1$[ebp+12], eax

; 179  :     vec_lambda1.dword[1] = vec_lambda1.dword[0];
; 180  :   vec_lambda2.dword[3] = vec_lambda2.dword[2] =

	mov	eax, DWORD PTR _vec_lambda2$[ebp]
	push	edi
	mov	DWORD PTR _vec_offset$[ebp], ecx
	mov	DWORD PTR _vec_lambda2$[ebp+4], eax
	mov	DWORD PTR _vec_lambda2$[ebp+8], eax
	mov	DWORD PTR _vec_lambda2$[ebp+12], eax

; 181  :     vec_lambda2.dword[1] = vec_lambda2.dword[0];
; 182  :   vec_offset[3] = vec_offset[2] = vec_offset[1] = vec_offset[0];

	mov	DWORD PTR _vec_offset$[ebp+4], ecx
	mov	DWORD PTR _vec_offset$[ebp+8], ecx
	mov	DWORD PTR _vec_offset$[ebp+12], ecx

; 185  :       XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx

; 186  :       MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 187  :       MOV EAX,src

	mov	eax, DWORD PTR _src$[ebp]

; 188  :       MOV EDI,dst

	mov	edi, DWORD PTR _dst$[ebp]

; 189  :       MOVDQU XMM0,vec_lambda1

	movdqu	xmm0, XMMWORD PTR _vec_lambda1$[ebp]

; 190  :       MOVDQU XMM1,vec_lambda2

	movdqu	xmm1, XMMWORD PTR _vec_lambda2$[ebp]

; 191  :       MOVDQU XMM2,vec_offset

	movdqu	xmm2, XMMWORD PTR _vec_offset$[ebp]

; 192  :       MOVD XMM3,downshift

	movd	xmm3, DWORD PTR _downshift$[ebp]

; 193  :       PCMPEQW XMM7,XMM7          // Set XMM7 to 1's

	pcmpeqw	xmm7, xmm7

; 194  :       PSRLD XMM7,16              // Leaves mask for low words in each dword

	psrld	xmm7, 16				; 00000010H
$loop_src_aligned$9:

; 195  : loop_src_aligned:
; 196  :       MOVDQU XMM4,[EAX+2*ECX]

	movdqu	xmm4, XMMWORD PTR [eax+ecx*2]

; 197  :       MOVDQU XMM5,[EAX+2*ECX+4]

	movdqu	xmm5, XMMWORD PTR [eax+ecx*2+4]

; 198  :       PMADDWD XMM4,XMM0  // Multiply by first two lifting step coefficients

	pmaddwd	xmm4, xmm0

; 199  :       PMADDWD XMM5,XMM1  // Multiply by second two lifting step coefficients

	pmaddwd	xmm5, xmm1

; 200  :       MOVDQU XMM6,[EAX+2*ECX+2]

	movdqu	xmm6, XMMWORD PTR [eax+ecx*2+2]

; 201  :       PADDD XMM4,XMM5    // Add products

	paddd	xmm4, xmm5

; 202  :       PADDD XMM4,XMM2    // Add rounding offset

	paddd	xmm4, xmm2

; 203  :       MOVDQU XMM5,[EAX+2*ECX+6]

	movdqu	xmm5, XMMWORD PTR [eax+ecx*2+6]

; 204  :       PSRAD XMM4,XMM3    // Downshift to get results in low-order words

	psrad	xmm4, xmm3

; 205  :       PMADDWD XMM6,XMM0  // Multiply by first two lifting step coefficients

	pmaddwd	xmm6, xmm0

; 206  :       PMADDWD XMM5,XMM1  // Multiply by second two lifting step coefficients

	pmaddwd	xmm5, xmm1

; 207  :       PADDD XMM6,XMM5    // Add products

	paddd	xmm6, xmm5

; 208  :       MOVDQA XMM5,[EDI+2*ECX]

	movdqa	xmm5, XMMWORD PTR [edi+ecx*2]

; 209  :       PADDD XMM6,XMM2    // Add rounding offset

	paddd	xmm6, xmm2

; 210  :       PSRAD XMM6,XMM3    // Downshift to get results in low-order words

	psrad	xmm6, xmm3

; 211  :       PAND XMM4,XMM7   // Zero out high words of XMM4

	pand	xmm4, xmm7

; 212  :       PSLLD XMM6,16    // Move XMM6 results into high words

	pslld	xmm6, 16				; 00000010H

; 213  :       PSUBW XMM5,XMM4

	psubw	xmm5, xmm4

; 214  :       PSUBW XMM5,XMM6

	psubw	xmm5, xmm6

; 215  :       MOVDQA [EDI+2*ECX],XMM5

	movdqa	XMMWORD PTR [edi+ecx*2], xmm5

; 216  :       ADD ECX,8

	add	ecx, 8

; 217  :       CMP ECX,EDX

	cmp	ecx, edx

; 218  :       JL loop_src_aligned

	jl	SHORT $loop_src_aligned$9

; 183  : 
; 184  :   __asm {

	pop	edi
$LN7@simd_4tap_:

; 219  :     }
; 220  :   return true;

	mov	al, 1

; 221  : #endif // !KDU_NO_SSE
; 222  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?simd_4tap_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z ENDP ; simd_4tap_h_synth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_2tap_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_vec_offset$ = -36					; size = 16
_vec_lambda$ = -20					; size = 16
_downshift$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_samples$ = 16						; size = 4
_step$ = 20						; size = 4
?simd_2tap_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z PROC ; simd_2tap_h_synth, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 89   : #ifdef KDU_NO_SSE
; 90   :   return false;
; 91   : #else
; 92   :   assert((step->support_length == 1) || (step->support_length == 2));
; 93   :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	jge	SHORT $LN2@simd_2tap_

; 94   :     return false;

	xor	al, al

; 143  : #endif // !KDU_NO_SSE
; 144  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_2tap_:

; 95   :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN7@simd_2tap_

; 96   :     return true;
; 97   : 
; 98   :   union {
; 99   :       kdu_int16 word[8];
; 100  :       kdu_int32 dword[4];
; 101  :     } vec_lambda;
; 102  :   kdu_int32 vec_offset[4];
; 103  :   int downshift = step->downshift;

	mov	ecx, DWORD PTR _step$[ebp]

; 104  :   vec_lambda.word[0] = step->icoeffs[0];
; 105  :   vec_lambda.word[1] = (step->support_length==2)?(step->icoeffs[1]):0;

	cmp	BYTE PTR [ecx+1], 2
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, BYTE PTR [ecx+2]
	mov	DWORD PTR _downshift$[ebp], eax
	mov	ax, WORD PTR [edx]
	mov	WORD PTR _vec_lambda$[ebp], ax
	jne	SHORT $LN5@simd_2tap_
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $LN6@simd_2tap_
$LN5@simd_2tap_:
	xor	eax, eax
$LN6@simd_2tap_:

; 106  :   vec_offset[0] = step->rounding_offset;

	movsx	ecx, WORD PTR [ecx+6]
	mov	WORD PTR _vec_lambda$[ebp+2], ax

; 107  :   vec_lambda.dword[3] = vec_lambda.dword[2] =

	mov	eax, DWORD PTR _vec_lambda$[ebp]
	push	edi
	mov	DWORD PTR _vec_offset$[ebp], ecx
	mov	DWORD PTR _vec_lambda$[ebp+4], eax
	mov	DWORD PTR _vec_lambda$[ebp+8], eax
	mov	DWORD PTR _vec_lambda$[ebp+12], eax

; 108  :     vec_lambda.dword[1] = vec_lambda.dword[0];
; 109  :   vec_offset[3] = vec_offset[2] = vec_offset[1] = vec_offset[0];

	mov	DWORD PTR _vec_offset$[ebp+4], ecx
	mov	DWORD PTR _vec_offset$[ebp+8], ecx
	mov	DWORD PTR _vec_offset$[ebp+12], ecx

; 112  :       XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx

; 113  :       MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 114  :       MOV EAX,src

	mov	eax, DWORD PTR _src$[ebp]

; 115  :       MOV EDI,dst

	mov	edi, DWORD PTR _dst$[ebp]

; 116  :       MOVDQU XMM0,vec_lambda

	movdqu	xmm0, XMMWORD PTR _vec_lambda$[ebp]

; 117  :       MOVDQU XMM1,vec_offset

	movdqu	xmm1, XMMWORD PTR _vec_offset$[ebp]

; 118  :       MOVD XMM2,downshift

	movd	xmm2, DWORD PTR _downshift$[ebp]

; 119  :       PCMPEQW XMM7,XMM7          // Set XMM7 to 1's

	pcmpeqw	xmm7, xmm7

; 120  :       PSRLD XMM7,16              // Leaves mask for low words in each dword

	psrld	xmm7, 16				; 00000010H

; 121  :       MOVDQU XMM3,[EAX]

	movdqu	xmm3, XMMWORD PTR [eax]

; 122  :       MOVDQU XMM4,[EAX+2]

	movdqu	xmm4, XMMWORD PTR [eax+2]
$loop_src_aligned$9:

; 123  : loop_src_aligned:
; 124  :       PMADDWD XMM3,XMM0

	pmaddwd	xmm3, xmm0

; 125  :       PMADDWD XMM4,XMM0

	pmaddwd	xmm4, xmm0

; 126  :       MOVDQA XMM6,[EDI+2*ECX]

	movdqa	xmm6, XMMWORD PTR [edi+ecx*2]

; 127  :       PADDD XMM3,XMM1

	paddd	xmm3, xmm1

; 128  :       PADDD XMM4,XMM1

	paddd	xmm4, xmm1

; 129  :       PSRAD XMM3,XMM2

	psrad	xmm3, xmm2

; 130  :       PSRAD XMM4,XMM2

	psrad	xmm4, xmm2

; 131  :       PAND XMM3,XMM7   // Zero out high words of XMM3

	pand	xmm3, xmm7

; 132  :       PSLLD XMM4,16    // Move XMM4 results into high words

	pslld	xmm4, 16				; 00000010H

; 133  :       PSUBW XMM6,XMM3

	psubw	xmm6, xmm3

; 134  :       MOVDQU XMM3,[EAX+2*ECX+16]

	movdqu	xmm3, XMMWORD PTR [eax+ecx*2+16]

; 135  :       PSUBW XMM6,XMM4

	psubw	xmm6, xmm4

; 136  :       MOVDQU XMM4,[EAX+2*ECX+18]

	movdqu	xmm4, XMMWORD PTR [eax+ecx*2+18]

; 137  :       MOVDQA [EDI+2*ECX],XMM6

	movdqa	XMMWORD PTR [edi+ecx*2], xmm6

; 138  :       ADD ECX,8

	add	ecx, 8

; 139  :       CMP ECX,EDX

	cmp	ecx, edx

; 140  :       JL loop_src_aligned

	jl	SHORT $loop_src_aligned$9

; 110  : 
; 111  :   __asm {

	pop	edi
$LN7@simd_2tap_:

; 141  :     }
; 142  :   return true;

	mov	al, 1

; 143  : #endif // !KDU_NO_SSE
; 144  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?simd_2tap_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z ENDP ; simd_2tap_h_synth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ??__Esimd_w97_preoff@@YAXXZ
text$di	SEGMENT
tv89 = -8						; size = 8
tv81 = -8						; size = 8
tv75 = -8						; size = 8
??__Esimd_w97_preoff@@YAXXZ PROC			; `dynamic initializer for 'simd_w97_preoff'', COMDAT

; 68   :    (kdu_int16) floor(0.5 + 0.5/W97_FACT_3)};

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 65   :   {(kdu_int16) floor(0.5 + 0.5/(W97_FACT_0+2.0)),

	fld	QWORD PTR __real@3ffb5477208894d9
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv75[ebp]
	cvttsd2si eax, QWORD PTR tv75[ebp]

; 66   :    0,
; 67   :    (kdu_int16) floor(0.5 + 0.5/(W97_FACT_2-1.0)),

	fld	QWORD PTR __real@c00e297d9a2f0174
	fstp	QWORD PTR [esp]
	mov	WORD PTR ?simd_w97_preoff@@3PAFA, ax
	call	_floor
	fstp	QWORD PTR tv81[ebp]
	cvttsd2si eax, QWORD PTR tv81[ebp]

; 68   :    (kdu_int16) floor(0.5 + 0.5/W97_FACT_3)};

	fld	QWORD PTR __real@3ffa09bdc981b97a
	fstp	QWORD PTR [esp]
	mov	WORD PTR ?simd_w97_preoff@@3PAFA+4, ax
	call	_floor
	fstp	QWORD PTR tv89[ebp]
	cvttsd2si eax, QWORD PTR tv89[ebp]
	add	esp, 8
	mov	WORD PTR ?simd_w97_preoff@@3PAFA+6, ax
	mov	esp, ebp
	pop	ebp
	ret	0
??__Esimd_w97_preoff@@YAXXZ ENDP			; `dynamic initializer for 'simd_w97_preoff''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ??__Esimd_w97_rem@@YAXXZ
text$di	SEGMENT
tv164 = -8						; size = 8
tv92 = -8						; size = 8
tv84 = -8						; size = 8
tv79 = -8						; size = 8
??__Esimd_w97_rem@@YAXXZ PROC				; `dynamic initializer for 'simd_w97_rem'', COMDAT

; 63   :    (kdu_int16) floor(0.5 + W97_FACT_3*(double)(1<<16))};

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 60   :   {(kdu_int16) floor(0.5 + (W97_FACT_0+2.0)*(double)(1<<16)),

	fld	QWORD PTR __real@40da7ce680000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv79[ebp]
	cvttsd2si eax, QWORD PTR tv79[ebp]

; 61   :    (kdu_int16) floor(0.5 + W97_FACT_1*(double)(1<<19)),

	fld	QWORD PTR __real@c0db2015c0000000
	fstp	QWORD PTR [esp]
	mov	WORD PTR ?simd_w97_rem@@3PAFA, ax
	call	_floor
	fstp	QWORD PTR tv84[ebp]
	cvttsd2si eax, QWORD PTR tv84[ebp]

; 62   :    (kdu_int16) floor(0.5 + (W97_FACT_2-1.0)*(double)(1<<16)),

	fld	QWORD PTR __real@c0bdf90a00000000
	fstp	QWORD PTR [esp]
	mov	WORD PTR ?simd_w97_rem@@3PAFA+2, ax
	call	_floor
	fstp	QWORD PTR tv92[ebp]
	cvttsd2si eax, QWORD PTR tv92[ebp]

; 63   :    (kdu_int16) floor(0.5 + W97_FACT_3*(double)(1<<16))};

	fld	QWORD PTR __real@40dc628aa0000000
	fstp	QWORD PTR [esp]
	mov	WORD PTR ?simd_w97_rem@@3PAFA+4, ax
	call	_floor
	fstp	QWORD PTR tv164[ebp]
	cvttsd2si eax, QWORD PTR tv164[ebp]
	add	esp, 8
	mov	WORD PTR ?simd_w97_rem@@3PAFA+6, ax
	mov	esp, ebp
	pop	ebp
	ret	0
??__Esimd_w97_rem@@YAXXZ ENDP				; `dynamic initializer for 'simd_w97_rem''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_synthesis@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_synthesis@@MAEPAXI@Z PROC			; kd_synthesis::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_synthesis@@MAE@XZ			; kd_synthesis::~kd_synthesis
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	760					; 000002f8H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_synthesis@@MAEPAXI@Z ENDP			; kd_synthesis::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
;	COMDAT ?horizontal_synthesis@kd_synthesis@@IAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_lambda1$1 = -80					; size = 4
_lambda0$2 = -64					; size = 4
_downshift$1$ = -48					; size = 4
tv5255 = -44						; size = 4
_i_lambda$1$ = -40					; size = 4
_downshift$1$ = -40					; size = 4
_k$10$ = -40						; size = 4
_k$4$ = -40						; size = 4
tv5293 = -40						; size = 4
tv5237 = -40						; size = 4
tv5217 = -40						; size = 4
_src$ = -40						; size = 4
_offset$1$ = -36					; size = 4
_cpp$1$ = -36						; size = 4
_esp$1$ = -36						; size = 4
_k$5$ = -36						; size = 4
tv5235 = -36						; size = 4
_samples$ = -36						; size = 4
$T3 = -32						; size = 4
_cpp$1$ = -32						; size = 4
_i_lambda$1$ = -32					; size = 4
_esp$1$ = -32						; size = 4
_k$9$ = -32						; size = 4
_k$8$ = -32						; size = 4
_k$2$ = -32						; size = 4
tv5311 = -32						; size = 4
tv5310 = -32						; size = 4
tv5238 = -32						; size = 4
tv5201 = -32						; size = 4
_dst$ = -32						; size = 4
_sum$1$ = -28						; size = 4
_t$1$ = -28						; size = 4
_offset$1$ = -28					; size = 4
_dp$1$ = -28						; size = 4
tv5239 = -28						; size = 4
_dp$1$ = -24						; size = 4
_support$1$ = -24					; size = 4
_offset$1$ = -24					; size = 4
_c$1$ = -24						; size = 4
tv5250 = -24						; size = 4
tv5249 = -24						; size = 4
$T4 = -20						; size = 4
_cpp$1$ = -20						; size = 4
_c$2$ = -20						; size = 4
tv5251 = -20						; size = 4
_s$1$ = -16						; size = 4
tv5252 = -16						; size = 4
$T5 = -12						; size = 4
_x_off$1$ = -12						; size = 4
tv5200 = -12						; size = 4
$T6 = -8						; size = 4
_offset$1$ = -8						; size = 4
_step$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
_line$ = 8						; size = 4
_support$1$ = 12					; size = 4
_downshift$1$ = 12					; size = 4
_sp$1$ = 12						; size = 4
_sum$1$ = 12						; size = 4
_downshift$1$ = 12					; size = 4
_sp$1$ = 12						; size = 4
tv5312 = 12						; size = 4
_vert_parity$ = 12					; size = 4
tv5278 = 15						; size = 1
tv5277 = 15						; size = 1
tv5276 = 15						; size = 1
_width$1$ = 16						; size = 4
_env$ = 16						; size = 4
?horizontal_synthesis@kd_synthesis@@IAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z PROC ; kd_synthesis::horizontal_synthesis, COMDAT
; _this$ = ecx

; 1093 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi

; 1094 :   int s, c, k, width, x_off;
; 1095 : 
; 1096 :   // Load the data in from subbands, performing any boundary fill
; 1097 :   for (c=0; c < 2; c++)

	mov	esi, DWORD PTR _line$[ebp]
	lea	eax, DWORD PTR [ecx+128]
	push	edi
	xor	edi, edi
	mov	DWORD PTR _this$1$[ebp], ecx
	add	esi, 8
	mov	DWORD PTR _c$1$[ebp], edi
	mov	DWORD PTR tv5252[ebp], eax
	mov	DWORD PTR tv5251[ebp], esi
$LL4@horizontal:

; 1098 :     if (request_width[c] > 0)

	cmp	DWORD PTR [eax], 0
	jle	$LN2@horizontal

; 1100 :         subbands[2*vert_parity+c].pull(line->cosets[c],env);

	mov	eax, DWORD PTR _vert_parity$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 776  :         state->pull(line,env);

	push	DWORD PTR _env$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1100 :         subbands[2*vert_parity+c].pull(line->cosets[c],env);

	lea	eax, DWORD PTR [edi+eax*2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 776  :         state->pull(line,env);

	mov	ecx, DWORD PTR [ecx+eax*4+4]
	lea	eax, DWORD PTR [esi-8]
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1101 :         if ((k=left_fill[c]) > 0)

	mov	ecx, DWORD PTR _this$1$[ebp]
	movzx	edx, BYTE PTR [edi+ecx+136]
	test	edx, edx
	jle	SHORT $LN9@horizontal

; 1102 :           {
; 1103 :             if (use_shorts)

	cmp	BYTE PTR [ecx+162], 0
	je	SHORT $LN73@horizontal
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [esi-2], 2
	je	SHORT $LN130@horizontal
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR tv5311[ebp], eax
	jmp	SHORT $LN131@horizontal
$LN130@horizontal:
	mov	DWORD PTR tv5311[ebp], 0
$LN131@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1104 :               for (kdu_sample16 *sp=line->cosets[c].get_buf16() +

	movzx	eax, BYTE PTR [edi+ecx+126]
	mov	ecx, DWORD PTR tv5311[ebp]
	lea	eax, DWORD PTR [ecx+eax*2]
$LL7@horizontal:

; 1105 :                    request_offset[c]; k > 0; k--, sp--)

	lea	ecx, DWORD PTR [eax-2]
	dec	edx

; 1106 :                 sp[-1] = sp[0];

	mov	ax, WORD PTR [eax]
	mov	WORD PTR [ecx], ax
	lea	eax, DWORD PTR [ecx]
	test	edx, edx
	jg	SHORT $LL7@horizontal

; 1107 :             else

	jmp	SHORT $LN313@horizontal
$LN73@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [esi-2], 2
	je	SHORT $LN134@horizontal
	mov	DWORD PTR tv5310[ebp], 0
	jmp	SHORT $LN135@horizontal
$LN134@horizontal:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR tv5310[ebp], eax
$LN135@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1108 :               for (kdu_sample32 *sp=line->cosets[c].get_buf32() +

	movzx	eax, BYTE PTR [edi+ecx+126]
	mov	ecx, DWORD PTR tv5310[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	npad	7
$LL10@horizontal:

; 1109 :                    request_offset[c]; k > 0; k--, sp--)

	lea	ecx, DWORD PTR [eax-4]
	dec	edx

; 1110 :                 sp[-1] = sp[0];

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	lea	eax, DWORD PTR [ecx]
	test	edx, edx
	jg	SHORT $LL10@horizontal
$LN313@horizontal:
	mov	ecx, DWORD PTR _this$1$[ebp]
$LN9@horizontal:

; 1111 :           }
; 1112 :         if ((k=right_fill[c]) > 0)

	movzx	eax, BYTE PTR [edi+ecx+138]
	mov	DWORD PTR _k$2$[ebp], eax
	test	eax, eax
	jle	SHORT $LN298@horizontal

; 1113 :           {
; 1114 :             if (use_shorts)

	cmp	BYTE PTR [ecx+162], 0
	je	SHORT $LN76@horizontal
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [esi-2], 2
	je	SHORT $LN138@horizontal
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN139@horizontal
$LN138@horizontal:
	xor	esi, esi
$LN139@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1116 :                    request_offset[c] + request_width[c]; k > 0; k--, sp++)

	movzx	eax, BYTE PTR [edi+ecx+126]
	mov	edx, DWORD PTR tv5252[ebp]
	mov	ecx, DWORD PTR _k$2$[ebp]
	add	eax, DWORD PTR [edx]
	lea	edi, DWORD PTR [esi+eax*2]
	lea	esi, DWORD PTR [edi-2]
	rep movsw

; 1117 :                 sp[0] = sp[-1];
; 1118 :             else

	jmp	SHORT $LN319@horizontal
$LN76@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [esi-2], 2
	je	SHORT $LN142@horizontal
	xor	esi, esi
	jmp	SHORT $LN143@horizontal
$LN142@horizontal:
	mov	esi, DWORD PTR [esi]
$LN143@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1120 :                    request_offset[c] + request_width[c]; k > 0; k--, sp++)

	movzx	eax, BYTE PTR [edi+ecx+126]
	mov	edx, DWORD PTR tv5252[ebp]
	mov	ecx, DWORD PTR _k$2$[ebp]
	add	eax, DWORD PTR [edx]
	lea	edi, DWORD PTR [esi+eax*4]
	lea	esi, DWORD PTR [edi-4]
	rep movsd
$LN319@horizontal:
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	edi, DWORD PTR _c$1$[ebp]
	mov	esi, DWORD PTR tv5251[ebp]
$LN298@horizontal:
	mov	eax, DWORD PTR tv5252[ebp]
$LN2@horizontal:

; 1094 :   int s, c, k, width, x_off;
; 1095 : 
; 1096 :   // Load the data in from subbands, performing any boundary fill
; 1097 :   for (c=0; c < 2; c++)

	inc	edi
	add	eax, 4
	add	esi, 12					; 0000000cH
	mov	DWORD PTR _c$1$[ebp], edi
	mov	DWORD PTR tv5252[ebp], eax
	mov	DWORD PTR tv5251[ebp], esi
	cmp	edi, 2
	jl	$LL4@horizontal

; 1121 :                 sp[0] = sp[-1];
; 1122 :           }
; 1123 :       }
; 1124 : 
; 1125 :   // Check to see if we can skip the horizontal transform
; 1126 :   if (num_hor_steps == 0)

	cmp	DWORD PTR [ecx+28], 0
	je	$LN18@horizontal

; 1127 :     return;
; 1128 :   if (unit_width && reversible && (x_min_in & 1))

	cmp	BYTE PTR [ecx+164], 0
	je	SHORT $LN315@horizontal
	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN81@horizontal
	test	BYTE PTR [ecx+108], 1
	je	SHORT $LN81@horizontal

; 1130 :       if (!use_shorts)

	cmp	BYTE PTR [ecx+162], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	esi, DWORD PTR _line$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1130 :       if (!use_shorts)

	jne	SHORT $LN80@horizontal
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [esi+18], 2
	je	SHORT $LN146@horizontal
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1131 :         (line->cosets[1].get_buf32())[coset_off_in[1]].ival >>= 1;

	movzx	eax, BYTE PTR [ecx+125]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	xor	edx, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1131 :         (line->cosets[1].get_buf32())[coset_off_in[1]].ival >>= 1;

	sar	DWORD PTR [edx+eax*4], 1

; 1132 :       else

	jmp	SHORT $LN81@horizontal
$LN146@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	edx, DWORD PTR [esi+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1131 :         (line->cosets[1].get_buf32())[coset_off_in[1]].ival >>= 1;

	movzx	eax, BYTE PTR [ecx+125]
	sar	DWORD PTR [edx+eax*4], 1

; 1132 :       else

	jmp	SHORT $LN81@horizontal
$LN80@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [esi+18], 2
	je	SHORT $LN150@horizontal
	mov	edx, DWORD PTR [esi+20]
	jmp	SHORT $LN151@horizontal
$LN150@horizontal:
	xor	edx, edx
$LN151@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1133 :         (line->cosets[1].get_buf16())[coset_off_in[1]].ival >>= 1;

	movzx	eax, BYTE PTR [ecx+125]
	sar	WORD PTR [edx+eax*2], 1
$LN81@horizontal:

; 1134 :     }
; 1135 : 
; 1136 :   if (unit_width)

	cmp	BYTE PTR [ecx+164], 0
	jne	$LN18@horizontal
$LN315@horizontal:

; 1137 :     return;
; 1138 : 
; 1139 :   // Perform horizontal lifting steps
; 1140 :   for (s=num_hor_steps-1; s >= 0; s--)

	mov	eax, DWORD PTR [ecx+28]
	sub	eax, 1
	mov	DWORD PTR _s$1$[ebp], eax
	js	$LN18@horizontal
	movss	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edi, DWORD PTR _this$1$[ebp]
	npad	9
$LL19@horizontal:

; 1141 :     {
; 1142 :       kd_lifting_step *step = hor_steps + s;

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi+48]

; 1143 :       if (step->support_length == 0)

	cmp	BYTE PTR [eax+ecx*4+1], 0
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _step$1$[ebp], ecx
	je	$LN17@horizontal

; 1144 :         continue;
; 1145 :       c = 1 - (s & 1); // Coset which is updated by this lifting step

	mov	eax, DWORD PTR _s$1$[ebp]
	mov	esi, 1
	and	eax, 1
	sub	esi, eax

; 1146 :       width = coset_width_in[c];
; 1147 :       x_off = coset_off_in[c];
; 1148 :       if (use_shorts)

	cmp	BYTE PTR [edi+162], 0
	mov	DWORD PTR _c$2$[ebp], esi
	movzx	eax, BYTE PTR [esi+edi+124]
	mov	edx, DWORD PTR [edi+esi*4+116]

; 1150 :           kdu_sample16 *sp=line->cosets[1-c].get_buf16()+coset_off_in[1-c];

	lea	edi, DWORD PTR [esi+esi*2]
	mov	DWORD PTR _x_off$1$[ebp], eax
	mov	eax, DWORD PTR _line$[ebp]
	mov	DWORD PTR _width$1$[ebp], edx
	je	$LN84@horizontal
	shl	edi, 2
	sub	eax, edi
	mov	DWORD PTR tv5293[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [eax+18], 2
	je	SHORT $LN154@horizontal
	mov	ecx, DWORD PTR [eax+20]
	jmp	SHORT $LN155@horizontal
$LN154@horizontal:
	xor	ecx, ecx
$LN155@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1150 :           kdu_sample16 *sp=line->cosets[1-c].get_buf16()+coset_off_in[1-c];

	mov	eax, DWORD PTR _this$1$[ebp]
	sub	eax, esi
	movzx	eax, BYTE PTR [eax+125]
	lea	edi, DWORD PTR [ecx+eax*2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	mov	eax, DWORD PTR tv5293[ebp]
	mov	ecx, DWORD PTR _line$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1150 :           kdu_sample16 *sp=line->cosets[1-c].get_buf16()+coset_off_in[1-c];

	mov	DWORD PTR _sp$1$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [eax+ecx+6], 2
	je	SHORT $LN158@horizontal
	mov	ecx, DWORD PTR [eax+ecx+8]
	jmp	SHORT $LN159@horizontal
$LN158@horizontal:
	xor	ecx, ecx
$LN159@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1151 :           kdu_sample16 *dp=line->cosets[c].get_buf16()+x_off;

	mov	eax, DWORD PTR _x_off$1$[ebp]
	lea	esi, DWORD PTR [eax+eax]

; 1152 :           kdu_sample16 *esp=sp+coset_width_in[1-c]-1; // End of source buffer

	mov	eax, 30					; 0000001eH
	sub	eax, DWORD PTR _c$2$[ebp]
	add	esi, ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _dp$1$[ebp], esi
	mov	eax, DWORD PTR [ecx+eax*4]
	dec	eax
	lea	eax, DWORD PTR [edi+eax*2]
	mov	DWORD PTR _esp$1$[ebp], eax

; 1153 :           if (!hor_symmetric_extension)

	mov	eax, ecx
	mov	ecx, DWORD PTR _step$1$[ebp]
	cmp	BYTE PTR [eax+55], 0
	jne	SHORT $LN86@horizontal

; 1154 :             for (k=1; k <= step->extend; k++)

	cmp	BYTE PTR [ecx+3], 1
	mov	edi, 1
	jb	$LN297@horizontal
	mov	esi, DWORD PTR _sp$1$[ebp]
	mov	edx, DWORD PTR _esp$1$[ebp]
	lea	eax, DWORD PTR [esi-2]
	mov	DWORD PTR tv5250[ebp], eax
	npad	8
$LL22@horizontal:

; 1155 :               { sp[-k] = sp[0];  esp[k] = esp[0]; }

	mov	ecx, DWORD PTR tv5250[ebp]
	movzx	eax, WORD PTR [esi]
	sub	DWORD PTR tv5250[ebp], 2
	mov	WORD PTR [ecx], ax
	mov	ecx, DWORD PTR _step$1$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	WORD PTR [edx+edi*2], ax
	inc	edi
	movzx	eax, BYTE PTR [ecx+3]
	cmp	edi, eax
	jle	SHORT $LL22@horizontal

; 1156 :           else

	mov	eax, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LN320@horizontal
$LN86@horizontal:

; 1157 :             for (k=1; k <= step->extend; k++)

	cmp	BYTE PTR [ecx+3], 1
	mov	DWORD PTR _k$4$[ebp], 1
	jb	SHORT $LN24@horizontal
	mov	edx, DWORD PTR _k$4$[ebp]
	add	edi, -2					; fffffffeH
	mov	esi, DWORD PTR _esp$1$[ebp]
	mov	DWORD PTR tv5249[ebp], edi
	mov	edi, DWORD PTR _step$1$[ebp]
$LL25@horizontal:

; 1158 :               { // Apply symmetric extension policy
; 1159 :                 sp[-k] = sp[k - ((x_min_in^s) & 1)];

	mov	ecx, DWORD PTR [eax+108]
	mov	eax, edx
	xor	ecx, DWORD PTR _s$1$[ebp]
	and	ecx, 1
	sub	eax, ecx
	mov	ecx, DWORD PTR _sp$1$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	ecx, DWORD PTR tv5249[ebp]
	mov	WORD PTR [ecx], ax
	sub	ecx, 2

; 1160 :                 esp[k] = esp[-k + ((x_max_in^s) & 1)];

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR tv5249[ebp], ecx
	mov	eax, DWORD PTR [eax+112]
	xor	eax, DWORD PTR _s$1$[ebp]
	and	eax, 1
	sub	eax, edx
	movzx	eax, WORD PTR [esi+eax*2]
	mov	WORD PTR [esi+edx*2], ax
	inc	edx
	movzx	eax, BYTE PTR [edi+3]
	cmp	edx, eax
	mov	eax, DWORD PTR _this$1$[ebp]
	jle	SHORT $LL25@horizontal
$LN320@horizontal:
	mov	edx, DWORD PTR _width$1$[ebp]
	mov	esi, DWORD PTR _dp$1$[ebp]
$LN297@horizontal:
	mov	edi, DWORD PTR _sp$1$[ebp]
$LN24@horizontal:

; 1161 :               }
; 1162 :           if (x_min_in & 1)

	test	BYTE PTR [eax+108], 1
	je	SHORT $LN88@horizontal

; 1163 :             sp -= c+c-1;

	mov	eax, DWORD PTR _c$2$[ebp]
	mov	ecx, 2
	shl	eax, 2
	sub	ecx, eax
	add	edi, ecx
$LN88@horizontal:

; 1164 :           sp += step->support_min;

	mov	ecx, DWORD PTR _step$1$[ebp]

; 1165 : 
; 1166 : #ifdef KDU_SIMD_OPTIMIZATIONS
; 1167 :           if ((step->kernel_id == (kdu_byte) Ckernels_W5X3) &&

	cmp	BYTE PTR [ecx+18], 1
	movsx	eax, WORD PTR [ecx+4]
	lea	edi, DWORD PTR [edi+eax*2]
	jne	SHORT $LN89@horizontal
	mov	eax, DWORD PTR _x_off$1$[ebp]
	add	eax, edx
	mov	edx, DWORD PTR _x_off$1$[ebp]
	push	ecx
	push	eax
	mov	eax, esi
	lea	ecx, DWORD PTR [edx+edx]
	sub	eax, ecx
	push	eax
	mov	eax, edi
	sub	eax, ecx
	push	eax
	call	?simd_W5X3_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z ; simd_W5X3_h_synth
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN309@horizontal
	mov	edx, DWORD PTR _width$1$[ebp]
	mov	ecx, DWORD PTR _step$1$[ebp]
$LN89@horizontal:

; 1168 :               simd_W5X3_h_synth(&(sp[-x_off].ival),&(dp[-x_off].ival),
; 1169 :                                 width+x_off,step))
; 1170 :             continue;
; 1171 :           else if ((step->kernel_id == (kdu_byte) Ckernels_W9X7) &&

	cmp	BYTE PTR [ecx+18], 0
	jne	SHORT $LN91@horizontal
	mov	eax, DWORD PTR _x_off$1$[ebp]
	add	eax, edx
	mov	edx, DWORD PTR _x_off$1$[ebp]
	push	ecx
	push	eax
	mov	eax, esi
	lea	ecx, DWORD PTR [edx+edx]
	sub	eax, ecx
	push	eax
	mov	eax, edi
	sub	eax, ecx
	push	eax
	call	?simd_W9X7_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z ; simd_W9X7_h_synth
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN309@horizontal
	mov	ecx, DWORD PTR _step$1$[ebp]
$LN91@horizontal:

; 1172 :                    simd_W9X7_h_synth(&(sp[-x_off].ival),&(dp[-x_off].ival),
; 1173 :                                      width+x_off,step))
; 1174 :             continue;
; 1175 :           else if (step->support_length <= 2)

	mov	al, BYTE PTR [ecx+1]
	cmp	al, 2
	ja	SHORT $LN93@horizontal

; 1176 :             {
; 1177 :               if (simd_2tap_h_synth(&(sp[-x_off].ival),&(dp[-x_off].ival),

	mov	edx, DWORD PTR _x_off$1$[ebp]
	mov	eax, DWORD PTR _width$1$[ebp]
	add	eax, edx
	push	ecx
	push	eax
	lea	ecx, DWORD PTR [edx+edx]
	mov	eax, esi
	sub	eax, ecx
	push	eax
	mov	eax, edi
	sub	eax, ecx
	push	eax
	call	?simd_2tap_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z ; simd_2tap_h_synth

; 1178 :                                     width+x_off,step))
; 1179 :                 continue;
; 1180 :             }

	jmp	SHORT $LN317@horizontal
$LN93@horizontal:

; 1181 :           else if (step->support_length <= 4)

	cmp	al, 4
	ja	SHORT $LN97@horizontal

; 1182 :             {
; 1183 :               if (simd_4tap_h_synth(&(sp[-x_off].ival),&(dp[-x_off].ival),

	mov	edx, DWORD PTR _x_off$1$[ebp]
	mov	eax, DWORD PTR _width$1$[ebp]
	add	eax, edx
	push	ecx
	push	eax
	lea	ecx, DWORD PTR [edx+edx]
	mov	eax, esi
	sub	eax, ecx
	push	eax
	mov	eax, edi
	sub	eax, ecx
	push	eax
	call	?simd_4tap_h_synth@@YA_NPAF0HPAUkd_lifting_step@@@Z ; simd_4tap_h_synth
$LN317@horizontal:
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN309@horizontal
	mov	ecx, DWORD PTR _step$1$[ebp]
$LN97@horizontal:

; 1184 :                                     width+x_off,step))
; 1185 :                 continue;
; 1186 :             }
; 1187 : #endif // KDU_SIMD_OPTIMIZATIONS
; 1188 :           if ((step->support_length==2)&&(step->icoeffs[0]==step->icoeffs[1]))

	mov	al, BYTE PTR [ecx+1]
	cmp	al, 2
	jne	$LN98@horizontal
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _i_lambda$1$[ebp], edx
	cmp	edx, DWORD PTR [eax+4]
	jne	$LN311@horizontal

; 1189 :             { // Special implementation for symmetric least-dissimilar filters
; 1190 :               kdu_int32 downshift = step->downshift;

	movzx	eax, BYTE PTR [ecx+2]

; 1191 :               kdu_int32 offset = step->rounding_offset;

	movsx	edx, WORD PTR [ecx+6]
	mov	DWORD PTR _downshift$1$[ebp], eax

; 1192 :               kdu_int32 val, i_lambda = step->icoeffs[0];
; 1193 :               if (i_lambda == 1)

	mov	eax, DWORD PTR _i_lambda$1$[ebp]
	mov	DWORD PTR _offset$1$[ebp], edx
	cmp	eax, 1
	jne	SHORT $LN100@horizontal

; 1194 :                 for (k=0; k < width; k++)

	cmp	DWORD PTR _width$1$[ebp], 0
	jle	$LN309@horizontal
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sub	edi, esi
$LL28@horizontal:

; 1195 :                   { val = sp[k].ival;  val += sp[k+1].ival;

	movsx	eax, WORD PTR [esi+edi+2]
	lea	esi, DWORD PTR [esi+2]
	movsx	edx, WORD PTR [esi+edi-2]

; 1196 :                     dp[k].ival -= (kdu_int16)((offset+val)>>downshift); }

	add	eax, DWORD PTR _offset$1$[ebp]
	add	edx, eax
	sar	edx, cl
	sub	WORD PTR [esi-2], dx
	sub	DWORD PTR _width$1$[ebp], 1
	jne	SHORT $LL28@horizontal

; 1197 :               else if (i_lambda == -1)

	jmp	$LN309@horizontal
$LN100@horizontal:
	cmp	eax, -1
	jne	SHORT $LN102@horizontal

; 1198 :                 for (k=0; k < width; k++)

	cmp	DWORD PTR _width$1$[ebp], 0
	jle	$LN309@horizontal
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sub	edi, esi
	npad	7
$LL31@horizontal:

; 1199 :                   { val = sp[k].ival;  val += sp[k+1].ival;

	movsx	eax, WORD PTR [esi+edi+2]
	lea	esi, DWORD PTR [esi+2]

; 1200 :                     dp[k].ival -= (kdu_int16)((offset-val)>>downshift); }

	sub	edx, eax
	movsx	eax, WORD PTR [esi+edi-2]
	sub	edx, eax
	sar	edx, cl
	sub	WORD PTR [esi-2], dx
	sub	DWORD PTR _width$1$[ebp], 1
	mov	edx, DWORD PTR _offset$1$[ebp]
	jne	SHORT $LL31@horizontal

; 1201 :               else

	jmp	$LN309@horizontal
$LN102@horizontal:

; 1202 :                 for (k=0; k < width; k++)

	cmp	DWORD PTR _width$1$[ebp], 0
	jle	$LN309@horizontal
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sub	edi, esi
	npad	12
$LL34@horizontal:

; 1203 :                   { val = sp[k].ival;  val += sp[k+1].ival;

	movsx	edx, WORD PTR [esi+edi+2]
	lea	esi, DWORD PTR [esi+2]
	movsx	eax, WORD PTR [esi+edi-2]
	add	edx, eax

; 1204 :                     dp[k].ival -=

	imul	edx, DWORD PTR _i_lambda$1$[ebp]
	add	edx, DWORD PTR _offset$1$[ebp]
	sar	edx, cl
	sub	WORD PTR [esi-2], dx
	sub	DWORD PTR _width$1$[ebp], 1
	jne	SHORT $LL34@horizontal

; 1205 :                       (kdu_int16)((offset+i_lambda*val)>>downshift); }
; 1206 :             }
; 1207 :           else

	jmp	$LN309@horizontal
$LN311@horizontal:
	mov	al, BYTE PTR [ecx+1]
$LN98@horizontal:

; 1208 :             { // Generic 16-bit implementation
; 1209 :               int t, support=step->support_length;
; 1210 :               kdu_int32 downshift = step->downshift;
; 1211 :               kdu_int32 offset = step->rounding_offset;
; 1212 :               int sum, *cpp = step->icoeffs;
; 1213 :               for (k=0; k < width; k++, sp++)

	mov	edx, DWORD PTR _width$1$[ebp]
	movzx	eax, al
	mov	DWORD PTR _support$1$[ebp], eax
	movzx	eax, BYTE PTR [ecx+2]
	mov	DWORD PTR _downshift$1$[ebp], eax
	movsx	eax, WORD PTR [ecx+6]
	mov	DWORD PTR _offset$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _cpp$1$[ebp], eax
	mov	DWORD PTR _k$5$[ebp], 0
	test	edx, edx
	jle	$LN309@horizontal
$LL37@horizontal:

; 1214 :                 {
; 1215 :                   for (sum=offset, t=0; t < support; t++)

	mov	ecx, DWORD PTR _offset$1$[ebp]
	xor	eax, eax
	mov	DWORD PTR _sum$1$[ebp], ecx
	xor	ecx, ecx
	cmp	DWORD PTR _support$1$[ebp], 2
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR $T4[ebp], eax
	jl	SHORT $LC253@horizontal
	mov	edx, DWORD PTR _support$1$[ebp]
	mov	esi, DWORD PTR _cpp$1$[ebp]
	dec	edx
$LL254@horizontal:

; 1216 :                     sum += cpp[t] * sp[t].ival;

	movsx	eax, WORD PTR [edi+ecx*2]
	imul	eax, DWORD PTR [esi+ecx*4]
	add	DWORD PTR $T5[ebp], eax
	movsx	eax, WORD PTR [edi+ecx*2+2]
	imul	eax, DWORD PTR [esi+ecx*4+4]
	add	ecx, 2
	add	DWORD PTR $T4[ebp], eax
	cmp	ecx, edx
	jl	SHORT $LL254@horizontal
	mov	esi, DWORD PTR _dp$1$[ebp]
	mov	edx, DWORD PTR _width$1$[ebp]
	mov	eax, DWORD PTR $T5[ebp]
$LC253@horizontal:

; 1214 :                 {
; 1215 :                   for (sum=offset, t=0; t < support; t++)

	cmp	ecx, DWORD PTR _support$1$[ebp]
	jge	SHORT $LN252@horizontal

; 1216 :                     sum += cpp[t] * sp[t].ival;

	movsx	eax, WORD PTR [edi+ecx*2]
	mov	DWORD PTR _sum$1$[ebp], eax
	mov	eax, DWORD PTR _cpp$1$[ebp]
	mov	edx, DWORD PTR _sum$1$[ebp]
	imul	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _offset$1$[ebp]
	mov	DWORD PTR _sum$1$[ebp], edx
	add	DWORD PTR _sum$1$[ebp], eax
	mov	edx, DWORD PTR _width$1$[ebp]
	mov	eax, DWORD PTR $T5[ebp]
$LN252@horizontal:

; 1208 :             { // Generic 16-bit implementation
; 1209 :               int t, support=step->support_length;
; 1210 :               kdu_int32 downshift = step->downshift;
; 1211 :               kdu_int32 offset = step->rounding_offset;
; 1212 :               int sum, *cpp = step->icoeffs;
; 1213 :               for (k=0; k < width; k++, sp++)

	add	eax, DWORD PTR $T4[ebp]
	add	edi, 2
	add	eax, DWORD PTR _sum$1$[ebp]

; 1217 :                   dp[k].ival -= (kdu_int16)(sum >> downshift);

	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sar	eax, cl
	mov	ecx, DWORD PTR _k$5$[ebp]
	sub	WORD PTR [esi+ecx*2], ax
	inc	ecx
	mov	DWORD PTR _k$5$[ebp], ecx
	cmp	ecx, edx
	jl	$LL37@horizontal

; 1218 :                 }
; 1219 :             }
; 1220 :         }
; 1221 :       else

	jmp	$LN309@horizontal
$LN84@horizontal:

; 1223 :           kdu_sample32 *sp=line->cosets[1-c].get_buf32()+coset_off_in[1-c];

	shl	edi, 2
	sub	eax, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [eax+18], 2
	je	SHORT $LN162@horizontal
	xor	ecx, ecx
	jmp	SHORT $LN163@horizontal
$LN162@horizontal:
	mov	ecx, DWORD PTR [eax+20]
$LN163@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1223 :           kdu_sample32 *sp=line->cosets[1-c].get_buf32()+coset_off_in[1-c];

	mov	eax, DWORD PTR _this$1$[ebp]
	sub	eax, esi
	movzx	eax, BYTE PTR [eax+125]
	lea	esi, DWORD PTR [ecx+eax*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	eax, DWORD PTR _line$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1223 :           kdu_sample32 *sp=line->cosets[1-c].get_buf32()+coset_off_in[1-c];

	mov	DWORD PTR _sp$1$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edi+eax+6], 2
	je	SHORT $LN166@horizontal
	xor	ecx, ecx
	jmp	SHORT $LN167@horizontal
$LN166@horizontal:
	mov	ecx, DWORD PTR [edi+eax+8]
$LN167@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1224 :           kdu_sample32 *dp=line->cosets[c].get_buf32()+x_off;

	mov	edi, DWORD PTR _x_off$1$[ebp]

; 1225 :           kdu_sample32 *esp=sp+coset_width_in[1-c]-1; // End of source buffer

	mov	eax, 30					; 0000001eH
	sub	eax, DWORD PTR _c$2$[ebp]
	shl	edi, 2
	add	edi, ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _dp$1$[ebp], edi
	mov	eax, DWORD PTR [ecx+eax*4]
	dec	eax
	lea	eax, DWORD PTR [esi+eax*4]

; 1226 :           if (!hor_symmetric_extension)
; 1227 :             for (k=1; k <= step->extend; k++)

	mov	esi, 1
	mov	DWORD PTR _esp$1$[ebp], eax
	mov	eax, ecx
	mov	ecx, DWORD PTR _step$1$[ebp]
	cmp	BYTE PTR [eax+55], 0
	jne	SHORT $LN104@horizontal
	cmp	BYTE PTR [ecx+3], 1
	jb	$LN45@horizontal
	mov	edi, DWORD PTR _sp$1$[ebp]
	mov	edx, DWORD PTR _esp$1$[ebp]
	lea	eax, DWORD PTR [edi-4]
	mov	DWORD PTR tv5239[ebp], eax
	npad	1
$LL43@horizontal:

; 1228 :               { sp[-k] = sp[0];  esp[k] = esp[0]; }

	mov	ecx, DWORD PTR tv5239[ebp]
	mov	eax, DWORD PTR [edi]
	sub	DWORD PTR tv5239[ebp], 4
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _step$1$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edx+esi*4], eax
	inc	esi
	movzx	eax, BYTE PTR [ecx+3]
	cmp	esi, eax
	jle	SHORT $LL43@horizontal

; 1229 :           else

	jmp	SHORT $LN318@horizontal
$LN104@horizontal:

; 1230 :             for (k=1; k <= step->extend; k++)

	cmp	BYTE PTR [ecx+3], 1
	jb	SHORT $LN45@horizontal
	mov	eax, DWORD PTR _sp$1$[ebp]
	mov	edx, DWORD PTR _step$1$[ebp]
	add	eax, -4					; fffffffcH
	mov	edi, DWORD PTR _esp$1$[ebp]
	mov	DWORD PTR tv5238[ebp], eax
$LL46@horizontal:

; 1231 :               { // Apply symmetric extension policy
; 1232 :                 sp[-k] = sp[k - ((x_min_in^s) & 1)];

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	eax, esi
	xor	ecx, DWORD PTR _s$1$[ebp]
	and	ecx, 1
	sub	eax, ecx
	mov	ecx, DWORD PTR _sp$1$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR tv5238[ebp]
	mov	DWORD PTR [ecx], eax
	sub	ecx, 4

; 1233 :                 esp[k] = esp[-k + ((x_max_in^s) & 1)];

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR tv5238[ebp], ecx
	mov	eax, DWORD PTR [eax+112]
	xor	eax, DWORD PTR _s$1$[ebp]
	and	eax, 1
	sub	eax, esi
	mov	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [edi+esi*4], eax
	inc	esi
	movzx	eax, BYTE PTR [edx+3]
	cmp	esi, eax
	jle	SHORT $LL46@horizontal
$LN318@horizontal:
	mov	edx, DWORD PTR _width$1$[ebp]
	mov	edi, DWORD PTR _dp$1$[ebp]
$LN45@horizontal:

; 1234 :               }
; 1235 :           if (x_min_in & 1)

	mov	ecx, DWORD PTR _this$1$[ebp]
	test	BYTE PTR [ecx+108], 1
	je	SHORT $LN106@horizontal

; 1236 :             sp -= c+c-1;

	mov	eax, DWORD PTR _c$2$[ebp]
	mov	ecx, 4
	shl	eax, 3
	sub	ecx, eax
	add	DWORD PTR _sp$1$[ebp], ecx
$LN106@horizontal:

; 1237 :           sp += step->support_min;

	mov	ecx, DWORD PTR _step$1$[ebp]
	mov	esi, DWORD PTR _sp$1$[ebp]

; 1238 : 
; 1239 : #ifdef KDU_SIMD_OPTIMIZATIONS
; 1240 :           if ((step->kernel_id == (kdu_byte) Ckernels_W5X3) &&

	cmp	BYTE PTR [ecx+18], 1
	movsx	eax, WORD PTR [ecx+4]
	lea	esi, DWORD PTR [esi+eax*4]
	jne	SHORT $LN107@horizontal
	mov	eax, DWORD PTR _x_off$1$[ebp]
	add	eax, edx
	mov	edx, DWORD PTR _x_off$1$[ebp]
	push	ecx
	push	eax
	mov	eax, edi
	lea	ecx, DWORD PTR [edx*4]
	sub	eax, ecx
	push	eax
	mov	eax, esi
	sub	eax, ecx
	push	eax
	call	?simd_W5X3_h_synth32@@YA_NPAH0HPAUkd_lifting_step@@@Z ; simd_W5X3_h_synth32
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN309@horizontal
	movss	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	mov	edx, DWORD PTR _width$1$[ebp]
	mov	ecx, DWORD PTR _step$1$[ebp]
$LN107@horizontal:

; 1241 :               simd_W5X3_h_synth32(&(sp[-x_off].ival),&(dp[-x_off].ival),
; 1242 :                                   width+x_off,step))
; 1243 :             continue;
; 1244 :           else if (!reversible)

	mov	eax, DWORD PTR _this$1$[ebp]
	cmp	BYTE PTR [eax+20], 0
	jne	$LN295@horizontal

; 1245 :             {
; 1246 :               if (step->support_length <= 2)

	mov	al, BYTE PTR [ecx+1]
	mov	BYTE PTR tv5277[ebp], al
	cmp	al, 2
	ja	$LN110@horizontal

; 1248 :                   if (simd_2tap_h_irrev32(&(sp[-x_off].fval),

	mov	ecx, DWORD PTR _x_off$1$[ebp]
	mov	eax, DWORD PTR _x_off$1$[ebp]
	add	eax, DWORD PTR _width$1$[ebp]
	mov	DWORD PTR _samples$[ebp], eax
	mov	eax, edi
	lea	edx, DWORD PTR [ecx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h

; 1634 :   if (kdu_mmx_level < 2)

	mov	ecx, DWORD PTR _width$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1248 :                   if (simd_2tap_h_irrev32(&(sp[-x_off].fval),

	sub	eax, edx
	mov	DWORD PTR _dst$[ebp], eax
	mov	eax, esi
	sub	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h

; 1634 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1248 :                   if (simd_2tap_h_irrev32(&(sp[-x_off].fval),

	mov	DWORD PTR _src$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h

; 1634 :   if (kdu_mmx_level < 2)

	jl	$LN114@horizontal

; 1635 :     return false;
; 1636 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN309@horizontal

; 1637 :     return true;
; 1638 : 
; 1639 :   float lambda0 = step->coeffs[0];
; 1640 :   float lambda1 = (step->support_length==2)?(step->coeffs[1]):0.0F;

	cmp	BYTE PTR tv5277[ebp], 2
	mov	eax, DWORD PTR _step$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	movss	xmm1, DWORD PTR [eax]
	jne	SHORT $LN173@horizontal
	movss	xmm0, DWORD PTR [eax+4]
	jmp	SHORT $LN174@horizontal
$LN173@horizontal:
	xorps	xmm0, xmm0
$LN174@horizontal:

; 1641 :   if (synthesis)
; 1642 :     { lambda0 = -lambda0;  lambda1 = -lambda1; }

	xorps	xmm1, xmm2
	xorps	xmm0, xmm2
	movss	DWORD PTR _lambda0$2[ebp], xmm1
	movss	DWORD PTR _lambda1$1[ebp], xmm0

; 1643 :   __asm {
; 1644 :       MOVSS XMM0, lambda0

	movss	xmm0, XMMWORD PTR _lambda0$2[ebp]

; 1645 :       MOVSS XMM1, lambda1

	movss	xmm1, XMMWORD PTR _lambda1$1[ebp]

; 1646 :       PUNPCKLDQ XMM0,XMM0

	punpckldq xmm0, xmm0

; 1647 :       PUNPCKLDQ XMM1,XMM1

	punpckldq xmm1, xmm1

; 1648 :       PUNPCKLQDQ XMM0,XMM0

	punpcklqdq xmm0, xmm0

; 1649 :       PUNPCKLQDQ XMM1,XMM1

	punpcklqdq xmm1, xmm1

; 1650 :       MOV ESI,src

	mov	esi, DWORD PTR _src$[ebp]

; 1651 :       MOV EDI,dst

	mov	edi, DWORD PTR _dst$[ebp]

; 1652 : 
; 1653 :       MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 1654 :       XOR ECX,ECX        // Zero sample counter

	xor	ecx, ecx

; 1655 :       MOVUPS XMM4,[ESI]

	movups	xmm4, XMMWORD PTR [esi]

; 1656 :       MOVUPS XMM5,[ESI+4]

	movups	xmm5, XMMWORD PTR [esi+4]
$loop_dqword$322:

; 1657 : loop_dqword:
; 1658 :       MULPS XMM4, XMM0

	mulps	xmm4, xmm0

; 1659 :       MULPS XMM5, XMM1

	mulps	xmm5, xmm1

; 1660 :       MOVAPS XMM2, [EDI+4*ECX]

	movaps	xmm2, XMMWORD PTR [edi+ecx*4]

; 1661 :       ADDPS XMM5, XMM4

	addps	xmm5, xmm4

; 1662 :       MOVUPS XMM4, [ESI+4*ECX+16]

	movups	xmm4, XMMWORD PTR [esi+ecx*4+16]

; 1663 :       ADDPS XMM2, XMM5

	addps	xmm2, xmm5

; 1664 :       MOVUPS XMM5, [ESI+4*ECX+20]

	movups	xmm5, XMMWORD PTR [esi+ecx*4+20]

; 1665 :       MOVAPS [EDI+4*ECX],XMM2

	movaps	XMMWORD PTR [edi+ecx*4], xmm2

; 1666 :       ADD ECX,4

	add	ecx, 4

; 1667 :       CMP ECX,EDX

	cmp	ecx, edx

; 1668 :       JL loop_dqword

	jl	SHORT $loop_dqword$322
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1248 :                   if (simd_2tap_h_irrev32(&(sp[-x_off].fval),

	jmp	$LN309@horizontal
$LN110@horizontal:

; 1249 :                                           &(dp[-x_off].fval),width+x_off,
; 1250 :                                           step,true))
; 1251 :                     continue;
; 1252 :                 }
; 1253 :               else if (step->support_length <= 4)

	cmp	al, 4
	ja	SHORT $LN295@horizontal

; 1254 :                 {
; 1255 :                   if (simd_4tap_h_irrev32(&(sp[-x_off].fval),

	mov	eax, DWORD PTR _x_off$1$[ebp]
	add	eax, edx
	mov	edx, DWORD PTR _x_off$1$[ebp]
	push	1
	push	ecx
	push	eax
	lea	ecx, DWORD PTR [edx*4]
	mov	eax, edi
	sub	eax, ecx
	push	eax
	mov	eax, esi
	sub	eax, ecx
	push	eax
	call	?simd_4tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z ; simd_4tap_h_irrev32
	add	esp, 20					; 00000014H
	test	al, al
	jne	$LN309@horizontal
$LN295@horizontal:
	mov	ecx, DWORD PTR _width$1$[ebp]
$LN114@horizontal:

; 1256 :                                           &(dp[-x_off].fval),width+x_off,
; 1257 :                                           step,true))
; 1258 :                     continue;
; 1259 :                 }
; 1260 :             }
; 1261 : #endif // KDU_SIMD_OPTIMIZATIONS
; 1262 :           if ((step->support_length==2) && (step->coeffs[0]==step->coeffs[1]))

	mov	edx, DWORD PTR _step$1$[ebp]
	mov	al, BYTE PTR [edx+1]
	cmp	al, 2
	jne	$LN115@horizontal
	mov	eax, DWORD PTR [edx+8]
	movss	xmm2, DWORD PTR [eax]
	ucomiss	xmm2, DWORD PTR [eax+4]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN310@horizontal

; 1263 :             { // Special implementation for symmetric least-dissimilar filters
; 1264 :               if (!reversible)

	mov	eax, DWORD PTR _this$1$[ebp]
	cmp	BYTE PTR [eax+20], 0
	jne	$LN117@horizontal

; 1267 :                   for (k=0; k < width; k++)

	xor	edx, edx
	cmp	ecx, 4
	jl	$LC256@horizontal

; 1265 :                 {
; 1266 :                   float lambda = step->coeffs[0];

	lea	edx, DWORD PTR [esi+8]
	mov	DWORD PTR tv5237[ebp], edx
	lea	eax, DWORD PTR [edi+4]
	mov	edx, esi
	sub	edx, edi
	mov	DWORD PTR tv5235[ebp], edx
	lea	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR tv5235[ebp]
	shr	edx, 2
	inc	edx
	mov	DWORD PTR tv5312[ebp], edx
	shl	edx, 2
	mov	DWORD PTR _k$8$[ebp], edx
	mov	edx, DWORD PTR tv5237[ebp]
	npad	9

; 1267 :                   for (k=0; k < width; k++)

$LL257@horizontal:

; 1268 :                     dp[k].fval -= lambda*(sp[k].fval+sp[k+1].fval);

	movss	xmm1, DWORD PTR [edx-8]
	addss	xmm1, DWORD PTR [ecx+eax]
	movss	xmm0, DWORD PTR [eax-4]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [eax-4], xmm0
	movss	xmm1, DWORD PTR [edx]
	addss	xmm1, DWORD PTR [ecx+eax]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [eax], xmm0
	movss	xmm1, DWORD PTR [edx]
	addss	xmm1, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm1, DWORD PTR [edx+8]
	addss	xmm1, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+8]
	add	edx, 16					; 00000010H
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [eax+8], xmm0
	add	eax, 16					; 00000010H
	sub	DWORD PTR tv5312[ebp], 1
	jne	SHORT $LL257@horizontal
	mov	ecx, DWORD PTR _width$1$[ebp]
	mov	edx, DWORD PTR _k$8$[ebp]
$LC256@horizontal:

; 1267 :                   for (k=0; k < width; k++)

	cmp	edx, ecx
	jge	$LN309@horizontal
	sub	esi, edi
	lea	eax, DWORD PTR [edi+edx*4]
	sub	ecx, edx
	npad	3
$LC49@horizontal:

; 1268 :                     dp[k].fval -= lambda*(sp[k].fval+sp[k+1].fval);

	movss	xmm1, DWORD PTR [eax+esi+4]
	addss	xmm1, DWORD PTR [eax+esi]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LC49@horizontal

; 1269 :                 }
; 1270 :               else

	jmp	$LN309@horizontal
$LN117@horizontal:

; 1271 :                 {
; 1272 :                   kdu_int32 downshift = step->downshift;

	movzx	eax, BYTE PTR [edx+2]
	mov	DWORD PTR _downshift$1$[ebp], eax

; 1273 :                   kdu_int32 offset = step->rounding_offset;

	movsx	eax, WORD PTR [edx+6]
	mov	DWORD PTR _offset$1$[ebp], eax

; 1274 :                   kdu_int32 i_lambda = step->icoeffs[0];

	mov	eax, DWORD PTR [edx+12]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _i_lambda$1$[ebp], eax

; 1275 :                   if (i_lambda == 1)

	cmp	eax, 1
	jne	SHORT $LN119@horizontal

; 1276 :                     for (k=0; k < width; k++)

	test	ecx, ecx
	jle	$LN309@horizontal
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sub	esi, edi
	mov	edx, DWORD PTR _offset$1$[ebp]
$LL52@horizontal:

; 1277 :                       dp[k].ival -=

	mov	eax, DWORD PTR [edi+esi+4]
	lea	edi, DWORD PTR [edi+4]
	add	eax, edx
	add	eax, DWORD PTR [edi+esi-4]
	sar	eax, cl
	sub	DWORD PTR [edi-4], eax
	sub	DWORD PTR _width$1$[ebp], 1
	jne	SHORT $LL52@horizontal

; 1278 :                         ((offset+sp[k].ival+sp[k+1].ival)>>downshift);
; 1279 :                   else if (i_lambda == -1)

	jmp	$LN309@horizontal
$LN119@horizontal:
	cmp	eax, -1
	jne	SHORT $LN121@horizontal

; 1280 :                     for (k=0; k < width; k++)

	test	ecx, ecx
	jle	$LN309@horizontal
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sub	esi, edi
	mov	edx, DWORD PTR _offset$1$[ebp]
$LL55@horizontal:

; 1281 :                       dp[k].ival -=

	mov	eax, edx
	lea	edi, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [esi+edi]
	sub	eax, DWORD PTR [esi+edi-4]
	sar	eax, cl
	sub	DWORD PTR [edi-4], eax
	sub	DWORD PTR _width$1$[ebp], 1
	jne	SHORT $LL55@horizontal

; 1282 :                         ((offset-sp[k].ival-sp[k+1].ival)>>downshift);
; 1283 :                   else

	jmp	$LN309@horizontal
$LN121@horizontal:

; 1284 :                     for (k=0; k < width; k++)

	test	ecx, ecx
	jle	$LN309@horizontal
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sub	esi, edi
	mov	edx, DWORD PTR _offset$1$[ebp]
$LL58@horizontal:

; 1285 :                       dp[k].ival -=

	mov	eax, DWORD PTR [esi+edi+4]
	lea	edi, DWORD PTR [edi+4]
	add	eax, DWORD PTR [esi+edi-4]
	imul	eax, DWORD PTR _i_lambda$1$[ebp]
	add	eax, edx
	sar	eax, cl
	sub	DWORD PTR [edi-4], eax
	sub	DWORD PTR _width$1$[ebp], 1
	jne	SHORT $LL58@horizontal

; 1286 :                       ((offset+i_lambda*(sp[k].ival+sp[k+1].ival))>>downshift);
; 1287 :                 }
; 1288 :             }
; 1289 :           else

	jmp	$LN309@horizontal
$LN310@horizontal:
	mov	al, BYTE PTR [edx+1]
$LN115@horizontal:

; 1290 :             { // Generic 32-bit lifting step implementation
; 1291 :               int t, support=step->support_length;

	movzx	eax, al
	mov	DWORD PTR _support$1$[ebp], eax

; 1292 :               if (!reversible)

	mov	eax, DWORD PTR _this$1$[ebp]
	cmp	BYTE PTR [eax+20], 0
	mov	eax, DWORD PTR _support$1$[ebp]
	jne	$LN123@horizontal

; 1293 :                 {
; 1294 :                   float sum, *cpp = step->coeffs;

	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _cpp$1$[ebp], edx

; 1295 :                   for (k=0; k < width; k++, sp++)

	mov	DWORD PTR _k$9$[ebp], 0
	test	ecx, ecx
	jle	$LN309@horizontal

; 1293 :                 {
; 1294 :                   float sum, *cpp = step->coeffs;

	sub	esi, edx
$LL61@horizontal:

; 1296 :                     {
; 1297 :                       for (sum=0.0F, t=0; t < support; t++)

	xor	edx, edx
	xorps	xmm2, xmm2
	mov	DWORD PTR _t$1$[ebp], edx
	cmp	eax, 4
	jl	SHORT $LC259@horizontal
	mov	eax, DWORD PTR _cpp$1$[ebp]
	mov	edx, DWORD PTR _support$1$[ebp]
	add	edx, -4					; fffffffcH
	shr	edx, 2
	lea	ecx, DWORD PTR [eax+12]
	add	eax, 4
	add	ecx, esi
	inc	edx
	mov	DWORD PTR tv5217[ebp], ecx
	lea	ecx, DWORD PTR [edx*4]
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	ecx, DWORD PTR tv5217[ebp]
	npad	12
$LL260@horizontal:

; 1298 :                         sum += cpp[t] * sp[t].fval;

	movss	xmm1, DWORD PTR [eax-4]
	mulss	xmm1, DWORD PTR [ecx-12]
	movss	xmm0, DWORD PTR [esi+eax]
	mulss	xmm0, DWORD PTR [eax]
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [ecx-4]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [ecx]
	add	eax, 16					; 00000010H
	add	ecx, 16					; 00000010H
	addss	xmm2, xmm0
	sub	edx, 1
	jne	SHORT $LL260@horizontal
	mov	ecx, DWORD PTR _width$1$[ebp]
	mov	eax, DWORD PTR _support$1$[ebp]
	mov	edx, DWORD PTR _t$1$[ebp]
$LC259@horizontal:

; 1296 :                     {
; 1297 :                       for (sum=0.0F, t=0; t < support; t++)

	cmp	edx, eax
	jge	SHORT $LN258@horizontal
	mov	eax, DWORD PTR _cpp$1$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _support$1$[ebp]
	sub	edx, DWORD PTR _t$1$[ebp]
	npad	6
$LC223@horizontal:

; 1298 :                         sum += cpp[t] * sp[t].fval;

	movss	xmm0, DWORD PTR [esi+eax]
	mulss	xmm0, DWORD PTR [eax]
	add	eax, 4
	addss	xmm2, xmm0
	sub	edx, 1
	jne	SHORT $LC223@horizontal
	mov	eax, DWORD PTR _support$1$[ebp]
$LN258@horizontal:

; 1299 :                       dp[k].fval -= sum;

	mov	edx, DWORD PTR _k$9$[ebp]
	add	esi, 4
	movss	xmm0, DWORD PTR [edi+edx*4]
	subss	xmm0, xmm2
	movss	DWORD PTR [edi+edx*4], xmm0
	inc	edx
	mov	DWORD PTR _k$9$[ebp], edx
	cmp	edx, ecx
	jl	$LL61@horizontal

; 1300 :                     }
; 1301 :                 }
; 1302 :               else

	jmp	$LN309@horizontal
$LN123@horizontal:

; 1303 :                 {
; 1304 :                   kdu_int32 downshift = step->downshift;

	movzx	eax, BYTE PTR [edx+2]
	mov	DWORD PTR _downshift$1$[ebp], eax

; 1305 :                   kdu_int32 offset = step->rounding_offset;

	movsx	eax, WORD PTR [edx+6]

; 1306 :                   int sum, *cpp = step->icoeffs;

	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR _offset$1$[ebp], eax

; 1307 :                   for (k=0; k < width; k++, sp++)

	mov	eax, DWORD PTR _support$1$[ebp]
	mov	DWORD PTR _cpp$1$[ebp], edx
	mov	DWORD PTR _k$10$[ebp], 0
	test	ecx, ecx
	jle	$LN309@horizontal

; 1303 :                 {
; 1304 :                   kdu_int32 downshift = step->downshift;

	mov	ecx, esi
	sub	ecx, edx
	mov	DWORD PTR tv5200[ebp], ecx
	npad	6
$LL67@horizontal:

; 1308 :                     {
; 1309 :                       for (sum=offset, t=0; t < support; t++)

	mov	edx, DWORD PTR _offset$1$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _sum$1$[ebp], edx
	test	eax, eax
	jle	$LN226@horizontal
	cmp	eax, 8
	jb	$LN226@horizontal
	cmp	DWORD PTR ___isa_available, 2
	jl	$LN226@horizontal
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN312@horizontal
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN312@horizontal:
	mov	edx, DWORD PTR _support$1$[ebp]
	xorps	xmm6, xmm6
	sub	edx, eax
	movaps	xmm5, xmm6
	mov	eax, DWORD PTR tv5200[ebp]
	mov	DWORD PTR tv5201[ebp], edx
	mov	edx, DWORD PTR _cpp$1$[ebp]
	mov	edi, edx
	add	edi, 8
	add	eax, edi
	mov	edi, DWORD PTR _dp$1$[ebp]
$LL70@horizontal:

; 1310 :                         sum += cpp[t] * sp[t].ival;

	movd	xmm2, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [edx+32]
	movd	xmm0, DWORD PTR [eax]
	lea	eax, DWORD PTR [eax+32]
	movd	xmm1, DWORD PTR [eax-36]
	add	ecx, 8
	movd	xmm3, DWORD PTR [eax-40]
	movups	xmm4, XMMWORD PTR [edx-32]
	punpckldq xmm3, xmm0
	movd	xmm0, DWORD PTR [eax-16]
	punpckldq xmm1, xmm2
	movd	xmm2, DWORD PTR [eax-12]
	punpckldq xmm3, xmm1
	movd	xmm1, DWORD PTR [eax-20]
	pmulld	xmm3, xmm4
	paddd	xmm6, xmm3
	movd	xmm3, DWORD PTR [eax-24]
	movups	xmm4, XMMWORD PTR [edx-16]
	punpckldq xmm3, xmm0
	punpckldq xmm1, xmm2
	punpckldq xmm3, xmm1
	pmulld	xmm3, xmm4
	paddd	xmm5, xmm3
	cmp	ecx, DWORD PTR tv5201[ebp]
	jl	SHORT $LL70@horizontal
	mov	eax, DWORD PTR _support$1$[ebp]
	paddd	xmm5, xmm6
	movaps	xmm0, xmm5
	psrldq	xmm0, 8
	paddd	xmm5, xmm0
	movaps	xmm0, xmm5
	psrldq	xmm0, 4
	paddd	xmm5, xmm0
	movd	edx, xmm5
	add	edx, DWORD PTR _offset$1$[ebp]
	mov	DWORD PTR _sum$1$[ebp], edx
$LN226@horizontal:
	mov	DWORD PTR $T6[ebp], 0
	mov	DWORD PTR $T3[ebp], 0
	cmp	ecx, eax
	jge	SHORT $LN261@horizontal
	sub	eax, ecx

; 1308 :                     {
; 1309 :                       for (sum=offset, t=0; t < support; t++)

	cmp	eax, 2
	jl	SHORT $LC262@horizontal
	mov	eax, DWORD PTR _support$1$[ebp]
	mov	edx, DWORD PTR _cpp$1$[ebp]
	dec	eax
	mov	edi, DWORD PTR tv5200[ebp]
	add	edx, 4
	mov	DWORD PTR tv5255[ebp], eax
	lea	edx, DWORD PTR [edx+ecx*4]
	npad	4
$LL264@horizontal:

; 1310 :                         sum += cpp[t] * sp[t].ival;

	mov	eax, DWORD PTR [esi+ecx*4]
	lea	edx, DWORD PTR [edx+8]
	imul	eax, DWORD PTR [edx-12]
	add	ecx, 2
	add	DWORD PTR $T6[ebp], eax
	mov	eax, DWORD PTR [edi+edx-8]
	imul	eax, DWORD PTR [edx-8]
	add	DWORD PTR $T3[ebp], eax
	cmp	ecx, DWORD PTR tv5255[ebp]
	jl	SHORT $LL264@horizontal
	mov	edi, DWORD PTR _dp$1$[ebp]
$LC262@horizontal:
	mov	edx, DWORD PTR _sum$1$[ebp]
	cmp	ecx, DWORD PTR _support$1$[ebp]
	jge	SHORT $LN263@horizontal
	mov	eax, DWORD PTR _cpp$1$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	imul	eax, DWORD PTR [esi+ecx*4]
	add	edx, eax
$LN263@horizontal:
	mov	eax, DWORD PTR $T6[ebp]
	add	eax, DWORD PTR $T3[ebp]
	add	edx, eax
	mov	eax, DWORD PTR _support$1$[ebp]
$LN261@horizontal:

; 1311 :                       dp[k].ival -= (sum >> downshift);

	mov	ecx, DWORD PTR _downshift$1$[ebp]
	add	esi, 4
	add	DWORD PTR tv5200[ebp], 4
	sar	edx, cl
	mov	ecx, DWORD PTR _k$10$[ebp]
	sub	DWORD PTR [edi+ecx*4], edx
	inc	ecx
	mov	DWORD PTR _k$10$[ebp], ecx
	cmp	ecx, DWORD PTR _width$1$[ebp]
	jl	$LL67@horizontal
$LN309@horizontal:
	mov	edi, DWORD PTR _this$1$[ebp]
$LN17@horizontal:

; 1137 :     return;
; 1138 : 
; 1139 :   // Perform horizontal lifting steps
; 1140 :   for (s=num_hor_steps-1; s >= 0; s--)

	mov	eax, DWORD PTR _s$1$[ebp]
	movss	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	sub	eax, 1
	mov	DWORD PTR _s$1$[ebp], eax
	jns	$LL19@horizontal
$LN18@horizontal:
	pop	edi
	pop	esi

; 1312 :                     }
; 1313 :                 }
; 1314 :             }
; 1315 :         }
; 1316 :     }
; 1317 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?horizontal_synthesis@kd_synthesis@@IAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z ENDP ; kd_synthesis::horizontal_synthesis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
;	COMDAT ?simulate_vertical_lifting@kd_synthesis@@IAEHH@Z
_TEXT	SEGMENT
_sim_y_max_in$ = -48					; size = 8
tv1270 = -40						; size = 4
tv1171 = -40						; size = 4
_idx$1$ = -40						; size = 4
tv1285 = -36						; size = 4
_step$1$ = -36						; size = 4
tv1287 = -32						; size = 4
_src_idx$1$ = -32					; size = 4
_max_source_request_idx$1$ = -28			; size = 4
tv1240 = -24						; size = 4
_y_min$1$ = -24						; size = 4
tv1275 = -20						; size = 4
_local_y_min$1$ = -20					; size = 4
_sim_y_max_out$1$ = -16					; size = 4
tv1243 = -12						; size = 4
_vsub_parity$1$ = -12					; size = 4
_s$3$ = -8						; size = 4
_y_max$1$ = -8						; size = 4
_used_lines$ = -4					; size = 4
_idx$1$ = 8						; size = 4
tv1241 = 8						; size = 4
_local_y_max$1$ = 8					; size = 4
_support_max$ = 8					; size = 4
?simulate_vertical_lifting@kd_synthesis@@IAEHH@Z PROC	; kd_synthesis::simulate_vertical_lifting, COMDAT
; _this$ = ecx

; 702  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 703  :   int s, s_max, src_idx, vsub_parity;
; 704  :   int max_used_lines=0, used_lines=0;

	xor	esi, esi
	xor	ebx, ebx
	mov	DWORD PTR _used_lines$[ebp], esi

; 705  :   kd_lifting_step *step;
; 706  : 
; 707  :   // Find simple upper bounds to avoid wasting too much simulation effort
; 708  :   int sim_y_max_out = y_max_out;

	mov	eax, DWORD PTR [edi+76]

; 709  :   int sim_y_max_in[2] = {y_max_in[0], y_max_in[1]};

	mov	ecx, DWORD PTR [edi+96]
	mov	edx, DWORD PTR [edi+100]
	mov	DWORD PTR _sim_y_max_out$1$[ebp], eax

; 710  :   int delta = sim_y_max_out - (y_min_out + support_max + 2);

	sub	eax, DWORD PTR [edi+68]
	sub	eax, DWORD PTR _support_max$[ebp]
	sub	eax, 2
	mov	DWORD PTR _sim_y_max_in$[ebp], ecx
	mov	DWORD PTR _sim_y_max_in$[ebp+4], edx

; 711  :   if (delta > 0)

	test	eax, eax
	jle	SHORT $LN17@simulate_v

; 712  :     {
; 713  :       delta &= ~1; // Change height by multiple of 2

	and	eax, -2					; fffffffeH

; 714  :       sim_y_max_out -= delta;

	sub	DWORD PTR _sim_y_max_out$1$[ebp], eax

; 715  :       sim_y_max_in[0] -= delta;

	sub	ecx, eax

; 716  :       sim_y_max_in[1] -= delta;

	sub	edx, eax
	mov	DWORD PTR _sim_y_max_in$[ebp], ecx
	mov	DWORD PTR _sim_y_max_in$[ebp+4], edx
$LN17@simulate_v:

; 717  :     }
; 718  : 
; 719  :   // Set up counters for simulation
; 720  :   y_next_out = y_min_out;

	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR [edi+72], eax

; 721  :   y_next_in[0] = y_min_in[0];  y_next_in[1] = y_min_in[1];

	mov	eax, DWORD PTR [edi+80]
	mov	ebx, DWORD PTR [edi+84]

; 722  :   {
; 723  :     int y_min = (y_min_in[0] < y_min_in[1])?y_min_in[0]:y_min_in[1];

	cmp	eax, ebx
	mov	DWORD PTR [edi+92], ebx
	cmovl	ebx, eax
	mov	DWORD PTR [edi+88], eax

; 724  :     int y_max =
; 725  :       (sim_y_max_in[0] > sim_y_max_in[1])?sim_y_max_in[0]:sim_y_max_in[1];

	cmp	ecx, edx
	mov	DWORD PTR _y_min$1$[ebp], ebx

; 726  :     for (s=-1; s < num_vert_steps; s++)

	mov	ebx, esi
	cmovg	edx, ecx
	mov	DWORD PTR _y_max$1$[ebp], edx
	or	edx, -1
	cmp	DWORD PTR [edi+24], edx
	jle	$LN3@simulate_v
	mov	ecx, DWORD PTR _y_min$1$[ebp]
	lea	ebx, DWORD PTR [edx-39]
	mov	eax, DWORD PTR _y_max$1$[ebp]
	inc	ecx
	dec	eax
	mov	DWORD PTR tv1287[ebp], ecx
	mov	DWORD PTR tv1285[ebp], eax
	mov	DWORD PTR tv1243[ebp], -20		; ffffffecH
	npad	7
$LL4@simulate_v:

; 727  :       {
; 728  :         int local_y_min = (y_min_in[s&1] > (y_min+1))?(y_min_in[s&1]):y_min;

	mov	esi, DWORD PTR _y_min$1$[ebp]
	mov	ecx, edx
	and	ecx, 1
	mov	eax, DWORD PTR [edi+ecx*4+80]
	cmp	eax, DWORD PTR tv1287[ebp]
	cmovg	esi, eax

; 729  :         int local_y_max =
; 730  :           (sim_y_max_in[s&1] < (y_max-1))?(sim_y_max_in[s&1]):y_max;

	mov	eax, DWORD PTR _sim_y_max_in$[ebp+ecx*4]
	cmp	eax, DWORD PTR tv1285[ebp]
	mov	ecx, DWORD PTR _y_max$1$[ebp]
	cmovl	ecx, eax
	mov	DWORD PTR tv1171[ebp], eax

; 731  :         int max_source_request_idx = local_y_max - ((local_y_max ^ s) & 1);

	mov	eax, ecx
	mov	DWORD PTR _local_y_max$1$[ebp], ecx
	xor	eax, edx
	mov	DWORD PTR _local_y_min$1$[ebp], esi

; 732  :         if (s >= 0)

	mov	esi, DWORD PTR tv1243[ebp]
	and	eax, 1
	sub	ecx, eax
	mov	DWORD PTR _max_source_request_idx$1$[ebp], ecx
	test	edx, edx
	js	SHORT $LN18@simulate_v

; 733  :           max_source_request_idx = sim_y_max_in[s & 1] +

	mov	eax, DWORD PTR [edi+44]
	movsx	ecx, WORD PTR [eax+esi+4]
	movzx	eax, BYTE PTR [eax+esi+1]
	add	ecx, eax
	mov	eax, DWORD PTR tv1171[ebp]
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -2					; fffffffeH
	mov	DWORD PTR _max_source_request_idx$1$[ebp], eax
$LN18@simulate_v:

; 734  :             2*(vert_steps[s].support_min - 1 +
; 735  :                (int) vert_steps[s].support_length);
; 736  :         queues[s].init(local_y_min,local_y_max,s,vert_symmetric_extension,

	mov	ecx, DWORD PTR [edi+60]
	mov	al, BYTE PTR [edi+54]
	add	ecx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 125  :         this->y_min = y_min;  this->y_max = y_max;

	mov	esi, DWORD PTR _local_y_min$1$[ebp]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR _local_y_max$1$[ebp]
	mov	DWORD PTR [ecx+4], esi

; 126  :         head_idx = source_pos = update_pos = y_min - 1000; // Ridiculous value

	mov	esi, DWORD PTR _local_y_min$1$[ebp]
	add	esi, -1000				; fffffc18H

; 127  :         this->symmetric_extension = symmetric_extension;

	mov	BYTE PTR [ecx+36], al

; 128  :         if ((!symmetric_extension) || (max_source_request_idx < y_max))

	test	al, al
	mov	BYTE PTR [ecx+37], dl
	mov	eax, DWORD PTR _local_y_max$1$[ebp]
	mov	DWORD PTR [ecx+28], esi
	mov	DWORD PTR [ecx+24], esi
	mov	DWORD PTR [ecx+16], esi
	je	SHORT $LN44@simulate_v
	mov	esi, DWORD PTR _max_source_request_idx$1$[ebp]
	cmp	esi, eax
	jl	SHORT $LN44@simulate_v

; 130  :         else
; 131  :           recycling_lim = 2*y_max - max_source_request_idx;

	add	eax, eax
	sub	eax, esi
	jmp	SHORT $LN113@simulate_v
$LN44@simulate_v:

; 129  :           recycling_lim = y_max - 1; // Keep last row only

	dec	eax
$LN113@simulate_v:
	mov	DWORD PTR [ecx+32], eax

; 132  :         if (queue_idx < 0)

	test	edx, edx
	jns	SHORT $LN45@simulate_v

; 133  :           source_pos = recycling_lim = y_max+2; // Block use of `access_source'

	mov	eax, DWORD PTR _local_y_max$1$[ebp]
	add	eax, 2
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+24], eax
$LN45@simulate_v:

; 134  :         tail_idx = head_idx - 2;

	mov	eax, DWORD PTR _local_y_min$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 738  :         if ((s >= 0) && (vert_steps[s].support_length <= 0))

	mov	esi, DWORD PTR tv1243[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 134  :         tail_idx = head_idx - 2;

	add	eax, -1002				; fffffc16H
	mov	DWORD PTR [ecx+20], eax

; 135  :         head = tail = NULL;

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 738  :         if ((s >= 0) && (vert_steps[s].support_length <= 0))

	test	edx, edx
	js	SHORT $LN2@simulate_v
	mov	eax, DWORD PTR [edi+44]
	cmp	BYTE PTR [eax+esi+1], 0
	ja	SHORT $LN2@simulate_v

; 739  :           queues[s].source_done();

	mov	ecx, DWORD PTR [edi+60]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 145  :         source_pos = recycling_lim = y_max + 2;

	mov	eax, DWORD PTR [ecx+ebx+4]
	add	eax, 2
	mov	DWORD PTR [ecx+ebx+32], eax
	mov	DWORD PTR [ecx+ebx+24], eax
$LN2@simulate_v:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 726  :     for (s=-1; s < num_vert_steps; s++)

	inc	edx
	add	esi, 20					; 00000014H
	add	ebx, 40					; 00000028H
	mov	DWORD PTR tv1243[ebp], esi
	cmp	edx, DWORD PTR [edi+24]
	jl	$LL4@simulate_v
	xor	esi, esi
	xor	ebx, ebx
$LN3@simulate_v:

; 740  :       }
; 741  :   }
; 742  :   for (s=0; s < num_vert_steps; s++)

	cmp	DWORD PTR [edi+24], 0
	jle	SHORT $LN6@simulate_v
	xor	ebx, ebx
$LL7@simulate_v:

; 743  :     step_next_row_pos[s] = y_min_in[1-(s&1)];

	mov	ecx, DWORD PTR [edi+64]
	mov	eax, ebx
	and	eax, 1
	mov	edx, 21					; 00000015H
	sub	edx, eax
	mov	eax, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [ecx+ebx*4], eax
	inc	ebx
	cmp	ebx, DWORD PTR [edi+24]
	jl	SHORT $LL7@simulate_v
	xor	ebx, ebx
$LN6@simulate_v:

; 746  :   for (; y_next_out <= sim_y_max_out; y_next_out++)

	mov	eax, DWORD PTR _sim_y_max_out$1$[ebp]
	cmp	DWORD PTR [edi+72], eax
	jg	$LN108@simulate_v
	npad	3
$LL10@simulate_v:

; 747  :     {
; 748  :       s_max = -1;

	or	edx, -1
$LL13@simulate_v:

; 751  :           for (s=s_max; s >= 0; s--)

	mov	eax, edx
	mov	DWORD PTR _s$3$[ebp], eax
	test	edx, edx
	js	$LN104@simulate_v
	lea	ecx, DWORD PTR [edx+edx*4]
	shl	ecx, 3
	mov	DWORD PTR tv1241[ebp], ecx
	lea	ecx, DWORD PTR [edx+edx*4]
	shl	ecx, 2
	mov	DWORD PTR tv1240[ebp], ecx
$LL16@simulate_v:

; 752  :             {
; 753  :               vsub_parity = 1 - (s & 1); // Parity of output line for this step

	and	eax, 1
	mov	edx, 1
	sub	edx, eax

; 754  :               if (s == num_vert_steps)

	mov	eax, DWORD PTR _s$3$[ebp]
	mov	DWORD PTR _vsub_parity$1$[ebp], edx
	cmp	eax, DWORD PTR [edi+24]
	jne	SHORT $LN20@simulate_v

; 755  :                 { // This happens when we need to load data into the last
; 756  :                   // queue
; 757  :                   if (y_next_in[vsub_parity] <= sim_y_max_in[vsub_parity])

	add	edx, 22					; 00000016H
	lea	eax, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv1270[ebp], eax
	mov	eax, DWORD PTR _vsub_parity$1$[ebp]
	cmp	edx, DWORD PTR _sim_y_max_in$[ebp+eax*4]
	jg	$LN14@simulate_v

; 758  :                     {
; 759  :                       used_lines++; // Simulate getting new line from free list
; 760  :                       if (used_lines > max_used_lines)
; 761  :                         max_used_lines = used_lines;
; 762  :                       queues[s-1].simulate_push_line(y_next_in[vsub_parity],

	mov	ecx, DWORD PTR tv1241[ebp]
	inc	esi
	cmp	esi, ebx
	mov	DWORD PTR _used_lines$[ebp], esi
	cmovg	ebx, esi
	add	ecx, DWORD PTR [edi+60]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 252  :         if ((idx < source_pos) && (idx < update_pos))

	cmp	edx, DWORD PTR [ecx-16]
	jge	SHORT $LN50@simulate_v
	cmp	edx, DWORD PTR [ecx-12]
	jge	SHORT $LN50@simulate_v
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 764  :                       y_next_in[vsub_parity] += 2;

	mov	eax, DWORD PTR tv1270[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 254  :             used_lines--;  return;

	dec	esi
	mov	DWORD PTR _used_lines$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 764  :                       y_next_in[vsub_parity] += 2;

	add	DWORD PTR [eax], 2

; 765  :                     }
; 766  :                   continue;

	jmp	$LN14@simulate_v
$LN50@simulate_v:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 256  :         if (tail_idx < head_idx)

	mov	eax, DWORD PTR [ecx-20]
	cmp	eax, DWORD PTR [ecx-24]
	jge	SHORT $LN51@simulate_v

; 257  :           head_idx = idx;

	mov	DWORD PTR [ecx-24], edx
$LN51@simulate_v:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 764  :                       y_next_in[vsub_parity] += 2;

	mov	eax, DWORD PTR tv1270[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 258  :         tail_idx = idx;

	mov	DWORD PTR [ecx-20], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 764  :                       y_next_in[vsub_parity] += 2;

	add	DWORD PTR [eax], 2

; 765  :                     }
; 766  :                   continue;

	jmp	$LN14@simulate_v
$LN20@simulate_v:

; 767  :                 }
; 768  : 
; 769  :               step = vert_steps + s;

	mov	ecx, DWORD PTR [edi+44]
	add	ecx, DWORD PTR tv1240[ebp]
	shl	eax, 2
	mov	DWORD PTR tv1275[ebp], eax

; 770  :               src_idx = (step_next_row_pos[s] ^ 1) + 2*step->support_min;

	mov	edx, eax
	mov	eax, DWORD PTR [edi+64]
	mov	DWORD PTR _step$1$[ebp], ecx
	movsx	ecx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax]

; 771  :               if (step_next_row_pos[s] > sim_y_max_in[vsub_parity])

	mov	edx, DWORD PTR _vsub_parity$1$[ebp]
	mov	DWORD PTR _idx$1$[ebp], eax
	xor	eax, 1
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	ecx, DWORD PTR _idx$1$[ebp]
	mov	DWORD PTR _src_idx$1$[ebp], eax
	cmp	ecx, DWORD PTR _sim_y_max_in$[ebp+edx*4]
	jg	$LN14@simulate_v

; 772  :                 continue; // Lifting step is finished
; 773  : 
; 774  :               if (s < (num_vert_steps-1))

	mov	eax, DWORD PTR [edi+24]
	dec	eax
	cmp	DWORD PTR _s$3$[ebp], eax
	jge	SHORT $LN25@simulate_v

; 775  :                 {
; 776  :                   if (!queues[s+1].test_update(step_next_row_pos[s],false))

	mov	eax, DWORD PTR [edi+60]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 179  :         update_pos = idx;

	mov	edx, DWORD PTR tv1241[ebp]
	mov	DWORD PTR [edx+eax+68], ecx

; 180  :         return ((idx >= head_idx) && (idx <= tail_idx) &&

	cmp	ecx, DWORD PTR [edx+eax+56]
	jl	$LN82@simulate_v
	cmp	ecx, DWORD PTR [edx+eax+60]
	mov	edx, DWORD PTR _vsub_parity$1$[ebp]
	jg	$LN82@simulate_v
$LN25@simulate_v:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 782  :               if ((step->support_length > 0) &&

	mov	eax, DWORD PTR _step$1$[ebp]
	mov	al, BYTE PTR [eax+1]
	test	al, al
	je	SHORT $LN26@simulate_v
	lea	ecx, DWORD PTR _used_lines$[ebp]
	movzx	eax, al
	push	ecx
	mov	ecx, DWORD PTR [edi+60]
	add	ecx, DWORD PTR tv1241[ebp]
	push	eax
	push	DWORD PTR _src_idx$1$[ebp]
	call	?simulate_access_source@kd_vlift_queue@@QAE_NHHAAH@Z ; kd_vlift_queue::simulate_access_source
	mov	esi, DWORD PTR _used_lines$[ebp]
	test	al, al
	je	$LN83@simulate_v
	mov	edx, DWORD PTR _vsub_parity$1$[ebp]
$LN26@simulate_v:

; 788  :                   break;
; 789  :                 }
; 790  :               if (s == (num_vert_steps-1))

	mov	eax, DWORD PTR [edi+24]
	dec	eax
	cmp	DWORD PTR _s$3$[ebp], eax
	jne	SHORT $LN27@simulate_v

; 791  :                 { // Read update row from subbands
; 792  :                   used_lines++; // Simulate getting input line from free list

	inc	esi

; 793  :                                 // and re-using it as the output line
; 794  :                   if (used_lines > max_used_lines)

	cmp	esi, ebx
	cmovg	ebx, esi

; 795  :                     max_used_lines = used_lines;
; 796  :                   assert(step_next_row_pos[s] == y_next_in[vsub_parity]);
; 797  :                   y_next_in[vsub_parity] += 2;

	add	DWORD PTR [edi+edx*4+88], 2

; 798  :                 }
; 799  :               else

	jmp	SHORT $LN114@simulate_v
$LN27@simulate_v:

; 800  :                 {
; 801  :                   queues[s+1].simulate_access_update(step_next_row_pos[s],

	mov	eax, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR tv1275[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR tv1241[ebp]
	add	ecx, DWORD PTR [edi+60]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 267  :         if ((idx < head_idx) || (idx > tail_idx))

	mov	eax, DWORD PTR [ecx+56]
	mov	DWORD PTR [ecx+68], edx
	cmp	edx, eax
	jl	SHORT $LN109@simulate_v
	cmp	edx, DWORD PTR [ecx+60]
	jg	SHORT $LN109@simulate_v

; 268  :           return false;
; 269  :         update_pos += 2;

	add	edx, 2
	mov	DWORD PTR [ecx+68], edx

; 270  :         while ((head_idx < update_pos) && (head_idx < source_pos) &&
; 271  :                (tail_idx >= head_idx) && (head_idx < recycling_lim))

	cmp	eax, edx
	jge	SHORT $LN109@simulate_v
	npad	3
$LL60@simulate_v:
	mov	eax, DWORD PTR [ecx+56]
	cmp	eax, DWORD PTR [ecx+64]
	jge	SHORT $LN109@simulate_v
	cmp	DWORD PTR [ecx+60], eax
	jl	SHORT $LN109@simulate_v
	cmp	eax, DWORD PTR [ecx+72]
	jge	SHORT $LN109@simulate_v

; 272  :           { head_idx+=2; used_lines--; }

	add	eax, 2
	dec	esi
	mov	DWORD PTR [ecx+56], eax
	cmp	eax, edx
	jl	SHORT $LL60@simulate_v
$LN109@simulate_v:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 803  :                   used_lines++; // Simulate getting output line from free list

	inc	esi

; 804  :                   if (used_lines > max_used_lines)

	cmp	esi, ebx
	cmovg	ebx, esi
$LN114@simulate_v:

; 805  :                     max_used_lines = used_lines;
; 806  :                 }
; 807  : 
; 808  :               queues[s-1].simulate_push_line(step_next_row_pos[s],used_lines);

	mov	ecx, DWORD PTR tv1275[ebp]
	mov	eax, DWORD PTR [edi+64]
	mov	DWORD PTR _used_lines$[ebp], esi
	mov	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR tv1241[ebp]
	add	ecx, DWORD PTR [edi+60]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 252  :         if ((idx < source_pos) && (idx < update_pos))

	cmp	edx, DWORD PTR [ecx-16]
	jge	SHORT $LN66@simulate_v
	cmp	edx, DWORD PTR [ecx-12]
	jge	SHORT $LN66@simulate_v

; 254  :             used_lines--;  return;

	dec	esi
	mov	DWORD PTR _used_lines$[ebp], esi
	jmp	SHORT $LN65@simulate_v
$LN66@simulate_v:

; 256  :         if (tail_idx < head_idx)

	mov	eax, DWORD PTR [ecx-20]
	cmp	eax, DWORD PTR [ecx-24]
	jge	SHORT $LN67@simulate_v

; 257  :           head_idx = idx;

	mov	DWORD PTR [ecx-24], edx
$LN67@simulate_v:

; 258  :         tail_idx = idx;

	mov	DWORD PTR [ecx-20], edx
$LN65@simulate_v:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 751  :           for (s=s_max; s >= 0; s--)

	mov	eax, DWORD PTR [edi+64]

; 809  : 
; 810  :               step_next_row_pos[s] += 2;

	mov	ecx, DWORD PTR tv1275[ebp]
	add	DWORD PTR [ecx+eax], 2
$LN14@simulate_v:

; 751  :           for (s=s_max; s >= 0; s--)

	mov	eax, DWORD PTR _s$3$[ebp]
	sub	DWORD PTR tv1240[ebp], 20		; 00000014H
	dec	eax
	sub	DWORD PTR tv1241[ebp], 40		; 00000028H
	mov	DWORD PTR _s$3$[ebp], eax
	test	eax, eax
	jns	$LL16@simulate_v
	jmp	SHORT $LN104@simulate_v
$LN82@simulate_v:

; 777  :                     { // Need to progress up-stream synthesis step
; 778  :                       s_max = s+2;

	mov	eax, DWORD PTR _s$3$[ebp]
	lea	edx, DWORD PTR [eax+2]

; 779  :                       break;

	jmp	SHORT $LN15@simulate_v
$LN83@simulate_v:

; 783  :                   !queues[s].simulate_access_source(src_idx,
; 784  :                                                     step->support_length,
; 785  :                                                     used_lines))
; 786  :                 { // Can't access all source lines required by step
; 787  :                   s_max = s+1;

	mov	eax, DWORD PTR _s$3$[ebp]
	lea	edx, DWORD PTR [eax+1]
$LN15@simulate_v:

; 811  :             }
; 812  : 
; 813  :           if (s < 0)

	test	eax, eax
	jns	$LL13@simulate_v
$LN104@simulate_v:

; 814  :             { // Finished a round of vertical synthesis.  See if we have
; 815  :               // the required row yet
; 816  :               s_max = 1 - (y_next_out & 1);

	mov	eax, DWORD PTR [edi+72]
	mov	edx, 1
	mov	DWORD PTR _idx$1$[ebp], eax
	and	eax, 1
	sub	edx, eax

; 817  :               have_result =

	mov	eax, DWORD PTR [edi+60]
	lea	ecx, DWORD PTR [edx+edx*4]
	lea	ecx, DWORD PTR [eax+ecx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 266  :         update_pos = idx; // At least this large

	mov	eax, DWORD PTR _idx$1$[ebp]
	mov	DWORD PTR [ecx-12], eax

; 267  :         if ((idx < head_idx) || (idx > tail_idx))

	cmp	eax, DWORD PTR [ecx-24]
	jl	$LL13@simulate_v
	cmp	eax, DWORD PTR [ecx-20]
	jg	$LL13@simulate_v

; 268  :           return false;
; 269  :         update_pos += 2;

	lea	edx, DWORD PTR [eax+2]
	mov	DWORD PTR [ecx-12], edx

; 270  :         while ((head_idx < update_pos) && (head_idx < source_pos) &&
; 271  :                (tail_idx >= head_idx) && (head_idx < recycling_lim))

	cmp	DWORD PTR [ecx-24], edx
	jge	SHORT $LN110@simulate_v
$LL70@simulate_v:
	mov	eax, DWORD PTR [ecx-24]
	cmp	eax, DWORD PTR [ecx-16]
	jge	SHORT $LN110@simulate_v
	cmp	DWORD PTR [ecx-20], eax
	jl	SHORT $LN110@simulate_v
	cmp	eax, DWORD PTR [ecx-8]
	jge	SHORT $LN110@simulate_v

; 272  :           { head_idx+=2; used_lines--; }

	add	eax, 2
	dec	esi
	mov	DWORD PTR [ecx-24], eax
	mov	DWORD PTR _used_lines$[ebp], esi
	cmp	eax, edx
	jl	SHORT $LL70@simulate_v
$LN110@simulate_v:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 746  :   for (; y_next_out <= sim_y_max_out; y_next_out++)

	inc	DWORD PTR [edi+72]
	mov	eax, DWORD PTR _sim_y_max_out$1$[ebp]
	cmp	DWORD PTR [edi+72], eax
	jle	$LL10@simulate_v
$LN108@simulate_v:
	pop	edi
	pop	esi

; 818  :                 queues[s_max-1].simulate_access_update(y_next_out,used_lines);
; 819  :             }
; 820  :         } while (!have_result);
; 821  :     }
; 822  : 
; 823  :   return max_used_lines;

	mov	eax, ebx
	pop	ebx

; 824  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?simulate_vertical_lifting@kd_synthesis@@IAEHH@Z ENDP	; kd_synthesis::simulate_vertical_lifting
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
;	COMDAT ?pull@kd_synthesis@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
tv2723 = -44						; size = 4
tv2717 = -44						; size = 4
_src_idx$1$ = -40					; size = 4
tv2683 = -40						; size = 4
tv2681 = -36						; size = 4
_this$1$ = -32						; size = 4
_s$1$ = -28						; size = 4
tv2745 = -24						; size = 4
tv2728 = -24						; size = 4
tv2687 = -24						; size = 4
tv2686 = -20						; size = 4
_c$1$ = -16						; size = 4
_step$1$ = -12						; size = 4
_this$1$ = -8						; size = 4
tv2682 = -8						; size = 4
_vline_in$2$ = -4					; size = 4
_dp$1$ = 8						; size = 4
tv2699 = 8						; size = 4
_line$ = 8						; size = 4
_sp2$1$ = 12						; size = 4
_c$4$ = 12						; size = 4
tv2731 = 12						; size = 4
tv2708 = 12						; size = 4
_env$ = 12						; size = 4
?pull@kd_synthesis@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z PROC ; kd_synthesis::pull, COMDAT
; _this$ = ecx

; 857  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi

; 858  :   if (empty)

	cmp	BYTE PTR [esi+165], 0
	jne	$LN232@pull

; 859  :     return;
; 860  : 
; 861  :   kd_vlift_line *vline_in, *vline_out=NULL;
; 862  :   if (!initialized)

	cmp	BYTE PTR [esi+21], 0
	mov	ecx, DWORD PTR _env$[ebp]
	jne	SHORT $LN54@pull

; 863  :     start(env);

	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _env$[ebp]
$LN54@pull:

; 864  : 
; 865  :   assert(y_next_out <= y_max_out);
; 866  : 
; 867  :   int c, k;
; 868  :   int vsub_parity=(vert_xform_exists)?(y_next_out&1):0; // Vert subband parity

	cmp	BYTE PTR [esi+22], 0
	push	ebx
	je	SHORT $LN91@pull
	mov	ebx, DWORD PTR [esi+72]
	and	ebx, 1
	jmp	SHORT $LN92@pull
$LN91@pull:
	xor	ebx, ebx
$LN92@pull:

; 869  :   if ((num_vert_steps == 0) || unit_height)

	cmp	DWORD PTR [esi+24], 0
	push	edi
	je	$LN57@pull
	cmp	BYTE PTR [esi+163], 0
	jne	$LN57@pull

; 890  :             }
; 891  :         }
; 892  :     }
; 893  :   else
; 894  :     { // Need to perform vertical synthesis
; 895  :       kd_lifting_step *step;
; 896  :       int src_idx, s, s_max=-1;

	or	edi, -1
	npad	7
$LL16@pull:

; 897  :       do { // Loop until row `y_next_out' becomes available
; 898  :           for (s=s_max; s >= 0; s--)

	mov	eax, edi
	mov	DWORD PTR _s$1$[ebp], eax
	test	edi, edi
	js	$LN269@pull
	lea	ecx, DWORD PTR [edi+edi*4]
	shl	ecx, 3
	lea	edx, DWORD PTR [edi+edi*4]
	shl	edx, 2
	mov	DWORD PTR tv2682[ebp], ecx
	mov	DWORD PTR tv2681[ebp], edx
	npad	1
$LL19@pull:

; 899  :             {
; 900  :               vsub_parity = 1 - (s & 1); // Parity of output line for this step
; 901  :               if (s == num_vert_steps)

	mov	edi, DWORD PTR [esi+24]
	and	eax, 1
	mov	ebx, 1
	sub	ebx, eax
	mov	eax, DWORD PTR _s$1$[ebp]
	cmp	eax, edi
	jne	SHORT $LN61@pull

; 902  :                 { // This happens when we need to load data into the last
; 903  :                   // queue
; 904  :                   if (y_next_in[vsub_parity] <= y_max_in[vsub_parity])

	lea	eax, DWORD PTR [ebx+22]
	lea	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR tv2723[ebp], eax
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [esi+ebx*4+96]
	jg	$LN17@pull

; 905  :                     {
; 906  :                       vline_in = free_lines;  assert(vline_in != NULL);

	mov	edi, DWORD PTR [esi+40]
	add	esi, 40					; 00000028H

; 907  :                       free_lines = vline_in->next;  vline_in->next = NULL;
; 908  :                       horizontal_synthesis(vline_in,vsub_parity,env);

	push	DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	ebx
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [esi], eax
	push	edi
	mov	DWORD PTR [edi+24], 0
	call	?horizontal_synthesis@kd_synthesis@@IAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z ; kd_synthesis::horizontal_synthesis

; 909  :                       queues[s-1].push_line(y_next_in[vsub_parity],vline_in,

	mov	ecx, DWORD PTR tv2682[ebp]
	push	esi
	mov	esi, DWORD PTR _this$1$[ebp]
	add	ecx, -40				; ffffffd8H
	push	edi
	mov	edi, DWORD PTR tv2723[ebp]
	add	ecx, DWORD PTR [esi+60]
	push	DWORD PTR [edi]
	call	?push_line@kd_vlift_queue@@QAEXHPAUkd_vlift_line@@AAPAU2@@Z ; kd_vlift_queue::push_line

; 910  :                                             free_lines);
; 911  :                       y_next_in[vsub_parity] += 2;

	add	DWORD PTR [edi], 2

; 912  :                     }
; 913  :                   continue;

	jmp	$LN17@pull
$LN61@pull:

; 914  :                 }
; 915  : 
; 916  :               step = vert_steps + s;

	mov	ecx, DWORD PTR [esi+44]
	add	ecx, edx
	lea	edx, DWORD PTR [eax*4]

; 917  :               src_idx = (step_next_row_pos[s] ^ 1) + 2*step->support_min;

	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR tv2717[ebp], edx
	mov	DWORD PTR _step$1$[ebp], ecx
	movsx	ecx, WORD PTR [ecx+4]
	mov	edx, DWORD PTR [edx+eax]
	mov	eax, edx
	xor	eax, 1
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR _src_idx$1$[ebp], eax

; 918  :               vline_in = vline_out = NULL;
; 919  :               if (step_next_row_pos[s] > y_max_in[vsub_parity])

	cmp	edx, DWORD PTR [esi+ebx*4+96]
	jg	$LN17@pull

; 920  :                 continue; // Lifting step is finished
; 921  : 
; 922  :               vline_in = NULL;
; 923  :               if (s < (num_vert_steps-1))

	lea	eax, DWORD PTR [edi-1]
	mov	edi, DWORD PTR _s$1$[ebp]
	cmp	edi, eax
	jge	SHORT $LN65@pull

; 924  :                 {
; 925  :                   if (!queues[s+1].test_update(step_next_row_pos[s],false))

	mov	eax, DWORD PTR [esi+60]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 179  :         update_pos = idx;

	mov	ecx, DWORD PTR tv2682[ebp]
	mov	DWORD PTR [eax+ecx+68], edx

; 180  :         return ((idx >= head_idx) && (idx <= tail_idx) &&

	cmp	edx, DWORD PTR [eax+ecx+56]
	jl	$LN103@pull
	cmp	edx, DWORD PTR [eax+ecx+60]
	jg	$LN103@pull
$LN65@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 931  :               if ((step->support_length > 0) &&

	mov	eax, DWORD PTR _step$1$[ebp]
	mov	cl, BYTE PTR [eax+1]
	test	cl, cl
	je	SHORT $LN66@pull
	lea	eax, DWORD PTR [esi+40]
	push	eax
	push	DWORD PTR [esi+32]
	movzx	eax, cl
	mov	ecx, DWORD PTR [esi+60]
	add	ecx, DWORD PTR tv2682[ebp]
	push	eax
	push	DWORD PTR _src_idx$1$[ebp]
	call	?access_source@kd_vlift_queue@@QAE_NHHQAPAUkd_vlift_line@@AAPAU2@@Z ; kd_vlift_queue::access_source
	test	al, al
	je	$LN209@pull
$LN66@pull:

; 936  :                   break;
; 937  :                 }
; 938  :               if (s == (num_vert_steps-1))

	mov	eax, DWORD PTR [esi+24]
	dec	eax
	cmp	edi, eax
	jne	SHORT $LN67@pull

; 939  :                 { // Read update row from subbands
; 940  :                   vline_in = free_lines;  assert(vline_in != NULL);
; 941  :                   assert(step_next_row_pos[s] == y_next_in[vsub_parity]);
; 942  :                   horizontal_synthesis(vline_in,vsub_parity,env);

	push	DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [esi+40]
	mov	ecx, esi
	push	ebx
	push	eax
	mov	DWORD PTR _vline_in$2$[ebp], eax
	call	?horizontal_synthesis@kd_synthesis@@IAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z ; kd_synthesis::horizontal_synthesis

; 943  :                   y_next_in[vsub_parity] += 2;

	add	DWORD PTR [esi+ebx*4+88], 2

; 944  :                 }
; 945  :               else

	lea	ebx, DWORD PTR [esi+40]
	jmp	SHORT $LN68@pull
$LN67@pull:

; 946  :                 vline_in =

	mov	eax, DWORD PTR [esi+64]
	lea	ebx, DWORD PTR [esi+40]
	mov	ecx, DWORD PTR tv2682[ebp]
	push	ebx
	add	ecx, 40					; 00000028H
	push	DWORD PTR [eax+edi*4]
	add	ecx, DWORD PTR [esi+60]
	call	?access_update@kd_vlift_queue@@QAEPAUkd_vlift_line@@HAAPAU2@@Z ; kd_vlift_queue::access_update
	mov	DWORD PTR _vline_in$2$[ebp], eax
$LN68@pull:

; 947  :                   queues[s+1].access_update(step_next_row_pos[s],free_lines);
; 948  :               vline_out = free_lines;  assert(vline_out != NULL);

	mov	edi, DWORD PTR [ebx]

; 949  :               free_lines = vline_out->next;  vline_out->next = NULL;
; 950  :               queues[s-1].push_line(step_next_row_pos[s],vline_out,

	push	ebx
	push	edi
	mov	ecx, DWORD PTR [edi+24]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR tv2717[ebp]
	mov	DWORD PTR [edi+24], 0
	mov	eax, DWORD PTR [esi+64]
	push	DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR tv2682[ebp]
	add	ecx, -40				; ffffffd8H
	add	ecx, DWORD PTR [esi+60]
	call	?push_line@kd_vlift_queue@@QAEXHPAUkd_vlift_line@@AAPAU2@@Z ; kd_vlift_queue::push_line

; 951  :                                     free_lines);
; 952  :               if (step->support_length <= 0)

	mov	edx, DWORD PTR _step$1$[ebp]
	cmp	BYTE PTR [edx+1], 0
	ja	$LN69@pull

; 953  :                 {
; 954  :                   if (use_shorts)
; 955  :                     for (c=0; c < 2; c++)

	mov	eax, DWORD PTR _vline_in$2$[ebp]
	lea	ebx, DWORD PTR [edi+6]
	sub	edi, eax
	cmp	BYTE PTR [esi+162], 0
	lea	esi, DWORD PTR [eax+8]
	je	SHORT $LN71@pull
	mov	DWORD PTR tv2728[ebp], 2
	npad	6
$LL22@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [esi-2], 2

; 414  :       }
; 415  :     bool get_floats(float *buffer, int first_idx, int num_samples)
; 416  :       {
; 417  :       /* [SYNOPSIS]
; 418  :            Returns false if the object does not hold a 32-bit normalized
; 419  :            (floating point) sample representation.  Otherwise, returns true
; 420  :            and copies the floating point samples into the supplied `buffer'.
; 421  :            The first copied sample is `first_idx' positions from the start
; 422  :            of the line.  There may be little or no checking that the
; 423  :            sample range represented by `first_idx' and `num_samples' is
; 424  :            legal, so be careful.
; 425  :            [//]
; 426  :            For native C/C++ interfacing, it is more efficient to explicitly
; 427  :            access the internal buffer using `get_buf32'.
; 428  :       */
; 429  :         if (flags & (KD_LINE_BUF_ABSOLUTE | KD_LINE_BUF_ABSOLUTE))
; 430  :           return false;
; 431  :         for (int i=0; i < num_samples; i++)
; 432  :           buffer[i] = buf32[first_idx+i].fval;
; 433  :         return true;
; 434  :       }
; 435  :     bool set_floats(float *buffer, int first_idx, int num_samples)
; 436  :       {
; 437  :       /* [SYNOPSIS]
; 438  :            Returns false if the object does not hold a 32-bit normalized
; 439  :            (floating point) sample representation.  Otherwise, returns true
; 440  :            and copies the floating point samples from the supplied `buffer'.
; 441  :            The first sample in `buffer' is stored `first_idx' positions from
; 442  :            the start of the line.  There may be little or no checking that
; 443  :            the sample range represented by `first_idx' and `num_samples' is
; 444  :            legal, so be careful.
; 445  :            [//]
; 446  :            For native C/C++ interfacing, it is more efficient to explicitly
; 447  :            access the internal buffer using `get_buf32'.
; 448  :       */
; 449  :         if (flags & (KD_LINE_BUF_ABSOLUTE | KD_LINE_BUF_ABSOLUTE))
; 450  :           return false;
; 451  :         for (int i=0; i < num_samples; i++)
; 452  :           buf32[i+first_idx].fval = buffer[i];
; 453  :         return true;
; 454  :       }
; 455  :     bool get_ints(kdu_int32 *buffer, int first_idx, int num_samples)
; 456  :       {
; 457  :       /* [SYNOPSIS]
; 458  :            Returns false if the object does not hold a 32-bit absolute
; 459  :            (integer) sample representation.  Otherwise, returns true
; 460  :            and copies the integer samples into the supplied `buffer'.
; 461  :            The first copied sample is `first_idx' positions from the start
; 462  :            of the line.  There may be little or no checking that the
; 463  :            sample range represented by `first_idx' and `num_samples' is
; 464  :            legal, so be careful.
; 465  :            [//]
; 466  :            For native C/C++ interfacing, it is more efficient to explicitly
; 467  :            access the internal buffer using `get_buf32'.
; 468  :       */
; 469  :         if ((flags & KD_LINE_BUF_SHORTS) || !(flags & KD_LINE_BUF_ABSOLUTE))
; 470  :           return false;
; 471  :         for (int i=0; i < num_samples; i++)
; 472  :           buffer[i] = buf32[first_idx+i].ival;
; 473  :         return true;
; 474  :       }
; 475  :     bool set_ints(kdu_int32 *buffer, int first_idx, int num_samples)
; 476  :       {
; 477  :       /* [SYNOPSIS]
; 478  :            Returns false if the object does not hold a 32-bit absolute
; 479  :            (integer) sample representation.  Otherwise, returns true
; 480  :            and copies the integer samples from the supplied `buffer'.
; 481  :            The first sample in `buffer' is stored `first_idx' positions from
; 482  :            the start of the line.  There may be little or no checking that
; 483  :            the sample range represented by `first_idx' and `num_samples' is
; 484  :            legal, so be careful.
; 485  :            [//]
; 486  :            For native C/C++ interfacing, it is more efficient to explicitly
; 487  :            access the internal buffer using `get_buf32'.
; 488  :       */
; 489  :         if ((flags & KD_LINE_BUF_SHORTS) || !(flags & KD_LINE_BUF_ABSOLUTE))
; 490  :           return false;
; 491  :         for (int i=0; i < num_samples; i++)
; 492  :           buf32[i+first_idx].ival = buffer[i];
; 493  :         return true;
; 494  :       }
; 495  :     bool get_ints(kdu_int16 *buffer, int first_idx, int num_samples)
; 496  :       {
; 497  :       /* [SYNOPSIS]
; 498  :            Returns false if the object does not hold a 16-bit sample
; 499  :            representation (either fixed point or absolute integers).
; 500  :            Otherwise, returns true and copies the 16-bit samples into the
; 501  :            supplied `buffer'.  The first copied sample is `first_idx'
; 502  :            positions from the start of the line.  There may be little or no
; 503  :            checking that the sample range represented by `first_idx' and
; 504  :            `num_samples' is legal, so be careful.
; 505  :            [//]
; 506  :            For native C/C++ interfacing, it is more efficient to explicitly
; 507  :            access the internal buffer using `get_buf16'.
; 508  :       */
; 509  :         if (!(flags & KD_LINE_BUF_SHORTS))
; 510  :           return false;
; 511  :         for (int i=0; i < num_samples; i++)
; 512  :           buffer[i] = buf16[first_idx+i].ival;
; 513  :         return true;
; 514  :       }
; 515  :     bool set_ints(kdu_int16 *buffer, int first_idx, int num_samples)
; 516  :       {
; 517  :       /* [SYNOPSIS]
; 518  :            Returns false if the object does not hold a 16-bit sample
; 519  :            representation (either fixed point or absolute integers).
; 520  :            Otherwise, returns true and copies the integer samples from the
; 521  :            supplied `buffer'.  The first sample in `buffer' is stored
; 522  :            `first_idx' positions from the start of the line.  There may be
; 523  :            little or no checking that the sample range represented by
; 524  :            `first_idx' and `num_samples' is legal, so be careful.
; 525  :            [//]
; 526  :            For native C/C++ interfacing, it is more efficient to explicitly
; 527  :            access the internal buffer using `get_buf16'.
; 528  :       */
; 529  :         if (!(flags & KD_LINE_BUF_SHORTS))
; 530  :           return false;
; 531  :         for (int i=0; i < num_samples; i++)
; 532  :           buf16[i+first_idx].ival = buffer[i];
; 533  :         return true;
; 534  :       }
; 535  :     int get_width()
; 536  :       {
; 537  :       /* [SYNOPSIS]
; 538  :            Returns 0 if the object has not been created.  Otherwise, returns
; 539  :            the nominal width of the line.  Remember that the arrays returned
; 540  :            by `get_buf16' and `get_buf32' are typically larger than the actual
; 541  :            line width, as explained in the comments appearing with the
; 542  :            `pre_create' function.
; 543  :       */
; 544  :         return width;

	mov	eax, DWORD PTR [esi-8]

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	je	SHORT $LN111@pull
	mov	edx, DWORD PTR [esi]
	jmp	SHORT $LN112@pull
$LN111@pull:
	xor	edx, edx
$LN112@pull:
	test	BYTE PTR [ebx], 2
	je	SHORT $LN115@pull
	mov	ecx, DWORD PTR [edi+esi]
	jmp	SHORT $LN116@pull
$LN115@pull:
	xor	ecx, ecx
$LN116@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 956  :                       memcpy(vline_out->cosets[c].get_buf16(),

	add	eax, eax
	push	eax
	push	edx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	esi, 12					; 0000000cH
	add	ebx, 12					; 0000000cH
	sub	DWORD PTR tv2728[ebp], 1
	jne	SHORT $LL22@pull

; 957  :                              vline_in->cosets[c].get_buf16(),
; 958  :                              (size_t)(vline_in->cosets[c].get_width()<<1));
; 959  :                   else

	mov	esi, DWORD PTR _this$1$[ebp]
	jmp	$LN27@pull
$LN71@pull:

; 960  :                     for (c=0; c < 2; c++)

	mov	DWORD PTR tv2745[ebp], 2
$LL25@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [esi-2], 2

; 414  :       }
; 415  :     bool get_floats(float *buffer, int first_idx, int num_samples)
; 416  :       {
; 417  :       /* [SYNOPSIS]
; 418  :            Returns false if the object does not hold a 32-bit normalized
; 419  :            (floating point) sample representation.  Otherwise, returns true
; 420  :            and copies the floating point samples into the supplied `buffer'.
; 421  :            The first copied sample is `first_idx' positions from the start
; 422  :            of the line.  There may be little or no checking that the
; 423  :            sample range represented by `first_idx' and `num_samples' is
; 424  :            legal, so be careful.
; 425  :            [//]
; 426  :            For native C/C++ interfacing, it is more efficient to explicitly
; 427  :            access the internal buffer using `get_buf32'.
; 428  :       */
; 429  :         if (flags & (KD_LINE_BUF_ABSOLUTE | KD_LINE_BUF_ABSOLUTE))
; 430  :           return false;
; 431  :         for (int i=0; i < num_samples; i++)
; 432  :           buffer[i] = buf32[first_idx+i].fval;
; 433  :         return true;
; 434  :       }
; 435  :     bool set_floats(float *buffer, int first_idx, int num_samples)
; 436  :       {
; 437  :       /* [SYNOPSIS]
; 438  :            Returns false if the object does not hold a 32-bit normalized
; 439  :            (floating point) sample representation.  Otherwise, returns true
; 440  :            and copies the floating point samples from the supplied `buffer'.
; 441  :            The first sample in `buffer' is stored `first_idx' positions from
; 442  :            the start of the line.  There may be little or no checking that
; 443  :            the sample range represented by `first_idx' and `num_samples' is
; 444  :            legal, so be careful.
; 445  :            [//]
; 446  :            For native C/C++ interfacing, it is more efficient to explicitly
; 447  :            access the internal buffer using `get_buf32'.
; 448  :       */
; 449  :         if (flags & (KD_LINE_BUF_ABSOLUTE | KD_LINE_BUF_ABSOLUTE))
; 450  :           return false;
; 451  :         for (int i=0; i < num_samples; i++)
; 452  :           buf32[i+first_idx].fval = buffer[i];
; 453  :         return true;
; 454  :       }
; 455  :     bool get_ints(kdu_int32 *buffer, int first_idx, int num_samples)
; 456  :       {
; 457  :       /* [SYNOPSIS]
; 458  :            Returns false if the object does not hold a 32-bit absolute
; 459  :            (integer) sample representation.  Otherwise, returns true
; 460  :            and copies the integer samples into the supplied `buffer'.
; 461  :            The first copied sample is `first_idx' positions from the start
; 462  :            of the line.  There may be little or no checking that the
; 463  :            sample range represented by `first_idx' and `num_samples' is
; 464  :            legal, so be careful.
; 465  :            [//]
; 466  :            For native C/C++ interfacing, it is more efficient to explicitly
; 467  :            access the internal buffer using `get_buf32'.
; 468  :       */
; 469  :         if ((flags & KD_LINE_BUF_SHORTS) || !(flags & KD_LINE_BUF_ABSOLUTE))
; 470  :           return false;
; 471  :         for (int i=0; i < num_samples; i++)
; 472  :           buffer[i] = buf32[first_idx+i].ival;
; 473  :         return true;
; 474  :       }
; 475  :     bool set_ints(kdu_int32 *buffer, int first_idx, int num_samples)
; 476  :       {
; 477  :       /* [SYNOPSIS]
; 478  :            Returns false if the object does not hold a 32-bit absolute
; 479  :            (integer) sample representation.  Otherwise, returns true
; 480  :            and copies the integer samples from the supplied `buffer'.
; 481  :            The first sample in `buffer' is stored `first_idx' positions from
; 482  :            the start of the line.  There may be little or no checking that
; 483  :            the sample range represented by `first_idx' and `num_samples' is
; 484  :            legal, so be careful.
; 485  :            [//]
; 486  :            For native C/C++ interfacing, it is more efficient to explicitly
; 487  :            access the internal buffer using `get_buf32'.
; 488  :       */
; 489  :         if ((flags & KD_LINE_BUF_SHORTS) || !(flags & KD_LINE_BUF_ABSOLUTE))
; 490  :           return false;
; 491  :         for (int i=0; i < num_samples; i++)
; 492  :           buf32[i+first_idx].ival = buffer[i];
; 493  :         return true;
; 494  :       }
; 495  :     bool get_ints(kdu_int16 *buffer, int first_idx, int num_samples)
; 496  :       {
; 497  :       /* [SYNOPSIS]
; 498  :            Returns false if the object does not hold a 16-bit sample
; 499  :            representation (either fixed point or absolute integers).
; 500  :            Otherwise, returns true and copies the 16-bit samples into the
; 501  :            supplied `buffer'.  The first copied sample is `first_idx'
; 502  :            positions from the start of the line.  There may be little or no
; 503  :            checking that the sample range represented by `first_idx' and
; 504  :            `num_samples' is legal, so be careful.
; 505  :            [//]
; 506  :            For native C/C++ interfacing, it is more efficient to explicitly
; 507  :            access the internal buffer using `get_buf16'.
; 508  :       */
; 509  :         if (!(flags & KD_LINE_BUF_SHORTS))
; 510  :           return false;
; 511  :         for (int i=0; i < num_samples; i++)
; 512  :           buffer[i] = buf16[first_idx+i].ival;
; 513  :         return true;
; 514  :       }
; 515  :     bool set_ints(kdu_int16 *buffer, int first_idx, int num_samples)
; 516  :       {
; 517  :       /* [SYNOPSIS]
; 518  :            Returns false if the object does not hold a 16-bit sample
; 519  :            representation (either fixed point or absolute integers).
; 520  :            Otherwise, returns true and copies the integer samples from the
; 521  :            supplied `buffer'.  The first sample in `buffer' is stored
; 522  :            `first_idx' positions from the start of the line.  There may be
; 523  :            little or no checking that the sample range represented by
; 524  :            `first_idx' and `num_samples' is legal, so be careful.
; 525  :            [//]
; 526  :            For native C/C++ interfacing, it is more efficient to explicitly
; 527  :            access the internal buffer using `get_buf16'.
; 528  :       */
; 529  :         if (!(flags & KD_LINE_BUF_SHORTS))
; 530  :           return false;
; 531  :         for (int i=0; i < num_samples; i++)
; 532  :           buf16[i+first_idx].ival = buffer[i];
; 533  :         return true;
; 534  :       }
; 535  :     int get_width()
; 536  :       {
; 537  :       /* [SYNOPSIS]
; 538  :            Returns 0 if the object has not been created.  Otherwise, returns
; 539  :            the nominal width of the line.  Remember that the arrays returned
; 540  :            by `get_buf16' and `get_buf32' are typically larger than the actual
; 541  :            line width, as explained in the comments appearing with the
; 542  :            `pre_create' function.
; 543  :       */
; 544  :         return width;

	mov	eax, DWORD PTR [esi-8]

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	je	SHORT $LN121@pull
	xor	edx, edx
	jmp	SHORT $LN122@pull
$LN121@pull:
	mov	edx, DWORD PTR [esi]
$LN122@pull:
	test	BYTE PTR [ebx], 2
	je	SHORT $LN125@pull
	xor	ecx, ecx
	jmp	SHORT $LN126@pull
$LN125@pull:
	mov	ecx, DWORD PTR [esi+edi]
$LN126@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 961  :                       memcpy(vline_out->cosets[c].get_buf32(),

	shl	eax, 2
	push	eax
	push	edx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	esi, 12					; 0000000cH
	add	ebx, 12					; 0000000cH
	sub	DWORD PTR tv2745[ebp], 1
	jne	SHORT $LL25@pull

; 962  :                              vline_in->cosets[c].get_buf32(),
; 963  :                              (size_t)(vline_in->cosets[c].get_width()<<2));
; 964  :                 }
; 965  :               else

	mov	esi, DWORD PTR _this$1$[ebp]
	jmp	$LN27@pull
$LN69@pull:

; 966  :                 {
; 967  :                   int k;
; 968  :                   for (c=0; c < 2; c++)

	xor	eax, eax
	lea	ecx, DWORD PTR [esi+148]
	mov	DWORD PTR _c$1$[ebp], eax
	lea	ebx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR _vline_in$2$[ebp]
	sub	DWORD PTR _vline_in$2$[ebp], edi
	add	eax, 6
	mov	DWORD PTR tv2686[ebp], eax
	mov	eax, -8					; fffffff8H
	sub	eax, edi
	mov	DWORD PTR tv2687[ebp], ecx
	mov	edi, DWORD PTR tv2686[ebp]
	mov	DWORD PTR tv2683[ebp], eax
	mov	eax, DWORD PTR _c$1$[ebp]
	npad	3
$LL28@pull:

; 969  :                     {
; 970  :                       if (coset_width_out[c] == 0)

	cmp	DWORD PTR [ecx], 0
	je	$LN26@pull

; 971  :                         continue;
; 972  :                       if (use_shorts)
; 973  :                         {
; 974  :                           kdu_sample16 **bf=(kdu_sample16 **) vert_source_bufs;

	mov	edi, DWORD PTR [esi+36]

; 975  :                           for (k=0; k < (int) step->support_length; k++)

	xor	ecx, ecx
	cmp	BYTE PTR [esi+162], cl
	je	SHORT $LN74@pull
	cmp	BYTE PTR [edx+1], cl
	jbe	SHORT $LN30@pull
	npad	5
$LL31@pull:

; 976  :                             bf[k]=vert_source_vlines[k]->cosets[c].get_buf16();

	mov	eax, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [eax+ecx*4]
	add	eax, DWORD PTR tv2683[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [eax+ebx+6], 2
	je	SHORT $LN129@pull
	mov	eax, DWORD PTR [eax+ebx+8]
	jmp	SHORT $LN130@pull
$LN129@pull:
	xor	eax, eax
$LN130@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 976  :                             bf[k]=vert_source_vlines[k]->cosets[c].get_buf16();

	mov	DWORD PTR [edi+ecx*4], eax
	inc	ecx
	movzx	eax, BYTE PTR [edx+1]
	cmp	ecx, eax
	jl	SHORT $LL31@pull
$LN30@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ebx-2], 2
	je	SHORT $LN133@pull
	mov	edx, DWORD PTR [ebx]
	jmp	SHORT $LN134@pull
$LN133@pull:
	xor	edx, edx
$LN134@pull:
	mov	eax, DWORD PTR tv2686[ebp]
	test	BYTE PTR [eax], 2
	je	SHORT $LN137@pull
	mov	eax, DWORD PTR _vline_in$2$[ebp]
	mov	ecx, DWORD PTR [eax+ebx]
	jmp	SHORT $LN138@pull
$LN137@pull:
	xor	ecx, ecx
$LN138@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 977  :                           perform_synthesis_lifting_step(step,bf,

	mov	eax, DWORD PTR _c$1$[ebp]
	movzx	eax, BYTE PTR [eax+esi+160]
	push	eax
	mov	eax, DWORD PTR tv2687[ebp]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR _step$1$[ebp]
	push	edx
	push	ecx
	push	edi
	push	eax
	call	?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z ; perform_synthesis_lifting_step

; 978  :                                       vline_in->cosets[c].get_buf16(),
; 979  :                                       vline_out->cosets[c].get_buf16(),
; 980  :                                       coset_width_out[c],coset_off_out[c]);
; 981  :                         }
; 982  :                       else

	jmp	SHORT $LN275@pull
$LN74@pull:

; 983  :                         {
; 984  :                           kdu_sample32 **bf=(kdu_sample32 **) vert_source_bufs;
; 985  :                           for (k=0; k < (int) step->support_length; k++)

	cmp	BYTE PTR [edx+1], cl
	jbe	SHORT $LN33@pull
$LL34@pull:

; 986  :                             bf[k]=vert_source_vlines[k]->cosets[c].get_buf32();

	mov	eax, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [eax+ecx*4]
	add	eax, DWORD PTR tv2683[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [eax+ebx+6], 2
	je	SHORT $LN141@pull
	xor	eax, eax
	jmp	SHORT $LN142@pull
$LN141@pull:
	mov	eax, DWORD PTR [eax+ebx+8]
$LN142@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 986  :                             bf[k]=vert_source_vlines[k]->cosets[c].get_buf32();

	mov	DWORD PTR [edi+ecx*4], eax
	inc	ecx
	movzx	eax, BYTE PTR [edx+1]
	cmp	ecx, eax
	jl	SHORT $LL34@pull
$LN33@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ebx-2], 2
	je	SHORT $LN145@pull
	xor	edx, edx
	jmp	SHORT $LN146@pull
$LN145@pull:
	mov	edx, DWORD PTR [ebx]
$LN146@pull:
	mov	eax, DWORD PTR tv2686[ebp]
	test	BYTE PTR [eax], 2
	je	SHORT $LN149@pull
	xor	ecx, ecx
	jmp	SHORT $LN150@pull
$LN149@pull:
	mov	eax, DWORD PTR _vline_in$2$[ebp]
	mov	ecx, DWORD PTR [eax+ebx]
$LN150@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 987  :                           perform_synthesis_lifting_step(step,bf,

	mov	eax, DWORD PTR _c$1$[ebp]
	movzx	eax, BYTE PTR [eax+esi+160]
	push	eax
	mov	eax, DWORD PTR tv2687[ebp]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR _step$1$[ebp]
	push	edx
	push	ecx
	push	edi
	push	eax
	call	?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z ; perform_synthesis_lifting_step
$LN275@pull:
	mov	edi, DWORD PTR tv2686[ebp]
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR _c$1$[ebp]
	mov	ecx, DWORD PTR tv2687[ebp]
	mov	edx, DWORD PTR _step$1$[ebp]
$LN26@pull:

; 966  :                 {
; 967  :                   int k;
; 968  :                   for (c=0; c < 2; c++)

	inc	eax
	add	ecx, 4
	add	edi, 12					; 0000000cH
	mov	DWORD PTR _c$1$[ebp], eax
	add	ebx, 12					; 0000000cH
	mov	DWORD PTR tv2687[ebp], ecx
	mov	DWORD PTR tv2686[ebp], edi
	cmp	eax, 2
	jl	$LL28@pull
$LN27@pull:

; 897  :       do { // Loop until row `y_next_out' becomes available
; 898  :           for (s=s_max; s >= 0; s--)

	mov	eax, DWORD PTR [esi+64]

; 988  :                                       vline_in->cosets[c].get_buf32(),
; 989  :                                       vline_out->cosets[c].get_buf32(),
; 990  :                                       coset_width_out[c],coset_off_out[c]);
; 991  :                         }
; 992  :                     }
; 993  :                 }
; 994  :               step_next_row_pos[s] += 2;

	mov	ecx, DWORD PTR tv2717[ebp]
	add	DWORD PTR [eax+ecx], 2
$LN17@pull:

; 897  :       do { // Loop until row `y_next_out' becomes available
; 898  :           for (s=s_max; s >= 0; s--)

	mov	eax, DWORD PTR _s$1$[ebp]
	sub	DWORD PTR tv2681[ebp], 20		; 00000014H
	dec	eax
	sub	DWORD PTR tv2682[ebp], 40		; 00000028H
	mov	DWORD PTR _s$1$[ebp], eax
	test	eax, eax
	js	SHORT $LN269@pull
	mov	edx, DWORD PTR tv2681[ebp]
	jmp	$LL19@pull
$LN103@pull:

; 926  :                     { // Need to progress up-stream synthesis step
; 927  :                       s_max = s+2;

	add	edi, 2

; 928  :                       break;

	jmp	SHORT $LN18@pull
$LN209@pull:

; 932  :                   !queues[s].access_source(src_idx,step->support_length,
; 933  :                                            vert_source_vlines,free_lines))
; 934  :                 { // Can't access all source lines required by step
; 935  :                   s_max = s+1;

	inc	edi
$LN18@pull:

; 995  :             }
; 996  : 
; 997  :           vline_out = NULL;
; 998  :           if (s < 0)

	mov	eax, DWORD PTR _s$1$[ebp]
	test	eax, eax
	jns	$LL16@pull
$LN269@pull:

; 999  :             { // Finished a round of vertical synthesis.  See if we have
; 1000 :               // the required row yet
; 1001 :               s_max = 1 - (y_next_out & 1);

	mov	ecx, DWORD PTR [esi+72]
	mov	edi, 1
	mov	eax, ecx
	and	eax, 1
	sub	edi, eax

; 1002 :               vline_out = queues[s_max-1].access_update(y_next_out,free_lines);

	lea	eax, DWORD PTR [esi+40]
	push	eax
	mov	eax, DWORD PTR [esi+60]
	push	ecx
	lea	ecx, DWORD PTR [edi-1]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	call	?access_update@kd_vlift_queue@@QAEPAUkd_vlift_line@@HAAPAU2@@Z ; kd_vlift_queue::access_update
	mov	ecx, eax
	mov	DWORD PTR _this$1$[ebp], ecx

; 1003 :             }
; 1004 :         } while (vline_out == NULL);

	test	ecx, ecx
	je	$LL16@pull
	jmp	$LN15@pull
$LN57@pull:

; 870  :     { // No vertical synthesis
; 871  :       vline_out = free_lines;

	mov	edi, DWORD PTR [esi+40]

; 872  :       horizontal_synthesis(vline_out,vsub_parity,env);

	push	ecx
	push	ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _this$1$[ebp], edi
	call	?horizontal_synthesis@kd_synthesis@@IAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z ; kd_synthesis::horizontal_synthesis

; 873  :       if (unit_height && reversible && vsub_parity)

	cmp	BYTE PTR [esi+163], 0
	je	$LN272@pull
	cmp	BYTE PTR [esi+20], 0
	je	$LN272@pull
	test	ebx, ebx
	je	$LN272@pull

; 874  :         { // Reversible transform of a single odd-indexed sample -- halve vals
; 875  :           if (!use_shorts)
; 876  :             { // Working with 32-bit data
; 877  :               kdu_sample32 *dp;
; 878  :               for (c=0; c < 2; c++)

	xor	edx, edx
	lea	ebx, DWORD PTR [esi+148]
	add	edi, 8
	cmp	BYTE PTR [esi+162], dl
	jne	SHORT $LL10@pull
	npad	1
$LL4@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edi-2], 2
	je	SHORT $LN95@pull
	xor	ecx, ecx
	jmp	SHORT $LN96@pull
$LN95@pull:
	mov	ecx, DWORD PTR [edi]
$LN96@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 879  :                 for (dp=vline_out->cosets[c].get_buf32()+coset_off_out[c],

	movzx	eax, BYTE PTR [esi+edx+160]
	lea	eax, DWORD PTR [ecx+eax*4]

; 880  :                      k=coset_width_out[c]; k--; dp++)

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN216@pull
	npad	3
$LL7@pull:

; 881  :                   dp->ival >>= 1;

	sar	DWORD PTR [eax], 1
	lea	eax, DWORD PTR [eax+4]
	sub	ecx, 1
	jne	SHORT $LL7@pull
$LN216@pull:

; 874  :         { // Reversible transform of a single odd-indexed sample -- halve vals
; 875  :           if (!use_shorts)
; 876  :             { // Working with 32-bit data
; 877  :               kdu_sample32 *dp;
; 878  :               for (c=0; c < 2; c++)

	inc	edx
	add	ebx, 4
	add	edi, 12					; 0000000cH
	cmp	edx, 2
	jl	SHORT $LL4@pull

; 882  :             }
; 883  :           else

	mov	ecx, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LN15@pull
	npad	5
$LL10@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [edi-2], 2
	je	SHORT $LN99@pull
	mov	ecx, DWORD PTR [edi]
	jmp	SHORT $LN100@pull
$LN99@pull:
	xor	ecx, ecx
$LN100@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 887  :                 for (dp=vline_out->cosets[c].get_buf16()+coset_off_out[c],

	movzx	eax, BYTE PTR [esi+edx+160]
	lea	eax, DWORD PTR [ecx+eax*2]

; 888  :                      k=coset_width_out[c]; k--; dp++)

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN219@pull
	npad	3
$LL13@pull:

; 889  :                   dp->ival >>= 1;

	sar	WORD PTR [eax], 1
	lea	eax, DWORD PTR [eax+2]
	sub	ecx, 1
	jne	SHORT $LL13@pull
$LN219@pull:

; 884  :             { // Working with 16-bit data
; 885  :               kdu_sample16 *dp;
; 886  :               for (c=0; c < 2; c++)

	inc	edx
	add	ebx, 4
	add	edi, 12					; 0000000cH
	cmp	edx, 2
	jl	SHORT $LL10@pull
	mov	ecx, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LN15@pull
$LN272@pull:
	mov	ecx, edi
$LN15@pull:

; 1005 :     }
; 1006 : 
; 1007 :   y_next_out++;
; 1008 : 
; 1009 :   /* Finally, copy newly generated samples into `line', interleaving the
; 1010 :      even and odd sub-sequences, as required, and supplying any required
; 1011 :      upshift. */
; 1012 :   c = x_min_pull & 1; // Index of first coset to be interleaved.

	mov	edx, DWORD PTR [esi+156]
	mov	eax, edx
	inc	DWORD PTR [esi+72]
	and	eax, 1

; 1013 :   k = (x_max_out+2-x_min_pull)>>1; // May write one extra sample.

	mov	esi, DWORD PTR [esi+144]

; 1014 :   int src_off = (x_min_pull-x_min_buf)>>1;

	mov	ebx, DWORD PTR _this$1$[ebp]
	sub	esi, edx
	add	esi, 2
	mov	DWORD PTR _c$4$[ebp], eax
	sar	esi, 1
	sub	edx, DWORD PTR [ebx+104]
	sar	edx, 1

; 1015 :   if (!hor_xform_exists)

	cmp	BYTE PTR [ebx+23], 0
	jne	$LN77@pull

; 1016 :     { // Just transfer contents from coset[0]
; 1017 :       assert(src_off == 0);
; 1018 :       if (!use_shorts)

	cmp	BYTE PTR [ebx+162], 0
	jne	SHORT $LN79@pull
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	ecx, DWORD PTR _line$[ebp]
	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN153@pull
	xor	ecx, ecx
	jmp	SHORT $LN154@pull
$LN153@pull:
	mov	ecx, DWORD PTR [ecx+8]
$LN154@pull:
	mov	edi, DWORD PTR _this$1$[ebp]
	test	BYTE PTR [edi+6], 2
	je	SHORT $LN157@pull
	xor	edx, edx
	jmp	SHORT $LN158@pull
$LN157@pull:
	mov	edx, DWORD PTR [edi+8]
$LN158@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1023 :           for (; k--; sp+=2, dp+=2)

	test	esi, esi
	je	$LN274@pull
	sub	edx, ecx
$LL37@pull:

; 1024 :             { dp[0] = sp[0];  dp[1] = sp[1]; }

	mov	eax, DWORD PTR [edx+ecx]
	lea	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx-8], eax
	mov	eax, DWORD PTR [edx+ecx-4]
	mov	DWORD PTR [ecx-4], eax
	sub	esi, 1
	jne	SHORT $LL37@pull
	pop	edi
	pop	ebx
	pop	esi

; 1080 :                   }
; 1081 :             }
; 1082 :         }
; 1083 :     }
; 1084 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN79@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	mov	edx, DWORD PTR _line$[ebp]
	test	BYTE PTR [edx+6], 2
	je	SHORT $LN161@pull
	mov	edx, DWORD PTR [edx+8]
	jmp	SHORT $LN162@pull
$LN161@pull:
	xor	edx, edx
$LN162@pull:
	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN165@pull
	mov	edi, DWORD PTR [ecx+8]
	jmp	SHORT $LN166@pull
$LN165@pull:
	xor	edi, edi
$LN166@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1030 :           if (normalizing_upshift == 0)

	cmp	DWORD PTR [ebx+56], 0
	jne	SHORT $LN81@pull

; 1031 :             for (; k--; sp+=2, dp+=2)

	test	esi, esi
	je	$LN274@pull
	sub	edi, edx
	npad	4
$LL40@pull:

; 1032 :               { dp[0] = sp[0]; dp[1] = sp[1]; }

	movzx	eax, WORD PTR [edi+edx]
	lea	edx, DWORD PTR [edx+4]
	mov	WORD PTR [edx-4], ax
	movzx	eax, WORD PTR [edi+edx-2]
	mov	WORD PTR [edx-2], ax
	sub	esi, 1
	jne	SHORT $LL40@pull
	pop	edi
	pop	ebx
	pop	esi

; 1080 :                   }
; 1081 :             }
; 1082 :         }
; 1083 :     }
; 1084 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN81@pull:

; 1033 :           else
; 1034 :             {
; 1035 :               for (; k--; sp+=2, dp+=2)

	test	esi, esi
	je	$LN274@pull
	npad	6
$LL43@pull:

; 1036 :                 {
; 1037 :                   dp[0].ival = (sp[0].ival << normalizing_upshift);

	movzx	eax, WORD PTR [edi]
	lea	edi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ebx+56]
	lea	edx, DWORD PTR [edx+4]
	shl	ax, cl
	mov	WORD PTR [edx-4], ax

; 1038 :                   dp[1].ival = (sp[1].ival << normalizing_upshift);

	movzx	eax, WORD PTR [edi-2]
	mov	ecx, DWORD PTR [ebx+56]
	shl	ax, cl
	mov	WORD PTR [edx-2], ax
	sub	esi, 1
	jne	SHORT $LL43@pull
	pop	edi
	pop	ebx
	pop	esi

; 1080 :                   }
; 1081 :             }
; 1082 :         }
; 1083 :     }
; 1084 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN77@pull:

; 1039 :                 }
; 1040 :             }
; 1041 :         }
; 1042 :     }
; 1043 :   else
; 1044 :     { // Interleave even and odd cosets
; 1045 :       if (!use_shorts)

	cmp	BYTE PTR [ebx+162], 0
	jne	$LN83@pull
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	edi, DWORD PTR _line$[ebp]
	test	BYTE PTR [edi+6], 2
	je	SHORT $LN169@pull
	xor	edi, edi
	jmp	SHORT $LN170@pull
$LN169@pull:
	mov	edi, DWORD PTR [edi+8]
$LN170@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1048 :           kdu_sample32 *sp1 = vline_out->cosets[c].get_buf32() + src_off;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [eax+ecx+6], 2
	je	SHORT $LN173@pull
	xor	ebx, ebx
	jmp	SHORT $LN174@pull
$LN173@pull:
	mov	ebx, DWORD PTR [eax+ecx+8]
$LN174@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1048 :           kdu_sample32 *sp1 = vline_out->cosets[c].get_buf32() + src_off;

	shl	edx, 2

; 1049 :           kdu_sample32 *sp2 = vline_out->cosets[1-c].get_buf32() + src_off;

	sub	ecx, eax
	add	ebx, edx
	mov	DWORD PTR tv2699[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ecx+18], 2
	je	SHORT $LN177@pull
	xor	eax, eax
	jmp	SHORT $LN277@pull
$LN177@pull:
	mov	eax, DWORD PTR [ecx+20]
$LN277@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1052 :           if (!simd_interleave(&(sp1->ival),&(sp2->ival),&(dp->ival),k))

	push	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	DWORD PTR tv2731[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1049 :           kdu_sample32 *sp2 = vline_out->cosets[1-c].get_buf32() + src_off;

	add	eax, edx

; 1052 :           if (!simd_interleave(&(sp1->ival),&(sp2->ival),&(dp->ival),k))

	push	edi
	push	eax
	push	ebx
	call	?simd_interleave@@YA_NPAH00H@Z		; simd_interleave
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN274@pull

; 1053 : #endif // KDU_SIMD_OPTIMIZATIONS          if (normalizing_upshift == 0)
; 1054 :             for (; k--; sp1++, sp2++, dp+=2)

	test	esi, esi
	je	$LN274@pull
	mov	ecx, DWORD PTR tv2731[ebp]
	add	ecx, DWORD PTR tv2699[ebp]
	sub	ecx, ebx
$LL46@pull:

; 1055 :               { dp[0] = *sp1; dp[1] = *sp2; }

	mov	eax, DWORD PTR [ebx]
	lea	ebx, DWORD PTR [ebx+4]
	mov	DWORD PTR [edi], eax
	lea	edi, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [ecx+ebx-4]
	mov	DWORD PTR [edi-4], eax
	sub	esi, 1
	jne	SHORT $LL46@pull
	pop	edi
	pop	ebx
	pop	esi

; 1080 :                   }
; 1081 :             }
; 1082 :         }
; 1083 :     }
; 1084 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN83@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	mov	eax, DWORD PTR _line$[ebp]
	test	BYTE PTR [eax+6], 2
	je	SHORT $LN181@pull
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN278@pull
$LN181@pull:
	xor	eax, eax
$LN278@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1060 :           kdu_sample16 *sp1 = vline_out->cosets[c].get_buf16() + src_off;

	mov	edi, DWORD PTR _c$4$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	mov	DWORD PTR _dp$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1060 :           kdu_sample16 *sp1 = vline_out->cosets[c].get_buf16() + src_off;

	lea	edi, DWORD PTR [edi+edi*2]
	shl	edi, 2
	mov	DWORD PTR tv2708[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [edi+ecx+6], 2
	je	SHORT $LN185@pull
	mov	edi, DWORD PTR [edi+ecx+8]
	jmp	SHORT $LN186@pull
$LN185@pull:
	xor	edi, edi
$LN186@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1061 :           kdu_sample16 *sp2 = vline_out->cosets[1-c].get_buf16() + src_off;

	sub	ecx, DWORD PTR tv2708[ebp]
	lea	edi, DWORD PTR [edi+edx*2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ecx+18], 2
	je	SHORT $LN189@pull
	mov	ecx, DWORD PTR [ecx+20]
	jmp	SHORT $LN190@pull
$LN189@pull:
	xor	ecx, ecx
$LN190@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 1061 :           kdu_sample16 *sp2 = vline_out->cosets[1-c].get_buf16() + src_off;

	lea	ecx, DWORD PTR [ecx+edx*2]

; 1062 :           if (normalizing_upshift == 0)

	mov	edx, DWORD PTR [ebx+56]
	mov	DWORD PTR _sp2$1$[ebp], ecx
	test	edx, edx
	jne	SHORT $LN86@pull

; 1063 :             {
; 1064 : #ifdef KDU_SIMD_OPTIMIZATIONS
; 1065 :               if (!simd_interleave(&(sp1->ival),&(sp2->ival),&(dp->ival),k))

	mov	ebx, DWORD PTR _dp$1$[ebp]
	push	esi
	push	ebx
	push	ecx
	push	edi
	call	?simd_interleave@@YA_NPAF00H@Z		; simd_interleave
	add	esp, 16					; 00000010H
	test	al, al
	jne	SHORT $LN274@pull

; 1066 : #endif // KDU_SIMD_OPTIMIZATIONS
; 1067 :                 for (; k--; sp1++, sp2++, dp+=2)

	test	esi, esi
	je	SHORT $LN274@pull
	mov	ecx, DWORD PTR _sp2$1$[ebp]
	sub	ecx, edi
	npad	6
$LL49@pull:

; 1068 :                   { dp[0] = *sp1; dp[1] = *sp2; }

	movzx	eax, WORD PTR [edi]
	lea	edi, DWORD PTR [edi+2]
	mov	WORD PTR [ebx], ax
	lea	ebx, DWORD PTR [ebx+4]
	movzx	eax, WORD PTR [ecx+edi-2]
	mov	WORD PTR [ebx-2], ax
	sub	esi, 1
	jne	SHORT $LL49@pull
	pop	edi
	pop	ebx
	pop	esi

; 1080 :                   }
; 1081 :             }
; 1082 :         }
; 1083 :     }
; 1084 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN86@pull:

; 1069 :             }
; 1070 :           else
; 1071 :             {
; 1072 : #ifdef KDU_SIMD_OPTIMIZATIONS
; 1073 :               if (!simd_upshifted_interleave(&(sp1->ival),&(sp2->ival),

	push	edx
	push	esi
	push	eax
	push	ecx
	push	edi
	call	?simd_upshifted_interleave@@YA_NPAF00HH@Z ; simd_upshifted_interleave
	add	esp, 20					; 00000014H
	test	al, al
	jne	SHORT $LN274@pull

; 1074 :                                            &(dp->ival),k,normalizing_upshift))
; 1075 : #endif // KDU_SIMD_OPTIMIZATIONS
; 1076 :                 for (; k--; sp1++, sp2++, dp+=2)

	test	esi, esi
	je	SHORT $LN274@pull
	sub	DWORD PTR _sp2$1$[ebp], edi
	mov	edx, DWORD PTR _dp$1$[ebp]
	npad	2
$LL52@pull:

; 1077 :                   {
; 1078 :                     dp[0].ival = (*sp1).ival<<normalizing_upshift;

	movzx	eax, WORD PTR [edi]
	lea	edi, DWORD PTR [edi+2]
	mov	ecx, DWORD PTR [ebx+56]
	lea	edx, DWORD PTR [edx+4]
	shl	ax, cl
	mov	WORD PTR [edx-4], ax

; 1079 :                     dp[1].ival = (*sp2).ival<<normalizing_upshift;

	mov	eax, DWORD PTR _sp2$1$[ebp]
	mov	ecx, DWORD PTR [ebx+56]
	movzx	eax, WORD PTR [eax+edi-2]
	shl	ax, cl
	mov	WORD PTR [edx-2], ax
	sub	esi, 1
	jne	SHORT $LL52@pull
$LN274@pull:
	pop	edi
	pop	ebx
$LN232@pull:
	pop	esi

; 1080 :                   }
; 1081 :             }
; 1082 :         }
; 1083 :     }
; 1084 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?pull@kd_synthesis@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z ENDP ; kd_synthesis::pull
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
;	COMDAT ?start@kd_synthesis@@MAEXPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
_env$ = 8						; size = 4
?start@kd_synthesis@@MAEXPAVkdu_thread_env@@@Z PROC	; kd_synthesis::start, COMDAT
; _this$ = ecx

; 832  : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 833  :   if (!initialized)

	mov	ebx, DWORD PTR _env$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
	cmp	BYTE PTR [edi+21], 0
	jne	SHORT $LN27@start

; 834  :     { // Finish creating all the buffers.
; 835  :       kd_vlift_line *scan;
; 836  :       if (env != NULL)

	test	ebx, ebx
	je	SHORT $LN15@start
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	esi, DWORD PTR [ebx+28]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN42@start
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN18@start
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN18@start:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [esi+28], ebx
$LN15@start:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 838  :       for (scan=free_lines; scan != NULL; scan=scan->next)

	mov	esi, DWORD PTR [edi+40]
	test	esi, esi
	je	SHORT $LN3@start
	npad	6
$LL4@start:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 82   :       { cosets[0].create(); cosets[1].create(); }

	mov	ecx, esi
	call	?create@kdu_line_buf@@QAEXXZ		; kdu_line_buf::create
	lea	ecx, DWORD PTR [esi+12]
	call	?create@kdu_line_buf@@QAEXXZ		; kdu_line_buf::create
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 838  :       for (scan=free_lines; scan != NULL; scan=scan->next)

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL4@start
$LN3@start:

; 839  :         scan->create();
; 840  :       initialized = true;

	mov	BYTE PTR [edi+21], 1

; 841  :       if (env != NULL)

	test	ebx, ebx
	je	SHORT $LN27@start
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [ebx+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+28], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN27@start
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN27@start:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 846  :   for (n=0; n < 4; n++)

	lea	esi, DWORD PTR [edi+4]
	mov	edi, 4
	npad	2
$LL7@start:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 741  :     bool exists() { return (state==NULL)?false:true; }

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 847  :     if (subbands[n].exists())

	je	SHORT $LN5@start
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 739  :         state->start(env);

	mov	eax, DWORD PTR [ecx]
	push	ebx
	call	DWORD PTR [eax+4]
$LN5@start:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 846  :   for (n=0; n < 4; n++)

	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL7@start
	pop	edi
	pop	esi
	pop	ebx

; 849  : }

	pop	ebp
	ret	4
$LN42@start:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN44@start:
$LN41@start:
	int	3
?start@kd_synthesis@@MAEXPAVkdu_thread_env@@@Z ENDP	; kd_synthesis::start
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
;	COMDAT ??1kd_synthesis@@MAE@XZ
_TEXT	SEGMENT
??1kd_synthesis@@MAE@XZ PROC				; kd_synthesis::~kd_synthesis, COMDAT
; _this$ = ecx

; 673  : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	ebx, 4
	mov	DWORD PTR [edi], OFFSET ??_7kd_synthesis@@6B@
	lea	esi, DWORD PTR [edi+4]
$LL4@kd_synthes:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 741  :     bool exists() { return (state==NULL)?false:true; }

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 676  :     if (subbands[n].exists())

	je	SHORT $LN2@kd_synthes
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 704  :         if (state != NULL) delete state;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]

; 705  :         state = NULL;

	mov	DWORD PTR [esi], 0
$LN2@kd_synthes:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 675  :   for (n=0; n < 4; n++)

	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL4@kd_synthes

; 677  :       subbands[n].destroy();
; 678  :   if (coeff_handle != NULL)

	mov	eax, DWORD PTR [edi+168]
	test	eax, eax
	je	SHORT $LN6@kd_synthes

; 679  :     delete[] coeff_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@kd_synthes:

; 680  :   if (icoeff_handle != NULL)

	mov	eax, DWORD PTR [edi+172]
	test	eax, eax
	je	SHORT $LN7@kd_synthes

; 681  :     delete[] icoeff_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@kd_synthes:

; 682  :   if (source_buf_handle != NULL)

	mov	eax, DWORD PTR [edi+176]
	test	eax, eax
	je	SHORT $LN8@kd_synthes

; 683  :     delete[] source_buf_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@kd_synthes:

; 684  :   if (line_handle != NULL)

	mov	eax, DWORD PTR [edi+180]
	test	eax, eax
	je	SHORT $LN9@kd_synthes

; 685  :     delete[] line_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN9@kd_synthes:

; 686  :   if (vert_step_handle != NULL)

	mov	eax, DWORD PTR [edi+184]
	test	eax, eax
	je	SHORT $LN10@kd_synthes

; 687  :     delete[] vert_step_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN10@kd_synthes:

; 688  :   if (hor_step_handle != NULL)

	mov	eax, DWORD PTR [edi+188]
	test	eax, eax
	je	SHORT $LN11@kd_synthes

; 689  :     delete[] hor_step_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN11@kd_synthes:

; 690  :   if (queue_handle != NULL)

	mov	eax, DWORD PTR [edi+192]
	test	eax, eax
	je	SHORT $LN12@kd_synthes

; 691  :     delete[] queue_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN12@kd_synthes:

; 692  :   if (next_row_pos_handle != NULL)

	mov	eax, DWORD PTR [edi+196]
	test	eax, eax
	je	SHORT $LN30@kd_synthes

; 693  :     delete[] next_row_pos_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN30@kd_synthes:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 669  :     virtual ~kdu_pull_ifc_base() { return; }

	mov	DWORD PTR [edi], OFFSET ??_7kdu_pull_ifc_base@@6B@
	pop	edi
	pop	esi
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 694  : }

	ret	0
??1kd_synthesis@@MAE@XZ ENDP				; kd_synthesis::~kd_synthesis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
;	COMDAT ?init@kd_synthesis@@QAEXVkdu_node@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
_TEXT	SEGMENT
_dims$ = -160						; size = 16
_res$ = -144						; size = 4
_ll_dims$ = -140					; size = 16
_env$GSCopy$1$ = -124					; size = 4
_env_queue$GSCopy$1$ = -120				; size = 4
_hor_high_gain$ = -116					; size = 4
_hor_low_gain$ = -112					; size = 4
_vert_high_gain$ = -108					; size = 4
_vert_low_gain$ = -104					; size = 4
_allocator$GSCopy$1$ = -100				; size = 4
_use_shorts$GSCopy$ = -96				; size = 1
_this$GSCopy$1$ = -92					; size = 4
_both_cosets$1$ = -85					; size = 1
_this$1$ = -84						; size = 4
_kernel_id$1$ = -84					; size = 4
tv4192 = -84						; size = 4
tv4634 = -80						; size = 8
tv4608 = -80						; size = 8
_rfill$2$ = -76						; size = 4
_n$4$ = -76						; size = 4
_n$2$ = -76						; size = 4
tv4321 = -76						; size = 4
tv4307 = -76						; size = 4
tv4027 = -76						; size = 4
$T1 = -76						; size = 4
_ns$2 = -76						; size = 4
$T3 = -76						; size = 4
_high_max$4 = -76					; size = 4
_low_max$5 = -76					; size = 4
_fact$2$ = -72						; size = 4
_fact$2$ = -72						; size = 4
_y_max$1$ = -72						; size = 4
_buf_width$2$ = -72					; size = 4
tv4383 = -72						; size = 4
tv4364 = -72						; size = 4
$T6 = -72						; size = 4
_high_min$7 = -72					; size = 4
_high_max$8 = -72					; size = 4
_child_offset$1$ = -68					; size = 4
_hor_bibo_gains$1$ = -68				; size = 4
_local_y_min$1$ = -68					; size = 4
_max_vert_kernel_support$1$ = -68			; size = 4
_max$1$ = -68						; size = 4
_absolute$ = -68					; size = 1
_rfill$1$ = -64						; size = 4
_y_min$1$ = -64						; size = 4
_coeff_next$1$ = -64					; size = 4
_low_min$9 = -64					; size = 4
_buf_width$1$ = -60					; size = 4
_s$4$ = -60						; size = 4
tv4299 = -60						; size = 4
tv4293 = -60						; size = 4
_low_max$10 = -60					; size = 4
_high_min$11 = -60					; size = 4
_buf_pos_extent$2$ = -56				; size = 4
_max_extend$1$ = -56					; size = 4
_s$3$ = -56						; size = 4
_vert_step_info$1$ = -56				; size = 4
tv4292 = -56						; size = 4
$T12 = -56						; size = 4
_local_y_max$1$ = -52					; size = 4
_icoeff_next$1$ = -52					; size = 4
_hl_dims$1$ = -52					; size = 4
_max_step_length$1$ = -52				; size = 4
_low_min$13 = -52					; size = 4
_lfill$1$ = -48						; size = 4
_vert_bibo_gains$1$ = -48				; size = 4
_buf_neg_extent$2$ = -48				; size = 4
_coefficients$1$ = -48					; size = 4
_coefficients$1$ = -48					; size = 4
_s$2$ = -48						; size = 4
_s$1$ = -48						; size = 4
tv4319 = -48						; size = 4
$T14 = -48						; size = 4
_use_shorts$GSCopy$1$ = -41				; size = 1
_required_line_buffers$1$ = -40				; size = 4
_extend_left$1$ = -40					; size = 4
_s$5$ = -40						; size = 4
_total_coeffs$1$ = -40					; size = 4
tv4298 = -40						; size = 4
tv4280 = -40						; size = 4
_child$ = -36						; size = 16
_child_ranges$ = -20					; size = 16
_hl_dims$15 = -20					; size = 16
_lh_dims$16 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_node$ = 8						; size = 4
_allocator$ = 12					; size = 4
_use_shorts$ = 16					; size = 1
_normalization$ = 20					; size = 4
_pull_offset$ = 24					; size = 4
_env$ = 28						; size = 4
_env_queue$ = 32					; size = 4
?init@kd_synthesis@@QAEXVkdu_node@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z PROC ; kd_synthesis::init, COMDAT
; _this$ = ecx

; 146  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR _allocator$GSCopy$1$[ebp], eax
	mov	al, BYTE PTR _use_shorts$[ebp]
	mov	BYTE PTR _use_shorts$GSCopy$1$[ebp], al
	mov	BYTE PTR _use_shorts$GSCopy$[ebp], al
	mov	eax, DWORD PTR _env$[ebp]
	push	esi
	mov	DWORD PTR _env$GSCopy$1$[ebp], eax
	mov	esi, ecx
	mov	eax, DWORD PTR _env_queue$[ebp]

; 147  :   kdu_resolution res = node.access_resolution();

	lea	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _env_queue$GSCopy$1$[ebp], eax
	lea	eax, DWORD PTR _res$[ebp]
	push	edi
	push	eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], esi
	call	?access_resolution@kdu_node@@QAE?AVkdu_resolution@@XZ ; kdu_node::access_resolution

; 148  :   this->reversible = res.get_reversible();

	lea	ecx, DWORD PTR _res$[ebp]
	call	?get_reversible@kdu_resolution@@QAE_NXZ	; kdu_resolution::get_reversible
	mov	BYTE PTR [esi+20], al

; 149  :   this->use_shorts = use_shorts;
; 150  :   this->initialized = false;
; 151  :   this->free_lines = NULL;
; 152  :   this->queues = NULL;
; 153  :   this->vert_source_vlines = NULL;
; 154  :   this->vert_source_bufs = NULL;
; 155  :   this->vert_steps = this->hor_steps = NULL;
; 156  :   this->num_vert_steps = this->num_hor_steps = 0;
; 157  :   this->vert_symmetric_extension = this->hor_symmetric_extension = false;
; 158  :   int kernel_id = node.get_kernel_id();

	lea	ecx, DWORD PTR _node$[ebp]
	mov	al, BYTE PTR _use_shorts$GSCopy$1$[ebp]
	mov	BYTE PTR [esi+162], al
	mov	BYTE PTR [esi+21], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+24], 0
	mov	WORD PTR [esi+54], 0
	call	?get_kernel_id@kdu_node@@QAEHXZ		; kdu_node::get_kernel_id
	mov	DWORD PTR _kernel_id$1$[ebp], eax

; 159  :   coeff_handle = NULL;
; 160  :   icoeff_handle = NULL;
; 161  :   source_buf_handle = NULL;
; 162  :   line_handle = NULL;
; 163  :   vert_step_handle = hor_step_handle = NULL;
; 164  :   queue_handle = NULL;
; 165  : 
; 166  :   // Get output dimensions
; 167  :   kdu_dims dims;  node.get_dims(dims);

	lea	ecx, DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _dims$[ebp]
	mov	DWORD PTR [esi+168], 0
	xorps	xmm0, xmm0
	mov	DWORD PTR [esi+172], 0
	push	eax
	mov	DWORD PTR [esi+176], 0
	mov	DWORD PTR [esi+180], 0
	mov	DWORD PTR [esi+188], 0
	mov	DWORD PTR [esi+184], 0
	mov	DWORD PTR [esi+192], 0
	movups	XMMWORD PTR _dims$[ebp], xmm0
	call	?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z	; kdu_node::get_dims

; 169  :   min = dims.pos; max = min + dims.size;  max.x--; max.y--;

	mov	edi, DWORD PTR _dims$[ebp+4]
	mov	ecx, DWORD PTR _dims$[ebp+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	edx, DWORD PTR _dims$[ebp+8]
	mov	eax, DWORD PTR _dims$[ebp]
	dec	edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 169  :   min = dims.pos; max = min + dims.size;  max.x--; max.y--;

	lea	esi, DWORD PTR [edi-1]
	add	edx, eax
	add	esi, ecx
	mov	DWORD PTR _max$1$[ebp], esi

; 170  :   y_min_out = min.y;  y_max_out = max.y;

	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR [esi+68], eax

; 171  :   x_min_out = min.x;  x_max_out = max.x;

	lea	eax, DWORD PTR [edi-1]
	add	eax, ecx
	mov	DWORD PTR [esi+76], edx
	mov	DWORD PTR [esi+144], eax

; 172  :   x_min_pull = x_min_out - pull_offset;

	mov	eax, edi
	sub	eax, DWORD PTR _pull_offset$[ebp]
	mov	DWORD PTR [esi+140], edi
	mov	DWORD PTR [esi+156], eax

; 173  :   x_min_buf = x_min_pull; // May need to change this later

	mov	DWORD PTR [esi+104], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	test	ecx, ecx
	jle	SHORT $LN168@init
	cmp	DWORD PTR _dims$[ebp+8], 0
	jle	SHORT $LN168@init
	xor	cl, cl
	jmp	SHORT $LN169@init
$LN168@init:
	mov	cl, 1
$LN169@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 176  :   unit_height = (y_min_out == y_max_out);

	cmp	DWORD PTR _dims$[ebp], edx
	mov	BYTE PTR [esi+165], cl
	sete	al

; 177  :   unit_width = (x_min_out == x_max_out);

	cmp	edi, DWORD PTR _max$1$[ebp]
	mov	BYTE PTR [esi+163], al
	sete	al
	mov	BYTE PTR [esi+164], al

; 178  : 
; 179  :   if (empty)

	test	cl, cl
	jne	$LN58@init

; 180  :     return;
; 181  : 
; 182  :   // Get basic structure
; 183  :   kdu_node child[4] =
; 184  :     {node.access_child(LL_BAND), node.access_child(HL_BAND),

	push	0
	lea	eax, DWORD PTR _child$[ebp]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?access_child@kdu_node@@QAE?AV1@H@Z	; kdu_node::access_child
	push	1
	lea	eax, DWORD PTR _child$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?access_child@kdu_node@@QAE?AV1@H@Z	; kdu_node::access_child

; 185  :      node.access_child(LH_BAND), node.access_child(HH_BAND)};

	push	2
	lea	eax, DWORD PTR _child$[ebp+8]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?access_child@kdu_node@@QAE?AV1@H@Z	; kdu_node::access_child
	push	3
	lea	eax, DWORD PTR _child$[ebp+12]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?access_child@kdu_node@@QAE?AV1@H@Z	; kdu_node::access_child

; 186  : 
; 187  :   assert(child[LL_BAND].exists()); // We should not be a leaf node here
; 188  :   kdu_dims ll_dims;  child[LL_BAND].get_dims(ll_dims);

	lea	eax, DWORD PTR _ll_dims$[ebp]
	xorps	xmm0, xmm0
	push	eax
	lea	ecx, DWORD PTR _child$[ebp]
	movups	XMMWORD PTR _ll_dims$[ebp], xmm0
	call	?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z	; kdu_node::get_dims
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4988 :     bool exists() { return (state==NULL)?false:true; }

	cmp	DWORD PTR _child$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 193  :   const kdu_kernel_step_info *hor_step_info=NULL, *vert_step_info=NULL;

	mov	DWORD PTR _vert_step_info$1$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4988 :     bool exists() { return (state==NULL)?false:true; }

	setne	cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 196  :   int max_vert_kernel_support = 0;

	mov	DWORD PTR _max_vert_kernel_support$1$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4988 :     bool exists() { return (state==NULL)?false:true; }

	cmp	DWORD PTR _child$[ebp+4], 0
	mov	BYTE PTR [esi+22], cl
	setne	al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 197  :   int total_coeffs = 0;

	mov	DWORD PTR _total_coeffs$1$[ebp], 0
	mov	BYTE PTR [esi+23], al

; 198  :   float vert_low_gain=1.0F, vert_high_gain=1.0F;

	mov	DWORD PTR _vert_low_gain$[ebp], 1065353216 ; 3f800000H
	mov	DWORD PTR _vert_high_gain$[ebp], 1065353216 ; 3f800000H

; 199  :   float hor_low_gain=1.0F, hor_high_gain=1.0F;

	mov	DWORD PTR _hor_low_gain$[ebp], 1065353216 ; 3f800000H
	mov	DWORD PTR _hor_high_gain$[ebp], 1065353216 ; 3f800000H

; 200  :   unit_height = false;

	mov	BYTE PTR [esi+163], 0

; 201  :   if (vert_xform_exists)

	test	cl, cl
	je	$LN61@init

; 202  :     {
; 203  :       int low_min, low_max, high_min, high_max, max_step_length;
; 204  :       vert_step_info =

	push	1
	lea	eax, DWORD PTR _high_max$8[ebp]
	push	eax
	lea	eax, DWORD PTR _high_min$11[ebp]
	push	eax
	lea	eax, DWORD PTR _low_max$5[ebp]
	push	eax
	lea	eax, DWORD PTR _low_min$9[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+54]
	push	eax
	lea	eax, DWORD PTR [esi+52]
	push	eax
	lea	eax, DWORD PTR _vert_high_gain$[ebp]
	push	eax
	lea	eax, DWORD PTR _vert_low_gain$[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+24]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?get_kernel_info@kdu_node@@QAEPBUkdu_kernel_step_info@@AAHAAM1AA_N20000_N@Z ; kdu_node::get_kernel_info

; 205  :         node.get_kernel_info(num_vert_steps,vert_low_gain,vert_high_gain,
; 206  :                              vert_symmetric,vert_symmetric_extension,
; 207  :                              low_min,low_max,high_min,high_max,true);
; 208  :       max_vert_kernel_support =

	mov	edx, DWORD PTR _high_min$11[ebp]
	mov	edi, eax
	cmp	DWORD PTR _low_min$9[ebp], edx
	mov	eax, DWORD PTR _high_max$8[ebp]
	cmovl	edx, DWORD PTR _low_min$9[ebp]
	cmp	DWORD PTR _low_max$5[ebp], eax
	mov	DWORD PTR _vert_step_info$1$[ebp], edi
	cmovg	eax, DWORD PTR _low_max$5[ebp]
	sub	eax, edx
	mov	DWORD PTR _max_vert_kernel_support$1$[ebp], eax

; 209  :         ((low_max > high_max)?low_max:high_max) -
; 210  :         ((low_min < high_min)?low_min:high_min);
; 211  :       if (num_vert_steps <= 4)

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, 4
	jg	SHORT $LN63@init

; 212  :         vert_steps = step_store;

	lea	eax, DWORD PTR [esi+464]

; 213  :       else

	jmp	SHORT $LN363@init
$LN63@init:

; 214  :         vert_steps = vert_step_handle = new kd_lifting_step[num_vert_steps];

	xor	ecx, ecx
	mov	edx, 20					; 00000014H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+184], eax
$LN363@init:

; 215  :       for (max_step_length=0, s=0; s < num_vert_steps; s++)

	xor	ecx, ecx
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR _max_step_length$1$[ebp], ecx
	mov	DWORD PTR _s$1$[ebp], ecx
	cmp	DWORD PTR [esi+24], ecx
	jle	$LN358@init
	xor	edx, edx
$LL4@init:

; 216  :         {
; 217  :           vert_steps[s].support_min = (kdu_int16)

	mov	ecx, DWORD PTR [esi+44]
	lea	edx, DWORD PTR [edx+20]
	movzx	eax, WORD PTR [edi+4]
	lea	edi, DWORD PTR [edi+16]
	mov	WORD PTR [edx+ecx-16], ax

; 218  :             vert_step_info[s].support_min;
; 219  :           vert_steps[s].support_length = (kdu_byte)

	mov	ecx, DWORD PTR [esi+44]
	mov	al, BYTE PTR [edi-16]
	mov	BYTE PTR [edx+ecx-19], al

; 220  :             vert_step_info[s].support_length;
; 221  :           vert_steps[s].downshift = (kdu_byte) vert_step_info[s].downshift;

	mov	ecx, DWORD PTR [esi+44]
	mov	al, BYTE PTR [edi-8]
	mov	BYTE PTR [edx+ecx-18], al

; 222  :           vert_steps[s].rounding_offset = (kdu_int16)

	mov	ecx, DWORD PTR [esi+44]
	movzx	eax, WORD PTR [edi-4]
	mov	WORD PTR [edx+ecx-14], ax

; 223  :             vert_step_info[s].rounding_offset;
; 224  :           vert_steps[s].kernel_id = (kdu_byte) kernel_id;

	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _kernel_id$1$[ebp]
	mov	BYTE PTR [edx+eax-2], cl

; 225  :           vert_steps[s].reversible = reversible;

	mov	ecx, DWORD PTR [esi+44]
	mov	al, BYTE PTR [esi+20]
	mov	BYTE PTR [edx+ecx-3], al

; 226  :           if (max_step_length < (int) vert_step_info[s].support_length)

	mov	eax, DWORD PTR [edi-16]
	mov	ecx, DWORD PTR _max_step_length$1$[ebp]
	cmp	ecx, eax
	cmovl	ecx, eax

; 227  :             max_step_length = vert_step_info[s].support_length;
; 228  :           total_coeffs += vert_step_info[s].support_length;

	add	DWORD PTR _total_coeffs$1$[ebp], eax
	mov	eax, DWORD PTR _s$1$[ebp]
	inc	eax
	mov	DWORD PTR _max_step_length$1$[ebp], ecx
	mov	DWORD PTR _s$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+24]
	jl	SHORT $LL4@init

; 229  :         }
; 230  : 
; 231  :       if (max_step_length <= 4)

	cmp	ecx, 4
	jle	SHORT $LN362@init

; 233  :       else
; 234  :         vert_source_bufs = source_buf_handle = new void *[2*max_step_length];

	lea	eax, DWORD PTR [ecx+ecx]
	mov	edx, 4
	xor	ecx, ecx
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR _max_step_length$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+176], eax
	jmp	SHORT $LN364@init
$LN362@init:
	mov	ecx, DWORD PTR _max_step_length$1$[ebp]
$LN358@init:

; 232  :         vert_source_bufs = source_buf_store;

	lea	eax, DWORD PTR [esi+264]
$LN364@init:
	mov	DWORD PTR [esi+36], eax
	xorps	xmm0, xmm0

; 235  :       vert_source_vlines =

	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+32], eax

; 236  :         (kd_vlift_line **)(vert_source_bufs+max_step_length);
; 237  : 
; 238  :       kdu_dims lh_dims;  child[LH_BAND].get_dims(lh_dims);

	lea	ecx, DWORD PTR _child$[ebp+8]
	lea	eax, DWORD PTR _lh_dims$16[ebp]
	push	eax
	movups	XMMWORD PTR _lh_dims$16[ebp], xmm0
	call	?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z	; kdu_node::get_dims

; 239  :       y_min_in[0] = (ll_dims.pos.y<<1);

	mov	ecx, DWORD PTR _ll_dims$[ebp]

; 240  :       y_max_in[0] = ((ll_dims.pos.y+ll_dims.size.y-1)<<1);

	mov	edi, DWORD PTR _ll_dims$[ebp+8]

; 241  :       y_min_in[1] = (lh_dims.pos.y<<1) + 1;

	mov	edx, DWORD PTR _lh_dims$16[ebp]
	lea	eax, DWORD PTR [ecx+ecx]
	mov	DWORD PTR [esi+80], eax
	lea	eax, DWORD PTR [edi+ecx]

; 242  :       y_max_in[1] = ((lh_dims.pos.y+lh_dims.size.y-1)<<1) + 1;

	mov	ecx, DWORD PTR _lh_dims$16[ebp+8]
	lea	eax, DWORD PTR [eax*2-2]
	mov	DWORD PTR [esi+96], eax
	lea	eax, DWORD PTR [edx*2+1]
	mov	DWORD PTR [esi+84], eax
	lea	eax, DWORD PTR [ecx+edx]
	lea	eax, DWORD PTR [eax*2-1]
	mov	DWORD PTR [esi+100], eax

; 243  :       if (lh_dims.size.y <= 0)

	test	ecx, ecx
	jg	SHORT $LN68@init

; 244  :         {
; 245  :           unit_height = 1;

	mov	BYTE PTR [esi+163], 1

; 246  :           assert(y_min_in[0] == y_max_in[0]);
; 247  :           y_min_in[1] = y_min_in[0] + 1;

	mov	eax, DWORD PTR [esi+80]
	inc	eax
	mov	DWORD PTR [esi+84], eax

; 248  :           y_max_in[1] = y_min_in[1] - 2;

	add	eax, -2					; fffffffeH
	mov	DWORD PTR [esi+100], eax
$LN68@init:

; 249  :         }
; 250  :       if (ll_dims.size.y <= 0)

	test	edi, edi
	jg	SHORT $LN62@init

; 251  :         {
; 252  :           unit_height = 1;

	mov	BYTE PTR [esi+163], 1

; 253  :           assert(y_min_in[1] == y_max_in[1]);
; 254  :           y_min_in[0] = y_min_in[1] + 1;

	mov	eax, DWORD PTR [esi+84]
	inc	eax
	mov	DWORD PTR [esi+80], eax

; 255  :           y_max_in[0] = y_min_in[0] - 2;

	add	eax, -2					; fffffffeH

; 256  :         }
; 257  :     }
; 258  :   else

	jmp	SHORT $LN365@init
$LN61@init:

; 259  :     {
; 260  :       y_min_in[0] = y_min_out;  y_max_in[0] = y_max_out;

	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [esi+80], eax
	mov	eax, DWORD PTR [esi+76]
$LN365@init:
	mov	DWORD PTR [esi+96], eax
$LN62@init:

; 261  :     }
; 262  : 
; 263  :   unit_width = false;
; 264  :   if (hor_xform_exists)

	cmp	BYTE PTR [esi+23], 0
	mov	BYTE PTR [esi+164], 0
	je	$LN70@init

; 265  :     {
; 266  :       int low_min, low_max, high_min, high_max;
; 267  :       hor_step_info =

	push	0
	lea	eax, DWORD PTR _high_max$4[ebp]
	push	eax
	lea	eax, DWORD PTR _high_min$7[ebp]
	push	eax
	lea	eax, DWORD PTR _low_max$10[ebp]
	push	eax
	lea	eax, DWORD PTR _low_min$13[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+55]
	push	eax
	lea	eax, DWORD PTR [esi+53]
	push	eax
	lea	eax, DWORD PTR _hor_high_gain$[ebp]
	push	eax
	lea	eax, DWORD PTR _hor_low_gain$[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+28]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?get_kernel_info@kdu_node@@QAEPBUkdu_kernel_step_info@@AAHAAM1AA_N20000_N@Z ; kdu_node::get_kernel_info
	mov	edi, eax

; 268  :         node.get_kernel_info(num_hor_steps,hor_low_gain,hor_high_gain,
; 269  :                              hor_symmetric,hor_symmetric_extension,
; 270  :                              low_min,low_max,high_min,high_max,false);
; 271  : 
; 272  :       if (hor_step_info == vert_step_info)

	cmp	edi, DWORD PTR _vert_step_info$1$[ebp]
	jne	SHORT $LN72@init

; 273  :         hor_steps = vert_steps;

	mov	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+48], ecx
	jmp	SHORT $LN75@init
$LN72@init:

; 274  :       else if ((num_hor_steps+num_vert_steps) <= 4)

	mov	edx, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [edx+ecx]
	cmp	eax, 4
	jg	SHORT $LN74@init

; 275  :         hor_steps = step_store + num_vert_steps;

	lea	eax, DWORD PTR [ecx+29]
	lea	eax, DWORD PTR [ecx+eax*4]
	lea	eax, DWORD PTR [esi+eax*4]

; 276  :       else

	jmp	SHORT $LN366@init
$LN74@init:

; 277  :         hor_steps = hor_step_handle = new kd_lifting_step[num_hor_steps];

	xor	ecx, ecx
	mov	eax, edx
	mov	edx, 20					; 00000014H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+188], eax
$LN366@init:
	mov	DWORD PTR [esi+48], eax
$LN75@init:

; 278  :       if (hor_steps != vert_steps)

	mov	eax, DWORD PTR [esi+48]
	cmp	eax, DWORD PTR [esi+44]
	je	SHORT $LN6@init

; 279  :         for (s=0; s < num_hor_steps; s++)

	cmp	DWORD PTR [esi+28], 0
	mov	DWORD PTR _s$2$[ebp], 0
	jle	SHORT $LN6@init
	xor	edx, edx
	add	edi, 8
$LL7@init:

; 280  :           {
; 281  :             hor_steps[s].support_min = (kdu_int16)

	mov	ecx, DWORD PTR [esi+48]
	lea	edx, DWORD PTR [edx+20]
	movzx	eax, WORD PTR [edi-4]
	lea	edi, DWORD PTR [edi+16]
	mov	WORD PTR [ecx+edx-16], ax

; 282  :               hor_step_info[s].support_min;
; 283  :             hor_steps[s].support_length = (kdu_byte)

	mov	ecx, DWORD PTR [esi+48]
	mov	al, BYTE PTR [edi-24]
	mov	BYTE PTR [ecx+edx-19], al

; 284  :               hor_step_info[s].support_length;
; 285  :             hor_steps[s].downshift = (kdu_byte) hor_step_info[s].downshift;

	mov	ecx, DWORD PTR [esi+48]
	mov	al, BYTE PTR [edi-16]
	mov	BYTE PTR [ecx+edx-18], al

; 286  :             hor_steps[s].rounding_offset = (kdu_int16)

	mov	ecx, DWORD PTR [esi+48]
	movzx	eax, WORD PTR [edi-12]
	mov	WORD PTR [ecx+edx-14], ax

; 287  :               hor_step_info[s].rounding_offset;
; 288  :             hor_steps[s].kernel_id = (kdu_byte) kernel_id;

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR _kernel_id$1$[ebp]
	mov	BYTE PTR [eax+edx-2], cl

; 289  :             hor_steps[s].reversible = reversible;

	mov	ecx, DWORD PTR [esi+48]
	mov	al, BYTE PTR [esi+20]
	mov	BYTE PTR [ecx+edx-3], al

; 290  :             total_coeffs += hor_step_info[s].support_length;

	mov	eax, DWORD PTR _total_coeffs$1$[ebp]
	add	eax, DWORD PTR [edi-24]
	mov	DWORD PTR _total_coeffs$1$[ebp], eax
	mov	eax, DWORD PTR _s$2$[ebp]
	inc	eax
	mov	DWORD PTR _s$2$[ebp], eax
	cmp	eax, DWORD PTR [esi+28]
	jl	SHORT $LL7@init
$LN6@init:

; 291  :           }
; 292  : 
; 293  :       kdu_dims hl_dims;  child[HL_BAND].get_dims(hl_dims);

	lea	eax, DWORD PTR _hl_dims$15[ebp]
	xorps	xmm0, xmm0
	push	eax
	lea	ecx, DWORD PTR _child$[ebp+4]
	movups	XMMWORD PTR _hl_dims$15[ebp], xmm0
	call	?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z	; kdu_node::get_dims

; 294  :       int min_in[2] = {(ll_dims.pos.x<<1),
; 295  :                        (hl_dims.pos.x<<1)+1};

	mov	eax, DWORD PTR _hl_dims$15[ebp+4]
	mov	edi, DWORD PTR _ll_dims$[ebp+4]

; 296  :       int max_in[2] = {((ll_dims.pos.x+ll_dims.size.x-1)<<1),
; 297  :                        ((hl_dims.pos.x+hl_dims.size.x-1)<<1)+1};

	mov	esi, DWORD PTR _hl_dims$15[ebp+12]
	mov	DWORD PTR _hl_dims$1$[ebp], eax
	lea	edx, DWORD PTR [eax*2+1]
	mov	eax, DWORD PTR _ll_dims$[ebp+12]
	add	eax, edi
	lea	ecx, DWORD PTR [edi+edi]
	lea	edi, DWORD PTR [eax*2-2]
	mov	eax, DWORD PTR _hl_dims$1$[ebp]
	add	eax, esi

; 298  :       if (hl_dims.size.x <= 0)

	test	esi, esi
	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR [eax*2-1]
	jg	SHORT $LN77@init

; 299  :         {
; 300  :           unit_width = true;
; 301  :           assert(min_in[0] == max_in[0]);
; 302  :           min_in[1] = min_in[0] + 1;

	lea	edx, DWORD PTR [ecx+1]
	mov	BYTE PTR [esi+164], 1

; 303  :           max_in[1] = min_in[1] - 2;

	lea	eax, DWORD PTR [edx-2]
$LN77@init:

; 304  :         }
; 305  :       if (ll_dims.size.x <= 0)

	cmp	DWORD PTR _ll_dims$[ebp+12], 0
	jg	SHORT $LN78@init

; 306  :         {
; 307  :           unit_width = true;
; 308  :           assert(min_in[1] == max_in[1]);
; 309  :           min_in[0] = min_in[1] + 1;

	lea	ecx, DWORD PTR [edx+1]
	mov	BYTE PTR [esi+164], 1

; 310  :           max_in[0] = min_in[0] - 2;

	lea	edi, DWORD PTR [ecx-2]
$LN78@init:

; 311  :         }
; 312  :       x_min_in = (min_in[0] < min_in[1])?min_in[0]:min_in[1];

	cmp	ecx, edx
	cmovl	edx, ecx

; 313  :       x_max_in = (max_in[0] > max_in[1])?max_in[0]:max_in[1];

	cmp	edi, eax
	mov	DWORD PTR [esi+108], edx
	cmovg	eax, edi
	mov	DWORD PTR [esi+112], eax

; 314  :       while (x_min_in < x_min_buf)

	mov	eax, DWORD PTR [esi+104]
	cmp	edx, eax
	jge	SHORT $LN9@init

; 315  :         x_min_buf -= (use_shorts)?8:4;

	xor	ecx, ecx
	cmp	BYTE PTR _use_shorts$GSCopy$1$[ebp], cl
	setne	cl
	lea	ecx, DWORD PTR [ecx*4+4]
$LL8@init:
	sub	eax, ecx
	cmp	edx, eax
	jl	SHORT $LL8@init
	mov	DWORD PTR [esi+104], eax
$LN9@init:

; 316  :       coset_off_in[0] = (kdu_byte)(((x_min_in+1)>>1) - ((x_min_buf+1)>>1));

	mov	eax, DWORD PTR [esi+104]
	inc	edx
	inc	eax
	sar	edx, 1
	sar	eax, 1
	sub	dl, al
	mov	BYTE PTR [esi+124], dl

; 317  :       coset_off_in[1] = (kdu_byte)((x_min_in >> 1) - (x_min_buf >> 1));

	mov	ecx, DWORD PTR [esi+108]
	mov	eax, DWORD PTR [esi+104]
	sar	eax, 1
	sar	ecx, 1
	sub	cl, al

; 318  :       coset_width_in[0] = 1 + (x_max_in>>1) - ((x_min_in+1)>>1);
; 319  :       coset_width_in[1] = 1 + ((x_max_in-1)>>1) - (x_min_in>>1);
; 320  :       request_offset[0] = (kdu_byte)(ll_dims.pos.x - ((x_min_buf+1)>>1));
; 321  :       request_offset[1] = (kdu_byte)(hl_dims.pos.x - (x_min_buf>>1));
; 322  :       request_width[0] = ll_dims.size.x;
; 323  :       request_width[1] = hl_dims.size.x;
; 324  : 
; 325  :       int lfill[2], rfill[2];
; 326  :       lfill[0] = ((int) request_offset[0]) - ((int) coset_off_in[0]);

	movzx	edx, dl
	mov	BYTE PTR [esi+125], cl
	mov	eax, DWORD PTR [esi+112]
	sar	eax, 1
	mov	DWORD PTR tv4027[ebp], ecx
	mov	ecx, DWORD PTR [esi+108]
	inc	ecx
	mov	DWORD PTR _rfill$1$[ebp], edx
	sar	ecx, 1
	sub	eax, ecx
	mov	ecx, DWORD PTR _ll_dims$[ebp+4]
	inc	eax
	mov	DWORD PTR [esi+116], eax
	mov	edi, DWORD PTR [esi+112]
	mov	DWORD PTR tv4364[ebp], eax
	dec	edi
	mov	eax, DWORD PTR [esi+108]
	sar	eax, 1
	sar	edi, 1
	sub	edi, eax
	inc	edi
	mov	DWORD PTR [esi+120], edi
	mov	eax, DWORD PTR [esi+104]
	inc	eax
	sar	eax, 1
	sub	cl, al
	mov	BYTE PTR [esi+126], cl
	mov	eax, DWORD PTR [esi+104]
	sar	eax, 1
	sub	BYTE PTR _hl_dims$1$[ebp], al
	mov	eax, DWORD PTR _hl_dims$1$[ebp]
	mov	BYTE PTR [esi+127], al
	mov	eax, DWORD PTR _ll_dims$[ebp+12]
	mov	DWORD PTR [esi+128], eax
	mov	eax, DWORD PTR _hl_dims$15[ebp+12]
	mov	DWORD PTR [esi+132], eax
	movzx	eax, cl

; 327  :       lfill[1] = ((int) request_offset[1]) - ((int) coset_off_in[1]);
; 328  :       rfill[0] = (coset_off_in[0]+coset_width_in[0])

	sub	DWORD PTR _rfill$1$[ebp], eax
	mov	ecx, eax
	mov	eax, DWORD PTR _rfill$1$[ebp]
	sub	ecx, edx
	sub	eax, DWORD PTR _ll_dims$[ebp+12]
	add	eax, DWORD PTR tv4364[ebp]
	mov	edx, DWORD PTR tv4027[ebp]
	mov	DWORD PTR _lfill$1$[ebp], ecx
	mov	ecx, DWORD PTR _hl_dims$1$[ebp]
	movzx	ecx, cl
	movzx	esi, dl
	mov	edx, ecx
	mov	DWORD PTR _rfill$1$[ebp], eax
	sub	edx, esi

; 329  :                - (request_offset[0]+request_width[0]);
; 330  :       rfill[1] = (coset_off_in[1]+coset_width_in[1])

	mov	eax, esi
	mov	DWORD PTR _rfill$2$[ebp], esi

; 331  :                - (request_offset[1]+request_width[1]);
; 332  :       assert((lfill[0] >= 0) && (rfill[0] >= 0) &&
; 333  :              (lfill[0] < 256) && (rfill[0] < 256) &&
; 334  :              (lfill[1] >= 0) && (rfill[1] >= 0) &&
; 335  :              (lfill[1] < 256) && (rfill[1] < 256));
; 336  :       left_fill[0] = (kdu_byte) lfill[0];  right_fill[0] = (kdu_byte) rfill[0];

	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	sub	eax, ecx
	sub	eax, DWORD PTR _hl_dims$15[ebp+12]
	mov	ecx, DWORD PTR _lfill$1$[ebp]
	add	eax, edi
	mov	BYTE PTR [esi+136], cl
	mov	ecx, DWORD PTR _rfill$1$[ebp]
	mov	BYTE PTR [esi+138], cl

; 337  :       left_fill[1] = (kdu_byte) lfill[1];  right_fill[1] = (kdu_byte) rfill[1];

	mov	BYTE PTR [esi+139], al
	mov	BYTE PTR [esi+137], dl

; 338  : 
; 339  :       coset_off_out[1] = (kdu_byte)((x_min_out >> 1) - (x_min_buf >> 1));

	mov	ecx, DWORD PTR [esi+140]
	mov	eax, DWORD PTR [esi+104]
	sar	ecx, 1
	sar	eax, 1
	sub	cl, al
	mov	BYTE PTR [esi+161], cl

; 340  :       coset_off_out[0] = (kdu_byte)(((x_min_out+1)>>1) - ((x_min_buf+1)>>1));

	mov	ecx, DWORD PTR [esi+140]
	mov	eax, DWORD PTR [esi+104]
	inc	ecx
	inc	eax
	sar	ecx, 1
	sar	eax, 1
	sub	cl, al
	mov	BYTE PTR [esi+160], cl

; 341  :       coset_width_out[0] = 1 + (x_max_out >> 1) - ((x_min_out+1)>>1);

	mov	ecx, DWORD PTR [esi+140]
	mov	eax, DWORD PTR [esi+144]
	inc	ecx
	sar	ecx, 1
	sar	eax, 1
	sub	eax, ecx
	inc	eax
	mov	DWORD PTR [esi+148], eax

; 342  :       coset_width_out[1] = 1 + ((x_max_out-1)>>1) - (x_min_out>>1);

	mov	ecx, DWORD PTR [esi+144]
	mov	eax, DWORD PTR [esi+140]
	dec	ecx
	sar	ecx, 1
	sar	eax, 1
	sub	ecx, eax
	inc	ecx
	mov	DWORD PTR [esi+152], ecx

; 343  :     }
; 344  :   else

	jmp	$LN71@init
$LN70@init:

; 345  :     {
; 346  :       x_min_in = x_min_out;  x_max_in = x_max_out;

	mov	eax, DWORD PTR [esi+140]
	mov	DWORD PTR [esi+108], eax
	mov	eax, DWORD PTR [esi+144]
	mov	DWORD PTR [esi+112], eax

; 347  :       request_offset[0] = (kdu_byte) pull_offset;

	mov	eax, DWORD PTR _pull_offset$[ebp]
	mov	BYTE PTR [esi+126], al

; 348  :       request_width[0] = x_max_out+1-x_min_out;

	mov	eax, DWORD PTR [esi+144]
	sub	eax, DWORD PTR [esi+140]
	inc	eax

; 349  :       request_offset[1] = 0; request_width[1] = 0;

	mov	BYTE PTR [esi+127], 0
	mov	DWORD PTR [esi+128], eax
	mov	DWORD PTR [esi+132], 0

; 350  :       left_fill[0] = left_fill[1] = right_fill[0] = right_fill[1] = 0;

	mov	DWORD PTR [esi+136], 0

; 351  :       coset_off_out[0] = (kdu_byte)(x_min_out - x_min_buf);

	mov	al, BYTE PTR [esi+140]
	sub	al, BYTE PTR [esi+104]
	mov	BYTE PTR [esi+160], al

; 352  :       coset_width_out[0] = 1 + x_max_out - x_min_out;

	mov	eax, DWORD PTR [esi+144]
	sub	eax, DWORD PTR [esi+140]
	inc	eax

; 353  :       coset_off_out[1] = 0;  coset_width_out[1] = 0;

	mov	BYTE PTR [esi+161], 0
	mov	DWORD PTR [esi+148], eax
	mov	DWORD PTR [esi+152], 0
$LN71@init:

; 354  :     }
; 355  : 
; 356  :   // Next, allocate coefficient storage and initialize lifting steps
; 357  :   float *coeff_next = coeff_store;
; 358  :   int *icoeff_next = icoeff_store;
; 359  :   if (total_coeffs > 8)

	mov	edi, DWORD PTR _total_coeffs$1$[ebp]
	lea	eax, DWORD PTR [esi+200]
	mov	DWORD PTR _coeff_next$1$[ebp], eax
	lea	eax, DWORD PTR [esi+232]
	mov	DWORD PTR _icoeff_next$1$[ebp], eax
	cmp	edi, 8
	jle	SHORT $LN79@init

; 360  :     {
; 361  :       coeff_next = coeff_handle = new float[total_coeffs];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR _coeff_next$1$[ebp], eax

; 362  :       icoeff_next = icoeff_handle = new int[total_coeffs];

	xor	ecx, ecx
	mov	DWORD PTR [esi+168], eax
	mov	edx, 4
	mov	eax, edi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 8
	mov	DWORD PTR _icoeff_next$1$[ebp], eax
	mov	DWORD PTR [esi+172], eax
$LN79@init:

; 363  :     }
; 364  :   if (vert_xform_exists)

	cmp	BYTE PTR [esi+22], 0
	je	$LN11@init

; 365  :     {
; 366  :       const float *coefficients = node.get_kernel_coefficients(true);

	push	1
	lea	ecx, DWORD PTR _node$[ebp]
	call	?get_kernel_coefficients@kdu_node@@QAEPBM_N@Z ; kdu_node::get_kernel_coefficients
	mov	edx, eax

; 367  :       for (s=0; s < num_vert_steps; s++)

	xor	eax, eax
	mov	DWORD PTR _coefficients$1$[ebp], edx
	mov	DWORD PTR _s$3$[ebp], eax
	cmp	DWORD PTR [esi+24], eax
	jle	$LN11@init

; 365  :     {
; 366  :       const float *coefficients = node.get_kernel_coefficients(true);

	xor	ecx, ecx
	mov	DWORD PTR tv4299[ebp], ecx
$LL12@init:

; 368  :         {
; 369  :           kd_lifting_step *step = vert_steps + s;

	mov	edi, DWORD PTR [esi+44]
	add	edi, ecx

; 370  :           step->step_idx = s;
; 371  : 
; 372  :           step->coeffs = coeff_next;
; 373  :           step->icoeffs = icoeff_next;
; 374  :           step->add_shorts_first = false;
; 375  : #ifdef KDU_SIMD_OPTIMIZATIONS
; 376  :           if ((kernel_id == Ckernels_W9X7) && (s != 1) &&

	cmp	DWORD PTR _kernel_id$1$[ebp], 0
	mov	ecx, DWORD PTR _coeff_next$1$[ebp]
	mov	BYTE PTR [edi], al
	mov	DWORD PTR [edi+8], ecx
	mov	ecx, DWORD PTR _icoeff_next$1$[ebp]
	mov	DWORD PTR [edi+12], ecx
	mov	BYTE PTR [edi+16], 0
	jne	SHORT $LN81@init
	cmp	eax, 1
	je	SHORT $LN81@init
	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 0	; kdu_mmx_level
	jg	SHORT $LN82@init
	cmp	BYTE PTR ?kdu_sparcvis_exists@@3_NA, 0	; kdu_sparcvis_exists
	jne	SHORT $LN82@init
	cmp	BYTE PTR ?kdu_altivec_exists@@3_NA, 0	; kdu_altivec_exists
	je	SHORT $LN81@init
$LN82@init:

; 377  :               ((kdu_mmx_level>0)||kdu_sparcvis_exists||kdu_altivec_exists))
; 378  :             step->add_shorts_first = true;

	mov	BYTE PTR [edi+16], 1
$LN81@init:

; 379  : #endif // KDU_SIMD_OPTIMIZATIONS
; 380  :           float fact, max_factor = 0.4F;

	movss	xmm1, DWORD PTR __real@3ecccccd

; 381  :           for (n=0; n < step->support_length; n++)

	xor	ecx, ecx
	cmp	BYTE PTR [edi+1], cl
	jbe	SHORT $LN14@init
$LL15@init:

; 382  :             {
; 383  :               step->coeffs[n] = fact = coefficients[n];

	mov	eax, DWORD PTR [edi+8]
	movss	xmm2, DWORD PTR [edx+ecx*4]

; 384  :               if (fact > max_factor)

	comiss	xmm2, xmm1
	movss	DWORD PTR [eax+ecx*4], xmm2
	jbe	SHORT $LN83@init

; 385  :                 max_factor = fact;

	movaps	xmm1, xmm2
	jmp	SHORT $LN13@init
$LN83@init:

; 386  :               else if (fact < -max_factor)

	movss	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm0, xmm1
	xorps	xmm0, xmm3
	comiss	xmm0, xmm2
	jbe	SHORT $LN13@init

; 387  :                 max_factor = -fact;

	movaps	xmm1, xmm2
	xorps	xmm1, xmm3
$LN13@init:

; 381  :           for (n=0; n < step->support_length; n++)

	movzx	eax, BYTE PTR [edi+1]
	inc	ecx
	cmp	ecx, eax
	jl	SHORT $LL15@init
$LN14@init:

; 388  :             }
; 389  :           if (!reversible)

	cmp	BYTE PTR [esi+20], 0
	jne	SHORT $LN88@init

; 390  :             { // Find appropriate downshift and rounding_offset values
; 391  :               for (step->downshift=16; max_factor >= 0.499F; max_factor*=0.5F)

	movss	xmm0, DWORD PTR __real@3eff7cee
	comiss	xmm1, xmm0
	mov	BYTE PTR [edi+2], 16			; 00000010H
	jb	SHORT $LN17@init
	movss	xmm2, DWORD PTR __real@3f000000
	mov	al, 16					; 00000010H
	npad	5
$LL18@init:
	mulss	xmm1, xmm2

; 392  :                 step->downshift--;

	add	al, 255					; 000000ffH
	comiss	xmm1, xmm0
	jae	SHORT $LL18@init
	mov	BYTE PTR [edi+2], al
$LN17@init:

; 393  :               if (step->downshift > 15)

	mov	al, BYTE PTR [edi+2]
	cmp	al, 15					; 0000000fH
	jbe	SHORT $LN87@init

; 394  :                 step->rounding_offset = KDU_INT16_MAX;

	mov	eax, 32767				; 00007fffH

; 395  :               else

	jmp	SHORT $LN367@init
$LN87@init:

; 396  :                 step->rounding_offset = (kdu_int16)(1<<(step->downshift-1));

	movzx	ecx, al
	mov	eax, 1
	dec	ecx
	shl	ax, cl
$LN367@init:
	mov	WORD PTR [edi+6], ax
$LN88@init:

; 397  :             }
; 398  :           fact = (float)(1<<step->downshift);

	mov	cl, BYTE PTR [edi+2]
	mov	eax, 1
	shl	eax, cl

; 399  :           for (n=0; n < step->support_length; n++)

	cmp	BYTE PTR [edi+1], 0
	mov	DWORD PTR _n$2$[ebp], 0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR _fact$2$[ebp], xmm1
	jbe	SHORT $LN20@init
	mov	esi, DWORD PTR _n$2$[ebp]
$LL21@init:

; 400  :             step->icoeffs[n] = (int) floor(0.5 + step->coeffs[n] * fact);

	mov	eax, DWORD PTR [edi+8]
	sub	esp, 8
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, xmm1
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv4634[ebp], xmm0
	fld	QWORD PTR tv4634[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR [edi+12]
	movss	xmm1, DWORD PTR _fact$2$[ebp]
	mov	DWORD PTR [ecx+esi*4], eax
	inc	esi
	movzx	eax, BYTE PTR [edi+1]
	cmp	esi, eax
	jl	SHORT $LL21@init
	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	edx, DWORD PTR _coefficients$1$[ebp]
$LN20@init:

; 401  :           coeff_next += step->support_length;

	movzx	eax, BYTE PTR [edi+1]
	mov	ecx, DWORD PTR tv4299[ebp]
	shl	eax, 2
	add	ecx, 20					; 00000014H
	add	DWORD PTR _coeff_next$1$[ebp], eax

; 402  :           icoeff_next += step->support_length;
; 403  :           coefficients += step->support_length;

	add	edx, eax
	add	DWORD PTR _icoeff_next$1$[ebp], eax
	mov	eax, DWORD PTR _s$3$[ebp]
	inc	eax

; 404  : 
; 405  :           step->extend = 0; // Not used in the vertical direction

	mov	BYTE PTR [edi+3], 0
	mov	DWORD PTR _coefficients$1$[ebp], edx
	mov	DWORD PTR _s$3$[ebp], eax
	mov	DWORD PTR tv4299[ebp], ecx
	cmp	eax, DWORD PTR [esi+24]
	jl	$LL12@init
$LN11@init:

; 406  :         }
; 407  :     }
; 408  : 
; 409  :   int max_extend=0;

	xor	edi, edi

; 410  :   if (hor_xform_exists)

	cmp	BYTE PTR [esi+23], 0
	mov	DWORD PTR _max_extend$1$[ebp], edi
	je	$LN23@init

; 411  :     {
; 412  :       const float *coefficients = node.get_kernel_coefficients(false);

	push	edi
	lea	ecx, DWORD PTR _node$[ebp]
	call	?get_kernel_coefficients@kdu_node@@QAEPBM_N@Z ; kdu_node::get_kernel_coefficients
	mov	DWORD PTR _coefficients$1$[ebp], eax

; 413  :       for (s=0; s < num_hor_steps; s++)

	xor	eax, eax
	mov	DWORD PTR _s$4$[ebp], eax
	cmp	DWORD PTR [esi+28], eax
	jle	$LN23@init

; 411  :     {
; 412  :       const float *coefficients = node.get_kernel_coefficients(false);

	xor	edx, edx
	mov	DWORD PTR tv4298[ebp], edx
	npad	5
$LL24@init:

; 414  :         {
; 415  :           kd_lifting_step *step = hor_steps + s;

	mov	edi, DWORD PTR [esi+48]

; 416  :           if (hor_steps != vert_steps)

	cmp	edi, DWORD PTR [esi+44]
	je	$LN90@init

; 417  :             {
; 418  :               step->step_idx = s;
; 419  :               step->coeffs = coeff_next;
; 420  :               step->icoeffs = icoeff_next;
; 421  :               step->add_shorts_first = false;
; 422  : #ifdef KDU_SIMD_OPTIMIZATIONS
; 423  :               if ((kernel_id == Ckernels_W9X7) && (s != 1) &&

	cmp	DWORD PTR _kernel_id$1$[ebp], 0
	mov	ecx, DWORD PTR _coeff_next$1$[ebp]
	mov	DWORD PTR [edi+edx+8], ecx
	mov	ecx, DWORD PTR _icoeff_next$1$[ebp]
	mov	BYTE PTR [edi+edx], al
	mov	DWORD PTR [edi+edx+12], ecx
	mov	BYTE PTR [edi+edx+16], 0
	jne	SHORT $LN92@init
	cmp	eax, 1
	je	SHORT $LN92@init
	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 0	; kdu_mmx_level
	jg	SHORT $LN93@init
	cmp	BYTE PTR ?kdu_sparcvis_exists@@3_NA, 0	; kdu_sparcvis_exists
	jne	SHORT $LN93@init
	cmp	BYTE PTR ?kdu_altivec_exists@@3_NA, 0	; kdu_altivec_exists
	je	SHORT $LN92@init
$LN93@init:

; 424  :                   ((kdu_mmx_level>0)||kdu_sparcvis_exists||kdu_altivec_exists))
; 425  :                 step->add_shorts_first = true;

	mov	BYTE PTR [edi+edx+16], 1
$LN92@init:

; 426  : #endif // KDU_SIMD_OPTIMIZATIONS
; 427  :               float fact, max_factor = 0.4F;

	movss	xmm1, DWORD PTR __real@3ecccccd

; 428  :               for (n=0; n < step->support_length; n++)

	xor	ecx, ecx
	cmp	BYTE PTR [edi+edx+1], cl
	jbe	SHORT $LN26@init
	mov	esi, DWORD PTR _coefficients$1$[ebp]
$LL27@init:

; 429  :                 {
; 430  :                   step->coeffs[n] = fact = coefficients[n];

	mov	eax, DWORD PTR [edi+edx+8]
	movss	xmm2, DWORD PTR [esi+ecx*4]

; 431  :                   if (fact > max_factor)

	comiss	xmm2, xmm1
	movss	DWORD PTR [eax+ecx*4], xmm2
	jbe	SHORT $LN94@init

; 432  :                     max_factor = fact;

	movaps	xmm1, xmm2
	jmp	SHORT $LN25@init
$LN94@init:

; 433  :                   else if (fact < -max_factor)

	movss	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm0, xmm1
	xorps	xmm0, xmm3
	comiss	xmm0, xmm2
	jbe	SHORT $LN25@init

; 434  :                     max_factor = -fact;

	movaps	xmm1, xmm2
	xorps	xmm1, xmm3
$LN25@init:

; 428  :               for (n=0; n < step->support_length; n++)

	movzx	eax, BYTE PTR [edi+edx+1]
	inc	ecx
	cmp	ecx, eax
	jl	SHORT $LL27@init
	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
$LN26@init:

; 435  :                 }
; 436  :               if (!reversible)

	cmp	BYTE PTR [esi+20], 0
	jne	SHORT $LN99@init

; 437  :                 { // Find appropriate downshift and rounding_offset values
; 438  :                   for (step->downshift=16;
; 439  :                        max_factor >= 0.499F; max_factor*=0.5F)

	movss	xmm0, DWORD PTR __real@3eff7cee
	comiss	xmm1, xmm0
	mov	BYTE PTR [edi+edx+2], 16		; 00000010H
	jb	SHORT $LN29@init
	movss	xmm2, DWORD PTR __real@3f000000
	mov	al, 16					; 00000010H
$LL30@init:
	mulss	xmm1, xmm2

; 440  :                     step->downshift--;

	add	al, 255					; 000000ffH
	comiss	xmm1, xmm0
	jae	SHORT $LL30@init
	mov	BYTE PTR [edi+edx+2], al
$LN29@init:

; 441  :                   if (step->downshift > 15)

	mov	al, BYTE PTR [edi+edx+2]
	cmp	al, 15					; 0000000fH
	jbe	SHORT $LN98@init

; 442  :                     step->rounding_offset = KDU_INT16_MAX;

	mov	eax, 32767				; 00007fffH

; 443  :                   else

	jmp	SHORT $LN368@init
$LN98@init:

; 444  :                     step->rounding_offset = (kdu_int16)(1<<(step->downshift-1));

	movzx	ecx, al
	mov	eax, 1
	dec	ecx
	shl	ax, cl
$LN368@init:
	mov	WORD PTR [edi+edx+6], ax
$LN99@init:

; 445  :                 }
; 446  :               fact = (float)(1<<step->downshift);

	mov	cl, BYTE PTR [edi+edx+2]
	mov	eax, 1
	shl	eax, cl

; 447  :               for (n=0; n < step->support_length; n++)

	cmp	BYTE PTR [edi+edx+1], 0
	mov	DWORD PTR _n$4$[ebp], 0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR _fact$2$[ebp], xmm1
	jbe	SHORT $LN32@init
	mov	esi, DWORD PTR _n$4$[ebp]
	npad	9
$LL33@init:

; 448  :                 step->icoeffs[n] = (int) floor(0.5 + step->coeffs[n] * fact);

	mov	eax, DWORD PTR [edi+edx+8]
	sub	esp, 8
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, xmm1
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv4608[ebp], xmm0
	fld	QWORD PTR tv4608[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	edx, DWORD PTR tv4298[ebp]
	movss	xmm1, DWORD PTR _fact$2$[ebp]
	mov	ecx, DWORD PTR [edi+edx+12]
	mov	DWORD PTR [ecx+esi*4], eax
	inc	esi
	movzx	eax, BYTE PTR [edi+edx+1]
	cmp	esi, eax
	jl	SHORT $LL33@init
	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
$LN32@init:

; 449  :               coeff_next += step->support_length;

	movzx	eax, BYTE PTR [edi+edx+1]
	shl	eax, 2
	add	DWORD PTR _coeff_next$1$[ebp], eax

; 450  :               icoeff_next += step->support_length;

	add	DWORD PTR _icoeff_next$1$[ebp], eax
$LN90@init:

; 451  :             }
; 452  :           else
; 453  :             { // Horizontal and vertical lifting steps should be identical
; 454  :               for (n=0; n < step->support_length; n++)
; 455  :                 assert(step->coeffs[n] == coefficients[n]);
; 456  :             }
; 457  : 
; 458  :           coefficients += step->support_length;

	movzx	ecx, BYTE PTR [edi+edx+1]
	mov	eax, DWORD PTR _coefficients$1$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 459  : 
; 460  :           int extend_left = -step->support_min;
; 461  :           int extend_right = step->support_min-1 + (int) step->support_length;

	dec	ecx
	mov	DWORD PTR _coefficients$1$[ebp], eax
	movsx	eax, WORD PTR [edi+edx+4]
	mov	DWORD PTR _extend_left$1$[ebp], eax
	add	ecx, eax
	neg	DWORD PTR _extend_left$1$[ebp]

; 462  :           if (x_min_in & 1)

	test	BYTE PTR [esi+108], 1
	je	SHORT $LN100@init

; 463  :             extend_left += (s & 1)?(-1):1;

	test	BYTE PTR _s$4$[ebp], 1
	mov	eax, 0
	sete	al
	lea	eax, DWORD PTR [eax*2-1]
	add	DWORD PTR _extend_left$1$[ebp], eax
$LN100@init:

; 464  :           if (!(x_max_in & 1))

	test	BYTE PTR [esi+112], 1
	jne	SHORT $LN101@init

; 465  :             extend_right += (s & 1)?1:(-1);

	test	BYTE PTR _s$4$[ebp], 1
	mov	eax, 0
	setne	al
	lea	ecx, DWORD PTR [ecx+eax*2]
	dec	ecx
$LN101@init:

; 466  :           int extend = (extend_left > extend_right)?extend_left:extend_right;

	cmp	DWORD PTR _extend_left$1$[ebp], ecx
	cmovg	ecx, DWORD PTR _extend_left$1$[ebp]

; 467  :           extend = (extend < 0)?0:extend;

	xor	eax, eax
	test	ecx, ecx
	cmovs	ecx, eax

; 468  :           if (extend > max_extend)

	mov	eax, DWORD PTR _max_extend$1$[ebp]
	cmp	ecx, eax

; 469  :             max_extend = extend;
; 470  :           assert(extend < 256);
; 471  :           step->extend = (kdu_byte) extend;

	mov	BYTE PTR [edi+edx+3], cl
	cmovg	eax, ecx
	add	edx, 20					; 00000014H
	mov	DWORD PTR _max_extend$1$[ebp], eax
	mov	eax, DWORD PTR _s$4$[ebp]
	inc	eax
	mov	DWORD PTR tv4298[ebp], edx
	mov	DWORD PTR _s$4$[ebp], eax
	cmp	eax, DWORD PTR [esi+28]
	jl	$LL24@init
	mov	edi, DWORD PTR _max_extend$1$[ebp]
$LN23@init:

; 472  :         }
; 473  :     }
; 474  : 
; 475  :   // Create line queues
; 476  :   if ((num_vert_steps > 0) && !unit_height)

	mov	eax, DWORD PTR [esi+24]
	lea	ecx, DWORD PTR [esi+24]
	test	eax, eax
	jle	SHORT $LN103@init
	cmp	BYTE PTR [esi+163], 0
	jne	SHORT $LN103@init

; 477  :     {
; 478  :       if (num_vert_steps <= 4)

	cmp	eax, 4
	jg	SHORT $LN104@init

; 479  :         queues = queue_store;

	lea	eax, DWORD PTR [esi+544]

; 480  :       else

	jmp	SHORT $LN369@init
$LN104@init:

; 481  :         queues = queue_handle = new kd_vlift_queue[num_vert_steps+1];

	xor	ecx, ecx
	inc	eax
	mov	edx, 40					; 00000028H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+192], eax
	lea	ecx, DWORD PTR [esi+24]
$LN369@init:
	mov	DWORD PTR [esi+60], eax

; 482  :       queues += 1; // So we can access first queue with index -1

	add	DWORD PTR [esi+60], 40			; 00000028H
$LN103@init:

; 483  :     }
; 484  : 
; 485  :   // Create `step_next_row_pos' array
; 486  :   step_next_row_pos = NULL;
; 487  :   if (num_vert_steps > 0)

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+64], 0
	test	eax, eax
	jle	SHORT $LN108@init

; 488  :     {
; 489  :       if (num_vert_steps <= 4)

	cmp	eax, 4
	jg	SHORT $LN107@init

; 490  :         step_next_row_pos = next_row_pos_store;

	lea	eax, DWORD PTR [esi+744]

; 491  :       else

	jmp	SHORT $LN370@init
$LN107@init:

; 492  :         step_next_row_pos = next_row_pos_handle = new int[num_vert_steps];

	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+196], eax
$LN370@init:
	mov	DWORD PTR [esi+64], eax
$LN108@init:

; 493  :     }
; 494  : 
; 495  :   // Find allocation parameters for internal line buffers
; 496  :   int buf_width[2] = {request_offset[0] + request_width[0],

	movzx	ecx, BYTE PTR [esi+126]

; 497  :                       request_offset[1] + request_width[1]};

	movzx	eax, BYTE PTR [esi+127]
	add	ecx, DWORD PTR [esi+128]
	add	eax, DWORD PTR [esi+132]

; 498  :   int buf_neg_extent, buf_pos_extent;
; 499  :   if (hor_xform_exists)

	cmp	BYTE PTR [esi+23], 0
	mov	DWORD PTR _buf_width$1$[ebp], ecx
	mov	DWORD PTR _buf_width$2$[ebp], eax
	je	SHORT $LN109@init

; 500  :     {
; 501  :       int spare_left = // Num unused initial samples in all cosets
; 502  :         (coset_off_in[0] < coset_off_in[1])?coset_off_in[0]:coset_off_in[1];

	mov	dh, BYTE PTR [esi+125]
	mov	dl, BYTE PTR [esi+124]
	cmp	dl, dh
	movzx	eax, dl
	movzx	ecx, dh
	cmovb	ecx, eax
	movzx	eax, cl

; 503  :       buf_neg_extent = max_extend - spare_left;

	sub	edi, eax

; 504  :       if (buf_neg_extent < 0)
; 505  :         buf_neg_extent = 0;
; 506  :       buf_pos_extent = coset_off_in[0] + coset_width_in[0];
; 507  :       if (buf_pos_extent < (coset_off_in[1] + coset_width_in[1]))

	movzx	ecx, dh
	mov	eax, 0
	cmovs	edi, eax
	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR _buf_neg_extent$2$[ebp], edi
	add	eax, ecx
	movzx	edi, dl
	add	edi, DWORD PTR [esi+116]
	cmp	edi, eax
	cmovl	edi, eax

; 508  :         buf_pos_extent = coset_off_in[1] + coset_width_in[1];
; 509  :       buf_pos_extent += max_extend;

	add	edi, DWORD PTR _max_extend$1$[ebp]
	mov	DWORD PTR _buf_pos_extent$2$[ebp], edi

; 510  :     }
; 511  :   else

	jmp	SHORT $LN110@init
$LN109@init:

; 512  :     {
; 513  :       buf_neg_extent = 0;

	mov	DWORD PTR _buf_neg_extent$2$[ebp], 0

; 514  :       buf_pos_extent = buf_width[0];

	mov	edi, ecx
	mov	DWORD PTR _buf_pos_extent$2$[ebp], ecx
$LN110@init:

; 515  :     }
; 516  : 
; 517  :   // Simulate vertical lifting process to find number of line buffers required
; 518  :   int required_line_buffers = 1; // Need this if no vertical transform
; 519  :   if ((num_vert_steps > 0) && !unit_height)

	cmp	DWORD PTR [esi+24], 0
	mov	eax, 1
	mov	DWORD PTR _required_line_buffers$1$[ebp], eax
	jle	$LN114@init
	cmp	BYTE PTR [esi+163], 0
	jne	$LN114@init

; 520  :     required_line_buffers = simulate_vertical_lifting(max_vert_kernel_support);

	push	DWORD PTR _max_vert_kernel_support$1$[ebp]
	mov	ecx, esi
	call	?simulate_vertical_lifting@kd_synthesis@@IAEHH@Z ; kd_synthesis::simulate_vertical_lifting
	mov	DWORD PTR _required_line_buffers$1$[ebp], eax

; 521  : 
; 522  :   if (required_line_buffers > 6)

	cmp	eax, 6
	jle	$LN114@init

; 523  :     line_handle = new kd_vlift_line[required_line_buffers];

	xor	ecx, ecx
	mov	edx, 28					; 0000001cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, eax
	add	esp, 4
	mov	eax, DWORD PTR _required_line_buffers$1$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN141@init
	mov	edx, eax
	test	eax, eax
	je	SHORT $LN142@init
	add	ecx, 7
	npad	14
$LL193@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx-7], 0
	lea	ecx, DWORD PTR [ecx+28]
	mov	WORD PTR [ecx-29], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx-27], 0
	mov	DWORD PTR [ecx-23], 0
	mov	WORD PTR [ecx-17], 0
	mov	DWORD PTR [ecx-15], 0
	sub	edx, 1
	jne	SHORT $LL193@init
	mov	ecx, DWORD PTR $T3[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 523  :     line_handle = new kd_vlift_line[required_line_buffers];

	jmp	SHORT $LN142@init
$LN141@init:
	xor	ecx, ecx
$LN142@init:
	mov	DWORD PTR [esi+180], ecx
$LN114@init:

; 524  :   for (free_lines=NULL, n=0; n < required_line_buffers; n++)

	mov	DWORD PTR [esi+40], 0
	test	eax, eax
	jle	$LN38@init
	mov	edx, DWORD PTR _buf_width$1$[ebp]
	mov	eax, edi
	sub	eax, edx
	xor	edi, edi
	mov	DWORD PTR tv4307[ebp], eax
	npad	8
$LL39@init:

; 525  :     {
; 526  :       if (line_handle == NULL)

	mov	ecx, DWORD PTR [esi+180]

; 527  :         { line_store[n].next = free_lines;  free_lines = line_store + n; }

	mov	eax, DWORD PTR [esi+40]
	test	ecx, ecx
	jne	SHORT $LN115@init
	lea	ecx, DWORD PTR [edi+296]
	add	ecx, esi
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [esi+40], ecx

; 528  :       else

	jmp	SHORT $LN116@init
$LN115@init:

; 529  :         { line_handle[n].next = free_lines; free_lines = line_handle + n; }

	mov	DWORD PTR [ecx+edi+24], eax
	mov	eax, DWORD PTR [esi+180]
	add	eax, edi
	mov	DWORD PTR [esi+40], eax
$LN116@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 75   :         cosets[0].pre_create(allocator,even_width,absolute,use_shorts,

	push	DWORD PTR tv4307[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 530  :       free_lines->pre_create(allocator,buf_width[0],buf_width[1],reversible,

	mov	al, BYTE PTR [esi+23]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 75   :         cosets[0].pre_create(allocator,even_width,absolute,use_shorts,

	push	DWORD PTR _buf_neg_extent$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 530  :       free_lines->pre_create(allocator,buf_width[0],buf_width[1],reversible,

	mov	BYTE PTR _both_cosets$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 75   :         cosets[0].pre_create(allocator,even_width,absolute,use_shorts,

	push	DWORD PTR _use_shorts$GSCopy$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 530  :       free_lines->pre_create(allocator,buf_width[0],buf_width[1],reversible,

	mov	al, BYTE PTR [esi+20]
	mov	BYTE PTR _absolute$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 75   :         cosets[0].pre_create(allocator,even_width,absolute,use_shorts,

	push	DWORD PTR _absolute$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 530  :       free_lines->pre_create(allocator,buf_width[0],buf_width[1],reversible,

	mov	eax, DWORD PTR [esi+40]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 75   :         cosets[0].pre_create(allocator,even_width,absolute,use_shorts,

	mov	ecx, eax
	push	edx
	push	DWORD PTR _allocator$GSCopy$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 530  :       free_lines->pre_create(allocator,buf_width[0],buf_width[1],reversible,

	mov	DWORD PTR _this$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 75   :         cosets[0].pre_create(allocator,even_width,absolute,use_shorts,

	call	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create

; 76   :                              neg_extent,pos_extent-even_width);
; 77   :         if (both_cosets)

	cmp	BYTE PTR _both_cosets$1$[ebp], 0
	je	SHORT $LN37@init

; 78   :           cosets[1].pre_create(allocator,odd_width,absolute,use_shorts,

	mov	ecx, DWORD PTR _buf_width$2$[ebp]
	mov	eax, DWORD PTR _buf_pos_extent$2$[ebp]
	sub	eax, ecx
	push	eax
	push	DWORD PTR _buf_neg_extent$2$[ebp]
	push	DWORD PTR _use_shorts$GSCopy$[ebp]
	push	DWORD PTR _absolute$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	DWORD PTR _allocator$GSCopy$1$[ebp]
	add	ecx, 12					; 0000000cH
	call	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create
$LN37@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 524  :   for (free_lines=NULL, n=0; n < required_line_buffers; n++)

	mov	edx, DWORD PTR _buf_width$1$[ebp]
	add	edi, 28					; 0000001cH
	sub	DWORD PTR _required_line_buffers$1$[ebp], 1
	jne	$LL39@init
$LN38@init:

; 531  :                              use_shorts,buf_neg_extent,buf_pos_extent,
; 532  :                              hor_xform_exists);
; 533  :     }
; 534  : 
; 535  :   // Set up vertical counters and queues
; 536  :   y_next_out = y_min_out;

	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [esi+72], eax

; 537  :   y_next_in[0] = y_min_in[0];  y_next_in[1] = y_min_in[1];

	mov	eax, DWORD PTR [esi+80]
	mov	edi, DWORD PTR [esi+84]
	mov	DWORD PTR [esi+88], eax
	mov	DWORD PTR [esi+92], edi

; 538  :   if (queues != NULL)

	cmp	DWORD PTR [esi+60], 0
	je	$LN41@init

; 539  :     { // Figure out reflection bounds
; 540  :       int y_min = (y_min_in[0] < y_min_in[1])?y_min_in[0]:y_min_in[1];
; 541  :       int y_max = (y_max_in[0] > y_max_in[1])?y_max_in[0]:y_max_in[1];

	mov	ecx, DWORD PTR [esi+100]
	cmp	eax, edi
	cmovl	edi, eax
	cmp	DWORD PTR [esi+96], ecx
	mov	DWORD PTR _y_min$1$[ebp], edi
	cmovg	ecx, DWORD PTR [esi+96]

; 542  :       for (s=-1; s < num_vert_steps; s++)

	or	edx, -1
	mov	DWORD PTR _y_max$1$[ebp], ecx
	mov	DWORD PTR _s$5$[ebp], edx
	cmp	DWORD PTR [esi+24], edx
	jle	$LN41@init
	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR tv4293[ebp], -40		; ffffffd8H
	mov	DWORD PTR tv4321[ebp], eax
	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR tv4319[ebp], eax
	mov	DWORD PTR tv4292[ebp], -20		; ffffffecH
$LL42@init:

; 543  :         {
; 544  :           int local_y_min = (y_min_in[s&1] > (y_min+1))?(y_min_in[s&1]):y_min;

	mov	ecx, edx
	mov	edx, edi
	and	ecx, 1
	mov	eax, DWORD PTR [esi+ecx*4+80]
	cmp	eax, DWORD PTR tv4321[ebp]
	cmovg	edx, eax

; 545  :           int local_y_max = (y_max_in[s&1] < (y_max-1))?(y_max_in[s&1]):y_max;

	mov	eax, DWORD PTR [esi+ecx*4+96]
	cmp	eax, DWORD PTR tv4319[ebp]

; 546  :           int max_source_request_idx = local_y_max - ((local_y_max ^ s) & 1);

	mov	ecx, DWORD PTR _s$5$[ebp]
	mov	DWORD PTR _local_y_min$1$[ebp], edx
	mov	edx, DWORD PTR _y_max$1$[ebp]
	cmovl	edx, eax
	mov	DWORD PTR tv4192[ebp], eax
	mov	eax, edx
	mov	DWORD PTR _local_y_max$1$[ebp], edx
	xor	eax, ecx
	mov	edi, edx
	and	eax, 1
	sub	edi, eax

; 547  :           if (s >= 0)

	test	ecx, ecx
	js	SHORT $LN118@init

; 548  :             max_source_request_idx = y_max_in[s & 1] +

	mov	eax, DWORD PTR [esi+44]
	mov	edi, DWORD PTR tv4292[ebp]
	movsx	ecx, WORD PTR [edi+eax+4]
	movzx	edi, BYTE PTR [edi+eax+1]
	mov	eax, DWORD PTR tv4192[ebp]
	add	edi, ecx
	sub	eax, 2
	lea	edi, DWORD PTR [eax+edi*2]
$LN118@init:

; 549  :               2*(vert_steps[s].support_min - 1 +
; 550  :                  (int) vert_steps[s].support_length);
; 551  :           queues[s].init(local_y_min,local_y_max,s,vert_symmetric_extension,

	mov	ecx, DWORD PTR [esi+60]
	mov	al, BYTE PTR [esi+54]
	add	ecx, DWORD PTR tv4293[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 125  :         this->y_min = y_min;  this->y_max = y_max;

	mov	esi, DWORD PTR _local_y_min$1$[ebp]
	mov	edx, DWORD PTR _s$5$[ebp]
	mov	DWORD PTR [ecx], esi

; 126  :         head_idx = source_pos = update_pos = y_min - 1000; // Ridiculous value

	add	esi, -1000				; fffffc18H
	mov	BYTE PTR [ecx+37], dl
	mov	edx, DWORD PTR _local_y_max$1$[ebp]
	mov	DWORD PTR [ecx+28], esi
	mov	DWORD PTR [ecx+24], esi
	mov	DWORD PTR [ecx+16], esi

; 127  :         this->symmetric_extension = symmetric_extension;
; 128  :         if ((!symmetric_extension) || (max_source_request_idx < y_max))

	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	BYTE PTR [ecx+36], al
	test	al, al
	je	SHORT $LN212@init
	cmp	edi, edx
	jl	SHORT $LN212@init

; 130  :         else
; 131  :           recycling_lim = 2*y_max - max_source_request_idx;

	lea	eax, DWORD PTR [edx+edx]
	sub	eax, edi
	jmp	SHORT $LN371@init
$LN212@init:

; 129  :           recycling_lim = y_max - 1; // Keep last row only

	lea	eax, DWORD PTR [edx-1]
$LN371@init:

; 132  :         if (queue_idx < 0)

	cmp	DWORD PTR _s$5$[ebp], 0
	mov	DWORD PTR [ecx+32], eax
	jge	SHORT $LN213@init

; 133  :           source_pos = recycling_lim = y_max+2; // Block use of `access_source'

	lea	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+24], eax
$LN213@init:

; 134  :         tail_idx = head_idx - 2;

	mov	eax, DWORD PTR _local_y_min$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 553  :           if ((s >= 0) && (vert_steps[s].support_length <= 0))

	mov	edx, DWORD PTR _s$5$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 134  :         tail_idx = head_idx - 2;

	add	eax, -1002				; fffffc16H
	mov	DWORD PTR [ecx+20], eax

; 135  :         head = tail = NULL;

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 553  :           if ((s >= 0) && (vert_steps[s].support_length <= 0))

	test	edx, edx
	js	SHORT $LN40@init
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR tv4292[ebp]
	cmp	BYTE PTR [ecx+eax+1], 0
	ja	SHORT $LN40@init

; 554  :             queues[s].source_done();

	mov	ecx, DWORD PTR [esi+60]
	add	ecx, DWORD PTR tv4293[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 145  :         source_pos = recycling_lim = y_max + 2;

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 2
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+24], eax
$LN40@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 542  :       for (s=-1; s < num_vert_steps; s++)

	add	DWORD PTR tv4292[ebp], 20		; 00000014H
	inc	edx
	add	DWORD PTR tv4293[ebp], 40		; 00000028H
	mov	edi, DWORD PTR _y_min$1$[ebp]
	mov	DWORD PTR _s$5$[ebp], edx
	cmp	edx, DWORD PTR [esi+24]
	jl	$LL42@init
$LN41@init:

; 555  :         }
; 556  :     }
; 557  :   for (s=0; s < num_vert_steps; s++)

	xor	edi, edi
	cmp	DWORD PTR [esi+24], edi
	jle	SHORT $LN44@init
	npad	5
$LL45@init:

; 558  :     step_next_row_pos[s] = y_min_in[1-(s&1)];

	mov	ecx, DWORD PTR [esi+64]
	mov	eax, edi
	and	eax, 1
	mov	edx, 21					; 00000015H
	sub	edx, eax
	mov	eax, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+edi*4], eax
	inc	edi
	cmp	edi, DWORD PTR [esi+24]
	jl	SHORT $LL45@init
$LN44@init:

; 559  : 
; 560  :   // Now determine the normalizing downshift and subband nominal ranges.
; 561  :   float child_ranges[4] =
; 562  :     {normalization, normalization, normalization, normalization};
; 563  :   normalizing_upshift = 0;
; 564  :   if (!reversible)

	cmp	BYTE PTR [esi+20], 0
	movss	xmm0, DWORD PTR _normalization$[ebp]
	movaps	xmm1, xmm0
	movss	DWORD PTR _child_ranges$[ebp+4], xmm0
	movss	DWORD PTR _child_ranges$[ebp], xmm1
	movss	DWORD PTR _child_ranges$[ebp+8], xmm1
	movss	DWORD PTR _child_ranges$[ebp+12], xmm0
	mov	DWORD PTR [esi+56], 0
	jne	$LN53@init

; 565  :     {
; 566  :       int ns;
; 567  :       const float *vert_bibo_gains = node.get_bibo_gains(ns,true);

	push	1
	lea	eax, DWORD PTR _ns$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?get_bibo_gains@kdu_node@@QAEPBMAAH_N@Z	; kdu_node::get_bibo_gains
	mov	edi, eax

; 568  :       assert(ns == num_vert_steps);
; 569  :       const float *hor_bibo_gains = node.get_bibo_gains(ns,false);

	lea	ecx, DWORD PTR _node$[ebp]
	push	0
	lea	eax, DWORD PTR _ns$2[ebp]
	mov	DWORD PTR _vert_bibo_gains$1$[ebp], edi
	push	eax
	call	?get_bibo_gains@kdu_node@@QAEPBMAAH_N@Z	; kdu_node::get_bibo_gains

; 570  :       assert(ns == num_hor_steps);
; 571  : 
; 572  :       float bibo_max = normalization; // Not a true BIBO gain; this value just

	movss	xmm4, DWORD PTR _normalization$[ebp]
	mov	edx, eax

; 573  :                                        // means leave normalization alone.
; 574  : 
; 575  :       // Find BIBO gains from vertical analysis steps (these are done first)
; 576  :       if ((num_vert_steps > 0) && !unit_height)

	mov	eax, DWORD PTR [esi+24]
	movaps	xmm2, xmm4
	movsd	xmm6, QWORD PTR __real@4000000000000000

; 577  :         {
; 578  :           child_ranges[LL_BAND] /= vert_low_gain;

	movaps	xmm3, xmm4
	mov	DWORD PTR _hor_bibo_gains$1$[ebp], edx

; 579  :           child_ranges[HL_BAND] /= vert_low_gain;
; 580  :           child_ranges[LH_BAND] /= vert_high_gain;

	movaps	xmm5, xmm4
	test	eax, eax
	jle	$LN47@init

; 573  :                                        // means leave normalization alone.
; 574  : 
; 575  :       // Find BIBO gains from vertical analysis steps (these are done first)
; 576  :       if ((num_vert_steps > 0) && !unit_height)

	cmp	BYTE PTR [esi+163], 0
	jne	$LN47@init

; 581  :           child_ranges[HH_BAND] /= vert_high_gain;
; 582  : 
; 583  :           float bibo_prev, bibo_in, bibo_out;
; 584  : 
; 585  :           // Find cumulative horizontal gain to input of node.
; 586  :           bibo_prev = hor_bibo_gains[0] * normalization;

	movss	xmm7, DWORD PTR [edx]
	mulss	xmm7, xmm4
	divss	xmm3, DWORD PTR _vert_low_gain$[ebp]

; 587  :           for (bibo_in=bibo_prev, n=0; n < num_vert_steps; n++,

	movaps	xmm0, xmm7
	movss	DWORD PTR _child_ranges$[ebp], xmm3
	movss	DWORD PTR _child_ranges$[ebp+4], xmm3
	divss	xmm5, DWORD PTR _vert_high_gain$[ebp]
	movss	DWORD PTR _child_ranges$[ebp+8], xmm5
	movss	DWORD PTR _child_ranges$[ebp+12], xmm5
	test	eax, eax
	jle	SHORT $LN47@init

; 593  :               if (use_shorts && vert_steps[n].add_shorts_first)

	lea	edx, DWORD PTR [edi+4]
	xor	ecx, ecx
	mov	edi, eax
$LL48@init:

; 588  :                bibo_in=bibo_out)
; 589  :             {
; 590  :               bibo_out = bibo_prev * vert_bibo_gains[n+1];

	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR [edx]

; 591  :               if (bibo_out > bibo_max)

	comiss	xmm1, xmm2
	jbe	SHORT $LN122@init

; 592  :                 bibo_max = bibo_out; // Fit representation to lifting outputs

	movaps	xmm2, xmm1
$LN122@init:

; 593  :               if (use_shorts && vert_steps[n].add_shorts_first)

	cmp	BYTE PTR _use_shorts$GSCopy$1$[ebp], 0
	je	SHORT $LN46@init
	mov	eax, DWORD PTR [esi+44]
	cmp	BYTE PTR [ecx+eax+16], 0
	je	SHORT $LN46@init

; 594  :                 {
; 595  :                   bibo_in *= 2.0; // Avoid overflow during pre-accumulation

	cvtss2sd xmm0, xmm0
	mulsd	xmm0, xmm6
	cvtsd2ss xmm0, xmm0

; 596  :                   if (bibo_in > bibo_max)

	comiss	xmm0, xmm2
	jbe	SHORT $LN46@init

; 597  :                     bibo_max = bibo_in;

	movaps	xmm2, xmm0
$LN46@init:

; 587  :           for (bibo_in=bibo_prev, n=0; n < num_vert_steps; n++,

	add	edx, 4
	add	ecx, 20					; 00000014H
	movaps	xmm0, xmm1
	sub	edi, 1
	jne	SHORT $LL48@init
	mov	eax, DWORD PTR [esi+24]
	mov	edx, DWORD PTR _hor_bibo_gains$1$[ebp]
$LN47@init:

; 598  :                 }
; 599  :             }
; 600  :         }
; 601  : 
; 602  :       // Find BIBO gains from horizonal analysis steps
; 603  :       if ((num_hor_steps > 0) && !unit_width)

	mov	edi, DWORD PTR [esi+28]
	test	edi, edi
	jle	$LN50@init
	cmp	BYTE PTR [esi+164], 0
	jne	$LN50@init

; 604  :         {
; 605  :           child_ranges[LL_BAND] /= hor_low_gain;
; 606  :           child_ranges[HL_BAND] /= hor_high_gain;

	movss	xmm0, DWORD PTR _hor_high_gain$[ebp]

; 607  :           child_ranges[LH_BAND] /= hor_low_gain;
; 608  :           child_ranges[HH_BAND] /= hor_high_gain;

	movss	xmm1, DWORD PTR _child_ranges$[ebp+12]

; 609  : 
; 610  :           float bibo_prev, bibo_in, bibo_out;
; 611  : 
; 612  :           // Find maximum gain at output of vertical decomposition, if any
; 613  :           bibo_prev = vert_bibo_gains[num_vert_steps];

	mov	ecx, DWORD PTR _vert_bibo_gains$1$[ebp]
	divss	xmm3, DWORD PTR _hor_low_gain$[ebp]
	divss	xmm5, DWORD PTR _hor_low_gain$[ebp]
	movss	DWORD PTR _child_ranges$[ebp], xmm3
	movss	xmm3, DWORD PTR _child_ranges$[ebp+4]
	movss	DWORD PTR _child_ranges$[ebp+8], xmm5
	divss	xmm3, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR _child_ranges$[ebp+4], xmm3
	movss	xmm3, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR _child_ranges$[ebp+12], xmm1

; 614  :           if ((num_vert_steps > 0) &&

	test	eax, eax
	jle	SHORT $LN126@init
	movss	xmm0, DWORD PTR [ecx+eax*4-4]
	comiss	xmm0, xmm3
	jbe	SHORT $LN126@init

; 615  :               (vert_bibo_gains[num_vert_steps-1] > bibo_prev))
; 616  :             bibo_prev = vert_bibo_gains[num_vert_steps-1];

	movaps	xmm3, xmm0
$LN126@init:

; 617  :           bibo_prev *= normalization; // Account for fact that gains reported

	mulss	xmm3, xmm4

; 618  :                    // by `kdu_node::get_bibo_gains' assume `normalization'=1
; 619  : 
; 620  :           for (bibo_in=bibo_prev, n=0; n < num_hor_steps; n++,

	movaps	xmm0, xmm3
	test	edi, edi
	jle	SHORT $LN50@init

; 626  :               if (use_shorts && hor_steps[n].add_shorts_first)

	xor	ecx, ecx
	add	edx, 4
	npad	2
$LL51@init:

; 621  :                bibo_in=bibo_out)
; 622  :             {
; 623  :               bibo_out = bibo_prev * hor_bibo_gains[n+1];

	movss	xmm1, DWORD PTR [edx]
	mulss	xmm1, xmm3

; 624  :               if (bibo_out > bibo_max)

	comiss	xmm1, xmm2
	jbe	SHORT $LN127@init

; 625  :                 bibo_max = bibo_out; // Fit representation to lifting outputs

	movaps	xmm2, xmm1
$LN127@init:

; 626  :               if (use_shorts && hor_steps[n].add_shorts_first)

	cmp	BYTE PTR _use_shorts$GSCopy$1$[ebp], 0
	je	SHORT $LN49@init
	mov	eax, DWORD PTR [esi+48]
	cmp	BYTE PTR [ecx+eax+16], 0
	je	SHORT $LN49@init

; 627  :                 {
; 628  :                   bibo_in *= 2.0; // Avoid overflow during pre-accumulation

	cvtps2pd xmm0, xmm0
	mulsd	xmm0, xmm6
	cvtpd2ps xmm0, xmm0

; 629  :                   if (bibo_in > bibo_max)

	comiss	xmm0, xmm2
	jbe	SHORT $LN49@init

; 630  :                     bibo_max = bibo_in;

	movaps	xmm2, xmm0
$LN49@init:

; 618  :                    // by `kdu_node::get_bibo_gains' assume `normalization'=1
; 619  : 
; 620  :           for (bibo_in=bibo_prev, n=0; n < num_hor_steps; n++,

	add	edx, 4
	add	ecx, 20					; 00000014H
	movaps	xmm0, xmm1
	sub	edi, 1
	jne	SHORT $LL51@init
$LN50@init:

; 631  :                 }
; 632  :             }
; 633  :         }
; 634  : 
; 635  :       if (use_shorts)

	cmp	BYTE PTR _use_shorts$GSCopy$1$[ebp], 0
	je	SHORT $LN53@init

; 636  :         {
; 637  :           float overflow_limit = 1.0F * (float)(1<<(16-KDU_FIX_POINT));
; 638  :           // This is the largest numeric range which can be represented in
; 639  :           // our signed 16-bit fixed-point representation without overflow.
; 640  :           while (bibo_max > 0.95*overflow_limit)

	movsd	xmm3, QWORD PTR __real@401e666666666666
	xorps	xmm0, xmm0
	cvtss2sd xmm0, xmm2
	comisd	xmm0, xmm3
	jbe	SHORT $LN53@init
	movaps	xmm4, XMMWORD PTR __xmm@3f0000003f0000003f0000003f000000
	mov	eax, DWORD PTR [esi+56]
	movups	xmm1, XMMWORD PTR _child_ranges$[ebp]
	movsd	xmm5, QWORD PTR __real@3fe0000000000000
$LL52@init:

; 641  :             { // Leave a little extra headroom to allow for approximations in
; 642  :               // the numerical BIBO gain calculations.
; 643  :               normalizing_upshift++;
; 644  :               for (int b=0; b < 4; b++)
; 645  :                 child_ranges[b] *= 0.5F;

	xorps	xmm0, xmm0
	mulps	xmm1, xmm4
	inc	eax

; 646  :               bibo_max *= 0.5;

	cvtss2sd xmm0, xmm2
	movups	XMMWORD PTR _child_ranges$[ebp], xmm1
	mulsd	xmm0, xmm5
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm2
	comisd	xmm0, xmm3
	ja	SHORT $LL52@init
	mov	DWORD PTR [esi+56], eax
$LN53@init:

; 652  :   for (n=0; n < 4; n++)

	lea	eax, DWORD PTR [esi+4]
	xor	edi, edi
	mov	DWORD PTR tv4280[ebp], eax
	npad	3
$LL59@init:
	lea	ecx, DWORD PTR _child$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4994 :     bool operator!() { return (state==NULL)?true:false; }

	cmp	DWORD PTR [ecx+edi*4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 652  :   for (n=0; n < 4; n++)

	lea	ecx, DWORD PTR [ecx+edi*4]

; 653  :     {
; 654  :       if (!child[n])

	je	$LN57@init

; 655  :         continue;
; 656  :       int child_offset = request_offset[n & 1];

	mov	eax, edi
	and	eax, 1

; 657  :       if (!child[n].access_child(LL_BAND))

	push	0
	movzx	eax, BYTE PTR [eax+esi+126]
	mov	DWORD PTR _child_offset$1$[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?access_child@kdu_node@@QAE?AV1@H@Z	; kdu_node::access_child
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4994 :     bool operator!() { return (state==NULL)?true:false; }

	cmp	DWORD PTR [eax], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 657  :       if (!child[n].access_child(LL_BAND))

	jne	SHORT $LN132@init

; 658  :         subbands[n] = kdu_decoder(child[n].access_subband(),allocator,

	lea	eax, DWORD PTR $T6[ebp]
	lea	ecx, DWORD PTR _child$[ebp]
	push	eax
	lea	ecx, DWORD PTR [ecx+edi*4]
	call	?access_subband@kdu_node@@QAE?AVkdu_subband@@XZ ; kdu_node::access_subband
	push	DWORD PTR _env_queue$GSCopy$1$[ebp]
	movss	xmm0, DWORD PTR _child_ranges$[ebp+edi*4]
	push	DWORD PTR _env$GSCopy$1$[ebp]
	push	DWORD PTR _child_offset$1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T14[ebp]
	push	DWORD PTR _use_shorts$GSCopy$[ebp]
	push	DWORD PTR _allocator$GSCopy$1$[ebp]
	push	DWORD PTR [eax]
	call	??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_decoder::kdu_decoder

; 659  :                                   use_shorts,child_ranges[n],child_offset,
; 660  :                                   env,env_queue);
; 661  :       else

	jmp	SHORT $LN372@init
$LN132@init:

; 662  :         subbands[n] = kdu_synthesis(child[n],allocator,use_shorts,

	push	DWORD PTR _env_queue$GSCopy$1$[ebp]
	movss	xmm0, DWORD PTR _child_ranges$[ebp+edi*4]
	lea	eax, DWORD PTR _child$[ebp]
	push	DWORD PTR _env$GSCopy$1$[ebp]
	lea	eax, DWORD PTR [eax+edi*4]
	push	DWORD PTR _child_offset$1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T12[ebp]
	push	DWORD PTR _use_shorts$GSCopy$[ebp]
	push	DWORD PTR _allocator$GSCopy$1$[ebp]
	push	DWORD PTR [eax]
	call	??0kdu_synthesis@@QAE@Vkdu_node@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_synthesis::kdu_synthesis
$LN372@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 2053 :   { state = rhs.state; return *this; }

	mov	ecx, DWORD PTR tv4280[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
$LN57@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 652  :   for (n=0; n < 4; n++)

	inc	edi
	add	eax, 4
	mov	DWORD PTR tv4280[ebp], eax
	cmp	edi, 4
	jl	$LL59@init
$LN58@init:

; 663  :                                     child_ranges[n],child_offset,
; 664  :                                     env,env_queue);
; 665  :     }
; 666  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?init@kd_synthesis@@QAEXVkdu_node@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ENDP ; kd_synthesis::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis_local.h
;	COMDAT ??0kd_synthesis@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0kd_synthesis@@QAE@XZ PROC				; kd_synthesis::kd_synthesis, COMDAT
; _this$ = ecx

; 69   :     kd_synthesis()

	push	ebp
	mov	ebp, esp
	push	ecx

; 70   :       {

	mov	DWORD PTR [ecx], OFFSET ??_7kd_synthesis@@6B@

; 77   :     void init(kdu_node node, kdu_sample_allocator *allocator,
; 78   :               bool use_shorts, float normalization, int pull_offset,
; 79   :               kdu_thread_env *env, kdu_thread_queue *env_queue);
; 80   :   protected: // These functions implement their namesakes in the base class
; 81   :     virtual ~kd_synthesis();
; 82   :     virtual void start(kdu_thread_env *env);
; 83   :     virtual void pull(kdu_line_buf &line, kdu_thread_env *env);
; 84   :   protected: // Internal implementation functions
; 85   :     int simulate_vertical_lifting(int support_max);
; 86   :       /* See the corresponding function in `kd_analysis'. */
; 87   :     void perform_vertical_lifting_step(kd_lifting_step *step,
; 88   :                                        kdu_sample16 **src_ptrs,
; 89   :                                        kd_vlift_line *vline_in,
; 90   :                                        kd_vlift_line *vline_out);
; 91   :       /* This function implements a single vertical lifting step, using
; 92   :          16-bit sample values.  Each line consists of up to two cosets,
; 93   :          whose dimensions and offsets are maintained in `coset_width_out'
; 94   :          and `coset_off_out', respectively.  The cosets of each source
; 95   :          line may be found in the `vert_source_vlines' buffer.  The `src_ptrs'
; 96   :          buffer has the same dimension and is used by the function to
; 97   :          temporarily record pointers to the actual source lines associated
; 98   :          with any given coset. */
; 99   :     void perform_vertical_lifting_step(kd_lifting_step *step,
; 100  :                                        kdu_sample32 **src_ptrs,
; 101  :                                        kd_vlift_line *vline_in,
; 102  :                                        kd_vlift_line *vline_out);
; 103  :       /* Same as the first form of the function, except for working with
; 104  :          32-bit sample values. */
; 105  :     void horizontal_synthesis(kd_vlift_line *line, int vert_parity,
; 106  :                               kdu_thread_env *env);
; 107  :       /* Performs horizontal synthesis, pulling source subband lines from
; 108  :          their respective subband interfaces.  Uses `vert_parity' to
; 109  :          determine whether the line belongs to a vertically low- or
; 110  :          high-pass subband.  If horizontal decomposition is not involved,
; 111  :          this function simply retrieves the required line directly from
; 112  :          the relevant subband interface. */
; 113  :   protected: // Data
; 114  :     kdu_pull_ifc subbands[4]; // Interfaces for acquiring subband samples
; 115  :     bool reversible;
; 116  :     bool initialized; // True after the first `pull' call.
; 117  :     bool vert_xform_exists; // True if vert splitting performed at this node
; 118  :     bool hor_xform_exists; // True if horiz. splitting performed at this node
; 119  :     int num_vert_steps; // Number of lifting steps in the vertical direction
; 120  :     int num_hor_steps; // Number of lifting steps in the horizontal direction
; 121  :     kd_vlift_line **vert_source_vlines; // Sized for max vertical step support
; 122  :     void **vert_source_bufs; // Sized for max vertical step support
; 123  :     kd_vlift_line *free_lines; // Head of free list used by `queues'
; 124  :     kd_lifting_step *vert_steps; // `num_vert_steps' entries
; 125  :     kd_lifting_step *hor_steps; // `num_hor_steps' entries
; 126  :     bool vert_symmetric; // If vertical kernel belongs to WS symmetric class
; 127  :     bool hor_symmetric; // If horizontal kernel belongs to WS symmetric class
; 128  :     bool vert_symmetric_extension; // If false, vert extension is 0-order hold
; 129  :     bool hor_symmetric_extension; // If false, hor extension is 0-order hold
; 130  :     int normalizing_upshift; // Amount to post-shift irreversible outputs.
; 131  :     kd_vlift_queue *queues; // valid indices run from -1 to `num_vert_steps'-1
; 132  :     int *step_next_row_pos; // Holds `num_vert_steps' entries
; 133  :     int y_min_out, y_next_out, y_max_out;
; 134  :     int y_min_in[2], y_next_in[2], y_max_in[2]; // One for each subband
; 135  :     int x_min_buf; // Coordinate associated with start of all internal buffers
; 136  :     int x_min_in; // Coordinate of first nominal input sample for hor. lifting
; 137  :     int x_max_in; // Coordinate of last nominal input sample for hor. lifting
; 138  :     int coset_width_in[2]; // From `x_min_in' to `x_max_in', in coset domain
; 139  :     kdu_byte coset_off_in[2]; // From `x_min_buf' to `x_min_in' in coset domain
; 140  :     kdu_byte request_offset[2]; // Offset supplied when requesting subband data
; 141  :     int request_width[2]; // Number of samples pulled from subbands
; 142  :     kdu_byte left_fill[2]; // See below
; 143  :     kdu_byte right_fill[2]; // See below
; 144  :     int x_min_out; // Coordinate of first required output sample
; 145  :     int x_max_out; // Coordinate of last required output sample
; 146  :     int coset_width_out[2]; // From `x_min_out' to `x_max_out', in coset domain
; 147  :     int x_min_pull; // Coordinate associated with start of line in `pull' calls
; 148  :     kdu_byte coset_off_out[2]; // `x_min_buf' to `x_min_out' in coset domain
; 149  :     bool use_shorts; // All `pull' calls will request 16-bit samples
; 150  :     bool unit_height;
; 151  :     bool unit_width;
; 152  :     bool empty;
; 153  :   private: // Handles to dynamically allocated arrays
; 154  :     float *coeff_handle; // Array from which step `coeffs' arrays are allocated
; 155  :     int *icoeff_handle; // Array from which step `icoeffs' arrays are allocated
; 156  :     void **source_buf_handle; // Handle to array holding source buf/vline ptrs
; 157  :     kd_vlift_line *line_handle; // Handle to array of allocated line buffers
; 158  :     kd_lifting_step *vert_step_handle; // Handle to array containing vert steps
; 159  :     kd_lifting_step *hor_step_handle; // Handle to array containing horiz steps
; 160  :     kd_vlift_queue *queue_handle; // Handle to array of step input queues
; 161  :     int *next_row_pos_handle; // Used to allocate `step_next_row_pos'

	lea	eax, DWORD PTR [ecx+296]
	mov	DWORD PTR _this$[ebp], ecx
	mov	edx, 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 696  :     kdu_pull_ifc() { state = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	npad	12
$LL14@kd_synthes:

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax+28]
	mov	WORD PTR [eax-22], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [eax-20], 0
	mov	DWORD PTR [eax-16], 0
	mov	WORD PTR [eax-10], 0
	mov	DWORD PTR [eax-8], 0
	sub	edx, 1
	jne	SHORT $LL14@kd_synthes
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis_local.h

; 71   :         vert_source_vlines=NULL; vert_source_bufs=NULL;

	mov	DWORD PTR [ecx+32], edx

; 72   :         free_lines=NULL; vert_steps=hor_steps=NULL; queues=NULL;
; 73   :         coeff_handle=NULL; icoeff_handle=NULL; source_buf_handle=NULL;
; 74   :         line_handle=NULL; vert_step_handle=hor_step_handle=NULL;
; 75   :         queue_handle=NULL; next_row_pos_handle=NULL;
; 76   :       }

	mov	eax, ecx
	mov	DWORD PTR [ecx+36], edx
	mov	DWORD PTR [ecx+40], edx
	mov	DWORD PTR [ecx+48], edx
	mov	DWORD PTR [ecx+44], edx
	mov	DWORD PTR [ecx+60], edx
	mov	DWORD PTR [ecx+168], edx
	mov	DWORD PTR [ecx+172], edx
	mov	DWORD PTR [ecx+176], edx
	mov	DWORD PTR [ecx+180], edx
	mov	DWORD PTR [ecx+188], edx
	mov	DWORD PTR [ecx+184], edx
	mov	DWORD PTR [ecx+192], edx
	mov	DWORD PTR [ecx+196], edx
	mov	esp, ebp
	pop	ebp
	ret	0
??0kd_synthesis@@QAE@XZ ENDP				; kd_synthesis::kd_synthesis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
;	COMDAT ?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z
_TEXT	SEGMENT
_i_lambda$1$ = -56					; size = 4
tv3501 = -56						; size = 4
tv3463 = -56						; size = 4
tv3456 = -56						; size = 4
tv3454 = -56						; size = 4
tv3477 = -52						; size = 4
tv3461 = -52						; size = 4
_in$1$ = -52						; size = 4
_downshift$1$ = -48					; size = 4
tv3481 = -48						; size = 4
tv3457 = -48						; size = 4
tv3485 = -44						; size = 4
tv3476 = -44						; size = 4
tv3500 = -40						; size = 4
tv3491 = -40						; size = 4
tv3489 = -36						; size = 4
_sum$1$ = -32						; size = 4
tv3492 = -32						; size = 4
_offset$1$ = -28					; size = 4
tv3493 = -28						; size = 4
_fpp$1$ = -24						; size = 4
tv3494 = -24						; size = 4
_support$1$ = -20					; size = 4
_sp$1$ = -20						; size = 4
_downshift$1$ = -20					; size = 4
tv3487 = -20						; size = 4
tv3472 = -16						; size = 4
tv3467 = -16						; size = 4
tv3465 = -16						; size = 4
_out$1$ = -16						; size = 4
$T1 = -12						; size = 4
_t$1$ = -12						; size = 4
_sp2$1$ = -12						; size = 4
$T2 = -8						; size = 4
_k$2$ = -8						; size = 4
_sp1$1$ = -8						; size = 4
tv3507 = -1						; size = 1
_step$ = 8						; size = 4
_src_ptrs$ = 12						; size = 4
_in$ = 16						; size = 4
_out$ = 20						; size = 4
_offset$1$ = 24						; size = 4
_width$ = 24						; size = 4
_x_off$ = 28						; size = 4
?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z PROC ; perform_synthesis_lifting_step, COMDAT

; 1333 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	ebx

; 1334 :   int k;
; 1335 : 
; 1336 :   if (width <= 0)

	mov	ebx, DWORD PTR _width$[ebp]
	test	ebx, ebx
	jle	$LN23@perform_sy

; 1337 :     return;
; 1338 :   while (x_off > 4)

	mov	edx, DWORD PTR _x_off$[ebp]
	push	esi
	mov	esi, DWORD PTR _out$[ebp]
	push	edi
	mov	edi, DWORD PTR _in$[ebp]
	cmp	edx, 4
	jle	SHORT $LN96@perform_sy
	lea	ecx, DWORD PTR [edx-5]
	shr	ecx, 2
	inc	ecx
	mov	eax, ecx
	shl	ecx, 4
	neg	eax
	add	esi, ecx
	add	edi, ecx
	lea	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _x_off$[ebp], edx
$LN96@perform_sy:

; 1339 :     { x_off -= 4; in += 4; out += 4; }
; 1340 :   width += x_off;
; 1341 : 
; 1342 : #ifdef KDU_SIMD_OPTIMIZATIONS
; 1343 :   if (step->kernel_id == (kdu_byte) Ckernels_W5X3)

	mov	ecx, DWORD PTR _step$[ebp]
	add	ebx, edx
	mov	DWORD PTR _out$1$[ebp], esi
	mov	DWORD PTR _width$[ebp], ebx
	cmp	BYTE PTR [ecx+18], 1
	jne	SHORT $LN29@perform_sy

; 1344 :     {
; 1345 :       if (simd_W5X3_v_synth32(&(src_ptrs[0]->ival),&(src_ptrs[1]->ival),

	mov	eax, DWORD PTR _src_ptrs$[ebp]
	push	ecx
	push	ebx
	push	esi
	push	edi
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	?simd_W5X3_v_synth32@@YA_NPAH000HPAUkd_lifting_step@@@Z ; simd_W5X3_v_synth32
	add	esp, 24					; 00000018H

; 1346 :                               &(in->ival),&(out->ival),width,step))
; 1347 :         return;
; 1348 :     }

	jmp	SHORT $LN102@perform_sy
$LN29@perform_sy:

; 1349 :   else if (!step->reversible)

	cmp	BYTE PTR [ecx+17], 0
	jne	SHORT $LN37@perform_sy

; 1350 :     {
; 1351 :       if (step->support_length <= 2)

	mov	al, BYTE PTR [ecx+1]
	cmp	al, 2
	ja	SHORT $LN33@perform_sy

; 1352 :         {
; 1353 :           if (simd_2tap_v_irrev32(&(src_ptrs[0]->fval),

	push	1
	push	ecx
	mov	ecx, DWORD PTR _src_ptrs$[ebp]
	push	ebx
	push	esi
	movzx	eax, al
	push	edi
	push	DWORD PTR [ecx+eax*4-4]
	push	DWORD PTR [ecx]
	call	?simd_2tap_v_irrev32@@YA_NPAM000HPAUkd_lifting_step@@_N@Z ; simd_2tap_v_irrev32
	add	esp, 28					; 0000001cH

; 1354 :                                   &(src_ptrs[step->support_length-1]->fval),
; 1355 :                                   &(in->fval),&(out->fval),width,step,true))
; 1356 :             return;
; 1357 :         }

	jmp	SHORT $LN102@perform_sy
$LN33@perform_sy:

; 1358 :       else if (step->support_length <= 4)

	cmp	al, 4
	ja	SHORT $LN37@perform_sy

; 1359 :         {
; 1360 :           if (simd_4tap_v_irrev32(&(src_ptrs[0]->fval),&(src_ptrs[1]->fval),

	push	1
	push	ecx
	mov	ecx, DWORD PTR _src_ptrs$[ebp]
	push	ebx
	push	esi
	movzx	eax, al
	push	edi
	push	DWORD PTR [ecx+eax*4-4]
	push	DWORD PTR [ecx+8]
	push	DWORD PTR [ecx+4]
	push	DWORD PTR [ecx]
	call	?simd_4tap_v_irrev32@@YA_NPAM00000HPAUkd_lifting_step@@_N@Z ; simd_4tap_v_irrev32
	add	esp, 36					; 00000024H
$LN102@perform_sy:
	test	al, al
	jne	$LN99@perform_sy
	mov	edx, DWORD PTR _x_off$[ebp]
	mov	ecx, DWORD PTR _step$[ebp]
$LN37@perform_sy:

; 1361 :                                   &(src_ptrs[2]->fval),
; 1362 :                                   &(src_ptrs[step->support_length-1]->fval),
; 1363 :                                   &(in->fval),&(out->fval),width,step,true))
; 1364 :             return;
; 1365 :         }
; 1366 :     }
; 1367 : #endif // KDU_SIMD_OPTIMIZATIONS
; 1368 :   if ((step->support_length==2) && (step->coeffs[0]==step->coeffs[1]))

	mov	al, BYTE PTR [ecx+1]
	cmp	al, 2
	jne	$LN38@perform_sy
	mov	eax, DWORD PTR [ecx+8]
	movss	xmm2, DWORD PTR [eax]
	ucomiss	xmm2, DWORD PTR [eax+4]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN97@perform_sy

; 1369 :     { // Special implementation for symmetric least-dissimilar filters
; 1370 :       kdu_sample32 *sp1=src_ptrs[0], *sp2=src_ptrs[1];

	mov	ecx, DWORD PTR _src_ptrs$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR _sp1$1$[ebp], eax

; 1371 :       if (!step->reversible)

	mov	eax, DWORD PTR _step$[ebp]
	mov	DWORD PTR _sp2$1$[ebp], ecx
	cmp	BYTE PTR [eax+17], 0
	jne	$LN40@perform_sy
	cmp	edx, ebx
	jge	$LN99@perform_sy
	mov	eax, ebx
	sub	eax, edx

; 1372 :         {
; 1373 :           float lambda = step->coeffs[0];
; 1374 :           for (k=x_off; k < width; k++)

	cmp	eax, 4
	jl	$LC77@perform_sy
	lea	eax, DWORD PTR [ebx-3]
	mov	DWORD PTR tv3487[ebp], esi
	sub	DWORD PTR tv3487[ebp], ecx
	mov	DWORD PTR tv3501[ebp], eax
	lea	eax, DWORD PTR [edx+3]
	lea	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR tv3494[ebp], eax
	mov	eax, DWORD PTR _sp1$1$[ebp]
	lea	ebx, DWORD PTR [eax+8]
	lea	ebx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR tv3493[ebp], ebx
	lea	ebx, DWORD PTR [ecx+4]
	lea	ebx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR tv3492[ebp], ebx
	mov	ebx, edi
	sub	ebx, ecx
	mov	DWORD PTR tv3491[ebp], ebx
	mov	ebx, eax
	sub	ebx, ecx
	mov	ecx, edi
	sub	ecx, eax
	mov	DWORD PTR tv3489[ebp], ebx
	mov	DWORD PTR tv3485[ebp], ecx
	mov	ecx, esi
	sub	ecx, eax
	mov	eax, edi
	sub	eax, esi
	mov	DWORD PTR tv3481[ebp], ecx
	mov	esi, DWORD PTR tv3493[ebp]
	mov	ecx, DWORD PTR tv3494[ebp]
	mov	DWORD PTR tv3477[ebp], eax
	mov	eax, DWORD PTR tv3492[ebp]
	jmp	SHORT $LN78@perform_sy
	npad	12
$LL98@perform_sy:
	mov	ebx, DWORD PTR tv3489[ebp]
$LN78@perform_sy:

; 1375 :             out[k].fval = in[k].fval - lambda*(sp1[k].fval+sp2[k].fval);

	movss	xmm1, DWORD PTR [eax-4]
	addss	xmm1, DWORD PTR [esi-8]
	movss	xmm0, DWORD PTR [edi+edx*4]
	add	edx, 4
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [ecx-12], xmm0
	movss	xmm1, DWORD PTR [ebx+eax]
	addss	xmm1, DWORD PTR [eax]
	mov	ebx, DWORD PTR tv3491[ebp]
	movss	xmm0, DWORD PTR [ebx+eax]
	mov	ebx, DWORD PTR tv3487[ebp]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [ebx+eax], xmm0
	movss	xmm1, DWORD PTR [eax+4]
	addss	xmm1, DWORD PTR [esi]
	mov	ebx, DWORD PTR tv3485[ebp]
	movss	xmm0, DWORD PTR [ebx+esi]
	mov	ebx, DWORD PTR tv3481[ebp]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [ebx+esi], xmm0
	movss	xmm1, DWORD PTR [eax+8]
	add	eax, 16					; 00000010H
	addss	xmm1, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR tv3477[ebp]
	add	esi, 16					; 00000010H
	movss	xmm0, DWORD PTR [ebx+ecx]
	mov	ebx, DWORD PTR _width$[ebp]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [ecx], xmm0
	add	ecx, 16					; 00000010H
	cmp	edx, DWORD PTR tv3501[ebp]
	jl	$LL98@perform_sy
	mov	esi, DWORD PTR _out$1$[ebp]
	mov	ecx, DWORD PTR _sp2$1$[ebp]
$LC77@perform_sy:

; 1372 :         {
; 1373 :           float lambda = step->coeffs[0];
; 1374 :           for (k=x_off; k < width; k++)

	cmp	edx, ebx
	jge	$LN99@perform_sy
	sub	DWORD PTR _sp1$1$[ebp], ecx
	lea	eax, DWORD PTR [ecx+edx*4]
	sub	edi, ecx
	sub	esi, ecx
	mov	ecx, DWORD PTR _sp1$1$[ebp]
	sub	ebx, edx
	npad	12
$LC6@perform_sy:

; 1375 :             out[k].fval = in[k].fval - lambda*(sp1[k].fval+sp2[k].fval);

	movss	xmm1, DWORD PTR [eax+ecx]
	addss	xmm1, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [eax+edi]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [eax+esi], xmm0
	add	eax, 4
	sub	ebx, 1
	jne	SHORT $LC6@perform_sy
	pop	edi
	pop	esi
	pop	ebx

; 1419 :             }
; 1420 :         }
; 1421 :     }
; 1422 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@perform_sy:

; 1376 :         }
; 1377 :       else
; 1378 :         {
; 1379 :           kdu_int32 downshift = step->downshift;

	movzx	ecx, BYTE PTR [eax+2]
	mov	DWORD PTR _downshift$1$[ebp], ecx

; 1380 :           kdu_int32 offset = step->rounding_offset;

	movsx	ecx, WORD PTR [eax+6]

; 1381 :           kdu_int32 i_lambda = step->icoeffs[0];

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _offset$1$[ebp], ecx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _i_lambda$1$[ebp], eax

; 1382 :           if (i_lambda == 1)

	cmp	eax, 1
	jne	SHORT $LN42@perform_sy

; 1383 :             for (k=x_off; k < width; k++)

	cmp	edx, ebx
	jge	$LN99@perform_sy
	mov	eax, DWORD PTR _sp1$1$[ebp]
	sub	edi, DWORD PTR _sp1$1$[ebp]
	sub	esi, DWORD PTR _sp1$1$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _sp2$1$[ebp]
	sub	eax, DWORD PTR _sp1$1$[ebp]
	sub	ebx, edx
	mov	DWORD PTR tv3472[ebp], ecx
	mov	DWORD PTR _sp2$1$[ebp], eax
$LL9@perform_sy:

; 1384 :               out[k].ival = in[k].ival -

	mov	edx, DWORD PTR [eax+ecx]
	add	edx, DWORD PTR _offset$1$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sar	edx, cl
	mov	ecx, DWORD PTR tv3472[ebp]
	mov	eax, DWORD PTR [ecx+edi]
	sub	eax, edx
	mov	DWORD PTR [ecx+esi], eax
	add	ecx, 4
	mov	eax, DWORD PTR _sp2$1$[ebp]
	mov	DWORD PTR tv3472[ebp], ecx
	sub	ebx, 1
	jne	SHORT $LL9@perform_sy
	pop	edi
	pop	esi
	pop	ebx

; 1419 :             }
; 1420 :         }
; 1421 :     }
; 1422 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@perform_sy:

; 1385 :                 ((offset + sp1[k].ival + sp2[k].ival) >> downshift);
; 1386 :           else if (i_lambda == -1)

	cmp	eax, -1
	jne	SHORT $LN44@perform_sy

; 1387 :             for (k=x_off; k < width; k++)

	cmp	edx, ebx
	jge	$LN99@perform_sy
	mov	eax, DWORD PTR _sp1$1$[ebp]
	sub	edi, DWORD PTR _sp1$1$[ebp]
	sub	esi, DWORD PTR _sp1$1$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _sp2$1$[ebp]
	sub	eax, DWORD PTR _sp1$1$[ebp]
	sub	ebx, edx
	mov	DWORD PTR tv3467[ebp], ecx
	mov	DWORD PTR _sp2$1$[ebp], eax
	npad	5
$LL12@perform_sy:

; 1388 :               out[k].ival = in[k].ival -

	mov	edx, DWORD PTR _offset$1$[ebp]
	sub	edx, DWORD PTR [eax+ecx]
	sub	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sar	edx, cl
	mov	ecx, DWORD PTR tv3467[ebp]
	mov	eax, DWORD PTR [edi+ecx]
	sub	eax, edx
	mov	DWORD PTR [esi+ecx], eax
	add	ecx, 4
	mov	eax, DWORD PTR _sp2$1$[ebp]
	mov	DWORD PTR tv3467[ebp], ecx
	sub	ebx, 1
	jne	SHORT $LL12@perform_sy
	pop	edi
	pop	esi
	pop	ebx

; 1419 :             }
; 1420 :         }
; 1421 :     }
; 1422 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@perform_sy:

; 1389 :                 ((offset - sp1[k].ival - sp2[k].ival) >> downshift);
; 1390 :           else
; 1391 :             for (k=x_off; k < width; k++)

	cmp	edx, ebx
	jge	$LN99@perform_sy
	mov	eax, DWORD PTR _sp1$1$[ebp]
	sub	edi, DWORD PTR _sp1$1$[ebp]
	sub	esi, DWORD PTR _sp1$1$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _sp2$1$[ebp]
	sub	eax, DWORD PTR _sp1$1$[ebp]
	sub	ebx, edx
	mov	DWORD PTR tv3465[ebp], ecx
	mov	DWORD PTR _sp2$1$[ebp], eax
	npad	1
$LL15@perform_sy:

; 1392 :               out[k].ival = in[k].ival -

	mov	edx, DWORD PTR [eax+ecx]
	add	edx, DWORD PTR [ecx]
	imul	edx, DWORD PTR _i_lambda$1$[ebp]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	add	edx, DWORD PTR _offset$1$[ebp]
	sar	edx, cl
	mov	ecx, DWORD PTR tv3465[ebp]
	mov	eax, DWORD PTR [edi+ecx]
	sub	eax, edx
	mov	DWORD PTR [esi+ecx], eax
	add	ecx, 4
	mov	eax, DWORD PTR _sp2$1$[ebp]
	mov	DWORD PTR tv3465[ebp], ecx
	sub	ebx, 1
	jne	SHORT $LL15@perform_sy
	pop	edi
	pop	esi
	pop	ebx

; 1419 :             }
; 1420 :         }
; 1421 :     }
; 1422 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN97@perform_sy:
	mov	al, BYTE PTR [ecx+1]
$LN38@perform_sy:

; 1393 :                 ((offset + i_lambda*(sp1[k].ival+sp2[k].ival))>>downshift);
; 1394 :         }
; 1395 :     }
; 1396 :   else
; 1397 :     { // More general 32-bit processing
; 1398 :       int t;
; 1399 :       if (!step->reversible)

	cmp	BYTE PTR [ecx+17], 0
	jne	$LN46@perform_sy

; 1400 :         {
; 1401 :           for (t=0; t < step->support_length; t++, in=out)

	mov	DWORD PTR _t$1$[ebp], 0
	test	al, al
	je	$LN99@perform_sy
	npad	3
$LL18@perform_sy:

; 1402 :             {
; 1403 :               kdu_sample32 *sp = src_ptrs[t];

	mov	esi, DWORD PTR _t$1$[ebp]
	mov	eax, DWORD PTR _src_ptrs$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR _sp$1$[ebp], eax

; 1404 :               float lambda = step->coeffs[t];

	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, esi
	mov	esi, DWORD PTR _out$1$[ebp]
	movss	xmm2, DWORD PTR [eax+ecx*4]

; 1405 :               for (k=x_off; k < width; k++)

	mov	ecx, edx
	mov	DWORD PTR _k$2$[ebp], ecx
	cmp	edx, ebx
	jge	$LN16@perform_sy
	mov	eax, ebx
	sub	eax, edx
	cmp	eax, 4
	jl	$LC80@perform_sy
	lea	eax, DWORD PTR [ebx-3]
	mov	ebx, edi
	sub	ebx, DWORD PTR _sp$1$[ebp]
	mov	DWORD PTR tv3500[ebp], eax
	lea	eax, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv3461[ebp], ebx
	mov	DWORD PTR tv3463[ebp], eax
	mov	ebx, esi
	mov	eax, DWORD PTR _sp$1$[ebp]
	sub	ebx, DWORD PTR _sp$1$[ebp]
	mov	DWORD PTR tv3457[ebp], ebx
	lea	eax, DWORD PTR [eax+edx*4]
	mov	edx, edi
	add	eax, 4
	sub	edx, esi
	mov	esi, DWORD PTR tv3461[ebp]
	mov	DWORD PTR tv3476[ebp], edx
	mov	edx, DWORD PTR tv3463[ebp]
	npad	8
$LL81@perform_sy:

; 1406 :                 out[k].fval = in[k].fval - lambda*sp[k].fval;

	movss	xmm1, DWORD PTR [eax-4]
	movss	xmm0, DWORD PTR [edi+ecx*4]
	mov	ebx, DWORD PTR tv3457[ebp]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movaps	xmm1, xmm2
	movss	DWORD PTR [edx-8], xmm0
	mulss	xmm1, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [esi+eax]
	subss	xmm0, xmm1
	movss	DWORD PTR [eax+ebx], xmm0
	movss	xmm1, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR tv3476[ebp]
	mulss	xmm1, xmm2
	movss	xmm0, DWORD PTR [edx+ebx]
	mov	ebx, DWORD PTR _width$[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR [edx], xmm0
	movss	xmm1, DWORD PTR [eax+8]
	add	eax, 16					; 00000010H
	movss	xmm0, DWORD PTR [edi+ecx*4+12]
	add	ecx, 4
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [edx+4], xmm0
	add	edx, 16					; 00000010H
	cmp	ecx, DWORD PTR tv3500[ebp]
	jl	SHORT $LL81@perform_sy
	mov	edx, DWORD PTR _x_off$[ebp]
	mov	esi, DWORD PTR _out$1$[ebp]
	mov	DWORD PTR _k$2$[ebp], ecx
$LC80@perform_sy:

; 1405 :               for (k=x_off; k < width; k++)

	cmp	ecx, ebx
	jge	SHORT $LN16@perform_sy
	mov	edx, DWORD PTR _sp$1$[ebp]
	sub	edi, edx
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, esi
	sub	ecx, edx
	mov	DWORD PTR tv3456[ebp], ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR _k$2$[ebp]
	mov	edx, DWORD PTR tv3456[ebp]
	npad	11
$LC21@perform_sy:

; 1406 :                 out[k].fval = in[k].fval - lambda*sp[k].fval;

	movss	xmm1, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [edi+eax]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [edx+eax], xmm0
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LC21@perform_sy
	mov	edx, DWORD PTR _x_off$[ebp]
$LN16@perform_sy:

; 1400 :         {
; 1401 :           for (t=0; t < step->support_length; t++, in=out)

	mov	ecx, DWORD PTR _step$[ebp]
	mov	edi, esi
	inc	DWORD PTR _t$1$[ebp]
	movzx	eax, BYTE PTR [ecx+1]
	cmp	DWORD PTR _t$1$[ebp], eax
	jl	$LL18@perform_sy
	pop	edi
	pop	esi
	pop	ebx

; 1419 :             }
; 1420 :         }
; 1421 :     }
; 1422 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@perform_sy:

; 1407 :             }
; 1408 :         }
; 1409 :       else
; 1410 :         {
; 1411 :           kdu_int32 downshift = step->downshift;

	movzx	esi, BYTE PTR [ecx+2]
	mov	DWORD PTR _downshift$1$[ebp], esi

; 1412 :           kdu_int32 offset = step->rounding_offset;

	movsx	esi, WORD PTR [ecx+6]

; 1413 :           int sum, *fpp, support=step->support_length;

	movzx	eax, al
	mov	DWORD PTR _offset$1$[ebp], esi

; 1414 :           for (k=x_off; k < width; k++)

	mov	esi, DWORD PTR _out$1$[ebp]
	mov	DWORD PTR _support$1$[ebp], eax
	cmp	edx, ebx
	jge	$LN99@perform_sy
	sub	edi, esi
	mov	DWORD PTR _in$1$[ebp], edi
$LL24@perform_sy:

; 1415 :             {
; 1416 :               for (fpp=step->icoeffs, sum=offset, t=0; t < support; t++)

	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	mov	DWORD PTR _fpp$1$[ebp], eax
	mov	eax, DWORD PTR _offset$1$[ebp]
	mov	DWORD PTR _sum$1$[ebp], eax
	mov	eax, DWORD PTR _support$1$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR $T2[ebp], 0
	cmp	eax, 2
	jl	SHORT $LC83@perform_sy
	mov	edi, DWORD PTR _fpp$1$[ebp]
	mov	ebx, DWORD PTR _src_ptrs$[ebp]
	mov	eax, ebx
	sub	eax, edi
	mov	DWORD PTR tv3454[ebp], eax
	lea	esi, DWORD PTR [edi+4]
	mov	edi, eax
$LL84@perform_sy:

; 1417 :                 sum += fpp[t] * (src_ptrs[t])[k].ival;

	mov	eax, DWORD PTR [ebx+ecx*4]
	lea	esi, DWORD PTR [esi+8]
	add	ecx, 2
	mov	eax, DWORD PTR [eax+edx*4]
	imul	eax, DWORD PTR [esi-12]
	add	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR [edi+esi-8]
	mov	eax, DWORD PTR [eax+edx*4]
	imul	eax, DWORD PTR [esi-8]
	mov	edx, DWORD PTR _x_off$[ebp]
	add	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _support$1$[ebp]
	dec	eax
	cmp	ecx, eax
	jl	SHORT $LL84@perform_sy
	mov	edi, DWORD PTR _in$1$[ebp]
	mov	ebx, DWORD PTR _width$[ebp]
	mov	esi, DWORD PTR _out$1$[ebp]
	mov	eax, DWORD PTR _support$1$[ebp]
$LC83@perform_sy:

; 1415 :             {
; 1416 :               for (fpp=step->icoeffs, sum=offset, t=0; t < support; t++)

	cmp	ecx, eax
	jge	SHORT $LN82@perform_sy

; 1417 :                 sum += fpp[t] * (src_ptrs[t])[k].ival;

	mov	eax, DWORD PTR _src_ptrs$[ebp]
	mov	ebx, DWORD PTR _fpp$1$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+edx*4]
	imul	eax, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _offset$1$[ebp]
	mov	DWORD PTR _sum$1$[ebp], eax
$LN82@perform_sy:

; 1418 :               out[k].ival = in[k].ival - (sum >> downshift);

	mov	ecx, DWORD PTR _downshift$1$[ebp]
	lea	esi, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR $T2[ebp]
	add	edx, DWORD PTR $T1[ebp]
	add	edx, DWORD PTR _sum$1$[ebp]
	mov	eax, DWORD PTR [esi+edi]
	sar	edx, cl
	mov	ecx, DWORD PTR _step$[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR _x_off$[ebp]
	inc	edx
	mov	DWORD PTR [esi], eax
	mov	esi, DWORD PTR _out$1$[ebp]
	mov	DWORD PTR _x_off$[ebp], edx
	cmp	edx, ebx
	jl	$LL24@perform_sy
$LN99@perform_sy:
	pop	edi
	pop	esi
$LN23@perform_sy:
	pop	ebx

; 1419 :             }
; 1420 :         }
; 1421 :     }
; 1422 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z ENDP ; perform_synthesis_lifting_step
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
;	COMDAT ?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z
_TEXT	SEGMENT
_downshift$1$ = -44					; size = 4
_sum$1$ = -40						; size = 4
tv1265 = -36						; size = 4
_offset$1$ = -32					; size = 4
_fpp$1$ = -28						; size = 4
$T1 = -24						; size = 4
_i_lambda$1$ = -24					; size = 4
_support$1$ = -20					; size = 4
_downshift$1$ = -20					; size = 4
$T2 = -16						; size = 4
_offset$1$ = -16					; size = 4
_in$1$ = -12						; size = 4
_out$1$ = -8						; size = 4
tv1289 = -1						; size = 1
_step$ = 8						; size = 4
_src_ptrs$ = 12						; size = 4
_in$ = 16						; size = 4
_out$ = 20						; size = 4
_sp2$1$ = 24						; size = 4
_sp1$1$ = 24						; size = 4
_width$ = 24						; size = 4
_x_off$ = 28						; size = 4
?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z PROC ; perform_synthesis_lifting_step, COMDAT

; 1433 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	edi

; 1434 :   int k;
; 1435 : 
; 1436 :   if (width <= 0)

	mov	edi, DWORD PTR _width$[ebp]
	test	edi, edi
	jle	$LN14@perform_sy

; 1437 :     return;
; 1438 :   while (x_off > 8)

	push	ebx
	mov	ebx, DWORD PTR _x_off$[ebp]
	push	esi
	mov	esi, DWORD PTR _in$[ebp]
	cmp	ebx, 8
	jle	SHORT $LN63@perform_sy
	lea	ecx, DWORD PTR [ebx-9]
	shr	ecx, 3
	inc	ecx
	mov	eax, ecx
	shl	ecx, 4
	neg	eax
	lea	ebx, DWORD PTR [ebx+eax*8]
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, ecx
	add	esi, ecx
	jmp	SHORT $LN68@perform_sy
$LN63@perform_sy:
	mov	eax, DWORD PTR _out$[ebp]
$LN68@perform_sy:

; 1439 :     { x_off -= 8; in += 8; out += 8; }
; 1440 :   width += x_off;
; 1441 : 
; 1442 : #ifdef KDU_SIMD_OPTIMIZATIONS
; 1443 :   if ((step->kernel_id == (kdu_byte) Ckernels_W5X3) &&

	mov	ecx, DWORD PTR _step$[ebp]
	add	edi, ebx
	mov	DWORD PTR _in$1$[ebp], esi
	mov	DWORD PTR _out$1$[ebp], eax
	mov	DWORD PTR _width$[ebp], edi
	cmp	BYTE PTR [ecx+18], 1
	jne	SHORT $LN20@perform_sy
	push	ecx
	push	edi
	push	eax
	mov	eax, DWORD PTR _src_ptrs$[ebp]
	push	esi
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	?simd_W5X3_v_synth@@YA_NPAF000HPAUkd_lifting_step@@@Z ; simd_W5X3_v_synth
	add	esp, 24					; 00000018H
	test	al, al
	jne	$LN66@perform_sy
	mov	ecx, DWORD PTR _step$[ebp]
$LN20@perform_sy:

; 1444 :       simd_W5X3_v_synth(&(src_ptrs[0]->ival),&(src_ptrs[1]->ival),
; 1445 :                         &(in->ival),&(out->ival),width,step))
; 1446 :     return;
; 1447 :   else if ((step->kernel_id == (kdu_byte) Ckernels_W9X7) &&

	cmp	BYTE PTR [ecx+18], 0
	jne	SHORT $LN22@perform_sy
	mov	eax, DWORD PTR _src_ptrs$[ebp]
	push	ecx
	push	edi
	push	DWORD PTR _out$1$[ebp]
	push	esi
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	?simd_W9X7_v_synth@@YA_NPAF000HPAUkd_lifting_step@@@Z ; simd_W9X7_v_synth
	add	esp, 24					; 00000018H
	test	al, al
	jne	$LN66@perform_sy
	mov	ecx, DWORD PTR _step$[ebp]
$LN22@perform_sy:

; 1448 :            simd_W9X7_v_synth(&(src_ptrs[0]->ival),&(src_ptrs[1]->ival),
; 1449 :                                  &(in->ival),&(out->ival),width,step))
; 1450 :     return;
; 1451 :   else if (step->support_length <= 2)

	mov	al, BYTE PTR [ecx+1]
	cmp	al, 2
	ja	SHORT $LN24@perform_sy

; 1452 :     {
; 1453 :       if (simd_2tap_v_synth(&(src_ptrs[0]->ival),

	push	ecx
	mov	ecx, DWORD PTR _src_ptrs$[ebp]
	push	edi
	push	DWORD PTR _out$1$[ebp]
	movzx	eax, al
	push	esi
	push	DWORD PTR [ecx+eax*4-4]
	push	DWORD PTR [ecx]
	call	?simd_2tap_v_synth@@YA_NPAF000HPAUkd_lifting_step@@@Z ; simd_2tap_v_synth
	add	esp, 24					; 00000018H

; 1454 :                             &(src_ptrs[step->support_length-1]->ival),
; 1455 :                             &(in->ival),&(out->ival),width,step))
; 1456 :         return;
; 1457 :     }

	jmp	SHORT $LN70@perform_sy
$LN24@perform_sy:

; 1458 :   else if (step->support_length <= 4)

	cmp	al, 4
	ja	SHORT $LN28@perform_sy

; 1459 :     {
; 1460 :       if (simd_4tap_v_synth(&(src_ptrs[0]->ival),&(src_ptrs[1]->ival),

	push	ecx
	mov	ecx, DWORD PTR _src_ptrs$[ebp]
	push	edi
	push	DWORD PTR _out$1$[ebp]
	movzx	eax, al
	push	esi
	push	DWORD PTR [ecx+eax*4-4]
	push	DWORD PTR [ecx+8]
	push	DWORD PTR [ecx+4]
	push	DWORD PTR [ecx]
	call	?simd_4tap_v_synth@@YA_NPAF00000HPAUkd_lifting_step@@@Z ; simd_4tap_v_synth
	add	esp, 32					; 00000020H
$LN70@perform_sy:
	test	al, al
	jne	$LN66@perform_sy
	mov	ecx, DWORD PTR _step$[ebp]
$LN28@perform_sy:

; 1461 :                             &(src_ptrs[2]->ival),
; 1462 :                             &(src_ptrs[step->support_length-1]->ival),
; 1463 :                             &(in->ival),&(out->ival),width,step))
; 1464 :         return;
; 1465 :     }
; 1466 : #endif // KDU_SIMD_OPTIMIZATIONS
; 1467 :   if ((step->support_length==2) && (step->icoeffs[0]==step->icoeffs[1]))

	mov	al, BYTE PTR [ecx+1]
	cmp	al, 2
	jne	$LN29@perform_sy
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _i_lambda$1$[ebp], edx
	cmp	edx, DWORD PTR [eax+4]
	jne	$LN65@perform_sy

; 1468 :     {
; 1469 :       kdu_sample16 *sp1=src_ptrs[0], *sp2=src_ptrs[1];
; 1470 :       kdu_int32 downshift = step->downshift;

	movzx	ecx, BYTE PTR [ecx+2]

; 1471 :       kdu_int32 offset = (1<<downshift)>>1;

	mov	edx, 1
	mov	eax, DWORD PTR _src_ptrs$[ebp]
	shl	edx, cl
	mov	DWORD PTR _downshift$1$[ebp], ecx
	mov	ecx, edx
	mov	DWORD PTR _offset$1$[ebp], edx
	mov	esi, DWORD PTR [eax]

; 1472 :       kdu_int32 val, i_lambda=step->icoeffs[0];
; 1473 :       if (i_lambda == 1)

	mov	edx, DWORD PTR _i_lambda$1$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sar	ecx, 1
	mov	DWORD PTR _sp1$1$[ebp], esi
	mov	DWORD PTR _offset$1$[ebp], ecx
	cmp	edx, 1
	jne	SHORT $LN31@perform_sy

; 1474 :         for (k=x_off; k < width; k++)

	cmp	ebx, edi
	jge	$LN66@perform_sy
	mov	edx, DWORD PTR _sp1$1$[ebp]
	lea	esi, DWORD PTR [esi+ebx*2]
	sub	DWORD PTR _in$1$[ebp], edx
	sub	eax, edx
	sub	DWORD PTR _out$1$[ebp], edx
	sub	edi, ebx
	mov	ebx, DWORD PTR _in$1$[ebp]
	mov	DWORD PTR _sp2$1$[ebp], eax
	npad	3
$LL6@perform_sy:

; 1475 :           {
; 1476 :             val = sp1[k].ival;  val += sp2[k].ival;

	movsx	eax, WORD PTR [eax+esi]
	lea	esi, DWORD PTR [esi+2]
	movsx	edx, WORD PTR [esi-2]

; 1477 :             out[k].ival = in[k].ival - (kdu_int16)((offset+val)>>downshift);

	add	eax, ecx
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	add	edx, eax
	mov	ax, WORD PTR [ebx+esi-2]
	sar	edx, cl
	mov	ecx, DWORD PTR _out$1$[ebp]
	sub	ax, dx
	mov	WORD PTR [ecx+esi-2], ax
	mov	eax, DWORD PTR _sp2$1$[ebp]
	mov	ecx, DWORD PTR _offset$1$[ebp]
	sub	edi, 1
	jne	SHORT $LL6@perform_sy
	pop	esi
	pop	ebx
	pop	edi

; 1502 :         }
; 1503 :     }
; 1504 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@perform_sy:

; 1478 :           }
; 1479 :       else if (i_lambda == -1)

	cmp	edx, -1
	jne	SHORT $LN33@perform_sy

; 1480 :         for (k=x_off; k < width; k++)

	cmp	ebx, edi
	jge	$LN66@perform_sy
	mov	edx, DWORD PTR _sp1$1$[ebp]
	lea	esi, DWORD PTR [esi+ebx*2]
	sub	DWORD PTR _in$1$[ebp], edx
	sub	eax, edx
	sub	DWORD PTR _out$1$[ebp], edx
	sub	edi, ebx
	mov	ebx, DWORD PTR _in$1$[ebp]
	mov	DWORD PTR _sp2$1$[ebp], eax
	npad	7
$LL9@perform_sy:

; 1481 :           {
; 1482 :             val = sp1[k].ival;  val += sp2[k].ival;

	movsx	eax, WORD PTR [esi+eax]
	lea	esi, DWORD PTR [esi+2]

; 1483 :             out[k].ival = in[k].ival - (kdu_int16)((offset-val) >> downshift);

	mov	edx, ecx
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sub	edx, eax
	movsx	eax, WORD PTR [esi-2]
	sub	edx, eax
	mov	ax, WORD PTR [esi+ebx-2]
	sar	edx, cl
	mov	ecx, DWORD PTR _out$1$[ebp]
	sub	ax, dx
	mov	WORD PTR [esi+ecx-2], ax
	mov	eax, DWORD PTR _sp2$1$[ebp]
	mov	ecx, DWORD PTR _offset$1$[ebp]
	sub	edi, 1
	jne	SHORT $LL9@perform_sy
	pop	esi
	pop	ebx
	pop	edi

; 1502 :         }
; 1503 :     }
; 1504 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@perform_sy:

; 1484 :           }
; 1485 :       else
; 1486 :         for (k=x_off; k < width; k++)

	cmp	ebx, edi
	jge	$LN66@perform_sy
	mov	edx, DWORD PTR _sp1$1$[ebp]
	lea	esi, DWORD PTR [esi+ebx*2]
	sub	DWORD PTR _in$1$[ebp], edx
	sub	eax, edx
	sub	DWORD PTR _out$1$[ebp], edx
	sub	edi, ebx
	mov	ebx, DWORD PTR _in$1$[ebp]
	mov	DWORD PTR _sp2$1$[ebp], eax
	npad	10
$LL12@perform_sy:

; 1487 :           {
; 1488 :             val = sp1[k].ival;  val += sp2[k].ival;  val *= i_lambda;

	movsx	edx, WORD PTR [esi+eax]
	lea	esi, DWORD PTR [esi+2]
	movsx	eax, WORD PTR [esi-2]
	add	edx, eax

; 1489 :             out[k].ival = in[k].ival - (kdu_int16)((offset+val) >> downshift);

	mov	ax, WORD PTR [esi+ebx-2]
	imul	edx, DWORD PTR _i_lambda$1$[ebp]
	add	edx, ecx
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sar	edx, cl
	mov	ecx, DWORD PTR _out$1$[ebp]
	sub	ax, dx
	mov	WORD PTR [esi+ecx-2], ax
	mov	eax, DWORD PTR _sp2$1$[ebp]
	mov	ecx, DWORD PTR _offset$1$[ebp]
	sub	edi, 1
	jne	SHORT $LL12@perform_sy
	pop	esi
	pop	ebx
	pop	edi

; 1502 :         }
; 1503 :     }
; 1504 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@perform_sy:
	mov	al, BYTE PTR [ecx+1]
$LN29@perform_sy:

; 1490 :           }
; 1491 :     }
; 1492 :   else
; 1493 :     { // More general 16-bit processing
; 1494 :       kdu_int32 downshift = step->downshift;

	movzx	edx, BYTE PTR [ecx+2]
	mov	DWORD PTR _downshift$1$[ebp], edx

; 1495 :       kdu_int32 offset = step->rounding_offset;

	movsx	edx, WORD PTR [ecx+6]

; 1496 :       int t, sum, *fpp, support=step->support_length;

	movzx	eax, al
	mov	DWORD PTR _offset$1$[ebp], edx
	mov	DWORD PTR _support$1$[ebp], eax

; 1497 :       for (k=x_off; k < width; k++)

	cmp	ebx, edi
	jge	$LN66@perform_sy
	mov	edx, DWORD PTR _out$1$[ebp]
	sub	esi, edx
	mov	DWORD PTR _in$1$[ebp], esi
$LL15@perform_sy:

; 1498 :         {
; 1499 :           for (fpp=step->icoeffs, sum=offset, t=0; t < support; t++)

	mov	esi, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	DWORD PTR _support$1$[ebp], 2
	mov	eax, DWORD PTR _offset$1$[ebp]
	mov	edi, DWORD PTR _width$[ebp]
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR _fpp$1$[ebp], esi
	mov	DWORD PTR _sum$1$[ebp], eax
	jl	SHORT $LN64@perform_sy
	lea	edx, DWORD PTR [esi+4]
	mov	esi, DWORD PTR _src_ptrs$[ebp]
	mov	eax, esi
	sub	eax, DWORD PTR _fpp$1$[ebp]
	mov	DWORD PTR tv1265[ebp], eax
	mov	edi, eax
$LL56@perform_sy:

; 1500 :             sum += fpp[t] * (src_ptrs[t])[k].ival;

	mov	eax, DWORD PTR [esi+ecx*4]
	lea	edx, DWORD PTR [edx+8]
	mov	esi, DWORD PTR _src_ptrs$[ebp]
	add	ecx, 2
	movsx	eax, WORD PTR [eax+ebx*2]
	imul	eax, DWORD PTR [edx-12]
	add	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR [edi+edx-8]
	movsx	eax, WORD PTR [eax+ebx*2]
	imul	eax, DWORD PTR [edx-8]
	add	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _support$1$[ebp]
	dec	eax
	cmp	ecx, eax
	jl	SHORT $LL56@perform_sy
	mov	edi, DWORD PTR _width$[ebp]
	mov	edx, DWORD PTR _out$1$[ebp]
	mov	eax, DWORD PTR _sum$1$[ebp]
	jmp	SHORT $LC55@perform_sy
$LN64@perform_sy:
	mov	esi, DWORD PTR _src_ptrs$[ebp]
$LC55@perform_sy:

; 1498 :         {
; 1499 :           for (fpp=step->icoeffs, sum=offset, t=0; t < support; t++)

	cmp	ecx, DWORD PTR _support$1$[ebp]
	jge	SHORT $LN54@perform_sy

; 1500 :             sum += fpp[t] * (src_ptrs[t])[k].ival;

	mov	eax, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR _fpp$1$[ebp]
	movsx	eax, WORD PTR [eax+ebx*2]
	imul	eax, DWORD PTR [esi+ecx*4]
	add	eax, DWORD PTR _offset$1$[ebp]
$LN54@perform_sy:

; 1501 :           out[k].ival = in[k].ival - (kdu_int16)(sum >> downshift);

	mov	ecx, DWORD PTR _downshift$1$[ebp]
	lea	esi, DWORD PTR [edx+ebx*2]
	mov	edx, DWORD PTR $T1[ebp]
	inc	ebx
	add	edx, DWORD PTR $T2[ebp]
	add	edx, eax
	mov	eax, DWORD PTR _in$1$[ebp]
	sar	edx, cl
	mov	ecx, DWORD PTR _step$[ebp]
	mov	ax, WORD PTR [esi+eax]
	sub	ax, dx
	mov	edx, DWORD PTR _out$1$[ebp]
	mov	WORD PTR [esi], ax
	cmp	ebx, edi
	jl	$LL15@perform_sy
$LN66@perform_sy:
	pop	esi
	pop	ebx
$LN14@perform_sy:
	pop	edi

; 1502 :         }
; 1503 :     }
; 1504 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z ENDP ; perform_synthesis_lifting_step
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?simulate_access_source@kd_vlift_queue@@QAE_NHHAAH@Z
_TEXT	SEGMENT
_idx$2$ = 8						; size = 4
_idx$ = 8						; size = 4
_num$ = 12						; size = 4
_used_lines$ = 16					; size = 4
?simulate_access_source@kd_vlift_queue@@QAE_NHHAAH@Z PROC ; kd_vlift_queue::simulate_access_source, COMDAT
; _this$ = ecx

; 276  :       { /* Used in the simulation phase to discover buffer requirements.

	push	ebp
	mov	ebp, esp

; 277  :            `used_lines' represents the total number of lines which would
; 278  :            be allocated from the free list during real processing. */
; 279  :         assert((((idx ^ queue_idx) & 1) == 0) && (idx >= source_pos));
; 280  :         source_pos = idx; // At least this large

	mov	eax, DWORD PTR _idx$[ebp]
	mov	edx, ecx
	push	ebx

; 281  :         num--;  idx += num<<1; // Find index of last requested line; allows

	mov	ebx, DWORD PTR _num$[ebp]
	sub	ebx, 1
	push	esi
	push	edi
	mov	DWORD PTR [edx+24], eax
	lea	ecx, DWORD PTR [eax+ebx*2]
	mov	DWORD PTR _idx$2$[ebp], ecx

; 282  :                                // us to detect failure as early as possible
; 283  :         int k;
; 284  :         for (; num >= 0; idx-=2, num--)

	js	SHORT $LN3@simulate_a

; 287  :             while ((k < y_min) || (k > y_max))

	mov	esi, DWORD PTR [edx]
	mov	edi, DWORD PTR [edx+4]
$LL4@simulate_a:

; 285  :           {
; 286  :             k = idx;

	mov	eax, ecx
$LL5@simulate_a:

; 287  :             while ((k < y_min) || (k > y_max))

	cmp	eax, esi
	jl	SHORT $LN31@simulate_a
	cmp	eax, edi
	jle	SHORT $LN6@simulate_a

; 291  :                 k = (symmetric_extension)?(2*y_max-k):(y_max-((y_max^k)&1));

	cmp	BYTE PTR [edx+36], 0
	je	SHORT $LN17@simulate_a
	lea	ecx, DWORD PTR [edi+edi]
	sub	ecx, eax
	jmp	SHORT $LL4@simulate_a
$LN17@simulate_a:
	mov	ecx, edi
	xor	ecx, eax
	mov	eax, edi
	and	ecx, 1
	sub	eax, ecx
	jmp	SHORT $LL5@simulate_a
$LN31@simulate_a:

; 288  :               if (k < y_min)
; 289  :                 k = (symmetric_extension)?(2*y_min-k):(y_min+((y_min^k)&1));

	cmp	BYTE PTR [edx+36], 0
	je	SHORT $LN15@simulate_a
	lea	ecx, DWORD PTR [esi+esi]
	sub	ecx, eax
	jmp	SHORT $LL4@simulate_a
$LN15@simulate_a:
	xor	eax, esi
	and	eax, 1
	add	eax, esi

; 290  :               else

	jmp	SHORT $LL5@simulate_a
$LN6@simulate_a:

; 292  :             if ((k < head_idx) || (k > tail_idx)) return false;

	cmp	eax, DWORD PTR [edx+16]
	jl	SHORT $LN23@simulate_a
	cmp	eax, DWORD PTR [edx+20]
	jg	SHORT $LN23@simulate_a

; 282  :                                // us to detect failure as early as possible
; 283  :         int k;
; 284  :         for (; num >= 0; idx-=2, num--)

	mov	ecx, DWORD PTR _idx$2$[ebp]
	sub	ecx, 2
	sub	ebx, 1
	mov	DWORD PTR _idx$2$[ebp], ecx
	jns	SHORT $LL4@simulate_a
$LN3@simulate_a:

; 293  :           }
; 294  :         source_pos += 2; // Advance `source_pos' when successful

	add	DWORD PTR [edx+24], 2

; 295  :         while ((head_idx < update_pos) && (head_idx < source_pos) &&
; 296  :                (tail_idx >= head_idx) && (head_idx < recycling_lim))

	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [edx+28]
	jge	SHORT $LN38@simulate_a
	mov	ecx, DWORD PTR _used_lines$[ebp]
$LL7@simulate_a:
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $LN38@simulate_a
	cmp	DWORD PTR [edx+20], eax
	jl	SHORT $LN38@simulate_a
	cmp	eax, DWORD PTR [edx+32]
	jge	SHORT $LN38@simulate_a

; 297  :           { head_idx+=2; used_lines--; }

	add	eax, 2
	mov	DWORD PTR [edx+16], eax
	dec	DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [edx+28]
	jl	SHORT $LL7@simulate_a
$LN38@simulate_a:
	pop	edi
	pop	esi

; 298  :         return true;

	mov	al, 1
	pop	ebx

; 299  :       }

	pop	ebp
	ret	12					; 0000000cH
$LN23@simulate_a:
	pop	edi
	pop	esi

; 292  :             if ((k < head_idx) || (k > tail_idx)) return false;

	xor	al, al
	pop	ebx

; 299  :       }

	pop	ebp
	ret	12					; 0000000cH
?simulate_access_source@kd_vlift_queue@@QAE_NHHAAH@Z ENDP ; kd_vlift_queue::simulate_access_source
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?simulate_access_update@kd_vlift_queue@@QAE_NHAAH@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_used_lines$ = 12					; size = 4
?simulate_access_update@kd_vlift_queue@@QAE_NHAAH@Z PROC ; kd_vlift_queue::simulate_access_update, COMDAT
; _this$ = ecx

; 261  :       { /* Used in the simulation phase to discover buffer requirements.

	push	ebp
	mov	ebp, esp

; 262  :            Returns false if `access_update' would have returned NULL.
; 263  :            `used_lines' represents the total number of lines which would be
; 264  :            allocated from the free list during real processing. */
; 265  :         assert((((idx ^ queue_idx) & 1) == 0) && (idx >= update_pos));
; 266  :         update_pos = idx; // At least this large

	mov	eax, DWORD PTR _idx$[ebp]

; 267  :         if ((idx < head_idx) || (idx > tail_idx))

	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx+28], eax
	cmp	eax, edx
	jl	SHORT $LN5@simulate_a
	cmp	eax, DWORD PTR [ecx+20]
	jg	SHORT $LN5@simulate_a

; 269  :         update_pos += 2;

	add	eax, 2
	mov	DWORD PTR [ecx+28], eax

; 270  :         while ((head_idx < update_pos) && (head_idx < source_pos) &&
; 271  :                (tail_idx >= head_idx) && (head_idx < recycling_lim))

	cmp	edx, eax
	jge	SHORT $LN3@simulate_a
	mov	edx, DWORD PTR _used_lines$[ebp]
$LL2@simulate_a:
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [ecx+24]
	jge	SHORT $LN3@simulate_a
	cmp	DWORD PTR [ecx+20], eax
	jl	SHORT $LN3@simulate_a
	cmp	eax, DWORD PTR [ecx+32]
	jge	SHORT $LN3@simulate_a

; 272  :           { head_idx+=2; used_lines--; }

	add	eax, 2
	mov	DWORD PTR [ecx+16], eax
	dec	DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [ecx+28]
	jl	SHORT $LL2@simulate_a
$LN3@simulate_a:

; 273  :         return true;

	mov	al, 1

; 274  :       }

	pop	ebp
	ret	8
$LN5@simulate_a:

; 268  :           return false;

	xor	al, al

; 274  :       }

	pop	ebp
	ret	8
?simulate_access_update@kd_vlift_queue@@QAE_NHAAH@Z ENDP ; kd_vlift_queue::simulate_access_update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?simulate_push_line@kd_vlift_queue@@QAEXHAAH@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_used_lines$ = 12					; size = 4
?simulate_push_line@kd_vlift_queue@@QAEXHAAH@Z PROC	; kd_vlift_queue::simulate_push_line, COMDAT
; _this$ = ecx

; 250  :       { /* Used in the simulation phase to discover buffer requirements. */

	push	ebp
	mov	ebp, esp

; 251  :         assert(((idx ^ queue_idx) & 1) == 0);
; 252  :         if ((idx < source_pos) && (idx < update_pos))

	mov	edx, DWORD PTR _idx$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $LN2@simulate_p
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN2@simulate_p

; 253  :           { // Recycle line immediatel.  It will never contribute.
; 254  :             used_lines--;  return;

	mov	eax, DWORD PTR _used_lines$[ebp]
	dec	DWORD PTR [eax]

; 259  :       }

	pop	ebp
	ret	8
$LN2@simulate_p:

; 255  :           }
; 256  :         if (tail_idx < head_idx)

	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR [ecx+16]
	jge	SHORT $LN3@simulate_p

; 257  :           head_idx = idx;

	mov	DWORD PTR [ecx+16], edx
$LN3@simulate_p:

; 258  :         tail_idx = idx;

	mov	DWORD PTR [ecx+20], edx

; 259  :       }

	pop	ebp
	ret	8
?simulate_push_line@kd_vlift_queue@@QAEXHAAH@Z ENDP	; kd_vlift_queue::simulate_push_line
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?access_source@kd_vlift_queue@@QAE_NHHQAPAUkd_vlift_line@@AAPAU2@@Z
_TEXT	SEGMENT
_idx$2$ = 8						; size = 4
_idx$ = 8						; size = 4
_num$ = 12						; size = 4
_lines$ = 16						; size = 4
_free_list$ = 20					; size = 4
?access_source@kd_vlift_queue@@QAE_NHHQAPAUkd_vlift_line@@AAPAU2@@Z PROC ; kd_vlift_queue::access_source, COMDAT
; _this$ = ecx

; 208  :       { /* Use this function to access the source lines for lifting step

	push	ebp
	mov	ebp, esp

; 209  :            `queue_idx'.  The number of required lines is given by `num'
; 210  :            and the location of the first line is given by `idx'.  The function
; 211  :            returns false if one or more of the requested lines is unavailable.
; 212  :            Otherwise, it returns true and also advances the internal
; 213  :            `source_pos' pointer to `idx'+2.  You may not invoke this
; 214  :            function for the queue whose `queue_index' value is -1.
; 215  :               Perhaps the most important feature of this function is that
; 216  :            it implements the boundary extension policy automatically.  This
; 217  :            means that the range of requested lines can lie outside the range
; 218  :            of actual available lines. */
; 219  :         assert((((idx ^ queue_idx) & 1) == 0) && (idx >= source_pos));
; 220  :         source_pos = idx; // At least this large

	mov	eax, DWORD PTR _idx$[ebp]
	mov	edx, ecx

; 221  :         num--;  idx += num<<1; // Find index of last requested line; allows

	mov	ecx, DWORD PTR _num$[ebp]
	dec	ecx
	push	esi
	mov	DWORD PTR [edx+24], eax
	mov	DWORD PTR _num$[ebp], ecx
	lea	esi, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR _idx$2$[ebp], esi

; 222  :                               // us to detect failure as early as possible
; 223  :         if ((idx > tail_idx) && (idx <= y_max))

	cmp	esi, DWORD PTR [edx+20]
	jle	SHORT $LN12@access_sou
	cmp	esi, DWORD PTR [edx+4]
	jg	SHORT $LN12@access_sou

; 224  :           return false; // Almost all failures are detected here, in practice

	xor	al, al
	pop	esi

; 246  :       }

	pop	ebp
	ret	16					; 00000010H
$LN12@access_sou:

; 225  :         int k;
; 226  :         for (lines+=num; num >= 0; idx-=2, num--, lines--)

	mov	eax, DWORD PTR _lines$[ebp]
	push	ebx
	push	edi
	lea	ebx, DWORD PTR [eax+ecx*4]
	test	ecx, ecx
	js	$LN3@access_sou
	npad	6
$LL4@access_sou:

; 227  :           {
; 228  :             k = idx;
; 229  :             while ((k < y_min) || (k > y_max))

	mov	edi, DWORD PTR [edx+4]
	mov	eax, esi
	mov	esi, DWORD PTR [edx]
$LL5@access_sou:
	cmp	eax, esi
	jl	SHORT $LN39@access_sou
	cmp	eax, edi
	jle	SHORT $LN6@access_sou

; 233  :                 k = (symmetric_extension)?(2*y_max-k):(y_max-((y_max^k)&1));

	cmp	BYTE PTR [edx+36], 0
	je	SHORT $LN22@access_sou
	lea	ecx, DWORD PTR [edi+edi]
	sub	ecx, eax
	mov	eax, ecx
	jmp	SHORT $LL5@access_sou
$LN22@access_sou:
	mov	ecx, edi
	xor	ecx, eax
	mov	eax, edi
	and	ecx, 1
	sub	eax, ecx
	jmp	SHORT $LL5@access_sou
$LN39@access_sou:

; 230  :               if (k < y_min)
; 231  :                 k = (symmetric_extension)?(2*y_min-k):(y_min+((y_min^k)&1));

	cmp	BYTE PTR [edx+36], 0
	je	SHORT $LN20@access_sou
	lea	ecx, DWORD PTR [esi+esi]
	sub	ecx, eax
	mov	eax, ecx
	jmp	SHORT $LL5@access_sou
$LN20@access_sou:
	xor	eax, esi
	and	eax, 1
	add	eax, esi

; 232  :               else

	jmp	SHORT $LL5@access_sou
$LN6@access_sou:

; 234  :             if ((k < head_idx) || (k > tail_idx)) return false;

	cmp	eax, DWORD PTR [edx+16]
	jl	$LN29@access_sou
	cmp	eax, DWORD PTR [edx+20]
	jg	$LN29@access_sou

; 235  :             for (*lines=head; k > head_idx; k-=2, *lines=(*lines)->next);

	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [ebx], ecx
	cmp	eax, DWORD PTR [edx+16]
	jle	SHORT $LN2@access_sou
	npad	1
$LL9@access_sou:
	mov	ecx, DWORD PTR [ebx]
	sub	eax, 2
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [ebx], ecx
	cmp	eax, DWORD PTR [edx+16]
	jg	SHORT $LL9@access_sou
$LN2@access_sou:

; 225  :         int k;
; 226  :         for (lines+=num; num >= 0; idx-=2, num--, lines--)

	mov	ecx, DWORD PTR _num$[ebp]
	sub	ebx, 4
	mov	esi, DWORD PTR _idx$2$[ebp]
	dec	ecx
	sub	esi, 2
	mov	DWORD PTR _num$[ebp], ecx
	mov	DWORD PTR _idx$2$[ebp], esi
	test	ecx, ecx
	jns	$LL4@access_sou
$LN3@access_sou:

; 236  :           }
; 237  :         source_pos += 2; // Advance `source_pos' when successful

	add	DWORD PTR [edx+24], 2

; 238  :         while ((head_idx < update_pos) && (head_idx < source_pos) &&
; 239  :                (head != NULL) && (head_idx < recycling_lim))

	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [edx+28]
	jge	SHORT $LN46@access_sou
	mov	edi, DWORD PTR _free_list$[ebp]
	npad	7
$LL10@access_sou:
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $LN46@access_sou
	mov	esi, DWORD PTR [edx+8]
	test	esi, esi
	je	SHORT $LN46@access_sou
	cmp	eax, DWORD PTR [edx+32]
	jge	SHORT $LN46@access_sou

; 240  :           {
; 241  :             head_idx+=2;  kd_vlift_line *new_head = head->next;

	add	eax, 2
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [esi+24]

; 242  :             head->next = free_list;  free_list = head;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [edi], eax

; 243  :             if ((head = new_head) == NULL) tail = NULL;

	mov	DWORD PTR [edx+8], ecx
	test	ecx, ecx
	jne	SHORT $LN18@access_sou
	mov	DWORD PTR [edx+12], ecx
$LN18@access_sou:

; 238  :         while ((head_idx < update_pos) && (head_idx < source_pos) &&
; 239  :                (head != NULL) && (head_idx < recycling_lim))

	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [edx+28]
	jl	SHORT $LL10@access_sou
$LN46@access_sou:
	pop	edi
	pop	ebx

; 244  :           }
; 245  :         return true;

	mov	al, 1
	pop	esi

; 246  :       }

	pop	ebp
	ret	16					; 00000010H
$LN29@access_sou:
	pop	edi
	pop	ebx

; 234  :             if ((k < head_idx) || (k > tail_idx)) return false;

	xor	al, al
	pop	esi

; 246  :       }

	pop	ebp
	ret	16					; 00000010H
?access_source@kd_vlift_queue@@QAE_NHHQAPAUkd_vlift_line@@AAPAU2@@Z ENDP ; kd_vlift_queue::access_source
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?access_update@kd_vlift_queue@@QAEPAUkd_vlift_line@@HAAPAU2@@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_free_list$ = 12					; size = 4
?access_update@kd_vlift_queue@@QAEPAUkd_vlift_line@@HAAPAU2@@Z PROC ; kd_vlift_queue::access_update, COMDAT
; _this$ = ecx

; 185  :       { /* Use this function to access the next line which needs to be

	push	ebp
	mov	ebp, esp

; 186  :            updated by lifting step `queue_idx'+1.   The index of the line
; 187  :            is given by `idx', which must have the same parity as `queue_idx'.
; 188  :            If the function succeeds, it advances its internal record of the
; 189  :            next line to be accessed in subsequent calls. */
; 190  :         assert((((idx ^ queue_idx) & 1) == 0) && (idx >= update_pos));
; 191  :         update_pos = idx; // At least this large

	mov	edx, DWORD PTR _idx$[ebp]
	push	esi

; 192  :         if ((idx < head_idx) || (idx > tail_idx))

	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx+28], edx
	cmp	edx, esi
	jl	SHORT $LN8@access_upd
	cmp	edx, DWORD PTR [ecx+20]
	jg	SHORT $LN8@access_upd

; 194  :         kd_vlift_line *result = head;

	push	edi
	mov	edi, DWORD PTR [ecx+8]

; 195  :         for (; idx > head_idx; idx-=2, result=result->next);

	cmp	edx, esi
	jle	SHORT $LN3@access_upd

; 194  :         kd_vlift_line *result = head;

	mov	eax, edx
	sub	eax, esi
	dec	eax
	shr	eax, 1
	inc	eax
$LL4@access_upd:

; 195  :         for (; idx > head_idx; idx-=2, result=result->next);

	mov	edi, DWORD PTR [edi+24]
	sub	eax, 1
	jne	SHORT $LL4@access_upd
$LN3@access_upd:

; 196  :         assert(result != NULL);
; 197  :         update_pos += 2;

	lea	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+28], eax

; 198  :         while ((head_idx < source_pos) && (head_idx < update_pos) &&
; 199  :                (head != NULL) && (head_idx < recycling_lim))

	cmp	esi, DWORD PTR [ecx+24]
	jge	SHORT $LN18@access_upd
	push	ebx
	mov	ebx, DWORD PTR _free_list$[ebp]
	npad	3
$LL5@access_upd:
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [ecx+28]
	jge	SHORT $LN19@access_upd
	mov	esi, DWORD PTR [ecx+8]
	test	esi, esi
	je	SHORT $LN19@access_upd
	cmp	eax, DWORD PTR [ecx+32]
	jge	SHORT $LN19@access_upd

; 200  :           { head_idx+=2;  kd_vlift_line *new_head = head->next;

	add	eax, 2
	mov	DWORD PTR [ecx+16], eax
	mov	edx, DWORD PTR [esi+24]

; 201  :             head->next = free_list;  free_list = head;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ebx], eax

; 202  :             if ((head = new_head) == NULL) tail = NULL;

	mov	DWORD PTR [ecx+8], edx
	test	edx, edx
	jne	SHORT $LN9@access_upd
	mov	DWORD PTR [ecx+12], edx
$LN9@access_upd:

; 198  :         while ((head_idx < source_pos) && (head_idx < update_pos) &&
; 199  :                (head != NULL) && (head_idx < recycling_lim))

	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR [ecx+24]
	jl	SHORT $LL5@access_upd
$LN19@access_upd:
	pop	ebx
$LN18@access_upd:

; 203  :           }
; 204  :         return result;

	mov	eax, edi
	pop	edi
	pop	esi

; 205  :       }

	pop	ebp
	ret	8
$LN8@access_upd:

; 193  :           return NULL;

	xor	eax, eax
	pop	esi

; 205  :       }

	pop	ebp
	ret	8
?access_update@kd_vlift_queue@@QAEPAUkd_vlift_line@@HAAPAU2@@Z ENDP ; kd_vlift_queue::access_update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?test_update@kd_vlift_queue@@QAE_NH_N@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_need_exclusive_use$ = 12				; size = 1
?test_update@kd_vlift_queue@@QAE_NH_N@Z PROC		; kd_vlift_queue::test_update, COMDAT
; _this$ = ecx

; 170  :       { /* Returns true if the line identified by `idx' is currently available.

	push	ebp
	mov	ebp, esp

; 171  :            Also sets the `update_pos' member equal to `idx' to make it clear
; 172  :            that no calls to `access_update' will attempt to access earlier
; 173  :            rows than this.  If `need_exclusive_use' is true and the
; 174  :            line identified by `idx' might be required by future calls to
; 175  :            `access_source', the function returns false.  For this function
; 176  :            to work correctly in conjunction with the `need_exclusive_use'
; 177  :            option, you must remember to call `source_done' once you have
; 178  :            finished all calls to `access_source'. */
; 179  :         update_pos = idx;

	mov	eax, DWORD PTR _idx$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 180  :         return ((idx >= head_idx) && (idx <= tail_idx) &&

	cmp	eax, DWORD PTR [ecx+16]
	jl	SHORT $LN3@test_updat
	cmp	eax, DWORD PTR [ecx+20]
	jg	SHORT $LN3@test_updat
	cmp	BYTE PTR _need_exclusive_use$[ebp], 0
	je	SHORT $LN5@test_updat
	cmp	eax, DWORD PTR [ecx+24]
	jge	SHORT $LN3@test_updat
	cmp	eax, DWORD PTR [ecx+32]
	jge	SHORT $LN3@test_updat
$LN5@test_updat:
	mov	al, 1

; 181  :                 ((!need_exclusive_use) ||
; 182  :                  ((idx < source_pos) && (idx < recycling_lim))));
; 183  :       }

	pop	ebp
	ret	8
$LN3@test_updat:

; 180  :         return ((idx >= head_idx) && (idx <= tail_idx) &&

	xor	al, al

; 181  :                 ((!need_exclusive_use) ||
; 182  :                  ((idx < source_pos) && (idx < recycling_lim))));
; 183  :       }

	pop	ebp
	ret	8
?test_update@kd_vlift_queue@@QAE_NH_N@Z ENDP		; kd_vlift_queue::test_update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?push_line@kd_vlift_queue@@QAEXHPAUkd_vlift_line@@AAPAU2@@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_line$ = 12						; size = 4
_free_list$ = 16					; size = 4
?push_line@kd_vlift_queue@@QAEXHPAUkd_vlift_line@@AAPAU2@@Z PROC ; kd_vlift_queue::push_line, COMDAT
; _this$ = ecx

; 150  :       { /* Used to push new lines into the queue.  The `idx' argument is

	push	ebp
	mov	ebp, esp

; 151  :            the absolute location of this line.  It must have the same
; 152  :            parity (LSB) as the `queue_idx' identifier for this queue. */
; 153  :         assert(((idx ^ queue_idx) & 1) == 0);
; 154  :         if ((idx < source_pos) && (idx < update_pos))

	mov	edx, DWORD PTR _idx$[ebp]
	push	esi
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $LN4@push_line
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN4@push_line

; 155  :           { // Recycle line immediately; it will never contribute.  Also
; 156  :             // recycle any existing lines on the queue.
; 157  :             line->next = free_list;  free_list = line;

	mov	esi, DWORD PTR _free_list$[ebp]
	mov	edx, DWORD PTR _line$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+24], eax
	mov	DWORD PTR [esi], edx

; 158  :             while ((tail=head) != NULL)

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+12], eax
	test	eax, eax
	je	SHORT $LN1@push_line
	npad	8
$LL2@push_line:

; 159  :               { head=tail->next;  tail->next=free_list;  free_list=tail; }

	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+24], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+12], eax
	test	eax, eax
	jne	SHORT $LL2@push_line
	pop	esi

; 168  :       }

	pop	ebp
	ret	12					; 0000000cH
$LN4@push_line:

; 160  :             return;
; 161  :           }
; 162  :         line->next = NULL;

	mov	eax, DWORD PTR _line$[ebp]
	mov	DWORD PTR [eax+24], 0

; 163  :         if (tail == NULL)

	mov	esi, DWORD PTR [ecx+12]
	test	esi, esi
	jne	SHORT $LN5@push_line

; 164  :           { head = tail = line;  head_idx = idx;  }

	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+16], edx

; 165  :         else
; 166  :           { assert(idx == (tail_idx+2));  tail = tail->next = line; }

	mov	DWORD PTR [ecx+12], eax

; 167  :         tail_idx = idx;

	mov	DWORD PTR [ecx+20], edx
	pop	esi

; 168  :       }

	pop	ebp
	ret	12					; 0000000cH
$LN5@push_line:

; 165  :         else
; 166  :           { assert(idx == (tail_idx+2));  tail = tail->next = line; }

	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [ecx+12], eax

; 167  :         tail_idx = idx;

	mov	DWORD PTR [ecx+20], edx
$LN1@push_line:
	pop	esi

; 168  :       }

	pop	ebp
	ret	12					; 0000000cH
?push_line@kd_vlift_queue@@QAEXHPAUkd_vlift_line@@AAPAU2@@Z ENDP ; kd_vlift_queue::push_line
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?source_done@kd_vlift_queue@@QAEXXZ
_TEXT	SEGMENT
?source_done@kd_vlift_queue@@QAEXXZ PROC		; kd_vlift_queue::source_done, COMDAT
; _this$ = ecx

; 141  :            to `access_source'.  This sets `recycling_lim' and `source_pos'
; 142  :            both beyond the value of `y_max' so that they no longer influence
; 143  :            the behaviour of the stripe recycling machinery or the conditions
; 144  :            under which `test_update' will return true. */
; 145  :         source_pos = recycling_lim = y_max + 2;

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 2
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+24], eax

; 146  :           // We won't bother trying to recycle stripes here, since this should
; 147  :           // happen soon enough on the next call to `access_update'.
; 148  :       }

	ret	0
?source_done@kd_vlift_queue@@QAEXXZ ENDP		; kd_vlift_queue::source_done
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?init@kd_vlift_queue@@QAEXHHH_NH@Z
_TEXT	SEGMENT
_y_min$ = 8						; size = 4
_y_max$ = 12						; size = 4
_queue_idx$ = 16					; size = 4
_symmetric_extension$ = 20				; size = 1
_max_source_request_idx$ = 24				; size = 4
?init@kd_vlift_queue@@QAEXHHH_NH@Z PROC			; kd_vlift_queue::init, COMDAT
; _this$ = ecx

; 118  :       { /* For the interpretation of most of the arguments, see the notes

	push	ebp
	mov	ebp, esp

; 119  :            below, describe the member variables with the same names.
; 120  :            The `max_source_request_idx' argument identifies the location of
; 121  :            the last line which will ever be requested via `access_source'.
; 122  :            This is used to determine the `recycling_lim' value. */
; 123  :         assert(((max_source_request_idx ^ queue_idx) & 1) == 0);
; 124  :         this->queue_idx = (kdu_byte) queue_idx;
; 125  :         this->y_min = y_min;  this->y_max = y_max;

	mov	eax, DWORD PTR _y_min$[ebp]
	mov	edx, DWORD PTR _y_max$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _queue_idx$[ebp]
	push	esi

; 126  :         head_idx = source_pos = update_pos = y_min - 1000; // Ridiculous value

	lea	esi, DWORD PTR [eax-1000]
	mov	DWORD PTR [ecx], eax

; 127  :         this->symmetric_extension = symmetric_extension;

	mov	al, BYTE PTR _symmetric_extension$[ebp]
	mov	BYTE PTR [ecx+37], bl
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+28], esi
	mov	DWORD PTR [ecx+24], esi
	mov	DWORD PTR [ecx+16], esi
	mov	BYTE PTR [ecx+36], al

; 128  :         if ((!symmetric_extension) || (max_source_request_idx < y_max))

	test	al, al
	je	SHORT $LN4@init
	cmp	DWORD PTR _max_source_request_idx$[ebp], edx
	jl	SHORT $LN4@init

; 130  :         else
; 131  :           recycling_lim = 2*y_max - max_source_request_idx;

	lea	eax, DWORD PTR [edx+edx]
	sub	eax, DWORD PTR _max_source_request_idx$[ebp]
	jmp	SHORT $LN7@init
$LN4@init:

; 129  :           recycling_lim = y_max - 1; // Keep last row only

	lea	eax, DWORD PTR [edx-1]
$LN7@init:
	mov	DWORD PTR [ecx+32], eax

; 132  :         if (queue_idx < 0)

	test	ebx, ebx
	jns	SHORT $LN5@init

; 133  :           source_pos = recycling_lim = y_max+2; // Block use of `access_source'

	lea	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+24], eax
$LN5@init:

; 134  :         tail_idx = head_idx - 2;

	lea	eax, DWORD PTR [esi-2]

; 135  :         head = tail = NULL;

	mov	DWORD PTR [ecx+12], 0
	pop	esi
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+8], 0
	pop	ebx

; 136  :       }

	pop	ebp
	ret	20					; 00000014H
?init@kd_vlift_queue@@QAEXHHH_NH@Z ENDP			; kd_vlift_queue::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??0kd_vlift_line@@QAE@XZ
_TEXT	SEGMENT
??0kd_vlift_line@@QAE@XZ PROC				; kd_vlift_line::kd_vlift_line, COMDAT
; _this$ = ecx

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	WORD PTR [ecx+6], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	WORD PTR [ecx+18], 0
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0kd_vlift_line@@QAE@XZ ENDP				; kd_vlift_line::kd_vlift_line
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?create@kd_vlift_line@@QAEXXZ
_TEXT	SEGMENT
?create@kd_vlift_line@@QAEXXZ PROC			; kd_vlift_line::create, COMDAT
; _this$ = ecx

; 82   :       { cosets[0].create(); cosets[1].create(); }

	push	esi
	mov	esi, ecx
	call	?create@kdu_line_buf@@QAEXXZ		; kdu_line_buf::create
	lea	ecx, DWORD PTR [esi+12]
	pop	esi
	jmp	?create@kdu_line_buf@@QAEXXZ		; kdu_line_buf::create
?create@kd_vlift_line@@QAEXXZ ENDP			; kd_vlift_line::create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?pre_create@kd_vlift_line@@QAEXPAVkdu_sample_allocator@@HH_N1HH1@Z
_TEXT	SEGMENT
_allocator$ = 8						; size = 4
_even_width$ = 12					; size = 4
_odd_width$ = 16					; size = 4
_absolute$ = 20						; size = 1
_use_shorts$ = 24					; size = 1
_neg_extent$ = 28					; size = 4
_pos_extent$ = 32					; size = 4
_both_cosets$ = 36					; size = 1
?pre_create@kd_vlift_line@@QAEXPAVkdu_sample_allocator@@HH_N1HH1@Z PROC ; kd_vlift_line::pre_create, COMDAT
; _this$ = ecx

; 74   :       {

	push	ebp
	mov	ebp, esp

; 75   :         cosets[0].pre_create(allocator,even_width,absolute,use_shorts,

	mov	edx, DWORD PTR _even_width$[ebp]
	push	esi
	mov	esi, DWORD PTR _pos_extent$[ebp]
	mov	eax, esi
	push	edi
	sub	eax, edx
	mov	edi, ecx
	push	eax
	push	DWORD PTR _neg_extent$[ebp]
	push	DWORD PTR _use_shorts$[ebp]
	push	DWORD PTR _absolute$[ebp]
	push	edx
	push	DWORD PTR _allocator$[ebp]
	call	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create

; 76   :                              neg_extent,pos_extent-even_width);
; 77   :         if (both_cosets)

	cmp	BYTE PTR _both_cosets$[ebp], 0
	je	SHORT $LN2@pre_create

; 78   :           cosets[1].pre_create(allocator,odd_width,absolute,use_shorts,

	mov	eax, DWORD PTR _odd_width$[ebp]
	lea	ecx, DWORD PTR [edi+12]
	sub	esi, eax
	push	esi
	push	DWORD PTR _neg_extent$[ebp]
	push	DWORD PTR _use_shorts$[ebp]
	push	DWORD PTR _absolute$[ebp]
	push	eax
	push	DWORD PTR _allocator$[ebp]
	call	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create
$LN2@pre_create:
	pop	edi
	pop	esi

; 79   :                                neg_extent,pos_extent-odd_width);
; 80   :       }

	pop	ebp
	ret	32					; 00000020H
?pre_create@kd_vlift_line@@QAEXPAVkdu_sample_allocator@@HH_N1HH1@Z ENDP ; kd_vlift_line::pre_create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
;	COMDAT ??0kdu_synthesis@@QAE@Vkdu_resolution@@PAVkdu_sample_allocator@@_NMPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
$T2 = -4						; size = 4
_resolution$ = 8					; size = 4
_allocator$ = 12					; size = 4
_use_shorts$ = 16					; size = 1
_normalization$ = 20					; size = 4
_env$ = 24						; size = 4
_env_queue$ = 28					; size = 4
??0kdu_synthesis@@QAE@Vkdu_resolution@@PAVkdu_sample_allocator@@_NMPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z PROC ; kdu_synthesis::kdu_synthesis, COMDAT
; _this$ = ecx

; 109  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 110  :   kd_synthesis *obj = new kd_synthesis;

	push	760					; 000002f8H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 696  :     kdu_pull_ifc() { state = NULL; }

	mov	DWORD PTR [edi], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 110  :   kd_synthesis *obj = new kd_synthesis;

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	test	eax, eax
	je	SHORT $LN3@kdu_synthe
	mov	ecx, eax
	call	??0kd_synthesis@@QAE@XZ			; kd_synthesis::kd_synthesis
	mov	esi, eax
	jmp	SHORT $LN4@kdu_synthe
$LN3@kdu_synthe:
	xor	esi, esi
$LN4@kdu_synthe:

; 111  :   state = obj;
; 112  :   obj->init(resolution.access_node(),allocator,

	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edi], esi
	push	eax
	lea	ecx, DWORD PTR _resolution$[ebp]
	call	?access_node@kdu_resolution@@QAE?AVkdu_node@@XZ ; kdu_resolution::access_node
	push	DWORD PTR _env_queue$[ebp]
	movss	xmm0, DWORD PTR _normalization$[ebp]
	push	DWORD PTR _env$[ebp]
	push	0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, esi
	push	DWORD PTR _use_shorts$[ebp]
	push	DWORD PTR _allocator$[ebp]
	push	DWORD PTR [eax]
	call	?init@kd_synthesis@@QAEXVkdu_node@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kd_synthesis::init

; 113  :             use_shorts,normalization,0,env,env_queue);
; 114  : }

	mov	eax, edi
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0kdu_synthesis@@QAE@Vkdu_resolution@@PAVkdu_sample_allocator@@_NMPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ENDP ; kdu_synthesis::kdu_synthesis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
;	COMDAT ??0kdu_synthesis@@QAE@Vkdu_node@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_node$ = 8						; size = 4
_allocator$ = 12					; size = 4
_use_shorts$ = 16					; size = 1
_normalization$ = 20					; size = 4
_pull_offset$ = 24					; size = 4
_env$ = 28						; size = 4
_env_queue$ = 32					; size = 4
??0kdu_synthesis@@QAE@Vkdu_node@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z PROC ; kdu_synthesis::kdu_synthesis, COMDAT
; _this$ = ecx

; 126  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 127  :   kd_synthesis *obj = new kd_synthesis;

	push	760					; 000002f8H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 696  :     kdu_pull_ifc() { state = NULL; }

	mov	DWORD PTR [esi], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp

; 127  :   kd_synthesis *obj = new kd_synthesis;

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN3@kdu_synthe
	mov	ecx, eax
	call	??0kd_synthesis@@QAE@XZ			; kd_synthesis::kd_synthesis
	jmp	SHORT $LN4@kdu_synthe
$LN3@kdu_synthe:
	xor	eax, eax
$LN4@kdu_synthe:

; 128  :   state = obj;
; 129  :   obj->init(node,allocator,use_shorts,normalization,pull_offset,env,env_queue);

	push	DWORD PTR _env_queue$[ebp]
	movss	xmm0, DWORD PTR _normalization$[ebp]
	push	DWORD PTR _env$[ebp]
	mov	DWORD PTR [esi], eax
	push	DWORD PTR _pull_offset$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, eax
	push	DWORD PTR _use_shorts$[ebp]
	push	DWORD PTR _allocator$[ebp]
	push	DWORD PTR _node$[ebp]
	call	?init@kd_synthesis@@QAEXVkdu_node@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kd_synthesis::init

; 130  : }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
??0kdu_synthesis@@QAE@Vkdu_node@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ENDP ; kdu_synthesis::kdu_synthesis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?pull@kdu_pull_ifc@@QAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_line$ = 8						; size = 4
_env$ = 12						; size = 4
?pull@kdu_pull_ifc@@QAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z PROC ; kdu_pull_ifc::pull, COMDAT
; _this$ = ecx

; 766  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 767  :              Fills out the supplied `line' buffer's sample values before
; 768  :              returning.
; 769  :            [ARG: env]
; 770  :              If the object was constructed for multi-threaded processing
; 771  :              (see the constructors for `kdu_synthesis' and `kdu_decoder'),
; 772  :              you MUST pass a non-NULL `env' argument in here, identifying
; 773  :              the thread which is performing the `pull' call.  Otherwise,
; 774  :              the `env' argument should be ignored.
; 775  :         */
; 776  :         state->pull(line,env);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]

; 777  :       }

	pop	ebp

; 767  :              Fills out the supplied `line' buffer's sample values before
; 768  :              returning.
; 769  :            [ARG: env]
; 770  :              If the object was constructed for multi-threaded processing
; 771  :              (see the constructors for `kdu_synthesis' and `kdu_decoder'),
; 772  :              you MUST pass a non-NULL `env' argument in here, identifying
; 773  :              the thread which is performing the `pull' call.  Otherwise,
; 774  :              the `env' argument should be ignored.
; 775  :         */
; 776  :         state->pull(line,env);

	jmp	DWORD PTR [eax+8]
?pull@kdu_pull_ifc@@QAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z ENDP ; kdu_pull_ifc::pull
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??4kdu_pull_ifc@@QAEAAV0@Vkdu_decoder@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4kdu_pull_ifc@@QAEAAV0@Vkdu_decoder@@@Z PROC		; kdu_pull_ifc::operator=, COMDAT
; _this$ = ecx

; 2055 :   { state = rhs.state; return *this; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4kdu_pull_ifc@@QAEAAV0@Vkdu_decoder@@@Z ENDP		; kdu_pull_ifc::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??4kdu_pull_ifc@@QAEAAV0@Vkdu_synthesis@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4kdu_pull_ifc@@QAEAAV0@Vkdu_synthesis@@@Z PROC	; kdu_pull_ifc::operator=, COMDAT
; _this$ = ecx

; 2053 :   { state = rhs.state; return *this; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4kdu_pull_ifc@@QAEAAV0@Vkdu_synthesis@@@Z ENDP	; kdu_pull_ifc::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?exists@kdu_pull_ifc@@QAE_NXZ
_TEXT	SEGMENT
?exists@kdu_pull_ifc@@QAE_NXZ PROC			; kdu_pull_ifc::exists, COMDAT
; _this$ = ecx

; 741  :     bool exists() { return (state==NULL)?false:true; }

	cmp	DWORD PTR [ecx], 0
	setne	al
	ret	0
?exists@kdu_pull_ifc@@QAE_NXZ ENDP			; kdu_pull_ifc::exists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?start@kdu_pull_ifc@@QAEXPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_env$ = 8						; size = 4
?start@kdu_pull_ifc@@QAEXPAVkdu_thread_env@@@Z PROC	; kdu_pull_ifc::start, COMDAT
; _this$ = ecx

; 714  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 715  :              This function may be called at any point after construction
; 716  :              of a `kdu_synthesis' or `kdu_decoder' object, once you have
; 717  :              invoked the `kdu_sample_allocator::finalize' function on the
; 718  :              `kdu_sample_allocator' object used during construction.  In
; 719  :              particular, this means that you will not be creating any
; 720  :              further objects to share the storage offered by the sample
; 721  :              allocator.
; 722  :              [//]
; 723  :              It is never necessary to call this function, since it will be
; 724  :              invoked automatically, if required, when `pull' is first called.
; 725  :              Indeed for applications which are not multi-threaded (i.e.,
; 726  :              when `env' is NULL) it is pretty pointless to call this function,
; 727  :              but you can if you like.
; 728  :              [//]
; 729  :              For multi-threaded applications (i.e., when `env' is non-NULL),
; 730  :              this function enables you to get the most benefit from
; 731  :              multi-threading, since it allows the code-block processing
; 732  :              associated with any number of tile-component-subbands to be
; 733  :              started immediately.  By contrast, the `pull' function will
; 734  :              not be invoked on a subband's `kdu_decoder' object until
; 735  :              dependencies have been satisfied in other subbands, which
; 736  :              cannot generally happen until a full row of code-blocks have
; 737  :              been decoded in a first subband.
; 738  :         */
; 739  :         state->start(env);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]

; 740  :       }

	pop	ebp

; 715  :              This function may be called at any point after construction
; 716  :              of a `kdu_synthesis' or `kdu_decoder' object, once you have
; 717  :              invoked the `kdu_sample_allocator::finalize' function on the
; 718  :              `kdu_sample_allocator' object used during construction.  In
; 719  :              particular, this means that you will not be creating any
; 720  :              further objects to share the storage offered by the sample
; 721  :              allocator.
; 722  :              [//]
; 723  :              It is never necessary to call this function, since it will be
; 724  :              invoked automatically, if required, when `pull' is first called.
; 725  :              Indeed for applications which are not multi-threaded (i.e.,
; 726  :              when `env' is NULL) it is pretty pointless to call this function,
; 727  :              but you can if you like.
; 728  :              [//]
; 729  :              For multi-threaded applications (i.e., when `env' is non-NULL),
; 730  :              this function enables you to get the most benefit from
; 731  :              multi-threading, since it allows the code-block processing
; 732  :              associated with any number of tile-component-subbands to be
; 733  :              started immediately.  By contrast, the `pull' function will
; 734  :              not be invoked on a subband's `kdu_decoder' object until
; 735  :              dependencies have been satisfied in other subbands, which
; 736  :              cannot generally happen until a full row of code-blocks have
; 737  :              been decoded in a first subband.
; 738  :         */
; 739  :         state->start(env);

	jmp	DWORD PTR [eax+4]
?start@kdu_pull_ifc@@QAEXPAVkdu_thread_env@@@Z ENDP	; kdu_pull_ifc::start
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?destroy@kdu_pull_ifc@@QAEXXZ
_TEXT	SEGMENT
?destroy@kdu_pull_ifc@@QAEXXZ PROC			; kdu_pull_ifc::destroy, COMDAT
; _this$ = ecx

; 703  :       {

	push	esi
	mov	esi, ecx

; 704  :         if (state != NULL) delete state;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@destroy
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN6@destroy:

; 705  :         state = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 706  :       }

	ret	0
?destroy@kdu_pull_ifc@@QAEXXZ ENDP			; kdu_pull_ifc::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??0kdu_pull_ifc@@QAE@XZ
_TEXT	SEGMENT
??0kdu_pull_ifc@@QAE@XZ PROC				; kdu_pull_ifc::kdu_pull_ifc, COMDAT
; _this$ = ecx

; 696  :     kdu_pull_ifc() { state = NULL; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0kdu_pull_ifc@@QAE@XZ ENDP				; kdu_pull_ifc::kdu_pull_ifc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??_Gkdu_pull_ifc_base@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkdu_pull_ifc_base@@MAEPAXI@Z PROC			; kdu_pull_ifc_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 669  :     virtual ~kdu_pull_ifc_base() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_pull_ifc_base@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkdu_pull_ifc_base@@MAEPAXI@Z ENDP			; kdu_pull_ifc_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0kdu_pull_ifc_base@@QAE@XZ
_TEXT	SEGMENT
??0kdu_pull_ifc_base@@QAE@XZ PROC			; kdu_pull_ifc_base::kdu_pull_ifc_base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kdu_pull_ifc_base@@6B@
	mov	eax, ecx
	ret	0
??0kdu_pull_ifc_base@@QAE@XZ ENDP			; kdu_pull_ifc_base::kdu_pull_ifc_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??1kdu_pull_ifc_base@@MAE@XZ
_TEXT	SEGMENT
??1kdu_pull_ifc_base@@MAE@XZ PROC			; kdu_pull_ifc_base::~kdu_pull_ifc_base, COMDAT
; _this$ = ecx

; 669  :     virtual ~kdu_pull_ifc_base() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_pull_ifc_base@@6B@
	ret	0
??1kdu_pull_ifc_base@@MAE@XZ ENDP			; kdu_pull_ifc_base::~kdu_pull_ifc_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_width@kdu_line_buf@@QAEHXZ
_TEXT	SEGMENT
?get_width@kdu_line_buf@@QAEHXZ PROC			; kdu_line_buf::get_width, COMDAT
; _this$ = ecx

; 537  :       /* [SYNOPSIS]
; 538  :            Returns 0 if the object has not been created.  Otherwise, returns
; 539  :            the nominal width of the line.  Remember that the arrays returned
; 540  :            by `get_buf16' and `get_buf32' are typically larger than the actual
; 541  :            line width, as explained in the comments appearing with the
; 542  :            `pre_create' function.
; 543  :       */
; 544  :         return width;

	mov	eax, DWORD PTR [ecx]

; 545  :       }

	ret	0
?get_width@kdu_line_buf@@QAEHXZ ENDP			; kdu_line_buf::get_width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ
_TEXT	SEGMENT
?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ PROC	; kdu_line_buf::get_buf16, COMDAT
; _this$ = ecx

; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN3@get_buf16
	mov	eax, DWORD PTR [ecx+8]

; 414  :       }

	ret	0
$LN3@get_buf16:

; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	xor	eax, eax

; 414  :       }

	ret	0
?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ ENDP	; kdu_line_buf::get_buf16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ
_TEXT	SEGMENT
?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ PROC	; kdu_line_buf::get_buf32, COMDAT
; _this$ = ecx

; 393  :       /* [SYNOPSIS]
; 394  :            Returns NULL if the sample values are of type `kdu_sample16'
; 395  :            instead of `kdu_sample32', or the buffer has not yet been
; 396  :            created.  Otherwise, returns an array which supports accesses
; 397  :            at least with indices in the range 0 to `width'-1, but typically
; 398  :            beyond these bounds -- see `pre_create' for an explanation of
; 399  :            extended access bounds.
; 400  :       */
; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN3@get_buf32
	xor	eax, eax

; 402  :       }

	ret	0
$LN3@get_buf32:

; 393  :       /* [SYNOPSIS]
; 394  :            Returns NULL if the sample values are of type `kdu_sample16'
; 395  :            instead of `kdu_sample32', or the buffer has not yet been
; 396  :            created.  Otherwise, returns an array which supports accesses
; 397  :            at least with indices in the range 0 to `width'-1, but typically
; 398  :            beyond these bounds -- see `pre_create' for an explanation of
; 399  :            extended access bounds.
; 400  :       */
; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	eax, DWORD PTR [ecx+8]

; 402  :       }

	ret	0
?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ ENDP	; kdu_line_buf::get_buf32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?destroy@kdu_line_buf@@QAEXXZ
_TEXT	SEGMENT
?destroy@kdu_line_buf@@QAEXXZ PROC			; kdu_line_buf::destroy, COMDAT
; _this$ = ecx

; 380  :       /* [SYNOPSIS]
; 381  :            Restores the object to its uninitialized state ready for a new
; 382  :            `pre_create' call.  Does not actually destroy any storage, since
; 383  :            the `kdu_sample_allocator' object from which storage is served
; 384  :            does not permit individual deallocation of storage blocks.
; 385  :       */
; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx], 0
	mov	WORD PTR [ecx+6], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx+8], 0

; 388  :       }

	ret	0
?destroy@kdu_line_buf@@QAEXXZ ENDP			; kdu_line_buf::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?create@kdu_line_buf@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?create@kdu_line_buf@@QAEXXZ PROC			; kdu_line_buf::create, COMDAT
; _this$ = ecx

; 361  :       {

	push	ebp
	mov	ebp, esp
	push	ecx

; 362  :       /* [SYNOPSIS]
; 363  :            Finalizes creation of storage which was initiated by `pre_create'.
; 364  :            Does nothing at all if the `pre_create' function was not called,
; 365  :            or the object was previously created and has not been destroyed.
; 366  :            Otherwise, you may not call this function until the
; 367  :            `kdu_sample_allocator' object supplied to `pre_create' has had
; 368  :            its `finalize' member function called.
; 369  :       */
; 370  :         if (!pre_created)

	cmp	BYTE PTR [ecx+7], 0
	mov	DWORD PTR _this$1$[ebp], ecx
	je	SHORT $LN4@create

; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)

	test	BYTE PTR [ecx+6], 2
	push	ebx

; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);

	mov	ebx, DWORD PTR [ecx+8]
	push	esi
	mov	BYTE PTR [ecx+7], 0
	push	edi
	movzx	edi, BYTE PTR [ecx+4]

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.
; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+16]

; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);

	movzx	ecx, BYTE PTR [ecx+5]
	je	SHORT $LN3@create

; 217  :         before = (before+7)&~7; // Round up to nearest multiple of 16 bytes.

	add	edi, 7
	and	edi, -8					; fffffff8H

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.
; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	lea	esi, DWORD PTR [eax+edi*2]
	mov	eax, DWORD PTR _this$1$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR [eax]
	add	eax, 7
	add	eax, ecx
	and	eax, -8					; fffffff8H
	add	eax, edi
	pop	edi
	lea	eax, DWORD PTR [edx+eax*2]

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.
; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	DWORD PTR [ebx+8], eax

; 375  :         else
; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [eax+8], esi
	pop	esi
	pop	ebx

; 377  :       }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@create:

; 221  :         assert(bytes_used <= bytes_reserved);
; 222  :         return result;
; 223  :       }
; 224  :     kdu_sample32 *alloc32(int before, int after)
; 225  :       {
; 226  :       /* [SYNOPSIS]
; 227  :            Same as `alloc16', except that it allocates storage for arrays of
; 228  :            32-bit quantities.  Again, the returned pointer is guaranteed to
; 229  :            be aligned on a 16-byte boundary.
; 230  :       */
; 231  :         assert(!pre_creation_phase);
; 232  :         before = (before+3)&~3; // Round up to nearest multiple of 16 bytes.

	add	edi, 3
	and	edi, -4					; fffffffcH

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.
; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	lea	esi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _this$1$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR [eax]
	add	eax, 3
	add	eax, ecx
	and	eax, -4					; fffffffcH
	add	eax, edi
	pop	edi
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ebx+8], eax

; 375  :         else
; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [eax+8], esi
	pop	esi
	pop	ebx
$LN4@create:

; 377  :       }

	mov	esp, ebp
	pop	ebp
	ret	0
?create@kdu_line_buf@@QAEXXZ ENDP			; kdu_line_buf::create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z
_TEXT	SEGMENT
_allocator$ = 8						; size = 4
_width$ = 12						; size = 4
_absolute$ = 16						; size = 1
_use_shorts$ = 20					; size = 1
_extend_left$ = 24					; size = 4
_extend_right$ = 28					; size = 4
?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z PROC ; kdu_line_buf::pre_create, COMDAT
; _this$ = ecx

; 294  :       {

	push	ebp
	mov	ebp, esp

; 295  :       /* [SYNOPSIS]
; 296  :            Declares the characteristics of the internal storage which will
; 297  :            later be created by `create'.  If `use_shorts' is true, the sample
; 298  :            values will have 16 bits each and normalized values will use a
; 299  :            fixed point representation with KDU_FIX_POINT fraction bits.
; 300  :            Otherwise, the sample values have 32 bits each and normalized
; 301  :            values use a true floating point representation.
; 302  :            [//]
; 303  :            This function essentially calls `allocator->pre_create', requesting
; 304  :            enough storage for a line with `width' samples, providing for legal
; 305  :            accesses up to `extend_left' samples before the beginning of the
; 306  :            line and `extend_right' samples beyond the end of the line.
; 307  :            [//]
; 308  :            Moreover, the returned line buffer is aligned on a 16-byte
; 309  :            boundary, the `extend_left' and `extend_right' values are rounded
; 310  :            up to the nearest multiple of 16 bytes, and the length of the
; 311  :            right-extended buffer is also rounded up to a multiple of 16 bytes.
; 312  :            Finally, it is possible to read at least 16 bytes beyond the
; 313  :            end of the extended region, although writes to these extra 16
; 314  :            bytes might overwrite data belonging to a different line.
; 315  :          [ARG: allocator]
; 316  :            Pointer to the object which will later be used to complete the
; 317  :            allocation of storage for the line.  The pointer is saved
; 318  :            internally until such time as the `create' function is called, so
; 319  :            you must be careful not to delete this object.  You must also be
; 320  :            careful to call its `kdu_sample_allocator::finalize' function
; 321  :            before calling `create'.
; 322  :          [ARG: width]
; 323  :            Nominal width of (number of samples in) the line.  Note that space
; 324  :            reserved for access to `extend_left' samples to the left and
; 325  :            `extend_right' samples to the right.  Moreover, additional
; 326  :            samples may often be accessed to the left and right of the nominal
; 327  :            line boundaries due to the alignment policy discussed above.
; 328  :          [ARG: absolute]
; 329  :            If true, the sample values in the line buffer are to be used in
; 330  :            JPEG2000's reversible processing path, which works with absolute
; 331  :            integers.  otherwise, the line is prepared for use with the
; 332  :            irreversible processing path, which works with normalized
; 333  :            (floating or fixed point) quantities.
; 334  :          [ARG: use_shorts]
; 335  :            If true, space is allocated for 16-bit sample values
; 336  :            (array entries will be of type `kdu_sample16').  Otherwise, the
; 337  :            line buffer will hold samples of type `kdu_sample32'.
; 338  :          [ARG: extend_left]
; 339  :            This quantity should be small, since it will be represented
; 340  :            internally using 8-bit numbers, after rounding up to an
; 341  :            appropriately aligned value.  It would be unusual to select
; 342  :            values larger than 16 or perhaps 32.
; 343  :          [ARG: extend_right]
; 344  :            This quantity should be small, since it will be represented
; 345  :            internally using 8-bit numbers, after rounding up to an
; 346  :            appropriately aligned value.  It would be unusual to select
; 347  :            values larger than 16 or perhaps 32.
; 348  :       */
; 349  :         assert((!pre_created) && (this->allocator == NULL)); this->width=width;
; 350  :         flags = (use_shorts)?KD_LINE_BUF_SHORTS:0; 
; 351  :         flags |= (absolute)?KD_LINE_BUF_ABSOLUTE:0;

	cmp	BYTE PTR _absolute$[ebp], 0
	mov	eax, DWORD PTR _width$[ebp]
	push	ebx
	setne	dl
	push	esi
	mov	esi, ecx
	mov	cl, BYTE PTR _use_shorts$[ebp]
	push	edi

; 352  :         this->allocator = allocator;

	mov	edi, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [esi], eax
	mov	al, cl
	neg	al
	mov	DWORD PTR [esi+8], edi
	sbb	al, al
	and	al, 2
	or	dl, al

; 353  :         buf_before = (kdu_byte) extend_left; // Rounded up automatically
; 354  :         buf_after = (kdu_byte)

	test	cl, cl
	mov	ecx, DWORD PTR _extend_right$[ebp]
	mov	al, cl
	setne	bl
	mov	BYTE PTR [esi+6], dl
	mov	edx, DWORD PTR _extend_left$[ebp]
	neg	al
	mov	BYTE PTR [esi+4], dl
	lea	ebx, DWORD PTR [ebx*4+3]
	and	bl, al
	add	bl, cl

; 355  :           (extend_right + ((-extend_right) & ((use_shorts)?7:3)));
; 356  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);

	movzx	ecx, dl

; 180  :         if (!use_shorts)

	mov	dl, BYTE PTR _use_shorts$[ebp]
	add	ecx, ecx

; 355  :           (extend_right + ((-extend_right) & ((use_shorts)?7:3)));
; 356  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);

	movzx	eax, bl
	mov	BYTE PTR [esi+5], bl

; 179  :         before+=before; after+=after; // Two bytes per sample

	mov	ebx, DWORD PTR _width$[ebp]
	add	eax, ebx
	add	eax, eax

; 180  :         if (!use_shorts)

	test	dl, dl
	jne	SHORT $LN4@pre_create

; 181  :           { before+=before; after+=after; } // Four bytes per sample

	add	ecx, ecx
	add	eax, eax
$LN4@pre_create:

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	ecx, 15					; 0000000fH
	add	eax, 15					; 0000000fH
	and	eax, -16				; fffffff0H
	and	ecx, -16				; fffffff0H
	add	ecx, eax
	add	DWORD PTR [edi+4], ecx

; 357  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);

	movzx	eax, BYTE PTR [esi+5]
	movzx	ecx, BYTE PTR [esi+4]

; 179  :         before+=before; after+=after; // Two bytes per sample

	add	eax, ebx
	add	ecx, ecx
	add	eax, eax

; 180  :         if (!use_shorts)

	test	dl, dl
	jne	SHORT $LN7@pre_create

; 181  :           { before+=before; after+=after; } // Four bytes per sample

	add	ecx, ecx
	add	eax, eax
$LN7@pre_create:

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	ecx, 15					; 0000000fH
	add	eax, 15					; 0000000fH
	and	ecx, -16				; fffffff0H
	and	eax, -16				; fffffff0H
	add	ecx, DWORD PTR [edi+4]
	add	eax, ecx
	mov	DWORD PTR [edi+4], eax
	pop	edi

; 358  :         pre_created = true;

	mov	BYTE PTR [esi+7], 1
	pop	esi
	pop	ebx

; 359  :       }

	pop	ebp
	ret	24					; 00000018H
?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ENDP ; kdu_line_buf::pre_create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??0kdu_line_buf@@QAE@XZ
_TEXT	SEGMENT
??0kdu_line_buf@@QAE@XZ PROC				; kdu_line_buf::kdu_line_buf, COMDAT
; _this$ = ecx

; 291  :     void pre_create(kdu_sample_allocator *allocator,
; 292  :                     int width, bool absolute, bool use_shorts,
; 293  :                     int extend_left=2, int extend_right=2)
; 294  :       {
; 295  :       /* [SYNOPSIS]
; 296  :            Declares the characteristics of the internal storage which will
; 297  :            later be created by `create'.  If `use_shorts' is true, the sample
; 298  :            values will have 16 bits each and normalized values will use a
; 299  :            fixed point representation with KDU_FIX_POINT fraction bits.
; 300  :            Otherwise, the sample values have 32 bits each and normalized
; 301  :            values use a true floating point representation.
; 302  :            [//]
; 303  :            This function essentially calls `allocator->pre_create', requesting
; 304  :            enough storage for a line with `width' samples, providing for legal
; 305  :            accesses up to `extend_left' samples before the beginning of the
; 306  :            line and `extend_right' samples beyond the end of the line.
; 307  :            [//]
; 308  :            Moreover, the returned line buffer is aligned on a 16-byte
; 309  :            boundary, the `extend_left' and `extend_right' values are rounded
; 310  :            up to the nearest multiple of 16 bytes, and the length of the
; 311  :            right-extended buffer is also rounded up to a multiple of 16 bytes.
; 312  :            Finally, it is possible to read at least 16 bytes beyond the
; 313  :            end of the extended region, although writes to these extra 16
; 314  :            bytes might overwrite data belonging to a different line.
; 315  :          [ARG: allocator]
; 316  :            Pointer to the object which will later be used to complete the
; 317  :            allocation of storage for the line.  The pointer is saved
; 318  :            internally until such time as the `create' function is called, so
; 319  :            you must be careful not to delete this object.  You must also be
; 320  :            careful to call its `kdu_sample_allocator::finalize' function
; 321  :            before calling `create'.
; 322  :          [ARG: width]
; 323  :            Nominal width of (number of samples in) the line.  Note that space
; 324  :            reserved for access to `extend_left' samples to the left and
; 325  :            `extend_right' samples to the right.  Moreover, additional
; 326  :            samples may often be accessed to the left and right of the nominal
; 327  :            line boundaries due to the alignment policy discussed above.
; 328  :          [ARG: absolute]
; 329  :            If true, the sample values in the line buffer are to be used in
; 330  :            JPEG2000's reversible processing path, which works with absolute
; 331  :            integers.  otherwise, the line is prepared for use with the
; 332  :            irreversible processing path, which works with normalized
; 333  :            (floating or fixed point) quantities.
; 334  :          [ARG: use_shorts]
; 335  :            If true, space is allocated for 16-bit sample values
; 336  :            (array entries will be of type `kdu_sample16').  Otherwise, the
; 337  :            line buffer will hold samples of type `kdu_sample32'.
; 338  :          [ARG: extend_left]
; 339  :            This quantity should be small, since it will be represented
; 340  :            internally using 8-bit numbers, after rounding up to an
; 341  :            appropriately aligned value.  It would be unusual to select
; 342  :            values larger than 16 or perhaps 32.
; 343  :          [ARG: extend_right]
; 344  :            This quantity should be small, since it will be represented
; 345  :            internally using 8-bit numbers, after rounding up to an
; 346  :            appropriately aligned value.  It would be unusual to select
; 347  :            values larger than 16 or perhaps 32.
; 348  :       */
; 349  :         assert((!pre_created) && (this->allocator == NULL)); this->width=width;
; 350  :         flags = (use_shorts)?KD_LINE_BUF_SHORTS:0; 
; 351  :         flags |= (absolute)?KD_LINE_BUF_ABSOLUTE:0;
; 352  :         this->allocator = allocator;
; 353  :         buf_before = (kdu_byte) extend_left; // Rounded up automatically
; 354  :         buf_after = (kdu_byte)
; 355  :           (extend_right + ((-extend_right) & ((use_shorts)?7:3)));
; 356  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);
; 357  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);
; 358  :         pre_created = true;
; 359  :       }
; 360  :     void create()
; 361  :       {
; 362  :       /* [SYNOPSIS]
; 363  :            Finalizes creation of storage which was initiated by `pre_create'.
; 364  :            Does nothing at all if the `pre_create' function was not called,
; 365  :            or the object was previously created and has not been destroyed.
; 366  :            Otherwise, you may not call this function until the
; 367  :            `kdu_sample_allocator' object supplied to `pre_create' has had
; 368  :            its `finalize' member function called.
; 369  :       */
; 370  :         if (!pre_created)
; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)
; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);
; 375  :         else
; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);
; 377  :       }
; 378  :     void destroy()
; 379  :       {
; 380  :       /* [SYNOPSIS]
; 381  :            Restores the object to its uninitialized state ready for a new
; 382  :            `pre_create' call.  Does not actually destroy any storage, since
; 383  :            the `kdu_sample_allocator' object from which storage is served
; 384  :            does not permit individual deallocation of storage blocks.
; 385  :       */
; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx], 0

; 290  :     kdu_line_buf() { destroy(); }

	mov	eax, ecx

; 291  :     void pre_create(kdu_sample_allocator *allocator,
; 292  :                     int width, bool absolute, bool use_shorts,
; 293  :                     int extend_left=2, int extend_right=2)
; 294  :       {
; 295  :       /* [SYNOPSIS]
; 296  :            Declares the characteristics of the internal storage which will
; 297  :            later be created by `create'.  If `use_shorts' is true, the sample
; 298  :            values will have 16 bits each and normalized values will use a
; 299  :            fixed point representation with KDU_FIX_POINT fraction bits.
; 300  :            Otherwise, the sample values have 32 bits each and normalized
; 301  :            values use a true floating point representation.
; 302  :            [//]
; 303  :            This function essentially calls `allocator->pre_create', requesting
; 304  :            enough storage for a line with `width' samples, providing for legal
; 305  :            accesses up to `extend_left' samples before the beginning of the
; 306  :            line and `extend_right' samples beyond the end of the line.
; 307  :            [//]
; 308  :            Moreover, the returned line buffer is aligned on a 16-byte
; 309  :            boundary, the `extend_left' and `extend_right' values are rounded
; 310  :            up to the nearest multiple of 16 bytes, and the length of the
; 311  :            right-extended buffer is also rounded up to a multiple of 16 bytes.
; 312  :            Finally, it is possible to read at least 16 bytes beyond the
; 313  :            end of the extended region, although writes to these extra 16
; 314  :            bytes might overwrite data belonging to a different line.
; 315  :          [ARG: allocator]
; 316  :            Pointer to the object which will later be used to complete the
; 317  :            allocation of storage for the line.  The pointer is saved
; 318  :            internally until such time as the `create' function is called, so
; 319  :            you must be careful not to delete this object.  You must also be
; 320  :            careful to call its `kdu_sample_allocator::finalize' function
; 321  :            before calling `create'.
; 322  :          [ARG: width]
; 323  :            Nominal width of (number of samples in) the line.  Note that space
; 324  :            reserved for access to `extend_left' samples to the left and
; 325  :            `extend_right' samples to the right.  Moreover, additional
; 326  :            samples may often be accessed to the left and right of the nominal
; 327  :            line boundaries due to the alignment policy discussed above.
; 328  :          [ARG: absolute]
; 329  :            If true, the sample values in the line buffer are to be used in
; 330  :            JPEG2000's reversible processing path, which works with absolute
; 331  :            integers.  otherwise, the line is prepared for use with the
; 332  :            irreversible processing path, which works with normalized
; 333  :            (floating or fixed point) quantities.
; 334  :          [ARG: use_shorts]
; 335  :            If true, space is allocated for 16-bit sample values
; 336  :            (array entries will be of type `kdu_sample16').  Otherwise, the
; 337  :            line buffer will hold samples of type `kdu_sample32'.
; 338  :          [ARG: extend_left]
; 339  :            This quantity should be small, since it will be represented
; 340  :            internally using 8-bit numbers, after rounding up to an
; 341  :            appropriately aligned value.  It would be unusual to select
; 342  :            values larger than 16 or perhaps 32.
; 343  :          [ARG: extend_right]
; 344  :            This quantity should be small, since it will be represented
; 345  :            internally using 8-bit numbers, after rounding up to an
; 346  :            appropriately aligned value.  It would be unusual to select
; 347  :            values larger than 16 or perhaps 32.
; 348  :       */
; 349  :         assert((!pre_created) && (this->allocator == NULL)); this->width=width;
; 350  :         flags = (use_shorts)?KD_LINE_BUF_SHORTS:0; 
; 351  :         flags |= (absolute)?KD_LINE_BUF_ABSOLUTE:0;
; 352  :         this->allocator = allocator;
; 353  :         buf_before = (kdu_byte) extend_left; // Rounded up automatically
; 354  :         buf_after = (kdu_byte)
; 355  :           (extend_right + ((-extend_right) & ((use_shorts)?7:3)));
; 356  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);
; 357  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);
; 358  :         pre_created = true;
; 359  :       }
; 360  :     void create()
; 361  :       {
; 362  :       /* [SYNOPSIS]
; 363  :            Finalizes creation of storage which was initiated by `pre_create'.
; 364  :            Does nothing at all if the `pre_create' function was not called,
; 365  :            or the object was previously created and has not been destroyed.
; 366  :            Otherwise, you may not call this function until the
; 367  :            `kdu_sample_allocator' object supplied to `pre_create' has had
; 368  :            its `finalize' member function called.
; 369  :       */
; 370  :         if (!pre_created)
; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)
; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);
; 375  :         else
; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);
; 377  :       }
; 378  :     void destroy()
; 379  :       {
; 380  :       /* [SYNOPSIS]
; 381  :            Restores the object to its uninitialized state ready for a new
; 382  :            `pre_create' call.  Does not actually destroy any storage, since
; 383  :            the `kdu_sample_allocator' object from which storage is served
; 384  :            does not permit individual deallocation of storage blocks.
; 385  :       */
; 386  :         width=0; flags=0; pre_created=false;

	mov	WORD PTR [ecx+6], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx+8], 0

; 290  :     kdu_line_buf() { destroy(); }

	ret	0
??0kdu_line_buf@@QAE@XZ ENDP				; kdu_line_buf::kdu_line_buf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z
_TEXT	SEGMENT
_before$ = 8						; size = 4
_after$ = 12						; size = 4
?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z PROC ; kdu_sample_allocator::alloc32, COMDAT
; _this$ = ecx

; 225  :       {

	push	ebp
	mov	ebp, esp
	push	esi

; 226  :       /* [SYNOPSIS]
; 227  :            Same as `alloc16', except that it allocates storage for arrays of
; 228  :            32-bit quantities.  Again, the returned pointer is guaranteed to
; 229  :            be aligned on a 16-byte boundary.
; 230  :       */
; 231  :         assert(!pre_creation_phase);
; 232  :         before = (before+3)&~3; // Round up to nearest multiple of 16 bytes.

	mov	esi, DWORD PTR _before$[ebp]
	push	edi
	mov	edi, ecx
	add	esi, 3

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.

	mov	ecx, DWORD PTR _after$[ebp]
	and	esi, -4					; fffffffcH
	add	ecx, 3
	and	ecx, -4					; fffffffcH

; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+esi*4]
	add	eax, edx
	add	ecx, esi
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [edi+8], ecx
	pop	edi
	pop	esi

; 236  :         assert(bytes_used <= bytes_reserved);
; 237  :         return result;
; 238  :       }

	pop	ebp
	ret	8
?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z ENDP ; kdu_sample_allocator::alloc32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z
_TEXT	SEGMENT
_before$ = 8						; size = 4
_after$ = 12						; size = 4
?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z PROC ; kdu_sample_allocator::alloc16, COMDAT
; _this$ = ecx

; 203  :       {

	push	ebp
	mov	ebp, esp
	push	esi

; 204  :       /* [SYNOPSIS]
; 205  :            Allocate an array with space for `before' entries prior to the
; 206  :            returned pointer and `after' entries after the returned pointer
; 207  :            (including the entry to which the pointer refers).  The returned
; 208  :            pointer is guaranteed to be aligned on a 16-byte boundary.
; 209  :            The pointer may be interpreted as the location of an array which
; 210  :            can accept signed indices, n, in the range -`before' <= n < `after'.
; 211  :            [//]
; 212  :            Before calling this function, you must have pre-allocated sufficient
; 213  :            space through calls to `pre_alloc' and you must have called the
; 214  :            `finalize' member function.
; 215  :       */
; 216  :         assert(!pre_creation_phase);
; 217  :         before = (before+7)&~7; // Round up to nearest multiple of 16 bytes.

	mov	esi, DWORD PTR _before$[ebp]
	push	edi
	mov	edi, ecx
	add	esi, 7

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.

	mov	ecx, DWORD PTR _after$[ebp]
	and	esi, -8					; fffffff8H
	add	ecx, 7
	and	ecx, -8					; fffffff8H

; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+esi*2]
	add	eax, edx
	add	ecx, esi
	lea	ecx, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR [edi+8], ecx
	pop	edi
	pop	esi

; 221  :         assert(bytes_used <= bytes_reserved);
; 222  :         return result;
; 223  :       }

	pop	ebp
	ret	8
?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z ENDP ; kdu_sample_allocator::alloc16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z
_TEXT	SEGMENT
_use_shorts$ = 8					; size = 1
_before$ = 12						; size = 4
_after$ = 16						; size = 4
_num_requests$ = 20					; size = 4
?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z PROC	; kdu_sample_allocator::pre_alloc, COMDAT
; _this$ = ecx

; 168  :       {

	push	ebp
	mov	ebp, esp

; 169  :       /* [SYNOPSIS]
; 170  :            Reserves enough storage for `num_requests' later calls to `alloc16'
; 171  :            (if `use_shorts' is true) or `alloc32' (if `use_shorts' is false).
; 172  :            Space is reserved such that each of these `num_requests' allocations
; 173  :            can return an appropriately aligned pointer to an array which offers
; 174  :            entries at locations n in the range -`before' <= n < `after', where
; 175  :            each entry is of type `kdu_sample16' (if `use_shorts'=true) or
; 176  :            `kdu_sample32' (if `use_shorts'=false).
; 177  :       */
; 178  :         assert(pre_creation_phase);
; 179  :         before+=before; after+=after; // Two bytes per sample

	mov	eax, DWORD PTR _before$[ebp]
	mov	edx, ecx
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _after$[ebp]
	add	eax, eax

; 180  :         if (!use_shorts)

	cmp	BYTE PTR _use_shorts$[ebp], 0
	jne	SHORT $LN2@pre_alloc

; 181  :           { before+=before; after+=after; } // Four bytes per sample

	add	ecx, ecx
	add	eax, eax
$LN2@pre_alloc:

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	ecx, 15					; 0000000fH
	add	eax, 15					; 0000000fH
	and	ecx, -16				; fffffff0H
	and	eax, -16				; fffffff0H
	add	ecx, eax
	imul	ecx, DWORD PTR _num_requests$[ebp]
	add	DWORD PTR [edx+4], ecx

; 183  :       }

	pop	ebp
	ret	16					; 00000010H
?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z ENDP	; kdu_sample_allocator::pre_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??7kdu_node@@QAE_NXZ
_TEXT	SEGMENT
??7kdu_node@@QAE_NXZ PROC				; kdu_node::operator!, COMDAT
; _this$ = ecx

; 4994 :     bool operator!() { return (state==NULL)?true:false; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
??7kdu_node@@QAE_NXZ ENDP				; kdu_node::operator!
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?exists@kdu_node@@QAE_NXZ
_TEXT	SEGMENT
?exists@kdu_node@@QAE_NXZ PROC				; kdu_node::exists, COMDAT
; _this$ = ecx

; 4988 :     bool exists() { return (state==NULL)?false:true; }

	cmp	DWORD PTR [ecx], 0
	setne	al
	ret	0
?exists@kdu_node@@QAE_NXZ ENDP				; kdu_node::exists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??7kdu_dims@@QAE_NXZ
_TEXT	SEGMENT
??7kdu_dims@@QAE_NXZ PROC				; kdu_dims::operator!, COMDAT
; _this$ = ecx

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR [ecx+12], 0
	jle	SHORT $LN3@operator
	cmp	DWORD PTR [ecx+8], 0
	jle	SHORT $LN3@operator
	xor	al, al
	ret	0
$LN3@operator:
	mov	al, 1
	ret	0
??7kdu_dims@@QAE_NXZ ENDP				; kdu_dims::operator!
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_dims@@QAE@XZ
_TEXT	SEGMENT
??0kdu_dims@@QAE@XZ PROC				; kdu_dims::kdu_dims, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0

; 304  :     kdu_dims() {};

	mov	eax, ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0

; 304  :     kdu_dims() {};

	ret	0
??0kdu_dims@@QAE@XZ ENDP				; kdu_dims::kdu_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??Hkdu_coords@@QAE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??Hkdu_coords@@QAE?AU0@ABU0@@Z PROC			; kdu_coords::operator+, COMDAT
; _this$ = ecx

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	esi
	mov	esi, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [esi+4]
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	pop	esi
	pop	ebp
	ret	8
??Hkdu_coords@@QAE?AU0@ABU0@@Z ENDP			; kdu_coords::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_coords@@QAE@XZ
_TEXT	SEGMENT
??0kdu_coords@@QAE@XZ PROC				; kdu_coords::kdu_coords, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kdu_coords@@QAE@XZ ENDP				; kdu_coords::kdu_coords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?release_lock@kdu_thread_entity@@QAEXH@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
?release_lock@kdu_thread_entity@@QAEXH@Z PROC		; kdu_thread_entity::release_lock, COMDAT
; _this$ = ecx

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _lock_id$[ebp]

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [ecx+eax*8+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN5@release_lo
	mov	DWORD PTR _lock_id$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	jmp	DWORD PTR __imp__ReleaseMutex@4
$LN5@release_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
	ret	4
?release_lock@kdu_thread_entity@@QAEXH@Z ENDP		; kdu_thread_entity::release_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?acquire_lock@kdu_thread_entity@@QAEXH_N@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
$T1 = 12						; size = 4
_allow_exceptions$ = 12					; size = 1
?acquire_lock@kdu_thread_entity@@QAEXH_N@Z PROC		; kdu_thread_entity::acquire_lock, COMDAT
; _this$ = ecx

; 1024 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp

; 1025 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	cmp	BYTE PTR _allow_exceptions$[ebp], 0
	mov	eax, DWORD PTR _lock_id$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edx, DWORD PTR [esi+28]
	lea	edi, DWORD PTR [edx+eax*8]
	je	SHORT $LN2@acquire_lo
	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN9@acquire_lo
$LN2@acquire_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@acquire_lo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN6@acquire_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+4], esi
	pop	edi
	pop	esi
	pop	ebp
	ret	8
$LN9@acquire_lo:

; 1025 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN11@acquire_lo:
$LN8@acquire_lo:
	int	3
?acquire_lock@kdu_thread_entity@@QAEXH_N@Z ENDP		; kdu_thread_entity::acquire_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?unlock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?unlock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::unlock, COMDAT
; _this$ = ecx

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@unlock
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	cmp	eax, 1
	jne	SHORT $LN3@unlock
	mov	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
$LN3@unlock:

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	xor	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
?unlock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?lock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?lock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::lock, COMDAT
; _this$ = ecx

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@lock
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	SHORT $LN3@lock
	mov	al, 1

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
$LN3@lock:

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	xor	al, al

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
?lock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\synthesis.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
