; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\transform\multi_transform.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	??1kdu_worker@@UAE@XZ				; kdu_worker::~kdu_worker
PUBLIC	??_Gkdu_worker@@UAEPAXI@Z			; kdu_worker::`scalar deleting destructor'
PUBLIC	??1kdu_kernels@@QAE@XZ				; kdu_kernels::~kdu_kernels
PUBLIC	??0kdu_line_buf@@QAE@XZ				; kdu_line_buf::kdu_line_buf
PUBLIC	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create
PUBLIC	??1kd_multi_analysis_base@@UAE@XZ		; kd_multi_analysis_base::~kd_multi_analysis_base
PUBLIC	??_Gkd_multi_analysis_base@@UAEPAXI@Z		; kd_multi_analysis_base::`scalar deleting destructor'
PUBLIC	?create@kdu_multi_analysis@@QAE_JVkdu_codestream@@Vkdu_tile@@_NPAVkdu_roi_image@@2HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ; kdu_multi_analysis::create
PUBLIC	??1kd_multi_synthesis_base@@UAE@XZ		; kd_multi_synthesis_base::~kd_multi_synthesis_base
PUBLIC	??_Gkd_multi_synthesis_base@@UAEPAXI@Z		; kd_multi_synthesis_base::`scalar deleting destructor'
PUBLIC	?create@kdu_multi_synthesis@@QAE_JVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ; kdu_multi_synthesis::create
PUBLIC	??0kd_multi_line@@QAE@XZ			; kd_multi_line::kd_multi_line
PUBLIC	?reset@kd_multi_line@@QAEXHM@Z			; kd_multi_line::reset
PUBLIC	?apply_offset@kd_multi_line@@QAEXHM@Z		; kd_multi_line::apply_offset
PUBLIC	?copy@kd_multi_line@@QAEXPAU1@HM@Z		; kd_multi_line::copy
PUBLIC	??1kd_multi_block@@UAE@XZ			; kd_multi_block::~kd_multi_block
PUBLIC	?normalize_coefficients@kd_multi_block@@UAEXXZ	; kd_multi_block::normalize_coefficients
PUBLIC	?propagate_bit_depths@kd_multi_block@@UAE_N_N0@Z ; kd_multi_block::propagate_bit_depths
PUBLIC	?perform_transform@kd_multi_block@@UAEXXZ	; kd_multi_block::perform_transform
PUBLIC	?prepare_for_inversion@kd_multi_block@@UAEPBDXZ	; kd_multi_block::prepare_for_inversion
PUBLIC	?perform_inverse@kd_multi_block@@UAEXXZ		; kd_multi_block::perform_inverse
PUBLIC	??_Gkd_multi_block@@UAEPAXI@Z			; kd_multi_block::`scalar deleting destructor'
PUBLIC	?initialize@kd_multi_null_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z ; kd_multi_null_block::initialize
PUBLIC	??_Gkd_multi_null_block@@UAEPAXI@Z		; kd_multi_null_block::`scalar deleting destructor'
PUBLIC	??1kd_multi_matrix_block@@UAE@XZ		; kd_multi_matrix_block::~kd_multi_matrix_block
PUBLIC	?initialize@kd_multi_matrix_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z ; kd_multi_matrix_block::initialize
PUBLIC	?normalize_coefficients@kd_multi_matrix_block@@UAEXXZ ; kd_multi_matrix_block::normalize_coefficients
PUBLIC	?perform_transform@kd_multi_matrix_block@@UAEXXZ ; kd_multi_matrix_block::perform_transform
PUBLIC	?prepare_for_inversion@kd_multi_matrix_block@@UAEPBDXZ ; kd_multi_matrix_block::prepare_for_inversion
PUBLIC	?perform_inverse@kd_multi_matrix_block@@UAEXXZ	; kd_multi_matrix_block::perform_inverse
PUBLIC	?create_short_coefficients@kd_multi_matrix_block@@AAEXH@Z ; kd_multi_matrix_block::create_short_coefficients
PUBLIC	?create_short_inverse_coefficients@kd_multi_matrix_block@@AAEXH@Z ; kd_multi_matrix_block::create_short_inverse_coefficients
PUBLIC	??_Gkd_multi_matrix_block@@UAEPAXI@Z		; kd_multi_matrix_block::`scalar deleting destructor'
PUBLIC	??1kd_multi_rxform_block@@UAE@XZ		; kd_multi_rxform_block::~kd_multi_rxform_block
PUBLIC	?initialize@kd_multi_rxform_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z ; kd_multi_rxform_block::initialize
PUBLIC	?perform_transform@kd_multi_rxform_block@@UAEXXZ ; kd_multi_rxform_block::perform_transform
PUBLIC	?prepare_for_inversion@kd_multi_rxform_block@@UAEPBDXZ ; kd_multi_rxform_block::prepare_for_inversion
PUBLIC	?perform_inverse@kd_multi_rxform_block@@UAEXXZ	; kd_multi_rxform_block::perform_inverse
PUBLIC	??_Gkd_multi_rxform_block@@UAEPAXI@Z		; kd_multi_rxform_block::`scalar deleting destructor'
PUBLIC	??1kd_multi_dependency_block@@UAE@XZ		; kd_multi_dependency_block::~kd_multi_dependency_block
PUBLIC	?initialize@kd_multi_dependency_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z ; kd_multi_dependency_block::initialize
PUBLIC	?normalize_coefficients@kd_multi_dependency_block@@UAEXXZ ; kd_multi_dependency_block::normalize_coefficients
PUBLIC	?perform_transform@kd_multi_dependency_block@@UAEXXZ ; kd_multi_dependency_block::perform_transform
PUBLIC	?prepare_for_inversion@kd_multi_dependency_block@@UAEPBDXZ ; kd_multi_dependency_block::prepare_for_inversion
PUBLIC	?perform_inverse@kd_multi_dependency_block@@UAEXXZ ; kd_multi_dependency_block::perform_inverse
PUBLIC	?create_short_matrix@kd_multi_dependency_block@@AAEXXZ ; kd_multi_dependency_block::create_short_matrix
PUBLIC	??_Gkd_multi_dependency_block@@UAEPAXI@Z	; kd_multi_dependency_block::`scalar deleting destructor'
PUBLIC	??0kd_multi_dwt_level@@QAE@XZ			; kd_multi_dwt_level::kd_multi_dwt_level
PUBLIC	??1kd_multi_dwt_level@@QAE@XZ			; kd_multi_dwt_level::~kd_multi_dwt_level
PUBLIC	??_Ekd_multi_dwt_level@@QAEPAXI@Z		; kd_multi_dwt_level::`vector deleting destructor'
PUBLIC	??1kd_multi_dwt_block@@UAE@XZ			; kd_multi_dwt_block::~kd_multi_dwt_block
PUBLIC	?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z ; kd_multi_dwt_block::initialize
PUBLIC	?normalize_coefficients@kd_multi_dwt_block@@UAEXXZ ; kd_multi_dwt_block::normalize_coefficients
PUBLIC	?propagate_bit_depths@kd_multi_dwt_block@@UAE_N_N0@Z ; kd_multi_dwt_block::propagate_bit_depths
PUBLIC	?perform_transform@kd_multi_dwt_block@@UAEXXZ	; kd_multi_dwt_block::perform_transform
PUBLIC	?prepare_for_inversion@kd_multi_dwt_block@@UAEPBDXZ ; kd_multi_dwt_block::prepare_for_inversion
PUBLIC	?perform_inverse@kd_multi_dwt_block@@UAEXXZ	; kd_multi_dwt_block::perform_inverse
PUBLIC	??_Gkd_multi_dwt_block@@UAEPAXI@Z		; kd_multi_dwt_block::`scalar deleting destructor'
PUBLIC	??0kd_multi_component@@QAE@XZ			; kd_multi_component::kd_multi_component
PUBLIC	??1kd_multi_component@@UAE@XZ			; kd_multi_component::~kd_multi_component
PUBLIC	?do_job@kd_multi_component@@UAEXPAVkdu_thread_entity@@H@Z ; kd_multi_component::do_job
PUBLIC	??_Ekd_multi_component@@UAEPAXI@Z		; kd_multi_component::`vector deleting destructor'
PUBLIC	??1kd_multi_transform@@UAE@XZ			; kd_multi_transform::~kd_multi_transform
PUBLIC	?get_scratch_ints@kd_multi_transform@@QAEPAHH@Z	; kd_multi_transform::get_scratch_ints
PUBLIC	?get_scratch_floats@kd_multi_transform@@QAEPAMH@Z ; kd_multi_transform::get_scratch_floats
PUBLIC	?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ; kd_multi_transform::construct
PUBLIC	?create_resources@kd_multi_transform@@IAEXXZ	; kd_multi_transform::create_resources
PUBLIC	?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z ; kd_multi_transform::propagate_knowledge
PUBLIC	??_Gkd_multi_transform@@UAEPAXI@Z		; kd_multi_transform::`scalar deleting destructor'
PUBLIC	??1kd_multi_synthesis@@UAE@XZ			; kd_multi_synthesis::~kd_multi_synthesis
PUBLIC	?terminate_queues@kd_multi_synthesis@@UAEXPAVkdu_thread_env@@@Z ; kd_multi_synthesis::terminate_queues
PUBLIC	?create@kd_multi_synthesis@@QAE_JVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ; kd_multi_synthesis::create
PUBLIC	?get_size@kd_multi_synthesis@@UAE?AUkdu_coords@@H@Z ; kd_multi_synthesis::get_size
PUBLIC	?get_line@kd_multi_synthesis@@UAEPAVkdu_line_buf@@HPAVkdu_thread_env@@@Z ; kd_multi_synthesis::get_line
PUBLIC	?is_line_precise@kd_multi_synthesis@@UAE_NH@Z	; kd_multi_synthesis::is_line_precise
PUBLIC	?is_line_absolute@kd_multi_synthesis@@UAE_NH@Z	; kd_multi_synthesis::is_line_absolute
PUBLIC	?get_line@kd_multi_synthesis@@AAEPAVkdu_line_buf@@PAUkd_multi_line@@HPAVkdu_thread_env@@@Z ; kd_multi_synthesis::get_line
PUBLIC	??_Gkd_multi_synthesis@@UAEPAXI@Z		; kd_multi_synthesis::`scalar deleting destructor'
PUBLIC	??1kd_multi_analysis@@UAE@XZ			; kd_multi_analysis::~kd_multi_analysis
PUBLIC	?terminate_queues@kd_multi_analysis@@UAEXPAVkdu_thread_env@@@Z ; kd_multi_analysis::terminate_queues
PUBLIC	?create@kd_multi_analysis@@QAE_JVkdu_codestream@@Vkdu_tile@@_NPAVkdu_roi_image@@2HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ; kd_multi_analysis::create
PUBLIC	?get_size@kd_multi_analysis@@UAE?AUkdu_coords@@H@Z ; kd_multi_analysis::get_size
PUBLIC	?exchange_line@kd_multi_analysis@@UAEPAVkdu_line_buf@@HPAV2@PAVkdu_thread_env@@@Z ; kd_multi_analysis::exchange_line
PUBLIC	?is_line_precise@kd_multi_analysis@@UAE_NH@Z	; kd_multi_analysis::is_line_precise
PUBLIC	?is_line_absolute@kd_multi_analysis@@UAE_NH@Z	; kd_multi_analysis::is_line_absolute
PUBLIC	?prepare_network_for_inversion@kd_multi_analysis@@AAEXXZ ; kd_multi_analysis::prepare_network_for_inversion
PUBLIC	?advance_line@kd_multi_analysis@@AAEXPAUkd_multi_line@@HPAVkdu_thread_env@@@Z ; kd_multi_analysis::advance_line
PUBLIC	??_Gkd_multi_analysis@@UAEPAXI@Z		; kd_multi_analysis::`scalar deleting destructor'
PUBLIC	??_Ekd_multi_synthesis@@W3AEPAXI@Z		; [thunk]:kd_multi_synthesis::`vector deleting destructor'
PUBLIC	??_Ekd_multi_analysis@@W3AEPAXI@Z		; [thunk]:kd_multi_analysis::`vector deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_7kdu_worker@@6B@				; kdu_worker::`vftable'
PUBLIC	??_7kd_multi_analysis_base@@6B@			; kd_multi_analysis_base::`vftable'
PUBLIC	??_7kd_multi_synthesis_base@@6B@		; kd_multi_synthesis_base::`vftable'
PUBLIC	??_7kd_multi_block@@6B@				; kd_multi_block::`vftable'
PUBLIC	??_C@_0ED@KEGEGAOK@Unimplemented?5multi?9component?5tr@ ; `string'
PUBLIC	??_7kd_multi_null_block@@6B@			; kd_multi_null_block::`vftable'
PUBLIC	??_7kd_multi_matrix_block@@6B@			; kd_multi_matrix_block::`vftable'
PUBLIC	??_7kd_multi_rxform_block@@6B@			; kd_multi_rxform_block::`vftable'
PUBLIC	??_7kd_multi_dependency_block@@6B@		; kd_multi_dependency_block::`vftable'
PUBLIC	??_7kd_multi_dwt_block@@6B@			; kd_multi_dwt_block::`vftable'
PUBLIC	??_7kd_multi_component@@6B@			; kd_multi_component::`vftable'
PUBLIC	??_7kd_multi_transform@@6B@			; kd_multi_transform::`vftable'
PUBLIC	??_7kd_multi_synthesis@@6Bkd_multi_synthesis_base@@@ ; kd_multi_synthesis::`vftable'
PUBLIC	??_7kd_multi_synthesis@@6Bkd_multi_transform@@@	; kd_multi_synthesis::`vftable'
PUBLIC	??_7kd_multi_analysis@@6Bkd_multi_analysis_base@@@ ; kd_multi_analysis::`vftable'
PUBLIC	??_7kd_multi_analysis@@6Bkd_multi_transform@@@	; kd_multi_analysis::`vftable'
PUBLIC	??_C@_0BE@DHNHLPAL@component?5processor?$AA@	; `string'
PUBLIC	??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@	; `string'
PUBLIC	??_C@_0CCJ@OBHDBNBL@Cannot?5implement?5multi?9component@ ; `string'
PUBLIC	??_C@_0BDP@OMPOBFOO@Part?92?5codestream?5declares?5a?5cod@ ; `string'
PUBLIC	??_C@_0DGI@MLEJMJIK@Cannot?5implement?5multi?9component@ ; `string'
PUBLIC	??_C@_0CLD@EIGIPOMM@Cannot?5perform?5forward?5multi?9com@ ; `string'
PUBLIC	??_C@_0DK@DNEDNIAC@?5?5The?5following?5additional?5expla@ ; `string'
PUBLIC	??_C@_0LC@FOOLOFAN@Encountered?5underdetermined?5syst@ ; `string'
PUBLIC	??_C@_0CBL@NHJPLOG@Encountered?5an?5irreversible?5deco@ ; `string'
PUBLIC	??_C@_0BAH@FNBHAICK@Near?5singular?5irreversible?5decor@ ; `string'
PUBLIC	??_C@_0KM@JOCABHJL@Reversible?5decorrelation?5transfo@ ; `string'
PUBLIC	??_C@_0LJ@PJJIHOJD@Multi?9component?5reversible?5decor@ ; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0MO@CPPIDHHM@Dependency?5transform?5block?5canno@ ; `string'
PUBLIC	??_C@_0CBI@FDCMKGLL@Encountered?5an?5irreversible?5depe@ ; `string'
PUBLIC	??_C@_0OO@CDGHEAGO@Multi?9component?5reversible?5depen@ ; `string'
PUBLIC	??_C@_0MD@NOKJMJMF@DWT?5transform?5block?5cannot?5be?5in@ ; `string'
PUBLIC	??_C@_0CBB@DNHOHNJD@Encountered?5an?5irreversible?5DWT?5@ ; `string'
PUBLIC	??_C@_0BGL@OKHHJDHO@Inconsistent?5bit?9depths?5encounte@ ; `string'
PUBLIC	??_R4kdu_worker@@6B@				; kdu_worker::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_worker@@@8				; kdu_worker `RTTI Type Descriptor'
PUBLIC	??_R3kdu_worker@@8				; kdu_worker::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_worker@@8				; kdu_worker::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_worker@@8			; kdu_worker::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_multi_analysis_base@@6B@		; kd_multi_analysis_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_multi_analysis_base@@@8		; kd_multi_analysis_base `RTTI Type Descriptor'
PUBLIC	??_R3kd_multi_analysis_base@@8			; kd_multi_analysis_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_multi_analysis_base@@8			; kd_multi_analysis_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_multi_analysis_base@@8		; kd_multi_analysis_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_multi_synthesis_base@@6B@		; kd_multi_synthesis_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_multi_synthesis_base@@@8		; kd_multi_synthesis_base `RTTI Type Descriptor'
PUBLIC	??_R3kd_multi_synthesis_base@@8			; kd_multi_synthesis_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_multi_synthesis_base@@8			; kd_multi_synthesis_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_multi_synthesis_base@@8	; kd_multi_synthesis_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_multi_component@@6B@			; kd_multi_component::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_multi_component@@@8			; kd_multi_component `RTTI Type Descriptor'
PUBLIC	??_R3kd_multi_component@@8			; kd_multi_component::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_multi_component@@8			; kd_multi_component::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_multi_component@@8		; kd_multi_component::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_multi_block@@6B@			; kd_multi_block::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_multi_block@@@8			; kd_multi_block `RTTI Type Descriptor'
PUBLIC	??_R3kd_multi_block@@8				; kd_multi_block::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_multi_block@@8				; kd_multi_block::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_multi_block@@8			; kd_multi_block::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_multi_null_block@@6B@			; kd_multi_null_block::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_multi_null_block@@@8			; kd_multi_null_block `RTTI Type Descriptor'
PUBLIC	??_R3kd_multi_null_block@@8			; kd_multi_null_block::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_multi_null_block@@8			; kd_multi_null_block::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_multi_null_block@@8		; kd_multi_null_block::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_multi_matrix_block@@6B@			; kd_multi_matrix_block::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_multi_matrix_block@@@8		; kd_multi_matrix_block `RTTI Type Descriptor'
PUBLIC	??_R3kd_multi_matrix_block@@8			; kd_multi_matrix_block::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_multi_matrix_block@@8			; kd_multi_matrix_block::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_multi_matrix_block@@8		; kd_multi_matrix_block::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_multi_dependency_block@@6B@		; kd_multi_dependency_block::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_multi_dependency_block@@@8		; kd_multi_dependency_block `RTTI Type Descriptor'
PUBLIC	??_R3kd_multi_dependency_block@@8		; kd_multi_dependency_block::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_multi_dependency_block@@8		; kd_multi_dependency_block::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_multi_dependency_block@@8	; kd_multi_dependency_block::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_multi_rxform_block@@6B@			; kd_multi_rxform_block::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_multi_rxform_block@@@8		; kd_multi_rxform_block `RTTI Type Descriptor'
PUBLIC	??_R3kd_multi_rxform_block@@8			; kd_multi_rxform_block::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_multi_rxform_block@@8			; kd_multi_rxform_block::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_multi_rxform_block@@8		; kd_multi_rxform_block::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_multi_dwt_block@@6B@			; kd_multi_dwt_block::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_multi_dwt_block@@@8			; kd_multi_dwt_block `RTTI Type Descriptor'
PUBLIC	??_R3kd_multi_dwt_block@@8			; kd_multi_dwt_block::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_multi_dwt_block@@8			; kd_multi_dwt_block::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_multi_dwt_block@@8		; kd_multi_dwt_block::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_multi_transform@@6B@			; kd_multi_transform::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_multi_transform@@@8			; kd_multi_transform `RTTI Type Descriptor'
PUBLIC	??_R3kd_multi_transform@@8			; kd_multi_transform::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_multi_transform@@8			; kd_multi_transform::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_multi_transform@@8		; kd_multi_transform::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_multi_synthesis@@6Bkd_multi_synthesis_base@@@ ; kd_multi_synthesis::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_multi_synthesis@@@8			; kd_multi_synthesis `RTTI Type Descriptor'
PUBLIC	??_R3kd_multi_synthesis@@8			; kd_multi_synthesis::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_multi_synthesis@@8			; kd_multi_synthesis::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_multi_synthesis@@8		; kd_multi_synthesis::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@kd_multi_transform@@8		; kd_multi_transform::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R4kd_multi_synthesis@@6Bkd_multi_transform@@@ ; kd_multi_synthesis::`RTTI Complete Object Locator'
PUBLIC	??_R4kd_multi_analysis@@6Bkd_multi_analysis_base@@@ ; kd_multi_analysis::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_multi_analysis@@@8			; kd_multi_analysis `RTTI Type Descriptor'
PUBLIC	??_R3kd_multi_analysis@@8			; kd_multi_analysis::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_multi_analysis@@8			; kd_multi_analysis::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_multi_analysis@@8		; kd_multi_analysis::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_multi_analysis@@6Bkd_multi_transform@@@	; kd_multi_analysis::`RTTI Complete Object Locator'
PUBLIC	__real@00000000
PUBLIC	__real@3727c5ac
PUBLIC	__real@3d3c25c268497682
PUBLIC	__real@3ecccccd
PUBLIC	__real@3eff7cee
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4018000000000000
PUBLIC	__real@46000000
PUBLIC	__real@467ffc00
PUBLIC	__real@46fffe00
PUBLIC	__xmm@80000000000000008000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	___std_terminate:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	??0kdu_error@@QAE@PBD@Z:PROC			; kdu_error::kdu_error
EXTRN	??1kdu_error@@UAE@XZ:PROC			; kdu_error::~kdu_error
EXTRN	??_Ekdu_worker@@UAEPAXI@Z:PROC			; kdu_worker::`vector deleting destructor'
EXTRN	?get_num_threads@kdu_thread_entity@@QAEHXZ:PROC	; kdu_thread_entity::get_num_threads
EXTRN	?add_queue@kdu_thread_entity@@QAEPAUkdu_thread_queue@@PAVkdu_worker@@PAU2@PBD_J@Z:PROC ; kdu_thread_entity::add_queue
EXTRN	?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z:PROC ; kdu_thread_entity::add_jobs
EXTRN	?terminate@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_NPAH@Z:PROC ; kdu_thread_entity::terminate
EXTRN	?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z:PROC ; kdu_thread_entity::process_jobs
EXTRN	?init@kdu_kernels@@QAEXHPBUkdu_kernel_step_info@@PBM_N22@Z:PROC ; kdu_kernels::init
EXTRN	?get_impulse_response@kdu_kernels@@QAEPAMW4kdu_kernel_type@@AAHPAH2@Z:PROC ; kdu_kernels::get_impulse_response
EXTRN	?get_bibo_gains@kdu_kernels@@QAEPANHHQA_NAAN1@Z:PROC ; kdu_kernels::get_bibo_gains
EXTRN	?clear@kdu_kernels@@AAEXXZ:PROC			; kdu_kernels::clear
EXTRN	?reset@kdu_kernels@@AAEXXZ:PROC			; kdu_kernels::reset
EXTRN	?get_bit_depth@kdu_codestream@@QAEHH_N@Z:PROC	; kdu_codestream::get_bit_depth
EXTRN	?get_signed@kdu_codestream@@QAE_NH_N@Z:PROC	; kdu_codestream::get_signed
EXTRN	?get_tile_dims@kdu_codestream@@QAEXUkdu_coords@@HAAUkdu_dims@@_N@Z:PROC ; kdu_codestream::get_tile_dims
EXTRN	?get_tile_idx@kdu_tile@@QAE?AUkdu_coords@@XZ:PROC ; kdu_tile::get_tile_idx
EXTRN	?get_ycc@kdu_tile@@QAE_NXZ:PROC			; kdu_tile::get_ycc
EXTRN	?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z:PROC ; kdu_tile::get_mct_block_info
EXTRN	?get_mct_matrix_info@kdu_tile@@QAE_NHHPAM@Z:PROC ; kdu_tile::get_mct_matrix_info
EXTRN	?get_mct_rxform_info@kdu_tile@@QAE_NHHPAH0@Z:PROC ; kdu_tile::get_mct_rxform_info
EXTRN	?get_mct_dependency_info@kdu_tile@@QAE_NHHAA_NPAM1PAH22@Z:PROC ; kdu_tile::get_mct_dependency_info
EXTRN	?get_mct_dwt_info@kdu_tile@@QAEPBUkdu_kernel_step_info@@HHAA_NAAH11100AAPBMPAH3@Z:PROC ; kdu_tile::get_mct_dwt_info
EXTRN	?access_component@kdu_tile@@QAE?AVkdu_tile_comp@@H@Z:PROC ; kdu_tile::access_component
EXTRN	?get_reversible@kdu_tile_comp@@QAE_NXZ:PROC	; kdu_tile_comp::get_reversible
EXTRN	?get_bit_depth@kdu_tile_comp@@QAEH_N@Z:PROC	; kdu_tile_comp::get_bit_depth
EXTRN	?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@XZ:PROC ; kdu_tile_comp::access_resolution
EXTRN	?which@kdu_resolution@@QAEHXZ:PROC		; kdu_resolution::which
EXTRN	?get_dims@kdu_resolution@@QAEXAAUkdu_dims@@@Z:PROC ; kdu_resolution::get_dims
EXTRN	?access_subband@kdu_resolution@@QAE?AVkdu_subband@@H@Z:PROC ; kdu_resolution::access_subband
EXTRN	??0kdu_analysis@@QAE@Vkdu_resolution@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z:PROC ; kdu_analysis::kdu_analysis
EXTRN	??0kdu_synthesis@@QAE@Vkdu_resolution@@PAVkdu_sample_allocator@@_NMPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z:PROC ; kdu_synthesis::kdu_synthesis
EXTRN	??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z:PROC ; kdu_encoder::kdu_encoder
EXTRN	??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z:PROC ; kdu_decoder::kdu_decoder
EXTRN	??_Ekd_multi_analysis_base@@UAEPAXI@Z:PROC	; kd_multi_analysis_base::`vector deleting destructor'
EXTRN	??_Ekd_multi_synthesis_base@@UAEPAXI@Z:PROC	; kd_multi_synthesis_base::`vector deleting destructor'
EXTRN	?kdu_convert_rgb_to_ycc@@YAXAAVkdu_line_buf@@00@Z:PROC ; kdu_convert_rgb_to_ycc
EXTRN	?kdu_convert_ycc_to_rgb@@YAXAAVkdu_line_buf@@00H@Z:PROC ; kdu_convert_ycc_to_rgb
EXTRN	?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z:PROC ; perform_synthesis_lifting_step
EXTRN	?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z:PROC ; perform_synthesis_lifting_step
EXTRN	?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z:PROC ; perform_analysis_lifting_step
EXTRN	?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z:PROC ; perform_analysis_lifting_step
EXTRN	??_Ekd_multi_block@@UAEPAXI@Z:PROC		; kd_multi_block::`vector deleting destructor'
EXTRN	??_Ekd_multi_null_block@@UAEPAXI@Z:PROC		; kd_multi_null_block::`vector deleting destructor'
EXTRN	??_Ekd_multi_matrix_block@@UAEPAXI@Z:PROC	; kd_multi_matrix_block::`vector deleting destructor'
EXTRN	??_Ekd_multi_rxform_block@@UAEPAXI@Z:PROC	; kd_multi_rxform_block::`vector deleting destructor'
EXTRN	??_Ekd_multi_dependency_block@@UAEPAXI@Z:PROC	; kd_multi_dependency_block::`vector deleting destructor'
EXTRN	??_Ekd_multi_dwt_block@@UAEPAXI@Z:PROC		; kd_multi_dwt_block::`vector deleting destructor'
EXTRN	??_Ekd_multi_transform@@UAEPAXI@Z:PROC		; kd_multi_transform::`vector deleting destructor'
EXTRN	??_Ekd_multi_synthesis@@UAEPAXI@Z:PROC		; kd_multi_synthesis::`vector deleting destructor'
EXTRN	??_Ekd_multi_analysis@@UAEPAXI@Z:PROC		; kd_multi_analysis::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	_floor:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@467ffc00
CONST	SEGMENT
__real@467ffc00 DD 0467ffc00r			; 16383
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3eff7cee
CONST	SEGMENT
__real@3eff7cee DD 03eff7ceer			; 0.499
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3d3c25c268497682
CONST	SEGMENT
__real@3d3c25c268497682 DQ 03d3c25c268497682r	; 1e-13
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-05
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R4kd_multi_analysis@@6Bkd_multi_transform@@@
rdata$r	SEGMENT
??_R4kd_multi_analysis@@6Bkd_multi_transform@@@ DD 00H	; kd_multi_analysis::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_analysis@@@8
	DD	FLAT:??_R3kd_multi_analysis@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_multi_analysis@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_multi_analysis@@8 DD FLAT:??_R0?AVkd_multi_analysis@@@8 ; kd_multi_analysis::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_multi_analysis@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_multi_analysis@@8
rdata$r	SEGMENT
??_R2kd_multi_analysis@@8 DD FLAT:??_R1A@?0A@EA@kd_multi_analysis@@8 ; kd_multi_analysis::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kd_multi_analysis_base@@8
	DD	FLAT:??_R13?0A@EA@kd_multi_transform@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_multi_analysis@@8
rdata$r	SEGMENT
??_R3kd_multi_analysis@@8 DD 00H			; kd_multi_analysis::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2kd_multi_analysis@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_multi_analysis@@@8
data$r	SEGMENT
??_R0?AVkd_multi_analysis@@@8 DD FLAT:??_7type_info@@6B@ ; kd_multi_analysis `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_multi_analysis@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_multi_analysis@@6Bkd_multi_analysis_base@@@
rdata$r	SEGMENT
??_R4kd_multi_analysis@@6Bkd_multi_analysis_base@@@ DD 00H ; kd_multi_analysis::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_analysis@@@8
	DD	FLAT:??_R3kd_multi_analysis@@8
rdata$r	ENDS
;	COMDAT ??_R4kd_multi_synthesis@@6Bkd_multi_transform@@@
rdata$r	SEGMENT
??_R4kd_multi_synthesis@@6Bkd_multi_transform@@@ DD 00H	; kd_multi_synthesis::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_synthesis@@@8
	DD	FLAT:??_R3kd_multi_synthesis@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@kd_multi_transform@@8
rdata$r	SEGMENT
??_R13?0A@EA@kd_multi_transform@@8 DD FLAT:??_R0?AVkd_multi_transform@@@8 ; kd_multi_transform::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_multi_transform@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_multi_synthesis@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_multi_synthesis@@8 DD FLAT:??_R0?AVkd_multi_synthesis@@@8 ; kd_multi_synthesis::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_multi_synthesis@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_multi_synthesis@@8
rdata$r	SEGMENT
??_R2kd_multi_synthesis@@8 DD FLAT:??_R1A@?0A@EA@kd_multi_synthesis@@8 ; kd_multi_synthesis::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kd_multi_synthesis_base@@8
	DD	FLAT:??_R13?0A@EA@kd_multi_transform@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_multi_synthesis@@8
rdata$r	SEGMENT
??_R3kd_multi_synthesis@@8 DD 00H			; kd_multi_synthesis::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2kd_multi_synthesis@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_multi_synthesis@@@8
data$r	SEGMENT
??_R0?AVkd_multi_synthesis@@@8 DD FLAT:??_7type_info@@6B@ ; kd_multi_synthesis `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_multi_synthesis@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_multi_synthesis@@6Bkd_multi_synthesis_base@@@
rdata$r	SEGMENT
??_R4kd_multi_synthesis@@6Bkd_multi_synthesis_base@@@ DD 00H ; kd_multi_synthesis::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_synthesis@@@8
	DD	FLAT:??_R3kd_multi_synthesis@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_multi_transform@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_multi_transform@@8 DD FLAT:??_R0?AVkd_multi_transform@@@8 ; kd_multi_transform::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_multi_transform@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_multi_transform@@8
rdata$r	SEGMENT
??_R2kd_multi_transform@@8 DD FLAT:??_R1A@?0A@EA@kd_multi_transform@@8 ; kd_multi_transform::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kd_multi_transform@@8
rdata$r	SEGMENT
??_R3kd_multi_transform@@8 DD 00H			; kd_multi_transform::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kd_multi_transform@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_multi_transform@@@8
data$r	SEGMENT
??_R0?AVkd_multi_transform@@@8 DD FLAT:??_7type_info@@6B@ ; kd_multi_transform `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_multi_transform@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_multi_transform@@6B@
rdata$r	SEGMENT
??_R4kd_multi_transform@@6B@ DD 00H			; kd_multi_transform::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_transform@@@8
	DD	FLAT:??_R3kd_multi_transform@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_multi_dwt_block@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_multi_dwt_block@@8 DD FLAT:??_R0?AVkd_multi_dwt_block@@@8 ; kd_multi_dwt_block::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_multi_dwt_block@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_multi_dwt_block@@8
rdata$r	SEGMENT
??_R2kd_multi_dwt_block@@8 DD FLAT:??_R1A@?0A@EA@kd_multi_dwt_block@@8 ; kd_multi_dwt_block::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kd_multi_block@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_multi_dwt_block@@8
rdata$r	SEGMENT
??_R3kd_multi_dwt_block@@8 DD 00H			; kd_multi_dwt_block::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_multi_dwt_block@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_multi_dwt_block@@@8
data$r	SEGMENT
??_R0?AVkd_multi_dwt_block@@@8 DD FLAT:??_7type_info@@6B@ ; kd_multi_dwt_block `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_multi_dwt_block@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_multi_dwt_block@@6B@
rdata$r	SEGMENT
??_R4kd_multi_dwt_block@@6B@ DD 00H			; kd_multi_dwt_block::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_dwt_block@@@8
	DD	FLAT:??_R3kd_multi_dwt_block@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_multi_rxform_block@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_multi_rxform_block@@8 DD FLAT:??_R0?AVkd_multi_rxform_block@@@8 ; kd_multi_rxform_block::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_multi_rxform_block@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_multi_rxform_block@@8
rdata$r	SEGMENT
??_R2kd_multi_rxform_block@@8 DD FLAT:??_R1A@?0A@EA@kd_multi_rxform_block@@8 ; kd_multi_rxform_block::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kd_multi_block@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_multi_rxform_block@@8
rdata$r	SEGMENT
??_R3kd_multi_rxform_block@@8 DD 00H			; kd_multi_rxform_block::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_multi_rxform_block@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_multi_rxform_block@@@8
data$r	SEGMENT
??_R0?AVkd_multi_rxform_block@@@8 DD FLAT:??_7type_info@@6B@ ; kd_multi_rxform_block `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_multi_rxform_block@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_multi_rxform_block@@6B@
rdata$r	SEGMENT
??_R4kd_multi_rxform_block@@6B@ DD 00H			; kd_multi_rxform_block::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_rxform_block@@@8
	DD	FLAT:??_R3kd_multi_rxform_block@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_multi_dependency_block@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_multi_dependency_block@@8 DD FLAT:??_R0?AVkd_multi_dependency_block@@@8 ; kd_multi_dependency_block::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_multi_dependency_block@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_multi_dependency_block@@8
rdata$r	SEGMENT
??_R2kd_multi_dependency_block@@8 DD FLAT:??_R1A@?0A@EA@kd_multi_dependency_block@@8 ; kd_multi_dependency_block::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kd_multi_block@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_multi_dependency_block@@8
rdata$r	SEGMENT
??_R3kd_multi_dependency_block@@8 DD 00H		; kd_multi_dependency_block::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_multi_dependency_block@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_multi_dependency_block@@@8
data$r	SEGMENT
??_R0?AVkd_multi_dependency_block@@@8 DD FLAT:??_7type_info@@6B@ ; kd_multi_dependency_block `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_multi_dependency_block@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_multi_dependency_block@@6B@
rdata$r	SEGMENT
??_R4kd_multi_dependency_block@@6B@ DD 00H		; kd_multi_dependency_block::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_dependency_block@@@8
	DD	FLAT:??_R3kd_multi_dependency_block@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_multi_matrix_block@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_multi_matrix_block@@8 DD FLAT:??_R0?AVkd_multi_matrix_block@@@8 ; kd_multi_matrix_block::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_multi_matrix_block@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_multi_matrix_block@@8
rdata$r	SEGMENT
??_R2kd_multi_matrix_block@@8 DD FLAT:??_R1A@?0A@EA@kd_multi_matrix_block@@8 ; kd_multi_matrix_block::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kd_multi_block@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_multi_matrix_block@@8
rdata$r	SEGMENT
??_R3kd_multi_matrix_block@@8 DD 00H			; kd_multi_matrix_block::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_multi_matrix_block@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_multi_matrix_block@@@8
data$r	SEGMENT
??_R0?AVkd_multi_matrix_block@@@8 DD FLAT:??_7type_info@@6B@ ; kd_multi_matrix_block `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_multi_matrix_block@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_multi_matrix_block@@6B@
rdata$r	SEGMENT
??_R4kd_multi_matrix_block@@6B@ DD 00H			; kd_multi_matrix_block::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_matrix_block@@@8
	DD	FLAT:??_R3kd_multi_matrix_block@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_multi_null_block@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_multi_null_block@@8 DD FLAT:??_R0?AVkd_multi_null_block@@@8 ; kd_multi_null_block::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_multi_null_block@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_multi_null_block@@8
rdata$r	SEGMENT
??_R2kd_multi_null_block@@8 DD FLAT:??_R1A@?0A@EA@kd_multi_null_block@@8 ; kd_multi_null_block::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kd_multi_block@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_multi_null_block@@8
rdata$r	SEGMENT
??_R3kd_multi_null_block@@8 DD 00H			; kd_multi_null_block::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_multi_null_block@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_multi_null_block@@@8
data$r	SEGMENT
??_R0?AVkd_multi_null_block@@@8 DD FLAT:??_7type_info@@6B@ ; kd_multi_null_block `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_multi_null_block@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_multi_null_block@@6B@
rdata$r	SEGMENT
??_R4kd_multi_null_block@@6B@ DD 00H			; kd_multi_null_block::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_null_block@@@8
	DD	FLAT:??_R3kd_multi_null_block@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_multi_block@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_multi_block@@8 DD FLAT:??_R0?AVkd_multi_block@@@8 ; kd_multi_block::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_multi_block@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_multi_block@@8
rdata$r	SEGMENT
??_R2kd_multi_block@@8 DD FLAT:??_R1A@?0A@EA@kd_multi_block@@8 ; kd_multi_block::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kd_multi_block@@8
rdata$r	SEGMENT
??_R3kd_multi_block@@8 DD 00H				; kd_multi_block::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kd_multi_block@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_multi_block@@@8
data$r	SEGMENT
??_R0?AVkd_multi_block@@@8 DD FLAT:??_7type_info@@6B@	; kd_multi_block `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_multi_block@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_multi_block@@6B@
rdata$r	SEGMENT
??_R4kd_multi_block@@6B@ DD 00H				; kd_multi_block::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_block@@@8
	DD	FLAT:??_R3kd_multi_block@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_multi_component@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_multi_component@@8 DD FLAT:??_R0?AVkd_multi_component@@@8 ; kd_multi_component::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_multi_component@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_multi_component@@8
rdata$r	SEGMENT
??_R2kd_multi_component@@8 DD FLAT:??_R1A@?0A@EA@kd_multi_component@@8 ; kd_multi_component::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_multi_component@@8
rdata$r	SEGMENT
??_R3kd_multi_component@@8 DD 00H			; kd_multi_component::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_multi_component@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_multi_component@@@8
data$r	SEGMENT
??_R0?AVkd_multi_component@@@8 DD FLAT:??_7type_info@@6B@ ; kd_multi_component `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_multi_component@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_multi_component@@6B@
rdata$r	SEGMENT
??_R4kd_multi_component@@6B@ DD 00H			; kd_multi_component::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_component@@@8
	DD	FLAT:??_R3kd_multi_component@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_multi_synthesis_base@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_multi_synthesis_base@@8 DD FLAT:??_R0?AVkd_multi_synthesis_base@@@8 ; kd_multi_synthesis_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_multi_synthesis_base@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_multi_synthesis_base@@8
rdata$r	SEGMENT
??_R2kd_multi_synthesis_base@@8 DD FLAT:??_R1A@?0A@EA@kd_multi_synthesis_base@@8 ; kd_multi_synthesis_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kd_multi_synthesis_base@@8
rdata$r	SEGMENT
??_R3kd_multi_synthesis_base@@8 DD 00H			; kd_multi_synthesis_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kd_multi_synthesis_base@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_multi_synthesis_base@@@8
data$r	SEGMENT
??_R0?AVkd_multi_synthesis_base@@@8 DD FLAT:??_7type_info@@6B@ ; kd_multi_synthesis_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_multi_synthesis_base@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_multi_synthesis_base@@6B@
rdata$r	SEGMENT
??_R4kd_multi_synthesis_base@@6B@ DD 00H		; kd_multi_synthesis_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_synthesis_base@@@8
	DD	FLAT:??_R3kd_multi_synthesis_base@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_multi_analysis_base@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_multi_analysis_base@@8 DD FLAT:??_R0?AVkd_multi_analysis_base@@@8 ; kd_multi_analysis_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_multi_analysis_base@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_multi_analysis_base@@8
rdata$r	SEGMENT
??_R2kd_multi_analysis_base@@8 DD FLAT:??_R1A@?0A@EA@kd_multi_analysis_base@@8 ; kd_multi_analysis_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kd_multi_analysis_base@@8
rdata$r	SEGMENT
??_R3kd_multi_analysis_base@@8 DD 00H			; kd_multi_analysis_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kd_multi_analysis_base@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_multi_analysis_base@@@8
data$r	SEGMENT
??_R0?AVkd_multi_analysis_base@@@8 DD FLAT:??_7type_info@@6B@ ; kd_multi_analysis_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_multi_analysis_base@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_multi_analysis_base@@6B@
rdata$r	SEGMENT
??_R4kd_multi_analysis_base@@6B@ DD 00H			; kd_multi_analysis_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_multi_analysis_base@@@8
	DD	FLAT:??_R3kd_multi_analysis_base@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_worker@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_worker@@8 DD FLAT:??_R0?AVkdu_worker@@@8 ; kdu_worker::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_worker@@8
rdata$r	SEGMENT
??_R2kdu_worker@@8 DD FLAT:??_R1A@?0A@EA@kdu_worker@@8	; kdu_worker::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_worker@@8
rdata$r	SEGMENT
??_R3kdu_worker@@8 DD 00H				; kdu_worker::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_worker@@@8
data$r	SEGMENT
??_R0?AVkdu_worker@@@8 DD FLAT:??_7type_info@@6B@	; kdu_worker `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_worker@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_worker@@6B@
rdata$r	SEGMENT
??_R4kdu_worker@@6B@ DD 00H				; kdu_worker::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_worker@@@8
	DD	FLAT:??_R3kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BGL@OKHHJDHO@Inconsistent?5bit?9depths?5encounte@
CONST	SEGMENT
??_C@_0BGL@OKHHJDHO@Inconsistent?5bit?9depths?5encounte@ DB 'Inconsistent'
	DB	' bit-depths encountered amongst output image components produ'
	DB	'ced by a DWT transform block embedded inside the multi-compon'
	DB	'ent transform network.  All output (i.e., synthesized) compon'
	DB	'ents produced by a single DWT block must be declared with the'
	DB	' same bit-depth.  Anything else makes no sense, so Kakadu doe'
	DB	's not bother trying to accommodate this case.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CBB@DNHOHNJD@Encountered?5an?5irreversible?5DWT?5@
CONST	SEGMENT
??_C@_0CBB@DNHOHNJD@Encountered?5an?5irreversible?5DWT?5@ DB 'Encountered'
	DB	' an irreversible DWT transform block which operates on revers'
	DB	'ible codestream sample data.  While we allow such transforms '
	DB	'to be processed during decompression, it is unreasonable to g'
	DB	'enerate reversibly compressed component samples using an irre'
	DB	'versible inverse multi-component transform during compression'
	DB	'.  Kakadu will not invert this transform during compression. '
	DB	' This can prevent the compression process from proceeding if '
	DB	'there are no other paths back from the MCT output components '
	DB	'to the codestream components.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0MD@NOKJMJMF@DWT?5transform?5block?5cannot?5be?5in@
CONST	SEGMENT
??_C@_0MD@NOKJMJMF@DWT?5transform?5block?5cannot?5be?5in@ DB 'DWT transfo'
	DB	'rm block cannot be inverted unless all output components can '
	DB	'be computed by downstream transform blocks in the multi-compo'
	DB	'nent transform network, or by the application supplying them.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0OO@CDGHEAGO@Multi?9component?5reversible?5depen@
CONST	SEGMENT
??_C@_0OO@CDGHEAGO@Multi?9component?5reversible?5depen@ DB 'Multi-compone'
	DB	'nt reversible dependency transforms must have exact positive '
	DB	'powers of 2 on the diagonal of their triangular coefficient m'
	DB	'atrix; these are the divisors used to scale and round the pre'
	DB	'diction terms.  The offending divisor is ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CBI@FDCMKGLL@Encountered?5an?5irreversible?5depe@
CONST	SEGMENT
??_C@_0CBI@FDCMKGLL@Encountered?5an?5irreversible?5depe@ DB 'Encountered '
	DB	'an irreversible dependency transform block which operates on '
	DB	'reversible codestream sample data.  While we allow such trans'
	DB	'forms to be processed during decompression, it is unreasonabl'
	DB	'e to generate reversibly compressed component samples using a'
	DB	'n irreversible inverse multi-component transform during compr'
	DB	'ession.  Kakadu will not invert this transform during compres'
	DB	'sion.  This can prevent the compression process from proceedi'
	DB	'ng if there are no other paths back from the MCT output compo'
	DB	'nents to the codestream components.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0MO@CPPIDHHM@Dependency?5transform?5block?5canno@
CONST	SEGMENT
??_C@_0MO@CPPIDHHM@Dependency?5transform?5block?5canno@ DB 'Dependency tr'
	DB	'ansform block cannot be inverted or partially inverted unless'
	DB	' a contiguous prefix of the output components can be computed'
	DB	' by downstream transform blocks, or by the application supply'
	DB	'ing them.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0LJ@PJJIHOJD@Multi?9component?5reversible?5decor@
CONST	SEGMENT
??_C@_0LJ@PJJIHOJD@Multi?9component?5reversible?5decor@ DB 'Multi-compone'
	DB	'nt reversible decorrelation transforms must have exact positi'
	DB	've powers of 2 for the divisors which are used to scale and r'
	DB	'ound the update terms.  The offending divisor is ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0KM@JOCABHJL@Reversible?5decorrelation?5transfo@
CONST	SEGMENT
??_C@_0KM@JOCABHJL@Reversible?5decorrelation?5transfo@ DB 'Reversible dec'
	DB	'orrelation transform block cannot be inverted unless all of i'
	DB	'ts outputs can be computed by downstream transform blocks, or'
	DB	' by the application supplying them.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAH@FNBHAICK@Near?5singular?5irreversible?5decor@
CONST	SEGMENT
??_C@_0BAH@FNBHAICK@Near?5singular?5irreversible?5decor@ DB 'Near singula'
	DB	'r irreversible decorrelation transform block encountered in m'
	DB	'ulti-component transform description.  This can prevent the c'
	DB	'ompression process from proceeding if there are no other path'
	DB	's back from the MCT output components to the codestream compo'
	DB	'nents.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CBL@NHJPLOG@Encountered?5an?5irreversible?5deco@
CONST	SEGMENT
??_C@_0CBL@NHJPLOG@Encountered?5an?5irreversible?5deco@ DB 'Encountered a'
	DB	'n irreversible decorrelation transform block which operates o'
	DB	'n reversible codestream sample data.  While we allow such tra'
	DB	'nsforms to be processed during decompression, it is unreasona'
	DB	'ble to generate reversibly compressed component samples using'
	DB	' an irreversible inverse multi-component transform during com'
	DB	'pression.  Kakadu will not invert this transform during compr'
	DB	'ession.  This can prevent the compression process from procee'
	DB	'ding if there are no other paths back from the MCT output com'
	DB	'ponents to the codestream components.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0LC@FOOLOFAN@Encountered?5underdetermined?5syst@
CONST	SEGMENT
??_C@_0LC@FOOLOFAN@Encountered?5underdetermined?5syst@ DB 'Encountered un'
	DB	'derdetermined system while trying to invert a multi-component'
	DB	' transform block so as to convert MCT output components into '
	DB	'codestream components during compression.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@DNEDNIAC@?5?5The?5following?5additional?5expla@
CONST	SEGMENT
??_C@_0DK@DNEDNIAC@?5?5The?5following?5additional?5expla@ DB '  The follo'
	DB	'wing additional explanation is available ---- ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CLD@EIGIPOMM@Cannot?5perform?5forward?5multi?9com@
CONST	SEGMENT
??_C@_0CLD@EIGIPOMM@Cannot?5perform?5forward?5multi?9com@ DB 'Cannot perf'
	DB	'orm forward multi-component transform based on the source ima'
	DB	'ge components supplied.  The multi-component transform is def'
	DB	'ined from the perspective of decompression (i.e., synthesis, '
	DB	'or inverse transformation).  Not all of the defined transform'
	DB	' blocks may be invertible.  Also, if the defined transform bl'
	DB	'ocks do not use all codestream components to produce final ou'
	DB	'tput image components during decompression, it will not be po'
	DB	'ssible to work back from the final image components to codest'
	DB	'ream components which can be subjected to spatial wavelet tra'
	DB	'nsformation and coding.  One of these conditions has been enc'
	DB	'ountered with the configuration you are targeting during comp'
	DB	'ression.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DGI@MLEJMJIK@Cannot?5implement?5multi?9component@
CONST	SEGMENT
??_C@_0DGI@MLEJMJIK@Cannot?5implement?5multi?9component@ DB 'Cannot imple'
	DB	'ment multi-component transform.  It seems that one or more tr'
	DB	'ansform steps require image samples to be treated as reversib'
	DB	'le, where other steps require the same image samples to be tr'
	DB	'eated as irreversible.  This is illegal in Part-1 of the JPEG'
	DB	'2000 standard.  Although Part-2 is not clear on the matter, K'
	DB	'akadu''s implementation insists only that irreversibly compre'
	DB	'ssed samples not be subjected to reversible multi-component t'
	DB	'ransform processing during decompression -- this is eminently'
	DB	' reasonable, since exact reversible processing of data which '
	DB	'is not already exactly defined, makes no sense.  The reverse '
	DB	'case, in which reversibly compressed data is processed using '
	DB	'an irreversible multi-component transform, can make sense, pa'
	DB	'rticularly where there are multiple ways to render the same o'
	DB	'riginal reversibly compressed codestream components to MCT ou'
	DB	'tputs.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BDP@OMPOBFOO@Part?92?5codestream?5declares?5a?5cod@
CONST	SEGMENT
??_C@_0BDP@OMPOBFOO@Part?92?5codestream?5declares?5a?5cod@ DB 'Part-2 cod'
	DB	'estream declares a codestream component to have a different b'
	DB	'it-depth (Sprecision) to the output component (Mprecision) wi'
	DB	'th which it is directly associated.  While this is allowed, i'
	DB	't makes very little sense, and Kakadu will not perform the re'
	DB	'quired multiple scaling for irreversibly transformed componen'
	DB	'ts.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CCJ@OBHDBNBL@Cannot?5implement?5multi?9component@
CONST	SEGMENT
??_C@_0CCJ@OBHDBNBL@Cannot?5implement?5multi?9component@ DB 'Cannot imple'
	DB	'ment multi-component transform.  It seems that image componen'
	DB	'ts which must be processed by a common transform block (or de'
	DB	'correlating colour transform) have incompatible dimensions.  '
	DB	'This error may also be detected if the sub-sampling factors a'
	DB	'ssociated with an MCT output image component vary from tile t'
	DB	'o tile or if relative component size change from resolution l'
	DB	'evel to resolution level (due to incompatible Part-2 downsamp'
	DB	'ling factor style usage).  While these latter conditions migh'
	DB	't not be strictly illegal, they are clearly foolish.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
CONST	SEGMENT
??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@ DB 'Kakadu Core Error:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DHNHLPAL@component?5processor?$AA@
CONST	SEGMENT
??_C@_0BE@DHNHLPAL@component?5processor?$AA@ DB 'component processor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7kd_multi_analysis@@6Bkd_multi_transform@@@
CONST	SEGMENT
??_7kd_multi_analysis@@6Bkd_multi_transform@@@ DD FLAT:??_R4kd_multi_analysis@@6Bkd_multi_transform@@@ ; kd_multi_analysis::`vftable'
	DD	FLAT:??_Ekd_multi_analysis@@W3AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7kd_multi_analysis@@6Bkd_multi_analysis_base@@@
CONST	SEGMENT
??_7kd_multi_analysis@@6Bkd_multi_analysis_base@@@ DD FLAT:??_R4kd_multi_analysis@@6Bkd_multi_analysis_base@@@ ; kd_multi_analysis::`vftable'
	DD	FLAT:??_Ekd_multi_analysis@@UAEPAXI@Z
	DD	FLAT:?terminate_queues@kd_multi_analysis@@UAEXPAVkdu_thread_env@@@Z
	DD	FLAT:?get_size@kd_multi_analysis@@UAE?AUkdu_coords@@H@Z
	DD	FLAT:?exchange_line@kd_multi_analysis@@UAEPAVkdu_line_buf@@HPAV2@PAVkdu_thread_env@@@Z
	DD	FLAT:?is_line_precise@kd_multi_analysis@@UAE_NH@Z
	DD	FLAT:?is_line_absolute@kd_multi_analysis@@UAE_NH@Z
CONST	ENDS
;	COMDAT ??_7kd_multi_synthesis@@6Bkd_multi_transform@@@
CONST	SEGMENT
??_7kd_multi_synthesis@@6Bkd_multi_transform@@@ DD FLAT:??_R4kd_multi_synthesis@@6Bkd_multi_transform@@@ ; kd_multi_synthesis::`vftable'
	DD	FLAT:??_Ekd_multi_synthesis@@W3AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7kd_multi_synthesis@@6Bkd_multi_synthesis_base@@@
CONST	SEGMENT
??_7kd_multi_synthesis@@6Bkd_multi_synthesis_base@@@ DD FLAT:??_R4kd_multi_synthesis@@6Bkd_multi_synthesis_base@@@ ; kd_multi_synthesis::`vftable'
	DD	FLAT:??_Ekd_multi_synthesis@@UAEPAXI@Z
	DD	FLAT:?terminate_queues@kd_multi_synthesis@@UAEXPAVkdu_thread_env@@@Z
	DD	FLAT:?get_size@kd_multi_synthesis@@UAE?AUkdu_coords@@H@Z
	DD	FLAT:?get_line@kd_multi_synthesis@@UAEPAVkdu_line_buf@@HPAVkdu_thread_env@@@Z
	DD	FLAT:?is_line_precise@kd_multi_synthesis@@UAE_NH@Z
	DD	FLAT:?is_line_absolute@kd_multi_synthesis@@UAE_NH@Z
CONST	ENDS
;	COMDAT ??_7kd_multi_transform@@6B@
CONST	SEGMENT
??_7kd_multi_transform@@6B@ DD FLAT:??_R4kd_multi_transform@@6B@ ; kd_multi_transform::`vftable'
	DD	FLAT:??_Ekd_multi_transform@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7kd_multi_component@@6B@
CONST	SEGMENT
??_7kd_multi_component@@6B@ DD FLAT:??_R4kd_multi_component@@6B@ ; kd_multi_component::`vftable'
	DD	FLAT:??_Ekd_multi_component@@UAEPAXI@Z
	DD	FLAT:?do_job@kd_multi_component@@UAEXPAVkdu_thread_entity@@H@Z
CONST	ENDS
;	COMDAT ??_7kd_multi_dwt_block@@6B@
CONST	SEGMENT
??_7kd_multi_dwt_block@@6B@ DD FLAT:??_R4kd_multi_dwt_block@@6B@ ; kd_multi_dwt_block::`vftable'
	DD	FLAT:??_Ekd_multi_dwt_block@@UAEPAXI@Z
	DD	FLAT:?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z
	DD	FLAT:?normalize_coefficients@kd_multi_dwt_block@@UAEXXZ
	DD	FLAT:?propagate_bit_depths@kd_multi_dwt_block@@UAE_N_N0@Z
	DD	FLAT:?perform_transform@kd_multi_dwt_block@@UAEXXZ
	DD	FLAT:?prepare_for_inversion@kd_multi_dwt_block@@UAEPBDXZ
	DD	FLAT:?perform_inverse@kd_multi_dwt_block@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7kd_multi_dependency_block@@6B@
CONST	SEGMENT
??_7kd_multi_dependency_block@@6B@ DD FLAT:??_R4kd_multi_dependency_block@@6B@ ; kd_multi_dependency_block::`vftable'
	DD	FLAT:??_Ekd_multi_dependency_block@@UAEPAXI@Z
	DD	FLAT:?initialize@kd_multi_dependency_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z
	DD	FLAT:?normalize_coefficients@kd_multi_dependency_block@@UAEXXZ
	DD	FLAT:?propagate_bit_depths@kd_multi_block@@UAE_N_N0@Z
	DD	FLAT:?perform_transform@kd_multi_dependency_block@@UAEXXZ
	DD	FLAT:?prepare_for_inversion@kd_multi_dependency_block@@UAEPBDXZ
	DD	FLAT:?perform_inverse@kd_multi_dependency_block@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7kd_multi_rxform_block@@6B@
CONST	SEGMENT
??_7kd_multi_rxform_block@@6B@ DD FLAT:??_R4kd_multi_rxform_block@@6B@ ; kd_multi_rxform_block::`vftable'
	DD	FLAT:??_Ekd_multi_rxform_block@@UAEPAXI@Z
	DD	FLAT:?initialize@kd_multi_rxform_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z
	DD	FLAT:?normalize_coefficients@kd_multi_block@@UAEXXZ
	DD	FLAT:?propagate_bit_depths@kd_multi_block@@UAE_N_N0@Z
	DD	FLAT:?perform_transform@kd_multi_rxform_block@@UAEXXZ
	DD	FLAT:?prepare_for_inversion@kd_multi_rxform_block@@UAEPBDXZ
	DD	FLAT:?perform_inverse@kd_multi_rxform_block@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7kd_multi_matrix_block@@6B@
CONST	SEGMENT
??_7kd_multi_matrix_block@@6B@ DD FLAT:??_R4kd_multi_matrix_block@@6B@ ; kd_multi_matrix_block::`vftable'
	DD	FLAT:??_Ekd_multi_matrix_block@@UAEPAXI@Z
	DD	FLAT:?initialize@kd_multi_matrix_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z
	DD	FLAT:?normalize_coefficients@kd_multi_matrix_block@@UAEXXZ
	DD	FLAT:?propagate_bit_depths@kd_multi_block@@UAE_N_N0@Z
	DD	FLAT:?perform_transform@kd_multi_matrix_block@@UAEXXZ
	DD	FLAT:?prepare_for_inversion@kd_multi_matrix_block@@UAEPBDXZ
	DD	FLAT:?perform_inverse@kd_multi_matrix_block@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7kd_multi_null_block@@6B@
CONST	SEGMENT
??_7kd_multi_null_block@@6B@ DD FLAT:??_R4kd_multi_null_block@@6B@ ; kd_multi_null_block::`vftable'
	DD	FLAT:??_Ekd_multi_null_block@@UAEPAXI@Z
	DD	FLAT:?initialize@kd_multi_null_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z
	DD	FLAT:?normalize_coefficients@kd_multi_block@@UAEXXZ
	DD	FLAT:?propagate_bit_depths@kd_multi_block@@UAE_N_N0@Z
	DD	FLAT:?perform_transform@kd_multi_block@@UAEXXZ
	DD	FLAT:?prepare_for_inversion@kd_multi_block@@UAEPBDXZ
	DD	FLAT:?perform_inverse@kd_multi_block@@UAEXXZ
CONST	ENDS
;	COMDAT ??_C@_0ED@KEGEGAOK@Unimplemented?5multi?9component?5tr@
CONST	SEGMENT
??_C@_0ED@KEGEGAOK@Unimplemented?5multi?9component?5tr@ DB 'Unimplemented'
	DB	' multi-component transform block inversion procedure.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7kd_multi_block@@6B@
CONST	SEGMENT
??_7kd_multi_block@@6B@ DD FLAT:??_R4kd_multi_block@@6B@ ; kd_multi_block::`vftable'
	DD	FLAT:??_Ekd_multi_block@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:?normalize_coefficients@kd_multi_block@@UAEXXZ
	DD	FLAT:?propagate_bit_depths@kd_multi_block@@UAE_N_N0@Z
	DD	FLAT:?perform_transform@kd_multi_block@@UAEXXZ
	DD	FLAT:?prepare_for_inversion@kd_multi_block@@UAEPBDXZ
	DD	FLAT:?perform_inverse@kd_multi_block@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7kd_multi_synthesis_base@@6B@
CONST	SEGMENT
??_7kd_multi_synthesis_base@@6B@ DD FLAT:??_R4kd_multi_synthesis_base@@6B@ ; kd_multi_synthesis_base::`vftable'
	DD	FLAT:??_Ekd_multi_synthesis_base@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7kd_multi_analysis_base@@6B@
CONST	SEGMENT
??_7kd_multi_analysis_base@@6B@ DD FLAT:??_R4kd_multi_analysis_base@@6B@ ; kd_multi_analysis_base::`vftable'
	DD	FLAT:??_Ekd_multi_analysis_base@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7kdu_worker@@6B@
CONST	SEGMENT
??_7kdu_worker@@6B@ DD FLAT:??_R4kdu_worker@@6B@	; kdu_worker::`vftable'
	DD	FLAT:??_Ekdu_worker@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?prepare_network_for_inversion@kd_multi_analysis@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?prepare_network_for_inversion@kd_multi_analysis@@AAEXXZ$0
__ehfuncinfo$?prepare_network_for_inversion@kd_multi_analysis@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?prepare_network_for_inversion@kd_multi_analysis@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z$1
__ehfuncinfo$?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?create_resources@kd_multi_transform@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?create_resources@kd_multi_transform@@IAEXXZ$0
__ehfuncinfo$?create_resources@kd_multi_transform@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?create_resources@kd_multi_transform@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z$1
__ehfuncinfo$?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Ekd_multi_component@@UAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?normalize_coefficients@kd_multi_dwt_block@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?normalize_coefficients@kd_multi_dwt_block@@UAEXXZ$0
__ehfuncinfo$?normalize_coefficients@kd_multi_dwt_block@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?normalize_coefficients@kd_multi_dwt_block@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z$3
__ehfuncinfo$?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1kd_multi_dwt_block@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_multi_dwt_block@@UAE@XZ$0
__ehfuncinfo$??1kd_multi_dwt_block@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1kd_multi_dwt_block@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Ekd_multi_dwt_level@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?perform_inverse@kd_multi_dependency_block@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?perform_inverse@kd_multi_dependency_block@@UAEXXZ$0
__ehfuncinfo$?perform_inverse@kd_multi_dependency_block@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?perform_inverse@kd_multi_dependency_block@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?perform_transform@kd_multi_dependency_block@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?perform_transform@kd_multi_dependency_block@@UAEXXZ$0
__ehfuncinfo$?perform_transform@kd_multi_dependency_block@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?perform_transform@kd_multi_dependency_block@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?perform_inverse@kd_multi_rxform_block@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?perform_inverse@kd_multi_rxform_block@@UAEXXZ$0
__ehfuncinfo$?perform_inverse@kd_multi_rxform_block@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?perform_inverse@kd_multi_rxform_block@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?perform_transform@kd_multi_rxform_block@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?perform_transform@kd_multi_rxform_block@@UAEXXZ$0
__ehfuncinfo$?perform_transform@kd_multi_rxform_block@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?perform_transform@kd_multi_rxform_block@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kdu_kernels@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_Ekd_multi_analysis@@W3AEPAXI@Z
_TEXT	SEGMENT
??_Ekd_multi_analysis@@W3AEPAXI@Z PROC			; [thunk]:kd_multi_analysis::`vector deleting destructor', COMDAT
	sub	ecx, 4
	jmp	??_Ekd_multi_analysis@@UAEPAXI@Z
??_Ekd_multi_analysis@@W3AEPAXI@Z ENDP			; [thunk]:kd_multi_analysis::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_Ekd_multi_synthesis@@W3AEPAXI@Z
_TEXT	SEGMENT
??_Ekd_multi_synthesis@@W3AEPAXI@Z PROC			; [thunk]:kd_multi_synthesis::`vector deleting destructor', COMDAT
	sub	ecx, 4
	jmp	??_Ekd_multi_synthesis@@UAEPAXI@Z
??_Ekd_multi_synthesis@@W3AEPAXI@Z ENDP			; [thunk]:kd_multi_synthesis::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_multi_analysis@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_multi_analysis@@UAEPAXI@Z PROC			; kd_multi_analysis::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_multi_analysis@@UAE@XZ		; kd_multi_analysis::~kd_multi_analysis
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	84					; 00000054H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_multi_analysis@@UAEPAXI@Z ENDP			; kd_multi_analysis::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?advance_line@kd_multi_analysis@@AAEXPAUkd_multi_line@@HPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_last_stripe$1 = -16					; size = 1
_first_available_row$1$ = -12				; size = 4
tv803 = -8						; size = 4
_this$1$ = -4						; size = 4
_line$ = 8						; size = 4
_process_ycc$1$ = 11					; size = 1
_new_row_idx$ = 12					; size = 4
_env$ = 16						; size = 4
?advance_line@kd_multi_analysis@@AAEXPAUkd_multi_line@@HPAVkdu_thread_env@@@Z PROC ; kd_multi_analysis::advance_line, COMDAT
; _this$ = ecx

; 1471 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1472 :   assert(line->num_consumers == 1);       // Must be true by the time this
; 1473 :   assert(line->row_idx==(new_row_idx-1)); // function is invoked.
; 1474 :   line->row_idx = new_row_idx;

	mov	eax, DWORD PTR _line$[ebp]
	mov	edx, DWORD PTR _new_row_idx$[ebp]
	mov	DWORD PTR _this$1$[ebp], ecx

; 1475 :   line->waiting_for_inversion = false; // Unless proven otherwise
; 1476 :   if (line->is_constant)

	cmp	BYTE PTR [eax+35], 0
	mov	DWORD PTR [eax+20], edx
	mov	BYTE PTR [eax+28], 0
	jne	$LN20@advance_li
	push	esi
	push	edi
$LL50@advance_li:

; 1477 :     return; // Nothing more to do
; 1478 : 
; 1479 :   int n;
; 1480 :   kd_multi_block *block = line->block;

	mov	esi, DWORD PTR [eax+52]

; 1481 :   if ((block != NULL) && block->is_null_transform)

	test	esi, esi
	je	$LN27@advance_li
	cmp	BYTE PTR [esi+4], 0
	je	$LN23@advance_li

; 1482 :     { // Pass through to the corresponding dependency line, if any
; 1483 :       n = (int)(line - block->components);

	mov	ecx, eax
	mov	eax, -2004318071			; 88888889H
	sub	ecx, DWORD PTR [esi+12]
	imul	ecx

; 1484 :       assert((n >= 0) && (n < block->num_dependencies));
; 1485 :       kd_multi_line *dep = block->dependencies[n];

	mov	eax, DWORD PTR [esi+20]
	add	edx, ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	edi, DWORD PTR [eax+ecx*4]

; 1486 :       if ((dep != NULL) && (dep->row_idx >= new_row_idx))

	test	edi, edi
	je	$LN97@advance_li
	mov	eax, DWORD PTR _new_row_idx$[ebp]
	cmp	DWORD PTR [edi+20], eax
	jge	SHORT $LN95@advance_li

; 1491 :         }
; 1492 :       if (dep == NULL)
; 1493 :         return; // Nothing to do; this dependency need not be written
; 1494 :       assert((dep->num_consumers > 0) && !dep->is_constant);
; 1495 :       dep->copy(line,-dep->rev_offset,-dep->irrev_offset);

	movss	xmm0, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [edi+40]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	neg	eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, edi
	push	eax
	push	DWORD PTR _line$[ebp]
	call	?copy@kd_multi_line@@QAEXPAU1@HM@Z	; kd_multi_line::copy
	mov	edx, DWORD PTR _new_row_idx$[ebp]

; 1496 :       advance_line(dep,new_row_idx,env);

	mov	eax, edi
	mov	DWORD PTR [edi+20], edx
	mov	BYTE PTR [edi+28], 0
	cmp	BYTE PTR [edi+35], 0
	mov	DWORD PTR _line$[ebp], eax
	je	SHORT $LL50@advance_li
	pop	edi
	pop	esi

; 1609 :     }
; 1610 : 
; 1611 :   // If we get here, we have used the new line
; 1612 :   assert(!line->waiting_for_inversion);
; 1613 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN95@advance_li:

; 1487 :         { // This dependency has been written already
; 1488 :           assert(dep->num_consumers > 1);
; 1489 :           dep->num_consumers--;

	dec	DWORD PTR [edi+24]

; 1490 :           block->dependencies[n] = dep = NULL;

	mov	eax, DWORD PTR [esi+20]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+ecx*4], 0

; 1609 :     }
; 1610 : 
; 1611 :   // If we get here, we have used the new line
; 1612 :   assert(!line->waiting_for_inversion);
; 1613 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN23@advance_li:

; 1497 :     }
; 1498 :   else if (block != NULL)
; 1499 :     { // See if we can invert the transform block
; 1500 :       line->waiting_for_inversion = true;

	mov	BYTE PTR [eax+28], 1
	dec	DWORD PTR [esi+28]

; 1501 :       block->outstanding_consumers--;
; 1502 :       if (block->outstanding_consumers > 0)

	cmp	DWORD PTR [esi+28], 0
	jg	$LN97@advance_li

; 1503 :         return; // Can't process the block yet
; 1504 :       kd_multi_line *dep;
; 1505 :       while (block->num_available_dependencies < block->num_dependencies)

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, DWORD PTR [esi+16]
	jge	SHORT $LN3@advance_li
$LL2@advance_li:

; 1506 :         {
; 1507 :           dep = block->dependencies[block->num_available_dependencies];

	mov	ecx, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [edi+ecx*4]

; 1508 :           if ((dep != NULL) && dep->is_constant)

	test	eax, eax
	je	SHORT $LN31@advance_li
	cmp	BYTE PTR [eax+35], 0
	je	SHORT $LN30@advance_li

; 1509 :             { // Should not happen, but just in case
; 1510 :               block->dependencies[block->num_available_dependencies]=dep=NULL;

	mov	DWORD PTR [edi+ecx*4], 0

; 1511 :             }
; 1512 :           if ((dep != NULL) && (dep->row_idx < new_row_idx) &&

	jmp	SHORT $LN31@advance_li
$LN30@advance_li:
	cmp	DWORD PTR [eax+20], edx
	jge	SHORT $LN31@advance_li
	cmp	BYTE PTR [eax+28], 0
	jne	$LN97@advance_li
$LN31@advance_li:

; 1513 :               dep->waiting_for_inversion)
; 1514 :             return; // Can't write inversion results yet
; 1515 :           block->num_available_dependencies++;

	inc	DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, DWORD PTR [esi+16]
	jl	SHORT $LL2@advance_li
$LN3@advance_li:

; 1516 :         }
; 1517 : 
; 1518 :       // If we get here, we can run the transform, but first remove any
; 1519 :       // dependencies which have already been written
; 1520 :       for (n=0; n < block->num_dependencies; n++)

	xor	ecx, ecx
	cmp	DWORD PTR [esi+16], ecx
	jle	SHORT $LN5@advance_li
	npad	1
$LL6@advance_li:

; 1521 :         if (((dep = block->dependencies[n]) != NULL) &&

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN4@advance_li
	cmp	DWORD PTR [eax+20], edx
	jl	SHORT $LN4@advance_li

; 1522 :             (dep->row_idx >= new_row_idx))
; 1523 :           {
; 1524 :             assert(dep->num_consumers > 1);
; 1525 :             dep->num_consumers--;

	dec	DWORD PTR [eax+24]

; 1526 :             block->dependencies[n] = NULL;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+ecx*4], 0
$LN4@advance_li:

; 1516 :         }
; 1517 : 
; 1518 :       // If we get here, we can run the transform, but first remove any
; 1519 :       // dependencies which have already been written
; 1520 :       for (n=0; n < block->num_dependencies; n++)

	inc	ecx
	cmp	ecx, DWORD PTR [esi+16]
	jl	SHORT $LL6@advance_li
$LN5@advance_li:

; 1527 :           }
; 1528 : 
; 1529 :       block->perform_inverse();

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+24]

; 1530 : 
; 1531 :       for (n=0; n < block->num_dependencies; n++)

	xor	edi, edi
	cmp	DWORD PTR [esi+16], edi
	jle	SHORT $LN8@advance_li
$LL9@advance_li:

; 1532 :         if ((dep = block->dependencies[n]) != NULL)

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	SHORT $LN7@advance_li

; 1533 :           advance_line(dep,new_row_idx,env);

	push	DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	DWORD PTR _new_row_idx$[ebp]
	push	eax
	call	?advance_line@kd_multi_analysis@@AAEXPAUkd_multi_line@@HPAVkdu_thread_env@@@Z ; kd_multi_analysis::advance_line
$LN7@advance_li:

; 1530 : 
; 1531 :       for (n=0; n < block->num_dependencies; n++)

	inc	edi
	cmp	edi, DWORD PTR [esi+16]
	jl	SHORT $LL9@advance_li
$LN8@advance_li:

; 1534 :       for (n=0; n < block->num_components; n++)

	xor	ecx, ecx
	cmp	DWORD PTR [esi+8], ecx
	jle	SHORT $LN11@advance_li
	mov	edx, DWORD PTR [esi+12]
	xor	eax, eax
	npad	5
$LL12@advance_li:

; 1535 :         {
; 1536 :           block->components[n].waiting_for_inversion = false;

	mov	BYTE PTR [eax+edx+28], 0

; 1537 :           if (block->components[n].num_consumers > 0)

	mov	edx, DWORD PTR [esi+12]
	cmp	DWORD PTR [eax+edx+24], 0
	jle	SHORT $LN10@advance_li

; 1538 :             {
; 1539 :               assert(block->components[n].num_consumers == 1);
; 1540 :               block->outstanding_consumers++;

	inc	DWORD PTR [esi+28]
$LN10@advance_li:

; 1534 :       for (n=0; n < block->num_components; n++)

	inc	ecx
	add	eax, 60					; 0000003cH
	cmp	ecx, DWORD PTR [esi+8]
	jl	SHORT $LL12@advance_li
$LN11@advance_li:
	pop	edi

; 1541 :             }
; 1542 :         }
; 1543 :       block->num_available_dependencies = 0;

	mov	DWORD PTR [esi+24], 0
	pop	esi

; 1609 :     }
; 1610 : 
; 1611 :   // If we get here, we have used the new line
; 1612 :   assert(!line->waiting_for_inversion);
; 1613 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN27@advance_li:

; 1544 :     }
; 1545 :   else
; 1546 :     { // Push the line into the relevant codestream component engine
; 1547 :       n = line->collection_idx;  assert(n >= 0);
; 1548 :       assert(codestream_collection->components[n] == line);
; 1549 :       bool process_ycc = use_ycc && (n < 3);

	mov	esi, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	cmp	BYTE PTR [esi+8], 0
	je	SHORT $LN46@advance_li
	cmp	ecx, 3
	jge	SHORT $LN46@advance_li

; 1550 :       if (process_ycc)
; 1551 :         {
; 1552 :           line->waiting_for_inversion = true;

	mov	BYTE PTR [eax+28], 1

; 1553 :           kd_multi_line **ycc_lines = codestream_collection->components;
; 1554 :           for (n=0; n < 3; n++)

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+24]
	mov	BYTE PTR _process_ycc$1$[ebp], 1
	mov	esi, DWORD PTR [eax+4]
	npad	5
$LL15@advance_li:

; 1555 :             if (ycc_lines[n]->row_idx < new_row_idx)

	mov	eax, DWORD PTR [esi+ecx*4]
	cmp	DWORD PTR [eax+20], edx
	jl	$LN97@advance_li

; 1553 :           kd_multi_line **ycc_lines = codestream_collection->components;
; 1554 :           for (n=0; n < 3; n++)

	inc	ecx
	cmp	ecx, 3
	jl	SHORT $LL15@advance_li

; 1556 :               return; // Cannot run RCT/ICT yet
; 1557 :           kdu_convert_rgb_to_ycc(ycc_lines[0]->line,

	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	?kdu_convert_rgb_to_ycc@@YAXAAVkdu_line_buf@@00@Z ; kdu_convert_rgb_to_ycc

; 1558 :                                  ycc_lines[1]->line,
; 1559 :                                  ycc_lines[2]->line);
; 1560 :           for (n=0; n < 3; n++)
; 1561 :             {
; 1562 :               assert(ycc_lines[n]->waiting_for_inversion);
; 1563 :               ycc_lines[n]->waiting_for_inversion = false;

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH

; 1564 :             }
; 1565 :           n = 0;

	mov	edx, DWORD PTR _new_row_idx$[ebp]
	xor	ecx, ecx
	mov	BYTE PTR [eax+28], 0
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+28], 0
	mov	eax, DWORD PTR [esi+8]
	mov	esi, DWORD PTR _this$1$[ebp]
	mov	BYTE PTR [eax+28], 0
	jmp	SHORT $LN94@advance_li
$LN46@advance_li:

; 1544 :     }
; 1545 :   else
; 1546 :     { // Push the line into the relevant codestream component engine
; 1547 :       n = line->collection_idx;  assert(n >= 0);
; 1548 :       assert(codestream_collection->components[n] == line);
; 1549 :       bool process_ycc = use_ycc && (n < 3);

	mov	BYTE PTR _process_ycc$1$[ebp], 0
$LN94@advance_li:
	imul	edi, ecx, 112
	mov	DWORD PTR tv803[ebp], edi
	npad	6
$LL21@advance_li:

; 1566 :         }
; 1567 :       do {
; 1568 :           kd_multi_component *comp = codestream_components + n;

	mov	esi, DWORD PTR [esi+20]
	add	esi, edi

; 1569 :           if (comp->num_available_rows == 0)

	cmp	DWORD PTR [esi+80], 0
	jne	$LN37@advance_li

; 1570 :             { // We have generated all rows
; 1571 :               int num_rows_left = comp->line.size.y - (new_row_idx+1);

	mov	edi, DWORD PTR [esi+24]
	sub	edi, edx
	sub	edi, 1

; 1572 :               bool last_stripe = (num_rows_left == 0);

	sete	BYTE PTR _last_stripe$1[ebp]

; 1573 :               if (comp->double_buffering)

	cmp	BYTE PTR [esi+72], 0
	je	SHORT $LN38@advance_li

; 1574 :                 { // Convert available rows into an active job in progress
; 1575 :                   assert(env != NULL);
; 1576 :                   int first_available_row = 0;

	xor	ecx, ecx
	mov	DWORD PTR _first_available_row$1$[ebp], ecx

; 1577 :                   if (comp->num_rows_in_progress)

	cmp	DWORD PTR [esi+88], ecx
	je	SHORT $LN41@advance_li

; 1578 :                     { // Do outstanding work
; 1579 :                       env->process_jobs(comp->env_queue);

	push	1
	push	ecx
	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _env$[ebp]
	call	?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z ; kdu_thread_entity::process_jobs

; 1580 :                       if (comp->first_row_in_progress == 0)

	cmp	DWORD PTR [esi+84], 0
	jne	SHORT $LN96@advance_li

; 1581 :                         first_available_row = comp->num_rows_in_progress;

	mov	ecx, DWORD PTR [esi+88]
	jmp	SHORT $LN41@advance_li
$LN96@advance_li:
	mov	ecx, DWORD PTR _first_available_row$1$[ebp]
$LN41@advance_li:

; 1582 :                     }
; 1583 :                   comp->first_row_in_progress = first_available_row;
; 1584 :                   comp->num_rows_in_progress =

	mov	eax, DWORD PTR [esi+76]
	sub	eax, ecx
	mov	DWORD PTR [esi+84], ecx
	mov	DWORD PTR [esi+88], eax

; 1585 :                     comp->next_available_row - first_available_row;
; 1586 :                   if (first_available_row > 0)

	test	ecx, ecx
	jle	SHORT $LN42@advance_li

; 1587 :                     comp->next_available_row = 0;

	mov	DWORD PTR [esi+76], 0
$LN42@advance_li:

; 1588 :                   env->add_jobs(comp->env_queue,1,last_stripe);

	mov	ecx, DWORD PTR _env$[ebp]
	push	0
	push	DWORD PTR _last_stripe$1[ebp]
	push	1
	push	DWORD PTR [esi+8]
	call	?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z ; kdu_thread_entity::add_jobs

; 1589 :                 }
; 1590 :               else

	jmp	SHORT $LN39@advance_li
$LN38@advance_li:

; 1591 :                 {
; 1592 :                   assert(((comp->env_queue == NULL) && (env == NULL)) ||
; 1593 :                          ((comp->env_queue != NULL) && (env != NULL)));
; 1594 :                   comp->num_rows_in_progress = comp->next_available_row;

	mov	eax, DWORD PTR [esi+76]

; 1595 :                   comp->next_available_row = comp->first_row_in_progress = 0;
; 1596 :                   comp->do_job(env,0);

	mov	ecx, DWORD PTR _env$[ebp]
	mov	DWORD PTR [esi+88], eax
	mov	eax, DWORD PTR [esi]
	push	0
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR [esi+84], 0
	mov	DWORD PTR [esi+76], 0
	call	DWORD PTR [eax+4]

; 1597 :                   comp->num_rows_in_progress = 0;

	mov	DWORD PTR [esi+88], 0
$LN39@advance_li:

; 1598 :                 }
; 1599 :               comp->num_available_rows =

	mov	eax, DWORD PTR [esi+92]
	cmp	edi, eax
	cmovl	eax, edi
	mov	edi, DWORD PTR tv803[ebp]
	mov	DWORD PTR [esi+80], eax
$LN37@advance_li:

; 1600 :                 (num_rows_left < comp->max_available_rows)?
; 1601 :                   num_rows_left:(comp->max_available_rows);
; 1602 :             }
; 1603 :           if (comp->num_available_rows > 0)

	mov	eax, DWORD PTR [esi+80]
	test	eax, eax
	jle	SHORT $LN19@advance_li

; 1604 :             {
; 1605 :               comp->line.line = comp->buffer[comp->next_available_row++];

	mov	edx, DWORD PTR [esi+76]
	mov	eax, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR [edx+edx*2]
	movq	xmm0, QWORD PTR [eax+ecx*4]
	movq	QWORD PTR [esi+12], xmm0
	mov	eax, DWORD PTR [eax+ecx*4+8]

; 1606 :               comp->num_available_rows--;

	dec	DWORD PTR [esi+80]
	mov	DWORD PTR [esi+20], eax
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi+76], eax
$LN19@advance_li:

; 1607 :             }
; 1608 :         } while (process_ycc && ((++n) < 3));

	cmp	BYTE PTR _process_ycc$1$[ebp], 0
	je	SHORT $LN97@advance_li
	mov	edx, DWORD PTR _new_row_idx$[ebp]
	add	edi, 112				; 00000070H
	mov	esi, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR tv803[ebp], edi
	cmp	edi, 336				; 00000150H
	jl	$LL21@advance_li
$LN97@advance_li:
	pop	edi
	pop	esi
$LN20@advance_li:

; 1609 :     }
; 1610 : 
; 1611 :   // If we get here, we have used the new line
; 1612 :   assert(!line->waiting_for_inversion);
; 1613 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?advance_line@kd_multi_analysis@@AAEXPAUkd_multi_line@@HPAVkdu_thread_env@@@Z ENDP ; kd_multi_analysis::advance_line
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?prepare_network_for_inversion@kd_multi_analysis@@AAEXXZ
_TEXT	SEGMENT
_e$2 = -44						; size = 20
_line$1$ = -24						; size = 4
_n$6$ = -20						; size = 4
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?prepare_network_for_inversion@kd_multi_analysis@@AAEXXZ PROC ; kd_multi_analysis::prepare_network_for_inversion, COMDAT
; _this$ = ecx

; 1344 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?prepare_network_for_inversion@kd_multi_analysis@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 1345 :   int n;
; 1346 :   kd_multi_block *block;
; 1347 :   const char *expl, *failure_explanation = NULL;
; 1348 : 
; 1349 :   for (block=block_tail; block != NULL; block=block->prev)

	mov	esi, DWORD PTR [edi+16]
	xor	ebx, ebx
	test	esi, esi
	je	$LN3@prepare_ne
	npad	6
$LL4@prepare_ne:

; 1350 :     {
; 1351 :       if (block->is_null_transform)

	cmp	BYTE PTR [esi+4], 0
	je	SHORT $LN32@prepare_ne

; 1352 :         {
; 1353 :           for (n=0; n < block->num_dependencies; n++)

	xor	ecx, ecx
	cmp	DWORD PTR [esi+16], ecx
	jle	$LN2@prepare_ne
	xor	edx, edx
$LL7@prepare_ne:

; 1354 :             {
; 1355 :               assert(n < block->num_components);
; 1356 :               if ((block->components[n].num_consumers == 0) &&

	mov	eax, DWORD PTR [esi+12]
	cmp	DWORD PTR [edx+eax+24], 0
	jne	SHORT $LN5@prepare_ne
	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN5@prepare_ne

; 1357 :                   (block->dependencies[n] != NULL))
; 1358 :                 {
; 1359 :                   block->dependencies[n]->num_consumers--;

	dec	DWORD PTR [eax+24]

; 1360 :                   block->dependencies[n] = NULL;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+ecx*4], 0
$LN5@prepare_ne:

; 1352 :         {
; 1353 :           for (n=0; n < block->num_dependencies; n++)

	inc	ecx
	add	edx, 60					; 0000003cH
	cmp	ecx, DWORD PTR [esi+16]
	jl	SHORT $LL7@prepare_ne

; 1361 :                 }
; 1362 :             }
; 1363 :         }
; 1364 :       else if ((expl = block->prepare_for_inversion()) != NULL)

	jmp	SHORT $LN2@prepare_ne
$LN32@prepare_ne:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+20]
	test	eax, eax
	je	SHORT $LN2@prepare_ne

; 1367 :           for (n=0; n < block->num_components; n++)

	xor	ecx, ecx
	mov	ebx, eax
	cmp	DWORD PTR [esi+8], ecx
	jle	SHORT $LN9@prepare_ne

; 1365 :         {
; 1366 :           failure_explanation = expl;

	xor	edx, edx
$LL10@prepare_ne:

; 1368 :             block->components[n].is_constant = true;

	mov	eax, DWORD PTR [esi+12]
	lea	edx, DWORD PTR [edx+60]
	inc	ecx
	mov	BYTE PTR [edx+eax-25], 1
	cmp	ecx, DWORD PTR [esi+8]
	jl	SHORT $LL10@prepare_ne
$LN9@prepare_ne:

; 1369 :                  // This notifies downstream blocks that there is no need to
; 1370 :                  // write to this component.
; 1371 :           for (n=0; n < block->num_dependencies; n++)

	xor	ecx, ecx
	cmp	DWORD PTR [esi+16], ecx
	jle	SHORT $LN2@prepare_ne
	npad	3
$LL13@prepare_ne:

; 1372 :             if (block->dependencies[n] != NULL)

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN11@prepare_ne

; 1373 :               {
; 1374 :                 block->dependencies[n]->num_consumers--;

	dec	DWORD PTR [eax+24]

; 1375 :                 block->dependencies[n] = NULL;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+ecx*4], 0
$LN11@prepare_ne:

; 1369 :                  // This notifies downstream blocks that there is no need to
; 1370 :                  // write to this component.
; 1371 :           for (n=0; n < block->num_dependencies; n++)

	inc	ecx
	cmp	ecx, DWORD PTR [esi+16]
	jl	SHORT $LL13@prepare_ne
$LN2@prepare_ne:

; 1345 :   int n;
; 1346 :   kd_multi_block *block;
; 1347 :   const char *expl, *failure_explanation = NULL;
; 1348 : 
; 1349 :   for (block=block_tail; block != NULL; block=block->prev)

	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	jne	$LL4@prepare_ne
$LN3@prepare_ne:

; 1376 :               }
; 1377 :         }
; 1378 :     }
; 1379 : 
; 1380 :   // Make a forward sweep through the blocks, removing any dependencies which
; 1381 :   // are now constant
; 1382 :   for (block=xform_blocks; block != NULL; block=block->next)

	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	je	SHORT $LN15@prepare_ne
	npad	1
$LL16@prepare_ne:

; 1383 :     {
; 1384 :       for (n=0; n < block->num_dependencies; n++)

	xor	edx, edx
	cmp	DWORD PTR [ecx+16], edx
	jle	SHORT $LN14@prepare_ne
	xor	esi, esi
	npad	7
$LL19@prepare_ne:
	mov	eax, DWORD PTR [ecx+20]
	lea	edi, DWORD PTR [eax+edx*4]

; 1385 :         {
; 1386 :           kd_multi_line *line = block->dependencies[n];

	mov	eax, DWORD PTR [edi]

; 1387 :           if ((line == NULL) || !line->is_constant)

	test	eax, eax
	je	SHORT $LN17@prepare_ne
	cmp	BYTE PTR [eax+35], 0
	je	SHORT $LN17@prepare_ne

; 1388 :             continue;
; 1389 :           block->dependencies[n] = NULL;

	mov	DWORD PTR [edi], 0

; 1390 :           line->num_consumers--;

	dec	DWORD PTR [eax+24]

; 1391 :           if (block->is_null_transform)

	cmp	BYTE PTR [ecx+4], 0
	je	SHORT $LN17@prepare_ne

; 1392 :             block->components[n].is_constant = true;

	mov	eax, DWORD PTR [ecx+12]
	mov	BYTE PTR [eax+esi+35], 1
$LN17@prepare_ne:

; 1383 :     {
; 1384 :       for (n=0; n < block->num_dependencies; n++)

	inc	edx
	add	esi, 60					; 0000003cH
	cmp	edx, DWORD PTR [ecx+16]
	jl	SHORT $LL19@prepare_ne
$LN14@prepare_ne:

; 1376 :               }
; 1377 :         }
; 1378 :     }
; 1379 : 
; 1380 :   // Make a forward sweep through the blocks, removing any dependencies which
; 1381 :   // are now constant
; 1382 :   for (block=xform_blocks; block != NULL; block=block->next)

	mov	ecx, DWORD PTR [ecx+32]
	test	ecx, ecx
	jne	SHORT $LL16@prepare_ne
$LN15@prepare_ne:

; 1393 :         }
; 1394 :     }
; 1395 : 
; 1396 :   // Now check to see if we will be able to generate all codestream components
; 1397 :   for (n=0; n < codestream_collection->num_components; n++)

	mov	ecx, DWORD PTR _this$1$[ebp]
	xor	esi, esi
	mov	eax, DWORD PTR [ecx+24]
	cmp	DWORD PTR [eax], esi
	jle	SHORT $LN21@prepare_ne
$LL22@prepare_ne:

; 1398 :     if (codestream_collection->components[n]->num_consumers <= 0)

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+esi*4]
	cmp	DWORD PTR [eax+24], 0
	jg	SHORT $LN20@prepare_ne

; 1399 :       { KDU_ERROR(e,0x26080501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0CLD@EIGIPOMM@Cannot?5perform?5forward?5multi?9com@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1399 :       { KDU_ERROR(e,0x26080501); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1412 :         if (failure_explanation != NULL)

	test	ebx, ebx
	je	SHORT $LN41@prepare_ne
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0DK@DNEDNIAC@?5?5The?5following?5additional?5expla@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	ebx
	call	DWORD PTR [eax+8]
$LN41@prepare_ne:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1415 :       }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _this$1$[ebp]
$LN20@prepare_ne:

; 1393 :         }
; 1394 :     }
; 1395 : 
; 1396 :   // Now check to see if we will be able to generate all codestream components
; 1397 :   for (n=0; n < codestream_collection->num_components; n++)

	mov	eax, DWORD PTR [ecx+24]
	inc	esi
	cmp	esi, DWORD PTR [eax]
	jl	SHORT $LL22@prepare_ne
$LN21@prepare_ne:

; 1416 : 
; 1417 :   // Finally, make sure that there is only one consumer for each output
; 1418 :   // row (means one consumer for each source row from the compressor's
; 1419 :   // perspective).
; 1420 :   for (n=0; n < output_collection->num_components; n++)

	mov	eax, DWORD PTR [ecx+28]
	xor	edi, edi
	mov	DWORD PTR _n$6$[ebp], edi
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN24@prepare_ne
$LL25@prepare_ne:

; 1421 :     {
; 1422 :       kd_multi_line *line = output_collection->components[n];

	mov	eax, DWORD PTR [eax+4]

; 1423 :       for (block=block_tail;

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _line$1$[ebp], eax

; 1424 :            (block != NULL) && (line->num_consumers > 1);

	test	edx, edx
	je	SHORT $LN23@prepare_ne
$LL28@prepare_ne:
	cmp	DWORD PTR [eax+24], 1
	jle	SHORT $LN23@prepare_ne

; 1426 :         for (int k=0; k < block->num_dependencies; k++)

	mov	esi, DWORD PTR [edx+16]
	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN93@prepare_ne

; 1427 :           if (block->dependencies[k] == output_collection->components[n])

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ebx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, ebx
$LL31@prepare_ne:
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN61@prepare_ne

; 1426 :         for (int k=0; k < block->num_dependencies; k++)

	inc	ecx
	add	eax, 4
	cmp	ecx, esi
	jl	SHORT $LL31@prepare_ne

; 1427 :           if (block->dependencies[k] == output_collection->components[n])

	mov	eax, DWORD PTR _line$1$[ebp]
	mov	edi, DWORD PTR _n$6$[ebp]
$LN93@prepare_ne:
	mov	ecx, DWORD PTR _this$1$[ebp]
$LN26@prepare_ne:

; 1425 :            block=block->prev)

	mov	edx, DWORD PTR [edx+36]
	test	edx, edx
	jne	SHORT $LL28@prepare_ne
$LN23@prepare_ne:

; 1416 : 
; 1417 :   // Finally, make sure that there is only one consumer for each output
; 1418 :   // row (means one consumer for each source row from the compressor's
; 1419 :   // perspective).
; 1420 :   for (n=0; n < output_collection->num_components; n++)

	mov	eax, DWORD PTR [ecx+28]
	inc	edi
	mov	DWORD PTR _n$6$[ebp], edi
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL25@prepare_ne
$LN24@prepare_ne:

; 1431 :               break;
; 1432 :             }
; 1433 :     }
; 1434 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@prepare_ne:

; 1428 :             {
; 1429 :               block->dependencies[k] = NULL;
; 1430 :               output_collection->components[n]->num_consumers--;

	mov	edi, DWORD PTR _n$6$[ebp]
	mov	DWORD PTR [ebx+ecx*4], 0
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edi*4]
	dec	DWORD PTR [eax+24]
	mov	eax, DWORD PTR _line$1$[ebp]
	jmp	SHORT $LN26@prepare_ne
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?prepare_network_for_inversion@kd_multi_analysis@@AAEXXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?prepare_network_for_inversion@kd_multi_analysis@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?prepare_network_for_inversion@kd_multi_analysis@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?prepare_network_for_inversion@kd_multi_analysis@@AAEXXZ ENDP ; kd_multi_analysis::prepare_network_for_inversion
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?is_line_absolute@kd_multi_analysis@@UAE_NH@Z
_TEXT	SEGMENT
_comp_idx$ = 8						; size = 4
?is_line_absolute@kd_multi_analysis@@UAE_NH@Z PROC	; kd_multi_analysis::is_line_absolute, COMDAT
; _this$ = ecx

; 1635 : {

	push	ebp
	mov	ebp, esp

; 1636 :   if ((output_collection == NULL) ||
; 1637 :       (comp_idx < 0) || (comp_idx >= output_collection->num_components))

	mov	eax, DWORD PTR [ecx+28]
	test	eax, eax
	je	SHORT $LN3@is_line_ab
	mov	ecx, DWORD PTR _comp_idx$[ebp]
	test	ecx, ecx
	js	SHORT $LN3@is_line_ab
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@is_line_ab

; 1639 :   kd_multi_line *line = output_collection->components[comp_idx];
; 1640 :   return line->reversible;

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	al, BYTE PTR [eax+32]

; 1641 : }

	pop	ebp
	ret	4
$LN3@is_line_ab:

; 1638 :     return false;

	xor	al, al

; 1641 : }

	pop	ebp
	ret	4
?is_line_absolute@kd_multi_analysis@@UAE_NH@Z ENDP	; kd_multi_analysis::is_line_absolute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?is_line_precise@kd_multi_analysis@@UAE_NH@Z
_TEXT	SEGMENT
_comp_idx$ = 8						; size = 4
?is_line_precise@kd_multi_analysis@@UAE_NH@Z PROC	; kd_multi_analysis::is_line_precise, COMDAT
; _this$ = ecx

; 1621 : {

	push	ebp
	mov	ebp, esp

; 1622 :   if ((output_collection == NULL) ||
; 1623 :       (comp_idx < 0) || (comp_idx >= output_collection->num_components))

	mov	eax, DWORD PTR [ecx+28]
	test	eax, eax
	je	SHORT $LN3@is_line_pr
	mov	ecx, DWORD PTR _comp_idx$[ebp]
	test	ecx, ecx
	js	SHORT $LN3@is_line_pr
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@is_line_pr

; 1625 :   kd_multi_line *line = output_collection->components[comp_idx];
; 1626 :   return line->need_precise;

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	al, BYTE PTR [eax+34]

; 1627 : }

	pop	ebp
	ret	4
$LN3@is_line_pr:

; 1624 :     return false;

	xor	al, al

; 1627 : }

	pop	ebp
	ret	4
?is_line_precise@kd_multi_analysis@@UAE_NH@Z ENDP	; kd_multi_analysis::is_line_precise
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?exchange_line@kd_multi_analysis@@UAEPAVkdu_line_buf@@HPAV2@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_row_idx$1$ = -4					; size = 4
_comp_idx$ = 8						; size = 4
_written$ = 12						; size = 4
_env$ = 16						; size = 4
?exchange_line@kd_multi_analysis@@UAEPAVkdu_line_buf@@HPAV2@PAVkdu_thread_env@@@Z PROC ; kd_multi_analysis::exchange_line, COMDAT
; _this$ = ecx

; 1443 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 1444 :   assert((comp_idx >= 0) && (comp_idx < output_collection->num_components));
; 1445 :   int row_idx = source_row_counters[comp_idx];

	mov	ecx, DWORD PTR _comp_idx$[ebp]
	mov	eax, DWORD PTR [edi+80]
	mov	edx, DWORD PTR [eax+ecx*4]

; 1446 :   kd_multi_line *line = output_collection->components[comp_idx];

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR _row_idx$1$[ebp], edx
	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax+ecx*4]

; 1447 :   if (row_idx >= line->size.y)

	cmp	edx, DWORD PTR [esi+12]
	jl	SHORT $LN2@exchange_l

; 1448 :     return NULL;

	pop	edi
	xor	eax, eax
	pop	esi

; 1459 :     return NULL;
; 1460 :   else
; 1461 :     return &(line->line);
; 1462 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN2@exchange_l:

; 1449 :   assert(line->num_consumers == 1);
; 1450 :   if (written != NULL)

	cmp	DWORD PTR _written$[ebp], 0
	je	SHORT $LN3@exchange_l

; 1451 :     {
; 1452 :       assert((written == &(line->line)) && !line->waiting_for_inversion);
; 1453 :       line->apply_offset(-line->rev_offset,-line->irrev_offset);

	movss	xmm0, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [esi+40]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	neg	eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, esi
	push	eax
	call	?apply_offset@kd_multi_line@@QAEXHM@Z	; kd_multi_line::apply_offset

; 1454 :       advance_line(line,row_idx,env);

	push	DWORD PTR _env$[ebp]
	mov	ecx, edi
	push	DWORD PTR _row_idx$1$[ebp]
	push	esi
	call	?advance_line@kd_multi_analysis@@AAEXPAUkd_multi_line@@HPAVkdu_thread_env@@@Z ; kd_multi_analysis::advance_line

; 1455 :       source_row_counters[comp_idx] = ++row_idx;

	mov	ecx, DWORD PTR [edi+80]
	mov	eax, DWORD PTR _comp_idx$[ebp]
	mov	edx, DWORD PTR _row_idx$1$[ebp]
	inc	edx
	mov	DWORD PTR [ecx+eax*4], edx
$LN3@exchange_l:

; 1456 :     }
; 1457 :   assert(line->row_idx == (row_idx-1));
; 1458 :   if (line->waiting_for_inversion)

	xor	eax, eax
	cmp	BYTE PTR [esi+28], al
	pop	edi
	cmovne	esi, eax
	mov	eax, esi
	pop	esi

; 1459 :     return NULL;
; 1460 :   else
; 1461 :     return &(line->line);
; 1462 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?exchange_line@kd_multi_analysis@@UAEPAVkdu_line_buf@@HPAV2@PAVkdu_thread_env@@@Z ENDP ; kd_multi_analysis::exchange_line
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?get_size@kd_multi_analysis@@UAE?AUkdu_coords@@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_comp_idx$ = 12						; size = 4
?get_size@kd_multi_analysis@@UAE?AUkdu_coords@@H@Z PROC	; kd_multi_analysis::get_size, COMDAT
; _this$ = ecx

; 1333 : {

	push	ebp
	mov	ebp, esp

; 1334 :   assert((comp_idx >= 0) && (comp_idx < output_collection->num_components));
; 1335 :   return output_collection->components[comp_idx]->size;

	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _comp_idx$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+4], ecx

; 1336 : }

	pop	ebp
	ret	8
?get_size@kd_multi_analysis@@UAE?AUkdu_coords@@H@Z ENDP	; kd_multi_analysis::get_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?create@kd_multi_analysis@@QAE_JVkdu_codestream@@Vkdu_tile@@_NPAVkdu_roi_image@@2HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z
_TEXT	SEGMENT
_tile_dims$1 = -28					; size = 16
$T2 = -12						; size = 4
$T3 = -8						; size = 4
$T4 = -4						; size = 4
_codestream$ = 8					; size = 4
_tile$ = 12						; size = 4
_force_precise$ = 16					; size = 1
_tc$5 = 16						; size = 4
_roi_image$ = 20					; size = 4
_n$1$ = 24						; size = 4
_want_fastest$ = 24					; size = 1
_roi_node$1$ = 28					; size = 4
_processing_stripe_height$ = 28				; size = 4
_env$ = 32						; size = 4
_queue$1$ = 36						; size = 4
_env_queue$ = 36					; size = 4
_double_buffering$ = 40					; size = 1
_res$6 = 40						; size = 4
?create@kd_multi_analysis@@QAE_JVkdu_codestream@@Vkdu_tile@@_NPAVkdu_roi_image@@2HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z PROC ; kd_multi_analysis::create, COMDAT
; _this$ = ecx

; 1279 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi

; 1280 :   construct(codestream,tile,force_precise,false,want_fastest,

	push	DWORD PTR _double_buffering$[ebp]
	mov	esi, ecx
	push	DWORD PTR _env_queue$[ebp]
	push	DWORD PTR _env$[ebp]
	lea	ecx, DWORD PTR [esi+4]
	push	DWORD PTR _processing_stripe_height$[ebp]
	push	DWORD PTR _want_fastest$[ebp]
	push	0
	push	DWORD PTR _force_precise$[ebp]
	push	DWORD PTR _tile$[ebp]
	push	DWORD PTR _codestream$[ebp]
	call	?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ; kd_multi_transform::construct

; 1281 :             processing_stripe_height,env,env_queue,double_buffering);
; 1282 :   prepare_network_for_inversion();

	mov	ecx, esi
	call	?prepare_network_for_inversion@kd_multi_analysis@@AAEXXZ ; kd_multi_analysis::prepare_network_for_inversion

; 1286 :   for (n=0; n < codestream_collection->num_components; n++)

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _n$1$[ebp], 0
	cmp	DWORD PTR [eax], 0
	jle	$LN3@create

; 1280 :   construct(codestream,tile,force_precise,false,want_fastest,

	xor	ebx, ebx
	npad	7
$LL4@create:

; 1287 :     {
; 1288 :       kd_multi_component *comp = codestream_components + n;

	mov	edi, DWORD PTR [esi+20]
	add	edi, ebx

; 1289 :       kdu_thread_queue *queue = (env==NULL)?NULL:comp->env_queue;

	cmp	DWORD PTR _env$[ebp], 0
	jne	SHORT $LN16@create
	mov	DWORD PTR _queue$1$[ebp], 0
	jmp	SHORT $LN17@create
$LN16@create:
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR _queue$1$[ebp], eax
$LN17@create:

; 1290 :       kdu_tile_comp tc = tile.access_component(comp->comp_idx);

	push	DWORD PTR [edi+4]
	lea	eax, DWORD PTR _tc$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?access_component@kdu_tile@@QAE?AVkdu_tile_comp@@H@Z ; kdu_tile::access_component

; 1291 :       kdu_resolution res = tc.access_resolution();

	lea	eax, DWORD PTR _res$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _tc$5[ebp]
	call	?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@XZ ; kdu_tile_comp::access_resolution

; 1292 :       kdu_dims tile_dims;  res.get_dims(tile_dims);

	lea	eax, DWORD PTR _tile_dims$1[ebp]
	xorps	xmm0, xmm0
	push	eax
	lea	ecx, DWORD PTR _res$6[ebp]
	movups	XMMWORD PTR _tile_dims$1[ebp], xmm0
	call	?get_dims@kdu_resolution@@QAEXAAUkdu_dims@@@Z ; kdu_resolution::get_dims

; 1293 :       kdu_roi_node *roi_node = NULL;
; 1294 :       if (roi_image != NULL)

	mov	ecx, DWORD PTR _roi_image$[ebp]
	mov	DWORD PTR _roi_node$1$[ebp], 0
	test	ecx, ecx
	je	SHORT $LN11@create

; 1295 :         roi_node = roi_image->acquire_node(comp->comp_idx,tile_dims);

	movups	xmm0, XMMWORD PTR _tile_dims$1[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	push	DWORD PTR [edi+4]
	movups	XMMWORD PTR [eax], xmm0
	call	DWORD PTR [edx+4]
	mov	DWORD PTR _roi_node$1$[ebp], eax
$LN11@create:

; 1296 :       if (res.which() == 0)

	lea	ecx, DWORD PTR _res$6[ebp]
	call	?which@kdu_resolution@@QAEHXZ		; kdu_resolution::which
	test	eax, eax
	jne	SHORT $LN12@create

; 1297 :         comp->push_ifc = kdu_encoder(res.access_subband(LL_BAND),&allocator,

	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	ecx, DWORD PTR _res$6[ebp]
	call	?access_subband@kdu_resolution@@QAE?AVkdu_subband@@H@Z ; kdu_resolution::access_subband
	push	DWORD PTR _queue$1$[ebp]
	cmp	BYTE PTR [edi+46], 0
	push	DWORD PTR _env$[ebp]
	push	DWORD PTR _roi_node$1$[ebp]
	push	ecx
	sete	cl
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	movzx	ecx, cl
	push	ecx
	lea	ecx, DWORD PTR [esi+36]
	push	ecx
	push	DWORD PTR [eax]
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_encoder::kdu_encoder

; 1298 :                                      !(comp->line.need_precise),1.0F,roi_node,
; 1299 :                                      env,queue);
; 1300 :       else

	jmp	SHORT $LN42@create
$LN12@create:

; 1301 :         comp->push_ifc = kdu_analysis(res,&allocator,

	push	DWORD PTR _queue$1$[ebp]
	cmp	BYTE PTR [edi+46], 0
	push	DWORD PTR _env$[ebp]
	sete	al
	push	DWORD PTR _roi_node$1$[ebp]
	movzx	eax, al
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	lea	ecx, DWORD PTR $T2[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+36]
	push	eax
	push	DWORD PTR _res$6[ebp]
	call	??0kdu_analysis@@QAE@Vkdu_resolution@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_analysis::kdu_analysis
$LN42@create:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 2048 :   { state = rhs.state; return *this; }

	mov	eax, DWORD PTR [eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1286 :   for (n=0; n < codestream_collection->num_components; n++)

	add	ebx, 112				; 00000070H
	mov	ecx, DWORD PTR _n$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 2048 :   { state = rhs.state; return *this; }

	mov	DWORD PTR [edi+108], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1286 :   for (n=0; n < codestream_collection->num_components; n++)

	inc	ecx
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	ecx, DWORD PTR [eax]
	jl	$LL4@create
$LN3@create:

; 1302 :                                       !(comp->line.need_precise),1.0F,roi_node,
; 1303 :                                       env,queue);
; 1304 :     }
; 1305 : 
; 1306 :   create_resources();

	lea	ecx, DWORD PTR [esi+4]
	call	?create_resources@kd_multi_transform@@IAEXXZ ; kd_multi_transform::create_resources

; 1307 : 
; 1308 :   source_row_counters = new int[output_collection->num_components];

	mov	eax, DWORD PTR [esi+28]
	xor	ecx, ecx
	mov	edx, 4
	mov	eax, DWORD PTR [eax]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+80], eax

; 1309 :   for (n=0; n < output_collection->num_components; n++)

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+28]
	add	esp, 4
	cmp	DWORD PTR [eax], ecx
	jle	SHORT $LN6@create
	npad	7
$LL7@create:

; 1310 :     source_row_counters[n] = 0;

	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [eax+ecx*4], 0
	inc	ecx
	mov	eax, DWORD PTR [esi+28]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LL7@create
$LN6@create:

; 1311 :   for (n=0; n < codestream_collection->num_components; n++)

	mov	eax, DWORD PTR [esi+24]
	xor	edi, edi
	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN9@create
	xor	ebx, ebx
	npad	3
$LL10@create:

; 1312 :     {
; 1313 :       kd_multi_component *comp = codestream_components + n;

	mov	ecx, DWORD PTR [esi+20]
	add	ecx, ebx

; 1314 :       comp->num_available_rows = comp->max_available_rows;

	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [ecx+80], edx

; 1315 :       assert(comp->num_available_rows <= comp->line.size.y);
; 1316 :       if (comp->num_available_rows > 0)

	test	edx, edx
	jle	SHORT $LN8@create

; 1317 :         {
; 1318 :           comp->line.line = comp->buffer[0];

	mov	eax, DWORD PTR [ecx+100]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx+12], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+20], eax

; 1319 :           comp->next_available_row = 1;
; 1320 :           comp->num_available_rows--;

	lea	eax, DWORD PTR [edx-1]
	mov	DWORD PTR [ecx+76], 1
	mov	DWORD PTR [ecx+80], eax
$LN8@create:

; 1311 :   for (n=0; n < codestream_collection->num_components; n++)

	mov	eax, DWORD PTR [esi+24]
	inc	edi
	add	ebx, 112				; 00000070H
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL10@create
$LN9@create:

; 1321 :         }
; 1322 :     }
; 1323 : 
; 1324 :   return allocator.get_size();

	mov	eax, DWORD PTR [esi+48]

; 1325 : }

	pop	edi
	pop	esi
	cdq
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?create@kd_multi_analysis@@QAE_JVkdu_codestream@@Vkdu_tile@@_NPAVkdu_roi_image@@2HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ENDP ; kd_multi_analysis::create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?terminate_queues@kd_multi_analysis@@UAEXPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_env$ = 8						; size = 4
?terminate_queues@kd_multi_analysis@@UAEXPAVkdu_thread_env@@@Z PROC ; kd_multi_analysis::terminate_queues, COMDAT
; _this$ = ecx

; 1260 : {

	push	ebp
	mov	ebp, esp
	mov	eax, ecx

; 1261 :   if (env != NULL)

	mov	ecx, DWORD PTR _env$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@terminate_

; 1262 :     {
; 1263 :       assert((env_queue != NULL) &&
; 1264 :              (codestream_components[0].env_queue != NULL));
; 1265 :       env->terminate(env_queue,true);

	push	0
	push	1
	push	DWORD PTR [eax+60]
	call	?terminate@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_NPAH@Z ; kdu_thread_entity::terminate
$LN2@terminate_:

; 1266 :     }
; 1267 : }

	pop	ebp
	ret	4
?terminate_queues@kd_multi_analysis@@UAEXPAVkdu_thread_env@@@Z ENDP ; kd_multi_analysis::terminate_queues
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ??1kd_multi_analysis@@UAE@XZ
_TEXT	SEGMENT
??1kd_multi_analysis@@UAE@XZ PROC			; kd_multi_analysis::~kd_multi_analysis, COMDAT
; _this$ = ecx

; 1249 : {

	push	esi
	mov	esi, ecx
	push	edi

; 1250 :   if (source_row_counters != NULL)

	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_analysis@@6Bkd_multi_analysis_base@@@
	mov	DWORD PTR [esi+4], OFFSET ??_7kd_multi_analysis@@6Bkd_multi_transform@@@
	test	eax, eax
	je	SHORT $LN2@kd_multi_a

; 1251 :     delete[] source_row_counters;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_multi_a:

; 1252 : }

	lea	ecx, DWORD PTR [esi+4]
	call	??1kd_multi_transform@@UAE@XZ		; kd_multi_transform::~kd_multi_transform
	pop	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 1260 :     virtual ~kd_multi_analysis_base() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_analysis_base@@6B@
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1252 : }

	ret	0
??1kd_multi_analysis@@UAE@XZ ENDP			; kd_multi_analysis::~kd_multi_analysis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??0kd_multi_analysis@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0kd_multi_analysis@@QAE@XZ PROC			; kd_multi_analysis::kd_multi_analysis, COMDAT
; _this$ = ecx

; 828  :     kd_multi_analysis() { source_row_counters=NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx

; 737  :       {

	mov	DWORD PTR [ecx+4], OFFSET ??_7kd_multi_transform@@6B@

; 828  :     kd_multi_analysis() { source_row_counters=NULL; }

	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 150  :       { bytes_reserved = bytes_used = buffer_size = 0;

	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+40], 0

; 151  :         pre_creation_phase=true; buffer = buf_handle = NULL; }

	mov	BYTE PTR [ecx+36], 1
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+52], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 738  :         use_ycc=false; xform_blocks=block_tail=NULL;

	mov	BYTE PTR [ecx+8], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+12], 0

; 739  :         codestream_collection=output_collection=NULL;

	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+24], 0

; 740  :         constant_output_lines=NULL; codestream_components = NULL;

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+20], 0

; 741  :         env_queue = NULL;  max_scratch_ints = max_scratch_floats = 0;

	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+72], 0
	mov	DWORD PTR [ecx+64], 0

; 742  :         scratch_ints=NULL;  scratch_floats=NULL;

	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+76], 0

; 828  :     kd_multi_analysis() { source_row_counters=NULL; }

	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_analysis@@6Bkd_multi_analysis_base@@@
	mov	DWORD PTR [ecx+4], OFFSET ??_7kd_multi_analysis@@6Bkd_multi_transform@@@
	mov	DWORD PTR [ecx+80], 0
	mov	esp, ebp
	pop	ebp
	ret	0
??0kd_multi_analysis@@QAE@XZ ENDP			; kd_multi_analysis::kd_multi_analysis
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_multi_synthesis@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_multi_synthesis@@UAEPAXI@Z PROC			; kd_multi_synthesis::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_multi_synthesis@@UAE@XZ		; kd_multi_synthesis::~kd_multi_synthesis
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	84					; 00000054H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_multi_synthesis@@UAEPAXI@Z ENDP			; kd_multi_synthesis::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?get_line@kd_multi_synthesis@@AAEPAVkdu_line_buf@@PAUkd_multi_line@@HPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
tv859 = -16						; size = 4
_final_stripe$1 = -12					; size = 1
_this$1$ = -8						; size = 4
_perform_ycc$1$ = -1					; size = 1
_line$ = 8						; size = 4
_tgt_row_idx$ = 12					; size = 4
_env$ = 16						; size = 4
?get_line@kd_multi_synthesis@@AAEPAVkdu_line_buf@@PAUkd_multi_line@@HPAVkdu_thread_env@@@Z PROC ; kd_multi_synthesis::get_line, COMDAT
; _this$ = ecx

; 1020 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx

; 1021 :   assert(line->bypass == NULL);
; 1022 :   if (line->is_constant)

	mov	ebx, DWORD PTR _line$[ebp]
	mov	edx, ecx
	mov	DWORD PTR _this$1$[ebp], edx
	cmp	BYTE PTR [ebx+35], 0
	je	SHORT $LN22@get_line

; 1023 :     return &(line->line);

	mov	eax, ebx
	pop	ebx

; 1185 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN22@get_line:
	push	edi

; 1024 :   if (line->row_idx == tgt_row_idx)

	mov	edi, DWORD PTR _tgt_row_idx$[ebp]
	cmp	DWORD PTR [ebx+20], edi
	jne	SHORT $LN23@get_line

; 1025 :     { // The line we want has already been generated
; 1026 :       assert(line->outstanding_consumers > 0);
; 1027 :       line->outstanding_consumers--;

	dec	DWORD PTR [ebx+28]

; 1028 :       if (line->block != NULL)

	mov	eax, DWORD PTR [ebx+52]
	test	eax, eax
	je	SHORT $LN24@get_line

; 1029 :         line->block->outstanding_consumers--;

	dec	DWORD PTR [eax+28]
$LN24@get_line:
	pop	edi

; 1030 :       return &(line->line);

	mov	eax, ebx
	pop	ebx

; 1185 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN23@get_line:

; 1031 :     }
; 1032 : 
; 1033 :   // If we get here, we need to generate the requested row
; 1034 :   assert(line->row_idx == (tgt_row_idx-1));
; 1035 :   if (line->outstanding_consumers > 0)

	cmp	DWORD PTR [ebx+28], 0
	jle	SHORT $LN25@get_line

; 1036 :     return NULL; // Have to wait until previous line is completely consumed

	pop	edi
	xor	eax, eax
	pop	ebx

; 1185 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN25@get_line:
	push	esi

; 1037 : 
; 1038 :   int n;
; 1039 :   kd_multi_block *block = line->block;

	mov	esi, DWORD PTR [ebx+52]

; 1040 :   if ((block != NULL) && block->is_null_transform)

	test	esi, esi
	je	$LN29@get_line
	cmp	BYTE PTR [esi+4], 0
	je	SHORT $LN26@get_line

; 1041 :     {
; 1042 :       n = (int)(line - block->components);
; 1043 :       assert((n >= 0) && (n < block->num_dependencies));
; 1044 :       kd_multi_line *dep = block->dependencies[n];  assert(dep != NULL);
; 1045 :       if (get_line(dep,tgt_row_idx,env) == NULL)

	push	DWORD PTR _env$[ebp]
	mov	ecx, ebx
	mov	eax, -2004318071			; 88888889H
	sub	ecx, DWORD PTR [esi+12]
	imul	ecx
	mov	eax, DWORD PTR [esi+20]
	add	edx, ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	push	edi
	mov	esi, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	esi
	call	?get_line@kd_multi_synthesis@@AAEPAVkdu_line_buf@@PAUkd_multi_line@@HPAVkdu_thread_env@@@Z ; kd_multi_synthesis::get_line
	test	eax, eax
	je	$LN66@get_line

; 1046 :         return NULL;
; 1047 :       line->row_idx = tgt_row_idx;
; 1048 :       line->outstanding_consumers = line->num_consumers;
; 1049 :       line->copy(dep,line->rev_offset,line->irrev_offset);

	movss	xmm0, DWORD PTR [ebx+44]
	mov	eax, DWORD PTR [ebx+24]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, ebx
	push	DWORD PTR [ebx+40]
	mov	DWORD PTR [ebx+20], edi
	push	esi
	mov	DWORD PTR [ebx+28], eax
	call	?copy@kd_multi_line@@QAEXPAU1@HM@Z	; kd_multi_line::copy
	jmp	$LN51@get_line
$LN26@get_line:

; 1050 :     }
; 1051 :   else if (block != NULL)
; 1052 :     { // The line is generated by a transform block; see if it is ready to
; 1053 :       // advance.
; 1054 :       if (block->outstanding_consumers > 0)

	cmp	DWORD PTR [esi+28], 0
	jg	$LN66@get_line

; 1055 :         return NULL;
; 1056 :       kd_multi_line *scan;
; 1057 :       while (block->num_available_dependencies < block->num_dependencies)

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, DWORD PTR [esi+16]
	jge	SHORT $LN96@get_line
	npad	7
$LL2@get_line:

; 1058 :         {
; 1059 :           scan = block->dependencies[block->num_available_dependencies];

	mov	ecx, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+20]
	mov	edi, DWORD PTR [eax+ecx*4]

; 1060 :           if ((scan == NULL) || scan->is_constant)

	test	edi, edi
	je	SHORT $LN33@get_line
	cmp	BYTE PTR [edi+35], 0
	jne	SHORT $LN33@get_line

; 1062 :           if (get_line(scan,tgt_row_idx,env) == NULL)

	push	DWORD PTR _env$[ebp]
	mov	ecx, edx
	push	DWORD PTR _tgt_row_idx$[ebp]
	push	edi
	call	?get_line@kd_multi_synthesis@@AAEPAVkdu_line_buf@@PAUkd_multi_line@@HPAVkdu_thread_env@@@Z ; kd_multi_synthesis::get_line
	test	eax, eax
	je	$LN66@get_line

; 1063 :             return NULL;
; 1064 :           scan->outstanding_consumers++; // Don't actually consume the row yet

	inc	DWORD PTR [edi+28]

; 1065 :           if (scan->block != NULL)

	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	je	SHORT $LN35@get_line

; 1066 :             scan->block->outstanding_consumers++;

	inc	DWORD PTR [eax+28]
$LN35@get_line:

; 1067 :           block->num_available_dependencies++;

	inc	DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+24]

; 1068 :         }

	mov	edx, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LN67@get_line
$LN33@get_line:

; 1061 :             { block->num_available_dependencies++; continue; }

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+24], eax
$LN67@get_line:

; 1055 :         return NULL;
; 1056 :       kd_multi_line *scan;
; 1057 :       while (block->num_available_dependencies < block->num_dependencies)

	cmp	eax, DWORD PTR [esi+16]
	jl	SHORT $LL2@get_line
$LN96@get_line:

; 1069 : 
; 1070 :       // See if we can write to all the outputs of the transform
; 1071 :       for (n=0; n < block->num_components; n++)

	mov	edx, DWORD PTR [esi+8]
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN5@get_line

; 1072 :         {
; 1073 :           scan = block->components + n;

	mov	eax, DWORD PTR [esi+12]
	add	eax, 28					; 0000001cH
	npad	5
$LL6@get_line:

; 1074 :           if (scan->outstanding_consumers > 0)

	cmp	DWORD PTR [eax], 0
	jg	$LN66@get_line

; 1069 : 
; 1070 :       // See if we can write to all the outputs of the transform
; 1071 :       for (n=0; n < block->num_components; n++)

	inc	ecx
	add	eax, 60					; 0000003cH
	cmp	ecx, edx
	jl	SHORT $LL6@get_line
$LN5@get_line:

; 1075 :             return false;
; 1076 :         }
; 1077 : 
; 1078 :       // If we get here, we can run the transform
; 1079 :       block->perform_transform();

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+16]

; 1080 :       for (n=0; n < block->num_dependencies; n++)

	xor	ecx, ecx
	cmp	DWORD PTR [esi+16], ecx
	jle	SHORT $LN8@get_line
	npad	1
$LL9@get_line:

; 1081 :         if ((scan = block->dependencies[n]) != NULL)

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN7@get_line

; 1082 :           {
; 1083 :             assert(scan->row_idx == tgt_row_idx);
; 1084 :             scan->outstanding_consumers--;

	dec	DWORD PTR [eax+28]

; 1085 :             if (scan->block != NULL)

	mov	eax, DWORD PTR [eax+52]
	test	eax, eax
	je	SHORT $LN7@get_line

; 1086 :               scan->block->outstanding_consumers--;

	dec	DWORD PTR [eax+28]
$LN7@get_line:

; 1080 :       for (n=0; n < block->num_dependencies; n++)

	inc	ecx
	cmp	ecx, DWORD PTR [esi+16]
	jl	SHORT $LL9@get_line
$LN8@get_line:

; 1087 :           }
; 1088 :       for (n=0; n < block->num_components; n++)

	xor	edx, edx
	cmp	DWORD PTR [esi+8], edx
	jle	SHORT $LN11@get_line
	mov	ebx, DWORD PTR _tgt_row_idx$[ebp]
	xor	edi, edi
	npad	7
$LL12@get_line:

; 1089 :         {
; 1090 :           scan = block->components + n;

	mov	ecx, DWORD PTR [esi+12]
	lea	edi, DWORD PTR [edi+60]
	inc	edx

; 1091 :           assert((scan->outstanding_consumers == 0) &&
; 1092 :                  (scan->row_idx == (tgt_row_idx-1)));
; 1093 :           scan->row_idx = tgt_row_idx;
; 1094 :           scan->outstanding_consumers = scan->num_consumers;

	mov	eax, DWORD PTR [ecx+edi-36]
	mov	DWORD PTR [ecx+edi-40], ebx
	mov	DWORD PTR [ecx+edi-32], eax

; 1095 :           block->outstanding_consumers += scan->outstanding_consumers;

	add	DWORD PTR [esi+28], eax
	cmp	edx, DWORD PTR [esi+8]
	jl	SHORT $LL12@get_line
	mov	ebx, DWORD PTR _line$[ebp]
$LN11@get_line:

; 1096 :         }
; 1097 :       block->num_available_dependencies = 0;

	mov	DWORD PTR [esi+24], 0

; 1098 :     }
; 1099 :   else

	jmp	$LN51@get_line
$LN29@get_line:

; 1100 :     {
; 1101 :       n = line->collection_idx;  assert(n >= 0);
; 1102 :       assert(codestream_collection->components[n] == line);
; 1103 :       bool perform_ycc = use_ycc && (n < 3);

	cmp	BYTE PTR [edx+8], 0
	mov	eax, DWORD PTR [ebx+56]
	je	SHORT $LN54@get_line
	cmp	eax, 3
	jge	SHORT $LN54@get_line

; 1104 :       if (perform_ycc)
; 1105 :         { // We will have to process all 3 lines & perform inverse RCT/ICT
; 1106 :           for (n=0; n < 3; n++)

	mov	eax, ecx
	mov	BYTE PTR _perform_ycc$1$[ebp], 1
	xor	edx, edx
	mov	eax, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [eax+4]
$LL15@get_line:

; 1107 :             {
; 1108 :               kd_multi_line *ycc_line = codestream_collection->components[n];
; 1109 :               assert(ycc_line->row_idx == (tgt_row_idx-1));
; 1110 :               if (ycc_line->outstanding_consumers > 0)

	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax+28], 0
	jg	SHORT $LN66@get_line

; 1104 :       if (perform_ycc)
; 1105 :         { // We will have to process all 3 lines & perform inverse RCT/ICT
; 1106 :           for (n=0; n < 3; n++)

	inc	edx
	add	ecx, 4
	cmp	edx, 3
	jl	SHORT $LL15@get_line

; 1112 :             }
; 1113 :           n = 0; // Start from first one

	mov	edx, DWORD PTR _this$1$[ebp]
	xor	eax, eax
	jmp	SHORT $LN94@get_line
$LN66@get_line:
	pop	esi
	pop	edi

; 1111 :                 return NULL; // Cannot run inverse RCT/ICT yet

	xor	eax, eax
	pop	ebx

; 1185 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN54@get_line:

; 1100 :     {
; 1101 :       n = line->collection_idx;  assert(n >= 0);
; 1102 :       assert(codestream_collection->components[n] == line);
; 1103 :       bool perform_ycc = use_ycc && (n < 3);

	mov	BYTE PTR _perform_ycc$1$[ebp], 0
$LN94@get_line:
	imul	edi, eax, 112
$LL18@get_line:

; 1114 :         }
; 1115 :       do {
; 1116 :           kd_multi_component *comp = codestream_components+n;

	mov	esi, DWORD PTR [edx+20]
	add	esi, edi

; 1117 :           if (comp->num_available_rows == 0)

	cmp	DWORD PTR [esi+80], 0
	jne	$LN43@get_line

; 1118 :             {
; 1119 :               if (comp->double_buffering)

	cmp	BYTE PTR [esi+72], 0
	je	SHORT $LN42@get_line

; 1120 :                 { // Need to wait for stripe rows in progress
; 1121 :                   assert((env != NULL) &&
; 1122 :                          (comp->num_rows_in_progress > 0));
; 1123 :                   env->process_jobs(comp->env_queue);

	mov	ecx, DWORD PTR _env$[ebp]
	push	1
	push	0
	push	DWORD PTR [esi+8]
	call	?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z ; kdu_thread_entity::process_jobs

; 1124 :                   comp->next_available_row = comp->first_row_in_progress;

	mov	ecx, DWORD PTR [esi+84]

; 1125 :                   comp->num_available_rows = comp->num_rows_in_progress;
; 1126 :                   if (comp->next_available_row > 0)

	test	ecx, ecx
	mov	edx, DWORD PTR [esi+88]
	mov	eax, edx
	mov	DWORD PTR tv859[ebp], 0
	cmovg	eax, DWORD PTR tv859[ebp]
	mov	DWORD PTR [esi+84], eax

; 1127 :                     comp->first_row_in_progress = 0;
; 1128 :                   else
; 1129 :                     comp->first_row_in_progress = comp->num_available_rows;
; 1130 :                   comp->num_rows_in_progress =

	mov	eax, DWORD PTR [esi+24]
	sub	eax, edx
	mov	DWORD PTR [esi+76], ecx
	sub	eax, DWORD PTR _tgt_row_idx$[ebp]

; 1131 :                     comp->line.size.y - tgt_row_idx - comp->num_available_rows;
; 1132 :                   bool final_stripe = true;
; 1133 :                   if (comp->num_rows_in_progress > comp->max_available_rows)

	mov	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [esi+80], edx
	mov	DWORD PTR [esi+88], eax
	mov	BYTE PTR _final_stripe$1[ebp], 1
	cmp	eax, ecx
	jle	SHORT $LN46@get_line

; 1134 :                     {
; 1135 :                       comp->num_rows_in_progress = comp->max_available_rows;

	mov	DWORD PTR [esi+88], ecx

; 1136 :                       final_stripe = false;

	mov	BYTE PTR _final_stripe$1[ebp], 0
$LN46@get_line:

; 1137 :                     }
; 1138 :                   if (comp->num_rows_in_progress > 0)

	cmp	DWORD PTR [esi+88], 0
	jle	SHORT $LN43@get_line

; 1139 :                     env->add_jobs(comp->env_queue,1,final_stripe);

	mov	ecx, DWORD PTR _env$[ebp]
	push	0
	push	DWORD PTR _final_stripe$1[ebp]
	push	1
	push	DWORD PTR [esi+8]
	call	?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z ; kdu_thread_entity::add_jobs

; 1140 :                 }
; 1141 :               else

	jmp	SHORT $LN43@get_line
$LN42@get_line:

; 1142 :                 { // Need to generate more available stripe rows
; 1143 :                   assert(((comp->env_queue == NULL) && (env == NULL)) ||
; 1144 :                          ((comp->env_queue != NULL) && (env != NULL)));
; 1145 :                   comp->next_available_row = comp->first_row_in_progress = 0;
; 1146 :                   comp->num_rows_in_progress = comp->line.size.y - tgt_row_idx;

	mov	ecx, DWORD PTR [esi+24]
	sub	ecx, DWORD PTR _tgt_row_idx$[ebp]

; 1147 :                   if (comp->num_rows_in_progress > comp->max_available_rows)

	cmp	ecx, DWORD PTR [esi+92]

; 1148 :                     comp->num_rows_in_progress = comp->max_available_rows;
; 1149 :                   comp->do_job(env,0);

	mov	eax, DWORD PTR [esi]
	cmovg	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [esi+88], ecx
	mov	ecx, DWORD PTR _env$[ebp]
	push	0
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR [esi+84], 0
	mov	DWORD PTR [esi+76], 0
	call	DWORD PTR [eax+4]

; 1150 :                   comp->num_available_rows = comp->num_rows_in_progress;

	mov	eax, DWORD PTR [esi+88]
	mov	DWORD PTR [esi+80], eax

; 1151 :                   comp->num_rows_in_progress = 0;

	mov	DWORD PTR [esi+88], 0
$LN43@get_line:

; 1152 :                 }
; 1153 :             }
; 1154 :           comp->line.line = comp->buffer[comp->next_available_row++];

	mov	edx, DWORD PTR [esi+76]
	mov	eax, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR [edx+edx*2]
	movq	xmm0, QWORD PTR [eax+ecx*4]
	movq	QWORD PTR [esi+12], xmm0
	mov	eax, DWORD PTR [eax+ecx*4+8]

; 1155 :           comp->num_available_rows--;

	dec	DWORD PTR [esi+80]

; 1156 :         } while (perform_ycc && ((++n) < 3));

	cmp	BYTE PTR _perform_ycc$1$[ebp], 0
	mov	DWORD PTR [esi+20], eax
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi+76], eax
	je	SHORT $LN50@get_line
	mov	edx, DWORD PTR _this$1$[ebp]
	add	edi, 112				; 00000070H
	cmp	edi, 336				; 00000150H
	jl	$LL18@get_line

; 1157 :       if (perform_ycc)
; 1158 :         {
; 1159 :           kd_multi_line **ycc_lines = codestream_collection->components;

	mov	eax, edx

; 1160 :           kdu_convert_ycc_to_rgb(ycc_lines[0]->line,

	push	-1
	mov	eax, DWORD PTR [eax+24]
	mov	ebx, DWORD PTR [eax+4]
	push	DWORD PTR [ebx+8]
	push	DWORD PTR [ebx+4]
	push	DWORD PTR [ebx]
	call	?kdu_convert_ycc_to_rgb@@YAXAAVkdu_line_buf@@00H@Z ; kdu_convert_ycc_to_rgb
	add	esp, 16					; 00000010H

; 1161 :                                  ycc_lines[1]->line,
; 1162 :                                  ycc_lines[2]->line);
; 1163 :           for (n=0; n < 3; n++)

	xor	edi, edi
$LL21@get_line:

; 1164 :             {
; 1165 :               kd_multi_line *scan = ycc_lines[n];

	mov	esi, DWORD PTR [ebx+edi*4]

; 1166 :               scan->apply_offset(scan->rev_offset,scan->irrev_offset);

	push	ecx
	mov	ecx, esi
	movss	xmm0, DWORD PTR [esi+44]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR [esi+40]
	call	?apply_offset@kd_multi_line@@QAEXHM@Z	; kd_multi_line::apply_offset

; 1167 :               scan->row_idx++;

	inc	DWORD PTR [esi+20]
	inc	edi

; 1168 :               scan->outstanding_consumers = scan->num_consumers;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+28], eax
	cmp	edi, 3
	jl	SHORT $LL21@get_line

; 1169 :             }
; 1170 :         }
; 1171 :       else

	mov	ebx, DWORD PTR _line$[ebp]
	jmp	SHORT $LN51@get_line
$LN50@get_line:

; 1172 :         {
; 1173 :           line->apply_offset(line->rev_offset,line->irrev_offset);

	movss	xmm0, DWORD PTR [ebx+44]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, ebx
	push	DWORD PTR [ebx+40]
	call	?apply_offset@kd_multi_line@@QAEXHM@Z	; kd_multi_line::apply_offset

; 1174 :           line->row_idx++;
; 1175 :           line->outstanding_consumers = line->num_consumers;

	mov	eax, DWORD PTR [ebx+24]
	inc	DWORD PTR [ebx+20]
	mov	DWORD PTR [ebx+28], eax
$LN51@get_line:

; 1176 :         }
; 1177 :     }
; 1178 : 
; 1179 :   // If we get here, we should have been successful
; 1180 :   assert((line->row_idx == tgt_row_idx) && (line->outstanding_consumers > 0));
; 1181 :   line->outstanding_consumers--;

	dec	DWORD PTR [ebx+28]

; 1182 :   if (line->block != NULL)

	mov	eax, DWORD PTR [ebx+52]
	test	eax, eax
	je	SHORT $LN52@get_line

; 1183 :     line->block->outstanding_consumers--;

	dec	DWORD PTR [eax+28]
$LN52@get_line:
	pop	esi
	pop	edi

; 1184 :   return &(line->line);

	mov	eax, ebx
	pop	ebx

; 1185 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get_line@kd_multi_synthesis@@AAEPAVkdu_line_buf@@PAUkd_multi_line@@HPAVkdu_thread_env@@@Z ENDP ; kd_multi_synthesis::get_line
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?is_line_absolute@kd_multi_synthesis@@UAE_NH@Z
_TEXT	SEGMENT
_comp_idx$ = 8						; size = 4
?is_line_absolute@kd_multi_synthesis@@UAE_NH@Z PROC	; kd_multi_synthesis::is_line_absolute, COMDAT
; _this$ = ecx

; 1207 : {

	push	ebp
	mov	ebp, esp

; 1208 :   if ((output_collection == NULL) ||
; 1209 :       (comp_idx < 0) || (comp_idx >= output_collection->num_components))

	mov	eax, DWORD PTR [ecx+28]
	test	eax, eax
	je	SHORT $LN3@is_line_ab
	mov	ecx, DWORD PTR _comp_idx$[ebp]
	test	ecx, ecx
	js	SHORT $LN3@is_line_ab
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@is_line_ab

; 1211 :   kd_multi_line *line = output_collection->components[comp_idx];
; 1212 :   return line->reversible;

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	al, BYTE PTR [eax+32]

; 1213 : }

	pop	ebp
	ret	4
$LN3@is_line_ab:

; 1210 :     return false;

	xor	al, al

; 1213 : }

	pop	ebp
	ret	4
?is_line_absolute@kd_multi_synthesis@@UAE_NH@Z ENDP	; kd_multi_synthesis::is_line_absolute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?is_line_precise@kd_multi_synthesis@@UAE_NH@Z
_TEXT	SEGMENT
_comp_idx$ = 8						; size = 4
?is_line_precise@kd_multi_synthesis@@UAE_NH@Z PROC	; kd_multi_synthesis::is_line_precise, COMDAT
; _this$ = ecx

; 1193 : {

	push	ebp
	mov	ebp, esp

; 1194 :   if ((output_collection == NULL) ||
; 1195 :       (comp_idx < 0) || (comp_idx >= output_collection->num_components))

	mov	eax, DWORD PTR [ecx+28]
	test	eax, eax
	je	SHORT $LN3@is_line_pr
	mov	ecx, DWORD PTR _comp_idx$[ebp]
	test	ecx, ecx
	js	SHORT $LN3@is_line_pr
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN3@is_line_pr

; 1197 :   kd_multi_line *line = output_collection->components[comp_idx];
; 1198 :   return line->need_precise;

	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	al, BYTE PTR [eax+34]

; 1199 : }

	pop	ebp
	ret	4
$LN3@is_line_pr:

; 1196 :     return false;

	xor	al, al

; 1199 : }

	pop	ebp
	ret	4
?is_line_precise@kd_multi_synthesis@@UAE_NH@Z ENDP	; kd_multi_synthesis::is_line_precise
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?get_line@kd_multi_synthesis@@UAEPAVkdu_line_buf@@HPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_comp_idx$ = 8						; size = 4
_env$ = 12						; size = 4
?get_line@kd_multi_synthesis@@UAEPAVkdu_line_buf@@HPAVkdu_thread_env@@@Z PROC ; kd_multi_synthesis::get_line, COMDAT
; _this$ = ecx

; 1001 : {

	push	ebp
	mov	ebp, esp

; 1002 :   assert((comp_idx >= 0) && (comp_idx < output_collection->num_components));
; 1003 :   kd_multi_line *line =
; 1004 :     output_collection->components[comp_idx];

	mov	eax, DWORD PTR _comp_idx$[ebp]
	push	esi
	mov	esi, ecx
	push	edi

; 1005 :   kdu_line_buf *result =
; 1006 :     get_line(line,output_row_counters[comp_idx],env);

	push	DWORD PTR _env$[ebp]
	lea	edi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [esi+80]
	push	DWORD PTR [eax+edi]
	push	edx
	call	?get_line@kd_multi_synthesis@@AAEPAVkdu_line_buf@@PAUkd_multi_line@@HPAVkdu_thread_env@@@Z ; kd_multi_synthesis::get_line

; 1007 :   if (result != NULL)

	test	eax, eax
	je	SHORT $LN2@get_line

; 1008 :     output_row_counters[comp_idx]++;

	mov	ecx, DWORD PTR [esi+80]
	inc	DWORD PTR [ecx+edi]
$LN2@get_line:
	pop	edi
	pop	esi

; 1009 : 
; 1010 :   return result;
; 1011 : }

	pop	ebp
	ret	8
?get_line@kd_multi_synthesis@@UAEPAVkdu_line_buf@@HPAVkdu_thread_env@@@Z ENDP ; kd_multi_synthesis::get_line
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?get_size@kd_multi_synthesis@@UAE?AUkdu_coords@@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_comp_idx$ = 12						; size = 4
?get_size@kd_multi_synthesis@@UAE?AUkdu_coords@@H@Z PROC ; kd_multi_synthesis::get_size, COMDAT
; _this$ = ecx

; 990  : {

	push	ebp
	mov	ebp, esp

; 991  :   assert((comp_idx >= 0) && (comp_idx < output_collection->num_components));
; 992  :   return output_collection->components[comp_idx]->size;

	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _comp_idx$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+4], ecx

; 993  : }

	pop	ebp
	ret	8
?get_size@kd_multi_synthesis@@UAE?AUkdu_coords@@H@Z ENDP ; kd_multi_synthesis::get_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?create@kd_multi_synthesis@@QAE_JVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -4						; size = 4
_codestream$ = 8					; size = 4
_tile$ = 12						; size = 4
_force_precise$ = 16					; size = 1
$T3 = 16						; size = 4
_skip_ycc$ = 20						; size = 1
_tc$4 = 20						; size = 4
tv405 = 24						; size = 4
_want_fastest$ = 24					; size = 1
_result$2$ = 28						; size = 4
_n$1$ = 28						; size = 4
_processing_stripe_height$ = 28				; size = 4
_env$ = 32						; size = 4
_result$1$ = 36						; size = 4
_res$5 = 36						; size = 4
_env_queue$ = 36					; size = 4
_queue$1$ = 40						; size = 4
_double_buffering$ = 40					; size = 1
tv404 = 40						; size = 4
?create@kd_multi_synthesis@@QAE_JVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z PROC ; kd_multi_synthesis::create, COMDAT
; _this$ = ecx

; 937  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 938  :   construct(codestream,tile,force_precise,skip_ycc,want_fastest,

	mov	ebx, DWORD PTR _env$[ebp]
	push	esi
	push	edi
	push	DWORD PTR _double_buffering$[ebp]
	mov	edi, ecx
	push	DWORD PTR _env_queue$[ebp]
	push	ebx
	push	DWORD PTR _processing_stripe_height$[ebp]
	lea	ecx, DWORD PTR [edi+4]
	push	DWORD PTR _want_fastest$[ebp]
	push	DWORD PTR _skip_ycc$[ebp]
	push	DWORD PTR _force_precise$[ebp]
	push	DWORD PTR _tile$[ebp]
	push	DWORD PTR _codestream$[ebp]
	call	?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ; kd_multi_transform::construct

; 943  :   for (n=0; n < codestream_collection->num_components; n++)

	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR _n$1$[ebp], 0
	cmp	DWORD PTR [eax], 0
	jle	$LN3@create

; 938  :   construct(codestream,tile,force_precise,skip_ycc,want_fastest,

	xor	ecx, ecx
	mov	DWORD PTR tv405[ebp], ecx
$LL4@create:

; 944  :     {
; 945  :       kd_multi_component *comp = codestream_components + n;

	mov	esi, DWORD PTR [edi+20]
	add	esi, ecx

; 946  :       kdu_thread_queue *queue = (env==NULL)?NULL:comp->env_queue;

	test	ebx, ebx
	jne	SHORT $LN16@create
	mov	DWORD PTR _queue$1$[ebp], ebx
	jmp	SHORT $LN17@create
$LN16@create:
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _queue$1$[ebp], eax
$LN17@create:

; 947  :       kdu_tile_comp tc = tile.access_component(comp->comp_idx);

	push	DWORD PTR [esi+4]
	lea	eax, DWORD PTR _tc$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?access_component@kdu_tile@@QAE?AVkdu_tile_comp@@H@Z ; kdu_tile::access_component

; 948  :       kdu_resolution res = tc.access_resolution();

	lea	eax, DWORD PTR _res$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _tc$4[ebp]
	call	?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@XZ ; kdu_tile_comp::access_resolution

; 949  :       if (res.which() == 0)

	lea	ecx, DWORD PTR _res$5[ebp]
	call	?which@kdu_resolution@@QAEHXZ		; kdu_resolution::which
	test	eax, eax
	jne	SHORT $LN11@create

; 950  :         comp->pull_ifc = kdu_decoder(res.access_subband(LL_BAND),&allocator,

	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR _res$5[ebp]
	call	?access_subband@kdu_resolution@@QAE?AVkdu_subband@@H@Z ; kdu_resolution::access_subband
	push	DWORD PTR _queue$1$[ebp]
	cmp	BYTE PTR [esi+46], 0
	push	ebx
	push	0
	push	ecx
	sete	cl
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	movzx	ecx, cl
	push	ecx
	lea	ecx, DWORD PTR [edi+36]
	push	ecx
	push	DWORD PTR [eax]
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_decoder::kdu_decoder

; 951  :                                      !(comp->line.need_precise),1.0F,
; 952  :                                      0,env,queue);
; 953  :       else

	jmp	SHORT $LN39@create
$LN11@create:

; 954  :         comp->pull_ifc = kdu_synthesis(res,&allocator,

	push	DWORD PTR _queue$1$[ebp]
	cmp	BYTE PTR [esi+46], 0
	push	ebx
	push	ecx
	sete	al
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	movzx	eax, al
	lea	ecx, DWORD PTR $T1[ebp]
	push	eax
	lea	eax, DWORD PTR [edi+36]
	push	eax
	push	DWORD PTR _res$5[ebp]
	call	??0kdu_synthesis@@QAE@Vkdu_resolution@@PAVkdu_sample_allocator@@_NMPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_synthesis::kdu_synthesis
$LN39@create:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 2053 :   { state = rhs.state; return *this; }

	mov	eax, DWORD PTR [eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 943  :   for (n=0; n < codestream_collection->num_components; n++)

	mov	edx, DWORD PTR _n$1$[ebp]
	mov	ecx, DWORD PTR tv405[ebp]
	inc	edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 2053 :   { state = rhs.state; return *this; }

	mov	DWORD PTR [esi+104], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 943  :   for (n=0; n < codestream_collection->num_components; n++)

	add	ecx, 112				; 00000070H
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR _n$1$[ebp], edx
	mov	DWORD PTR tv405[ebp], ecx
	cmp	edx, DWORD PTR [eax]
	jl	$LL4@create
$LN3@create:

; 955  :                                        !(comp->line.need_precise),1.0F,
; 956  :                                        env,queue);
; 957  :     }
; 958  : 
; 959  :   create_resources();

	lea	ecx, DWORD PTR [edi+4]
	call	?create_resources@kd_multi_transform@@IAEXXZ ; kd_multi_transform::create_resources

; 960  : 
; 961  :   output_row_counters = new int[output_collection->num_components];

	mov	eax, DWORD PTR [edi+28]
	xor	ecx, ecx
	mov	edx, 4
	mov	eax, DWORD PTR [eax]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+80], eax

; 962  :   for (n=0; n < output_collection->num_components; n++)

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi+28]
	add	esp, 4
	cmp	DWORD PTR [eax], ecx
	jle	SHORT $LN6@create
$LL7@create:

; 963  :     output_row_counters[n] = 0;

	mov	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [eax+ecx*4], 0
	inc	ecx
	mov	eax, DWORD PTR [edi+28]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LL7@create
$LN6@create:

; 964  : 
; 965  :   kdu_long result = allocator.get_size();
; 966  :   for (n=0; n < codestream_collection->num_components; n++)

	mov	ecx, DWORD PTR [edi+24]
	xor	ebx, ebx
	mov	eax, DWORD PTR [edi+48]
	cdq
	mov	DWORD PTR _result$1$[ebp], eax
	mov	DWORD PTR _result$2$[ebp], edx
	cmp	DWORD PTR [ecx], ebx
	jle	SHORT $LN9@create
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 248  :         return buffer_size;

	xor	ecx, ecx
	mov	DWORD PTR tv404[ebp], ecx
	npad	6
$LL10@create:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 969  :       kd_multi_component *comp = codestream_components + n;

	mov	esi, DWORD PTR [edi+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 739  :         state->start(env);

	push	DWORD PTR _env$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 969  :       kd_multi_component *comp = codestream_components + n;

	add	esi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 739  :         state->start(env);

	mov	ecx, DWORD PTR [esi+104]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 971  :       if (comp->double_buffering)

	cmp	BYTE PTR [esi+72], 0
	je	SHORT $LN8@create

; 972  :         {
; 973  :           comp->first_row_in_progress = 0;
; 974  :           comp->num_rows_in_progress = comp->max_available_rows;

	mov	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [esi+84], 0
	mov	DWORD PTR [esi+88], ecx

; 976  :           assert(remaining_lines >= 0);
; 977  :           if (comp->num_rows_in_progress > 0)

	test	ecx, ecx
	jle	SHORT $LN8@create

; 975  :           int remaining_lines = comp->line.size.y - comp->num_rows_in_progress;

	mov	eax, DWORD PTR [esi+24]
	sub	eax, ecx

; 978  :             env->add_jobs(comp->env_queue,1,(remaining_lines==0));

	mov	ecx, DWORD PTR _env$[ebp]
	push	0
	sete	al
	movzx	eax, al
	push	eax
	push	1
	push	DWORD PTR [esi+8]
	call	?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z ; kdu_thread_entity::add_jobs
$LN8@create:

; 964  : 
; 965  :   kdu_long result = allocator.get_size();
; 966  :   for (n=0; n < codestream_collection->num_components; n++)

	mov	eax, DWORD PTR [edi+24]
	inc	ebx
	mov	ecx, DWORD PTR tv404[ebp]
	add	ecx, 112				; 00000070H
	mov	DWORD PTR tv404[ebp], ecx
	cmp	ebx, DWORD PTR [eax]
	jl	SHORT $LL10@create

; 979  :         }
; 980  :     }
; 981  :   return result;

	mov	eax, DWORD PTR _result$1$[ebp]
	mov	edx, DWORD PTR _result$2$[ebp]
$LN9@create:
	pop	edi
	pop	esi
	pop	ebx

; 982  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?create@kd_multi_synthesis@@QAE_JVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ENDP ; kd_multi_synthesis::create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?terminate_queues@kd_multi_synthesis@@UAEXPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_env$ = 8						; size = 4
?terminate_queues@kd_multi_synthesis@@UAEXPAVkdu_thread_env@@@Z PROC ; kd_multi_synthesis::terminate_queues, COMDAT
; _this$ = ecx

; 919  : {

	push	ebp
	mov	ebp, esp
	mov	eax, ecx

; 920  :   if (env != NULL)

	mov	ecx, DWORD PTR _env$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@terminate_

; 921  :     {
; 922  :       assert((env_queue != NULL) &&
; 923  :              (codestream_components[0].env_queue != NULL));
; 924  :       env->terminate(env_queue,true);

	push	0
	push	1
	push	DWORD PTR [eax+60]
	call	?terminate@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_NPAH@Z ; kdu_thread_entity::terminate
$LN2@terminate_:

; 925  :     }
; 926  : }

	pop	ebp
	ret	4
?terminate_queues@kd_multi_synthesis@@UAEXPAVkdu_thread_env@@@Z ENDP ; kd_multi_synthesis::terminate_queues
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ??1kd_multi_synthesis@@UAE@XZ
_TEXT	SEGMENT
??1kd_multi_synthesis@@UAE@XZ PROC			; kd_multi_synthesis::~kd_multi_synthesis, COMDAT
; _this$ = ecx

; 908  : {

	push	esi
	mov	esi, ecx
	push	edi

; 909  :   if (output_row_counters != NULL)

	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_synthesis@@6Bkd_multi_synthesis_base@@@
	mov	DWORD PTR [esi+4], OFFSET ??_7kd_multi_synthesis@@6Bkd_multi_transform@@@
	test	eax, eax
	je	SHORT $LN2@kd_multi_s

; 910  :     delete[] output_row_counters;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_multi_s:

; 911  : }

	lea	ecx, DWORD PTR [esi+4]
	call	??1kd_multi_transform@@UAE@XZ		; kd_multi_transform::~kd_multi_transform
	pop	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 1659 :     virtual ~kd_multi_synthesis_base() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_synthesis_base@@6B@
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 911  : }

	ret	0
??1kd_multi_synthesis@@UAE@XZ ENDP			; kd_multi_synthesis::~kd_multi_synthesis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??0kd_multi_synthesis@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0kd_multi_synthesis@@QAE@XZ PROC			; kd_multi_synthesis::kd_multi_synthesis, COMDAT
; _this$ = ecx

; 801  :     kd_multi_synthesis() { output_row_counters=NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx

; 737  :       {

	mov	DWORD PTR [ecx+4], OFFSET ??_7kd_multi_transform@@6B@

; 801  :     kd_multi_synthesis() { output_row_counters=NULL; }

	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 150  :       { bytes_reserved = bytes_used = buffer_size = 0;

	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+40], 0

; 151  :         pre_creation_phase=true; buffer = buf_handle = NULL; }

	mov	BYTE PTR [ecx+36], 1
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+52], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 738  :         use_ycc=false; xform_blocks=block_tail=NULL;

	mov	BYTE PTR [ecx+8], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+12], 0

; 739  :         codestream_collection=output_collection=NULL;

	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+24], 0

; 740  :         constant_output_lines=NULL; codestream_components = NULL;

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+20], 0

; 741  :         env_queue = NULL;  max_scratch_ints = max_scratch_floats = 0;

	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+72], 0
	mov	DWORD PTR [ecx+64], 0

; 742  :         scratch_ints=NULL;  scratch_floats=NULL;

	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+76], 0

; 801  :     kd_multi_synthesis() { output_row_counters=NULL; }

	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_synthesis@@6Bkd_multi_synthesis_base@@@
	mov	DWORD PTR [ecx+4], OFFSET ??_7kd_multi_synthesis@@6Bkd_multi_transform@@@
	mov	DWORD PTR [ecx+80], 0
	mov	esp, ebp
	pop	ebp
	ret	0
??0kd_multi_synthesis@@QAE@XZ ENDP			; kd_multi_synthesis::kd_multi_synthesis
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_multi_transform@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_multi_transform@@UAEPAXI@Z PROC			; kd_multi_transform::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_multi_transform@@UAE@XZ		; kd_multi_transform::~kd_multi_transform
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	76					; 0000004cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_multi_transform@@UAEPAXI@Z ENDP			; kd_multi_transform::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z
_TEXT	SEGMENT
_e$2 = -92						; size = 20
_e$3 = -72						; size = 20
tv1331 = -52						; size = 4
tv1322 = -48						; size = 4
tv1279 = -44						; size = 4
_block$1$ = -44						; size = 4
tv1282 = -40						; size = 4
_have_unknown_input_bit_depth$4 = -40			; size = 1
_have_unknown_output_bit_depth$5 = -36			; size = 1
tv1390 = -32						; size = 4
tv1389 = -32						; size = 4
tv1366 = -32						; size = 4
_n$3$ = -32						; size = 4
_this$1$ = -32						; size = 4
tv1353 = -28						; size = 4
tv1350 = -28						; size = 4
tv1317 = -28						; size = 4
tv1285 = -28						; size = 4
_n$1$ = -28						; size = 4
tv1342 = -24						; size = 4
tv1355 = -20						; size = 4
tv1344 = -20						; size = 4
_n$2$ = -20						; size = 4
_found_bit_depth_inconsistency$1$ = -15			; size = 1
_have_xform_size$1$ = -14				; size = 1
_found_size_inconsistency$1$ = -13			; size = 1
__$EHRec$ = -12						; size = 12
_force_precise$ = 8					; size = 1
?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z PROC	; kd_multi_transform::propagate_knowledge, COMDAT
; _this$ = ecx

; 565  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, ecx
	mov	DWORD PTR _this$1$[ebp], eax

; 566  :   int n;
; 567  :   kd_multi_block *block;
; 568  :   bool any_change = false;
; 569  :   bool found_size_inconsistency=false;

	xor	cl, cl

; 570  :   bool found_bit_depth_inconsistency=false;
; 571  : 
; 572  :   if (use_ycc)

	mov	DWORD PTR tv1342[ebp], 1
	xor	bl, bl
	mov	BYTE PTR _found_size_inconsistency$1$[ebp], cl
	mov	DWORD PTR tv1344[ebp], ebx
	mov	BYTE PTR _found_bit_depth_inconsistency$1$[ebp], cl
	cmp	BYTE PTR [eax+4], cl
	je	$LN149@propagate_

; 573  :     { // Ensure consistency amongst the first 3 components in the codestream
; 574  :       // collection.
; 575  :       assert(codestream_collection->num_components >= 3);
; 576  :       kd_multi_line **lines = codestream_collection->components;

	mov	eax, DWORD PTR [eax+20]

; 577  :       bool reversible=false, irreversible=false, precise=force_precise;

	xor	dl, dl

; 578  :       for (n=0; n < 3; n++)
; 579  :         {
; 580  :           if (lines[n]->reversible)
; 581  :             reversible = true;
; 582  :           if (lines[n]->need_irreversible)

	movzx	edx, dl
	mov	edi, DWORD PTR [eax+4]
	xor	al, al
	movzx	ecx, al
	mov	esi, DWORD PTR [edi]
	cmp	BYTE PTR [esi+32], al
	mov	eax, 1
	cmovne	ecx, eax
	cmp	BYTE PTR [esi+33], bl

; 583  :             irreversible = true;
; 584  :           if (lines[n]->need_precise)

	movzx	ebx, BYTE PTR _force_precise$[ebp]
	cmovne	edx, eax
	movzx	ecx, cl
	cmp	BYTE PTR [esi+34], 0
	movzx	edx, dl
	cmovne	ebx, eax
	mov	eax, DWORD PTR [edi+4]
	movzx	ebx, bl
	cmp	BYTE PTR [eax+32], 0
	cmovne	ecx, DWORD PTR tv1342[ebp]
	cmp	BYTE PTR [eax+33], 0
	movzx	ecx, cl
	cmovne	edx, DWORD PTR tv1342[ebp]
	cmp	BYTE PTR [eax+34], 0
	mov	eax, 1
	movzx	edx, dl
	cmovne	ebx, eax
	mov	eax, DWORD PTR [edi+8]
	movzx	ebx, bl
	cmp	BYTE PTR [eax+32], 0
	cmovne	ecx, DWORD PTR tv1342[ebp]
	cmp	BYTE PTR [eax+33], 0
	mov	DWORD PTR tv1279[ebp], ecx
	cmovne	edx, DWORD PTR tv1342[ebp]
	cmp	BYTE PTR [eax+34], 0
	mov	eax, 1

; 585  :             precise = true;
; 586  :         }
; 587  :       for (n=0; n < 3; n++)
; 588  :         {
; 589  :           lines[n]->reversible = reversible;

	mov	BYTE PTR [esi+32], cl
	cmovne	ebx, eax
	mov	DWORD PTR tv1282[ebp], edx

; 590  :           lines[n]->need_irreversible = irreversible;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR tv1285[ebp], ebx
	mov	BYTE PTR [eax+33], dl

; 591  :           lines[n]->need_precise = precise;

	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR [eax+34], bl

; 592  :           if (lines[n]->size != lines[0]->size)

	mov	ecx, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, eax
	jne	SHORT $LN72@propagate_
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, eax
	je	SHORT $LN167@propagate_
$LN72@propagate_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 593  :             found_size_inconsistency = true;

	mov	cl, 1
	mov	BYTE PTR _found_size_inconsistency$1$[ebp], cl
	jmp	SHORT $LN5@propagate_
$LN167@propagate_:
	mov	cl, BYTE PTR _found_size_inconsistency$1$[ebp]
$LN5@propagate_:

; 585  :             precise = true;
; 586  :         }
; 587  :       for (n=0; n < 3; n++)
; 588  :         {
; 589  :           lines[n]->reversible = reversible;

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR tv1279[ebp]
	mov	BYTE PTR [eax+32], bl

; 590  :           lines[n]->need_irreversible = irreversible;

	mov	eax, DWORD PTR [edi+4]
	mov	BYTE PTR [eax+33], dl

; 591  :           lines[n]->need_precise = precise;

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR tv1285[ebp]
	mov	BYTE PTR [eax+34], dl

; 592  :           if (lines[n]->size != lines[0]->size)

	mov	esi, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, DWORD PTR [edx+16]
	jne	SHORT $LN143@propagate_
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [edx+12]
	je	SHORT $LN145@propagate_
$LN143@propagate_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 593  :             found_size_inconsistency = true;

	mov	cl, 1
	mov	BYTE PTR _found_size_inconsistency$1$[ebp], cl
$LN145@propagate_:

; 590  :           lines[n]->need_irreversible = irreversible;

	mov	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR tv1282[ebp]
	mov	BYTE PTR [eax+32], bl
	mov	eax, DWORD PTR [edi+8]
	mov	BYTE PTR [eax+33], dl

; 591  :           lines[n]->need_precise = precise;

	mov	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR tv1285[ebp]
	mov	BYTE PTR [eax+34], dl

; 592  :           if (lines[n]->size != lines[0]->size)

	mov	esi, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, DWORD PTR [edx+16]
	jne	SHORT $LN147@propagate_
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [edx+12]
	je	SHORT $LN166@propagate_
$LN147@propagate_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 593  :             found_size_inconsistency = true;

	mov	cl, 1
	mov	BYTE PTR _found_size_inconsistency$1$[ebp], cl
$LN166@propagate_:
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ebx, DWORD PTR tv1344[ebp]
$LN149@propagate_:

; 594  :         }
; 595  :     }
; 596  : 
; 597  :   for (block=xform_blocks;

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR _block$1$[ebp], esi

; 598  :        (block != NULL) && !found_size_inconsistency;

	test	esi, esi
	je	$LN9@propagate_
$LL10@propagate_:
	test	cl, cl
	jne	$LN156@propagate_

; 600  :     {
; 601  :       if (block->is_null_transform)
; 602  :         { // These pass components through individually; they have no size
; 603  :           // of their own.
; 604  :           assert(block->num_dependencies <= block->num_components);
; 605  :               // The `kd_multi_null_block::initialize' function should have
; 606  :               // made this condition hold.
; 607  :           for (n=0; n < block->num_components; n++)

	xor	edx, edx
	cmp	BYTE PTR [esi+4], dl
	je	$LN31@propagate_
	mov	DWORD PTR _n$1$[ebp], edx
	cmp	DWORD PTR [esi+8], edx
	jle	$LN8@propagate_
	xor	ecx, ecx
	mov	DWORD PTR tv1355[ebp], ecx
$LL13@propagate_:

; 608  :             {
; 609  :               kd_multi_line *line = block->components + n;

	mov	eax, DWORD PTR [esi+12]
	add	eax, ecx

; 610  :               if (force_precise)

	cmp	BYTE PTR _force_precise$[ebp], 0
	je	SHORT $LN33@propagate_

; 611  :                 line->need_precise = true;

	mov	BYTE PTR [eax+34], 1
$LN33@propagate_:

; 612  :               if (!line->is_constant)

	cmp	BYTE PTR [eax+35], 0
	jne	$LN11@propagate_

; 613  :                 {
; 614  :                   kd_multi_line *dep = block->dependencies[n];

	mov	ecx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [ecx+edx*4]

; 615  :                   if (dep->need_precise != line->need_precise)

	mov	cl, BYTE PTR [edx+34]
	cmp	cl, BYTE PTR [eax+34]
	je	SHORT $LN35@propagate_

; 616  :                     {
; 617  :                       any_change = true;

	mov	bl, 1

; 618  :                       line->need_precise = dep->need_precise = true;

	mov	BYTE PTR [edx+34], bl
	mov	BYTE PTR [eax+34], bl
$LN35@propagate_:

; 619  :                     }
; 620  :                   if (dep->need_irreversible != line->need_irreversible)

	mov	cl, BYTE PTR [edx+33]
	cmp	cl, BYTE PTR [eax+33]
	je	SHORT $LN36@propagate_

; 621  :                     {
; 622  :                       any_change = true;

	mov	bl, 1

; 623  :                       line->need_irreversible = dep->need_irreversible = true;

	mov	BYTE PTR [edx+33], bl
	mov	BYTE PTR [eax+33], bl
$LN36@propagate_:

; 624  :                     }
; 625  :                   if (dep->reversible != line->reversible)

	mov	cl, BYTE PTR [edx+32]
	cmp	cl, BYTE PTR [eax+32]
	je	SHORT $LN37@propagate_

; 626  :                     {
; 627  :                       any_change = true;

	mov	bl, 1

; 628  :                       line->reversible = dep->reversible = true;

	mov	BYTE PTR [edx+32], bl
	mov	BYTE PTR [eax+32], bl
$LN37@propagate_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }

	mov	ecx, DWORD PTR [edx+16]
	cmp	ecx, DWORD PTR [eax+16]
	jne	SHORT $LN76@propagate_
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+12]
	je	SHORT $LN42@propagate_
$LN76@propagate_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 633  :                       if ((dep->size.x == 0) && (dep->size.y == 0))

	cmp	DWORD PTR [edx+16], 0
	mov	bl, 1
	jne	SHORT $LN39@propagate_
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN39@propagate_

; 634  :                         dep->size = line->size;

	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN42@propagate_
$LN39@propagate_:

; 635  :                       else if ((line->size.x == 0) && (line->size.y == 0))

	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN41@propagate_
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN41@propagate_

; 636  :                         line->size = dep->size;

	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx

; 637  :                       else

	jmp	SHORT $LN42@propagate_
$LN41@propagate_:

; 638  :                         found_size_inconsistency = true;

	mov	BYTE PTR _found_size_inconsistency$1$[ebp], 1
$LN42@propagate_:

; 639  :                     }
; 640  :                   if (dep->bit_depth != line->bit_depth)

	mov	edi, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax+36]
	cmp	edi, ecx
	je	SHORT $LN11@propagate_

; 641  :                     {
; 642  :                       any_change = true;

	mov	bl, 1

; 643  :                       if (dep->bit_depth == 0)

	test	edi, edi
	jne	SHORT $LN44@propagate_

; 644  :                         dep->bit_depth = line->bit_depth;

	mov	DWORD PTR [edx+36], ecx
	jmp	SHORT $LN11@propagate_
$LN44@propagate_:

; 645  :                       else if (line->bit_depth == 0)

	test	ecx, ecx
	jne	SHORT $LN46@propagate_

; 646  :                         line->bit_depth = dep->bit_depth;

	mov	DWORD PTR [eax+36], edi

; 647  :                       else

	jmp	SHORT $LN11@propagate_
$LN46@propagate_:

; 648  :                         found_bit_depth_inconsistency = true;

	mov	BYTE PTR _found_bit_depth_inconsistency$1$[ebp], 1
$LN11@propagate_:

; 600  :     {
; 601  :       if (block->is_null_transform)
; 602  :         { // These pass components through individually; they have no size
; 603  :           // of their own.
; 604  :           assert(block->num_dependencies <= block->num_components);
; 605  :               // The `kd_multi_null_block::initialize' function should have
; 606  :               // made this condition hold.
; 607  :           for (n=0; n < block->num_components; n++)

	mov	eax, DWORD PTR _n$1$[ebp]
	add	DWORD PTR tv1355[ebp], 60		; 0000003cH
	inc	eax
	mov	edx, eax
	mov	ecx, DWORD PTR tv1355[ebp]
	mov	DWORD PTR _n$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+8]
	jl	$LL13@propagate_

; 649  :                     }
; 650  :                 }
; 651  :             }
; 652  :         }
; 653  :       else

	jmp	$LN169@propagate_
$LN31@propagate_:

; 654  :         { // Regular block transform; hi/lo precision and size of all
; 655  :           // components manipulated by the transform must be consistent.
; 656  :           bool xform_needs_precise = force_precise;

	mov	cl, BYTE PTR _force_precise$[ebp]

; 659  :           bool have_unknown_input_bit_depth=false;

	xor	al, al
	mov	DWORD PTR tv1322[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	xor	edi, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 659  :           bool have_unknown_input_bit_depth=false;

	mov	BYTE PTR _have_unknown_input_bit_depth$4[ebp], al

; 660  :           bool have_unknown_output_bit_depth=false;

	mov	DWORD PTR tv1331[ebp], eax
	mov	BYTE PTR _have_unknown_output_bit_depth$5[ebp], al

; 661  :           kd_multi_line *line;
; 662  :           for (n=0; n < block->num_dependencies; n++)

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR tv1317[ebp], ecx
	mov	BYTE PTR _have_xform_size$1$[ebp], 0
	test	eax, eax
	jle	SHORT $LN15@propagate_

; 663  :             {
; 664  :               if ((line = block->dependencies[n]) == NULL)

	mov	ebx, DWORD PTR tv1322[ebp]
	mov	esi, DWORD PTR [esi+20]
	mov	DWORD PTR tv1390[ebp], eax
$LL16@propagate_:
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN14@propagate_

; 665  :                 continue;
; 666  :               if (line->need_precise)

	cmp	BYTE PTR [eax+34], 0
	movzx	ecx, cl
	cmovne	ecx, DWORD PTR tv1342[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }

	cmp	DWORD PTR [eax+16], edi
	jne	SHORT $LN82@propagate_
	cmp	DWORD PTR [eax+12], edx
	je	SHORT $LN50@propagate_
$LN82@propagate_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 668  :               if ((line->size != xform_size) && !have_xform_size)

	cmp	BYTE PTR _have_xform_size$1$[ebp], 0
	jne	SHORT $LN50@propagate_

; 669  :                 { xform_size = line->size;  have_xform_size = true; }

	mov	edx, DWORD PTR [eax+12]
	mov	edi, DWORD PTR [eax+16]
	mov	BYTE PTR _have_xform_size$1$[ebp], 1
$LN50@propagate_:

; 670  :               if (line->bit_depth == 0)

	cmp	DWORD PTR [eax+36], 0
	mov	eax, 1
	movzx	ebx, bl
	cmove	ebx, eax
	mov	BYTE PTR _have_unknown_input_bit_depth$4[ebp], bl
$LN14@propagate_:

; 661  :           kd_multi_line *line;
; 662  :           for (n=0; n < block->num_dependencies; n++)

	add	esi, 4
	sub	DWORD PTR tv1390[ebp], 1
	jne	SHORT $LL16@propagate_
	mov	esi, DWORD PTR _block$1$[ebp]
	mov	ebx, DWORD PTR tv1344[ebp]
	mov	DWORD PTR tv1317[ebp], ecx
$LN15@propagate_:

; 671  :                 have_unknown_input_bit_depth = true;
; 672  :             }
; 673  :           for (n=0; n < block->num_components; n++)

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR tv1389[ebp], eax
	test	eax, eax
	jle	SHORT $LN18@propagate_

; 674  :             {
; 675  :               line = block->components + n;

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR tv1317[ebp]
	add	ecx, 12					; 0000000cH
	mov	ebx, DWORD PTR tv1331[ebp]
	npad	4
$LL19@propagate_:

; 676  :               if (line->need_precise)

	cmp	BYTE PTR [ecx+22], 0
	movzx	eax, al
	cmovne	eax, DWORD PTR tv1342[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }

	cmp	DWORD PTR [ecx+4], edi
	jne	SHORT $LN86@propagate_
	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN53@propagate_
$LN86@propagate_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 678  :               if ((line->size != xform_size) && !have_xform_size)

	cmp	BYTE PTR _have_xform_size$1$[ebp], 0
	jne	SHORT $LN53@propagate_

; 679  :                 { xform_size = line->size;  have_xform_size = true; }

	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	BYTE PTR _have_xform_size$1$[ebp], 1
$LN53@propagate_:

; 680  :               if (line->bit_depth == 0)

	cmp	DWORD PTR [ecx+24], 0
	movzx	ebx, bl
	cmove	ebx, DWORD PTR tv1342[ebp]
	add	ecx, 60					; 0000003cH
	sub	DWORD PTR tv1389[ebp], 1
	mov	BYTE PTR _have_unknown_output_bit_depth$5[ebp], bl
	jne	SHORT $LL19@propagate_
	mov	ebx, DWORD PTR tv1344[ebp]
	mov	ecx, eax
	mov	DWORD PTR tv1317[ebp], eax
$LN18@propagate_:

; 681  :                 have_unknown_output_bit_depth = true;
; 682  :             }
; 683  :           for (n=0; n < block->num_dependencies; n++)

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR _n$2$[ebp], 0
	test	eax, eax
	jle	SHORT $LN21@propagate_
$LL22@propagate_:

; 684  :             {
; 685  :               if ((line = block->dependencies[n]) == NULL)

	mov	ecx, DWORD PTR _n$2$[ebp]
	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR tv1317[ebp]
	test	eax, eax
	je	SHORT $LN20@propagate_

; 686  :                 continue;
; 687  :               if (line->need_precise != xform_needs_precise)

	cmp	BYTE PTR [eax+34], cl
	je	SHORT $LN56@propagate_

; 688  :                 { any_change = true; line->need_precise = true; }

	mov	bl, 1
	mov	BYTE PTR [eax+34], bl
$LN56@propagate_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }

	cmp	DWORD PTR [eax+16], edi
	jne	SHORT $LN90@propagate_
	cmp	DWORD PTR [eax+12], edx
	je	SHORT $LN20@propagate_
$LN90@propagate_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 693  :                   if ((line->size.x == 0) && (line->size.y == 0))

	cmp	DWORD PTR [eax+16], 0
	mov	bl, 1
	jne	SHORT $LN58@propagate_
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN58@propagate_

; 694  :                     line->size = xform_size;

	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], edi

; 695  :                   else

	jmp	SHORT $LN20@propagate_
$LN58@propagate_:

; 696  :                     found_size_inconsistency = true;

	mov	BYTE PTR _found_size_inconsistency$1$[ebp], 1
$LN20@propagate_:

; 681  :                 have_unknown_output_bit_depth = true;
; 682  :             }
; 683  :           for (n=0; n < block->num_dependencies; n++)

	mov	eax, DWORD PTR _n$2$[ebp]
	inc	eax
	mov	DWORD PTR _n$2$[ebp], eax
	cmp	eax, DWORD PTR [esi+16]
	jl	SHORT $LL22@propagate_
$LN21@propagate_:

; 697  :                 }
; 698  :             }
; 699  :           for (n=0; n < block->num_components; n++)

	cmp	DWORD PTR [esi+8], 0
	mov	DWORD PTR _n$3$[ebp], 0
	jle	SHORT $LN24@propagate_
	mov	DWORD PTR tv1350[ebp], 0
	npad	2
$LL25@propagate_:

; 700  :             {
; 701  :               line = block->components + n;

	mov	eax, DWORD PTR [esi+12]
	add	eax, DWORD PTR tv1350[ebp]

; 702  :               if (line->need_precise != xform_needs_precise)

	cmp	BYTE PTR [eax+34], cl
	je	SHORT $LN60@propagate_

; 703  :                 { any_change = true; line->need_precise = true; }

	mov	bl, 1
	mov	BYTE PTR [eax+34], bl
$LN60@propagate_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }

	cmp	DWORD PTR [eax+16], edi
	jne	SHORT $LN94@propagate_
	cmp	DWORD PTR [eax+12], edx
	je	SHORT $LN23@propagate_
$LN94@propagate_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 708  :                   if ((line->size.x == 0) && (line->size.y == 0))

	cmp	DWORD PTR [eax+16], 0
	mov	bl, 1
	jne	SHORT $LN62@propagate_
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN62@propagate_

; 709  :                     line->size = xform_size;

	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], edi

; 710  :                   else

	jmp	SHORT $LN23@propagate_
$LN62@propagate_:

; 711  :                     found_size_inconsistency = true;

	mov	BYTE PTR _found_size_inconsistency$1$[ebp], 1
$LN23@propagate_:

; 697  :                 }
; 698  :             }
; 699  :           for (n=0; n < block->num_components; n++)

	mov	eax, DWORD PTR _n$3$[ebp]
	add	DWORD PTR tv1350[ebp], 60		; 0000003cH
	inc	eax
	mov	DWORD PTR _n$3$[ebp], eax
	cmp	eax, DWORD PTR [esi+8]
	jl	SHORT $LL25@propagate_
$LN24@propagate_:

; 712  :                 }
; 713  :             }
; 714  :           if (block->propagate_bit_depths(have_unknown_input_bit_depth,

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	DWORD PTR _have_unknown_output_bit_depth$5[ebp]
	push	DWORD PTR _have_unknown_input_bit_depth$4[ebp]
	mov	eax, DWORD PTR [eax+12]
	call	eax
	test	al, al
	movzx	ebx, bl
	mov	edx, 1
	cmovne	ebx, edx
$LN169@propagate_:
	mov	cl, BYTE PTR _found_size_inconsistency$1$[ebp]
	mov	DWORD PTR tv1344[ebp], ebx
$LN8@propagate_:

; 599  :        block=block->next)

	mov	esi, DWORD PTR [esi+32]
	mov	DWORD PTR _block$1$[ebp], esi
	test	esi, esi
	jne	$LL10@propagate_
$LN9@propagate_:

; 715  :                                           have_unknown_output_bit_depth))
; 716  :             any_change = true;
; 717  :         }
; 718  :     }
; 719  : 
; 720  :   if (found_size_inconsistency)

	test	cl, cl
	je	SHORT $LN65@propagate_
$LN156@propagate_:

; 721  :     { KDU_ERROR(e,0x25080500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0CCJ@OBHDBNBL@Cannot?5implement?5multi?9component@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 721  :     { KDU_ERROR(e,0x25080500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 731  :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN65@propagate_:

; 732  : 
; 733  :   if (found_bit_depth_inconsistency)

	cmp	BYTE PTR _found_bit_depth_inconsistency$1$[ebp], 0
	je	SHORT $LN165@propagate_

; 734  :     { KDU_ERROR(e,0x22080500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	edx, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BDP@OMPOBFOO@Part?92?5codestream?5declares?5a?5cod@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 734  :     { KDU_ERROR(e,0x22080500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 741  :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN165@propagate_:

; 742  : 
; 743  :   return any_change;

	mov	al, bl

; 744  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z ENDP	; kd_multi_transform::propagate_knowledge
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?create_resources@kd_multi_transform@@IAEXXZ
_TEXT	SEGMENT
_e$2 = -60						; size = 20
tv1161 = -40						; size = 4
tv1149 = -40						; size = 4
_n$4$ = -40						; size = 4
tv1274 = -36						; size = 4
tv1234 = -36						; size = 4
tv1233 = -36						; size = 4
_comp$1$ = -36						; size = 4
tv1230 = -32						; size = 4
_k$1$ = -32						; size = 4
_block$2$ = -32						; size = 4
_n$6$ = -32						; size = 4
_n$1$ = -32						; size = 4
tv1231 = -28						; size = 4
tv1228 = -28						; size = 4
_n$5$ = -28						; size = 4
tv1229 = -24						; size = 4
tv1227 = -24						; size = 4
_this$1$ = -20						; size = 4
_this$1$ = -16						; size = 4
_line$1$ = -16						; size = 4
_line$1$ = -16						; size = 4
tv1137 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?create_resources@kd_multi_transform@@IAEXXZ PROC	; kd_multi_transform::create_resources, COMDAT
; _this$ = ecx

; 752  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?create_resources@kd_multi_transform@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 757  :   for (n=0; n < codestream_collection->num_components; n++)

	mov	eax, DWORD PTR [edi+20]
	xor	ebx, ebx
	mov	cl, 1
	mov	DWORD PTR _n$1$[ebp], ebx
	mov	DWORD PTR tv1137[ebp], ecx
	cmp	DWORD PTR [eax], ebx
	jle	$LN3@create_res

; 753  :   int n;
; 754  :   kd_multi_block *block;
; 755  : 
; 756  :   bool reversibility_consistent = true;

	xor	edx, edx
	mov	DWORD PTR tv1231[ebp], edx
$LL4@create_res:

; 758  :     {
; 759  :       kd_multi_component *comp = codestream_components + n;

	mov	esi, DWORD PTR [edi+16]

; 760  :       assert(codestream_collection->components[n] == &(comp->line));
; 761  :       if (comp->line.reversible != !comp->line.need_irreversible)

	xor	ecx, ecx
	add	esi, edx
	mov	edx, DWORD PTR tv1137[ebp]
	movzx	edx, dl
	mov	DWORD PTR tv1137[ebp], edx
	cmp	BYTE PTR [esi+45], cl
	movzx	eax, BYTE PTR [esi+44]
	sete	cl
	xor	edx, edx
	cmp	eax, ecx
	mov	ecx, DWORD PTR tv1137[ebp]
	cmovne	ecx, edx
	mov	DWORD PTR tv1137[ebp], ecx

; 762  :         reversibility_consistent = false;
; 763  :       for (int k=0; k < comp->num_buffer_rows; k++)

	cmp	DWORD PTR [esi+96], edx
	jle	SHORT $LN2@create_res
	lea	ecx, DWORD PTR [edi+32]
	xor	ebx, ebx
	mov	DWORD PTR tv1274[ebp], ecx
	mov	edi, edx
	npad	3
$LL7@create_res:

; 764  :         comp->buffer[k].pre_create(&allocator,comp->line.size.x,

	cmp	BYTE PTR [esi+46], 0
	push	2
	push	2
	sete	al
	movzx	eax, al
	push	eax
	movzx	eax, BYTE PTR [esi+44]
	push	eax
	push	DWORD PTR [esi+28]
	push	ecx
	mov	ecx, DWORD PTR [esi+100]
	add	ecx, ebx
	call	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create
	mov	ecx, DWORD PTR tv1274[ebp]
	inc	edi
	add	ebx, 12					; 0000000cH
	cmp	edi, DWORD PTR [esi+96]
	jl	SHORT $LL7@create_res
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR tv1137[ebp]
	mov	ebx, DWORD PTR _n$1$[ebp]
$LN2@create_res:

; 757  :   for (n=0; n < codestream_collection->num_components; n++)

	mov	eax, DWORD PTR [edi+20]
	inc	ebx
	mov	edx, DWORD PTR tv1231[ebp]
	add	edx, 112				; 00000070H
	mov	DWORD PTR _n$1$[ebp], ebx
	mov	DWORD PTR tv1231[ebp], edx
	cmp	ebx, DWORD PTR [eax]
	jl	$LL4@create_res
$LN3@create_res:

; 765  :                                    comp->line.reversible,
; 766  :                                    !comp->line.need_precise);
; 767  :     }
; 768  :   for (block=xform_blocks; block != NULL; block=block->next)

	mov	ebx, DWORD PTR [edi+8]
	test	ebx, ebx
	je	$LN9@create_res
	npad	6
$LL10@create_res:

; 769  :     for (n=0; n < block->num_components; n++)

	xor	edi, edi
	cmp	DWORD PTR [ebx+8], edi
	jle	SHORT $LN8@create_res
	xor	eax, eax
	mov	DWORD PTR tv1230[ebp], eax
	npad	4
$LL13@create_res:

; 770  :       {
; 771  :         kd_multi_line *line = block->components + n;

	mov	esi, DWORD PTR [ebx+12]

; 772  :         if (line->reversible != !line->need_irreversible)

	xor	edx, edx
	add	esi, eax
	movzx	ecx, cl
	mov	DWORD PTR tv1149[ebp], 0
	cmp	BYTE PTR [esi+33], dl
	mov	al, BYTE PTR [esi+32]
	mov	DWORD PTR tv1233[ebp], eax
	sete	dl
	movzx	eax, al
	cmp	eax, edx
	cmovne	ecx, DWORD PTR tv1149[ebp]

; 773  :           reversibility_consistent = false;
; 774  :         if (line->bypass == NULL)

	cmp	DWORD PTR [esi+48], 0
	mov	DWORD PTR tv1137[ebp], ecx
	jne	SHORT $LN11@create_res

; 775  :           line->line.pre_create(&allocator,line->size.x,

	cmp	BYTE PTR [esi+34], 0
	mov	ecx, esi
	push	2
	push	2
	sete	al
	movzx	eax, al
	push	eax
	push	DWORD PTR tv1233[ebp]
	mov	eax, DWORD PTR _this$1$[ebp]
	push	DWORD PTR [esi+16]
	add	eax, 32					; 00000020H
	push	eax
	call	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create
	mov	ecx, DWORD PTR tv1137[ebp]
$LN11@create_res:

; 769  :     for (n=0; n < block->num_components; n++)

	mov	eax, DWORD PTR tv1230[ebp]
	inc	edi
	add	eax, 60					; 0000003cH
	mov	DWORD PTR tv1230[ebp], eax
	cmp	edi, DWORD PTR [ebx+8]
	jl	SHORT $LL13@create_res
$LN8@create_res:

; 765  :                                    comp->line.reversible,
; 766  :                                    !comp->line.need_precise);
; 767  :     }
; 768  :   for (block=xform_blocks; block != NULL; block=block->next)

	mov	ebx, DWORD PTR [ebx+32]
	test	ebx, ebx
	jne	SHORT $LL10@create_res
	mov	edi, DWORD PTR _this$1$[ebp]
$LN9@create_res:

; 776  :                                 line->reversible,!line->need_precise);
; 777  :       }
; 778  :   for (n=0; n < output_collection->num_components; n++)

	mov	eax, DWORD PTR [edi+24]
	xor	ebx, ebx
	cmp	DWORD PTR [eax], ebx
	jle	SHORT $LN15@create_res
$LL16@create_res:

; 779  :     {
; 780  :       kd_multi_line *line = output_collection->components[n];

	mov	eax, DWORD PTR [eax+4]

; 781  :       if (line->reversible != !line->need_irreversible)

	xor	edx, edx
	movzx	ecx, cl
	mov	DWORD PTR tv1161[ebp], 0
	mov	esi, DWORD PTR [eax+ebx*4]
	cmp	BYTE PTR [esi+33], dl
	mov	al, BYTE PTR [esi+32]
	mov	DWORD PTR tv1234[ebp], eax
	sete	dl
	movzx	eax, al
	cmp	eax, edx
	cmovne	ecx, DWORD PTR tv1161[ebp]

; 782  :         reversibility_consistent = false;
; 783  :       if ((line->bypass == NULL) && (line->block == NULL) &&

	cmp	DWORD PTR [esi+48], 0
	mov	DWORD PTR tv1137[ebp], ecx
	jne	SHORT $LN14@create_res
	cmp	DWORD PTR [esi+52], 0
	jne	SHORT $LN14@create_res
	cmp	DWORD PTR [esi+56], 0
	jge	SHORT $LN14@create_res

; 784  :           (line->collection_idx < 0))
; 785  :         line->line.pre_create(&allocator,line->size.x,

	cmp	BYTE PTR [esi+34], 0
	mov	ecx, esi
	push	2
	push	2
	sete	al
	movzx	eax, al
	push	eax
	push	DWORD PTR tv1234[ebp]
	lea	eax, DWORD PTR [edi+32]
	push	DWORD PTR [esi+16]
	push	eax
	call	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create
	mov	ecx, DWORD PTR tv1137[ebp]
$LN14@create_res:

; 776  :                                 line->reversible,!line->need_precise);
; 777  :       }
; 778  :   for (n=0; n < output_collection->num_components; n++)

	mov	eax, DWORD PTR [edi+24]
	inc	ebx
	cmp	ebx, DWORD PTR [eax]
	jl	SHORT $LL16@create_res
$LN15@create_res:

; 786  :                               line->reversible,!line->need_precise);
; 787  :     }
; 788  : 
; 789  :   if (!reversibility_consistent)

	test	cl, cl
	jne	SHORT $LN37@create_res

; 790  :     { KDU_ERROR(e,0x23080501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0DGI@MLEJMJIK@Cannot?5implement?5multi?9component@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 790  :     { KDU_ERROR(e,0x23080501); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 806  :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN37@create_res:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 192  :         if (bytes_reserved > buffer_size)

	mov	eax, DWORD PTR [edi+36]
	mov	BYTE PTR [edi+32], 0
	cmp	eax, DWORD PTR [edi+44]
	jle	SHORT $LN48@create_res

; 193  :           { // Otherwise, use the previously allocated buffer.
; 194  :             buffer_size = bytes_reserved;

	mov	DWORD PTR [edi+44], eax

; 195  :             if (buf_handle != NULL) delete[] buf_handle;

	mov	eax, DWORD PTR [edi+52]
	test	eax, eax
	je	SHORT $LN47@create_res
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN47@create_res:

; 196  :             buffer = buf_handle = new kdu_byte[buffer_size+24];

	mov	eax, DWORD PTR [edi+44]
	add	eax, 24					; 00000018H
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [edi+52], eax
	mov	DWORD PTR [edi+48], eax

; 197  :             if (_addr_to_kdu_int32(buffer) & 8)

	test	al, 8
	je	SHORT $LN48@create_res

; 198  :               buffer += 8; // Align on 16-byte boundary

	add	eax, 8
	mov	DWORD PTR [edi+48], eax
$LN48@create_res:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 810  :   for (n=0; n < codestream_collection->num_components; n++)

	mov	eax, DWORD PTR [edi+20]
	xor	edx, edx
	mov	DWORD PTR _n$4$[ebp], edx
	cmp	DWORD PTR [eax], edx
	jle	$LN18@create_res
	xor	eax, eax
	mov	DWORD PTR tv1228[ebp], eax
	npad	10
$LL19@create_res:

; 811  :     {
; 812  :       kd_multi_component *comp = codestream_components + n;

	mov	ecx, DWORD PTR [edi+16]
	add	ecx, eax

; 813  :       for (int k=0; k < comp->num_buffer_rows; k++)

	mov	DWORD PTR _k$1$[ebp], 0
	mov	DWORD PTR _comp$1$[ebp], ecx
	cmp	DWORD PTR [ecx+96], 0
	jle	$LN17@create_res

; 811  :     {
; 812  :       kd_multi_component *comp = codestream_components + n;

	xor	eax, eax
	mov	DWORD PTR tv1229[ebp], eax
	npad	2
$LL22@create_res:

; 814  :         comp->buffer[k].create();

	mov	ecx, DWORD PTR [ecx+100]
	add	ecx, eax
	mov	DWORD PTR _this$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 370  :         if (!pre_created)

	cmp	BYTE PTR [ecx+7], 0
	je	SHORT $LN20@create_res

; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)
; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);

	mov	ebx, DWORD PTR [ecx+8]
	movzx	edi, BYTE PTR [ecx+4]
	test	BYTE PTR [ecx+6], 2
	mov	BYTE PTR [ecx+7], 0

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.
; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+16]

; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)
; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);

	movzx	ecx, BYTE PTR [ecx+5]
	je	SHORT $LN52@create_res

; 199  :           }
; 200  :         assert((bytes_reserved == 0) || (buffer != NULL));
; 201  :       }
; 202  :     kdu_sample16 *alloc16(int before, int after)
; 203  :       {
; 204  :       /* [SYNOPSIS]
; 205  :            Allocate an array with space for `before' entries prior to the
; 206  :            returned pointer and `after' entries after the returned pointer
; 207  :            (including the entry to which the pointer refers).  The returned
; 208  :            pointer is guaranteed to be aligned on a 16-byte boundary.
; 209  :            The pointer may be interpreted as the location of an array which
; 210  :            can accept signed indices, n, in the range -`before' <= n < `after'.
; 211  :            [//]
; 212  :            Before calling this function, you must have pre-allocated sufficient
; 213  :            space through calls to `pre_alloc' and you must have called the
; 214  :            `finalize' member function.
; 215  :       */
; 216  :         assert(!pre_creation_phase);
; 217  :         before = (before+7)&~7; // Round up to nearest multiple of 16 bytes.

	add	edi, 7
	and	edi, -8					; fffffff8H

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.
; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	lea	esi, DWORD PTR [eax+edi*2]
	mov	eax, DWORD PTR _this$1$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR [eax]
	add	eax, 7
	add	eax, ecx
	and	eax, -8					; fffffff8H
	add	eax, edi
	lea	eax, DWORD PTR [edx+eax*2]

; 375  :         else

	jmp	SHORT $LN122@create_res
$LN52@create_res:

; 221  :         assert(bytes_used <= bytes_reserved);
; 222  :         return result;
; 223  :       }
; 224  :     kdu_sample32 *alloc32(int before, int after)
; 225  :       {
; 226  :       /* [SYNOPSIS]
; 227  :            Same as `alloc16', except that it allocates storage for arrays of
; 228  :            32-bit quantities.  Again, the returned pointer is guaranteed to
; 229  :            be aligned on a 16-byte boundary.
; 230  :       */
; 231  :         assert(!pre_creation_phase);
; 232  :         before = (before+3)&~3; // Round up to nearest multiple of 16 bytes.

	add	edi, 3
	and	edi, -4					; fffffffcH

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.
; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	lea	esi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _this$1$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR [eax]
	add	eax, 3
	add	eax, ecx
	and	eax, -4					; fffffffcH
	add	eax, edi
	lea	eax, DWORD PTR [edx+eax*4]
$LN122@create_res:
	mov	DWORD PTR [ebx+8], eax

; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [eax+8], esi
	mov	eax, DWORD PTR tv1229[ebp]
$LN20@create_res:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 813  :       for (int k=0; k < comp->num_buffer_rows; k++)

	mov	edx, DWORD PTR _comp$1$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _k$1$[ebp]
	inc	ecx
	mov	DWORD PTR tv1229[ebp], eax
	mov	DWORD PTR _k$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edx+96]
	mov	ecx, edx
	jl	$LL22@create_res
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	edx, DWORD PTR _n$4$[ebp]
	mov	eax, DWORD PTR tv1228[ebp]
$LN17@create_res:

; 810  :   for (n=0; n < codestream_collection->num_components; n++)

	add	eax, 112				; 00000070H
	inc	edx
	mov	DWORD PTR tv1228[ebp], eax
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _n$4$[ebp], edx
	cmp	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR tv1228[ebp]
	jl	$LL19@create_res
$LN18@create_res:

; 815  :     }
; 816  :   for (block=xform_blocks; block != NULL; block=block->next)

	mov	esi, DWORD PTR [edi+8]
	mov	DWORD PTR _block$2$[ebp], esi
	test	esi, esi
	je	$LN24@create_res
	npad	5
$LL25@create_res:

; 817  :     for (n=0; n < block->num_components; n++)

	xor	ebx, ebx
	mov	DWORD PTR _n$5$[ebp], ebx
	cmp	DWORD PTR [esi+8], ebx
	jle	$LN23@create_res
	xor	edi, edi
	mov	DWORD PTR tv1227[ebp], edi
$LL28@create_res:

; 818  :       {
; 819  :         kd_multi_line *line = block->components + n;

	mov	ecx, DWORD PTR [esi+12]
	add	ecx, edi
	mov	DWORD PTR _line$1$[ebp], ecx

; 820  :         if (line->bypass == NULL)

	cmp	DWORD PTR [ecx+48], 0
	jne	$LN26@create_res
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 370  :         if (!pre_created)

	cmp	BYTE PTR [ecx+7], 0
	je	SHORT $LN62@create_res

; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)
; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);

	mov	ebx, DWORD PTR [ecx+8]
	movzx	edi, BYTE PTR [ecx+4]
	test	BYTE PTR [ecx+6], 2
	mov	BYTE PTR [ecx+7], 0

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.
; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+16]

; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)
; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);

	movzx	ecx, BYTE PTR [ecx+5]
	je	SHORT $LN61@create_res

; 199  :           }
; 200  :         assert((bytes_reserved == 0) || (buffer != NULL));
; 201  :       }
; 202  :     kdu_sample16 *alloc16(int before, int after)
; 203  :       {
; 204  :       /* [SYNOPSIS]
; 205  :            Allocate an array with space for `before' entries prior to the
; 206  :            returned pointer and `after' entries after the returned pointer
; 207  :            (including the entry to which the pointer refers).  The returned
; 208  :            pointer is guaranteed to be aligned on a 16-byte boundary.
; 209  :            The pointer may be interpreted as the location of an array which
; 210  :            can accept signed indices, n, in the range -`before' <= n < `after'.
; 211  :            [//]
; 212  :            Before calling this function, you must have pre-allocated sufficient
; 213  :            space through calls to `pre_alloc' and you must have called the
; 214  :            `finalize' member function.
; 215  :       */
; 216  :         assert(!pre_creation_phase);
; 217  :         before = (before+7)&~7; // Round up to nearest multiple of 16 bytes.

	add	edi, 7
	and	edi, -8					; fffffff8H

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.
; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	lea	esi, DWORD PTR [eax+edi*2]
	mov	eax, DWORD PTR _line$1$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR [eax]
	add	eax, 7
	add	eax, ecx
	and	eax, -8					; fffffff8H
	add	eax, edi
	lea	eax, DWORD PTR [edx+eax*2]

; 375  :         else

	jmp	SHORT $LN123@create_res
$LN61@create_res:

; 221  :         assert(bytes_used <= bytes_reserved);
; 222  :         return result;
; 223  :       }
; 224  :     kdu_sample32 *alloc32(int before, int after)
; 225  :       {
; 226  :       /* [SYNOPSIS]
; 227  :            Same as `alloc16', except that it allocates storage for arrays of
; 228  :            32-bit quantities.  Again, the returned pointer is guaranteed to
; 229  :            be aligned on a 16-byte boundary.
; 230  :       */
; 231  :         assert(!pre_creation_phase);
; 232  :         before = (before+3)&~3; // Round up to nearest multiple of 16 bytes.

	add	edi, 3
	and	edi, -4					; fffffffcH

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.
; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	lea	esi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _line$1$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR [eax]
	add	eax, 3
	add	eax, ecx
	and	eax, -4					; fffffffcH
	add	eax, edi
	lea	eax, DWORD PTR [edx+eax*4]
$LN123@create_res:

; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);

	mov	ecx, DWORD PTR _line$1$[ebp]
	mov	edi, DWORD PTR tv1227[ebp]

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.
; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	DWORD PTR [ebx+8], eax
	mov	ebx, DWORD PTR _n$5$[ebp]

; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);

	mov	DWORD PTR [ecx+8], esi
	mov	esi, DWORD PTR _block$2$[ebp]
$LN62@create_res:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 823  :             if (line->is_constant)

	cmp	BYTE PTR [ecx+35], 0
	je	SHORT $LN26@create_res
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 92   :     void initialize() { reset(rev_offset,irrev_offset); }

	movss	xmm0, DWORD PTR [ecx+44]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR [ecx+40]
	call	?reset@kd_multi_line@@QAEXHM@Z		; kd_multi_line::reset
$LN26@create_res:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 817  :     for (n=0; n < block->num_components; n++)

	inc	ebx
	add	edi, 60					; 0000003cH
	mov	DWORD PTR _n$5$[ebp], ebx
	mov	DWORD PTR tv1227[ebp], edi
	cmp	ebx, DWORD PTR [esi+8]
	jl	$LL28@create_res
$LN23@create_res:

; 815  :     }
; 816  :   for (block=xform_blocks; block != NULL; block=block->next)

	mov	esi, DWORD PTR [esi+32]
	mov	DWORD PTR _block$2$[ebp], esi
	test	esi, esi
	jne	$LL25@create_res
	mov	edi, DWORD PTR _this$1$[ebp]
$LN24@create_res:

; 827  :   for (n=0; n < output_collection->num_components; n++)

	mov	eax, DWORD PTR [edi+24]
	xor	ebx, ebx
	mov	DWORD PTR _n$6$[ebp], ebx
	cmp	DWORD PTR [eax], ebx
	jle	$LN30@create_res
$LL31@create_res:

; 828  :     {
; 829  :       kd_multi_line *line = output_collection->components[n];

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _line$1$[ebp], ecx

; 830  :       if ((line->bypass == NULL) && (line->block == NULL) &&

	cmp	DWORD PTR [ecx+48], 0
	jne	$LN29@create_res
	cmp	DWORD PTR [ecx+52], 0
	jne	$LN29@create_res
	cmp	DWORD PTR [ecx+56], 0
	jge	$LN29@create_res
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 370  :         if (!pre_created)

	cmp	BYTE PTR [ecx+7], 0
	je	SHORT $LN73@create_res

; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)
; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);

	mov	ebx, DWORD PTR [ecx+8]
	movzx	edi, BYTE PTR [ecx+4]
	test	BYTE PTR [ecx+6], 2
	mov	BYTE PTR [ecx+7], 0

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.
; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+16]

; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)
; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);

	movzx	ecx, BYTE PTR [ecx+5]
	je	SHORT $LN72@create_res

; 199  :           }
; 200  :         assert((bytes_reserved == 0) || (buffer != NULL));
; 201  :       }
; 202  :     kdu_sample16 *alloc16(int before, int after)
; 203  :       {
; 204  :       /* [SYNOPSIS]
; 205  :            Allocate an array with space for `before' entries prior to the
; 206  :            returned pointer and `after' entries after the returned pointer
; 207  :            (including the entry to which the pointer refers).  The returned
; 208  :            pointer is guaranteed to be aligned on a 16-byte boundary.
; 209  :            The pointer may be interpreted as the location of an array which
; 210  :            can accept signed indices, n, in the range -`before' <= n < `after'.
; 211  :            [//]
; 212  :            Before calling this function, you must have pre-allocated sufficient
; 213  :            space through calls to `pre_alloc' and you must have called the
; 214  :            `finalize' member function.
; 215  :       */
; 216  :         assert(!pre_creation_phase);
; 217  :         before = (before+7)&~7; // Round up to nearest multiple of 16 bytes.

	add	edi, 7
	and	edi, -8					; fffffff8H

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.
; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	lea	esi, DWORD PTR [eax+edi*2]
	mov	eax, DWORD PTR _line$1$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR [eax]
	add	eax, 7
	add	eax, ecx
	and	eax, -8					; fffffff8H
	add	eax, edi
	lea	eax, DWORD PTR [edx+eax*2]

; 375  :         else

	jmp	SHORT $LN124@create_res
$LN72@create_res:

; 221  :         assert(bytes_used <= bytes_reserved);
; 222  :         return result;
; 223  :       }
; 224  :     kdu_sample32 *alloc32(int before, int after)
; 225  :       {
; 226  :       /* [SYNOPSIS]
; 227  :            Same as `alloc16', except that it allocates storage for arrays of
; 228  :            32-bit quantities.  Again, the returned pointer is guaranteed to
; 229  :            be aligned on a 16-byte boundary.
; 230  :       */
; 231  :         assert(!pre_creation_phase);
; 232  :         before = (before+3)&~3; // Round up to nearest multiple of 16 bytes.

	add	edi, 3
	and	edi, -4					; fffffffcH

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.
; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	lea	esi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _line$1$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR [eax]
	add	eax, 3
	add	eax, ecx
	and	eax, -4					; fffffffcH
	add	eax, edi
	lea	eax, DWORD PTR [edx+eax*4]
$LN124@create_res:

; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);

	mov	ecx, DWORD PTR _line$1$[ebp]
	mov	edi, DWORD PTR _this$1$[ebp]

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.
; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	DWORD PTR [ebx+8], eax
	mov	ebx, DWORD PTR _n$6$[ebp]

; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);

	mov	DWORD PTR [ecx+8], esi
$LN73@create_res:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 92   :     void initialize() { reset(rev_offset,irrev_offset); }

	movss	xmm0, DWORD PTR [ecx+44]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR [ecx+40]
	call	?reset@kd_multi_line@@QAEXHM@Z		; kd_multi_line::reset
$LN29@create_res:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 827  :   for (n=0; n < output_collection->num_components; n++)

	mov	eax, DWORD PTR [edi+24]
	inc	ebx
	mov	DWORD PTR _n$6$[ebp], ebx
	cmp	ebx, DWORD PTR [eax]
	jl	$LL31@create_res
$LN30@create_res:

; 831  :           (line->collection_idx < 0))
; 832  :         {
; 833  :           line->line.create();
; 834  :           assert(line->is_constant);
; 835  :           line->initialize();
; 836  :         }
; 837  :     }
; 838  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?create_resources@kd_multi_transform@@IAEXXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?create_resources@kd_multi_transform@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?create_resources@kd_multi_transform@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?create_resources@kd_multi_transform@@IAEXXZ ENDP	; kd_multi_transform::create_resources
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z
_TEXT	SEGMENT
_dims$2 = -88						; size = 16
_dims$3 = -72						; size = 16
_num_steps$4 = -56					; size = 4
$T5 = -56						; size = 4
$T6 = -56						; size = 4
_this$1$ = -52						; size = 4
_canvas_lim$7 = -48					; size = 4
_res$8 = -48						; size = 4
$T9 = -48						; size = 4
_tmp_comp_indices$1$ = -44				; size = 4
_canvas_min$10 = -44					; size = 4
tv2663 = -40						; size = 4
_num_levels$11 = -40					; size = 4
$T12 = -36						; size = 8
$T13 = -32						; size = 4
_num_block_inputs$ = -28				; size = 4
_num_block_outputs$ = -24				; size = 4
_num_stage_outputs$ = -20				; size = 4
_num_stage_inputs$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
_codestream$ = 8					; size = 4
_tile$ = 12						; size = 4
_force_precise$ = 16					; size = 1
_num_constant_output_lines$1$ = 20			; size = 4
_tc$14 = 20						; size = 4
$T15 = 20						; size = 4
_skip_ycc$ = 20						; size = 1
_block_is_reversible$16 = 23				; size = 1
tv2660 = 24						; size = 4
tv2658 = 24						; size = 4
tv2639 = 24						; size = 4
$T17 = 24						; size = 4
_want_fastest$ = 24					; size = 1
_symmetric_ext$18 = 27					; size = 1
_dwt_coeffs$19 = 28					; size = 4
_processing_stripe_height$ = 28				; size = 4
$T20 = 32						; size = 4
_env$ = 32						; size = 4
_n$2$ = 36						; size = 4
$T21 = 36						; size = 4
$T22 = 36						; size = 4
$T23 = 36						; size = 4
$T24 = 36						; size = 4
$T25 = 36						; size = 4
$T26 = 36						; size = 4
_env_queue$ = 36					; size = 4
_double_buffering$ = 40					; size = 1
_symmetric$27 = 43					; size = 1
?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z PROC ; kd_multi_transform::construct, COMDAT
; _this$ = ecx

; 313  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 314  :   this->use_ycc = (!skip_ycc) && tile.get_ycc();

	cmp	BYTE PTR _skip_ycc$[ebp], 0
	jne	SHORT $LN100@construct
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?get_ycc@kdu_tile@@QAE_NXZ		; kdu_tile::get_ycc
	test	al, al
	je	SHORT $LN100@construct
	mov	eax, 1
	jmp	SHORT $LN101@construct
$LN100@construct:
	xor	eax, eax
$LN101@construct:

; 321  :   kd_multi_collection *collection = new kd_multi_collection;

	push	16					; 00000010H
	mov	BYTE PTR [ebx+4], al
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	mov	DWORD PTR $T13[ebp], eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN102@construct
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 614  :       { num_components=0;  components=NULL;  next=prev=NULL; }

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 321  :   kd_multi_collection *collection = new kd_multi_collection;

	jmp	SHORT $LN103@construct
$LN102@construct:
	xor	esi, esi
	mov	DWORD PTR $T13[ebp], esi
$LN103@construct:

; 322  :   codestream_collection = output_collection = collection;
; 323  :   if (!tile.get_mct_block_info(0,0,num_stage_inputs,num_stage_outputs,

	push	0
	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _num_block_outputs$[ebp]
	mov	DWORD PTR [ebx+24], esi
	push	eax
	lea	eax, DWORD PTR _num_block_inputs$[ebp]
	mov	DWORD PTR [ebx+20], esi
	push	eax
	lea	eax, DWORD PTR _num_stage_outputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_inputs$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z ; kdu_tile::get_mct_block_info

; 324  :                                num_block_inputs,num_block_outputs))
; 325  :     assert(0); // Codestream machinery always defines at least one (dummy)
; 326  :                // stage, for simplicity;
; 327  :   collection->num_components = num_stage_inputs;

	mov	eax, DWORD PTR _num_stage_inputs$[ebp]

; 328  :   collection->components = new kd_multi_line *[num_stage_inputs];

	xor	ecx, ecx
	mov	DWORD PTR [esi], eax
	mov	edx, 4
	mov	eax, DWORD PTR _num_stage_inputs$[ebp]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+4], eax

; 329  :   codestream_components = new kd_multi_component[num_stage_inputs];

	xor	ecx, ecx
	mov	edi, DWORD PTR _num_stage_inputs$[ebp]
	mov	edx, 112				; 00000070H
	mov	eax, edi
	mov	DWORD PTR $T15[ebp], edi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 8
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN104@construct
	push	OFFSET ??1kd_multi_component@@UAE@XZ	; kd_multi_component::~kd_multi_component
	push	OFFSET ??0kd_multi_component@@QAE@XZ	; kd_multi_component::kd_multi_component
	push	edi
	lea	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], edi
	push	112					; 00000070H
	push	esi
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	jmp	SHORT $LN105@construct
$LN104@construct:
	xor	esi, esi
$LN105@construct:

; 330  :   if (env != NULL)

	mov	edi, DWORD PTR _env$[ebp]

; 333  :       for (n=0; n < num_stage_inputs; n++)

	mov	eax, DWORD PTR _num_stage_inputs$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [ebx+16], esi
	test	edi, edi
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _env_queue$[ebp]
	xor	edi, edi
	mov	DWORD PTR [ebx+56], ecx
	test	eax, eax
	jle	SHORT $LN409@construct

; 331  :     {
; 332  :       this->env_queue = env_queue;

	xor	esi, esi
$LL4@construct:

; 334  :         codestream_components[n].env_queue =

	mov	eax, DWORD PTR [ebx+16]
	push	0
	push	0
	push	OFFSET ??_C@_0BE@DHNHLPAL@component?5processor?$AA@
	push	ecx
	mov	ecx, DWORD PTR _env$[ebp]
	add	eax, esi
	push	eax
	call	?add_queue@kdu_thread_entity@@QAEPAUkdu_thread_queue@@PAVkdu_worker@@PAU2@PBD_J@Z ; kdu_thread_entity::add_queue
	mov	ecx, DWORD PTR [ebx+16]
	inc	edi
	mov	DWORD PTR [ecx+esi+8], eax
	add	esi, 112				; 00000070H
	mov	eax, DWORD PTR _num_stage_inputs$[ebp]
	mov	ecx, DWORD PTR _env_queue$[ebp]
	cmp	edi, eax
	jl	SHORT $LL4@construct
$LN409@construct:
	mov	edi, DWORD PTR _env$[ebp]
$LN3@construct:

; 335  :           env->add_queue(codestream_components+n,env_queue,
; 336  :                          "component processor");
; 337  :     }
; 338  :   int *tmp_comp_indices = get_scratch_ints(num_stage_inputs);

	push	eax
	mov	ecx, ebx
	call	?get_scratch_ints@kd_multi_transform@@QAEPAHH@Z ; kd_multi_transform::get_scratch_ints

; 339  :   tile.get_mct_block_info(0,0,num_stage_inputs,num_stage_outputs,

	push	eax
	push	0
	push	0
	push	0
	push	0
	mov	DWORD PTR _tmp_comp_indices$1$[ebp], eax
	lea	ecx, DWORD PTR _tile$[ebp]
	lea	eax, DWORD PTR _num_block_outputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_block_inputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_outputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_inputs$[ebp]
	push	eax
	push	0
	push	0
	call	?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z ; kdu_tile::get_mct_block_info

; 340  :                           num_block_inputs,num_block_outputs,
; 341  :                           NULL,NULL,NULL,NULL,tmp_comp_indices);
; 342  :   for (n=0; n < num_stage_inputs; n++)

	xor	edx, edx
	mov	DWORD PTR _n$2$[ebp], edx
	cmp	DWORD PTR _num_stage_inputs$[ebp], edx
	jle	$LN6@construct

; 335  :           env->add_queue(codestream_components+n,env_queue,
; 336  :                          "component processor");
; 337  :     }
; 338  :   int *tmp_comp_indices = get_scratch_ints(num_stage_inputs);

	xor	eax, eax
	mov	DWORD PTR tv2663[ebp], eax
	npad	7
$LL7@construct:

; 343  :     {
; 344  :       kd_multi_component *comp = codestream_components + n;

	mov	esi, DWORD PTR [ebx+16]
	add	esi, eax

; 345  :       comp->comp_idx = tmp_comp_indices[n];

	mov	eax, DWORD PTR _tmp_comp_indices$1$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]

; 346  :       collection->components[n] = &(comp->line);

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR $T13[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 347  :       comp->line.collection_idx = n;
; 348  :       kdu_tile_comp tc =
; 349  :         tile.access_component(comp->comp_idx);

	lea	eax, DWORD PTR _tc$14[ebp]
	push	DWORD PTR [esi+4]
	lea	ecx, DWORD PTR _tile$[ebp]
	mov	DWORD PTR [esi+68], edx
	push	eax
	call	?access_component@kdu_tile@@QAE?AVkdu_tile_comp@@H@Z ; kdu_tile::access_component

; 350  :       if (tc.get_reversible())

	lea	ecx, DWORD PTR _tc$14[ebp]
	call	?get_reversible@kdu_tile_comp@@QAE_NXZ	; kdu_tile_comp::get_reversible
	test	al, al
	je	SHORT $LN63@construct

; 351  :         comp->line.reversible = true;

	mov	BYTE PTR [esi+44], 1

; 352  :       else

	jmp	SHORT $LN64@construct
$LN63@construct:

; 353  :         comp->line.need_irreversible = true;

	mov	BYTE PTR [esi+45], 1
$LN64@construct:

; 354  : 
; 355  :       if (force_precise)

	cmp	BYTE PTR _force_precise$[ebp], 0
	je	SHORT $LN65@construct

; 356  :         comp->line.need_precise = true;

	mov	BYTE PTR [esi+46], 1
	jmp	SHORT $LN70@construct
$LN65@construct:

; 357  :       else if (tc.get_bit_depth(true) <= 16)

	push	1
	lea	ecx, DWORD PTR _tc$14[ebp]
	call	?get_bit_depth@kdu_tile_comp@@QAEH_N@Z	; kdu_tile_comp::get_bit_depth
	cmp	eax, 16					; 00000010H
	jg	SHORT $LN67@construct

; 358  :         comp->line.need_precise = false;

	mov	BYTE PTR [esi+46], 0
	jmp	SHORT $LN70@construct
$LN67@construct:

; 359  :       else if (comp->line.reversible)

	cmp	BYTE PTR [esi+44], 0
	je	SHORT $LN69@construct

; 360  :         comp->line.need_precise = true;

	mov	BYTE PTR [esi+46], 1

; 361  :       else

	jmp	SHORT $LN70@construct
$LN69@construct:

; 362  :         comp->line.need_precise = !want_fastest;

	cmp	BYTE PTR _want_fastest$[ebp], 0
	sete	al
	mov	BYTE PTR [esi+46], al
$LN70@construct:

; 363  : 
; 364  :       comp->line.bit_depth = tc.get_bit_depth(false);

	push	0
	lea	ecx, DWORD PTR _tc$14[ebp]
	call	?get_bit_depth@kdu_tile_comp@@QAEH_N@Z	; kdu_tile_comp::get_bit_depth
	mov	DWORD PTR [esi+48], eax

; 365  :       kdu_resolution res = tc.access_resolution();

	lea	ecx, DWORD PTR _tc$14[ebp]
	lea	eax, DWORD PTR _res$8[ebp]
	push	eax
	call	?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@XZ ; kdu_tile_comp::access_resolution

; 366  :       kdu_dims dims; res.get_dims(dims);

	lea	eax, DWORD PTR _dims$3[ebp]
	xorps	xmm0, xmm0
	push	eax
	lea	ecx, DWORD PTR _res$8[ebp]
	movups	XMMWORD PTR _dims$3[ebp], xmm0
	call	?get_dims@kdu_resolution@@QAEXAAUkdu_dims@@@Z ; kdu_resolution::get_dims

; 367  :       comp->line.size = dims.size;

	mov	eax, DWORD PTR _dims$3[ebp+8]
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR _dims$3[ebp+12]
	mov	DWORD PTR [esi+28], eax

; 368  :       comp->double_buffering =

	test	edi, edi
	je	SHORT $LN106@construct
	mov	ecx, edi
	call	?get_num_threads@kdu_thread_entity@@QAEHXZ ; kdu_thread_entity::get_num_threads
	cmp	eax, 2
	jl	SHORT $LN106@construct
	cmp	DWORD PTR _num_stage_inputs$[ebp], 2
	jl	SHORT $LN106@construct
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR _dims$3[ebp+12], 0
	jle	SHORT $LN106@construct
	cmp	DWORD PTR _dims$3[ebp+8], 0
	jle	SHORT $LN106@construct
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 368  :       comp->double_buffering =

	mov	al, BYTE PTR _double_buffering$[ebp]
	jmp	SHORT $LN107@construct
$LN106@construct:
	xor	al, al
$LN107@construct:

; 369  :         ((env==NULL) || (env->get_num_threads() < 2) ||
; 370  :          (num_stage_inputs < 2) || !dims)?false:double_buffering;
; 371  :       comp->max_available_rows=comp->num_buffer_rows=processing_stripe_height;

	mov	ecx, DWORD PTR _processing_stripe_height$[ebp]
	mov	BYTE PTR [esi+72], al
	mov	DWORD PTR [esi+96], ecx
	mov	DWORD PTR [esi+92], ecx

; 372  :       if (comp->double_buffering)

	test	al, al
	je	SHORT $LN71@construct

; 373  :         comp->num_buffer_rows *= 2;

	lea	eax, DWORD PTR [ecx+ecx]
	mov	DWORD PTR [esi+96], eax
	jmp	SHORT $LN73@construct
$LN71@construct:

; 374  :       else if (env != NULL)

	test	edi, edi
	je	SHORT $LN73@construct

; 375  :         env->add_jobs(comp->env_queue,0,true); // Make it clear that no jobs

	push	0
	push	1
	push	0
	push	DWORD PTR [esi+8]
	mov	ecx, edi
	call	?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z ; kdu_thread_entity::add_jobs
$LN73@construct:

; 376  :                                                // will be added to this queue.
; 377  :       if (comp->num_buffer_rows > comp->line.size.y)

	mov	eax, DWORD PTR [esi+24]
	cmp	DWORD PTR [esi+96], eax
	jle	SHORT $LN75@construct

; 378  :         {
; 379  :           comp->num_buffer_rows = comp->line.size.y;
; 380  :           comp->max_available_rows = comp->num_buffer_rows;
; 381  :           if (comp->double_buffering)

	cmp	BYTE PTR [esi+72], 0
	mov	DWORD PTR [esi+96], eax
	mov	DWORD PTR [esi+92], eax
	je	SHORT $LN75@construct

; 382  :             comp->max_available_rows = (comp->num_buffer_rows+1)>>1;

	inc	eax
	sar	eax, 1
	mov	DWORD PTR [esi+92], eax
$LN75@construct:

; 384  :       comp->buffer = new kdu_line_buf[comp->num_buffer_rows];

	mov	edi, DWORD PTR [esi+96]
	xor	ecx, ecx
	mov	eax, edi
	mov	DWORD PTR $T6[ebp], edi
	mov	edx, 12					; 0000000cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	test	eax, eax
	je	SHORT $LN108@construct
	test	edi, edi
	je	SHORT $LN109@construct
	lea	ecx, DWORD PTR [eax+7]
	npad	1
$LL151@construct:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx-7], 0
	lea	ecx, DWORD PTR [ecx+12]
	mov	WORD PTR [ecx-13], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx-11], 0
	sub	edi, 1
	jne	SHORT $LL151@construct
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 384  :       comp->buffer = new kdu_line_buf[comp->num_buffer_rows];

	jmp	SHORT $LN109@construct
$LN108@construct:
	xor	eax, eax
$LN109@construct:

; 340  :                           num_block_inputs,num_block_outputs,
; 341  :                           NULL,NULL,NULL,NULL,tmp_comp_indices);
; 342  :   for (n=0; n < num_stage_inputs; n++)

	mov	edx, DWORD PTR _n$2$[ebp]
	mov	edi, DWORD PTR _env$[ebp]
	inc	edx

; 384  :       comp->buffer = new kdu_line_buf[comp->num_buffer_rows];

	mov	DWORD PTR [esi+100], eax
	mov	eax, DWORD PTR tv2663[ebp]
	add	eax, 112				; 00000070H
	mov	DWORD PTR _n$2$[ebp], edx
	mov	DWORD PTR tv2663[ebp], eax
	cmp	edx, DWORD PTR _num_stage_inputs$[ebp]
	jl	$LL7@construct
$LN6@construct:

; 385  :     }
; 386  : 
; 387  :   // Now configure the remaining component collections and transform blocks.
; 388  :   int s, b;
; 389  :   kd_multi_block *block;
; 390  :   for (s=0; tile.get_mct_block_info(s,0,num_stage_inputs,num_stage_outputs,

	xor	edi, edi
	lea	eax, DWORD PTR _num_block_outputs$[ebp]
	push	edi
	push	edi
	push	edi
	push	edi
	push	edi
	push	eax
	lea	eax, DWORD PTR _num_block_inputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_outputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_inputs$[ebp]
	push	eax
	push	edi
	push	edi
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z ; kdu_tile::get_mct_block_info
	test	al, al
	je	$LN9@construct
$LL10@construct:

; 394  :       collection = new kd_multi_collection;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	mov	DWORD PTR $T20[ebp], eax
	add	esp, 4
	mov	DWORD PTR $T26[ebp], esi
	test	esi, esi
	je	SHORT $LN110@construct
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 614  :       { num_components=0;  components=NULL;  next=prev=NULL; }

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 394  :       collection = new kd_multi_collection;

	jmp	SHORT $LN111@construct
$LN110@construct:
	xor	esi, esi
	mov	DWORD PTR $T20[ebp], esi
$LN111@construct:

; 395  :       collection->prev = output_collection;

	mov	eax, DWORD PTR [ebx+24]

; 396  :       output_collection = output_collection->next = collection;
; 397  :       collection->num_components = num_stage_outputs;
; 398  :       collection->components = new kd_multi_line *[num_stage_outputs];

	xor	ecx, ecx
	mov	DWORD PTR [esi+12], eax
	mov	edx, 4
	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR [eax+8], esi
	mov	eax, DWORD PTR _num_stage_outputs$[ebp]
	mov	DWORD PTR [ebx+24], esi
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _num_stage_outputs$[ebp]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 399  :       for (n=0; n < num_stage_outputs; n++)

	xor	ecx, ecx
	mov	DWORD PTR [esi+4], eax
	add	esp, 4
	cmp	DWORD PTR _num_stage_outputs$[ebp], ecx
	jle	SHORT $LN12@construct
	npad	6
$LL13@construct:

; 400  :         collection->components[n] = NULL;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+ecx*4], 0
	inc	ecx
	cmp	ecx, DWORD PTR _num_stage_outputs$[ebp]
	jl	SHORT $LL13@construct
$LN12@construct:

; 401  : 
; 402  :       b = 0;

	xor	esi, esi
$LL16@construct:

; 403  :       do {
; 404  :           bool block_is_reversible, symmetric, symmetric_ext;
; 405  :           int num_levels, canvas_min, canvas_lim, num_steps;
; 406  :           const float *dwt_coeffs;
; 407  : 
; 408  :           if (tile.get_mct_matrix_info(s,b))

	push	0
	push	esi
	push	edi
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?get_mct_matrix_info@kdu_tile@@QAE_NHHPAM@Z ; kdu_tile::get_mct_matrix_info
	test	al, al
	je	SHORT $LN76@construct

; 409  :             block = new kd_multi_matrix_block;

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T25[ebp], ecx
	test	ecx, ecx
	je	$LN120@construct
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 374  :       {

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_matrix_block@@6B@

; 375  :         is_null_transform = false;

	mov	BYTE PTR [ecx+4], 0

; 376  :         coefficients = inverse_coefficients = NULL;

	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+40], 0

; 377  :         short_coefficients = NULL;  short_accumulator = NULL;  work = NULL;

	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+60], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 409  :             block = new kd_multi_matrix_block;

	jmp	$LN411@construct
$LN76@construct:

; 410  :           else if (tile.get_mct_rxform_info(s,b))

	push	0
	push	0
	push	esi
	push	edi
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?get_mct_rxform_info@kdu_tile@@QAE_NHHPAH0@Z ; kdu_tile::get_mct_rxform_info
	test	al, al
	je	SHORT $LN78@construct

; 411  :             block = new kd_multi_rxform_block;

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T24[ebp], ecx
	test	ecx, ecx
	je	$LN120@construct
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 424  :       {

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_rxform_block@@6B@

; 425  :         is_null_transform = false;

	mov	BYTE PTR [ecx+4], 0

; 426  :         coefficients = NULL;  accumulator = NULL;

	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 411  :             block = new kd_multi_rxform_block;

	jmp	$LN411@construct
$LN78@construct:

; 412  :           else if (tile.get_mct_dependency_info(s,b,block_is_reversible))

	push	0
	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _block_is_reversible$16[ebp]
	push	eax
	push	esi
	push	edi
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?get_mct_dependency_info@kdu_tile@@QAE_NHHAA_NPAM1PAH22@Z ; kdu_tile::get_mct_dependency_info
	test	al, al
	je	SHORT $LN80@construct

; 413  :             block = new kd_multi_dependency_block(block_is_reversible);

	push	76					; 0000004cH
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T23[ebp], ecx
	test	ecx, ecx
	je	$LN120@construct
	mov	al, BYTE PTR _block_is_reversible$16[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 454  :       {

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_dependency_block@@6B@

; 455  :         is_null_transform=false;  this->is_reversible = is_reversible;

	mov	BYTE PTR [ecx+4], 0
	mov	BYTE PTR [ecx+40], al

; 456  :         num_coeffs=0; short_matrix=NULL;  short_downshift=0; accumulator=NULL;

	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+64], 0
	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+72], 0

; 457  :         i_matrix = i_offsets = NULL;  f_matrix = f_offsets = NULL;

	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+56], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 414  :           else if (tile.get_mct_dwt_info(s,b,block_is_reversible,

	jmp	$LN411@construct
$LN80@construct:

; 415  :                                          num_levels,canvas_min,canvas_lim,
; 416  :                                          num_steps,symmetric,symmetric_ext,
; 417  :                                          dwt_coeffs) != NULL)

	push	0
	push	0
	lea	eax, DWORD PTR _dwt_coeffs$19[ebp]
	push	eax
	lea	eax, DWORD PTR _symmetric_ext$18[ebp]
	push	eax
	lea	eax, DWORD PTR _symmetric$27[ebp]
	push	eax
	lea	eax, DWORD PTR _num_steps$4[ebp]
	push	eax
	lea	eax, DWORD PTR _canvas_lim$7[ebp]
	push	eax
	lea	eax, DWORD PTR _canvas_min$10[ebp]
	push	eax
	lea	eax, DWORD PTR _num_levels$11[ebp]
	push	eax
	lea	eax, DWORD PTR _block_is_reversible$16[ebp]
	push	eax
	push	esi
	push	edi
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?get_mct_dwt_info@kdu_tile@@QAEPBUkdu_kernel_step_info@@HHAA_NAAH11100AAPBMPAH3@Z ; kdu_tile::get_mct_dwt_info
	test	eax, eax
	je	SHORT $LN82@construct

; 418  :             block = new kd_multi_dwt_block();

	push	80					; 00000050H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T22[ebp], ecx
	test	ecx, ecx
	je	$LN120@construct
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 559  :       {

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_dwt_block@@6B@

; 560  :         is_null_transform=false;  num_levels=0;  levels=NULL;

	mov	BYTE PTR [ecx+4], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0

; 561  :         num_steps=max_step_length=0;  steps=NULL;

	mov	DWORD PTR [ecx+72], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0

; 562  :         num_coefficients=0;  f_coefficients=NULL;  i_coefficients=NULL;

	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+64], 0
	mov	DWORD PTR [ecx+68], 0

; 563  :         src_bufs32 = NULL;  assert(src_bufs16 == NULL);

	mov	DWORD PTR [ecx+76], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 419  :           else

	jmp	SHORT $LN411@construct
$LN82@construct:

; 420  :             block = new kd_multi_null_block();

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T21[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN120@construct
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 358  :       { is_null_transform = true; }

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_null_block@@6B@
	mov	BYTE PTR [ecx+4], 1
$LN411@construct:

; 91   :       }
; 92   :     void initialize() { reset(rev_offset,irrev_offset); }
; 93   :       /* Do not call this function until after the `line' member has been
; 94   :          created.  Sets the line's contents equal to the value of the
; 95   :          `rev_offset' or `irrev_offset' member, depending on the
; 96   :          `reversible' flag.  Normally, this function need only be called
; 97   :          if `is_constant' is true. */
; 98   :     void reset(int rev_off, float irrev_off);
; 99   :       /* Sets the contents of the line to `rev_off' if it has a reversible
; 100  :          representation, else `irrev_off'. */
; 101  :     void apply_offset(int rev_off, float irrev_off);
; 102  :       /* Adds the offset defined by `rev_off' or `irrev_off', whichever
; 103  :          is appropriate, to the embedded `line's sample values.  Ignores the
; 104  :          internal `rev_offset' and `irrev_offset' members, although these may
; 105  :          well be the values used to derive the `rev_off' and `irrev_off'
; 106  :          arguments. */
; 107  :     void copy(kd_multi_line *src, int rev_offset, float irrev_offset);
; 108  :       /* Copies the contents of `src' to the present line.  The function
; 109  :          ignores any offsets which may be recorded in either object, using
; 110  :          the offset and scaling factors supplied via the function's
; 111  :          arguments instead (of course, these may be derived from one or
; 112  :          both objects' members).  Both lines must have the same width.
; 113  :          If the target line is reversible, the source line must also be
; 114  :          reversible, the `irrev_offset' argument is ignored and `rev_offset'
; 115  :          is added to the source sample values as they are copied.  If the
; 116  :          target line is irreversible, the `rev_offset' argument is ignored
; 117  :          and `irrev_offset' is added to the source samples after applying any
; 118  :          required conversions: if the source samples are also irreversible,
; 119  :          conversion means scaling by 2^{src->bit_depth} / 2^{this->bit_depth};
; 120  :          if the source samples are reversible, conversion means scaling by
; 121  :          1 / 2^{this->bit_depth}. */
; 122  :   public: // Data
; 123  :     kdu_line_buf line;
; 124  :     kdu_coords size; // Size of intermediate component to which line belongs
; 125  :     int row_idx; // First valid row is 0 -- initialized to -1
; 126  :     int num_consumers; // See below
; 127  :     union {
; 128  :         int outstanding_consumers; // See below
; 129  :         bool waiting_for_inversion; // See below
; 130  :       };
; 131  :     bool reversible;   // True if producer or consumer needs reversible data
; 132  :     bool need_irreversible; // If producer or consumer needs irreversible data
; 133  :     bool need_precise; // If producer or consumer needs 32-bit samples
; 134  :     bool is_constant; // True if there is no generator for this line
; 135  :     int bit_depth; // 0 if not a codestream or final output component
; 136  :     int rev_offset;
; 137  :     float irrev_offset;
; 138  :     kd_multi_line *bypass; // See below
; 139  :     kd_multi_block *block;
; 140  :     int collection_idx; // See below
; 141  :   };
; 142  :   /* Notes:
; 143  :         Each `kd_multi_line' object represents a single intermediate component.
; 144  :      We describe the flow of information in terms of generators and consumers,
; 145  :      taking the perspective of the decompressor, since this is the more
; 146  :      complex case.  During compression, however, the roles of generator
; 147  :      and consumer are interchanged.
; 148  :         The line associated with an intermediate component has at most one
; 149  :      generator, but potentially multiple consumers.  Consumers include
; 150  :      transform blocks and the application, which is a consumer for
; 151  :      all final output components.  During decompression, the line cannot be
; 152  :      advanced until all consumers have finished using its contents -- i.e.,
; 153  :      until `outstanding_consumers' goes to 0.  When it does, a new line is
; 154  :      generated, `row_idx' is advanced, and `outstanding_consumers' is reset
; 155  :      to `num_consumers'.  During compression, the `outstanding_consumers'
; 156  :      member is not used.  In this case, the `waiting_for_inversion' flag is
; 157  :      involved -- it is set to true if the row identified by `row_idx' has
; 158  :      been written by a consumer, but has not yet been used by the transform
; 159  :      block.
; 160  :         If `block' is non-NULL, the line is generated by the referenced
; 161  :      transform block.  Otherwise, the line either corresponds to a
; 162  :      codestream image component or a constant component (`is_constant' is
; 163  :      true).  For codestream components, the `collection_idx' identifies the
; 164  :      index of the entry in the `kd_component_collection::components'
; 165  :      array within the codestream component collection (maintained by
; 166  :      `kd_multi_transform') which points to this line.  This is the only
; 167  :      piece of information required to pull or push a new line to the
; 168  :      relevant codestream component processing engine.  In all other cases,
; 169  :      `collection_idx' will be negative.
; 170  :         If `bypass' is non-NULL, all accesses to this line should be
; 171  :      treated as accesses to the line identified by `bypass'.  In this
; 172  :      case, all offsets are collapsed into the line referenced by `bypass'
; 173  :      so that no arithmetic is required here.  Also, in this case the
; 174  :      `line' resource remains empty.  `bypass' pointers are found during
; 175  :      a transform optimization phase; they serve principally to avoid
; 176  :      line copying when implementing null transforms.
; 177  :         Note that no line which has `is_constant' set will be bypassed.  Also
; 178  :      note that all line references found in `kd_multi_block::dependencies'
; 179  :      or `kd_multi_collection::components' arrays are adjusted to ensure that
; 180  :      they do not point to lines which have been bypassed -- they always
; 181  :      point to the lines which actually have the source data of interest.
; 182  :      This simplifies the processing of data. */
; 183  : 
; 184  : /*****************************************************************************/
; 185  : /*                              kd_multi_block                               */
; 186  : /*****************************************************************************/
; 187  : 
; 188  : class kd_multi_block {
; 189  :   public: // Member functions
; 190  :     kd_multi_block()
; 191  :       {
; 192  :         is_null_transform = true; // Changed by derived constructors
; 193  :         num_components = 0;  components = NULL;  next = prev = NULL;
; 194  :         num_dependencies = num_available_dependencies = 0; dependencies = NULL;
; 195  :         outstanding_consumers = 0;

	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 420  :             block = new kd_multi_null_block();

	jmp	SHORT $LN121@construct
$LN120@construct:
	xor	ecx, ecx
$LN121@construct:

; 421  : 
; 422  :           block->prev = block_tail;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [ecx+36], eax

; 423  :           if (block_tail == NULL)

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	jne	SHORT $LN84@construct

; 424  :             xform_blocks = block_tail = block;

	mov	DWORD PTR [ebx+8], ecx

; 425  :           else

	jmp	SHORT $LN412@construct
$LN84@construct:

; 426  :             block_tail = block_tail->next = block;

	mov	DWORD PTR [eax+32], ecx
$LN412@construct:

; 427  :           block->initialize(s,b,tile,num_block_inputs,num_block_outputs,

	mov	edx, DWORD PTR $T20[ebp]
	push	ebx
	push	edx
	mov	DWORD PTR [ebx+12], ecx
	push	DWORD PTR [edx+12]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _num_block_outputs$[ebp]
	push	DWORD PTR _num_block_inputs$[ebp]
	push	DWORD PTR _tile$[ebp]
	push	esi
	push	edi
	call	DWORD PTR [eax+4]

; 428  :                             collection->prev,collection,this);
; 429  :         } while (tile.get_mct_block_info(s,++b,num_stage_inputs,

	push	0
	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _num_block_outputs$[ebp]
	inc	esi
	push	eax
	lea	eax, DWORD PTR _num_block_inputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_outputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_inputs$[ebp]
	push	eax
	push	esi
	push	edi
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z ; kdu_tile::get_mct_block_info
	test	al, al
	jne	$LL16@construct

; 385  :     }
; 386  : 
; 387  :   // Now configure the remaining component collections and transform blocks.
; 388  :   int s, b;
; 389  :   kd_multi_block *block;
; 390  :   for (s=0; tile.get_mct_block_info(s,0,num_stage_inputs,num_stage_outputs,

	push	0
	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _num_block_outputs$[ebp]

; 391  :                                     num_block_inputs,num_block_outputs); s++)

	inc	edi
	push	eax
	lea	eax, DWORD PTR _num_block_inputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_outputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_inputs$[ebp]
	push	eax
	push	0
	push	edi
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z ; kdu_tile::get_mct_block_info
	test	al, al
	jne	$LL10@construct
$LN9@construct:

; 430  :                         num_stage_outputs,num_block_inputs,num_block_outputs));
; 431  :     }
; 432  : 
; 433  :   // Find out how many constant output lines there are -- these need to be
; 434  :   // assigned line resources from the `constant_output_lines' array
; 435  :   int cscan, num_constant_output_lines=0;
; 436  :   for (n=0; n < output_collection->num_components; n++)

	mov	eax, DWORD PTR [ebx+24]
	xor	esi, esi
	mov	DWORD PTR _num_constant_output_lines$1$[ebp], esi
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	jle	$LN87@construct

; 437  :     if (output_collection->components[n] == NULL)

	mov	eax, DWORD PTR [eax+4]
	npad	2
$LL19@construct:
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN17@construct

; 438  :       num_constant_output_lines++;

	inc	esi
$LN17@construct:

; 430  :                         num_stage_outputs,num_block_inputs,num_block_outputs));
; 431  :     }
; 432  : 
; 433  :   // Find out how many constant output lines there are -- these need to be
; 434  :   // assigned line resources from the `constant_output_lines' array
; 435  :   int cscan, num_constant_output_lines=0;
; 436  :   for (n=0; n < output_collection->num_components; n++)

	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LL19@construct

; 439  :   if (num_constant_output_lines > 0)

	mov	DWORD PTR _num_constant_output_lines$1$[ebp], esi
	test	esi, esi
	jle	$LN87@construct

; 440  :     constant_output_lines = new kd_multi_line[num_constant_output_lines];

	mov	eax, esi
	mov	edx, 60					; 0000003cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T17[ebp], eax
	test	eax, eax
	je	$LN122@construct
	mov	edx, esi
	test	esi, esi
	je	$LN123@construct
	lea	ecx, DWORD PTR [eax+6]
	npad	6
$LL181@construct:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx-6], 0
	lea	ecx, DWORD PTR [ecx+60]
	mov	WORD PTR [ecx-60], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx-58], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx-54], 0
	mov	DWORD PTR [ecx-50], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 87   :         row_idx = -1;  num_consumers = outstanding_consumers = 0;

	mov	DWORD PTR [ecx-46], -1
	mov	DWORD PTR [ecx-38], 0
	mov	DWORD PTR [ecx-42], 0

; 88   :         reversible = need_irreversible = need_precise = is_constant = false;

	mov	DWORD PTR [ecx-34], 0

; 89   :         bit_depth = 0;  rev_offset = 0;  irrev_offset = 0.0F;

	mov	DWORD PTR [ecx-30], 0
	mov	DWORD PTR [ecx-26], 0
	mov	DWORD PTR [ecx-22], 0

; 90   :         bypass=NULL;  block=NULL;  collection_idx = -1;

	mov	DWORD PTR [ecx-18], 0
	mov	DWORD PTR [ecx-14], 0
	mov	DWORD PTR [ecx-10], -1
	sub	edx, 1
	jne	SHORT $LL181@construct
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 440  :     constant_output_lines = new kd_multi_line[num_constant_output_lines];

	jmp	SHORT $LN123@construct
$LN122@construct:
	xor	eax, eax
$LN123@construct:
	mov	DWORD PTR [ebx+28], eax
$LN87@construct:

; 441  : 
; 442  :   // Set output component sizes and bit-depths.
; 443  :   for (cscan=0, n=0; n < output_collection->num_components; n++)

	mov	eax, DWORD PTR [ebx+24]
	xor	edi, edi
	cmp	DWORD PTR [eax], edi
	jle	$LL23@construct
	xor	ecx, ecx
	mov	DWORD PTR tv2660[ebp], ecx
	npad	7
$LL22@construct:
	mov	eax, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [eax+4]

; 444  :     {
; 445  :       kd_multi_line *line = output_collection->components[n];

	mov	esi, DWORD PTR [edx+edi*4]

; 446  :       if (line == NULL)

	test	esi, esi
	jne	SHORT $LN88@construct

; 447  :         {
; 448  :           line = output_collection->components[n] =

	mov	esi, DWORD PTR [ebx+28]

; 449  :             constant_output_lines + (cscan++);
; 450  :           line->need_precise = force_precise;

	mov	eax, DWORD PTR _force_precise$[ebp]
	add	esi, ecx
	mov	DWORD PTR [edx+edi*4], esi
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR tv2660[ebp], ecx
	mov	BYTE PTR [esi+34], al

; 451  :           line->need_irreversible = true; // Use irreversible as the default

	mov	BYTE PTR [esi+33], 1

; 452  :           line->is_constant = true;

	mov	BYTE PTR [esi+35], 1
$LN88@construct:

; 453  :         }
; 454  :       line->num_consumers++;

	inc	DWORD PTR [esi+24]

; 455  :       kdu_dims dims;
; 456  :       codestream.get_tile_dims(tile.get_tile_idx(),n,dims,true);

	lea	eax, DWORD PTR $T12[ebp]
	xorps	xmm0, xmm0
	lea	ecx, DWORD PTR _tile$[ebp]
	push	eax
	movups	XMMWORD PTR _dims$2[ebp], xmm0
	call	?get_tile_idx@kdu_tile@@QAE?AUkdu_coords@@XZ ; kdu_tile::get_tile_idx
	push	1
	lea	ecx, DWORD PTR _dims$2[ebp]
	push	ecx
	push	edi
	push	DWORD PTR [eax+4]
	lea	ecx, DWORD PTR _codestream$[ebp]
	push	DWORD PTR [eax]
	call	?get_tile_dims@kdu_codestream@@QAEXUkdu_coords@@HAAUkdu_dims@@_N@Z ; kdu_codestream::get_tile_dims

; 457  :       line->size = dims.size;

	mov	eax, DWORD PTR _dims$2[ebp+8]

; 458  :       line->bit_depth = codestream.get_bit_depth(n,true);

	lea	ecx, DWORD PTR _codestream$[ebp]
	push	1
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR _dims$2[ebp+12]
	push	edi
	mov	DWORD PTR [esi+16], eax
	call	?get_bit_depth@kdu_codestream@@QAEHH_N@Z ; kdu_codestream::get_bit_depth
	mov	ecx, DWORD PTR tv2660[ebp]
	inc	edi
	mov	DWORD PTR [esi+36], eax
	mov	eax, DWORD PTR [ebx+24]
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL22@construct
	npad	8
$LL23@construct:

; 459  :     }
; 460  : 
; 461  :   // Now pass through the network as often as required, until the
; 462  :   // reversibility, bit-depth and `need_precise' flags of all blocks and
; 463  :   // lines becomes stable.  This could take a few iterations, if there are
; 464  :   // null lines.
; 465  :   while (propagate_knowledge(force_precise));

	push	DWORD PTR _force_precise$[ebp]
	mov	ecx, ebx
	call	?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z ; kd_multi_transform::propagate_knowledge
	test	al, al
	jne	SHORT $LL23@construct

; 466  : 
; 467  :   // Now normalize the coefficients based on available bit-depth information
; 468  :   for (block=xform_blocks; block != NULL; block=block->next)

	mov	esi, DWORD PTR [ebx+8]
	test	esi, esi
	je	SHORT $LL31@construct
$LL27@construct:

; 469  :     {
; 470  :       for (n=0; n < block->num_components; n++)

	xor	edi, edi
	cmp	DWORD PTR [esi+8], edi
	jle	SHORT $LN29@construct
	xor	ecx, ecx
	mov	DWORD PTR tv2658[ebp], ecx
$LL30@construct:

; 471  :         { 
; 472  :           kd_multi_line *line = block->components + n;

	mov	edx, DWORD PTR [esi+12]
	add	edx, ecx

; 473  :           if ((line->bit_depth == 0) || (line->irrev_offset == 0.0F))

	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN28@construct
	movss	xmm2, DWORD PTR [edx+44]
	xorps	xmm0, xmm0
	ucomiss	xmm2, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN28@construct

; 474  :             continue; // Normalization is not possible or not required
; 475  :           line->irrev_offset *= 1.0F / ((float)(1<<line->bit_depth));

	mov	ecx, DWORD PTR [edx+36]
	mov	eax, 1
	movss	xmm1, DWORD PTR __real@3f800000
	shl	eax, cl
	mov	ecx, DWORD PTR tv2658[ebp]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	mulss	xmm1, xmm2
	movss	DWORD PTR [edx+44], xmm1
$LN28@construct:

; 469  :     {
; 470  :       for (n=0; n < block->num_components; n++)

	inc	edi
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR tv2658[ebp], ecx
	cmp	edi, DWORD PTR [esi+8]
	jl	SHORT $LL30@construct
$LN29@construct:

; 476  :         }
; 477  :       block->normalize_coefficients();

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+8]
	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL27@construct
$LL31@construct:

; 478  :     }
; 479  : 
; 480  :   // Re-run the `propagate_knowledge' function in case coefficient
; 481  :   // normalization encountered a problem which caused it to adjust the
; 482  :   // `need_precise' flag for one or more lines.
; 483  :   while (propagate_knowledge(false));

	push	0
	mov	ecx, ebx
	call	?propagate_knowledge@kd_multi_transform@@AAE_N_N@Z ; kd_multi_transform::propagate_knowledge
	test	al, al
	jne	SHORT $LL31@construct

; 484  : 
; 485  :   // Now adjust offsets to make sure that output components are signed.
; 486  :   for (n=0; n < output_collection->num_components; n++)

	mov	eax, DWORD PTR [ebx+24]
	xor	esi, esi
	cmp	DWORD PTR [eax], esi
	jle	SHORT $LN34@construct
$LL35@construct:

; 487  :     {
; 488  :       kd_multi_line *line = output_collection->components[n];

	mov	eax, DWORD PTR [ebx+24]

; 489  :       if (!codestream.get_signed(n,true))

	lea	ecx, DWORD PTR _codestream$[ebp]
	push	1
	push	esi
	mov	eax, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+esi*4]
	call	?get_signed@kdu_codestream@@QAE_NH_N@Z	; kdu_codestream::get_signed
	test	al, al
	jne	SHORT $LN33@construct

; 490  :         {
; 491  :           line->rev_offset -= ((1 << line->bit_depth) >> 1);
; 492  :           line->irrev_offset -= 0.5F;

	movss	xmm0, DWORD PTR [edi+44]
	mov	eax, 1
	subss	xmm0, DWORD PTR __real@3f000000
	mov	ecx, DWORD PTR [edi+36]
	shl	eax, cl
	sar	eax, 1
	sub	DWORD PTR [edi+40], eax
	movss	DWORD PTR [edi+44], xmm0
$LN33@construct:

; 484  : 
; 485  :   // Now adjust offsets to make sure that output components are signed.
; 486  :   for (n=0; n < output_collection->num_components; n++)

	mov	eax, DWORD PTR [ebx+24]
	inc	esi
	cmp	esi, DWORD PTR [eax]
	jl	SHORT $LL35@construct
$LN34@construct:

; 493  :         }
; 494  :     }
; 495  : 
; 496  :   if (num_constant_output_lines > 0)

	mov	edi, DWORD PTR _num_constant_output_lines$1$[ebp]
	test	edi, edi
	jle	SHORT $LN37@construct

; 497  :     { // See if we can combine some of the constant output lines
; 498  :       for (n=0; n < output_collection->num_components; n++)

	mov	eax, DWORD PTR [ebx+24]
	xor	esi, esi
	cmp	DWORD PTR [eax], esi
	jle	SHORT $LN37@construct
$LL38@construct:
	mov	eax, DWORD PTR [ebx+24]

; 499  :         {
; 500  :           kd_multi_line *line = output_collection->components[n];
; 501  :           if ((line > constant_output_lines) &&

	mov	ecx, DWORD PTR [ebx+28]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR tv2639[ebp], eax
	mov	edx, DWORD PTR [eax+esi*4]
	cmp	edx, ecx
	jbe	SHORT $LN36@construct
	mov	eax, edi
	shl	eax, 4
	sub	eax, edi
	lea	eax, DWORD PTR [ecx+eax*4]
	cmp	edx, eax
	jae	SHORT $LN36@construct

; 502  :               (line < (constant_output_lines+num_constant_output_lines)))
; 503  :             { // Candidate for replacement
; 504  :               assert(line->is_constant && !line->reversible);
; 505  :               kd_multi_line *ref = constant_output_lines;
; 506  :               for (; ref < line; ref++)

	cmp	ecx, edx
	jae	SHORT $LN36@construct

; 507  :                 if ((ref->size.x == line->size.x) &&

	mov	edi, DWORD PTR [edx+16]
	npad	1
$LL41@construct:
	cmp	DWORD PTR [ecx+16], edi
	jne	SHORT $LN39@construct
	movss	xmm0, DWORD PTR [ecx+44]
	ucomiss	xmm0, DWORD PTR [edx+44]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN221@construct
$LN39@construct:

; 502  :               (line < (constant_output_lines+num_constant_output_lines)))
; 503  :             { // Candidate for replacement
; 504  :               assert(line->is_constant && !line->reversible);
; 505  :               kd_multi_line *ref = constant_output_lines;
; 506  :               for (; ref < line; ref++)

	add	ecx, 60					; 0000003cH
	cmp	ecx, edx
	jb	SHORT $LL41@construct
	jmp	SHORT $LN408@construct
$LN221@construct:

; 508  :                     (ref->irrev_offset == line->irrev_offset))
; 509  :                   {
; 510  :                     output_collection->components[n] = ref;

	mov	eax, DWORD PTR tv2639[ebp]
	mov	DWORD PTR [eax+esi*4], ecx
$LN408@construct:
	mov	edi, DWORD PTR _num_constant_output_lines$1$[ebp]
$LN36@construct:

; 497  :     { // See if we can combine some of the constant output lines
; 498  :       for (n=0; n < output_collection->num_components; n++)

	mov	eax, DWORD PTR [ebx+24]
	inc	esi
	cmp	esi, DWORD PTR [eax]
	jl	SHORT $LL38@construct
$LN37@construct:

; 511  :                     break;
; 512  :                   }
; 513  :             }
; 514  :         }
; 515  :     }
; 516  : 
; 517  :   // Finally, see if we can bypass copying in null transforms.
; 518  :   for (block=xform_blocks; block != NULL; block=block->next)

	mov	esi, DWORD PTR [ebx+8]
	test	esi, esi
	je	$LN43@construct
	xorps	xmm1, xmm1
	npad	4
$LL44@construct:

; 519  :     {
; 520  :       for (n=0; n < block->num_dependencies; n++)

	xor	edx, edx
	cmp	DWORD PTR [esi+16], edx
	jle	SHORT $LN46@construct
	mov	ecx, DWORD PTR [esi+20]
	npad	6
$LL47@construct:

; 521  :         {
; 522  :           while ((block->dependencies[n] != NULL) &&

	mov	eax, DWORD PTR [ecx+edx*4]
	test	eax, eax
	je	SHORT $LN45@construct
$LL48@construct:
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $LN45@construct

; 523  :                  (block->dependencies[n]->bypass != NULL))
; 524  :             block->dependencies[n] = block->dependencies[n]->bypass;

	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [ecx+edx*4]
	test	eax, eax
	jne	SHORT $LL48@construct
$LN45@construct:

; 519  :     {
; 520  :       for (n=0; n < block->num_dependencies; n++)

	inc	edx
	cmp	edx, DWORD PTR [esi+16]
	jl	SHORT $LL47@construct
$LN46@construct:

; 525  :         }
; 526  :       if (block->is_null_transform)

	cmp	BYTE PTR [esi+4], 0
	je	SHORT $LN42@construct

; 527  :         for (n=0; n < block->num_components; n++)

	xor	edi, edi
	cmp	DWORD PTR [esi+8], edi
	jle	SHORT $LN42@construct
	xor	ebx, ebx
$LL52@construct:

; 528  :           {
; 529  :             kd_multi_line *tgt_line = block->components + n;

	mov	ecx, DWORD PTR [esi+12]
	add	ecx, ebx

; 530  :             if (tgt_line->is_constant)

	cmp	BYTE PTR [ecx+35], 0
	jne	SHORT $LN50@construct

; 531  :               continue;
; 532  :             kd_multi_line *src_line = block->dependencies[n];
; 533  :             assert((n < block->num_dependencies) && (src_line != NULL));
; 534  :             bool have_offset = (tgt_line->reversible)?

	cmp	BYTE PTR [ecx+32], 0
	mov	eax, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [eax+edi*4]
	je	SHORT $LN126@construct
	cmp	DWORD PTR [ecx+40], 0
	setne	al

; 535  :               (tgt_line->rev_offset != 0):(tgt_line->irrev_offset != 0.0F);
; 536  :             assert(src_line->bypass == NULL);
; 537  :             assert(tgt_line->reversible == src_line->reversible);
; 538  :             if (have_offset && (src_line->num_consumers > 1))

	test	al, al
	je	SHORT $LN97@construct
	jmp	SHORT $LN319@construct
$LN126@construct:

; 531  :               continue;
; 532  :             kd_multi_line *src_line = block->dependencies[n];
; 533  :             assert((n < block->num_dependencies) && (src_line != NULL));
; 534  :             bool have_offset = (tgt_line->reversible)?

	movss	xmm0, DWORD PTR [ecx+44]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN97@construct
$LN319@construct:

; 535  :               (tgt_line->rev_offset != 0):(tgt_line->irrev_offset != 0.0F);
; 536  :             assert(src_line->bypass == NULL);
; 537  :             assert(tgt_line->reversible == src_line->reversible);
; 538  :             if (have_offset && (src_line->num_consumers > 1))

	cmp	DWORD PTR [edx+24], 1
	jg	SHORT $LN50@construct
$LN97@construct:

; 539  :               continue; // Bypassing could cause conflicts
; 540  :             if ((!src_line->reversible) &&

	cmp	BYTE PTR [edx+32], 0
	jne	SHORT $LN98@construct
	mov	eax, DWORD PTR [edx+36]
	cmp	eax, DWORD PTR [ecx+36]
	jne	SHORT $LN50@construct
$LN98@construct:

; 541  :                 (src_line->bit_depth != tgt_line->bit_depth))
; 542  :               continue; // Bypassing will cause bit-depth inconsistencies
; 543  :             tgt_line->bypass = src_line;
; 544  :             src_line->rev_offset += tgt_line->rev_offset;

	mov	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR [ecx+48], edx
	add	DWORD PTR [edx+40], eax

; 545  :             src_line->irrev_offset += tgt_line->irrev_offset;

	movss	xmm0, DWORD PTR [ecx+44]
	addss	xmm0, DWORD PTR [edx+44]
	movss	DWORD PTR [edx+44], xmm0

; 546  :             src_line->num_consumers += tgt_line->num_consumers-1;

	mov	eax, DWORD PTR [ecx+24]
	dec	eax
	add	DWORD PTR [edx+24], eax
$LN50@construct:

; 527  :         for (n=0; n < block->num_components; n++)

	inc	edi
	add	ebx, 60					; 0000003cH
	cmp	edi, DWORD PTR [esi+8]
	jl	SHORT $LL52@construct
$LN42@construct:

; 511  :                     break;
; 512  :                   }
; 513  :             }
; 514  :         }
; 515  :     }
; 516  : 
; 517  :   // Finally, see if we can bypass copying in null transforms.
; 518  :   for (block=xform_blocks; block != NULL; block=block->next)

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	$LL44@construct
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN43@construct:

; 547  :           }
; 548  :     }
; 549  :   for (collection=codestream_collection->next;

	mov	eax, DWORD PTR [ebx+20]
	mov	esi, DWORD PTR [eax+8]

; 550  :        collection != NULL; collection=collection->next)

	test	esi, esi
	je	SHORT $LN54@construct
$LL55@construct:

; 551  :     for (n=0; n < collection->num_components; n++)

	xor	edx, edx
	cmp	DWORD PTR [esi], edx
	jle	SHORT $LN53@construct
	mov	ecx, DWORD PTR [esi+4]
	npad	1
$LL58@construct:

; 552  :       {
; 553  :         while ((collection->components[n] != NULL) &&

	mov	eax, DWORD PTR [ecx+edx*4]
	test	eax, eax
	je	SHORT $LN56@construct
$LL59@construct:
	mov	eax, DWORD PTR [eax+48]
	test	eax, eax
	je	SHORT $LN56@construct

; 554  :                (collection->components[n]->bypass != NULL))
; 555  :           collection->components[n] = collection->components[n]->bypass;

	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+edx*4]
	test	eax, eax
	jne	SHORT $LL59@construct
$LN56@construct:

; 551  :     for (n=0; n < collection->num_components; n++)

	inc	edx
	cmp	edx, DWORD PTR [esi]
	jl	SHORT $LL58@construct
$LN53@construct:

; 550  :        collection != NULL; collection=collection->next)

	mov	esi, DWORD PTR [esi+8]
	test	esi, esi
	jne	SHORT $LL55@construct
$LN54@construct:

; 556  :       }
; 557  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z$1:
	xor	ebx, ebx
	mov	eax, DWORD PTR $T15[ebp]
	mov	ecx, 112				; 00000070H
	mul	ecx
	seto	bl
	neg	ebx
	or	ebx, eax
	xor	eax, eax
	add	ebx, 4
	setb	al
	neg	eax
	or	eax, ebx
	push	eax
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
__ehhandler$?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@kd_multi_transform@@IAEXVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ENDP ; kd_multi_transform::construct
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?get_scratch_floats@kd_multi_transform@@QAEPAMH@Z
_TEXT	SEGMENT
_num_elts$ = 8						; size = 4
?get_scratch_floats@kd_multi_transform@@QAEPAMH@Z PROC	; kd_multi_transform::get_scratch_floats, COMDAT
; _this$ = ecx

; 863  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 864  :   if (max_scratch_floats < num_elts)

	mov	ecx, DWORD PTR _num_elts$[ebp]
	mov	eax, DWORD PTR [esi+68]
	cmp	eax, ecx
	jge	SHORT $LN5@get_scratc

; 865  :     {
; 866  :       max_scratch_floats += num_elts;

	add	eax, ecx
	mov	DWORD PTR [esi+68], eax

; 867  :       if (scratch_floats != NULL)

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN3@get_scratc

; 868  :         delete[] scratch_floats;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@get_scratc:

; 869  :       scratch_floats = new float[max_scratch_floats];

	mov	eax, DWORD PTR [esi+68]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+72], eax
$LN5@get_scratc:

; 870  :     }
; 871  :   return scratch_floats;

	mov	eax, DWORD PTR [esi+72]
	pop	esi

; 872  : }

	pop	ebp
	ret	4
?get_scratch_floats@kd_multi_transform@@QAEPAMH@Z ENDP	; kd_multi_transform::get_scratch_floats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?get_scratch_ints@kd_multi_transform@@QAEPAHH@Z
_TEXT	SEGMENT
_num_elts$ = 8						; size = 4
?get_scratch_ints@kd_multi_transform@@QAEPAHH@Z PROC	; kd_multi_transform::get_scratch_ints, COMDAT
; _this$ = ecx

; 846  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 847  :   if (max_scratch_ints < num_elts)

	mov	ecx, DWORD PTR _num_elts$[ebp]
	mov	eax, DWORD PTR [esi+60]
	cmp	eax, ecx
	jge	SHORT $LN5@get_scratc

; 848  :     {
; 849  :       max_scratch_ints += num_elts;

	add	eax, ecx
	mov	DWORD PTR [esi+60], eax

; 850  :       if (scratch_ints != NULL)

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN3@get_scratc

; 851  :         delete[] scratch_ints;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@get_scratc:

; 852  :       scratch_ints = new int[max_scratch_ints];

	mov	eax, DWORD PTR [esi+60]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+64], eax
$LN5@get_scratc:

; 853  :     }
; 854  :   return scratch_ints;

	mov	eax, DWORD PTR [esi+64]
	pop	esi

; 855  : }

	pop	ebp
	ret	4
?get_scratch_ints@kd_multi_transform@@QAEPAHH@Z ENDP	; kd_multi_transform::get_scratch_ints
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ??1kd_multi_transform@@UAE@XZ
_TEXT	SEGMENT
??1kd_multi_transform@@UAE@XZ PROC			; kd_multi_transform::~kd_multi_transform, COMDAT
; _this$ = ecx

; 283  : {

	push	esi
	mov	esi, ecx

; 284  :   while ((block_tail=xform_blocks) != NULL)

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_transform@@6B@
	mov	DWORD PTR [esi+12], eax
	test	eax, eax
	je	SHORT $LN31@kd_multi_t
$LL2@kd_multi_t:

; 285  :     {
; 286  :       xform_blocks = block_tail->next;

	mov	eax, DWORD PTR [esi+12]

; 287  :       delete block_tail;

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [eax+32]
	mov	DWORD PTR [esi+8], eax
	test	ecx, ecx
	je	SHORT $LN11@kd_multi_t
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN11@kd_multi_t:

; 284  :   while ((block_tail=xform_blocks) != NULL)

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+12], eax
	test	eax, eax
	jne	SHORT $LL2@kd_multi_t
$LN31@kd_multi_t:

; 289  :   while ((output_collection=codestream_collection) != NULL)

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+24], eax
	test	eax, eax
	je	SHORT $LN5@kd_multi_t
	push	edi
	npad	2
$LL4@kd_multi_t:

; 290  :     {
; 291  :       codestream_collection = output_collection->next;

	mov	eax, DWORD PTR [esi+24]

; 292  :       delete output_collection;

	mov	edi, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+20], eax
	test	edi, edi
	je	SHORT $LN20@kd_multi_t
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 616  :       { delete[] components; }

	push	DWORD PTR [edi+4]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	16					; 00000010H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 12					; 0000000cH
$LN20@kd_multi_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 289  :   while ((output_collection=codestream_collection) != NULL)

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+24], eax
	test	eax, eax
	jne	SHORT $LL4@kd_multi_t
	pop	edi
$LN5@kd_multi_t:

; 293  :     }
; 294  :   if (constant_output_lines != NULL)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN6@kd_multi_t

; 295  :     delete[] constant_output_lines;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@kd_multi_t:

; 296  :   if (codestream_components != NULL)

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $LN16@kd_multi_t
	cmp	DWORD PTR [ecx-4], 0
	lea	eax, DWORD PTR [ecx-4]
	je	SHORT $LN15@kd_multi_t
	mov	eax, DWORD PTR [ecx]
	push	3
	call	DWORD PTR [eax]
	jmp	SHORT $LN16@kd_multi_t
$LN15@kd_multi_t:
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN16@kd_multi_t:

; 297  :     delete[] codestream_components;
; 298  :   if (scratch_ints != NULL)

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN8@kd_multi_t

; 299  :     delete[] scratch_ints;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@kd_multi_t:

; 300  :   if (scratch_floats != NULL)

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN9@kd_multi_t

; 301  :     delete[] scratch_floats;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN9@kd_multi_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 154  :       { if (buf_handle != NULL) delete[] buf_handle; }

	mov	eax, DWORD PTR [esi+52]
	pop	esi
	test	eax, eax
	je	SHORT $LN27@kd_multi_t
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN27@kd_multi_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 302  : }

	ret	0
??1kd_multi_transform@@UAE@XZ ENDP			; kd_multi_transform::~kd_multi_transform
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??0kd_multi_transform@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0kd_multi_transform@@QAE@XZ PROC			; kd_multi_transform::kd_multi_transform, COMDAT
; _this$ = ecx

; 736  :     kd_multi_transform()

	push	ebp
	mov	ebp, esp
	push	ecx

; 737  :       {

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_transform@@6B@

; 743  :       }

	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 150  :       { bytes_reserved = bytes_used = buffer_size = 0;

	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+36], 0

; 151  :         pre_creation_phase=true; buffer = buf_handle = NULL; }

	mov	BYTE PTR [ecx+32], 1
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+48], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 736  :     kd_multi_transform()

	mov	DWORD PTR _this$[ebp], ecx

; 738  :         use_ycc=false; xform_blocks=block_tail=NULL;

	mov	BYTE PTR [ecx+4], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0

; 739  :         codestream_collection=output_collection=NULL;

	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+20], 0

; 740  :         constant_output_lines=NULL; codestream_components = NULL;

	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+16], 0

; 741  :         env_queue = NULL;  max_scratch_ints = max_scratch_floats = 0;

	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+60], 0

; 742  :         scratch_ints=NULL;  scratch_floats=NULL;

	mov	DWORD PTR [ecx+64], 0
	mov	DWORD PTR [ecx+72], 0

; 743  :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??0kd_multi_transform@@QAE@XZ ENDP			; kd_multi_transform::kd_multi_transform
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Ekd_multi_component@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekd_multi_component@@UAEPAXI@Z PROC			; kd_multi_component::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekd_multi_component@@UAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kd_multi_component@@UAE@XZ	; kd_multi_component::~kd_multi_component
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	112					; 00000070H
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	imul	ecx, DWORD PTR [edi], 112
	add	ecx, 4
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:
	call	??1kd_multi_component@@UAE@XZ		; kd_multi_component::~kd_multi_component
	test	bl, 1
	je	SHORT $LN4@vector
	push	112					; 00000070H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Ekd_multi_component@@UAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekd_multi_component@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekd_multi_component@@UAEPAXI@Z ENDP			; kd_multi_component::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ?do_job@kd_multi_component@@UAEXPAVkdu_thread_entity@@H@Z
_TEXT	SEGMENT
_ent$ = 8						; size = 4
_job_idx$ = 12						; size = 4
?do_job@kd_multi_component@@UAEXPAVkdu_thread_entity@@H@Z PROC ; kd_multi_component::do_job, COMDAT
; _this$ = ecx

; 661  :       {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx

; 663  :         for (int k=0; k < num_rows_in_progress; k++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+88], ebx
	jle	SHORT $LN3@do_job
	mov	eax, DWORD PTR _ent$[ebp]
	push	edi
$LL4@do_job:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 776  :         state->pull(line,env);

	push	eax
	mov	eax, DWORD PTR [esi+84]
	add	eax, ebx

; 651  :       }
; 652  :     void push(kdu_line_buf &line, bool allow_exchange)
; 653  :       { /* [SYNOPSIS]
; 654  :              This version of the `push' function is provided only for
; 655  :              backward compatibility with Kakadu versions 4.5 and earlier. */
; 656  :         state->push(line,NULL);
; 657  :       }
; 658  :   protected: // Data
; 659  :     kdu_push_ifc_base *state;
; 660  :   };
; 661  : 
; 662  : /*****************************************************************************/
; 663  : /*                            kdu_pull_ifc_base                              */
; 664  : /*****************************************************************************/
; 665  : 
; 666  : class kdu_pull_ifc_base {
; 667  :   protected:
; 668  :     friend class kdu_pull_ifc;
; 669  :     virtual ~kdu_pull_ifc_base() { return; }
; 670  :     virtual void start(kdu_thread_env *env) = 0;
; 671  :     virtual void pull(kdu_line_buf &line, kdu_thread_env *env) = 0;
; 672  :   };
; 673  : 
; 674  : /*****************************************************************************/
; 675  : /*                               kdu_pull_ifc                                */
; 676  : /*****************************************************************************/
; 677  : 
; 678  : class kdu_pull_ifc {
; 679  :   /* [BIND: reference]
; 680  :      [SYNOPSIS]
; 681  :      All classes which support `pull' calls derive from this class so
; 682  :      that the caller may remain ignorant of the specific type of object from
; 683  :      which samples are to be recovered.  The purpose of derivation is usually
; 684  :      just to introduce the correct constructor.  The objects are actually just
; 685  :      interfaces to an appropriate object created by the relevant derived
; 686  :      class's constructor.  The interface directs `pull' calls to the internal
; 687  :      object in a manner which should incur no cost.
; 688  :      [//]
; 689  :      The interface objects may be copied at will; the internal object will
; 690  :      not be destroyed when an interface goes out of scope.  Consequently,
; 691  :      the interface objects do not have meaningful destructors.  Instead,
; 692  :      to destroy the internal object, the `destroy' member function must be
; 693  :      called explicitly.
; 694  :   */
; 695  :   public: // Member functions
; 696  :     kdu_pull_ifc() { state = NULL; }
; 697  :       /* [SYNOPSIS]
; 698  :            Creates an empty interface.  You must assign the interface to
; 699  :            one of the derived objects such as `kdu_decoder' or `kdu_synthesis'
; 700  :            before you may use the `pull' function.
; 701  :       */
; 702  :     void destroy()
; 703  :       {
; 704  :         if (state != NULL) delete state;
; 705  :         state = NULL;
; 706  :       }
; 707  :       /* [SYNOPSIS]
; 708  :            Automatically destroys all objects which were created by this
; 709  :            relevant derived object's constructor, including lower level
; 710  :            DWT synthesis stages and decoding objects.  Upon return, the
; 711  :            interface will be empty, meaning that `exists' returns false.
; 712  :       */
; 713  :     void start(kdu_thread_env *env)
; 714  :       { /* [SYNOPSIS]
; 715  :              This function may be called at any point after construction
; 716  :              of a `kdu_synthesis' or `kdu_decoder' object, once you have
; 717  :              invoked the `kdu_sample_allocator::finalize' function on the
; 718  :              `kdu_sample_allocator' object used during construction.  In
; 719  :              particular, this means that you will not be creating any
; 720  :              further objects to share the storage offered by the sample
; 721  :              allocator.
; 722  :              [//]
; 723  :              It is never necessary to call this function, since it will be
; 724  :              invoked automatically, if required, when `pull' is first called.
; 725  :              Indeed for applications which are not multi-threaded (i.e.,
; 726  :              when `env' is NULL) it is pretty pointless to call this function,
; 727  :              but you can if you like.
; 728  :              [//]
; 729  :              For multi-threaded applications (i.e., when `env' is non-NULL),
; 730  :              this function enables you to get the most benefit from
; 731  :              multi-threading, since it allows the code-block processing
; 732  :              associated with any number of tile-component-subbands to be
; 733  :              started immediately.  By contrast, the `pull' function will
; 734  :              not be invoked on a subband's `kdu_decoder' object until
; 735  :              dependencies have been satisfied in other subbands, which
; 736  :              cannot generally happen until a full row of code-blocks have
; 737  :              been decoded in a first subband.
; 738  :         */
; 739  :         state->start(env);
; 740  :       }
; 741  :     bool exists() { return (state==NULL)?false:true; }

	cmp	DWORD PTR [esi+104], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 665  :             pull_ifc.pull(buffer[first_row_in_progress+k],env);

	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+100]
	lea	eax, DWORD PTR [eax+edx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 776  :         state->pull(line,env);

	push	eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 664  :           if (pull_ifc.exists())

	je	SHORT $LN5@do_job
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 776  :         state->pull(line,env);

	mov	ecx, DWORD PTR [esi+104]
	mov	edi, DWORD PTR [ecx]
	call	DWORD PTR [edi+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 666  :           else

	jmp	SHORT $LN2@do_job
$LN5@do_job:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 650  :         state->push(line,env);

	mov	ecx, DWORD PTR [esi+108]
	mov	edi, DWORD PTR [ecx]
	call	DWORD PTR [edi+4]
$LN2@do_job:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 663  :         for (int k=0; k < num_rows_in_progress; k++)

	mov	eax, DWORD PTR _ent$[ebp]
	inc	ebx
	cmp	ebx, DWORD PTR [esi+88]
	jl	SHORT $LL4@do_job
	pop	edi
$LN3@do_job:
	pop	esi
	pop	ebx

; 667  :             push_ifc.push(buffer[first_row_in_progress+k],env);
; 668  :       }

	pop	ebp
	ret	8
?do_job@kd_multi_component@@UAEXPAVkdu_thread_entity@@H@Z ENDP ; kd_multi_component::do_job
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??1kd_multi_component@@UAE@XZ
_TEXT	SEGMENT
??1kd_multi_component@@UAE@XZ PROC			; kd_multi_component::~kd_multi_component, COMDAT
; _this$ = ecx

; 655  :       {

	push	esi
	mov	esi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 741  :     bool exists() { return (state==NULL)?false:true; }

	cmp	DWORD PTR [esi+104], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 655  :       {

	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_component@@6B@

; 656  :         if (pull_ifc.exists()) pull_ifc.destroy();

	je	SHORT $LN2@kd_multi_c
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 704  :         if (state != NULL) delete state;

	mov	ecx, DWORD PTR [esi+104]
	test	ecx, ecx
	je	SHORT $LN11@kd_multi_c
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN11@kd_multi_c:

; 705  :         state = NULL;

	mov	DWORD PTR [esi+104], 0
$LN2@kd_multi_c:

; 608  :       }
; 609  :       /* [SYNOPSIS]
; 610  :            Automatically destroys all objects which were created by the
; 611  :            relevant derived object's constructor, including lower level
; 612  :            DWT analysis stages and encoding objects.  Upon return, the
; 613  :            interface will be empty, meaning that `exists' returns
; 614  :            false.
; 615  :       */
; 616  :     bool exists() { return (state==NULL)?false:true; }

	cmp	DWORD PTR [esi+108], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 657  :         if (push_ifc.exists()) push_ifc.destroy();

	je	SHORT $LN3@kd_multi_c
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 606  :         if (state != NULL) delete state;

	mov	ecx, DWORD PTR [esi+108]
	test	ecx, ecx
	je	SHORT $LN18@kd_multi_c
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN18@kd_multi_c:

; 607  :         state = NULL;

	mov	DWORD PTR [esi+108], 0
$LN3@kd_multi_c:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 658  :         if (buffer != NULL) delete[] buffer;

	mov	eax, DWORD PTR [esi+100]
	test	eax, eax
	je	SHORT $LN23@kd_multi_c
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN23@kd_multi_c:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 106  :     virtual ~kdu_worker() { return; } // Prevent compiler warnings

	mov	DWORD PTR [esi], OFFSET ??_7kdu_worker@@6B@
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 659  :       }

	ret	0
??1kd_multi_component@@UAE@XZ ENDP			; kd_multi_component::~kd_multi_component
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??0kd_multi_component@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0kd_multi_component@@QAE@XZ PROC			; kd_multi_component::kd_multi_component, COMDAT
; _this$ = ecx

; 647  :     kd_multi_component()

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 648  :       {

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_component@@6B@
	call	??0kd_multi_line@@QAE@XZ		; kd_multi_line::kd_multi_line
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 696  :     kdu_pull_ifc() { state = NULL; }

	mov	DWORD PTR [esi+104], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 653  :       }

	mov	eax, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 598  :     kdu_push_ifc() { state = NULL; }

	mov	DWORD PTR [esi+108], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 649  :         comp_idx=0;  env_queue=NULL;  double_buffering=false;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	BYTE PTR [esi+72], 0

; 650  :         next_available_row = first_row_in_progress = 0;

	mov	DWORD PTR [esi+84], 0
	mov	DWORD PTR [esi+76], 0

; 651  :         num_available_rows = num_rows_in_progress = 0;

	mov	DWORD PTR [esi+88], 0
	mov	DWORD PTR [esi+80], 0

; 652  :         max_available_rows = num_buffer_rows = 0;  buffer=NULL;

	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+92], 0
	mov	DWORD PTR [esi+100], 0
	pop	esi

; 653  :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??0kd_multi_component@@QAE@XZ ENDP			; kd_multi_component::kd_multi_component
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??_Gkd_multi_collection@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_multi_collection@@QAEPAXI@Z PROC			; kd_multi_collection::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 616  :       { delete[] components; }

	push	DWORD PTR [esi+4]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	16					; 00000010H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_multi_collection@@QAEPAXI@Z ENDP			; kd_multi_collection::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??1kd_multi_collection@@QAE@XZ
_TEXT	SEGMENT
??1kd_multi_collection@@QAE@XZ PROC			; kd_multi_collection::~kd_multi_collection, COMDAT
; _this$ = ecx

; 616  :       { delete[] components; }

	push	DWORD PTR [ecx+4]
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
??1kd_multi_collection@@QAE@XZ ENDP			; kd_multi_collection::~kd_multi_collection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??0kd_multi_collection@@QAE@XZ
_TEXT	SEGMENT
??0kd_multi_collection@@QAE@XZ PROC			; kd_multi_collection::kd_multi_collection, COMDAT
; _this$ = ecx

; 614  :       { num_components=0;  components=NULL;  next=prev=NULL; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0kd_multi_collection@@QAE@XZ ENDP			; kd_multi_collection::kd_multi_collection
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_multi_dwt_block@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_multi_dwt_block@@UAEPAXI@Z PROC			; kd_multi_dwt_block::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_multi_dwt_block@@UAE@XZ		; kd_multi_dwt_block::~kd_multi_dwt_block
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	80					; 00000050H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_multi_dwt_block@@UAEPAXI@Z ENDP			; kd_multi_dwt_block::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?perform_inverse@kd_multi_dwt_block@@UAEXXZ
_TEXT	SEGMENT
_lev_idx$1$ = -60					; size = 4
tv3016 = -56						; size = 8
tv3009 = -56						; size = 8
_i_scale$1$ = -52					; size = 4
_sp$1$ = -52						; size = 4
_width$1$ = -52						; size = 4
_downshift$1$ = -52					; size = 4
_sp$1$ = -52						; size = 4
tv2940 = -52						; size = 4
tv3005 = -48						; size = 8
tv2999 = -48						; size = 8
_offset$2$ = -44					; size = 4
_line$1$ = -44						; size = 4
_dst32$1$ = -44						; size = 4
tv2949 = -44						; size = 4
tv2912 = -44						; size = 4
_upshift$1$ = -40					; size = 4
_dp$1$ = -40						; size = 4
_sp$1$ = -40						; size = 4
tv2915 = -40						; size = 4
_w$1$ = -36						; size = 4
_s$1$ = -36						; size = 4
_n$1$ = -36						; size = 4
tv2941 = -36						; size = 4
_n$2$ = -32						; size = 4
_dst16$1$ = -28						; size = 4
_src_idx$1$ = -24					; size = 4
_step$1$ = -20						; size = 4
_n$3$ = -20						; size = 4
_sp$1$ = -16						; size = 4
_i$1$ = -16						; size = 4
_this$1$ = -12						; size = 4
_lev$1$ = -8						; size = 4
tv2932 = -1						; size = 1
?perform_inverse@kd_multi_dwt_block@@UAEXXZ PROC	; kd_multi_dwt_block::perform_inverse, COMDAT
; _this$ = ecx

; 3719 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	edx, ecx
	mov	DWORD PTR _this$1$[ebp], edx

; 3720 :   int n, lev_idx;
; 3721 :   for (lev_idx=num_levels-1; lev_idx >= 0; lev_idx--)

	mov	eax, DWORD PTR [edx+40]
	sub	eax, 1
	mov	DWORD PTR _lev_idx$1$[ebp], eax
	js	$LN3@perform_in

; 3791 :                         if (k < c_min)
; 3792 :                           k=(sym_extension)?(2*c_min-k):(c_min+((c_min^k)&1));

	movss	xmm6, DWORD PTR __real@3f000000
	movss	xmm7, DWORD PTR __real@46fffe00
	push	esi
	push	edi
	npad	4
$LL4@perform_in:

; 3722 :     {
; 3723 :       kd_multi_dwt_level *lev = levels + lev_idx;

	imul	eax, eax, 52
	add	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _lev$1$[ebp], eax

; 3724 : 
; 3725 :       // Start with subband analysis in this level
; 3726 :       if (lev->canvas_size == 1)

	cmp	DWORD PTR [eax+4], 1
	jne	$LN49@perform_in

; 3727 :         { // DWT analysis consists of simply copying the single input line to
; 3728 :           // the corresponding subband line, possibly with a scaling factor
; 3729 :           // of 2.  Of course, the transform is performed in-place here, so
; 3730 :           // no actual copying is required.
; 3731 :           assert(lev->normalizing_shift == 0);
; 3732 :           if ((lev->canvas_min & 1) && is_reversible)

	test	BYTE PTR [eax], 1
	je	SHORT $LN21@perform_in
	cmp	BYTE PTR [edx+48], 0
	je	SHORT $LN21@perform_in

; 3733 :             { // Double the size of reversible samples
; 3734 :               kd_multi_line *line = lev->components[0];

	mov	eax, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	mov	al, BYTE PTR [ecx+6]
	and	al, 2
	je	SHORT $LN83@perform_in
	mov	esi, DWORD PTR [ecx+8]
	jmp	SHORT $LN84@perform_in
$LN83@perform_in:
	xor	esi, esi
$LN84@perform_in:

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	al, al
	je	SHORT $LN87@perform_in
	xor	edi, edi
	jmp	SHORT $LN88@perform_in
$LN87@perform_in:
	mov	edi, DWORD PTR [ecx+8]
$LN88@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3737 :               int w, width=line->size.x;

	mov	ecx, DWORD PTR [ecx+16]

; 3738 :               if (dp16 != NULL)
; 3739 :                 for (w=0; w < width; w++)

	xor	eax, eax
	test	esi, esi
	je	$LN52@perform_in
	test	ecx, ecx
	jle	SHORT $LN224@perform_in
	npad	3
$LL7@perform_in:

; 3740 :                   dp16[w].ival <<= 1;

	shl	WORD PTR [esi+eax*2], 1
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL7@perform_in
$LN224@perform_in:
	mov	eax, DWORD PTR _lev$1$[ebp]
$LN21@perform_in:

; 3807 :                                                   width,0);
; 3808 :                   else
; 3809 :                     assert(0);
; 3810 :                 }
; 3811 :             }
; 3812 :         }
; 3813 : 
; 3814 :       // Finish by transferring the subband data to the dependencies
; 3815 :       for (n=0; n < lev->region_size; n++)

	xor	esi, esi
	mov	DWORD PTR _n$3$[ebp], esi
	cmp	DWORD PTR [eax+20], esi
	jle	$LN2@perform_in
	npad	6
$LL33@perform_in:

; 3816 :         {
; 3817 :           if (lev->dependencies[n] == NULL)

	mov	eax, DWORD PTR [eax+36]
	mov	esi, DWORD PTR [eax+esi*4]
	mov	DWORD PTR tv2941[ebp], esi
	test	esi, esi
	je	$LN31@perform_in

; 3818 :             continue;
; 3819 :           kd_multi_line *line = lev->components[n];

	mov	ecx, DWORD PTR _lev$1$[ebp]

; 3820 :           kd_multi_line *dep = *(lev->dependencies[n]);

	mov	esi, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _n$3$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _line$1$[ebp], ecx

; 3821 :           if (dep == NULL)

	test	esi, esi
	je	$LN31@perform_in

; 3822 :             continue;
; 3823 :           if (is_reversible)

	cmp	BYTE PTR [edx+48], 0
	je	$LN68@perform_in

; 3824 :             dep->copy(line,-dep->rev_offset,-dep->irrev_offset);

	movss	xmm0, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [esi+40]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	neg	eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	eax
	push	ecx
	mov	ecx, esi
	call	?copy@kd_multi_line@@QAEXPAU1@HM@Z	; kd_multi_line::copy

; 3825 :           else

	jmp	$LN221@perform_in
$LN52@perform_in:

; 3741 :               else
; 3742 :                 for (w=0; w < width; w++)

	test	ecx, ecx
	jle	SHORT $LN224@perform_in
	npad	3
$LL10@perform_in:

; 3743 :                   dp32[w].ival <<= 1;

	shl	DWORD PTR [edi+eax*4], 1
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL10@perform_in

; 3744 :             }
; 3745 :         }
; 3746 :       else

	jmp	$LN224@perform_in
$LN49@perform_in:

; 3747 :         {
; 3748 :           if ((!is_reversible) && (lev->normalizing_shift > 0))

	cmp	BYTE PTR [edx+48], 0
	jne	$LN12@perform_in
	cmp	DWORD PTR [eax+40], 0
	jle	$LN12@perform_in

; 3749 :             { // Need to downshift the input samples before performing
; 3750 :               // subband analysis
; 3751 :               for (n=0; n < lev->region_size; n++)

	xor	ecx, ecx
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	DWORD PTR [eax+20], ecx
	jle	$LN12@perform_in
	npad	1
$LL13@perform_in:

; 3752 :                 {
; 3753 :                   kd_multi_line *line = lev->components[n];

	mov	eax, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [eax+ecx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	cl, BYTE PTR [eax+6]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3754 :                   int w, width=line->size.x;

	mov	edi, DWORD PTR [eax+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	and	cl, 2
	jne	$LN55@perform_in
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR _sp$1$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3755 :                   if (line->line.get_buf32() != NULL)

	test	esi, esi
	je	$LN55@perform_in

; 3756 :                     {
; 3757 :                       kdu_sample32 *sp = line->line.get_buf32();
; 3758 :                       float scale = 1.0F / (float)(1<<lev->normalizing_shift);

	mov	ecx, DWORD PTR _lev$1$[ebp]
	mov	eax, 1
	movss	xmm4, DWORD PTR __real@3f800000
	mov	ecx, DWORD PTR [ecx+40]
	shl	eax, cl

; 3759 :                       for (w=0; w < width; w++)

	xor	ecx, ecx
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm4, xmm0
	shufps	xmm4, xmm4, 0
	movaps	xmm5, xmm4
	shufps	xmm5, xmm5, 0
	test	edi, edi
	jle	$LN11@perform_in
	cmp	edi, 8
	jb	$LN169@perform_in
	mov	eax, edi
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN225@perform_in
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN225@perform_in:
	mov	edx, edi
	sub	edx, eax
	lea	eax, DWORD PTR [esi+8]
	npad	10
$LL16@perform_in:

; 3760 :                         sp[w].fval *= scale;

	movss	xmm2, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [eax+32]
	movss	xmm0, DWORD PTR [eax-32]
	add	ecx, 8
	movss	xmm1, DWORD PTR [eax-36]
	movss	xmm3, DWORD PTR [eax-40]
	unpcklps xmm3, xmm0
	unpcklps xmm1, xmm2
	unpcklps xmm3, xmm1
	mulps	xmm3, xmm5
	movss	DWORD PTR [eax-40], xmm3
	shufps	xmm3, xmm3, 229				; 000000e5H
	movss	DWORD PTR [eax-36], xmm3
	movss	xmm1, DWORD PTR [eax-20]
	unpckhps xmm3, xmm3
	movss	DWORD PTR [eax-32], xmm3
	movss	xmm0, DWORD PTR [eax-16]
	unpckhps xmm3, xmm3
	movss	DWORD PTR [eax-28], xmm3
	movss	xmm2, DWORD PTR [eax-12]
	movss	xmm3, DWORD PTR [eax-24]
	unpcklps xmm3, xmm0
	unpcklps xmm1, xmm2
	unpcklps xmm3, xmm1
	mulps	xmm3, xmm5
	movss	DWORD PTR [eax-24], xmm3
	shufps	xmm3, xmm3, 229				; 000000e5H
	movss	DWORD PTR [eax-20], xmm3
	unpckhps xmm3, xmm3
	movss	DWORD PTR [eax-16], xmm3
	unpckhps xmm3, xmm3
	movss	DWORD PTR [eax-12], xmm3
	cmp	ecx, edx
	jl	$LL16@perform_in
$LN169@perform_in:
	cmp	ecx, edi
	jge	$LN11@perform_in
	mov	eax, edi
	sub	eax, ecx

; 3759 :                       for (w=0; w < width; w++)

	cmp	eax, 4
	jl	SHORT $LC189@perform_in
	lea	eax, DWORD PTR [esi+8]
	mov	esi, edi
	sub	esi, ecx
	lea	eax, DWORD PTR [eax+ecx*4]
	sub	esi, 4
	shr	esi, 2
	inc	esi
	lea	ecx, DWORD PTR [ecx+esi*4]
	npad	1
$LL190@perform_in:

; 3760 :                         sp[w].fval *= scale;

	lea	eax, DWORD PTR [eax+16]
	movups	xmm0, XMMWORD PTR [eax-24]
	mulps	xmm0, xmm4
	movups	XMMWORD PTR [eax-24], xmm0
	sub	esi, 1
	jne	SHORT $LL190@perform_in
	mov	esi, DWORD PTR _sp$1$[ebp]
$LC189@perform_in:

; 3759 :                       for (w=0; w < width; w++)

	cmp	ecx, edi
	jge	SHORT $LN11@perform_in
	npad	6
$LC168@perform_in:

; 3760 :                         sp[w].fval *= scale;

	movss	xmm0, DWORD PTR [esi+ecx*4]
	mulss	xmm0, xmm4
	movss	DWORD PTR [esi+ecx*4], xmm0
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LC168@perform_in

; 3761 :                     }
; 3762 :                   else

	jmp	SHORT $LN11@perform_in
$LN55@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	cl, cl
	je	SHORT $LN99@perform_in
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _sp$1$[ebp], eax
	jmp	SHORT $LN100@perform_in
$LN99@perform_in:
	mov	DWORD PTR _sp$1$[ebp], 0
$LN100@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3765 :                       int downshift = lev->normalizing_shift;

	mov	ecx, DWORD PTR _lev$1$[ebp]

; 3766 :                       kdu_int16 offset = (kdu_int16)(1<<(downshift-1));
; 3767 :                       for (w=0; w < width; w++)

	xor	esi, esi
	mov	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR _downshift$1$[ebp], eax
	lea	ecx, DWORD PTR [eax-1]
	mov	eax, 1
	shl	ax, cl
	movzx	eax, ax
	test	edi, edi
	jle	SHORT $LN11@perform_in
	mov	edx, DWORD PTR _sp$1$[ebp]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	cwde
	mov	DWORD PTR tv2949[ebp], eax
	npad	1
$LL19@perform_in:

; 3768 :                         sp[w].ival = (sp[w].ival+offset) >> downshift;

	movsx	eax, WORD PTR [edx+esi*2]
	add	eax, DWORD PTR tv2949[ebp]
	sar	eax, cl
	mov	WORD PTR [edx+esi*2], ax
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL19@perform_in
$LN11@perform_in:

; 3749 :             { // Need to downshift the input samples before performing
; 3750 :               // subband analysis
; 3751 :               for (n=0; n < lev->region_size; n++)

	mov	ecx, DWORD PTR _n$1$[ebp]
	mov	eax, DWORD PTR _lev$1$[ebp]
	inc	ecx
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+20]
	jl	$LL13@perform_in
	mov	edx, DWORD PTR _this$1$[ebp]
$LN12@perform_in:

; 3769 :                     }
; 3770 :                 }
; 3771 :             }
; 3772 : 
; 3773 :           // Now for the lifting steps
; 3774 :           int c_min = lev->canvas_min;

	mov	esi, DWORD PTR [eax]

; 3775 :           int c_max = c_min + lev->canvas_size-1;

	mov	eax, DWORD PTR [eax+4]

; 3776 :           for (int s=0; s < num_steps; s++)

	mov	DWORD PTR _s$1$[ebp], 0
	lea	edi, DWORD PTR [esi-1]
	add	edi, eax
	cmp	DWORD PTR [edx+52], 0
	jle	$LN224@perform_in

; 3769 :                     }
; 3770 :                 }
; 3771 :             }
; 3772 : 
; 3773 :           // Now for the lifting steps
; 3774 :           int c_min = lev->canvas_min;

	mov	eax, DWORD PTR _lev$1$[ebp]
	mov	DWORD PTR tv2915[ebp], 0
	npad	3
$LL22@perform_in:

; 3777 :             {
; 3778 :               kd_lifting_step *step = steps + s;

	mov	ecx, DWORD PTR [edx+56]
	add	ecx, DWORD PTR tv2915[ebp]
	mov	DWORD PTR _step$1$[ebp], ecx

; 3779 :               int parity = 1-(s&1); // Parity of the lines being updated here

	or	ecx, -1
	sub	ecx, DWORD PTR _s$1$[ebp]

; 3780 :               for (n=(lev->region_min^parity)&1; n < lev->region_size; n+=2)

	xor	ecx, DWORD PTR [eax+16]
	and	ecx, 1
	mov	DWORD PTR _n$2$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+20]
	jge	$LN20@perform_in
$LL25@perform_in:

; 3781 :                 {
; 3782 :                   kd_multi_line *line = lev->components[n];

	mov	eax, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3783 :                   int width = line->size.x;

	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _width$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	mov	cl, BYTE PTR [eax+6]
	and	cl, 2
	je	SHORT $LN103@perform_in
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _dst16$1$[ebp], edx
	mov	edx, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LN104@perform_in
$LN103@perform_in:
	mov	DWORD PTR _dst16$1$[ebp], 0
$LN104@perform_in:

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	cl, cl
	je	SHORT $LN107@perform_in
	xor	eax, eax
	jmp	SHORT $LN226@perform_in
$LN107@perform_in:
	mov	eax, DWORD PTR [eax+8]
$LN226@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3786 :                   int src_idx = ((n+lev->region_min)^1) + 2*step->support_min;

	mov	ecx, DWORD PTR _lev$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	DWORD PTR _dst32$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3786 :                   int src_idx = ((n+lev->region_min)^1) + 2*step->support_min;

	mov	eax, DWORD PTR _step$1$[ebp]

; 3787 :                   for (int i=0; i < step->support_length; i++, src_idx+=2)

	mov	DWORD PTR _i$1$[ebp], 0
	mov	ecx, DWORD PTR [ecx+16]
	add	ecx, DWORD PTR _n$2$[ebp]
	movsx	eax, WORD PTR [eax+4]
	xor	ecx, 1
	lea	eax, DWORD PTR [ecx+eax*2]
	mov	ecx, DWORD PTR _step$1$[ebp]
	mov	DWORD PTR _src_idx$1$[ebp], eax
	cmp	BYTE PTR [ecx+1], 0
	jbe	$LN219@perform_in
$LL28@perform_in:

; 3788 :                     { // Fill in the source buffers
; 3789 :                       int k = src_idx;

	mov	ecx, eax
$LL29@perform_in:

; 3790 :                       while ((k < c_min) || (k > c_max))

	cmp	ecx, esi
	jl	SHORT $LN213@perform_in
	cmp	ecx, edi
	jle	SHORT $LN30@perform_in

; 3794 :                           k=(sym_extension)?(2*c_max-k):(c_max-((c_max^k)&1));

	cmp	BYTE PTR [edx+50], 0
	je	SHORT $LN79@perform_in
	lea	eax, DWORD PTR [edi+edi]
	sub	eax, ecx
	jmp	SHORT $LL28@perform_in
$LN79@perform_in:
	mov	eax, ecx
	mov	ecx, edi
	xor	eax, edi
	and	eax, 1
	sub	ecx, eax
	jmp	SHORT $LL29@perform_in
$LN213@perform_in:

; 3791 :                         if (k < c_min)
; 3792 :                           k=(sym_extension)?(2*c_min-k):(c_min+((c_min^k)&1));

	cmp	BYTE PTR [edx+50], 0
	je	SHORT $LN77@perform_in
	lea	eax, DWORD PTR [esi+esi]
	sub	eax, ecx
	jmp	SHORT $LL28@perform_in
$LN77@perform_in:
	xor	ecx, esi
	and	ecx, 1
	add	ecx, esi

; 3793 :                         else

	jmp	SHORT $LL29@perform_in
$LN30@perform_in:

; 3795 :                       k -= lev->region_min;

	mov	eax, DWORD PTR _lev$1$[ebp]
	sub	ecx, DWORD PTR [eax+16]

; 3796 :                       assert((k >= 0) && (k < lev->region_size));
; 3797 :                       if (dst16 != NULL)

	cmp	DWORD PTR _dst16$1$[ebp], 0

; 3798 :                         src_bufs16[i] = lev->components[k]->line.get_buf16();

	mov	eax, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax+ecx*4]
	je	SHORT $LN60@perform_in
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN111@perform_in
$LN115@perform_in:

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	ecx, DWORD PTR [ecx+8]
$LN116@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3800 :                         src_bufs32[i] = lev->components[k]->line.get_buf32();

	mov	eax, DWORD PTR [edx+76]
	mov	edx, DWORD PTR _i$1$[ebp]
	add	DWORD PTR _src_idx$1$[ebp], 2
	mov	DWORD PTR [eax+edx*4], ecx
	mov	eax, DWORD PTR _step$1$[ebp]
	mov	ecx, DWORD PTR _i$1$[ebp]
	mov	edx, DWORD PTR _this$1$[ebp]
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	movzx	eax, BYTE PTR [eax+1]
	cmp	ecx, eax
	mov	eax, DWORD PTR _src_idx$1$[ebp]
	jl	SHORT $LL28@perform_in
	mov	ecx, DWORD PTR _step$1$[ebp]
$LN219@perform_in:

; 3801 :                     }
; 3802 :                   if (dst16 != NULL)

	mov	eax, DWORD PTR _dst16$1$[ebp]
	test	eax, eax
	je	SHORT $LN62@perform_in

; 3803 :                     perform_analysis_lifting_step(step,src_bufs16,dst16,dst16,

	push	0
	push	DWORD PTR _width$1$[ebp]
	push	eax
	push	eax
	push	DWORD PTR [edx+76]
	push	ecx
	call	?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z ; perform_analysis_lifting_step
	jmp	SHORT $LN227@perform_in
$LN60@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN115@perform_in
$LN111@perform_in:
	xor	ecx, ecx
	jmp	SHORT $LN116@perform_in
$LN62@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3805 :                   else if (dst32 != NULL)

	mov	eax, DWORD PTR _dst32$1$[ebp]
	test	eax, eax
	je	SHORT $LN23@perform_in

; 3806 :                     perform_analysis_lifting_step(step,src_bufs32,dst32,dst32,

	push	0
	push	DWORD PTR _width$1$[ebp]
	push	eax
	push	eax
	push	DWORD PTR [edx+76]
	push	ecx
	call	?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z ; perform_analysis_lifting_step
$LN227@perform_in:
	mov	edx, DWORD PTR _this$1$[ebp]
	add	esp, 24					; 00000018H
$LN23@perform_in:

; 3780 :               for (n=(lev->region_min^parity)&1; n < lev->region_size; n+=2)

	mov	ecx, DWORD PTR _n$2$[ebp]
	mov	eax, DWORD PTR _lev$1$[ebp]
	add	ecx, 2
	mov	DWORD PTR _n$2$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+20]
	jl	$LL25@perform_in
$LN20@perform_in:

; 3776 :           for (int s=0; s < num_steps; s++)

	mov	ecx, DWORD PTR _s$1$[ebp]
	add	DWORD PTR tv2915[ebp], 20		; 00000014H
	inc	ecx
	mov	DWORD PTR _s$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edx+52]
	jl	$LL22@perform_in
	movss	xmm6, DWORD PTR __real@3f000000
	movss	xmm7, DWORD PTR __real@46fffe00
	jmp	$LN21@perform_in
$LN68@perform_in:

; 3826 :             { // Copy irreversible samples with appropriate scaling
; 3827 :               int w, width=line->size.x;
; 3828 :               float range_expansion;
; 3829 :               if ((n+lev->region_min) & 1)

	mov	eax, DWORD PTR _lev$1$[ebp]
	mov	edi, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+16]
	add	eax, DWORD PTR _n$3$[ebp]
	test	al, 1

; 3830 :                 range_expansion = lev->high_range*0.5F;

	mov	eax, DWORD PTR _lev$1$[ebp]
	je	SHORT $LN70@perform_in
	movss	xmm2, DWORD PTR [eax+48]
	mulss	xmm2, xmm6

; 3831 :                       // MCT definition expects high-pass subbands to have a
; 3832 :                       // nominal range twice as large as the synthesized data
; 3833 :               else

	jmp	SHORT $LN71@perform_in
$LN70@perform_in:

; 3834 :                 range_expansion = lev->low_range;

	movss	xmm2, DWORD PTR [eax+44]
$LN71@perform_in:

; 3837 :                 (1<<line->bit_depth) / (range_expansion * (1<<dep->bit_depth));

	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR [esi+36]
	movd	xmm1, eax
	mov	eax, 1
	shl	eax, cl
	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	eax, DWORD PTR _line$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3837 :                 (1<<line->bit_depth) / (range_expansion * (1<<dep->bit_depth));

	cvtdq2ps xmm0, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	cl, BYTE PTR [eax+6]
	and	cl, 2
	mov	BYTE PTR tv2932[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3837 :                 (1<<line->bit_depth) / (range_expansion * (1<<dep->bit_depth));

	mulss	xmm0, xmm2
	divss	xmm1, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	jne	$LN72@perform_in
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _sp$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3838 :               if (line->line.get_buf32() != NULL)

	test	ecx, ecx
	je	$LN72@perform_in
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [esi+6], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3840 :                   float off = dep->irrev_offset;

	movss	xmm2, DWORD PTR [esi+44]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	je	SHORT $LN127@perform_in
	xor	eax, eax
	jmp	SHORT $LN229@perform_in
$LN127@perform_in:
	mov	eax, DWORD PTR [esi+8]
$LN229@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3843 :                   for (w=0; w < width; w++)

	xor	esi, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	DWORD PTR _dp$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3843 :                   for (w=0; w < width; w++)

	mov	DWORD PTR _w$1$[ebp], esi
	cmp	edi, 4
	jl	$LC192@perform_in
	mov	esi, DWORD PTR _sp$1$[ebp]
	add	ecx, 12					; 0000000cH
	sub	esi, DWORD PTR _dp$1$[ebp]
	add	eax, 4
	mov	DWORD PTR tv2912[ebp], esi
	lea	esi, DWORD PTR [edi-4]
	shr	esi, 2
	inc	esi
	lea	edx, DWORD PTR [esi*4]
	mov	DWORD PTR _w$1$[ebp], edx
	mov	edx, DWORD PTR tv2912[ebp]
$LL193@perform_in:

; 3844 :                     dp[w].fval = sp[w].fval*scale - off;

	movss	xmm0, DWORD PTR [ecx-12]
	mulss	xmm0, xmm1
	subss	xmm0, xmm2
	movss	DWORD PTR [eax-4], xmm0
	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, xmm1
	subss	xmm0, xmm2
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [ecx-4]
	mulss	xmm0, xmm1
	subss	xmm0, xmm2
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
	mulss	xmm0, xmm1
	subss	xmm0, xmm2
	movss	DWORD PTR [eax+8], xmm0
	add	eax, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL193@perform_in
	mov	edx, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR _sp$1$[ebp]
$LC192@perform_in:

; 3843 :                   for (w=0; w < width; w++)

	mov	eax, DWORD PTR _w$1$[ebp]
	cmp	eax, edi
	jge	$LN31@perform_in
	mov	esi, DWORD PTR _dp$1$[ebp]
	sub	ecx, esi
	sub	edi, DWORD PTR _w$1$[ebp]
	lea	eax, DWORD PTR [esi+eax*4]
	npad	3
$LC36@perform_in:

; 3844 :                     dp[w].fval = sp[w].fval*scale - off;

	movss	xmm0, DWORD PTR [eax+ecx]
	mulss	xmm0, xmm1
	subss	xmm0, xmm2
	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	sub	edi, 1
	jne	SHORT $LC36@perform_in

; 3845 :                 }
; 3846 :               else

	jmp	$LN31@perform_in
$LN72@perform_in:

; 3847 :                 { // Working with 16-bit samples
; 3848 :                   int downshift=0;
; 3849 :                   for (; scale < 16383.0F; scale*=2.0F, downshift++);

	movss	xmm0, DWORD PTR __real@467ffc00
	xor	eax, eax
	comiss	xmm0, xmm1
	mov	DWORD PTR _upshift$1$[ebp], eax
	jbe	SHORT $LN38@perform_in
	movss	xmm2, DWORD PTR __real@40000000
$LL39@perform_in:
	mulss	xmm1, xmm2
	inc	eax
	comiss	xmm0, xmm1
	ja	SHORT $LL39@perform_in
	mov	DWORD PTR _upshift$1$[ebp], eax
$LN38@perform_in:

; 3850 :                   for (; scale > 32767.0F; scale*=0.5F, downshift--);

	comiss	xmm1, xmm7
	jbe	SHORT $LN41@perform_in
	npad	6
$LL42@perform_in:
	mulss	xmm1, xmm6
	dec	eax
	comiss	xmm1, xmm7
	ja	SHORT $LL42@perform_in
	mov	DWORD PTR _upshift$1$[ebp], eax
$LN41@perform_in:
	xorps	xmm0, xmm0

; 3851 :                   kdu_int16 i_scale = (kdu_int16) floor(0.5+scale);

	sub	esp, 8
	cvtss2sd xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv3016[ebp], xmm0
	fld	QWORD PTR tv3016[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv3009[ebp]
	cvttsd2si eax, QWORD PTR tv3009[ebp]
	add	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	cmp	BYTE PTR tv2932[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3851 :                   kdu_int16 i_scale = (kdu_int16) floor(0.5+scale);

	movzx	eax, ax
	mov	DWORD PTR _i_scale$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	je	SHORT $LN131@perform_in
	mov	eax, DWORD PTR _line$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN230@perform_in
$LN131@perform_in:
	xor	eax, eax
$LN230@perform_in:
	test	BYTE PTR [esi+6], 2
	mov	DWORD PTR _sp$1$[ebp], eax
	je	SHORT $LN135@perform_in
	mov	esi, DWORD PTR [esi+8]
	jmp	SHORT $LN136@perform_in
$LN135@perform_in:
	xor	esi, esi
$LN136@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3855 :                     floor(0.5 + dep->irrev_offset*(1<<KDU_FIX_POINT));

	mov	ecx, DWORD PTR tv2941[ebp]
	sub	esp, 8
	mov	eax, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [eax+44]
	mulss	xmm0, DWORD PTR __real@46000000
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv3005[ebp], xmm0
	fld	QWORD PTR tv3005[ebp]
	fstp	QWORD PTR [esp]
	call	_floor

; 3856 :                   if (downshift >= 0)

	mov	ecx, DWORD PTR _upshift$1$[ebp]
	add	esp, 8
	fstp	QWORD PTR tv2999[ebp]
	cvttsd2si eax, QWORD PTR tv2999[ebp]
	mov	DWORD PTR _offset$2$[ebp], eax
	test	ecx, ecx
	js	SHORT $LN74@perform_in

; 3857 :                     {
; 3858 :                       offset = ((1<<downshift)>>1) - (offset << downshift);

	mov	edx, 1
	shl	eax, cl
	shl	edx, cl
	sar	edx, 1
	sub	edx, eax

; 3859 :                       for (w=0; w < width; w++)

	test	edi, edi
	jle	SHORT $LN221@perform_in
	mov	eax, DWORD PTR _i_scale$1$[ebp]
	cwde
	mov	DWORD PTR tv2940[ebp], eax
	mov	eax, DWORD PTR _sp$1$[ebp]
	sub	eax, esi
	mov	DWORD PTR _sp$1$[ebp], eax
$LL45@perform_in:

; 3860 :                         {
; 3861 :                           val = sp[w].ival;  val *= i_scale;

	movsx	eax, WORD PTR [eax+esi]
	lea	esi, DWORD PTR [esi+2]
	imul	eax, DWORD PTR tv2940[ebp]

; 3862 :                           val = (val+offset)>>downshift;

	add	eax, edx
	sar	eax, cl

; 3863 :                           dp[w].ival = (kdu_int16) val;

	mov	WORD PTR [esi-2], ax
	mov	eax, DWORD PTR _sp$1$[ebp]
	sub	edi, 1
	jne	SHORT $LL45@perform_in

; 3864 :                         }
; 3865 :                     }
; 3866 :                   else

	jmp	SHORT $LN221@perform_in
$LN74@perform_in:

; 3867 :                     { // Very unusual case
; 3868 :                       int upshift = -downshift;

	neg	ecx

; 3869 :                       for (w=0; w < width; w++)

	test	edi, edi
	jle	SHORT $LN221@perform_in
	mov	edx, DWORD PTR _sp$1$[ebp]
	sub	edx, esi
	mov	DWORD PTR _sp$1$[ebp], edx
$LL48@perform_in:

; 3870 :                         dp[w].ival = (kdu_int16)

	movsx	edx, WORD PTR [edx+esi]
	lea	esi, DWORD PTR [esi+2]
	mov	eax, DWORD PTR _i_scale$1$[ebp]
	cwde
	imul	edx, eax
	shl	dx, cl
	sub	dx, WORD PTR _offset$2$[ebp]
	mov	WORD PTR [esi-2], dx
	mov	edx, DWORD PTR _sp$1$[ebp]
	sub	edi, 1
	jne	SHORT $LL48@perform_in
$LN221@perform_in:
	mov	edx, DWORD PTR _this$1$[ebp]
$LN31@perform_in:

; 3807 :                                                   width,0);
; 3808 :                   else
; 3809 :                     assert(0);
; 3810 :                 }
; 3811 :             }
; 3812 :         }
; 3813 : 
; 3814 :       // Finish by transferring the subband data to the dependencies
; 3815 :       for (n=0; n < lev->region_size; n++)

	mov	esi, DWORD PTR _n$3$[ebp]
	mov	eax, DWORD PTR _lev$1$[ebp]
	inc	esi
	movss	xmm6, DWORD PTR __real@3f000000
	movss	xmm7, DWORD PTR __real@46fffe00
	mov	DWORD PTR _n$3$[ebp], esi
	cmp	esi, DWORD PTR [eax+20]
	jl	$LL33@perform_in
$LN2@perform_in:

; 3720 :   int n, lev_idx;
; 3721 :   for (lev_idx=num_levels-1; lev_idx >= 0; lev_idx--)

	mov	eax, DWORD PTR _lev_idx$1$[ebp]
	movss	xmm6, DWORD PTR __real@3f000000
	sub	eax, 1
	movss	xmm7, DWORD PTR __real@46fffe00
	mov	DWORD PTR _lev_idx$1$[ebp], eax
	jns	$LL4@perform_in
	pop	edi
	pop	esi
$LN3@perform_in:

; 3871 :                           (((sp[w].ival*i_scale)<<upshift) - offset);
; 3872 :                     }
; 3873 :                 }
; 3874 :             }
; 3875 :         }
; 3876 :     }
; 3877 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?perform_inverse@kd_multi_dwt_block@@UAEXXZ ENDP	; kd_multi_dwt_block::perform_inverse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?prepare_for_inversion@kd_multi_dwt_block@@UAEPBDXZ
_TEXT	SEGMENT
tv376 = -1						; size = 1
?prepare_for_inversion@kd_multi_dwt_block@@UAEPBDXZ PROC ; kd_multi_dwt_block::prepare_for_inversion, COMDAT
; _this$ = ecx

; 3366 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx

; 3367 :   assert(num_levels > 0);
; 3368 :   kd_multi_dwt_level *lev = levels + num_levels-1;
; 3369 :   int n;
; 3370 : 
; 3371 :   // Need only check that all components will be available.
; 3372 :   for (n=0; n < lev->canvas_size; n++)

	xor	edx, edx
	push	esi
	push	edi
	imul	edi, DWORD PTR [ebx+40], 52
	mov	eax, DWORD PTR [ebx+44]
	add	edi, eax
	mov	esi, DWORD PTR [edi-48]
	test	esi, esi
	jle	SHORT $LN3@prepare_fo

; 3373 :     {
; 3374 :       if ((lev->region_min != lev->canvas_min) ||
; 3375 :           (lev->region_size != lev->canvas_size) ||

	mov	ecx, DWORD PTR [edi-36]
	npad	2
$LL4@prepare_fo:
	cmp	ecx, DWORD PTR [edi-52]
	jne	SHORT $LN14@prepare_fo
	cmp	DWORD PTR [edi-32], esi
	jne	SHORT $LN14@prepare_fo
	mov	eax, DWORD PTR [edi-20]
	mov	eax, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR [eax+24], 1
	jl	SHORT $LN14@prepare_fo

; 3367 :   assert(num_levels > 0);
; 3368 :   kd_multi_dwt_level *lev = levels + num_levels-1;
; 3369 :   int n;
; 3370 : 
; 3371 :   // Need only check that all components will be available.
; 3372 :   for (n=0; n < lev->canvas_size; n++)

	inc	edx
	cmp	edx, esi
	jl	SHORT $LL4@prepare_fo
$LN3@prepare_fo:

; 3378 :                "output components can be computed by downstream "
; 3379 :                "transform blocks in the multi-component transform "
; 3380 :                "network, or by the application supplying them.";
; 3381 :     }
; 3382 :   outstanding_consumers = lev->canvas_size;
; 3383 : 
; 3384 :   for (n=0; n < num_dependencies; n++)

	mov	edx, DWORD PTR [ebx+16]
	xor	ecx, ecx
	mov	DWORD PTR [ebx+28], esi
	test	edx, edx
	jle	SHORT $LN22@prepare_fo

; 3385 :     if ((!is_reversible) && (dependencies[n] != NULL) &&

	mov	al, BYTE PTR [ebx+48]
	npad	6
$LL7@prepare_fo:
	test	al, al
	jne	SHORT $LN5@prepare_fo
	mov	eax, DWORD PTR [ebx+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN24@prepare_fo
	cmp	BYTE PTR [eax+32], 0
	jne	SHORT $LN15@prepare_fo
$LN24@prepare_fo:
	mov	al, BYTE PTR [ebx+48]
$LN5@prepare_fo:

; 3378 :                "output components can be computed by downstream "
; 3379 :                "transform blocks in the multi-component transform "
; 3380 :                "network, or by the application supplying them.";
; 3381 :     }
; 3382 :   outstanding_consumers = lev->canvas_size;
; 3383 : 
; 3384 :   for (n=0; n < num_dependencies; n++)

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL7@prepare_fo
$LN22@prepare_fo:
	pop	edi
	pop	esi

; 3388 :              "which operates on reversible codestream sample data.  "
; 3389 :              "While we allow such transforms to be processed during "
; 3390 :              "decompression, it is unreasonable to generate reversibly "
; 3391 :              "compressed component samples using an irreversible inverse "
; 3392 :              "multi-component transform during compression.  Kakadu will "
; 3393 :              "not invert this transform during compression.  This can "
; 3394 :              "prevent the compression process from proceeding if there are "
; 3395 :              "no other paths back from the MCT output components to the "
; 3396 :              "codestream components.";
; 3397 : 
; 3398 :   return NULL;

	xor	eax, eax
	pop	ebx

; 3399 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@prepare_fo:
	pop	edi
	pop	esi

; 3376 :           (lev->components[n]->num_consumers < 1))
; 3377 :         return "DWT transform block cannot be inverted unless all "

	mov	eax, OFFSET ??_C@_0MD@NOKJMJMF@DWT?5transform?5block?5cannot?5be?5in@
	pop	ebx

; 3399 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@prepare_fo:
	pop	edi
	pop	esi

; 3386 :         dependencies[n]->reversible)
; 3387 :       return "Encountered an irreversible DWT transform block "

	mov	eax, OFFSET ??_C@_0CBB@DNHOHNJD@Encountered?5an?5irreversible?5DWT?5@
	pop	ebx

; 3399 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?prepare_for_inversion@kd_multi_dwt_block@@UAEPBDXZ ENDP ; kd_multi_dwt_block::prepare_for_inversion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?perform_transform@kd_multi_dwt_block@@UAEXXZ
_TEXT	SEGMENT
_width$1$ = -52						; size = 4
tv3556 = -52						; size = 4
tv3533 = -52						; size = 4
tv3528 = -52						; size = 4
_sp$1$ = -52						; size = 4
_line$1$ = -52						; size = 4
_n$3$ = -52						; size = 4
tv3658 = -48						; size = 8
tv3652 = -48						; size = 8
_dst32$1$ = -44						; size = 4
_offset$1$ = -44					; size = 4
_w$2$ = -44						; size = 4
_w$1$ = -44						; size = 4
_src_idx$1$ = -40					; size = 4
_lev_idx$1$ = -36					; size = 4
_i_scale$1$ = -32					; size = 4
tv3521 = -32						; size = 4
_sp$1$ = -32						; size = 4
_sp$1$ = -32						; size = 4
_s$1$ = -28						; size = 4
_n$2$ = -24						; size = 4
_dst16$1$ = -20						; size = 4
_n$1$ = -20						; size = 4
_this$1$ = -16						; size = 4
_step$1$ = -12						; size = 4
_upshift$1$ = -12					; size = 4
_dp$1$ = -12						; size = 4
_lev$1$ = -8						; size = 4
tv3544 = -1						; size = 1
?perform_transform@kd_multi_dwt_block@@UAEXXZ PROC	; kd_multi_dwt_block::perform_transform, COMDAT
; _this$ = ecx

; 3534 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	ebx
	mov	ebx, ecx

; 3535 :   int n, lev_idx;
; 3536 :   for (lev_idx=0; lev_idx < num_levels; lev_idx++)

	xor	eax, eax
	mov	DWORD PTR _this$1$[ebp], ebx
	mov	DWORD PTR _lev_idx$1$[ebp], eax
	cmp	DWORD PTR [ebx+40], eax
	jle	$LN3@perform_tr

; 3655 :                         if (k < r_min)
; 3656 :                           k=(sym_extension)?(2*r_min-k):(r_min+((r_min^k)&1));

	movss	xmm2, DWORD PTR __real@3f000000
	movss	xmm3, DWORD PTR __real@46fffe00
	push	esi
	push	edi
	npad	4
$LL4@perform_tr:

; 3537 :     {
; 3538 :       kd_multi_dwt_level *lev = levels + lev_idx;
; 3539 : 
; 3540 :       // Start by transferring the subband data from the dependencies
; 3541 :       for (n=0; n < lev->region_size; n++)

	imul	edx, eax, 52
	xor	edi, edi
	mov	DWORD PTR _n$1$[ebp], edi
	add	edx, DWORD PTR [ebx+44]
	mov	DWORD PTR _lev$1$[ebp], edx
	cmp	DWORD PTR [edx+20], edi
	jle	$LN6@perform_tr
$LL7@perform_tr:

; 3542 :         {
; 3543 :           if (lev->dependencies[n] == NULL)

	mov	eax, DWORD PTR [edx+36]
	mov	edi, DWORD PTR [eax+edi*4]
	test	edi, edi
	je	$LN5@perform_tr

; 3544 :             continue;
; 3545 :           kd_multi_line *line = lev->components[n];

	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _n$1$[ebp]

; 3546 :           kd_multi_line *dep = *(lev->dependencies[n]);

	mov	edi, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _line$1$[ebp], edx

; 3547 :           if (dep == NULL)

	test	edi, edi
	jne	SHORT $LN56@perform_tr

; 3548 :             line->reset(0,0.0F);

	push	ecx
	mov	DWORD PTR [esp], edi
	mov	ecx, edx
	push	edi
	call	?reset@kd_multi_line@@QAEXHM@Z		; kd_multi_line::reset
	jmp	$LN254@perform_tr
$LN56@perform_tr:

; 3549 :           else if (is_reversible)

	cmp	BYTE PTR [ebx+48], 0
	je	SHORT $LN58@perform_tr

; 3550 :             line->copy(dep,0,0.0F);

	push	ecx
	mov	DWORD PTR [esp], 0
	mov	ecx, edx
	push	0
	push	edi
	call	?copy@kd_multi_line@@QAEXPAU1@HM@Z	; kd_multi_line::copy

; 3551 :           else

	jmp	$LN254@perform_tr
$LN58@perform_tr:

; 3552 :             { // Copy irreversible samples with appropriate scaling
; 3553 :               int w, width=line->size.x;
; 3554 :               float range_expansion;
; 3555 :               if ((n+lev->region_min) & 1)

	mov	eax, DWORD PTR _lev$1$[ebp]
	mov	esi, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax+16]
	add	eax, ecx
	test	al, 1

; 3556 :                 range_expansion = lev->high_range*0.5F;

	mov	eax, DWORD PTR _lev$1$[ebp]
	je	SHORT $LN60@perform_tr
	movss	xmm1, DWORD PTR [eax+48]
	mulss	xmm1, xmm2

; 3557 :                       // MCT definition expects high-pass subbands to have a
; 3558 :                       // nominal range twice as large as the synthesized data
; 3559 :               else

	jmp	SHORT $LN61@perform_tr
$LN60@perform_tr:

; 3560 :                 range_expansion = lev->low_range;

	movss	xmm1, DWORD PTR [eax+44]
$LN61@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	al, BYTE PTR [edx+6]
	and	al, 2
	mov	BYTE PTR tv3544[ebp], al
	jne	$LN62@perform_tr
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _dp$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3561 :               if (line->line.get_buf32() != NULL)

	test	eax, eax
	je	$LN62@perform_tr

; 3562 :                 { // Working with 32-bit samples
; 3563 :                   if (dep->reversible)

	cmp	BYTE PTR [edi+32], 0

; 3565 :                       float scale=range_expansion/(float)(1<<line->bit_depth);

	mov	eax, 1
	je	$LN64@perform_tr
	mov	ecx, DWORD PTR [edx+36]
	shl	eax, cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edi+6], 2
	movd	xmm0, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3565 :                       float scale=range_expansion/(float)(1<<line->bit_depth);

	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	je	SHORT $LN99@perform_tr
	xor	edi, edi
	jmp	SHORT $LN257@perform_tr
$LN99@perform_tr:
	mov	edi, DWORD PTR [edi+8]
$LN257@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3568 :                       for (w=0; w < width; w++)

	xor	edx, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	DWORD PTR _sp$1$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3568 :                       for (w=0; w < width; w++)

	cmp	esi, 4
	jl	SHORT $LC215@perform_tr
	mov	edx, DWORD PTR _dp$1$[ebp]
	lea	ecx, DWORD PTR [edi+12]
	mov	ebx, DWORD PTR _this$1$[ebp]
	sub	edi, edx
	mov	DWORD PTR tv3533[ebp], edi
	lea	eax, DWORD PTR [edx+4]
	lea	edx, DWORD PTR [esi-4]
	shr	edx, 2
	inc	edx
	lea	edi, DWORD PTR [edx*4]
	mov	DWORD PTR _w$1$[ebp], edi
	mov	edi, DWORD PTR tv3533[ebp]
	npad	2
$LL216@perform_tr:

; 3569 :                         dp[w].fval = sp[w].ival * scale;

	movd	xmm0, DWORD PTR [ecx-12]
	lea	eax, DWORD PTR [eax+16]
	lea	ecx, DWORD PTR [ecx+16]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax-20], xmm0
	movd	xmm0, DWORD PTR [edi+eax-16]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax-16], xmm0
	movd	xmm0, DWORD PTR [ecx-20]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax-12], xmm0
	movd	xmm0, DWORD PTR [ecx-16]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax-8], xmm0
	sub	edx, 1
	jne	SHORT $LL216@perform_tr
	mov	edi, DWORD PTR _sp$1$[ebp]
	mov	edx, DWORD PTR _w$1$[ebp]
$LC215@perform_tr:

; 3568 :                       for (w=0; w < width; w++)

	cmp	edx, esi
	jge	$LN255@perform_tr
	mov	ecx, DWORD PTR _dp$1$[ebp]
	sub	edi, ecx
	sub	esi, edx
	lea	eax, DWORD PTR [ecx+edx*4]
	npad	8
$LC10@perform_tr:

; 3569 :                         dp[w].fval = sp[w].ival * scale;

	movd	xmm0, DWORD PTR [eax+edi]
	lea	eax, DWORD PTR [eax+4]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax-4], xmm0
	sub	esi, 1
	jne	SHORT $LC10@perform_tr

; 3570 :                     }
; 3571 :                   else

	jmp	$LN255@perform_tr
$LN64@perform_tr:

; 3574 :                         (float)(1<<dep->bit_depth)/(float)(1<<line->bit_depth);

	mov	ecx, DWORD PTR [edi+36]
	shl	eax, cl
	mov	ecx, DWORD PTR [edx+36]
	movd	xmm2, eax
	mov	eax, 1
	shl	eax, cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edi+6], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3574 :                         (float)(1<<dep->bit_depth)/(float)(1<<line->bit_depth);

	cvtdq2ps xmm2, xmm2
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm2, xmm1
	divss	xmm2, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	je	SHORT $LN107@perform_tr
	xor	edi, edi
	jmp	SHORT $LN258@perform_tr
$LN107@perform_tr:
	mov	edi, DWORD PTR [edi+8]
$LN258@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3577 :                       for (w=0; w < width; w++)

	xor	edx, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	DWORD PTR _sp$1$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3577 :                       for (w=0; w < width; w++)

	cmp	esi, 4
	jl	SHORT $LC218@perform_tr
	mov	edx, DWORD PTR _dp$1$[ebp]
	lea	ecx, DWORD PTR [edi+12]
	mov	ebx, DWORD PTR _this$1$[ebp]
	sub	edi, edx
	mov	DWORD PTR tv3528[ebp], edi
	lea	eax, DWORD PTR [edx+4]
	lea	edx, DWORD PTR [esi-4]
	shr	edx, 2
	inc	edx
	lea	edi, DWORD PTR [edx*4]
	mov	DWORD PTR _w$2$[ebp], edi
	mov	edi, DWORD PTR tv3528[ebp]
	npad	1
$LL219@perform_tr:

; 3578 :                         dp[w].fval = sp[w].fval * scale;

	movss	xmm0, DWORD PTR [ecx-12]
	lea	eax, DWORD PTR [eax+16]
	mulss	xmm0, xmm2
	lea	ecx, DWORD PTR [ecx+16]
	movss	DWORD PTR [eax-20], xmm0
	movss	xmm0, DWORD PTR [edi+eax-16]
	mulss	xmm0, xmm2
	movss	DWORD PTR [eax-16], xmm0
	movss	xmm0, DWORD PTR [ecx-20]
	mulss	xmm0, xmm2
	movss	DWORD PTR [eax-12], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx-16]
	movss	DWORD PTR [eax-8], xmm0
	sub	edx, 1
	jne	SHORT $LL219@perform_tr
	mov	edi, DWORD PTR _sp$1$[ebp]
	mov	edx, DWORD PTR _w$2$[ebp]
$LC218@perform_tr:

; 3577 :                       for (w=0; w < width; w++)

	cmp	edx, esi
	jge	$LN253@perform_tr
	mov	ecx, DWORD PTR _dp$1$[ebp]
	sub	edi, ecx
	sub	esi, edx
	lea	eax, DWORD PTR [ecx+edx*4]
	npad	5
$LC13@perform_tr:

; 3578 :                         dp[w].fval = sp[w].fval * scale;

	movss	xmm0, DWORD PTR [eax+edi]
	lea	eax, DWORD PTR [eax+4]
	mulss	xmm0, xmm2
	movss	DWORD PTR [eax-4], xmm0
	sub	esi, 1
	jne	SHORT $LC13@perform_tr

; 3579 :                     }
; 3580 :                 }
; 3581 :               else

	jmp	$LN253@perform_tr
$LN62@perform_tr:

; 3582 :                 { // Working with 16-bit samples
; 3583 :                   float scale = range_expansion / (float)(1<<line->bit_depth);

	mov	ecx, DWORD PTR [edx+36]
	mov	eax, 1
	shl	eax, cl

; 3584 :                   if (dep->reversible)

	cmp	BYTE PTR [edi+32], 0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	je	SHORT $LN66@perform_tr

; 3585 :                     scale *= (1<<KDU_FIX_POINT);

	mulss	xmm1, DWORD PTR __real@46000000

; 3586 :                   else

	jmp	SHORT $LN67@perform_tr
$LN66@perform_tr:

; 3587 :                     scale *= (float)(1<<dep->bit_depth);

	mov	ecx, DWORD PTR [edi+36]
	mov	eax, 1
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm1, xmm0
$LN67@perform_tr:

; 3588 :                   int downshift=0;
; 3589 :                   for (; scale < 16383.0F; scale*=2.0F, downshift++);

	movss	xmm0, DWORD PTR __real@467ffc00
	xor	eax, eax
	comiss	xmm0, xmm1
	mov	DWORD PTR _upshift$1$[ebp], eax
	jbe	SHORT $LN15@perform_tr
	npad	9
$LL16@perform_tr:
	mulss	xmm1, DWORD PTR __real@40000000
	inc	eax
	comiss	xmm0, xmm1
	ja	SHORT $LL16@perform_tr
	mov	DWORD PTR _upshift$1$[ebp], eax
$LN15@perform_tr:

; 3590 :                   for (; scale > 32767.0F; scale*=0.5F, downshift--);

	comiss	xmm1, xmm3
	jbe	SHORT $LN18@perform_tr
$LL19@perform_tr:
	mulss	xmm1, xmm2
	dec	eax
	comiss	xmm1, xmm3
	ja	SHORT $LL19@perform_tr
	mov	DWORD PTR _upshift$1$[ebp], eax
$LN18@perform_tr:
	xorps	xmm0, xmm0

; 3591 :                   kdu_int16 i_scale = (kdu_int16) floor(0.5+scale);

	sub	esp, 8
	cvtss2sd xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv3658[ebp], xmm0
	fld	QWORD PTR tv3658[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv3652[ebp]
	cvttsd2si eax, QWORD PTR tv3652[ebp]
	add	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [edi+6], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3591 :                   kdu_int16 i_scale = (kdu_int16) floor(0.5+scale);

	movzx	eax, ax
	mov	DWORD PTR _i_scale$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	je	SHORT $LN115@perform_tr
	mov	edx, DWORD PTR [edi+8]
	jmp	SHORT $LN116@perform_tr
$LN115@perform_tr:
	xor	edx, edx
$LN116@perform_tr:
	cmp	BYTE PTR tv3544[ebp], 0
	je	SHORT $LN119@perform_tr
	mov	edi, DWORD PTR _line$1$[ebp]
	mov	edi, DWORD PTR [edi+8]
	jmp	SHORT $LN120@perform_tr
$LN119@perform_tr:
	xor	edi, edi
$LN120@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3594 :                   if (downshift >= 0)

	mov	ecx, DWORD PTR _upshift$1$[ebp]
	test	ecx, ecx
	js	SHORT $LN68@perform_tr

; 3595 :                     {
; 3596 :                       int val, offset = (1<<downshift)>>1;

	mov	eax, 1
	shl	eax, cl
	sar	eax, 1
	mov	DWORD PTR _offset$1$[ebp], eax

; 3597 :                       for (w=0; w < width; w++)

	test	esi, esi
	jle	SHORT $LN254@perform_tr
	mov	eax, DWORD PTR _i_scale$1$[ebp]
	sub	edx, edi
	cwde
	mov	DWORD PTR tv3556[ebp], eax
$LL22@perform_tr:

; 3598 :                         {
; 3599 :                           val = sp[w].ival;  val *= i_scale;

	movsx	eax, WORD PTR [edx+edi]
	lea	edi, DWORD PTR [edi+2]
	imul	eax, DWORD PTR tv3556[ebp]

; 3600 :                           val = (val+offset)>>downshift;

	add	eax, DWORD PTR _offset$1$[ebp]
	sar	eax, cl

; 3601 :                           dp[w].ival = (kdu_int16) val;

	mov	WORD PTR [edi-2], ax
	sub	esi, 1
	jne	SHORT $LL22@perform_tr

; 3602 :                         }
; 3603 :                     }
; 3604 :                   else

	jmp	SHORT $LN254@perform_tr
$LN68@perform_tr:

; 3605 :                     { // Very unusual case
; 3606 :                       int upshift = -downshift;

	neg	ecx

; 3607 :                       for (w=0; w < width; w++)

	test	esi, esi
	jle	SHORT $LN254@perform_tr
	mov	ebx, DWORD PTR _i_scale$1$[ebp]
	sub	edx, edi
	mov	DWORD PTR _sp$1$[ebp], edx
	npad	4
$LL25@perform_tr:

; 3608 :                         dp[w].ival = (kdu_int16)

	movsx	edx, WORD PTR [edi+edx]
	lea	edi, DWORD PTR [edi+2]
	movsx	eax, bx
	imul	edx, eax
	shl	dx, cl
	mov	WORD PTR [edi-2], dx
	mov	edx, DWORD PTR _sp$1$[ebp]
	sub	esi, 1
	jne	SHORT $LL25@perform_tr
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN254@perform_tr:
	movss	xmm3, DWORD PTR __real@46fffe00
$LN253@perform_tr:
	movss	xmm2, DWORD PTR __real@3f000000
$LN255@perform_tr:
	mov	edx, DWORD PTR _lev$1$[ebp]
$LN5@perform_tr:

; 3537 :     {
; 3538 :       kd_multi_dwt_level *lev = levels + lev_idx;
; 3539 : 
; 3540 :       // Start by transferring the subband data from the dependencies
; 3541 :       for (n=0; n < lev->region_size; n++)

	mov	edi, DWORD PTR _n$1$[ebp]
	inc	edi
	mov	DWORD PTR _n$1$[ebp], edi
	cmp	edi, DWORD PTR [edx+20]
	jl	$LL7@perform_tr
$LN6@perform_tr:

; 3609 :                         ((sp[w].ival*i_scale)<<upshift);
; 3610 :                     }
; 3611 :                 }
; 3612 :             }
; 3613 :         }
; 3614 : 
; 3615 :       // Now for subband synthesis in this level
; 3616 :       if (lev->canvas_size == 1)

	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN70@perform_tr

; 3617 :         { // DWT synthesis consists of simply copying the single output line
; 3618 :           // from the corresponding subband line, possibly with a scaling
; 3619 :           // factor of 2.  Of course, the transform is performed in-place here,
; 3620 :           // so no actual copying is required.
; 3621 :           if ((lev->region_min & 1) && is_reversible)

	test	BYTE PTR [edx+16], 1
	je	$LN44@perform_tr
	cmp	BYTE PTR [ebx+48], 0
	je	$LN44@perform_tr

; 3622 :             { // Halve the size of reversible samples
; 3623 :               kd_multi_line *line = lev->components[0];

	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	mov	al, BYTE PTR [ecx+6]
	and	al, 2
	je	SHORT $LN123@perform_tr
	mov	edx, DWORD PTR [ecx+8]
	jmp	SHORT $LN124@perform_tr
$LN123@perform_tr:
	xor	edx, edx
$LN124@perform_tr:

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	al, al
	je	SHORT $LN127@perform_tr
	xor	esi, esi
	jmp	SHORT $LN128@perform_tr
$LN127@perform_tr:
	mov	esi, DWORD PTR [ecx+8]
$LN128@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3626 :               int w, width=line->size.x;

	mov	ecx, DWORD PTR [ecx+16]

; 3627 :               if (sp16 != NULL)
; 3628 :                 for (w=0; w < width; w++)

	xor	eax, eax
	test	edx, edx
	je	SHORT $LN73@perform_tr
	test	ecx, ecx
	jle	$LN44@perform_tr
	npad	5
$LL28@perform_tr:

; 3629 :                   sp16[w].ival >>= 1;

	sar	WORD PTR [edx+eax*2], 1
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL28@perform_tr

; 3630 :               else

	jmp	$LN44@perform_tr
$LN73@perform_tr:

; 3631 :                 for (w=0; w < width; w++)

	test	ecx, ecx
	jle	$LN44@perform_tr
$LL31@perform_tr:

; 3632 :                   sp32[w].ival >>= 1;

	sar	DWORD PTR [esi+eax*4], 1
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL31@perform_tr

; 3633 :             }
; 3634 :           assert(lev->normalizing_shift == 0);
; 3635 :         }
; 3636 :       else

	jmp	$LN44@perform_tr
$LN70@perform_tr:

; 3637 :         {
; 3638 :           int r_min = lev->region_min;

	mov	esi, DWORD PTR [edx+16]

; 3639 :           int r_max = r_min + lev->region_size-1;

	mov	eax, DWORD PTR [edx+20]

; 3640 :           for (int s=num_steps-1; s >= 0; s--)

	mov	ecx, DWORD PTR [ebx+52]
	lea	edi, DWORD PTR [esi-1]
	add	edi, eax
	sub	ecx, 1
	mov	DWORD PTR _s$1$[ebp], ecx
	js	$LN33@perform_tr

; 3637 :         {
; 3638 :           int r_min = lev->region_min;

	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 2
	mov	DWORD PTR tv3521[ebp], ecx
$LL34@perform_tr:

; 3641 :             {
; 3642 :               kd_lifting_step *step = steps + s;

	mov	ecx, DWORD PTR [ebx+56]
	add	ecx, DWORD PTR tv3521[ebp]
	mov	DWORD PTR _step$1$[ebp], ecx

; 3643 :               int parity = 1-(s&1); // Parity of the lines being updated here

	or	ecx, -1
	sub	ecx, DWORD PTR _s$1$[ebp]

; 3644 :               for (n=(lev->region_min^parity)&1; n < lev->region_size; n+=2)

	xor	ecx, DWORD PTR [edx+16]
	and	ecx, 1
	mov	DWORD PTR _n$2$[ebp], ecx
	cmp	ecx, eax
	jge	$LN32@perform_tr
$LL37@perform_tr:

; 3645 :                 {
; 3646 :                   kd_multi_line *line = lev->components[n];

	mov	eax, DWORD PTR [edx+32]
	mov	eax, DWORD PTR [eax+ecx*4]

; 3647 :                   int width = line->size.x;

	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _width$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	mov	cl, BYTE PTR [eax+6]
	and	cl, 2
	je	SHORT $LN131@perform_tr
	mov	ebx, DWORD PTR [eax+8]
	mov	DWORD PTR _dst16$1$[ebp], ebx
	mov	ebx, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LN132@perform_tr
$LN131@perform_tr:
	mov	DWORD PTR _dst16$1$[ebp], 0
$LN132@perform_tr:

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	cl, cl
	je	SHORT $LN135@perform_tr
	xor	eax, eax
	jmp	SHORT $LN260@perform_tr
$LN135@perform_tr:
	mov	eax, DWORD PTR [eax+8]
$LN260@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3650 :                   int src_idx = ((n+lev->region_min)^1) + 2*step->support_min;

	mov	ecx, DWORD PTR [edx+16]

; 3651 :                   for (int i=0; i < step->support_length; i++, src_idx+=2)

	xor	edx, edx
	add	ecx, DWORD PTR _n$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	DWORD PTR _dst32$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3650 :                   int src_idx = ((n+lev->region_min)^1) + 2*step->support_min;

	xor	ecx, 1
	mov	eax, DWORD PTR _step$1$[ebp]
	movsx	eax, WORD PTR [eax+4]
	lea	ecx, DWORD PTR [ecx+eax*2]

; 3651 :                   for (int i=0; i < step->support_length; i++, src_idx+=2)

	mov	eax, DWORD PTR _step$1$[ebp]
	mov	DWORD PTR _src_idx$1$[ebp], ecx
	cmp	BYTE PTR [eax+1], dl
	jbe	SHORT $LN251@perform_tr
	npad	6
$LL40@perform_tr:

; 3652 :                     { // Fill in the source buffers
; 3653 :                       int k = src_idx;
; 3654 :                       while ((k < r_min) || (k > r_max))

	cmp	ecx, esi
	jl	SHORT $LN245@perform_tr
	cmp	ecx, edi
	jle	SHORT $LN42@perform_tr

; 3658 :                           k=(sym_extension)?(2*r_max-k):(r_max-((r_max^k)&1));

	cmp	BYTE PTR [ebx+50], 0
	je	SHORT $LN91@perform_tr
	lea	eax, DWORD PTR [edi+edi]
	sub	eax, ecx
	mov	ecx, eax
	jmp	SHORT $LL40@perform_tr
$LN91@perform_tr:
	mov	eax, ecx
	mov	ecx, edi
	xor	eax, edi
	and	eax, 1
	sub	ecx, eax
	jmp	SHORT $LL40@perform_tr
$LN245@perform_tr:

; 3655 :                         if (k < r_min)
; 3656 :                           k=(sym_extension)?(2*r_min-k):(r_min+((r_min^k)&1));

	cmp	BYTE PTR [ebx+50], 0
	je	SHORT $LN89@perform_tr
	lea	eax, DWORD PTR [esi+esi]
	sub	eax, ecx
	mov	ecx, eax
	jmp	SHORT $LL40@perform_tr
$LN89@perform_tr:
	xor	ecx, esi
	and	ecx, 1
	add	ecx, esi

; 3657 :                         else

	jmp	SHORT $LL40@perform_tr
$LN42@perform_tr:

; 3659 :                       k -= lev->region_min;

	mov	eax, DWORD PTR _lev$1$[ebp]
	sub	ecx, DWORD PTR [eax+16]

; 3660 :                       assert((k >= 0) && (k < lev->region_size));
; 3661 :                       if (dst16 != NULL)

	cmp	DWORD PTR _dst16$1$[ebp], 0

; 3662 :                         src_bufs16[i] = lev->components[k]->line.get_buf16();

	mov	eax, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax+ecx*4]
	je	SHORT $LN78@perform_tr
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN139@perform_tr
$LN143@perform_tr:

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	ecx, DWORD PTR [ecx+8]
$LN144@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3664 :                         src_bufs32[i] = lev->components[k]->line.get_buf32();

	mov	eax, DWORD PTR [ebx+76]
	mov	DWORD PTR [eax+edx*4], ecx
	inc	edx
	mov	eax, DWORD PTR _step$1$[ebp]
	mov	ecx, DWORD PTR _src_idx$1$[ebp]
	add	ecx, 2
	mov	DWORD PTR _src_idx$1$[ebp], ecx
	movzx	eax, BYTE PTR [eax+1]
	cmp	edx, eax
	jl	SHORT $LL40@perform_tr
$LN251@perform_tr:

; 3665 :                     }
; 3666 :                   if (dst16 != NULL)

	mov	eax, DWORD PTR _dst16$1$[ebp]
	test	eax, eax
	je	SHORT $LN80@perform_tr

; 3667 :                     perform_synthesis_lifting_step(step,src_bufs16,dst16,dst16,

	push	0
	push	DWORD PTR _width$1$[ebp]
	push	eax
	push	eax
	push	DWORD PTR [ebx+76]
	push	DWORD PTR _step$1$[ebp]
	call	?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z ; perform_synthesis_lifting_step
	jmp	SHORT $LN261@perform_tr
$LN78@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN143@perform_tr
$LN139@perform_tr:
	xor	ecx, ecx
	jmp	SHORT $LN144@perform_tr
$LN80@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3669 :                   else if (dst32 != NULL)

	mov	eax, DWORD PTR _dst32$1$[ebp]
	test	eax, eax
	je	SHORT $LN35@perform_tr

; 3670 :                     perform_synthesis_lifting_step(step,src_bufs32,dst32,dst32,

	push	0
	push	DWORD PTR _width$1$[ebp]
	push	eax
	push	eax
	push	DWORD PTR [ebx+76]
	push	DWORD PTR _step$1$[ebp]
	call	?perform_synthesis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z ; perform_synthesis_lifting_step
$LN261@perform_tr:
	add	esp, 24					; 00000018H
$LN35@perform_tr:

; 3644 :               for (n=(lev->region_min^parity)&1; n < lev->region_size; n+=2)

	mov	edx, DWORD PTR _lev$1$[ebp]
	mov	ecx, DWORD PTR _n$2$[ebp]
	add	ecx, 2
	mov	DWORD PTR _n$2$[ebp], ecx
	mov	eax, DWORD PTR [edx+20]
	cmp	ecx, eax
	jl	$LL37@perform_tr
$LN32@perform_tr:

; 3640 :           for (int s=num_steps-1; s >= 0; s--)

	mov	ecx, DWORD PTR _s$1$[ebp]
	sub	DWORD PTR tv3521[ebp], 20		; 00000014H
	dec	ecx
	mov	DWORD PTR _s$1$[ebp], ecx
	test	ecx, ecx
	jns	$LL34@perform_tr
$LN33@perform_tr:

; 3671 :                                                    width,0);
; 3672 :                   else
; 3673 :                     assert(0);
; 3674 :                 }
; 3675 :             }
; 3676 :           
; 3677 :           if ((!is_reversible) && (lev->normalizing_shift > 0))

	cmp	BYTE PTR [ebx+48], 0
	jne	$LN44@perform_tr
	cmp	DWORD PTR [edx+40], 0
	jle	$LN44@perform_tr

; 3678 :             { // Need to upshift the synthesized samples before moving to the
; 3679 :               // next level.
; 3680 :               for (n=0; n < lev->region_size; n++)

	cmp	DWORD PTR [edx+20], 0
	mov	DWORD PTR _n$3$[ebp], 0
	jle	$LN44@perform_tr
	mov	ebx, DWORD PTR _n$3$[ebp]
$LL45@perform_tr:

; 3681 :                 {
; 3682 :                   kd_multi_line *line = lev->components[n];

	mov	eax, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [eax+ebx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	al, BYTE PTR [edx+6]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3683 :                   int w, width=line->size.x;

	mov	esi, DWORD PTR [edx+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	and	al, 2
	jne	$LN85@perform_tr
	mov	edi, DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3684 :                   if (line->line.get_buf32() != NULL)

	test	edi, edi
	je	$LN85@perform_tr

; 3685 :                     {
; 3686 :                       kdu_sample32 *sp = line->line.get_buf32();
; 3687 :                       float scale = (float)(1<<lev->normalizing_shift);

	mov	ecx, DWORD PTR _lev$1$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [ecx+40]
	shl	eax, cl

; 3688 :                       for (w=0; w < width; w++)

	xor	ecx, ecx
	movd	xmm4, eax
	cvtdq2ps xmm4, xmm4
	shufps	xmm4, xmm4, 0
	movaps	xmm5, xmm4
	shufps	xmm5, xmm5, 0
	test	esi, esi
	jle	$LN43@perform_tr
	cmp	esi, 8
	jb	$LN193@perform_tr
	mov	eax, esi
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN256@perform_tr
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN256@perform_tr:
	mov	edx, esi
	sub	edx, eax
	lea	eax, DWORD PTR [edi+8]
	npad	5
$LL48@perform_tr:

; 3689 :                         sp[w].fval *= scale;

	movss	xmm2, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [eax+32]
	movss	xmm0, DWORD PTR [eax-32]
	add	ecx, 8
	movss	xmm1, DWORD PTR [eax-36]
	movss	xmm3, DWORD PTR [eax-40]
	unpcklps xmm3, xmm0
	unpcklps xmm1, xmm2
	unpcklps xmm3, xmm1
	mulps	xmm3, xmm5
	movss	DWORD PTR [eax-40], xmm3
	shufps	xmm3, xmm3, 229				; 000000e5H
	movss	DWORD PTR [eax-36], xmm3
	movss	xmm1, DWORD PTR [eax-20]
	unpckhps xmm3, xmm3
	movss	DWORD PTR [eax-32], xmm3
	movss	xmm0, DWORD PTR [eax-16]
	unpckhps xmm3, xmm3
	movss	DWORD PTR [eax-28], xmm3
	movss	xmm2, DWORD PTR [eax-12]
	movss	xmm3, DWORD PTR [eax-24]
	unpcklps xmm3, xmm0
	unpcklps xmm1, xmm2
	unpcklps xmm3, xmm1
	mulps	xmm3, xmm5
	movss	DWORD PTR [eax-24], xmm3
	shufps	xmm3, xmm3, 229				; 000000e5H
	movss	DWORD PTR [eax-20], xmm3
	unpckhps xmm3, xmm3
	movss	DWORD PTR [eax-16], xmm3
	unpckhps xmm3, xmm3
	movss	DWORD PTR [eax-12], xmm3
	cmp	ecx, edx
	jl	$LL48@perform_tr
$LN193@perform_tr:
	cmp	ecx, esi
	jge	$LN43@perform_tr
	mov	eax, esi
	sub	eax, ecx

; 3688 :                       for (w=0; w < width; w++)

	cmp	eax, 4
	jl	SHORT $LC221@perform_tr
	mov	edx, esi
	lea	eax, DWORD PTR [ecx+2]
	sub	edx, ecx
	lea	eax, DWORD PTR [edi+eax*4]
	sub	edx, 4
	shr	edx, 2
	inc	edx
	lea	ecx, DWORD PTR [ecx+edx*4]
	npad	1
$LL222@perform_tr:

; 3689 :                         sp[w].fval *= scale;

	lea	eax, DWORD PTR [eax+16]
	movups	xmm0, XMMWORD PTR [eax-24]
	mulps	xmm0, xmm4
	movups	XMMWORD PTR [eax-24], xmm0
	sub	edx, 1
	jne	SHORT $LL222@perform_tr
$LC221@perform_tr:

; 3688 :                       for (w=0; w < width; w++)

	cmp	ecx, esi
	jge	SHORT $LN43@perform_tr
	npad	9
$LC192@perform_tr:

; 3689 :                         sp[w].fval *= scale;

	movss	xmm0, DWORD PTR [edi+ecx*4]
	mulss	xmm0, xmm4
	movss	DWORD PTR [edi+ecx*4], xmm0
	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LC192@perform_tr

; 3690 :                     }
; 3691 :                   else

	jmp	SHORT $LN43@perform_tr
$LN85@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	al, al
	je	SHORT $LN155@perform_tr
	mov	edx, DWORD PTR [edx+8]
	jmp	SHORT $LN156@perform_tr
$LN155@perform_tr:
	xor	edx, edx
$LN156@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3694 :                       int upshift = lev->normalizing_shift;

	mov	eax, DWORD PTR _lev$1$[ebp]
	mov	edi, DWORD PTR [eax+40]

; 3695 :                       for (w=0; w < width; w++)

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN43@perform_tr
	npad	4
$LL51@perform_tr:

; 3696 :                         sp[w].ival <<= upshift;

	mov	cx, di
	shl	WORD PTR [edx+eax*2], cl
	inc	eax
	cmp	eax, esi
	jl	SHORT $LL51@perform_tr
$LN43@perform_tr:

; 3678 :             { // Need to upshift the synthesized samples before moving to the
; 3679 :               // next level.
; 3680 :               for (n=0; n < lev->region_size; n++)

	mov	edx, DWORD PTR _lev$1$[ebp]
	inc	ebx
	cmp	ebx, DWORD PTR [edx+20]
	jl	$LL45@perform_tr
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN44@perform_tr:

; 3697 :                     }
; 3698 :                 }
; 3699 :             }
; 3700 :         }
; 3701 : 
; 3702 :       // Finally, apply any required offsets to the synthesized results
; 3703 :       if (lev_idx < (num_levels-1))

	mov	eax, DWORD PTR [ebx+40]
	dec	eax
	cmp	DWORD PTR _lev_idx$1$[ebp], eax
	jl	SHORT $LN2@perform_tr

; 3704 :         continue; // Final results appear only at the highest DWT level
; 3705 :       for (n=0; n < lev->region_size; n++)

	mov	edi, DWORD PTR _lev$1$[ebp]
	xor	esi, esi
	cmp	DWORD PTR [edi+20], esi
	jle	SHORT $LN2@perform_tr
	npad	1
$LL54@perform_tr:

; 3706 :         {
; 3707 :           kd_multi_line *line = lev->components[n];

	mov	eax, DWORD PTR [edi+32]
	mov	ecx, DWORD PTR [eax+esi*4]

; 3708 :           line->apply_offset(line->rev_offset,line->irrev_offset);

	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR [ecx+40]
	call	?apply_offset@kd_multi_line@@QAEXHM@Z	; kd_multi_line::apply_offset
	inc	esi
	cmp	esi, DWORD PTR [edi+20]
	jl	SHORT $LL54@perform_tr
$LN2@perform_tr:

; 3535 :   int n, lev_idx;
; 3536 :   for (lev_idx=0; lev_idx < num_levels; lev_idx++)

	mov	eax, DWORD PTR _lev_idx$1$[ebp]
	movss	xmm2, DWORD PTR __real@3f000000
	inc	eax
	movss	xmm3, DWORD PTR __real@46fffe00
	mov	DWORD PTR _lev_idx$1$[ebp], eax
	cmp	eax, DWORD PTR [ebx+40]
	jl	$LL4@perform_tr
	pop	edi
	pop	esi
$LN3@perform_tr:
	pop	ebx

; 3709 :         }
; 3710 :     }
; 3711 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?perform_transform@kd_multi_dwt_block@@UAEXXZ ENDP	; kd_multi_dwt_block::perform_transform
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?propagate_bit_depths@kd_multi_dwt_block@@UAE_N_N0@Z
_TEXT	SEGMENT
_this$1$ = -12						; size = 4
$T1 = -8						; size = 4
_any_change$1$ = -1					; size = 1
tv541 = 8						; size = 4
_need_input_bit_depth$ = 8				; size = 1
_need_output_bit_depth$ = 12				; size = 1
?propagate_bit_depths@kd_multi_dwt_block@@UAE_N_N0@Z PROC ; kd_multi_dwt_block::propagate_bit_depths, COMDAT
; _this$ = ecx

; 3461 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3462 :   if (!(need_input_bit_depth || need_output_bit_depth))

	mov	al, BYTE PTR _need_input_bit_depth$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi
	test	al, al
	jne	SHORT $LN17@propagate_
	cmp	BYTE PTR _need_output_bit_depth$[ebp], al
	jne	SHORT $LN17@propagate_
	pop	esi

; 3526 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN17@propagate_:
	push	ebx
	mov	ebx, DWORD PTR [esi+8]

; 3463 :     return false;
; 3464 : 
; 3465 :   bool any_change = false;
; 3466 : 
; 3467 :   int n, out_depth = 0;
; 3468 :   for (n=0; n < num_components; n++)

	xor	ecx, ecx
	push	edi
	xor	edi, edi
	mov	BYTE PTR _any_change$1$[ebp], 0
	mov	DWORD PTR $T1[ebp], ebx
	test	ebx, ebx
	jle	SHORT $LN57@propagate_

; 3469 :     if (components[n].bit_depth != 0)

	mov	edx, DWORD PTR [esi+12]
	add	edx, 36					; 00000024H
	npad	7
$LL4@propagate_:
	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN2@propagate_

; 3470 :       {
; 3471 :         if ((out_depth != 0) && (out_depth != components[n].bit_depth))

	test	edi, edi
	je	SHORT $LN19@propagate_
	cmp	edi, eax
	jne	SHORT $LN64@propagate_
$LN19@propagate_:

; 3472 :           return false;
; 3473 :         out_depth = components[n].bit_depth;

	mov	edi, eax
$LN2@propagate_:

; 3463 :     return false;
; 3464 : 
; 3465 :   bool any_change = false;
; 3466 : 
; 3467 :   int n, out_depth = 0;
; 3468 :   for (n=0; n < num_components; n++)

	inc	ecx
	add	edx, 60					; 0000003cH
	cmp	ecx, ebx
	jl	SHORT $LL4@propagate_

; 3474 :       }
; 3475 : 
; 3476 :   if (out_depth == 0)

	test	edi, edi
	jne	SHORT $LN28@propagate_
	mov	al, BYTE PTR _need_input_bit_depth$[ebp]
$LN57@propagate_:

; 3477 :     {
; 3478 :       if (need_input_bit_depth)

	test	al, al
	jne	SHORT $LN64@propagate_

; 3479 :         return false;
; 3480 :       int max_ll_depth=0, min_ll_depth=0;
; 3481 :       for (n=0; n < levels->region_size; n++)

	mov	eax, DWORD PTR [esi+44]
	xor	edx, edx
	xor	edi, edi
	xor	ecx, ecx
	mov	esi, DWORD PTR [eax+20]
	test	esi, esi
	jle	SHORT $LN29@propagate_

; 3482 :         {
; 3483 :           if (levels->dependencies[n] == NULL)

	mov	ebx, DWORD PTR [eax+36]
$LL7@propagate_:
	mov	eax, DWORD PTR [ebx+ecx*4]
	test	eax, eax
	je	SHORT $LN5@propagate_

; 3484 :             continue;
; 3485 :           kd_multi_line *dep = *(levels->dependencies[n]);

	mov	eax, DWORD PTR [eax]

; 3486 :           if ((dep != NULL) && (dep->bit_depth != 0))

	test	eax, eax
	je	SHORT $LN5@propagate_
	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	je	SHORT $LN5@propagate_

; 3487 :             {
; 3488 :               if (dep->bit_depth > max_ll_depth)

	cmp	eax, edx
	cmovg	edx, eax

; 3489 :                 max_ll_depth = dep->bit_depth;
; 3490 :               if ((min_ll_depth==0) || (dep->bit_depth < min_ll_depth))

	test	edi, edi
	je	SHORT $LN26@propagate_
	cmp	eax, edi
	jge	SHORT $LN5@propagate_
$LN26@propagate_:

; 3491 :                 min_ll_depth = dep->bit_depth;

	mov	edi, eax
$LN5@propagate_:

; 3479 :         return false;
; 3480 :       int max_ll_depth=0, min_ll_depth=0;
; 3481 :       for (n=0; n < levels->region_size; n++)

	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LL7@propagate_

; 3492 :             }
; 3493 :         }
; 3494 :       if ((min_ll_depth > 0) || (max_ll_depth == min_ll_depth))

	test	edi, edi
	jg	SHORT $LN61@propagate_
	cmp	edx, edi
	je	SHORT $LN61@propagate_
$LN64@propagate_:
	pop	edi
	pop	ebx

; 3495 :         out_depth = min_ll_depth;
; 3496 :       else
; 3497 :         return false;

	xor	al, al
	pop	esi

; 3526 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN61@propagate_:
	mov	ebx, DWORD PTR $T1[ebp]
$LN29@propagate_:
	mov	esi, DWORD PTR _this$1$[ebp]
$LN28@propagate_:

; 3498 :     }
; 3499 : 
; 3500 :   if (need_output_bit_depth)

	cmp	BYTE PTR _need_output_bit_depth$[ebp], 0
	je	SHORT $LN9@propagate_

; 3501 :     for (n=0; n < num_components; n++)

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN9@propagate_
	xor	edx, edx
$LL10@propagate_:

; 3502 :       if (components[n].bit_depth == 0)

	mov	eax, DWORD PTR [esi+12]
	cmp	DWORD PTR [edx+eax+36], 0
	jne	SHORT $LN8@propagate_

; 3503 :         {
; 3504 :           components[n].bit_depth = out_depth;

	mov	DWORD PTR [edx+eax+36], edi

; 3505 :           any_change = true;

	mov	BYTE PTR _any_change$1$[ebp], 1
$LN8@propagate_:

; 3501 :     for (n=0; n < num_components; n++)

	inc	ecx
	add	edx, 60					; 0000003cH
	cmp	ecx, DWORD PTR [esi+8]
	jl	SHORT $LL10@propagate_
$LN9@propagate_:

; 3506 :         }
; 3507 : 
; 3508 :   if (need_input_bit_depth)

	cmp	BYTE PTR _need_input_bit_depth$[ebp], 0
	je	SHORT $LN12@propagate_

; 3509 :     for (int lev_idx=0; lev_idx < num_levels; lev_idx++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+40], ebx
	jle	SHORT $LN12@propagate_
	xor	eax, eax
	mov	DWORD PTR tv541[ebp], eax
$LL13@propagate_:

; 3510 :       {
; 3511 :         kd_multi_dwt_level *lev = levels + lev_idx;

	mov	esi, DWORD PTR [esi+44]
	add	esi, eax

; 3512 :         for (n=0; n < lev->region_size; n++)

	xor	eax, eax
	cmp	DWORD PTR [esi+20], eax
	jle	SHORT $LN11@propagate_
	npad	2
$LL16@propagate_:

; 3513 :           {
; 3514 :             if (lev->dependencies[n] == NULL)

	mov	ecx, DWORD PTR [esi+36]
	mov	edx, DWORD PTR [ecx+eax*4]
	test	edx, edx
	je	SHORT $LN14@propagate_

; 3515 :               continue;
; 3516 :             kd_multi_line *dep = *(lev->dependencies[n]);

	mov	edx, DWORD PTR [edx]

; 3517 :             if ((dep != NULL) && (dep->bit_depth == 0))

	test	edx, edx
	je	SHORT $LN14@propagate_
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN14@propagate_

; 3518 :               {
; 3519 :                 any_change = true;
; 3520 :                 dep->bit_depth = out_depth + ((lev_idx==0)?0:1);

	xor	ecx, ecx
	mov	BYTE PTR _any_change$1$[ebp], 1
	test	ebx, ebx
	setne	cl
	add	ecx, edi
	mov	DWORD PTR [edx+36], ecx
$LN14@propagate_:

; 3512 :         for (n=0; n < lev->region_size; n++)

	inc	eax
	cmp	eax, DWORD PTR [esi+20]
	jl	SHORT $LL16@propagate_
$LN11@propagate_:

; 3509 :     for (int lev_idx=0; lev_idx < num_levels; lev_idx++)

	mov	esi, DWORD PTR _this$1$[ebp]
	inc	ebx
	mov	eax, DWORD PTR tv541[ebp]
	add	eax, 52					; 00000034H
	mov	DWORD PTR tv541[ebp], eax
	cmp	ebx, DWORD PTR [esi+40]
	jl	SHORT $LL13@propagate_
$LN12@propagate_:

; 3521 :               }
; 3522 :           }
; 3523 :       }
; 3524 : 
; 3525 :   return any_change;

	mov	al, BYTE PTR _any_change$1$[ebp]
	pop	edi
	pop	ebx
	pop	esi

; 3526 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?propagate_bit_depths@kd_multi_dwt_block@@UAE_N_N0@Z ENDP ; kd_multi_dwt_block::propagate_bit_depths
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?normalize_coefficients@kd_multi_dwt_block@@UAEXXZ
_TEXT	SEGMENT
_e$2 = -40						; size = 20
tv419 = -20						; size = 4
_this$1$ = -20						; size = 4
_n$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?normalize_coefficients@kd_multi_dwt_block@@UAEXXZ PROC	; kd_multi_dwt_block::normalize_coefficients, COMDAT
; _this$ = ecx

; 3407 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?normalize_coefficients@kd_multi_dwt_block@@UAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi

; 3408 :   if (is_reversible)

	cmp	BYTE PTR [esi+48], 0
	jne	$LN12@normalize_

; 3409 :     return; // Only need to normalize for irreversible transforms
; 3410 : 
; 3411 :   bool need_precise=false;
; 3412 :   int n, max_bit_depth = 0;
; 3413 :   for (n=0; n < num_components; n++)

	mov	edx, DWORD PTR [esi+8]
	xor	bl, bl
	xor	edi, edi
	test	edx, edx
	jle	SHORT $LN45@normalize_

; 3414 :     {
; 3415 :       kd_multi_line *line = components + n;

	mov	ecx, DWORD PTR [esi+12]
	lea	esi, DWORD PTR [edi+1]
	add	ecx, 36					; 00000024H
	npad	5
$LL4@normalize_:

; 3416 :       if (line->bit_depth > max_bit_depth)

	cmp	DWORD PTR [ecx], edi

; 3417 :         max_bit_depth = line->bit_depth;
; 3418 :       if (line->need_precise)

	movzx	ebx, bl
	cmovg	edi, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+60]
	cmp	BYTE PTR [ecx-62], 0
	cmovne	ebx, esi
	sub	edx, esi
	jne	SHORT $LL4@normalize_

; 3419 :         need_precise = true;
; 3420 :     }
; 3421 :   if (max_bit_depth == 0)

	mov	esi, DWORD PTR _this$1$[ebp]
	test	edi, edi
	jne	SHORT $LN17@normalize_
$LN45@normalize_:

; 3422 :     need_precise = true;

	mov	bl, 1
$LN17@normalize_:

; 3423 :   for (n=0; n < num_dependencies; n++)

	mov	edx, DWORD PTR [esi+16]
	test	edx, edx
	jle	SHORT $LN6@normalize_

; 3424 :     {
; 3425 :       kd_multi_line *dep = dependencies[n];

	mov	ecx, DWORD PTR [esi+20]
	npad	7
$LL7@normalize_:
	mov	eax, DWORD PTR [ecx]

; 3426 :       if (dep == NULL)

	test	eax, eax
	je	SHORT $LN5@normalize_

; 3427 :         continue;
; 3428 :       if (dep->need_precise || (dep->bit_depth == 0))

	cmp	BYTE PTR [eax+34], 0
	jne	SHORT $LN20@normalize_
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN5@normalize_
$LN20@normalize_:

; 3429 :         need_precise = true;

	mov	bl, 1
$LN5@normalize_:

; 3423 :   for (n=0; n < num_dependencies; n++)

	add	ecx, 4
	sub	edx, 1
	jne	SHORT $LL7@normalize_
$LN6@normalize_:

; 3430 :     }
; 3431 :   for (n=0; n < num_components; n++)

	xor	ecx, ecx
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	DWORD PTR [esi+8], ecx
	jle	SHORT $LN9@normalize_
	xor	edx, edx
	mov	DWORD PTR tv419[ebp], edx
	npad	5
$LL10@normalize_:

; 3432 :     {
; 3433 :       kd_multi_line *line = components + n;

	mov	eax, DWORD PTR [esi+12]
	add	eax, edx

; 3434 :       line->need_precise = need_precise;

	mov	BYTE PTR [eax+34], bl

; 3435 :       assert(line->need_irreversible);
; 3436 :       if (line->bit_depth == 0)

	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN21@normalize_

; 3437 :         line->bit_depth = max_bit_depth;

	mov	DWORD PTR [eax+36], edi
	jmp	SHORT $LN8@normalize_
$LN21@normalize_:

; 3438 :       else if (line->bit_depth != max_bit_depth)

	cmp	DWORD PTR [eax+36], edi
	je	SHORT $LN8@normalize_

; 3439 :         { KDU_ERROR(e,0x28090500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BGL@OKHHJDHO@Inconsistent?5bit?9depths?5encounte@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3439 :         { KDU_ERROR(e,0x28090500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3447 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _n$1$[ebp]
	mov	edx, DWORD PTR tv419[ebp]
$LN8@normalize_:

; 3430 :     }
; 3431 :   for (n=0; n < num_components; n++)

	inc	ecx
	add	edx, 60					; 0000003cH
	mov	DWORD PTR _n$1$[ebp], ecx
	mov	DWORD PTR tv419[ebp], edx
	cmp	ecx, DWORD PTR [esi+8]
	jl	SHORT $LL10@normalize_
$LN9@normalize_:

; 3448 :     }
; 3449 :   for (n=0; n < num_dependencies; n++)

	xor	ecx, ecx
	cmp	DWORD PTR [esi+16], ecx
	jle	SHORT $LN12@normalize_
$LL13@normalize_:

; 3450 :     if (dependencies[n] != NULL)

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN11@normalize_

; 3451 :       dependencies[n]->need_precise = need_precise;

	mov	BYTE PTR [eax+34], bl
$LN11@normalize_:

; 3448 :     }
; 3449 :   for (n=0; n < num_dependencies; n++)

	inc	ecx
	cmp	ecx, DWORD PTR [esi+16]
	jl	SHORT $LL13@normalize_
$LN12@normalize_:

; 3452 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?normalize_coefficients@kd_multi_dwt_block@@UAEXXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?normalize_coefficients@kd_multi_dwt_block@@UAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?normalize_coefficients@kd_multi_dwt_block@@UAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?normalize_coefficients@kd_multi_dwt_block@@UAEXXZ ENDP	; kd_multi_dwt_block::normalize_coefficients
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z
_TEXT	SEGMENT
_lval$2 = -756						; size = 8
_hval$3 = -748						; size = 8
_num_stage_inputs$ = -740				; size = 4
_num_stage_outputs$ = -736				; size = 4
tv2319 = -732						; size = 4
_output_collection$GSCopy$1$ = -728			; size = 4
_high_support_min$ = -724				; size = 4
_low_support_min$ = -720				; size = 4
_high_support_max$ = -716				; size = 4
_low_support_max$ = -712				; size = 4
_active_inputs$1$ = -708				; size = 4
_high_range$1$ = -704					; size = 8
tv2500 = -704						; size = 8
_input_indices$1$ = -696				; size = 4
_rev_offsets$1$ = -692					; size = 4
_output_indices$1$ = -688				; size = 4
tv2305 = -684						; size = 4
_irrev_offsets$1$ = -684				; size = 4
tv2320 = -680						; size = 4
_coefficients$ = -676					; size = 4
_num_block_inputs$GSCopy$ = -672			; size = 4
_canvas_lim$ = -668					; size = 4
_num_block_outputs$GSCopy$ = -664			; size = 4
_low_scale$1$ = -660					; size = 4
$T4 = -660						; size = 4
$T5 = -660						; size = 4
_step_info$1$ = -660					; size = 4
_dep_ref$1$ = -656					; size = 4
_active_outputs$1$ = -656				; size = 4
_canvas_min$ = -652					; size = 4
_high_scale$1$ = -648					; size = 4
tv2253 = -648						; size = 4
tv2214 = -648						; size = 4
$T6 = -648						; size = 4
$T7 = -648						; size = 4
_this$GSCopy$1$ = -644					; size = 4
_block_idx$GSCopy$1$ = -640				; size = 4
_lev_idx$4$ = -640					; size = 4
_s$2$ = -640						; size = 4
tv2304 = -640						; size = 4
tv2251 = -640						; size = 4
_fact$2$ = -636						; size = 4
_lev$1$ = -636						; size = 4
_lev_idx$3$ = -636					; size = 4
tv2321 = -636						; size = 4
tv2254 = -636						; size = 4
tv2252 = -636						; size = 4
$T8 = -636						; size = 4
_region_lim$1$ = -632					; size = 4
_next_coeff_idx$1$ = -632				; size = 4
_stage_idx$GSCopy$1$ = -628				; size = 4
_lev_idx$2$ = -628					; size = 4
_lev_idx$1$ = -628					; size = 4
_n$2$ = -628						; size = 4
_s$1$ = -628						; size = 4
tv2242 = -628						; size = 4
___n$1$ = -624						; size = 4
_dep_idx$1$ = -624					; size = 4
_lev$1$ = -624						; size = 4
tv2261 = -624						; size = 4
_n$ = -620						; size = 4
_kernels$ = -616					; size = 600
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_stage_idx$ = 8						; size = 4
_block_idx$ = 12					; size = 4
_tile$ = 16						; size = 4
_num_block_inputs$ = 20					; size = 4
_num_block_outputs$ = 24				; size = 4
_input_collection$ = 28					; size = 4
_output_collection$ = 32				; size = 4
_owner$ = 36						; size = 4
?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z PROC ; kd_multi_dwt_block::initialize, COMDAT
; _this$ = ecx

; 3044 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 744				; 000002e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	eax, DWORD PTR _stage_idx$[ebp]
	mov	edx, DWORD PTR _num_block_inputs$[ebp]
	mov	ecx, DWORD PTR _output_collection$[ebp]
	mov	esi, DWORD PTR _owner$[ebp]
	mov	edi, DWORD PTR _block_idx$[ebp]
	mov	DWORD PTR _stage_idx$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _num_block_outputs$[ebp]
	mov	DWORD PTR _num_block_outputs$GSCopy$[ebp], eax
	mov	DWORD PTR _output_collection$GSCopy$1$[ebp], ecx

; 3045 :   int *scratch =
; 3046 :     owner->get_scratch_ints(2*num_block_inputs+3*num_block_outputs);

	mov	ecx, esi
	mov	DWORD PTR _block_idx$GSCopy$1$[ebp], edi
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _num_block_inputs$GSCopy$[ebp], edx
	lea	eax, DWORD PTR [eax+edx*2]
	push	eax
	call	?get_scratch_ints@kd_multi_transform@@QAEPAHH@Z ; kd_multi_transform::get_scratch_ints

; 3047 :   int *input_indices = scratch;
; 3048 :   int *active_inputs = input_indices + num_block_inputs;

	mov	ecx, DWORD PTR _num_block_inputs$GSCopy$[ebp]

; 3049 :   int *output_indices = active_inputs + num_block_inputs;
; 3050 :   int *active_outputs = output_indices + num_block_outputs;

	mov	edx, DWORD PTR _num_block_outputs$GSCopy$[ebp]
	mov	DWORD PTR _input_indices$1$[ebp], eax

; 3051 :   int *rev_offsets = active_outputs + num_block_outputs;
; 3052 :   float *irrev_offsets = owner->get_scratch_floats(num_block_outputs);

	push	edx
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _active_inputs$1$[ebp], eax
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _output_indices$1$[ebp], eax
	mov	ecx, esi
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _active_outputs$1$[ebp], eax
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _rev_offsets$1$[ebp], eax
	call	?get_scratch_floats@kd_multi_transform@@QAEPAMH@Z ; kd_multi_transform::get_scratch_floats

; 3053 :   int num_stage_inputs, num_stage_outputs;
; 3054 :   tile.get_mct_block_info(stage_idx,block_idx,num_stage_inputs,

	push	0
	push	DWORD PTR _rev_offsets$1$[ebp]
	mov	esi, DWORD PTR _stage_idx$GSCopy$1$[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	push	eax
	push	DWORD PTR _output_indices$1$[ebp]
	mov	DWORD PTR _irrev_offsets$1$[ebp], eax
	lea	eax, DWORD PTR _num_block_outputs$GSCopy$[ebp]
	push	DWORD PTR _input_indices$1$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_block_inputs$GSCopy$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_outputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_inputs$[ebp]
	push	eax
	push	edi
	push	esi
	call	?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z ; kdu_tile::get_mct_block_info

; 3055 :                           num_stage_outputs,num_block_inputs,num_block_outputs,
; 3056 :                           input_indices,output_indices,
; 3057 :                           irrev_offsets,rev_offsets);
; 3058 :   assert((num_stage_inputs == input_collection->num_components) &&
; 3059 :          (num_stage_outputs == output_collection->num_components));
; 3060 : 
; 3061 :   // Find and record DWT-specific parameters
; 3062 :   int n, s, canvas_min, canvas_lim;
; 3063 :   const float *coefficients=NULL;
; 3064 :   const kdu_kernel_step_info *step_info =
; 3065 :     tile.get_mct_dwt_info(stage_idx,block_idx,is_reversible,num_levels,

	push	DWORD PTR _active_outputs$1$[ebp]
	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	lea	edi, DWORD PTR _coefficients$[ebp]
	push	DWORD PTR _active_inputs$1$[ebp]
	mov	DWORD PTR _coefficients$[ebp], 0
	push	edi
	mov	edi, DWORD PTR _block_idx$GSCopy$1$[ebp]
	lea	ecx, DWORD PTR [eax+50]
	push	ecx
	lea	edx, DWORD PTR [eax+49]
	push	edx
	lea	esi, DWORD PTR [eax+52]
	mov	DWORD PTR tv2321[ebp], esi
	lea	ecx, DWORD PTR _canvas_lim$[ebp]
	push	DWORD PTR tv2321[ebp]
	lea	esi, DWORD PTR [eax+40]
	add	eax, 48					; 00000030H
	push	ecx
	lea	ecx, DWORD PTR _canvas_min$[ebp]
	mov	DWORD PTR tv2320[ebp], esi
	push	ecx
	push	esi
	mov	esi, DWORD PTR _stage_idx$GSCopy$1$[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	push	eax
	push	edi
	push	esi
	mov	DWORD PTR tv2319[ebp], eax
	call	?get_mct_dwt_info@kdu_tile@@QAEPBUkdu_kernel_step_info@@HHAA_NAAH11100AAPBMPAH3@Z ; kdu_tile::get_mct_dwt_info

; 3066 :                           canvas_min,canvas_lim,num_steps,symmetric,
; 3067 :                           sym_extension,coefficients,
; 3068 :                           active_inputs,active_outputs);
; 3069 :   assert((step_info != NULL) && (num_levels > 0));
; 3070 :   num_coefficients = max_step_length = 0;

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	esi, eax
	mov	DWORD PTR _step_info$1$[ebp], esi

; 3071 :   steps = new kd_lifting_step[num_steps];

	mov	eax, DWORD PTR [edi+52]
	xor	ecx, ecx
	mov	edx, 20					; 00000014H
	mov	DWORD PTR [edi+72], 0
	mul	edx
	mov	DWORD PTR [edi+60], 0
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 3072 :   for (s=0; s < num_steps; s++)

	xor	ecx, ecx
	mov	DWORD PTR [edi+56], eax
	add	esp, 4
	mov	DWORD PTR _s$1$[ebp], ecx
	cmp	DWORD PTR [edi+52], ecx
	jle	$LN3@initialize
	xor	edx, edx
$LL4@initialize:

; 3073 :     {
; 3074 :       steps[s].step_idx = (kdu_byte) s;

	mov	eax, DWORD PTR [edi+56]
	mov	BYTE PTR [edx+eax], cl

; 3075 :       steps[s].support_length = (kdu_byte) step_info[s].support_length;

	mov	ecx, DWORD PTR [edi+56]
	movzx	eax, BYTE PTR [esi]
	mov	BYTE PTR [edx+ecx+1], al

; 3076 :       steps[s].downshift = (kdu_byte) step_info[s].downshift;

	mov	ecx, DWORD PTR [edi+56]
	movzx	eax, BYTE PTR [esi+8]
	mov	BYTE PTR [edx+ecx+2], al

; 3077 :       steps[s].extend = 0; // Not used

	mov	eax, DWORD PTR [edi+56]
	mov	BYTE PTR [edx+eax+3], 0

; 3078 :       steps[s].support_min = (kdu_int16) step_info[s].support_min;

	mov	ecx, DWORD PTR [edi+56]
	movzx	eax, WORD PTR [esi+4]
	mov	WORD PTR [edx+ecx+4], ax

; 3079 :       steps[s].rounding_offset = (kdu_int16) step_info[s].rounding_offset;

	mov	ecx, DWORD PTR [edi+56]
	movzx	eax, WORD PTR [esi+12]
	mov	WORD PTR [edx+ecx+6], ax

; 3080 :       steps[s].coeffs = NULL;   steps[s].icoeffs = NULL;

	mov	eax, DWORD PTR [edi+56]
	mov	DWORD PTR [edx+eax+8], 0
	mov	eax, DWORD PTR [edi+56]
	mov	DWORD PTR [edx+eax+12], 0

; 3081 :       steps[s].add_shorts_first = false;

	mov	eax, DWORD PTR [edi+56]
	mov	BYTE PTR [edx+eax+16], 0

; 3082 :       steps[s].kernel_id = (kdu_byte) Ckernels_ATK;

	mov	eax, DWORD PTR [edi+56]
	mov	BYTE PTR [edx+eax+18], 255		; 000000ffH

; 3083 :       steps[s].reversible = is_reversible;

	mov	ecx, DWORD PTR [edi+56]
	movzx	eax, BYTE PTR [edi+48]
	mov	BYTE PTR [edx+ecx+17], al

; 3084 :       num_coefficients += step_info[s].support_length;

	mov	eax, DWORD PTR [esi]
	add	DWORD PTR [edi+60], eax

; 3085 :       if (max_step_length < step_info[s].support_length)

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [edi+72], eax
	jge	SHORT $LN2@initialize

; 3086 :         max_step_length = step_info[s].support_length;

	mov	DWORD PTR [edi+72], eax
$LN2@initialize:

; 3072 :   for (s=0; s < num_steps; s++)

	mov	ecx, DWORD PTR _s$1$[ebp]
	add	edx, 20					; 00000014H
	inc	ecx
	add	esi, 16					; 00000010H
	mov	DWORD PTR _s$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+52]
	jl	$LL4@initialize
$LN3@initialize:

; 3087 :     }
; 3088 :   src_bufs32 = new kdu_sample32 *[max_step_length];

	mov	eax, DWORD PTR [edi+72]
	xor	ecx, ecx
	mov	esi, 4
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+76], eax

; 3089 :   i_coefficients = new int[num_coefficients];

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi+60]
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+68], eax

; 3090 :   f_coefficients = new float[num_coefficients];

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi+60]
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 3091 :   int next_coeff_idx=0;

	xor	ecx, ecx
	mov	DWORD PTR [edi+64], eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _next_coeff_idx$1$[ebp], ecx

; 3092 :   for (s=0; s < num_steps; s++)

	mov	DWORD PTR _s$2$[ebp], ecx
	cmp	DWORD PTR [edi+52], ecx
	jle	$LN6@initialize

; 3087 :     }
; 3088 :   src_bufs32 = new kdu_sample32 *[max_step_length];

	movss	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	xor	esi, esi
	movss	xmm0, DWORD PTR __real@3eff7cee
	movss	xmm2, DWORD PTR __real@3f000000
	mov	DWORD PTR tv2261[ebp], esi
$LL7@initialize:

; 3093 :     {
; 3094 :       steps[s].coeffs = f_coefficients + next_coeff_idx;

	mov	eax, DWORD PTR [edi+56]
	lea	edx, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR [edi+64]

; 3095 :       steps[s].icoeffs = i_coefficients + next_coeff_idx;
; 3096 :       float fact, max_factor = 0.4F;

	movss	xmm1, DWORD PTR __real@3ecccccd
	add	ecx, edx
	mov	DWORD PTR [esi+eax+8], ecx
	mov	eax, DWORD PTR [edi+56]
	mov	ecx, DWORD PTR [edi+68]
	add	ecx, edx

; 3097 :       for (n=0; n < (int) steps[s].support_length; n++)

	xor	edx, edx
	mov	DWORD PTR [esi+eax+12], ecx
	mov	eax, DWORD PTR [edi+56]
	mov	DWORD PTR _n$[ebp], edx
	cmp	BYTE PTR [esi+eax+1], dl
	jbe	SHORT $LN9@initialize
	npad	6
$LL10@initialize:

; 3098 :         {
; 3099 :           steps[s].coeffs[n] = fact = coefficients[next_coeff_idx+n];

	mov	ecx, DWORD PTR _next_coeff_idx$1$[ebp]
	mov	eax, DWORD PTR _coefficients$[ebp]
	add	ecx, edx
	movss	xmm2, DWORD PTR [eax+ecx*4]

; 3100 :           if (fact > max_factor)

	comiss	xmm2, xmm1
	mov	eax, DWORD PTR [edi+56]
	mov	eax, DWORD PTR [esi+eax+8]
	movss	DWORD PTR [eax+edx*4], xmm2
	jbe	SHORT $LN73@initialize

; 3101 :             max_factor = fact;

	movaps	xmm1, xmm2
	jmp	SHORT $LN8@initialize
$LN73@initialize:

; 3102 :           else if (fact < -max_factor)

	movaps	xmm0, xmm1
	xorps	xmm0, xmm3
	comiss	xmm0, xmm2
	jbe	SHORT $LN8@initialize

; 3103 :             max_factor = -fact;

	movaps	xmm1, xmm2
	xorps	xmm1, xmm3
$LN8@initialize:

; 3097 :       for (n=0; n < (int) steps[s].support_length; n++)

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edi+56]
	inc	edx
	mov	DWORD PTR _n$[ebp], edx
	movzx	eax, BYTE PTR [esi+eax+1]
	cmp	edx, eax
	jl	SHORT $LL10@initialize
	movss	xmm0, DWORD PTR __real@3eff7cee
	movss	xmm2, DWORD PTR __real@3f000000
$LN9@initialize:

; 3104 :         }
; 3105 :       if (!is_reversible)

	cmp	BYTE PTR [edi+48], 0
	jne	SHORT $LN76@initialize

; 3106 :         { // Find appropriate downshift and rounding_offset values
; 3107 :           for (steps[s].downshift=16; max_factor >= 0.499F; max_factor*=0.5F)

	comiss	xmm1, xmm0
	mov	eax, DWORD PTR [edi+56]
	mov	BYTE PTR [esi+eax+2], 16		; 00000010H
	jb	SHORT $LN12@initialize
	npad	10
$LL13@initialize:

; 3108 :             steps[s].downshift--;

	mov	eax, DWORD PTR [edi+56]
	mulss	xmm1, xmm2
	dec	BYTE PTR [esi+eax+2]
	comiss	xmm1, xmm0
	jae	SHORT $LL13@initialize
$LN12@initialize:

; 3109 :           steps[s].rounding_offset = (kdu_int16)((1<<steps[s].downshift) >> 1);

	mov	edx, DWORD PTR [edi+56]
	mov	eax, 1
	mov	cl, BYTE PTR [esi+edx+2]
	shl	eax, cl
	sar	eax, 1
	mov	WORD PTR [esi+edx+6], ax
$LN76@initialize:

; 3110 :         }
; 3111 :       fact = (float)(1<<steps[s].downshift);

	mov	edx, DWORD PTR [edi+56]
	mov	eax, 1
	mov	cl, BYTE PTR [esi+edx+2]
	shl	eax, cl

; 3112 :       for (n=0; n < (int) steps[s].support_length; n++)

	xor	ecx, ecx
	mov	DWORD PTR _n$[ebp], ecx
	mov	DWORD PTR _n$2$[ebp], ecx
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR _fact$2$[ebp], xmm1
	cmp	BYTE PTR [esi+edx+1], cl
	jbe	$LN15@initialize
	npad	6
$LL16@initialize:

; 3113 :         steps[s].icoeffs[n] = (int) floor(0.5 + steps[s].coeffs[n] * fact);

	mov	esi, DWORD PTR [edi+56]
	sub	esp, 8
	mov	eax, DWORD PTR tv2261[ebp]
	mov	eax, DWORD PTR [eax+esi+8]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, xmm1
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv2500[ebp], xmm0
	fld	QWORD PTR tv2500[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	edx, DWORD PTR tv2261[ebp]
	movss	xmm1, DWORD PTR _fact$2$[ebp]
	mov	ecx, DWORD PTR [edx+esi+12]
	mov	edx, DWORD PTR _n$2$[ebp]
	mov	esi, DWORD PTR tv2261[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
	mov	ecx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edi+56]
	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx
	mov	DWORD PTR _n$2$[ebp], ecx
	movzx	eax, BYTE PTR [esi+eax+1]
	cmp	ecx, eax
	jl	$LL16@initialize
	movss	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
$LN15@initialize:

; 3114 :       next_coeff_idx += steps[s].support_length;

	mov	eax, DWORD PTR [edi+56]
	mov	ecx, DWORD PTR _next_coeff_idx$1$[ebp]
	movss	xmm0, DWORD PTR __real@3eff7cee
	movss	xmm2, DWORD PTR __real@3f000000
	movzx	eax, BYTE PTR [esi+eax+1]
	add	esi, 20					; 00000014H
	add	ecx, eax
	mov	DWORD PTR tv2261[ebp], esi
	mov	eax, DWORD PTR _s$2$[ebp]
	inc	eax
	mov	DWORD PTR _next_coeff_idx$1$[ebp], ecx
	mov	DWORD PTR _s$2$[ebp], eax
	cmp	eax, DWORD PTR [edi+52]
	jl	$LL7@initialize
$LN6@initialize:

; 3115 :     }
; 3116 : 
; 3117 :   // Find the region occupied by the active outputs
; 3118 :   int region_min=canvas_lim, region_lim=canvas_min;

	mov	eax, DWORD PTR _canvas_min$[ebp]

; 3119 :   for (n=0; n < num_block_outputs; n++)

	xor	edx, edx
	mov	esi, DWORD PTR _canvas_lim$[ebp]
	mov	DWORD PTR _region_lim$1$[ebp], eax
	mov	DWORD PTR _n$[ebp], edx
	cmp	DWORD PTR _num_block_outputs$GSCopy$[ebp], edx
	jle	SHORT $LN18@initialize
	mov	edi, DWORD PTR _active_outputs$1$[ebp]
	npad	5
$LL19@initialize:

; 3120 :     {
; 3121 :       int loc = active_outputs[n] + canvas_min;

	mov	ecx, DWORD PTR [edi+edx*4]
	add	ecx, DWORD PTR _canvas_min$[ebp]

; 3122 :       assert((loc >= canvas_min) && (loc < canvas_lim));
; 3123 :       if (loc < region_min)

	cmp	ecx, esi
	cmovl	esi, ecx

; 3124 :         region_min = loc;
; 3125 :       if (loc >= region_lim)

	cmp	ecx, eax
	jl	SHORT $LN17@initialize

; 3126 :         region_lim = loc+1;

	lea	eax, DWORD PTR [ecx+1]
$LN17@initialize:

; 3119 :   for (n=0; n < num_block_outputs; n++)

	inc	edx
	mov	DWORD PTR _n$[ebp], edx
	cmp	edx, DWORD PTR _num_block_outputs$GSCopy$[ebp]
	jl	SHORT $LL19@initialize
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR _region_lim$1$[ebp], eax
$LN18@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 135  :     kdu_kernels() { clear(); }

	lea	ecx, DWORD PTR _kernels$[ebp]
	call	?clear@kdu_kernels@@AAEXXZ		; kdu_kernels::clear
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3131 :   kernels.init(num_steps,step_info,coefficients,symmetric,sym_extension,

	movzx	eax, BYTE PTR [edi+48]
	lea	ecx, DWORD PTR _kernels$[ebp]
	push	eax
	movzx	eax, BYTE PTR [edi+50]
	push	eax
	movzx	eax, BYTE PTR [edi+49]
	push	eax
	push	DWORD PTR _coefficients$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	DWORD PTR _step_info$1$[ebp]
	push	DWORD PTR [edi+52]
	call	?init@kdu_kernels@@QAEXHPBUkdu_kernel_step_info@@PBM_N22@Z ; kdu_kernels::init

; 3132 :                is_reversible);
; 3133 : 
; 3134 :   levels = new kd_multi_dwt_level[num_levels];

	mov	eax, DWORD PTR [edi+40]
	xor	ecx, ecx
	mov	DWORD PTR $T5[ebp], eax
	mov	edx, 52					; 00000034H
	mov	DWORD PTR $T7[ebp], eax
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN107@initialize
	mov	ecx, DWORD PTR $T5[ebp]
	push	OFFSET ??1kd_multi_dwt_level@@QAE@XZ	; kd_multi_dwt_level::~kd_multi_dwt_level
	push	OFFSET ??0kd_multi_dwt_level@@QAE@XZ	; kd_multi_dwt_level::kd_multi_dwt_level
	push	ecx
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	push	52					; 00000034H
	push	eax
	mov	DWORD PTR $T4[ebp], eax
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	mov	eax, DWORD PTR $T4[ebp]
	jmp	SHORT $LN108@initialize
$LN107@initialize:
	xor	eax, eax
$LN108@initialize:

; 3135 :   int lev_idx;
; 3136 :   double range = 1.0; // Assumed range of samples prior to DWT analysis

	movsd	xmm0, QWORD PTR __real@3ff0000000000000

; 3141 :   kernels.get_impulse_response(KDU_SYNTHESIS_LOW,n, // n used as dummy var

	lea	ecx, DWORD PTR _kernels$[ebp]
	mov	DWORD PTR [edi+44], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 247  :           num_steps = this->num_steps; dc_scale = this->low_scale;

	mov	eax, DWORD PTR _kernels$[ebp+8]
	mov	DWORD PTR _n$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3141 :   kernels.get_impulse_response(KDU_SYNTHESIS_LOW,n, // n used as dummy var

	lea	eax, DWORD PTR _low_support_max$[ebp]
	push	eax
	lea	eax, DWORD PTR _low_support_min$[ebp]
	movsd	QWORD PTR _high_range$1$[ebp], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 247  :           num_steps = this->num_steps; dc_scale = this->low_scale;

	movss	xmm0, DWORD PTR _kernels$[ebp+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3141 :   kernels.get_impulse_response(KDU_SYNTHESIS_LOW,n, // n used as dummy var

	push	eax
	lea	eax, DWORD PTR _n$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 247  :           num_steps = this->num_steps; dc_scale = this->low_scale;

	movss	DWORD PTR _low_scale$1$[ebp], xmm0

; 248  :           nyq_scale = this->high_scale; return lifting_factors;

	movss	xmm0, DWORD PTR _kernels$[ebp+28]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3141 :   kernels.get_impulse_response(KDU_SYNTHESIS_LOW,n, // n used as dummy var

	push	eax
	push	2
	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 248  :           nyq_scale = this->high_scale; return lifting_factors;

	movss	DWORD PTR _high_scale$1$[ebp], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3141 :   kernels.get_impulse_response(KDU_SYNTHESIS_LOW,n, // n used as dummy var

	call	?get_impulse_response@kdu_kernels@@QAEPAMW4kdu_kernel_type@@AAHPAH2@Z ; kdu_kernels::get_impulse_response

; 3142 :                                &low_support_min,&low_support_max);
; 3143 :   kernels.get_impulse_response(KDU_SYNTHESIS_HIGH,n, // n used as dummy var

	lea	eax, DWORD PTR _high_support_max$[ebp]
	push	eax
	lea	eax, DWORD PTR _high_support_min$[ebp]
	push	eax
	lea	eax, DWORD PTR _n$[ebp]
	push	eax
	push	3
	lea	ecx, DWORD PTR _kernels$[ebp]
	call	?get_impulse_response@kdu_kernels@@QAEPAMW4kdu_kernel_type@@AAHPAH2@Z ; kdu_kernels::get_impulse_response

; 3144 :                                &high_support_min,&high_support_max);
; 3145 :   for (lev_idx=num_levels-1; lev_idx >= 0; lev_idx--)

	mov	eax, DWORD PTR [edi+40]
	sub	eax, 1
	mov	DWORD PTR _lev_idx$1$[ebp], eax
	js	$LN241@initialize

; 3132 :                is_reversible);
; 3133 : 
; 3134 :   levels = new kd_multi_dwt_level[num_levels];

	imul	edx, eax, 52
	mov	DWORD PTR tv2254[ebp], edx
	npad	3
$LL22@initialize:

; 3146 :     {
; 3147 :       kd_multi_dwt_level *lev = levels + lev_idx;

	mov	ecx, DWORD PTR [edi+44]

; 3148 :       lev->canvas_min = canvas_min;  lev->canvas_size = canvas_lim-canvas_min;

	mov	eax, DWORD PTR _canvas_min$[ebp]
	add	ecx, edx

; 3149 :       int low_min = region_min-low_support_max;  low_min += (low_min&1);

	mov	edx, esi
	mov	DWORD PTR _lev$1$[ebp], ecx
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _canvas_lim$[ebp]
	sub	eax, DWORD PTR _canvas_min$[ebp]
	mov	DWORD PTR [ecx+4], eax
	sub	edx, DWORD PTR _low_support_max$[ebp]

; 3150 :       int high_min = region_min-high_support_max;  high_min += 1-(high_min&1);

	sub	esi, DWORD PTR _high_support_max$[ebp]
	mov	DWORD PTR tv2304[ebp], eax
	mov	ecx, esi
	mov	eax, edx
	mov	edi, DWORD PTR _canvas_lim$[ebp]
	and	eax, 1
	and	ecx, 1
	add	edx, eax
	mov	eax, 1
	sub	eax, ecx

; 3151 :       int low_lim = region_lim-low_support_min;  low_lim -= 1-(low_lim&1);

	mov	ecx, DWORD PTR _region_lim$1$[ebp]
	sub	ecx, DWORD PTR _low_support_min$[ebp]
	add	esi, eax
	mov	eax, ecx
	dec	ecx
	and	eax, 1
	add	ecx, eax

; 3152 :       int high_lim = region_lim-high_support_min;  high_lim -= (high_lim&1);

	mov	eax, DWORD PTR _region_lim$1$[ebp]
	sub	eax, DWORD PTR _high_support_min$[ebp]
	mov	DWORD PTR _region_lim$1$[ebp], eax
	and	eax, 1
	sub	DWORD PTR _region_lim$1$[ebp], eax

; 3153 :       region_min = (low_min < high_min)?low_min:high_min;

	cmp	edx, esi
	cmovl	esi, edx

; 3154 :       region_lim = (low_lim > high_lim)?low_lim:high_lim;

	mov	edx, DWORD PTR _region_lim$1$[ebp]
	cmp	ecx, edx
	cmovg	edx, ecx
	mov	ecx, DWORD PTR _canvas_min$[ebp]
$LN246@initialize:
	mov	eax, DWORD PTR tv2304[ebp]
	npad	4
$LL23@initialize:

; 3155 :       while ((region_min < canvas_min) || (region_lim > canvas_lim))

	cmp	esi, ecx
	jl	SHORT $LN79@initialize
	cmp	edx, edi
	jle	SHORT $LN24@initialize
$LN79@initialize:

; 3156 :         { // Reflect required samples which lie outside the canvas back into
; 3157 :           // the interior of the canvas, using the symmetric extension rule;
; 3158 :           // this could be overly conservative if the DWT kernel uses constant
; 3159 :           // boundary extension instead.
; 3160 :           if (lev->canvas_size < 2)

	cmp	eax, 2
	jge	SHORT $LN80@initialize

; 3161 :             { // This loop may iterate forever, since symmetric extension will
; 3162 :               // not bring external locations into the canvas region.
; 3163 :               region_min = canvas_min; region_lim = canvas_lim;

	mov	esi, ecx
	mov	edx, edi

; 3164 :             }
; 3165 :           if (region_min < canvas_min)

	jmp	SHORT $LL23@initialize
$LN80@initialize:
	cmp	esi, ecx
	jge	SHORT $LN81@initialize

; 3166 :             {
; 3167 :               int refl = 2*canvas_min - region_min;

	lea	eax, DWORD PTR [ecx+ecx]
	sub	eax, esi

; 3168 :               if (refl >= region_lim)

	cmp	eax, edx
	jl	SHORT $LN82@initialize

; 3169 :                 region_lim = refl+1;

	lea	edx, DWORD PTR [eax+1]
$LN82@initialize:
	mov	eax, DWORD PTR tv2304[ebp]

; 3170 :               region_min = canvas_min;

	mov	esi, ecx
$LN81@initialize:

; 3171 :             }
; 3172 :           if (region_lim > canvas_lim)

	cmp	edx, edi
	jle	SHORT $LL23@initialize

; 3173 :             {
; 3174 :               int refl = 2*(canvas_lim-1)-(region_lim-1);

	lea	eax, DWORD PTR [edi+edi]
	sub	eax, edx

; 3175 :               if (refl < region_min)
; 3176 :                 region_min = refl;
; 3177 :               region_lim = canvas_lim;

	mov	edx, edi
	dec	eax
	cmp	eax, esi
	cmovl	esi, eax

; 3178 :             }
; 3179 :         }

	jmp	SHORT $LN246@initialize
$LN24@initialize:

; 3180 :       lev->region_min = region_min;  lev->region_size = region_lim-region_min;

	mov	ecx, DWORD PTR _lev$1$[ebp]
	mov	eax, edx
	sub	eax, esi
	mov	DWORD PTR _region_lim$1$[ebp], edx

; 3181 :       lev->components = new kd_multi_line *[lev->region_size];

	mov	edi, 4
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+16], esi
	xor	ecx, ecx
	mul	edi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, DWORD PTR _lev$1$[ebp]

; 3182 :       lev->dependencies = new kd_multi_line **[lev->region_size];

	xor	ecx, ecx
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR [edx+20]
	mul	edi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, DWORD PTR _lev$1$[ebp]

; 3183 :       for (n=0; n < lev->region_size; n++)

	xor	ecx, ecx
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	add	esp, 8
	mov	DWORD PTR [edx+36], eax
	mov	DWORD PTR _n$[ebp], ecx
	cmp	DWORD PTR [edx+20], ecx
	jle	SHORT $LN26@initialize
	npad	10
$LL27@initialize:

; 3184 :         { lev->components[n] = NULL;  lev->dependencies[n] = NULL; }

	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [eax+ecx*4], 0
	mov	ecx, DWORD PTR [edx+36]
	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0
	mov	ecx, DWORD PTR _n$[ebp]
	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, DWORD PTR [edx+20]
	jl	SHORT $LL27@initialize
$LN26@initialize:

; 3185 : 
; 3186 :       // Setup subband gains and normalization
; 3187 :       lev->normalizing_shift = 0;

	mov	DWORD PTR [edx+40], 0

; 3188 :       if (is_reversible)

	cmp	BYTE PTR [edi+48], 0
	je	SHORT $LN85@initialize

; 3189 :         {
; 3190 :           lev->low_range = 1.0F;

	mov	DWORD PTR [edx+44], 1065353216		; 3f800000H

; 3191 :           lev->high_range = 2.0F;

	mov	DWORD PTR [edx+48], 1073741824		; 40000000H
	jmp	$LN88@initialize
$LN85@initialize:

; 3192 :         }
; 3193 :       else if (lev->canvas_size < 2)

	cmp	DWORD PTR [edx+4], 2
	jge	SHORT $LN87@initialize

; 3194 :         { // Unit length irreversible signals are just passed through unaltered
; 3195 :           lev->low_range = (float) range;

	movsd	xmm0, QWORD PTR _high_range$1$[ebp]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [edx+44], xmm0

; 3196 :           lev->high_range = (float) range;

	movss	DWORD PTR [edx+48], xmm0

; 3197 :         }
; 3198 :       else

	jmp	$LN88@initialize
$LN87@initialize:

; 3199 :         {
; 3200 :           int depth = num_levels-1-lev_idx;

	mov	eax, DWORD PTR [edi+40]

; 3201 :           double lval, hval, bibo_max;
; 3202 :           const double *bibo_gains =
; 3203 :             kernels.get_bibo_gains(depth,0,NULL,lval, hval);

	lea	ecx, DWORD PTR _hval$3[ebp]
	sub	eax, DWORD PTR _lev_idx$1$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _lval$2[ebp]
	dec	eax
	push	ecx
	push	0
	push	0
	push	eax
	lea	ecx, DWORD PTR _kernels$[ebp]
	call	?get_bibo_gains@kdu_kernels@@QAEPANHHQA_NAAN1@Z ; kdu_kernels::get_bibo_gains

; 3204 :           for (bibo_max=1.0; n < num_steps; n++)

	mov	edx, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR _n$[ebp]
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	cmp	ecx, edx
	jge	SHORT $LN29@initialize
	npad	6
$LL30@initialize:

; 3205 :             if (bibo_gains[n] > bibo_max)

	movsd	xmm0, QWORD PTR [eax+ecx*8]
	comisd	xmm0, xmm1
	jbe	SHORT $LN28@initialize

; 3206 :               bibo_max = bibo_gains[n];

	movaps	xmm1, xmm0
$LN28@initialize:

; 3204 :           for (bibo_max=1.0; n < num_steps; n++)

	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, edx
	jl	SHORT $LL30@initialize
$LN29@initialize:
	movss	xmm0, DWORD PTR _low_scale$1$[ebp]

; 3207 :           bibo_max *= range;

	movsd	xmm3, QWORD PTR _high_range$1$[ebp]

; 3208 :           double low_range = range / low_scale;   // Ranges we will have if we
; 3209 :           double high_range = range / high_scale; // do not scale after lifting
; 3210 :           double overflow_limit = 1.0 * (double)(1<<(16-KDU_FIX_POINT));
; 3211 :           while (bibo_max > 0.75*overflow_limit)

	movsd	xmm4, QWORD PTR __real@4018000000000000
	movaps	xmm2, xmm3
	mov	eax, DWORD PTR _lev$1$[ebp]
	cvtps2pd xmm0, xmm0
	mulsd	xmm1, xmm3
	divsd	xmm2, xmm0
	comisd	xmm1, xmm4
	movss	xmm0, DWORD PTR _high_scale$1$[ebp]
	cvtps2pd xmm0, xmm0
	divsd	xmm3, xmm0
	jbe	SHORT $LN32@initialize
	mov	ecx, DWORD PTR [eax+40]
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
$LL31@initialize:

; 3212 :             {
; 3213 :               lev->normalizing_shift++;
; 3214 :               low_range *= 0.5;
; 3215 :               high_range *= 0.5;
; 3216 :               bibo_max *= 0.5;

	mulsd	xmm1, xmm0
	inc	ecx
	mulsd	xmm2, xmm0
	mulsd	xmm3, xmm0
	comisd	xmm1, xmm4
	ja	SHORT $LL31@initialize
	mov	DWORD PTR [eax+40], ecx
$LN32@initialize:
	xorps	xmm0, xmm0

; 3217 :             }
; 3218 :           lev->low_range = (float) low_range;
; 3219 :           lev->high_range = (float) high_range;
; 3220 :           range = low_range; // Passed on to the next level

	movsd	QWORD PTR _high_range$1$[ebp], xmm2
	cvtsd2ss xmm0, xmm2
	movss	DWORD PTR [eax+44], xmm0
	xorps	xmm0, xmm0
	cvtsd2ss xmm0, xmm3
	movss	DWORD PTR [eax+48], xmm0
$LN88@initialize:

; 3221 :         }
; 3222 : 
; 3223 :       // Adjust canvas/region dimensions for next lower level and use the
; 3224 :       // information to size the low- and high-pass subbands
; 3225 :       canvas_min = (canvas_min+1)>>1;  canvas_lim = (canvas_lim+1)>>1;

	mov	ecx, DWORD PTR _canvas_lim$[ebp]

; 3226 :       region_min = (region_min+1)>>1;  region_lim = (region_lim+1)>>1;

	inc	esi
	mov	edx, DWORD PTR _canvas_min$[ebp]
	mov	eax, DWORD PTR _region_lim$1$[ebp]
	inc	eax
	sar	esi, 1
	lea	ecx, DWORD PTR [ecx+1]
	sar	eax, 1
	lea	edx, DWORD PTR [edx+1]
	sar	ecx, 1
	mov	DWORD PTR _canvas_lim$[ebp], ecx
	sar	edx, 1
	mov	DWORD PTR _canvas_min$[ebp], edx

; 3227 :       lev->canvas_low_size = canvas_lim - canvas_min;

	sub	ecx, edx
	mov	edx, DWORD PTR _lev$1$[ebp]
	mov	DWORD PTR _region_lim$1$[ebp], eax

; 3228 :       lev->canvas_high_size = lev->canvas_size - lev->canvas_low_size;

	mov	eax, DWORD PTR [edx+4]
	sub	eax, ecx
	mov	DWORD PTR [edx+8], ecx

; 3229 :       lev->region_low_size = region_lim - region_min;

	mov	ecx, DWORD PTR _region_lim$1$[ebp]
	mov	DWORD PTR [edx+12], eax
	sub	ecx, esi

; 3230 :       lev->region_high_size = lev->region_size - lev->region_low_size;

	mov	eax, DWORD PTR [edx+20]
	sub	eax, ecx
	mov	DWORD PTR [edx+24], ecx
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR _lev_idx$1$[ebp]
	mov	edx, DWORD PTR tv2254[ebp]
	dec	eax
	sub	edx, 52					; 00000034H
	mov	DWORD PTR _lev_idx$1$[ebp], eax
	mov	DWORD PTR tv2254[ebp], edx
	test	eax, eax
	jns	$LL22@initialize
$LN241@initialize:

; 3240 :   kd_multi_line *dummy_comp_base = NULL;
; 3241 :   for (lev_idx=num_levels-1; lev_idx >= 0; lev_idx--)

	mov	ecx, DWORD PTR [edi+40]
	xor	esi, esi
	sub	ecx, 1
	mov	DWORD PTR ___n$1$[ebp], esi
	mov	DWORD PTR _lev_idx$2$[ebp], ecx
	js	$LN34@initialize

; 3231 :     }
; 3232 : 
; 3233 :   // Assign level component and dependency pointers.  To do this, we make
; 3234 :   // a first pass through the DWT levels, assigning dummy addresses to the
; 3235 :   // `kd_multi_dwt_level::dependencies' and `kd_multi_dwt_level::components'
; 3236 :   // array entries.  We then allocate the global `components' and
; 3237 :   // `dependencies' arrays and make a second pass through the levels to
; 3238 :   // convert these dummy addresses into valid addresses.
; 3239 :   int comp_idx = 0;

	imul	eax, ecx, 52
	mov	DWORD PTR tv2251[ebp], eax
	npad	4
$LL35@initialize:

; 3242 :     {
; 3243 :       kd_multi_dwt_level *lev = levels + lev_idx;

	mov	edx, DWORD PTR [edi+44]
	add	edx, eax

; 3244 :       if (lev_idx == (num_levels-1))

	mov	eax, DWORD PTR [edi+40]
	dec	eax
	cmp	ecx, eax
	jne	SHORT $LN90@initialize

; 3245 :         { // Top level; each component needs its own line.
; 3246 :           for (n=0; n < lev->region_size; n++)

	xor	ecx, ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	DWORD PTR [edx+20], ecx
	jle	$LN33@initialize
	mov	eax, esi
	shl	eax, 4
	sub	eax, esi
	shl	eax, 2
	mov	DWORD PTR tv2253[ebp], eax
	mov	edi, eax
$LL38@initialize:

; 3247 :             lev->components[n] = dummy_comp_base + (comp_idx++);

	mov	eax, DWORD PTR [edx+32]
	inc	esi
	mov	DWORD PTR [eax+ecx*4], edi
	add	edi, 60					; 0000003cH
	mov	ecx, DWORD PTR _n$[ebp]
	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, DWORD PTR [edx+20]
	jl	SHORT $LL38@initialize

; 3248 :         }
; 3249 :       else

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR ___n$1$[ebp], esi
	jmp	$LN33@initialize
$LN90@initialize:

; 3250 :         { // For lower levels, we re-use low-pass lines from the next higher
; 3251 :           // level wherever possible.
; 3252 :           for (n=0; n < lev->region_size; n++)

	xor	esi, esi
	mov	DWORD PTR _n$[ebp], esi
	cmp	DWORD PTR [edx+20], esi
	jle	$LN242@initialize
	mov	ecx, DWORD PTR ___n$1$[ebp]
	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx
	shl	eax, 2
	mov	DWORD PTR tv2252[ebp], eax
$LL41@initialize:

; 3253 :             {
; 3254 :               int loc = lev->region_min + n; // Absolute location in level
; 3255 :               loc += loc; // Absolute location in next higher level

	mov	edi, DWORD PTR [edx+16]
	add	edi, esi
	add	edi, edi

; 3256 :               int idx = loc - lev[1].region_min;

	sub	edi, DWORD PTR [edx+68]

; 3257 :               if ((idx < 0) || (idx >= lev[1].region_size))

	js	SHORT $LN94@initialize
	cmp	edi, DWORD PTR [edx+72]
	jge	SHORT $LN94@initialize

; 3259 :               else
; 3260 :                 lev->components[n] = lev[1].components[idx];

	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR [edx+32]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [ecx+esi*4], eax
	mov	ecx, DWORD PTR ___n$1$[ebp]
	jmp	SHORT $LN39@initialize
$LN94@initialize:

; 3258 :                 lev->components[n] = dummy_comp_base + (comp_idx++);

	mov	eax, DWORD PTR [edx+32]
	inc	ecx
	mov	edi, DWORD PTR tv2252[ebp]
	mov	DWORD PTR ___n$1$[ebp], ecx
	mov	DWORD PTR [eax+esi*4], edi
	add	edi, 60					; 0000003cH
	mov	DWORD PTR tv2252[ebp], edi
$LN39@initialize:

; 3250 :         { // For lower levels, we re-use low-pass lines from the next higher
; 3251 :           // level wherever possible.
; 3252 :           for (n=0; n < lev->region_size; n++)

	mov	esi, DWORD PTR _n$[ebp]
	inc	esi
	mov	DWORD PTR _n$[ebp], esi
	cmp	esi, DWORD PTR [edx+20]
	jl	SHORT $LL41@initialize
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN242@initialize:
	mov	esi, DWORD PTR ___n$1$[ebp]
$LN33@initialize:

; 3240 :   kd_multi_line *dummy_comp_base = NULL;
; 3241 :   for (lev_idx=num_levels-1; lev_idx >= 0; lev_idx--)

	mov	eax, DWORD PTR _lev_idx$2$[ebp]
	sub	DWORD PTR tv2251[ebp], 52		; 00000034H
	dec	eax
	mov	DWORD PTR _lev_idx$2$[ebp], eax
	test	eax, eax
	mov	ecx, eax
	mov	eax, DWORD PTR tv2251[ebp]
	jns	$LL35@initialize
$LN34@initialize:

; 3265 :   components = new kd_multi_line[num_components];

	xor	ecx, ecx
	mov	DWORD PTR [edi+8], esi
	mov	eax, esi
	mov	edx, 60					; 0000003cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	test	eax, eax
	je	$LN109@initialize
	test	esi, esi
	je	$LN110@initialize
	lea	ecx, DWORD PTR [eax+6]
	npad	2
$LL119@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx-6], 0
	lea	ecx, DWORD PTR [ecx+60]
	mov	WORD PTR [ecx-60], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx-58], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx-54], 0
	mov	DWORD PTR [ecx-50], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 87   :         row_idx = -1;  num_consumers = outstanding_consumers = 0;

	mov	DWORD PTR [ecx-46], -1
	mov	DWORD PTR [ecx-38], 0
	mov	DWORD PTR [ecx-42], 0

; 88   :         reversible = need_irreversible = need_precise = is_constant = false;

	mov	DWORD PTR [ecx-34], 0

; 89   :         bit_depth = 0;  rev_offset = 0;  irrev_offset = 0.0F;

	mov	DWORD PTR [ecx-30], 0
	mov	DWORD PTR [ecx-26], 0
	mov	DWORD PTR [ecx-22], 0

; 90   :         bypass=NULL;  block=NULL;  collection_idx = -1;

	mov	DWORD PTR [ecx-18], 0
	mov	DWORD PTR [ecx-14], 0
	mov	DWORD PTR [ecx-10], -1
	sub	esi, 1
	jne	SHORT $LL119@initialize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3265 :   components = new kd_multi_line[num_components];

	jmp	SHORT $LN110@initialize
$LN109@initialize:
	xor	eax, eax
$LN110@initialize:
	mov	DWORD PTR [edi+12], eax

; 3266 : 
; 3267 :   kd_multi_line **dummy_dep_base = NULL;
; 3268 :   for (n=0; n < num_components; n++)

	xor	eax, eax
	mov	DWORD PTR _n$[ebp], eax
	cmp	DWORD PTR [edi+8], eax
	jle	SHORT $LN43@initialize
$LL44@initialize:

; 3269 :     {
; 3270 :       kd_multi_line *line = components + n;

	mov	ecx, DWORD PTR [edi+12]
	mov	edx, eax
	shl	edx, 4
	sub	edx, eax

; 3271 :       line->block = this;

	mov	DWORD PTR [ecx+edx*4+52], edi

; 3272 :       line->reversible = is_reversible;

	mov	al, BYTE PTR [edi+48]
	mov	BYTE PTR [ecx+edx*4+32], al

; 3273 :       line->need_irreversible = !is_reversible;

	cmp	BYTE PTR [edi+48], 0
	sete	al
	mov	BYTE PTR [ecx+edx*4+33], al
	mov	eax, DWORD PTR _n$[ebp]
	inc	eax
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, DWORD PTR [edi+8]
	jl	SHORT $LL44@initialize
$LN43@initialize:

; 3274 :     }
; 3275 : 
; 3276 :   int dep_idx=0;

	xor	eax, eax

; 3277 :   for (lev_idx=0; lev_idx < num_levels; lev_idx++)

	xor	ecx, ecx
	mov	DWORD PTR _dep_idx$1$[ebp], eax
	mov	DWORD PTR _lev_idx$3$[ebp], ecx
	cmp	DWORD PTR [edi+40], eax
	jle	$LN46@initialize
	npad	1
$LL47@initialize:

; 3278 :     {
; 3279 :       kd_multi_dwt_level *lev = levels + lev_idx;

	imul	esi, ecx, 52
	add	esi, DWORD PTR [edi+44]

; 3280 :       if (lev_idx == 0)

	test	ecx, ecx
	jne	SHORT $LN49@initialize

; 3281 :         for (n=0; n < lev->region_low_size; n++)

	mov	DWORD PTR _n$[ebp], ecx
	cmp	DWORD PTR [esi+24], ecx
	jle	SHORT $LN49@initialize
	mov	edi, DWORD PTR _dep_idx$1$[ebp]
	npad	5
$LL50@initialize:

; 3282 :           lev->dependencies[(lev->region_min&1) + 2*n] =

	mov	eax, DWORD PTR [esi+16]
	lea	edx, DWORD PTR [edi*4]
	and	eax, 1
	inc	edi
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	ecx, DWORD PTR _n$[ebp]
	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, DWORD PTR [esi+24]
	jl	SHORT $LL50@initialize
	mov	DWORD PTR _dep_idx$1$[ebp], edi
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN49@initialize:

; 3283 :             dummy_dep_base + (dep_idx++);
; 3284 :       for (n=0; n < lev->region_high_size; n++)

	xor	ecx, ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	DWORD PTR [esi+28], ecx
	jle	SHORT $LN45@initialize
	mov	edi, DWORD PTR _dep_idx$1$[ebp]
	npad	8
$LL53@initialize:

; 3285 :         lev->dependencies[1-(lev->region_min&1) + 2*n] =

	mov	eax, DWORD PTR [esi+16]
	lea	edx, DWORD PTR [edi*4]
	add	ecx, ecx
	and	eax, 1
	sub	ecx, eax
	inc	edi
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+ecx*4+4], edx
	mov	ecx, DWORD PTR _n$[ebp]
	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, DWORD PTR [esi+28]
	jl	SHORT $LL53@initialize
	mov	DWORD PTR _dep_idx$1$[ebp], edi
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN45@initialize:

; 3277 :   for (lev_idx=0; lev_idx < num_levels; lev_idx++)

	mov	ecx, DWORD PTR _lev_idx$3$[ebp]
	inc	ecx
	mov	DWORD PTR _lev_idx$3$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+40]
	jl	$LL47@initialize
	mov	eax, DWORD PTR _dep_idx$1$[ebp]
$LN46@initialize:

; 3286 :           dummy_dep_base + (dep_idx++);
; 3287 :     }
; 3288 :   num_dependencies = dep_idx;
; 3289 :   dependencies = new kd_multi_line *[num_dependencies];

	xor	ecx, ecx
	mov	DWORD PTR [edi+16], eax
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 3290 :   for (n=0; n < num_dependencies; n++)

	xor	ecx, ecx
	mov	DWORD PTR [edi+20], eax
	add	esp, 4
	mov	DWORD PTR _n$[ebp], ecx
	cmp	DWORD PTR [edi+16], ecx
	jle	SHORT $LN55@initialize
	npad	1
$LL56@initialize:

; 3291 :     dependencies[n] = NULL;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [eax+ecx*4], 0
	mov	ecx, DWORD PTR _n$[ebp]
	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+16]
	jl	SHORT $LL56@initialize
$LN55@initialize:

; 3292 : 
; 3293 :   for (lev_idx=0; lev_idx < num_levels; lev_idx++)

	xor	ecx, ecx
	lea	edx, DWORD PTR [edi+40]
	mov	DWORD PTR _lev_idx$4$[ebp], ecx
	cmp	DWORD PTR [edx], ecx
	jle	$LN58@initialize
	xor	eax, eax
	mov	DWORD PTR tv2242[ebp], eax
$LL59@initialize:

; 3294 :     {
; 3295 :       kd_multi_dwt_level *lev = levels + lev_idx;

	mov	esi, DWORD PTR [edi+44]

; 3296 :       for (n=0; n < lev->region_size; n++)

	xor	edi, edi
	add	esi, eax
	mov	DWORD PTR _n$[ebp], edi
	mov	DWORD PTR _lev$1$[ebp], esi
	cmp	DWORD PTR [esi+20], edi
	jle	$LN57@initialize
$LL62@initialize:

; 3297 :         {
; 3298 :           lev->components[n] = components +

	mov	esi, DWORD PTR [esi+32]
	mov	eax, -2004318071			; 88888889H
	imul	DWORD PTR [esi+edi*4]
	add	edx, DWORD PTR [esi+edi*4]
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax

; 3299 :             (lev->components[n] - dummy_comp_base);
; 3300 :           if ((lev_idx == 0) || ((lev->region_min+n) & 1))

	cmp	DWORD PTR tv2242[ebp], 0
	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+12]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+edi*4], eax
	mov	edi, DWORD PTR _n$[ebp]
	mov	esi, DWORD PTR _lev$1$[ebp]
	je	SHORT $LN98@initialize
	mov	eax, DWORD PTR [esi+16]
	add	eax, edi
	test	al, 1
	je	SHORT $LN60@initialize
$LN98@initialize:

; 3301 :             lev->dependencies[n] = dependencies +

	mov	edx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [eax+20]
	sar	ecx, 2
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+edi*4], eax
	mov	edi, DWORD PTR _n$[ebp]
$LN60@initialize:

; 3296 :       for (n=0; n < lev->region_size; n++)

	inc	edi
	mov	DWORD PTR _n$[ebp], edi
	cmp	edi, DWORD PTR [esi+20]
	jl	SHORT $LL62@initialize
	mov	eax, DWORD PTR tv2242[ebp]
	mov	ecx, DWORD PTR _lev_idx$4$[ebp]
	mov	edx, DWORD PTR tv2320[ebp]
$LN57@initialize:

; 3292 : 
; 3293 :   for (lev_idx=0; lev_idx < num_levels; lev_idx++)

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	inc	ecx
	add	eax, 52					; 00000034H
	mov	DWORD PTR _lev_idx$4$[ebp], ecx
	mov	DWORD PTR tv2242[ebp], eax
	cmp	ecx, DWORD PTR [edx]
	jl	$LL59@initialize
$LN58@initialize:

; 3302 :               (lev->dependencies[n] - dummy_dep_base);
; 3303 :           else
; 3304 :             assert(lev->dependencies[n] == NULL);
; 3305 :         }
; 3306 :     }
; 3307 : 
; 3308 :   // Now bind output components and input dependency components
; 3309 :   kd_multi_dwt_level *top_level = levels + (num_levels-1);

	imul	eax, DWORD PTR [edx], 52

; 3310 :   for (n=0; n < num_block_outputs; n++)

	xor	esi, esi
	mov	edi, DWORD PTR [edi+44]
	mov	DWORD PTR _n$[ebp], esi
	mov	DWORD PTR tv2214[ebp], eax
	cmp	DWORD PTR _num_block_outputs$GSCopy$[ebp], esi
	jle	$LN64@initialize
	npad	7
$LL65@initialize:

; 3311 :     {
; 3312 :       int loc = active_outputs[n] + top_level->canvas_min;

	mov	ecx, DWORD PTR _active_outputs$1$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	add	ecx, DWORD PTR [eax+edi-52]

; 3313 :       int idx = loc - top_level->region_min;

	sub	ecx, DWORD PTR [eax+edi-36]

; 3314 :       assert((idx >= 0) && (idx < top_level->region_size));
; 3315 :       kd_multi_line *line = top_level->components[idx];

	mov	eax, DWORD PTR [eax+edi-20]
	mov	edx, DWORD PTR [eax+ecx*4]

; 3316 :       assert(line == (components + idx));
; 3317 :       output_collection->components[output_indices[n]] = line;

	mov	eax, DWORD PTR _output_indices$1$[ebp]
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _output_collection$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+ecx*4], edx

; 3318 :       line->rev_offset = rev_offsets[n];

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _rev_offsets$1$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]

; 3319 :       line->irrev_offset = irrev_offsets[n];

	mov	ecx, DWORD PTR _irrev_offsets$1$[ebp]
	mov	DWORD PTR [edx+40], eax
	mov	eax, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+44], eax
	mov	esi, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR tv2214[ebp]
	inc	esi
	mov	DWORD PTR _n$[ebp], esi
	cmp	esi, DWORD PTR _num_block_outputs$GSCopy$[ebp]
	jl	SHORT $LL65@initialize
	mov	edx, DWORD PTR tv2320[ebp]
$LN64@initialize:

; 3320 :     }
; 3321 :   for (n=0; n < num_block_inputs; n++)

	xor	ecx, ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	DWORD PTR _num_block_inputs$GSCopy$[ebp], ecx
	jle	$LN67@initialize
$LL68@initialize:

; 3322 :     {
; 3323 :       kd_multi_line **dep_ref = NULL;
; 3324 :       int loc = active_inputs[n];

	mov	eax, DWORD PTR _active_inputs$1$[ebp]

; 3325 :       for (lev_idx=0; lev_idx < num_levels; lev_idx++)

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR _dep_ref$1$[ebp], 0
	mov	edi, DWORD PTR [eax+ecx*4]
	xor	ecx, ecx
	test	edx, edx
	jle	$LN103@initialize

; 3326 :         {
; 3327 :           kd_multi_dwt_level *lev = levels + lev_idx;

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	DWORD PTR tv2305[ebp], eax
$LL71@initialize:
	imul	esi, ecx, 52
	add	esi, eax

; 3328 :           if (lev_idx == 0)

	test	ecx, ecx
	jne	SHORT $LN99@initialize

; 3329 :             {
; 3330 :               if (loc < lev->canvas_low_size)

	mov	eax, DWORD PTR [esi+8]
	cmp	edi, eax
	jl	SHORT $LN159@initialize

; 3337 :                 }
; 3338 :               loc -= lev->canvas_low_size;

	sub	edi, eax
$LN99@initialize:

; 3339 :             }
; 3340 :           if (loc < lev->canvas_high_size)

	mov	eax, DWORD PTR [esi+12]
	cmp	edi, eax
	jl	SHORT $LN160@initialize

; 3346 :               break;
; 3347 :             }
; 3348 :           loc -= lev->canvas_high_size;

	inc	ecx
	sub	edi, eax
	cmp	ecx, edx
	jge	SHORT $LN103@initialize

; 3325 :       for (lev_idx=0; lev_idx < num_levels; lev_idx++)

	mov	eax, DWORD PTR tv2305[ebp]
	jmp	SHORT $LL71@initialize
$LN159@initialize:

; 3331 :                 { // This is a low-pass subband sample in the current level
; 3332 :                   int abs_loc = lev->canvas_min+(lev->canvas_min&1) + 2*loc;

	mov	ecx, DWORD PTR [esi]
	and	ecx, 1
	add	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+edi*2]

; 3333 :                   int rel_loc = abs_loc - lev->region_min;
; 3334 :                   if ((rel_loc >= 0) && (rel_loc < lev->region_size))
; 3335 :                     dep_ref = lev->dependencies[rel_loc];
; 3336 :                   break;

	jmp	SHORT $LN249@initialize
$LN160@initialize:

; 3341 :             { // This is a high-pass subband sample in the current level
; 3342 :               int abs_loc = lev->canvas_min+1-(lev->canvas_min&1) + 2*loc;

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+edi]
	mov	ecx, edx
	and	ecx, 1
	sub	eax, ecx
	lea	ecx, DWORD PTR [edx+1]
	add	ecx, eax
$LN249@initialize:

; 3343 :               int rel_loc = abs_loc - lev->region_min;

	sub	ecx, DWORD PTR [esi+16]

; 3344 :               if ((rel_loc >= 0) && (rel_loc < lev->region_size))

	js	SHORT $LN103@initialize
	cmp	ecx, DWORD PTR [esi+20]
	jge	SHORT $LN103@initialize

; 3345 :                 dep_ref = lev->dependencies[rel_loc];

	mov	eax, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _dep_ref$1$[ebp], eax
$LN103@initialize:

; 3349 :         }
; 3350 :       assert(dep_ref != NULL);
; 3351 :       *dep_ref = input_collection->components[input_indices[n]];

	mov	ecx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _input_indices$1$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _input_collection$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _dep_ref$1$[ebp]
	mov	DWORD PTR [ecx], eax

; 3352 :       if (*dep_ref == NULL)

	test	eax, eax
	je	SHORT $LN66@initialize

; 3353 :         continue;
; 3354 :       (*dep_ref)->num_consumers++;

	inc	DWORD PTR [eax+24]

; 3355 :       if (is_reversible)

	mov	eax, DWORD PTR tv2319[ebp]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN66@initialize

; 3356 :         (*dep_ref)->reversible = true;

	mov	eax, DWORD PTR [ecx]
	mov	BYTE PTR [eax+32], 1
$LN66@initialize:

; 3320 :     }
; 3321 :   for (n=0; n < num_block_inputs; n++)

	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR tv2320[ebp]
	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, DWORD PTR _num_block_inputs$GSCopy$[ebp]
	jl	$LL68@initialize
$LN67@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 147  :     ~kdu_kernels() { reset(); }

	lea	ecx, DWORD PTR _kernels$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	call	?reset@kdu_kernels@@AAEXXZ		; kdu_kernels::reset
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3358 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z$0:
	lea	ecx, DWORD PTR _kernels$[ebp]
	jmp	??1kdu_kernels@@QAE@XZ			; kdu_kernels::~kdu_kernels
__unwindfunclet$?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z$1:
	xor	ebx, ebx
	mov	eax, DWORD PTR $T7[ebp]
	mov	ecx, 52					; 00000034H
	mul	ecx
	seto	bl
	neg	ebx
	or	ebx, eax
	xor	eax, eax
	add	ebx, 4
	setb	al
	neg	eax
	or	eax, ebx
	push	eax
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
__unwindfunclet$?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z$3:
	call	___std_terminate
	ret	0
__ehhandler$?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-760]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?initialize@kd_multi_dwt_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z ENDP ; kd_multi_dwt_block::initialize
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??1kd_multi_dwt_block@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_multi_dwt_block@@UAE@XZ PROC			; kd_multi_dwt_block::~kd_multi_dwt_block, COMDAT
; _this$ = ecx

; 566  :       {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_multi_dwt_block@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 567  :         if (levels != NULL) delete[] levels;

	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [edi], OFFSET ??_7kd_multi_dwt_block@@6B@
	test	eax, eax
	je	SHORT $LN13@kd_multi_d
	push	OFFSET ??1kd_multi_dwt_level@@QAE@XZ	; kd_multi_dwt_level::~kd_multi_dwt_level
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	52					; 00000034H
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [esi], 52
	add	eax, 4
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN13@kd_multi_d:

; 568  :         if (steps != NULL) delete[] steps;

	mov	eax, DWORD PTR [edi+56]
	test	eax, eax
	je	SHORT $LN3@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@kd_multi_d:

; 569  :         if (f_coefficients != NULL) delete[] f_coefficients;

	mov	eax, DWORD PTR [edi+64]
	test	eax, eax
	je	SHORT $LN4@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN4@kd_multi_d:

; 570  :         if (i_coefficients != NULL) delete[] i_coefficients;

	mov	eax, DWORD PTR [edi+68]
	test	eax, eax
	je	SHORT $LN5@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@kd_multi_d:

; 571  :         if (src_bufs32 != NULL) { delete[] src_bufs32;  src_bufs32=NULL; }

	mov	eax, DWORD PTR [edi+76]
	test	eax, eax
	je	SHORT $LN6@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [edi+76], 0
$LN6@kd_multi_d:

; 199  :         if (components != NULL) delete[] components;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [edi], OFFSET ??_7kd_multi_block@@6B@
	test	eax, eax
	je	SHORT $LN22@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN22@kd_multi_d:

; 200  :         if (dependencies != NULL) delete[] dependencies;

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN23@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN23@kd_multi_d:

; 572  :         assert(src_bufs16 == NULL); // `src_bufs32' & `src_bufs16' are aliased
; 573  :       }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1kd_multi_dwt_block@@UAE@XZ$0:
	call	___std_terminate
	ret	0
__ehhandler$??1kd_multi_dwt_block@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_multi_dwt_block@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_multi_dwt_block@@UAE@XZ ENDP			; kd_multi_dwt_block::~kd_multi_dwt_block
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??0kd_multi_dwt_block@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0kd_multi_dwt_block@@QAE@XZ PROC			; kd_multi_dwt_block::kd_multi_dwt_block, COMDAT
; _this$ = ecx

; 558  :     kd_multi_dwt_block()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 564  :       }

	mov	eax, ecx

; 193  :         num_components = 0;  components = NULL;  next = prev = NULL;

	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+32], 0

; 194  :         num_dependencies = num_available_dependencies = 0; dependencies = NULL;

	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0

; 195  :         outstanding_consumers = 0;

	mov	DWORD PTR [ecx+28], 0

; 559  :       {

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_dwt_block@@6B@

; 560  :         is_null_transform=false;  num_levels=0;  levels=NULL;

	mov	BYTE PTR [ecx+4], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0

; 561  :         num_steps=max_step_length=0;  steps=NULL;

	mov	DWORD PTR [ecx+72], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0

; 562  :         num_coefficients=0;  f_coefficients=NULL;  i_coefficients=NULL;

	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+64], 0
	mov	DWORD PTR [ecx+68], 0

; 563  :         src_bufs32 = NULL;  assert(src_bufs16 == NULL);

	mov	DWORD PTR [ecx+76], 0

; 564  :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??0kd_multi_dwt_block@@QAE@XZ ENDP			; kd_multi_dwt_block::kd_multi_dwt_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??_Ekd_multi_dwt_level@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekd_multi_dwt_level@@QAEPAXI@Z PROC			; kd_multi_dwt_level::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekd_multi_dwt_level@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kd_multi_dwt_level@@QAE@XZ	; kd_multi_dwt_level::~kd_multi_dwt_level
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	52					; 00000034H
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	imul	ecx, DWORD PTR [edi], 52
	add	ecx, 4
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:

; 504  :         if (components != NULL) delete[] components;

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN7@vector
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@vector:

; 505  :         if (dependencies != NULL) delete[] dependencies;

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN8@vector
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@vector:
	test	bl, 1
	je	SHORT $LN4@vector
	push	52					; 00000034H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Ekd_multi_dwt_level@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekd_multi_dwt_level@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekd_multi_dwt_level@@QAEPAXI@Z ENDP			; kd_multi_dwt_level::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??1kd_multi_dwt_level@@QAE@XZ
_TEXT	SEGMENT
??1kd_multi_dwt_level@@QAE@XZ PROC			; kd_multi_dwt_level::~kd_multi_dwt_level, COMDAT
; _this$ = ecx

; 503  :       {

	push	esi
	mov	esi, ecx

; 504  :         if (components != NULL) delete[] components;

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN2@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_multi_d:

; 505  :         if (dependencies != NULL) delete[] dependencies;

	mov	eax, DWORD PTR [esi+36]
	pop	esi
	test	eax, eax
	je	SHORT $LN3@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN3@kd_multi_d:

; 506  :       }

	ret	0
??1kd_multi_dwt_level@@QAE@XZ ENDP			; kd_multi_dwt_level::~kd_multi_dwt_level
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??0kd_multi_dwt_level@@QAE@XZ
_TEXT	SEGMENT
??0kd_multi_dwt_level@@QAE@XZ PROC			; kd_multi_dwt_level::kd_multi_dwt_level, COMDAT
; _this$ = ecx

; 497  :       {
; 498  :         canvas_min = canvas_size = canvas_low_size = canvas_high_size = 0;

	mov	DWORD PTR [ecx+12], 0

; 499  :         region_min = region_size = region_low_size = region_high_size = 0;
; 500  :         components = NULL;  dependencies = NULL;
; 501  :       }

	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	ret	0
??0kd_multi_dwt_level@@QAE@XZ ENDP			; kd_multi_dwt_level::kd_multi_dwt_level
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_multi_dependency_block@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_multi_dependency_block@@UAEPAXI@Z PROC		; kd_multi_dependency_block::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_multi_dependency_block@@UAE@XZ	; kd_multi_dependency_block::~kd_multi_dependency_block
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	76					; 0000004cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_multi_dependency_block@@UAEPAXI@Z ENDP		; kd_multi_dependency_block::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?create_short_matrix@kd_multi_dependency_block@@AAEXXZ
_TEXT	SEGMENT
tv1199 = -40						; size = 8
tv1192 = -40						; size = 8
_n$2$ = -36						; size = 4
tv1162 = -32						; size = 4
tv1146 = -32						; size = 4
tv1145 = -28						; size = 4
_n$1$ = -28						; size = 4
_factor$1$ = -24					; size = 4
_this$1$ = -20						; size = 4
tv1150 = -16						; size = 4
_m$2$ = -16						; size = 4
_N$1$ = -12						; size = 4
tv1161 = -8						; size = 4
tv1147 = -4						; size = 4
_max_val$1$ = -4					; size = 4
?create_short_matrix@kd_multi_dependency_block@@AAEXXZ PROC ; kd_multi_dependency_block::create_short_matrix, COMDAT
; _this$ = ecx

; 2745 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, ecx

; 2746 :   if ((short_matrix != NULL) || is_reversible)

	cmp	DWORD PTR [eax+64], 0
	push	edi
	lea	edi, DWORD PTR [eax+64]
	mov	DWORD PTR _this$1$[ebp], eax
	mov	DWORD PTR tv1161[ebp], edi
	jne	$LN21@create_sho
	cmp	BYTE PTR [eax+40], 0
	jne	$LN21@create_sho

; 2747 :     return;
; 2748 : 
; 2749 :   int m, n, N=num_components;  assert(N == num_dependencies);

	push	esi
	mov	esi, DWORD PTR [eax+8]
	xorps	xmm1, xmm1
	mov	DWORD PTR _N$1$[ebp], esi

; 2750 :   float val, max_val = 0.0F;

	movss	DWORD PTR _max_val$1$[ebp], xmm1

; 2751 :   for (m=0; m < N; m++)

	test	esi, esi
	jle	$LN3@create_sho

; 2753 :       {
; 2754 :         val = f_matrix[m*N + n];

	movss	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	xor	ecx, ecx
	mov	DWORD PTR tv1150[ebp], ecx
	xor	edi, edi
	npad	4
$LL4@create_sho:

; 2752 :     for (n=0; n < m; n++)

	xor	edx, edx
	cmp	edi, 4
	jl	$LC58@create_sho

; 2753 :       {
; 2754 :         val = f_matrix[m*N + n];

	mov	eax, DWORD PTR [eax+56]
	add	ecx, 2
	mov	edx, DWORD PTR tv1150[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+edx*4]
	lea	edx, DWORD PTR [edi-4]
	add	eax, 4
	shr	edx, 2
	inc	edx
	lea	esi, DWORD PTR [edx*4]
	mov	DWORD PTR _n$1$[ebp], esi
	mov	esi, DWORD PTR _N$1$[ebp]
$LL67@create_sho:
	movss	xmm3, DWORD PTR [ecx-8]

; 2755 :         if (val > max_val)

	comiss	xmm3, xmm1
	jbe	SHORT $LN59@create_sho

; 2756 :           max_val = val;

	movaps	xmm1, xmm3
	jmp	SHORT $LN60@create_sho
$LN59@create_sho:

; 2757 :         else if (val < -max_val)

	movaps	xmm0, xmm1
	xorps	xmm0, xmm2
	comiss	xmm0, xmm3
	jbe	SHORT $LN60@create_sho

; 2758 :           max_val = -val;

	movaps	xmm1, xmm3
	xorps	xmm1, xmm2
$LN60@create_sho:

; 2755 :         if (val > max_val)

	movss	xmm3, DWORD PTR [eax]
	comiss	xmm3, xmm1
	jbe	SHORT $LN61@create_sho

; 2756 :           max_val = val;

	movaps	xmm1, xmm3
	jmp	SHORT $LN62@create_sho
$LN61@create_sho:

; 2757 :         else if (val < -max_val)

	movaps	xmm0, xmm1
	xorps	xmm0, xmm2
	comiss	xmm0, xmm3
	jbe	SHORT $LN62@create_sho

; 2758 :           max_val = -val;

	movaps	xmm1, xmm3
	xorps	xmm1, xmm2
$LN62@create_sho:

; 2755 :         if (val > max_val)

	movss	xmm3, DWORD PTR [ecx]
	comiss	xmm3, xmm1
	jbe	SHORT $LN63@create_sho

; 2756 :           max_val = val;

	movaps	xmm1, xmm3
	jmp	SHORT $LN64@create_sho
$LN63@create_sho:

; 2757 :         else if (val < -max_val)

	movaps	xmm0, xmm1
	xorps	xmm0, xmm2
	comiss	xmm0, xmm3
	jbe	SHORT $LN64@create_sho

; 2758 :           max_val = -val;

	movaps	xmm1, xmm3
	xorps	xmm1, xmm2
$LN64@create_sho:

; 2755 :         if (val > max_val)

	movss	xmm3, DWORD PTR [ecx+4]
	comiss	xmm3, xmm1
	jbe	SHORT $LN65@create_sho

; 2756 :           max_val = val;

	movaps	xmm1, xmm3
	jmp	SHORT $LN66@create_sho
$LN65@create_sho:

; 2757 :         else if (val < -max_val)

	movaps	xmm0, xmm1
	xorps	xmm0, xmm2
	comiss	xmm0, xmm3
	jbe	SHORT $LN66@create_sho

; 2758 :           max_val = -val;

	movaps	xmm1, xmm3
	xorps	xmm1, xmm2
$LN66@create_sho:
	add	eax, 16					; 00000010H
	add	ecx, 16					; 00000010H
	sub	edx, 1
	jne	$LL67@create_sho
	mov	edx, DWORD PTR _n$1$[ebp]
	mov	ecx, DWORD PTR tv1150[ebp]
	mov	eax, DWORD PTR _this$1$[ebp]
	movss	DWORD PTR _max_val$1$[ebp], xmm1
$LC58@create_sho:

; 2752 :     for (n=0; n < m; n++)

	cmp	edx, edi
	jge	SHORT $LN2@create_sho

; 2753 :       {
; 2754 :         val = f_matrix[m*N + n];

	mov	eax, DWORD PTR [eax+56]
	add	ecx, edx
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, edi
	sub	ecx, edx
	npad	4
$LC41@create_sho:
	movss	xmm3, DWORD PTR [eax]

; 2755 :         if (val > max_val)

	comiss	xmm3, xmm1
	jbe	SHORT $LN42@create_sho

; 2756 :           max_val = val;

	movaps	xmm1, xmm3
	jmp	SHORT $LN43@create_sho
$LN42@create_sho:

; 2757 :         else if (val < -max_val)

	movaps	xmm0, xmm1
	xorps	xmm0, xmm2
	comiss	xmm0, xmm3
	jbe	SHORT $LN43@create_sho

; 2758 :           max_val = -val;

	movaps	xmm1, xmm3
	xorps	xmm1, xmm2
$LN43@create_sho:

; 2752 :     for (n=0; n < m; n++)

	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LC41@create_sho
	mov	ecx, DWORD PTR tv1150[ebp]
	movss	DWORD PTR _max_val$1$[ebp], xmm1
$LN2@create_sho:

; 2751 :   for (m=0; m < N; m++)

	mov	eax, DWORD PTR _this$1$[ebp]
	inc	edi
	add	ecx, esi
	mov	DWORD PTR tv1150[ebp], ecx
	cmp	edi, esi
	jl	$LL4@create_sho
	mov	edi, DWORD PTR tv1161[ebp]
$LN3@create_sho:

; 2759 :       }
; 2760 : 
; 2761 :   short_matrix = new kdu_int16[N*N];

	mov	eax, esi
	xor	ecx, ecx
	imul	eax, esi
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 2762 : 
; 2763 :   float factor = 1.0F;
; 2764 :   for (short_downshift=0; (factor*max_val) <= 16383.0F; factor*=2.0F)

	mov	ecx, DWORD PTR _this$1$[ebp]
	add	esp, 4
	movss	xmm3, DWORD PTR __real@467ffc00
	movss	xmm1, DWORD PTR _max_val$1$[ebp]
	comiss	xmm3, xmm1
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [ecx+68], 0
	movss	xmm2, DWORD PTR __real@3f800000
	movss	DWORD PTR _factor$1$[ebp], xmm2
	jb	SHORT $LN9@create_sho
	movss	xmm4, DWORD PTR __real@40000000
	xor	eax, eax
$LL10@create_sho:
	mulss	xmm2, xmm4

; 2765 :     short_downshift++;

	inc	eax
	movaps	xmm0, xmm2
	mulss	xmm0, xmm1
	comiss	xmm3, xmm0
	jae	SHORT $LL10@create_sho
	movss	DWORD PTR _factor$1$[ebp], xmm2
	mov	DWORD PTR [ecx+68], eax
$LN9@create_sho:

; 2766 :   for (m=0; m < N; m++)

	mov	edx, DWORD PTR _N$1$[ebp]
	xor	eax, eax
	mov	DWORD PTR _m$2$[ebp], eax
	test	edx, edx
	jle	$LN78@create_sho
	xor	edi, edi
	xor	ecx, ecx
	mov	DWORD PTR tv1147[ebp], edi
	mov	DWORD PTR tv1145[ebp], ecx
	npad	7
$LL13@create_sho:

; 2767 :     {
; 2768 :       for (n=0; n < m; n++)

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN15@create_sho

; 2775 :             ival = -(1<<15);
; 2776 :           short_matrix[m*N+n] = (kdu_int16) ival;

	mov	edi, ecx
	npad	8
$LL16@create_sho:

; 2769 :         {
; 2770 :           val = f_matrix[n] * factor;

	mov	eax, DWORD PTR _this$1$[ebp]

; 2771 :           int ival = (int) floor(val+0.5);

	sub	esp, 8
	mov	eax, DWORD PTR [eax+56]
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, xmm2
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv1199[ebp], xmm0
	fld	QWORD PTR tv1199[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv1192[ebp]
	cvttsd2si ecx, QWORD PTR tv1192[ebp]
	add	esp, 8

; 2772 :           if (ival >= (1<<15))

	cmp	ecx, 32768				; 00008000H
	jl	SHORT $LN25@create_sho

; 2773 :             ival = (1<<15)-1;

	mov	ecx, 32767				; 00007fffH
	jmp	SHORT $LN27@create_sho
$LN25@create_sho:

; 2774 :           else if (ival < -(1<<15))

	cmp	ecx, -32768				; ffff8000H
	mov	eax, -32768				; ffff8000H
	cmovl	ecx, eax
$LN27@create_sho:

; 2775 :             ival = -(1<<15);
; 2776 :           short_matrix[m*N+n] = (kdu_int16) ival;

	mov	eax, DWORD PTR tv1161[ebp]
	inc	esi
	movss	xmm2, DWORD PTR _factor$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	WORD PTR [edi+eax], cx
	add	edi, 2
	mov	eax, DWORD PTR _m$2$[ebp]
	cmp	esi, eax
	jl	SHORT $LL16@create_sho
	mov	edi, DWORD PTR tv1147[ebp]
	mov	edx, DWORD PTR _N$1$[ebp]
$LN15@create_sho:

; 2777 :         }
; 2778 :       for (; n < N; n++)

	mov	ecx, edx
	sub	ecx, esi
	cmp	esi, edx
	jge	$LN11@create_sho
	cmp	ecx, 8
	jb	SHORT $LN77@create_sho
	lea	eax, DWORD PTR [edi+edx]
	mov	edi, DWORD PTR tv1161[ebp]
	lea	eax, DWORD PTR [eax-1]
	mov	edx, DWORD PTR [edi]
	mov	edi, DWORD PTR tv1147[ebp]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR tv1146[ebp], eax
	lea	eax, DWORD PTR [edi+esi]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	edx, DWORD PTR _N$1$[ebp]
	cmp	eax, DWORD PTR tv1161[ebp]
	ja	SHORT $LN49@create_sho
	mov	eax, DWORD PTR tv1161[ebp]
	cmp	DWORD PTR tv1146[ebp], eax
	jae	SHORT $LN48@create_sho
$LN49@create_sho:
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN79@create_sho
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN79@create_sho:
	mov	eax, edx
	sub	eax, ecx
	mov	ecx, esi
	mov	DWORD PTR tv1162[ebp], ecx
$LL19@create_sho:
	add	esi, 8
	cmp	esi, eax
	jl	SHORT $LL19@create_sho

; 2779 :         short_matrix[m*N+n] = 0;

	sub	eax, ecx
	mov	DWORD PTR _n$2$[ebp], esi
	mov	esi, DWORD PTR tv1161[ebp]
	add	eax, 7
	cdq
	and	edx, 7
	lea	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR tv1162[ebp]
	add	edx, edi
	sar	ecx, 3
	mov	edi, DWORD PTR [esi]
	xor	eax, eax
	shl	ecx, 4
	shr	ecx, 1
	shr	ecx, 1
	lea	edi, DWORD PTR [edi+edx*2]
	mov	esi, DWORD PTR _n$2$[ebp]
	mov	edx, DWORD PTR _N$1$[ebp]
	rep stosd
	adc	ecx, ecx
	rep stosw
$LN77@create_sho:
	mov	eax, DWORD PTR tv1161[ebp]
$LN48@create_sho:
	mov	edi, DWORD PTR tv1147[ebp]

; 2777 :         }
; 2778 :       for (; n < N; n++)

	cmp	esi, edx
	jge	SHORT $LN76@create_sho
	npad	5
$LL47@create_sho:

; 2779 :         short_matrix[m*N+n] = 0;

	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [edi+esi]
	xor	edi, edi
	inc	esi
	mov	WORD PTR [eax+ecx*2], di
	mov	edi, DWORD PTR tv1147[ebp]
	mov	eax, DWORD PTR tv1161[ebp]
	cmp	esi, edx
	jl	SHORT $LL47@create_sho
$LN76@create_sho:
	mov	eax, DWORD PTR _m$2$[ebp]
$LN11@create_sho:

; 2766 :   for (m=0; m < N; m++)

	mov	ecx, DWORD PTR tv1145[ebp]
	inc	eax
	add	edi, edx
	mov	DWORD PTR _m$2$[ebp], eax
	mov	DWORD PTR tv1147[ebp], edi
	lea	ecx, DWORD PTR [ecx+edx*2]
	mov	DWORD PTR tv1145[ebp], ecx
	cmp	eax, edx
	jl	$LL13@create_sho
$LN78@create_sho:
	pop	esi
$LN21@create_sho:
	pop	edi

; 2780 :     }
; 2781 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?create_short_matrix@kd_multi_dependency_block@@AAEXXZ ENDP ; kd_multi_dependency_block::create_short_matrix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?perform_inverse@kd_multi_dependency_block@@UAEXXZ
_TEXT	SEGMENT
_e$2 = -172						; size = 20
_dep$1$ = -152						; size = 4
_dst$1$ = -148						; size = 4
tv2232 = -148						; size = 4
_width$1$ = -148					; size = 4
_N$1$ = -144						; size = 4
_dst$1$ = -140						; size = 4
_divisor$1$ = -140					; size = 4
_downshift$1$ = -140					; size = 4
tv2206 = -140						; size = 4
_w$5$ = -140						; size = 4
_factor$1$ = -136					; size = 4
tv2235 = -136						; size = 4
tv2207 = -136						; size = 4
_w$2$ = -136						; size = 4
_w$1$ = -136						; size = 4
_src$1$ = -132						; size = 4
tv2220 = -132						; size = 4
tv2203 = -132						; size = 4
tv2191 = -132						; size = 4
_downshift$1$ = -128					; size = 4
_dst$1$ = -128						; size = 4
_src$1$ = -128						; size = 4
_line$1$ = -124						; size = 4
tv2238 = -120						; size = 4
tv2197 = -120						; size = 4
tv2192 = -120						; size = 4
tv2188 = -120						; size = 4
_m$1$ = -116						; size = 4
_src$1$ = -112						; size = 4
_offset$1$ = -112					; size = 4
_src$1$ = -112						; size = 4
tv2229 = -112						; size = 4
tv2189 = -112						; size = 4
tv2219 = -108						; size = 4
tv2195 = -108						; size = 4
_dst$1$ = -108						; size = 4
_this$GSCopy$1$ = -104					; size = 4
_offset$1$ = -100					; size = 4
tv2196 = -100						; size = 4
tv2194 = -100						; size = 4
tv2193 = -100						; size = 4
tv2190 = -100						; size = 4
_text$3 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?perform_inverse@kd_multi_dependency_block@@UAEXXZ PROC	; kd_multi_dependency_block::perform_inverse, COMDAT
; _this$ = ecx

; 2917 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?perform_inverse@kd_multi_dependency_block@@UAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi

; 2918 :   int N = num_components;

	mov	eax, DWORD PTR [edi+8]

; 2919 :   int m, n;
; 2920 : 
; 2921 :   assert(num_dependencies == N);
; 2922 :   for (m=0; m < N; m++)

	xor	edx, edx
	mov	DWORD PTR _N$1$[ebp], eax
	mov	DWORD PTR _m$1$[ebp], edx
	test	eax, eax
	jle	$LN3@perform_in
	xorps	xmm0, xmm0
	npad	5
$LL4@perform_in:

; 2924 :       kd_multi_line *line = components + m;

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, edx
	shl	ecx, 4
	sub	ecx, edx

; 2926 :       int w, width=line->line.get_width();
; 2927 :       if (!is_reversible)

	cmp	BYTE PTR [edi+40], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 544  :         return width;

	mov	esi, DWORD PTR [eax+ecx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2924 :       kd_multi_line *line = components + m;

	lea	ecx, DWORD PTR [eax+ecx*4]

; 2925 :       kd_multi_line *dep = dependencies[m];

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _line$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 544  :         return width;

	mov	DWORD PTR _width$1$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2925 :       kd_multi_line *dep = dependencies[m];

	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dep$1$[ebp], eax

; 2926 :       int w, width=line->line.get_width();
; 2927 :       if (!is_reversible)

	jne	$LN47@perform_in
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ecx+6], 2
	jne	$LN49@perform_in
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _dst$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2929 :           if (line->line.get_buf32() != NULL)

	test	eax, eax
	je	$LN49@perform_in

; 2930 :             { // Perform 32-bit floating point irreversible processing
; 2931 :               kdu_sample32 *dst=line->line.get_buf32();
; 2932 :               for (n=0; n < m; n++)

	test	edx, edx
	jle	$LN21@perform_in
	mov	ecx, edx
	mov	DWORD PTR tv2229[ebp], edx
	imul	ecx, DWORD PTR _N$1$[ebp]
	xor	eax, eax
	mov	DWORD PTR tv2197[ebp], eax
	shl	ecx, 2
	mov	DWORD PTR tv2196[ebp], ecx
$LL7@perform_in:

; 2933 :                 {
; 2934 :                   kdu_sample32 *src = components[n].line.get_buf32();

	mov	edx, DWORD PTR [edi+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edx+eax+6], 2
	je	SHORT $LN79@perform_in
	xor	edx, edx
	jmp	SHORT $LN200@perform_in
$LN79@perform_in:
	mov	edx, DWORD PTR [edx+eax+8]
$LN200@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2935 :                   float factor = f_matrix[m*N+n];

	mov	eax, DWORD PTR [edi+56]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	DWORD PTR _src$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2935 :                   float factor = f_matrix[m*N+n];

	movss	xmm2, DWORD PTR [ecx+eax]

; 2936 :                   if (factor == 0.0F)

	ucomiss	xmm2, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN5@perform_in

; 2937 :                     continue;
; 2938 :                   for (w=0; w < width; w++)

	xor	edi, edi
	cmp	esi, 4
	jl	$LC169@perform_in
	mov	eax, DWORD PTR _dst$1$[ebp]
	lea	ecx, DWORD PTR [esi-4]
	lea	edi, DWORD PTR [edx+12]
	shr	ecx, 2
	sub	edx, DWORD PTR _dst$1$[ebp]
	add	eax, 4
	inc	ecx
	mov	DWORD PTR tv2203[ebp], edx
	lea	esi, DWORD PTR [ecx*4]
	mov	DWORD PTR _w$1$[ebp], esi
	mov	esi, DWORD PTR _width$1$[ebp]
	npad	9
$LL170@perform_in:

; 2939 :                     dst[w].fval -= src[w].fval * factor;

	movss	xmm1, DWORD PTR [edi-12]
	movss	xmm0, DWORD PTR [eax-4]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [eax-4], xmm0
	movss	xmm1, DWORD PTR [edx+eax]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [eax], xmm0
	movss	xmm1, DWORD PTR [edi-4]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm1, DWORD PTR [edi]
	add	edi, 16					; 00000010H
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [eax+8], xmm0
	add	eax, 16					; 00000010H
	sub	ecx, 1
	jne	SHORT $LL170@perform_in
	mov	edx, DWORD PTR _src$1$[ebp]
	mov	edi, DWORD PTR _w$1$[ebp]
	mov	ecx, DWORD PTR tv2196[ebp]
$LC169@perform_in:

; 2937 :                     continue;
; 2938 :                   for (w=0; w < width; w++)

	cmp	edi, esi
	jge	SHORT $LN195@perform_in
	mov	ecx, DWORD PTR _dst$1$[ebp]
	sub	edx, ecx
	lea	eax, DWORD PTR [ecx+edi*4]
	mov	ecx, esi
	sub	ecx, edi
$LC10@perform_in:

; 2939 :                     dst[w].fval -= src[w].fval * factor;

	movss	xmm1, DWORD PTR [eax+edx]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LC10@perform_in
	mov	ecx, DWORD PTR tv2196[ebp]
$LN195@perform_in:
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN5@perform_in:

; 2930 :             { // Perform 32-bit floating point irreversible processing
; 2931 :               kdu_sample32 *dst=line->line.get_buf32();
; 2932 :               for (n=0; n < m; n++)

	mov	eax, DWORD PTR tv2197[ebp]
	add	ecx, 4
	add	eax, 60					; 0000003cH
	mov	DWORD PTR tv2196[ebp], ecx
	sub	DWORD PTR tv2229[ebp], 1
	xorps	xmm0, xmm0
	mov	DWORD PTR tv2197[ebp], eax
	jne	$LL7@perform_in

; 2940 :                 }
; 2941 :             }
; 2942 :           else if (m > 0)

	jmp	$LN196@perform_in
$LN49@perform_in:
	test	edx, edx
	jle	$LN21@perform_in

; 2943 :             { // Perform 16-bit fixed point irreversible processing
; 2944 :               if (short_matrix == NULL)

	cmp	DWORD PTR [edi+64], 0
	jne	SHORT $LN53@perform_in

; 2945 :                 create_short_matrix();

	mov	ecx, edi
	call	?create_short_matrix@kd_multi_dependency_block@@AAEXXZ ; kd_multi_dependency_block::create_short_matrix
	mov	ecx, DWORD PTR _line$1$[ebp]
$LN53@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN83@perform_in
	mov	eax, DWORD PTR [ecx+8]
	jmp	SHORT $LN201@perform_in
$LN83@perform_in:
	xor	eax, eax
$LN201@perform_in:
	mov	DWORD PTR _dst$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2948 :               kdu_int32 offset = (1<<downshift)>>1; // Rounding offset

	mov	edx, 1
	mov	eax, DWORD PTR [edi+68]

; 2949 :               if (accumulator == NULL)

	add	edi, 72					; 00000048H
	mov	ecx, eax
	mov	DWORD PTR _downshift$1$[ebp], eax
	shl	edx, cl
	sar	edx, 1
	cmp	DWORD PTR [edi], 0
	mov	DWORD PTR _offset$1$[ebp], edx
	mov	DWORD PTR tv2220[ebp], edi
	jne	SHORT $LN54@perform_in

; 2950 :                 accumulator = new kdu_int32[width];

	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, DWORD PTR _offset$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi], eax
$LN54@perform_in:

; 2951 :               for (w=0; w < width; w++)

	xor	ecx, ecx
	test	esi, esi
	jle	$LN12@perform_in
	cmp	esi, 4
	jb	SHORT $LN146@perform_in

; 2952 :                 accumulator[w] = offset;

	mov	eax, DWORD PTR [edi]
	lea	edx, DWORD PTR [esi-1]
	lea	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv2207[ebp], edx
	mov	edx, DWORD PTR _offset$1$[ebp]
	cmp	eax, edi
	ja	SHORT $LN147@perform_in
	cmp	DWORD PTR tv2207[ebp], edi
	jae	SHORT $LN146@perform_in
$LN147@perform_in:
	mov	eax, esi
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN198@perform_in
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN198@perform_in:
	mov	edx, esi
	sub	edx, eax
	npad	1
$LL13@perform_in:

; 2951 :               for (w=0; w < width; w++)

	add	ecx, 4
	cmp	ecx, edx
	jl	SHORT $LL13@perform_in

; 2952 :                 accumulator[w] = offset;

	mov	edi, DWORD PTR [edi]
	lea	eax, DWORD PTR [edx+3]
	cdq
	and	edx, 3
	mov	DWORD PTR _w$2$[ebp], ecx
	lea	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR _offset$1$[ebp]
	sar	ecx, 2
	mov	eax, edx
	shl	ecx, 4
	shr	ecx, 2
	rep stosd
	mov	ecx, DWORD PTR _w$2$[ebp]
	mov	edi, DWORD PTR tv2220[ebp]
$LN146@perform_in:

; 2951 :               for (w=0; w < width; w++)

	cmp	ecx, esi
	jge	SHORT $LN12@perform_in
	npad	7
$LL145@perform_in:

; 2952 :                 accumulator[w] = offset;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+ecx*4], edx
	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LL145@perform_in
$LN12@perform_in:

; 2953 :               for (n=0; n < m; n++)

	mov	eax, DWORD PTR _m$1$[ebp]
	test	eax, eax
	jle	$LN15@perform_in
	mov	ecx, eax
	mov	DWORD PTR tv2238[ebp], eax
	imul	ecx, DWORD PTR _N$1$[ebp]
	xor	edx, edx
	mov	DWORD PTR tv2195[ebp], edx
	add	ecx, ecx
	mov	DWORD PTR tv2194[ebp], ecx
	npad	5
$LL16@perform_in:

; 2954 :                 {
; 2955 :                   kdu_sample16 *src = components[n].line.get_buf16();

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [eax+edx+6], 2
	je	SHORT $LN87@perform_in
	mov	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _src$1$[ebp], ecx
	mov	ecx, DWORD PTR tv2194[ebp]
	jmp	SHORT $LN88@perform_in
$LN87@perform_in:
	mov	DWORD PTR _src$1$[ebp], 0
$LN88@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2956 :                   int factor = short_matrix[m*N + n];

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+64]
	movsx	eax, WORD PTR [ecx+eax]
	mov	DWORD PTR _factor$1$[ebp], eax

; 2957 :                   if (factor == 0)

	test	eax, eax
	je	SHORT $LN14@perform_in

; 2958 :                     continue;
; 2959 :                   for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN189@perform_in
	npad	6
$LL19@perform_in:

; 2960 :                     accumulator[w] += src[w].ival * factor;

	mov	eax, DWORD PTR _src$1$[ebp]
	mov	ecx, DWORD PTR [edi]
	movsx	eax, WORD PTR [eax+edx*2]
	imul	eax, DWORD PTR _factor$1$[ebp]
	add	DWORD PTR [ecx+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL19@perform_in
	mov	ecx, DWORD PTR tv2194[ebp]
$LN189@perform_in:
	mov	edx, DWORD PTR tv2195[ebp]
$LN14@perform_in:

; 2953 :               for (n=0; n < m; n++)

	add	ecx, 2
	add	edx, 60					; 0000003cH
	sub	DWORD PTR tv2238[ebp], 1
	mov	DWORD PTR tv2194[ebp], ecx
	mov	DWORD PTR tv2195[ebp], edx
	jne	SHORT $LL16@perform_in
$LN15@perform_in:

; 2961 :                 }
; 2962 :               for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN196@perform_in
	npad	10
$LL22@perform_in:

; 2963 :                 dst[w].ival -= (kdu_int16)(accumulator[w] >> downshift);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	mov	ecx, DWORD PTR _dst$1$[ebp]
	sub	WORD PTR [ecx+edx*2], ax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL22@perform_in
$LN196@perform_in:
	mov	edx, DWORD PTR _m$1$[ebp]
	mov	ecx, DWORD PTR _line$1$[ebp]
$LN21@perform_in:

; 2964 :             }
; 2965 :           if (dep != NULL)

	mov	esi, DWORD PTR _dep$1$[ebp]

; 2969 :               dep->copy(line,0,-dep->irrev_offset-scale*f_offsets[m]);

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	test	esi, esi
	je	$LN2@perform_in

; 2966 :             {
; 2967 :               assert(!(dep->reversible || line->reversible));
; 2968 :               float scale = (1<<line->bit_depth) / (float)(1<<dep->bit_depth);

	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR [esi+36]

; 2969 :               dep->copy(line,0,-dep->irrev_offset-scale*f_offsets[m]);

	movss	xmm2, DWORD PTR [esi+44]
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	movd	xmm1, eax
	mov	eax, 1
	shl	eax, cl
	cvtdq2ps xmm1, xmm1
	push	ecx
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mov	eax, DWORD PTR [edi+60]
	divss	xmm1, xmm0
	mulss	xmm1, DWORD PTR [eax+edx*4]
	subss	xmm2, xmm1
	movss	DWORD PTR [esp], xmm2
	push	0
	push	DWORD PTR _line$1$[ebp]

; 2970 :             }
; 2971 :         }
; 2972 :       else

	jmp	$LN203@perform_in
$LN47@perform_in:

; 2973 :         {
; 2974 :           if (m > 0)

	test	edx, edx
	jle	$LN45@perform_in

; 2975 :             {
; 2976 :               int downshift, divisor = i_matrix[m*N+m];

	mov	ecx, DWORD PTR _N$1$[ebp]
	mov	eax, DWORD PTR [edi+48]
	inc	ecx
	imul	ecx, edx
	mov	eax, DWORD PTR [eax+ecx*4]

; 2977 :               for (downshift=0; (1<<downshift) < divisor; downshift++);

	xor	ecx, ecx
	mov	DWORD PTR _divisor$1$[ebp], eax
	mov	DWORD PTR _downshift$1$[ebp], ecx
	lea	edi, DWORD PTR [ecx+1]
	cmp	eax, edi
	jle	SHORT $LN24@perform_in
$LL25@perform_in:
	rol	edi, 1
	inc	ecx
	cmp	edi, eax
	jl	SHORT $LL25@perform_in
	mov	DWORD PTR _downshift$1$[ebp], ecx
$LN24@perform_in:

; 2978 :               if ((1<<downshift) != divisor)

	cmp	edi, eax
	je	$LN58@perform_in

; 2979 :                 { KDU_ERROR(e,0x23090503); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0OO@CDGHEAGO@Multi?9component?5reversible?5depen@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2979 :                 { KDU_ERROR(e,0x23090503); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$2[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _divisor$1$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$3[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$3[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	eax
	mov	eax, DWORD PTR _e$2[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2985 :                 }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN58@perform_in:

; 2986 :               kdu_int32 offset = ((1<<downshift)>>1);
; 2987 :               if (accumulator == NULL)

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	add	eax, 72					; 00000048H
	sar	edi, 1
	mov	DWORD PTR _offset$1$[ebp], edi
	mov	DWORD PTR tv2219[ebp], eax
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN59@perform_in

; 2988 :                 accumulator = new kdu_int32[width];

	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, DWORD PTR tv2219[ebp]
	add	esp, 4
	mov	DWORD PTR [edx], eax
	mov	eax, edx
$LN59@perform_in:

; 2989 :               for (w=0; w < width; w++)

	xor	ecx, ecx
	test	esi, esi
	jle	$LN27@perform_in
	cmp	esi, 4
	jb	SHORT $LN149@perform_in

; 2990 :                 accumulator[w] = offset;

	mov	edx, DWORD PTR [eax]
	lea	edi, DWORD PTR [esi-1]
	mov	DWORD PTR tv2235[ebp], edx
	lea	edi, DWORD PTR [edx+edi*4]
	mov	DWORD PTR tv2206[ebp], edi
	mov	edi, DWORD PTR _offset$1$[ebp]
	cmp	edx, eax
	ja	SHORT $LN150@perform_in
	cmp	DWORD PTR tv2206[ebp], eax
	jae	SHORT $LN149@perform_in
$LN150@perform_in:
	mov	eax, esi
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN199@perform_in
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN199@perform_in:
	mov	edx, esi
	sub	edx, eax
	npad	2
$LL28@perform_in:

; 2989 :               for (w=0; w < width; w++)

	add	ecx, 4
	cmp	ecx, edx
	jl	SHORT $LL28@perform_in

; 2990 :                 accumulator[w] = offset;

	lea	eax, DWORD PTR [edx+3]
	mov	DWORD PTR _w$5$[ebp], ecx
	cdq
	and	edx, 3
	lea	ecx, DWORD PTR [edx+eax]
	mov	eax, edi
	mov	edi, DWORD PTR tv2235[ebp]
	sar	ecx, 2
	shl	ecx, 4
	shr	ecx, 2
	rep stosd
	mov	ecx, DWORD PTR _w$5$[ebp]
	mov	edi, DWORD PTR _offset$1$[ebp]
$LN149@perform_in:

; 2989 :               for (w=0; w < width; w++)

	cmp	ecx, esi
	jge	SHORT $LN27@perform_in
	mov	edx, DWORD PTR tv2219[ebp]
	npad	6
$LL148@perform_in:

; 2990 :                 accumulator[w] = offset;

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edi
	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LL148@perform_in
$LN27@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	ecx, DWORD PTR _line$1$[ebp]
	mov	al, BYTE PTR [ecx+6]
	and	al, 2
	jne	$LN60@perform_in
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR _dst$1$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2992 :               if (line->line.get_buf32() != NULL)

	test	edi, edi
	je	$LN60@perform_in

; 2993 :                 { // Perform 32-bit integer reversible processing
; 2994 :                   kdu_sample32 *dst=line->line.get_buf32();
; 2995 :                   for (n=0; n < m; n++)

	mov	eax, DWORD PTR _m$1$[ebp]
	test	eax, eax
	jle	$LN30@perform_in
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	ecx, eax
	imul	ecx, DWORD PTR _N$1$[ebp]
	xor	edi, edi
	mov	DWORD PTR tv2193[ebp], edi
	mov	DWORD PTR tv2191[ebp], eax
	shl	ecx, 2
	mov	DWORD PTR tv2192[ebp], ecx
$LL31@perform_in:

; 2996 :                     {
; 2997 :                       kdu_sample32 *src = components[n].line.get_buf32();

	mov	eax, DWORD PTR [edx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [eax+edi+6], 2
	je	SHORT $LN105@perform_in
	mov	DWORD PTR _src$1$[ebp], 0
	jmp	SHORT $LN106@perform_in
$LN105@perform_in:
	mov	eax, DWORD PTR [eax+edi+8]
	mov	DWORD PTR _src$1$[ebp], eax
$LN106@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2998 :                       int factor = i_matrix[m*N+n];

	mov	eax, DWORD PTR [edx+48]
	mov	edi, DWORD PTR [ecx+eax]

; 2999 :                       if (factor == 0)

	test	edi, edi
	je	SHORT $LN29@perform_in

; 3000 :                         continue;
; 3001 :                       for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN190@perform_in
	npad	5
$LL34@perform_in:
	mov	eax, DWORD PTR tv2219[ebp]
	mov	ecx, DWORD PTR [eax]

; 3002 :                         accumulator[w] += src[w].ival * factor;

	mov	eax, DWORD PTR _src$1$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	imul	eax, edi
	add	DWORD PTR [ecx+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL34@perform_in
	mov	ecx, DWORD PTR tv2192[ebp]
$LN190@perform_in:
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
$LN29@perform_in:

; 2993 :                 { // Perform 32-bit integer reversible processing
; 2994 :                   kdu_sample32 *dst=line->line.get_buf32();
; 2995 :                   for (n=0; n < m; n++)

	mov	edi, DWORD PTR tv2193[ebp]
	add	ecx, 4
	add	edi, 60					; 0000003cH
	mov	DWORD PTR tv2192[ebp], ecx
	sub	DWORD PTR tv2191[ebp], 1
	mov	DWORD PTR tv2193[ebp], edi
	jne	SHORT $LL31@perform_in
	mov	edi, DWORD PTR _dst$1$[ebp]
	mov	ecx, DWORD PTR _line$1$[ebp]
$LN30@perform_in:

; 3003 :                     }
; 3004 :                   for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	$LN194@perform_in
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	npad	6
$LL37@perform_in:

; 3005 :                     dst[w].ival -= accumulator[w] >> downshift;

	mov	eax, DWORD PTR tv2219[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	sub	DWORD PTR [edi+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL37@perform_in

; 3006 :                 }
; 3007 :               else

	jmp	$LN204@perform_in
$LN60@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	al, al
	je	SHORT $LN109@perform_in
	mov	eax, DWORD PTR [ecx+8]
	jmp	SHORT $LN202@perform_in
$LN109@perform_in:
	xor	eax, eax
$LN202@perform_in:
	mov	DWORD PTR _dst$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3010 :                   for (n=0; n < m; n++)

	mov	eax, DWORD PTR _m$1$[ebp]
	test	eax, eax
	jle	$LN39@perform_in
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	edi, eax
	imul	edi, DWORD PTR _N$1$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR tv2190[ebp], ecx
	mov	DWORD PTR tv2188[ebp], eax
	shl	edi, 2
	mov	DWORD PTR tv2189[ebp], edi
	npad	3
$LL40@perform_in:

; 3011 :                     {
; 3012 :                       kdu_sample16 *src = components[n].line.get_buf16();

	mov	eax, DWORD PTR [edx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [eax+ecx+6], 2
	je	SHORT $LN113@perform_in
	mov	ecx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR _src$1$[ebp], ecx
	mov	ecx, DWORD PTR tv2190[ebp]
	jmp	SHORT $LN114@perform_in
$LN113@perform_in:
	mov	DWORD PTR _src$1$[ebp], 0
$LN114@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 3013 :                       int factor = i_matrix[m*N+n];

	mov	eax, DWORD PTR [edx+48]
	mov	edi, DWORD PTR [edi+eax]

; 3014 :                       if (factor == 0)

	test	edi, edi
	je	SHORT $LN38@perform_in

; 3015 :                         continue;
; 3016 :                       for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN191@perform_in
$LL43@perform_in:
	mov	eax, DWORD PTR tv2219[ebp]
	mov	ecx, DWORD PTR [eax]

; 3017 :                         accumulator[w] += src[w].ival * factor;

	mov	eax, DWORD PTR _src$1$[ebp]
	movsx	eax, WORD PTR [eax+edx*2]
	imul	eax, edi
	add	DWORD PTR [ecx+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL43@perform_in
	mov	ecx, DWORD PTR tv2190[ebp]
$LN191@perform_in:
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
$LN38@perform_in:

; 3010 :                   for (n=0; n < m; n++)

	mov	edi, DWORD PTR tv2189[ebp]
	add	ecx, 60					; 0000003cH
	add	edi, 4
	mov	DWORD PTR tv2190[ebp], ecx
	sub	DWORD PTR tv2188[ebp], 1
	mov	DWORD PTR tv2189[ebp], edi
	jne	SHORT $LL40@perform_in
	mov	ecx, DWORD PTR _line$1$[ebp]
$LN39@perform_in:

; 3018 :                     }
; 3019 :                   for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN194@perform_in
$LL46@perform_in:

; 3020 :                     dst[w].ival -= (kdu_int16)(accumulator[w] >> downshift);

	mov	eax, DWORD PTR tv2219[ebp]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	mov	ecx, DWORD PTR _dst$1$[ebp]
	sub	WORD PTR [ecx+edx*2], ax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL46@perform_in
$LN204@perform_in:
	mov	ecx, DWORD PTR _line$1$[ebp]
$LN194@perform_in:
	mov	edx, DWORD PTR _m$1$[ebp]
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN45@perform_in:

; 3021 :                 }
; 3022 :             }
; 3023 :           if (dep != NULL)

	mov	esi, DWORD PTR _dep$1$[ebp]
	test	esi, esi
	je	SHORT $LN2@perform_in

; 3024 :             dep->copy(line,-dep->rev_offset-i_offsets[m],0.0F);

	mov	eax, DWORD PTR [edi+52]
	push	ecx
	mov	DWORD PTR [esp], 0
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, DWORD PTR [esi+40]
	neg	eax
	push	eax
	push	ecx
$LN203@perform_in:
	mov	ecx, esi
	call	?copy@kd_multi_line@@QAEXPAU1@HM@Z	; kd_multi_line::copy
	mov	edx, DWORD PTR _m$1$[ebp]
$LN2@perform_in:

; 2919 :   int m, n;
; 2920 : 
; 2921 :   assert(num_dependencies == N);
; 2922 :   for (m=0; m < N; m++)

	inc	edx
	xorps	xmm0, xmm0
	mov	DWORD PTR _m$1$[ebp], edx
	cmp	edx, DWORD PTR _N$1$[ebp]
	jl	$LL4@perform_in
$LN3@perform_in:

; 3025 :         }
; 3026 :     }
; 3027 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?perform_inverse@kd_multi_dependency_block@@UAEXXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?perform_inverse@kd_multi_dependency_block@@UAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?perform_inverse@kd_multi_dependency_block@@UAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?perform_inverse@kd_multi_dependency_block@@UAEXXZ ENDP	; kd_multi_dependency_block::perform_inverse
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?prepare_for_inversion@kd_multi_dependency_block@@UAEPBDXZ
_TEXT	SEGMENT
?prepare_for_inversion@kd_multi_dependency_block@@UAEPBDXZ PROC ; kd_multi_dependency_block::prepare_for_inversion, COMDAT
; _this$ = ecx

; 2657 : {

	push	esi
	mov	esi, ecx

; 2658 :   int n;
; 2659 : 
; 2660 :   // Need only check that all components will be available.
; 2661 :   for (n=0; n < num_components; n++)

	xor	edx, edx
	push	edi
	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	jle	SHORT $LN3@prepare_fo

; 2662 :     if (components[n].num_consumers < 1)

	mov	eax, DWORD PTR [esi+12]
	add	eax, 24					; 00000018H
$LL4@prepare_fo:
	cmp	DWORD PTR [eax], 1
	jl	SHORT $LN13@prepare_fo

; 2658 :   int n;
; 2659 : 
; 2660 :   // Need only check that all components will be available.
; 2661 :   for (n=0; n < num_components; n++)

	inc	edx
	add	eax, 60					; 0000003cH
	cmp	edx, edi
	jl	SHORT $LL4@prepare_fo
$LN3@prepare_fo:

; 2664 :              "inverted unless a contiguous prefix of the output components "
; 2665 :              "can be computed by downstream transform blocks, or by the "
; 2666 :              "application supplying them.";
; 2667 : 
; 2668 :   for (n=0; n < num_dependencies; n++)

	mov	edx, DWORD PTR [esi+16]
	xor	ecx, ecx
	push	ebx
	test	edx, edx
	jle	SHORT $LN21@prepare_fo

; 2669 :     if ((!is_reversible) && (dependencies[n] != NULL) &&

	mov	bl, BYTE PTR [esi+40]
	npad	3
$LL7@prepare_fo:
	test	bl, bl
	jne	SHORT $LN5@prepare_fo
	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN5@prepare_fo
	cmp	BYTE PTR [eax+32], bl
	jne	SHORT $LN14@prepare_fo
$LN5@prepare_fo:

; 2664 :              "inverted unless a contiguous prefix of the output components "
; 2665 :              "can be computed by downstream transform blocks, or by the "
; 2666 :              "application supplying them.";
; 2667 : 
; 2668 :   for (n=0; n < num_dependencies; n++)

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL7@prepare_fo
$LN21@prepare_fo:
	pop	ebx

; 2672 :              "which operates on reversible codestream sample data.  "
; 2673 :              "While we allow such transforms to be processed during "
; 2674 :              "decompression, it is unreasonable to generate reversibly "
; 2675 :              "compressed component samples using an irreversible inverse "
; 2676 :              "multi-component transform during compression.  Kakadu will "
; 2677 :              "not invert this transform during compression.  This can "
; 2678 :              "prevent the compression process from proceeding if there are "
; 2679 :              "no other paths back from the MCT output components to the "
; 2680 :              "codestream components.";
; 2681 : 
; 2682 :   outstanding_consumers = num_components;

	mov	DWORD PTR [esi+28], edi

; 2683 :   return NULL;

	xor	eax, eax
	pop	edi
	pop	esi

; 2684 : }

	ret	0
$LN13@prepare_fo:
	pop	edi

; 2663 :       return "Dependency transform block cannot be inverted or partially "

	mov	eax, OFFSET ??_C@_0MO@CPPIDHHM@Dependency?5transform?5block?5canno@
	pop	esi

; 2684 : }

	ret	0
$LN14@prepare_fo:
	pop	ebx
	pop	edi

; 2670 :         dependencies[n]->reversible)
; 2671 :       return "Encountered an irreversible dependency transform block "

	mov	eax, OFFSET ??_C@_0CBI@FDCMKGLL@Encountered?5an?5irreversible?5depe@
	pop	esi

; 2684 : }

	ret	0
?prepare_for_inversion@kd_multi_dependency_block@@UAEPBDXZ ENDP ; kd_multi_dependency_block::prepare_for_inversion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?perform_transform@kd_multi_dependency_block@@UAEXXZ
_TEXT	SEGMENT
_e$2 = -156						; size = 20
_dst$1$ = -136						; size = 4
_downshift$1$ = -136					; size = 4
tv2218 = -136						; size = 4
_N$1$ = -132						; size = 4
tv2217 = -128						; size = 4
tv2174 = -128						; size = 4
tv2171 = -128						; size = 4
_width$1$ = -128					; size = 4
_downshift$1$ = -124					; size = 4
tv2220 = -124						; size = 4
tv2179 = -124						; size = 4
_dst$1$ = -120						; size = 4
_offset$1$ = -120					; size = 4
_factor$1$ = -120					; size = 4
_offset$1$ = -120					; size = 4
tv2186 = -120						; size = 4
tv2180 = -116						; size = 4
tv2178 = -116						; size = 4
tv2176 = -116						; size = 4
tv2173 = -116						; size = 4
_m$1$ = -112						; size = 4
tv2213 = -108						; size = 4
tv2204 = -108						; size = 4
tv2177 = -108						; size = 4
tv2175 = -108						; size = 4
tv2172 = -108						; size = 4
_line$1$ = -108						; size = 4
_dst$1$ = -104						; size = 4
tv2203 = -104						; size = 4
_dst$1$ = -104						; size = 4
_this$GSCopy$1$ = -100					; size = 4
_text$3 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?perform_transform@kd_multi_dependency_block@@UAEXXZ PROC ; kd_multi_dependency_block::perform_transform, COMDAT
; _this$ = ecx

; 2789 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?perform_transform@kd_multi_dependency_block@@UAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi

; 2790 :   int N = num_components;

	mov	ebx, DWORD PTR [edi+8]

; 2791 :   int m, n;
; 2792 : 
; 2793 :   assert(num_dependencies == N);
; 2794 :   for (m=0; m < N; m++)

	xor	edx, edx
	mov	DWORD PTR _N$1$[ebp], ebx
	mov	DWORD PTR _m$1$[ebp], edx
	test	ebx, ebx
	jle	$LN48@perform_tr
	npad	7
$LL4@perform_tr:

; 2796 :       kd_multi_line *line = components + m;

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, edx
	shl	ecx, 4
	sub	ecx, edx

; 2798 :       int w, width=line->line.get_width();
; 2799 :       if (!is_reversible)

	cmp	BYTE PTR [edi+40], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 544  :         return width;

	mov	esi, DWORD PTR [eax+ecx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2796 :       kd_multi_line *line = components + m;

	lea	ebx, DWORD PTR [eax+ecx*4]

; 2797 :       kd_multi_line *dep = dependencies[m];

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _line$1$[ebp], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 544  :         return width;

	mov	DWORD PTR _width$1$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2797 :       kd_multi_line *dep = dependencies[m];

	mov	ecx, DWORD PTR [eax+edx*4]

; 2800 :         {
; 2801 :           if (dep == NULL)
; 2802 :             line->reset(0,f_offsets[m]);

	push	ecx
	jne	$LN50@perform_tr
	mov	eax, DWORD PTR [edi+60]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR [esp], xmm0
	push	0
	test	ecx, ecx
	jne	SHORT $LN52@perform_tr
	mov	ecx, ebx
	call	?reset@kd_multi_line@@QAEXHM@Z		; kd_multi_line::reset

; 2803 :           else

	jmp	SHORT $LN53@perform_tr
$LN52@perform_tr:

; 2804 :             line->copy(dep,0,f_offsets[m]);

	push	ecx
	mov	ecx, ebx
	call	?copy@kd_multi_line@@QAEXPAU1@HM@Z	; kd_multi_line::copy
$LN53@perform_tr:

; 2805 :           if (m == 0)

	mov	edx, DWORD PTR _m$1$[ebp]
	test	edx, edx
	je	$LN2@perform_tr
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ebx+6], 2
	jne	$LN55@perform_tr
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR _dst$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2808 :           if (line->line.get_buf32() != NULL)

	test	ecx, ecx
	je	$LN55@perform_tr

; 2809 :             { // Perform 32-bit floating point irreversible processing
; 2810 :               kdu_sample32 *dst=line->line.get_buf32();
; 2811 :               for (n=0; n < m; n++)

	test	edx, edx
	jle	$LN2@perform_tr
	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	edi, edx
	imul	edi, DWORD PTR _N$1$[ebp]
	xor	eax, eax
	mov	DWORD PTR tv2180[ebp], eax
	mov	DWORD PTR tv2213[ebp], edx
	shl	edi, 2
	mov	DWORD PTR tv2179[ebp], edi
$LL7@perform_tr:

; 2812 :                 {
; 2813 :                   kdu_sample32 *src = components[n].line.get_buf32();

	mov	edx, DWORD PTR [ebx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edx+eax+6], 2
	je	SHORT $LN84@perform_tr
	xor	edx, edx
	jmp	SHORT $LN85@perform_tr
$LN84@perform_tr:
	mov	edx, DWORD PTR [edx+eax+8]
$LN85@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2814 :                   float factor = f_matrix[m*N+n];

	mov	eax, DWORD PTR [ebx+56]
	xorps	xmm0, xmm0
	movss	xmm1, DWORD PTR [edi+eax]

; 2815 :                   if (factor == 0.0F)

	ucomiss	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN5@perform_tr

; 2816 :                     continue;
; 2817 :                   for (w=0; w < width; w++)

	xor	ebx, ebx
	cmp	esi, 4
	jl	SHORT $LC177@perform_tr
	mov	edi, DWORD PTR _dst$1$[ebp]
	lea	ecx, DWORD PTR [edx+12]
	mov	ebx, edx
	sub	ebx, edi
	mov	DWORD PTR tv2186[ebp], ebx
	lea	eax, DWORD PTR [edi+4]
	lea	edi, DWORD PTR [esi-4]
	mov	esi, DWORD PTR tv2186[ebp]
	shr	edi, 2
	inc	edi
	lea	ebx, DWORD PTR [edi*4]
$LL178@perform_tr:

; 2818 :                     dst[w].fval += src[w].fval * factor;

	movss	xmm0, DWORD PTR [ecx-12]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax-4]
	movss	DWORD PTR [eax-4], xmm0
	movss	xmm0, DWORD PTR [esi+eax]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [ecx-4]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [eax+8], xmm0
	add	eax, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL178@perform_tr
	mov	esi, DWORD PTR _width$1$[ebp]
	mov	edi, DWORD PTR tv2179[ebp]
	mov	ecx, DWORD PTR _dst$1$[ebp]
$LC177@perform_tr:

; 2816 :                     continue;
; 2817 :                   for (w=0; w < width; w++)

	cmp	ebx, esi
	jge	SHORT $LN200@perform_tr
	lea	eax, DWORD PTR [ecx+ebx*4]
	sub	edx, ecx
	mov	ecx, esi
	sub	ecx, ebx
	npad	4
$LC10@perform_tr:

; 2818 :                     dst[w].fval += src[w].fval * factor;

	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LC10@perform_tr
$LN200@perform_tr:
	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
$LN5@perform_tr:

; 2809 :             { // Perform 32-bit floating point irreversible processing
; 2810 :               kdu_sample32 *dst=line->line.get_buf32();
; 2811 :               for (n=0; n < m; n++)

	mov	eax, DWORD PTR tv2180[ebp]
	add	edi, 4
	mov	ecx, DWORD PTR _dst$1$[ebp]
	add	eax, 60					; 0000003cH
	sub	DWORD PTR tv2213[ebp], 1
	mov	DWORD PTR tv2179[ebp], edi
	mov	DWORD PTR tv2180[ebp], eax
	jne	$LL7@perform_tr

; 2819 :                 }
; 2820 :             }
; 2821 :           else

	jmp	$LN206@perform_tr
$LN55@perform_tr:

; 2822 :             { // Perform 16-bit fixed point irreversible processing
; 2823 :               if (accumulator == NULL)

	add	edi, 72					; 00000048H
	mov	DWORD PTR tv2204[ebp], edi
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN58@perform_tr

; 2824 :                 accumulator = new kdu_int32[width];

	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [edi], eax
$LN58@perform_tr:

; 2825 :               if (short_matrix == NULL)

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	cmp	DWORD PTR [ecx+64], 0
	jne	SHORT $LN59@perform_tr

; 2826 :                 create_short_matrix();

	call	?create_short_matrix@kd_multi_dependency_block@@AAEXXZ ; kd_multi_dependency_block::create_short_matrix
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
$LN59@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ebx+6], 2
	je	SHORT $LN88@perform_tr
	mov	eax, DWORD PTR [ebx+8]
	jmp	SHORT $LN211@perform_tr
$LN88@perform_tr:
	xor	eax, eax
$LN211@perform_tr:
	mov	DWORD PTR _dst$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2829 :               kdu_int32 offset = (1<<downshift)>>1; // Rounding offset

	mov	edx, 1
	mov	eax, DWORD PTR [ecx+68]

; 2830 :               for (w=0; w < width; w++)

	xor	ebx, ebx
	mov	ecx, eax
	mov	DWORD PTR _downshift$1$[ebp], eax
	shl	edx, cl
	sar	edx, 1
	mov	DWORD PTR _offset$1$[ebp], edx
	test	esi, esi
	jle	SHORT $LN12@perform_tr
	cmp	esi, 4
	jb	SHORT $LN153@perform_tr

; 2831 :                 accumulator[w] = offset;

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [esi-1]
	lea	ecx, DWORD PTR [eax+ecx*4]
	cmp	eax, edi
	ja	SHORT $LN154@perform_tr
	cmp	ecx, edi
	jae	SHORT $LN153@perform_tr
$LN154@perform_tr:
	mov	eax, esi
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN208@perform_tr
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN208@perform_tr:
	mov	ecx, esi
	sub	ecx, eax
	npad	6
$LL13@perform_tr:

; 2830 :               for (w=0; w < width; w++)

	add	ebx, 4
	cmp	ebx, ecx
	jl	SHORT $LL13@perform_tr

; 2831 :                 accumulator[w] = offset;

	mov	edi, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+3]
	cdq
	and	edx, 3
	lea	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR _offset$1$[ebp]
	sar	ecx, 2
	mov	eax, edx
	shl	ecx, 4
	shr	ecx, 2
	rep stosd
	mov	edi, DWORD PTR tv2204[ebp]
$LN153@perform_tr:

; 2830 :               for (w=0; w < width; w++)

	cmp	ebx, esi
	jge	SHORT $LN12@perform_tr
	npad	6
$LL152@perform_tr:

; 2831 :                 accumulator[w] = offset;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+ebx*4], edx
	inc	ebx
	cmp	ebx, esi
	jl	SHORT $LL152@perform_tr
$LN12@perform_tr:

; 2832 :               for (n=0; n < m; n++)

	mov	eax, DWORD PTR _m$1$[ebp]
	test	eax, eax
	jle	SHORT $LN15@perform_tr
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	ecx, eax
	imul	ecx, DWORD PTR _N$1$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR tv2178[ebp], ebx
	mov	DWORD PTR tv2220[ebp], eax
	add	ecx, ecx
	mov	DWORD PTR tv2177[ebp], ecx
	npad	6
$LL16@perform_tr:

; 2833 :                 {
; 2834 :                   kdu_sample16 *src = components[n].line.get_buf16();

	mov	eax, DWORD PTR [edx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [eax+ebx+6], 2
	je	SHORT $LN92@perform_tr
	mov	ebx, DWORD PTR [eax+ebx+8]
	jmp	SHORT $LN93@perform_tr
$LN92@perform_tr:
	xor	ebx, ebx
$LN93@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2835 :                   int factor = short_matrix[m*N + n];

	mov	eax, DWORD PTR [edx+64]
	movsx	eax, WORD PTR [ecx+eax]
	mov	DWORD PTR _factor$1$[ebp], eax

; 2836 :                   if (factor == 0)

	test	eax, eax
	je	SHORT $LN14@perform_tr

; 2837 :                     continue;
; 2838 :                   for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN201@perform_tr
$LL19@perform_tr:

; 2839 :                     accumulator[w] += src[w].ival * factor;

	movsx	eax, WORD PTR [ebx+edx*2]
	imul	eax, DWORD PTR _factor$1$[ebp]
	mov	ecx, DWORD PTR [edi]
	add	DWORD PTR [ecx+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL19@perform_tr
	mov	ecx, DWORD PTR tv2177[ebp]
$LN201@perform_tr:
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
$LN14@perform_tr:

; 2832 :               for (n=0; n < m; n++)

	mov	ebx, DWORD PTR tv2178[ebp]
	add	ecx, 2
	add	ebx, 60					; 0000003cH
	mov	DWORD PTR tv2177[ebp], ecx
	sub	DWORD PTR tv2220[ebp], 1
	mov	DWORD PTR tv2178[ebp], ebx
	jne	SHORT $LL16@perform_tr
$LN15@perform_tr:

; 2840 :                 }
; 2841 :               for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	$LN206@perform_tr
	mov	ebx, DWORD PTR _downshift$1$[ebp]
$LL22@perform_tr:

; 2842 :                 dst[w].ival += (kdu_int16)(accumulator[w] >> downshift);

	mov	eax, DWORD PTR [edi]
	mov	ecx, ebx
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	mov	ecx, DWORD PTR _dst$1$[ebp]
	add	WORD PTR [ecx+edx*2], ax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL22@perform_tr

; 2843 :             }
; 2844 :         }
; 2845 :       else

	jmp	$LN206@perform_tr
$LN50@perform_tr:

; 2846 :         {
; 2847 :           if (dep == NULL)
; 2848 :             line->reset(i_offsets[m],0.0F);

	mov	eax, DWORD PTR [edi+52]
	mov	DWORD PTR [esp], 0
	push	DWORD PTR [eax+edx*4]
	test	ecx, ecx
	jne	SHORT $LN61@perform_tr
	mov	ecx, ebx
	call	?reset@kd_multi_line@@QAEXHM@Z		; kd_multi_line::reset

; 2849 :           else

	jmp	SHORT $LN62@perform_tr
$LN61@perform_tr:

; 2850 :             line->copy(dep,i_offsets[m],0.0F);

	push	ecx
	mov	ecx, ebx
	call	?copy@kd_multi_line@@QAEXPAU1@HM@Z	; kd_multi_line::copy
$LN62@perform_tr:

; 2851 :           if (m == 0)

	mov	edx, DWORD PTR _m$1$[ebp]
	test	edx, edx
	je	$LN2@perform_tr

; 2852 :             continue;
; 2853 : 
; 2854 :           int downshift, divisor = i_matrix[m*N+m];

	mov	ecx, DWORD PTR _N$1$[ebp]
	mov	eax, DWORD PTR [edi+48]
	inc	ecx
	imul	ecx, edx
	mov	ebx, DWORD PTR [eax+ecx*4]

; 2855 :           for (downshift=0; (1<<downshift) < divisor; downshift++);

	xor	eax, eax
	mov	DWORD PTR _downshift$1$[ebp], eax
	lea	edi, DWORD PTR [eax+1]
	cmp	ebx, edi
	jle	SHORT $LN24@perform_tr
$LL25@perform_tr:
	rol	edi, 1
	inc	eax
	cmp	edi, ebx
	jl	SHORT $LL25@perform_tr
	mov	DWORD PTR _downshift$1$[ebp], eax
$LN24@perform_tr:

; 2856 :           if ((1<<downshift) != divisor)

	cmp	edi, ebx
	je	$LN64@perform_tr

; 2857 :             { KDU_ERROR(e,0x23090500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0OO@CDGHEAGO@Multi?9component?5reversible?5depen@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2857 :             { KDU_ERROR(e,0x23090500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$2[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	ebx
	push	eax
	lea	eax, DWORD PTR _text$3[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$3[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	eax
	mov	eax, DWORD PTR _e$2[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2863 :             }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN64@perform_tr:

; 2864 :           kdu_int32 offset = ((1<<downshift)>>1);
; 2865 :           if (accumulator == NULL)

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	add	eax, 72					; 00000048H
	sar	edi, 1
	mov	DWORD PTR _offset$1$[ebp], edi
	mov	DWORD PTR tv2203[ebp], eax
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN65@perform_tr

; 2866 :             accumulator = new kdu_int32[width];

	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ebx, DWORD PTR tv2203[ebp]
	add	esp, 4
	mov	DWORD PTR [ebx], eax
	mov	eax, ebx
$LN65@perform_tr:

; 2867 :           for (w=0; w < width; w++)

	xor	ebx, ebx
	test	esi, esi
	jle	SHORT $LN198@perform_tr
	cmp	esi, 4
	jb	SHORT $LN156@perform_tr

; 2868 :             accumulator[w] = offset;

	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [esi-1]
	mov	DWORD PTR tv2218[ebp], ecx
	lea	edx, DWORD PTR [ecx+edx*4]
	cmp	ecx, eax
	ja	SHORT $LN157@perform_tr
	cmp	edx, eax
	jae	SHORT $LN156@perform_tr
$LN157@perform_tr:
	mov	eax, esi
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN209@perform_tr
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN209@perform_tr:
	mov	ecx, esi
	sub	ecx, eax
$LL28@perform_tr:

; 2867 :           for (w=0; w < width; w++)

	add	ebx, 4
	cmp	ebx, ecx
	jl	SHORT $LL28@perform_tr

; 2868 :             accumulator[w] = offset;

	lea	eax, DWORD PTR [ecx+3]
	cdq
	and	edx, 3
	lea	ecx, DWORD PTR [edx+eax]
	mov	eax, edi
	mov	edi, DWORD PTR tv2218[ebp]
	sar	ecx, 2
	shl	ecx, 4
	shr	ecx, 2
	rep stosd
	mov	edi, DWORD PTR _offset$1$[ebp]
$LN156@perform_tr:

; 2867 :           for (w=0; w < width; w++)

	mov	ecx, DWORD PTR tv2203[ebp]
	cmp	ebx, esi
	jge	SHORT $LN27@perform_tr
$LL155@perform_tr:

; 2868 :             accumulator[w] = offset;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [eax+ebx*4], edi
	inc	ebx
	cmp	ebx, esi
	jl	SHORT $LL155@perform_tr
	jmp	SHORT $LN27@perform_tr
$LN198@perform_tr:
	mov	ecx, DWORD PTR tv2203[ebp]
$LN27@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	eax, DWORD PTR _line$1$[ebp]
	mov	dl, BYTE PTR [eax+6]
	and	dl, 2
	jne	$LN66@perform_tr
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR _dst$1$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2870 :           if (line->line.get_buf32() != NULL)

	test	edi, edi
	je	$LN66@perform_tr

; 2871 :             { // Perform 32-bit integer reversible processing
; 2872 :               kdu_sample32 *dst=line->line.get_buf32();
; 2873 :               for (n=0; n < m; n++)

	mov	eax, DWORD PTR _m$1$[ebp]
	test	eax, eax
	jle	SHORT $LN30@perform_tr
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	ebx, eax
	imul	ebx, DWORD PTR _N$1$[ebp]
	xor	edi, edi
	mov	DWORD PTR tv2176[ebp], edi
	mov	DWORD PTR tv2174[ebp], eax
	shl	ebx, 2
	mov	DWORD PTR tv2175[ebp], ebx
$LL31@perform_tr:

; 2874 :                 {
; 2875 :                   kdu_sample32 *src = components[n].line.get_buf32();

	mov	eax, DWORD PTR [edx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [eax+edi+6], 2
	je	SHORT $LN110@perform_tr
	xor	edi, edi
	jmp	SHORT $LN111@perform_tr
$LN110@perform_tr:
	mov	edi, DWORD PTR [eax+edi+8]
$LN111@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2876 :                   int factor = i_matrix[m*N+n];

	mov	eax, DWORD PTR [edx+48]
	mov	ebx, DWORD PTR [ebx+eax]

; 2877 :                   if (factor == 0)

	test	ebx, ebx
	je	SHORT $LN29@perform_tr

; 2878 :                     continue;
; 2879 :                   for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN202@perform_tr
$LL34@perform_tr:

; 2880 :                     accumulator[w] += src[w].ival * factor;

	mov	eax, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR [ecx]
	imul	eax, ebx
	add	DWORD PTR [ecx+edx*4], eax
	inc	edx
	mov	ecx, DWORD PTR tv2203[ebp]
	cmp	edx, esi
	jl	SHORT $LL34@perform_tr
$LN202@perform_tr:
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
$LN29@perform_tr:

; 2871 :             { // Perform 32-bit integer reversible processing
; 2872 :               kdu_sample32 *dst=line->line.get_buf32();
; 2873 :               for (n=0; n < m; n++)

	mov	ebx, DWORD PTR tv2175[ebp]
	mov	edi, DWORD PTR tv2176[ebp]
	add	ebx, 4
	mov	ecx, DWORD PTR tv2203[ebp]
	add	edi, 60					; 0000003cH
	sub	DWORD PTR tv2174[ebp], 1
	mov	DWORD PTR tv2175[ebp], ebx
	mov	DWORD PTR tv2176[ebp], edi
	jne	SHORT $LL31@perform_tr
	mov	edi, DWORD PTR _dst$1$[ebp]
$LN30@perform_tr:

; 2881 :                 }
; 2882 :               for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	$LN206@perform_tr
	mov	ebx, DWORD PTR tv2203[ebp]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	npad	3
$LL37@perform_tr:

; 2883 :                 dst[w].ival += accumulator[w] >> downshift;

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	add	DWORD PTR [edi+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL37@perform_tr

; 2884 :             }
; 2885 :           else

	jmp	$LN206@perform_tr
$LN66@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	dl, dl
	je	SHORT $LN114@perform_tr
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN212@perform_tr
$LN114@perform_tr:
	xor	eax, eax
$LN212@perform_tr:
	mov	DWORD PTR _dst$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2888 :               for (n=0; n < m; n++)

	mov	eax, DWORD PTR _m$1$[ebp]
	test	eax, eax
	jle	SHORT $LN39@perform_tr
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	ebx, eax
	imul	ebx, DWORD PTR _N$1$[ebp]
	xor	edi, edi
	mov	DWORD PTR tv2172[ebp], edi
	mov	DWORD PTR tv2173[ebp], eax
	shl	ebx, 2
	mov	DWORD PTR tv2171[ebp], ebx
$LL40@perform_tr:

; 2889 :                 {
; 2890 :                   kdu_sample16 *src = components[n].line.get_buf16();

	mov	eax, DWORD PTR [edx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [eax+edi+6], 2
	je	SHORT $LN118@perform_tr
	mov	edi, DWORD PTR [eax+edi+8]
	jmp	SHORT $LN119@perform_tr
$LN118@perform_tr:
	xor	edi, edi
$LN119@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2891 :                   int factor = i_matrix[m*N+n];

	mov	eax, DWORD PTR [edx+48]
	mov	ebx, DWORD PTR [ebx+eax]

; 2892 :                   if (factor == 0)

	test	ebx, ebx
	je	SHORT $LN38@perform_tr

; 2893 :                     continue;
; 2894 :                   for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN203@perform_tr
$LL43@perform_tr:

; 2895 :                     accumulator[w] += src[w].ival * factor;

	movsx	eax, WORD PTR [edi+edx*2]
	mov	ecx, DWORD PTR [ecx]
	imul	eax, ebx
	add	DWORD PTR [ecx+edx*4], eax
	inc	edx
	mov	ecx, DWORD PTR tv2203[ebp]
	cmp	edx, esi
	jl	SHORT $LL43@perform_tr
$LN203@perform_tr:
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
$LN38@perform_tr:

; 2888 :               for (n=0; n < m; n++)

	mov	ebx, DWORD PTR tv2171[ebp]
	mov	edi, DWORD PTR tv2172[ebp]
	add	ebx, 4
	mov	ecx, DWORD PTR tv2203[ebp]
	add	edi, 60					; 0000003cH
	sub	DWORD PTR tv2173[ebp], 1
	mov	DWORD PTR tv2171[ebp], ebx
	mov	DWORD PTR tv2172[ebp], edi
	jne	SHORT $LL40@perform_tr
$LN39@perform_tr:

; 2896 :                 }
; 2897 :               for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN206@perform_tr
	mov	ebx, DWORD PTR tv2203[ebp]
$LL46@perform_tr:

; 2898 :                 dst[w].ival += (kdu_int16)(accumulator[w] >> downshift);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	mov	ecx, DWORD PTR _dst$1$[ebp]
	add	WORD PTR [ecx+edx*2], ax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL46@perform_tr
$LN206@perform_tr:
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	edx, DWORD PTR _m$1$[ebp]
$LN2@perform_tr:

; 2791 :   int m, n;
; 2792 : 
; 2793 :   assert(num_dependencies == N);
; 2794 :   for (m=0; m < N; m++)

	mov	ebx, DWORD PTR _N$1$[ebp]
	inc	edx
	mov	DWORD PTR _m$1$[ebp], edx
	cmp	edx, ebx
	jl	$LL4@perform_tr

; 2899 :             }
; 2900 :         }
; 2901 :     }
; 2902 : 
; 2903 :   // Finally add in any component offsets required for the output components
; 2904 :   for (m=0; m < N; m++)

	test	ebx, ebx
	jle	SHORT $LN48@perform_tr
	xor	esi, esi
$LL49@perform_tr:

; 2905 :     {
; 2906 :       kd_multi_line *line = components + m;

	mov	ecx, DWORD PTR [edi+12]
	add	ecx, esi

; 2907 :       line->apply_offset(line->rev_offset,line->irrev_offset);

	push	ecx
	movss	xmm0, DWORD PTR [ecx+44]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR [ecx+40]
	call	?apply_offset@kd_multi_line@@QAEXHM@Z	; kd_multi_line::apply_offset
	add	esi, 60					; 0000003cH
	sub	ebx, 1
	jne	SHORT $LL49@perform_tr
$LN48@perform_tr:

; 2908 :     }
; 2909 : }      

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?perform_transform@kd_multi_dependency_block@@UAEXXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?perform_transform@kd_multi_dependency_block@@UAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?perform_transform@kd_multi_dependency_block@@UAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?perform_transform@kd_multi_dependency_block@@UAEXXZ ENDP ; kd_multi_dependency_block::perform_transform
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?normalize_coefficients@kd_multi_dependency_block@@UAEXXZ
_TEXT	SEGMENT
tv2255 = -60						; size = 4
tv2235 = -60						; size = 4
tv2226 = -60						; size = 4
tv2240 = -56						; size = 4
tv2216 = -56						; size = 4
tv2244 = -52						; size = 4
tv2246 = -48						; size = 4
tv2154 = -44						; size = 4
_N$1$ = -40						; size = 4
tv2218 = -36						; size = 4
tv2221 = -32						; size = 4
tv2250 = -28						; size = 4
_m$1$ = -28						; size = 4
tv2245 = -24						; size = 4
tv2249 = -20						; size = 4
tv2219 = -16						; size = 4
_n$1$ = -12						; size = 4
tv2222 = -8						; size = 4
tv2153 = -4						; size = 4
?normalize_coefficients@kd_multi_dependency_block@@UAEXXZ PROC ; kd_multi_dependency_block::normalize_coefficients, COMDAT
; _this$ = ecx

; 2692 : {

	push	ebp
	mov	ebp, esp
	mov	edx, ecx
	sub	esp, 60					; 0000003cH

; 2693 :   if (is_reversible)

	cmp	BYTE PTR [edx+40], 0
	jne	$LN12@normalize_

; 2694 :     return; // Only need to normalize for irreversible transforms
; 2695 : 
; 2696 :   int n, m, N=num_components;  assert(N == num_dependencies);

	push	ebx
	push	esi
	mov	esi, DWORD PTR [edx+8]

; 2697 :   bool need_precise=false;
; 2698 :   for (n=0; n < N; n++)

	xor	ebx, ebx
	mov	DWORD PTR _N$1$[ebp], esi
	mov	BYTE PTR tv2153[ebp], 0
	mov	DWORD PTR _n$1$[ebp], ebx
	test	esi, esi
	jle	$LN56@normalize_

; 2694 :     return; // Only need to normalize for irreversible transforms
; 2695 : 
; 2696 :   int n, m, N=num_components;  assert(N == num_dependencies);

	movss	xmm3, DWORD PTR __real@3f800000
	lea	eax, DWORD PTR [esi+esi*2]
	push	edi
	mov	DWORD PTR tv2219[ebp], eax
	xor	edi, edi
	lea	eax, DWORD PTR [esi-1]
	mov	DWORD PTR tv2222[ebp], edi
	mov	DWORD PTR tv2221[ebp], ebx
	mov	DWORD PTR tv2218[ebp], eax
	mov	DWORD PTR tv2154[ebp], 1
	npad	1
$LL4@normalize_:

; 2699 :     {
; 2700 :       kd_multi_line *dep = dependencies[n];
; 2701 :       kd_multi_line *line = components + n;

	mov	ecx, DWORD PTR [edx+12]
	add	ecx, DWORD PTR tv2221[ebp]
	mov	eax, DWORD PTR [edx+20]

; 2702 :       if (line->bit_depth == 0)

	cmp	DWORD PTR [ecx+36], 0
	mov	eax, DWORD PTR [eax+ebx*4]
	jne	$LN15@normalize_

; 2703 :         {
; 2704 :           need_precise = true; // Better not risk fixed-point overflow
; 2705 :           if (dep != NULL)

	mov	ebx, DWORD PTR _n$1$[ebp]
	mov	BYTE PTR tv2153[ebp], 1
	test	eax, eax
	je	SHORT $LN55@normalize_

; 2706 :             line->bit_depth = dep->bit_depth; // Avoid scaling input samples

	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+36], eax
$LN55@normalize_:
	mov	eax, DWORD PTR tv2153[ebp]
$LN18@normalize_:

; 2709 :         need_precise = true;
; 2710 :       if (line->need_precise)

	cmp	BYTE PTR [ecx+34], 0

; 2711 :         need_precise = true;
; 2712 : 
; 2713 :       if (line->bit_depth > 0)

	mov	ecx, DWORD PTR [ecx+36]
	movzx	eax, al
	cmovne	eax, DWORD PTR tv2154[ebp]
	mov	DWORD PTR tv2153[ebp], eax
	test	ecx, ecx
	jle	$LN2@normalize_

; 2714 :         {
; 2715 :           // Scale terms which use this line as an input
; 2716 :           float source_factor = (float)(1<<line->bit_depth);

	mov	eax, 1

; 2717 :           for (m=n+1; m < N; m++)

	lea	edi, DWORD PTR [ebx+1]
	shl	eax, cl
	mov	ecx, edi
	mov	DWORD PTR tv2226[ebp], edi
	mov	DWORD PTR _m$1$[ebp], ecx
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
	cmp	edi, esi
	jge	$LN41@normalize_
	cmp	DWORD PTR tv2218[ebp], 4
	jl	$LC42@normalize_
	mov	eax, esi
	shl	eax, 4
	mov	DWORD PTR tv2240[ebp], eax
	mov	eax, DWORD PTR tv2222[ebp]
	add	eax, esi
	lea	ecx, DWORD PTR [eax+ebx]
	add	eax, ebx
	shl	ecx, 2
	add	eax, esi
	mov	DWORD PTR tv2249[ebp], ecx
	mov	ecx, DWORD PTR tv2219[ebp]
	add	ecx, ebx
	shl	eax, 2
	add	ecx, esi
	mov	DWORD PTR tv2244[ebp], eax
	shl	ecx, 2
	mov	DWORD PTR tv2246[ebp], ecx
	mov	ecx, DWORD PTR tv2219[ebp]
	add	ecx, ebx
	mov	ebx, DWORD PTR tv2244[ebp]
	shl	ecx, 2
	mov	DWORD PTR tv2245[ebp], ecx
	mov	ecx, esi
	mov	esi, DWORD PTR tv2246[ebp]
	sub	ecx, edi
	sub	ecx, 4
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR _m$1$[ebp], eax
	npad	3
$LL43@normalize_:

; 2718 :             f_matrix[m*N + n] *= source_factor;

	mov	eax, DWORD PTR [edx+56]
	mov	edi, DWORD PTR tv2249[ebp]
	movss	xmm0, DWORD PTR [eax+edi]
	mulss	xmm0, xmm2
	movss	DWORD PTR [eax+edi], xmm0
	mov	eax, DWORD PTR [edx+56]
	mov	edi, DWORD PTR tv2245[ebp]
	movss	xmm0, DWORD PTR [eax+ebx]
	mulss	xmm0, xmm2
	movss	DWORD PTR [eax+ebx], xmm0
	mov	eax, DWORD PTR [edx+56]
	movss	xmm0, DWORD PTR [eax+edi]
	mulss	xmm0, xmm2
	movss	DWORD PTR [eax+edi], xmm0
	movaps	xmm0, xmm2
	mov	eax, DWORD PTR [edx+56]
	mov	edi, DWORD PTR tv2240[ebp]
	add	ebx, edi
	add	DWORD PTR tv2249[ebp], edi
	add	DWORD PTR tv2245[ebp], edi
	mulss	xmm0, DWORD PTR [eax+esi]
	movss	DWORD PTR [eax+esi], xmm0
	add	esi, edi
	sub	ecx, 1
	jne	SHORT $LL43@normalize_
	mov	edi, DWORD PTR tv2226[ebp]
	mov	ebx, DWORD PTR _n$1$[ebp]
	mov	esi, DWORD PTR _N$1$[ebp]
	mov	ecx, DWORD PTR _m$1$[ebp]
$LC42@normalize_:

; 2717 :           for (m=n+1; m < N; m++)

	cmp	ecx, esi
	jge	SHORT $LN41@normalize_
	imul	ecx, esi
	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR tv2235[ebp], eax
	add	ecx, ebx
	mov	ebx, eax
	shl	ecx, 2
	sub	esi, DWORD PTR _m$1$[ebp]
$LC7@normalize_:

; 2718 :             f_matrix[m*N + n] *= source_factor;

	mov	eax, DWORD PTR [edx+56]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR [eax+ecx], xmm0
	add	ecx, ebx
	sub	esi, 1
	jne	SHORT $LC7@normalize_
	mov	ebx, DWORD PTR _n$1$[ebp]
$LN41@normalize_:

; 2719 : 
; 2720 :           // Scale terms which have this line as an output
; 2721 :           float target_factor = 1.0F / source_factor;

	movaps	xmm1, xmm3

; 2722 :           for (m=0; m < n; m++)

	xor	esi, esi
	divss	xmm1, xmm2
	movaps	xmm2, xmm1
	shufps	xmm2, xmm2, 0
	test	ebx, ebx
	jle	$LN44@normalize_
	cmp	ebx, 8
	jb	SHORT $LN33@normalize_

; 2723 :             f_matrix[n*N + m] *= target_factor;

	mov	ecx, DWORD PTR [edx+56]
	lea	eax, DWORD PTR [edx+56]
	mov	DWORD PTR tv2255[ebp], eax
	mov	eax, DWORD PTR tv2222[ebp]
	add	eax, -2					; fffffffeH
	add	eax, edi
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv2216[ebp], eax
	mov	eax, DWORD PTR tv2222[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR tv2255[ebp]
	ja	SHORT $LN34@normalize_
	lea	eax, DWORD PTR [edx+56]
	cmp	DWORD PTR tv2216[ebp], eax
	jae	SHORT $LN33@normalize_
$LN34@normalize_:
	mov	eax, ebx
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN59@normalize_
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN59@normalize_:
	mov	DWORD PTR tv2250[ebp], ebx
	sub	DWORD PTR tv2250[ebp], eax

; 2697 :   bool need_precise=false;
; 2698 :   for (n=0; n < N; n++)

	mov	eax, DWORD PTR tv2222[ebp]
	lea	eax, DWORD PTR [eax*4+16]
$LL10@normalize_:

; 2723 :             f_matrix[n*N + m] *= target_factor;

	movups	xmm0, XMMWORD PTR [eax+ecx-16]
	add	esi, 8
	lea	eax, DWORD PTR [eax+32]
	mulps	xmm0, xmm2
	movups	XMMWORD PTR [eax+ecx-48], xmm0
	movups	xmm0, XMMWORD PTR [eax+ecx-32]
	mulps	xmm0, xmm2
	movups	XMMWORD PTR [eax+ecx-32], xmm0
	cmp	esi, DWORD PTR tv2250[ebp]
	jl	SHORT $LL10@normalize_
$LN33@normalize_:
	cmp	esi, ebx
	jge	$LN44@normalize_
	mov	eax, ebx
	sub	eax, esi

; 2722 :           for (m=0; m < n; m++)

	cmp	eax, 4
	jl	SHORT $LC45@normalize_

; 2723 :             f_matrix[n*N + m] *= target_factor;

	mov	ecx, DWORD PTR tv2222[ebp]
	sub	edi, esi
	sub	edi, 5
	shr	edi, 2
	lea	ecx, DWORD PTR [ecx+esi]
	shl	ecx, 2
	inc	edi
	lea	esi, DWORD PTR [esi+edi*4]
	npad	4
$LL46@normalize_:
	mov	eax, DWORD PTR [edx+56]
	lea	ecx, DWORD PTR [ecx+16]
	movss	xmm0, DWORD PTR [eax+ecx-16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax+ecx-16], xmm0
	mov	eax, DWORD PTR [edx+56]
	movss	xmm0, DWORD PTR [eax+ecx-12]
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax+ecx-12], xmm0
	movaps	xmm0, xmm1
	mov	eax, DWORD PTR [edx+56]
	mulss	xmm0, DWORD PTR [eax+ecx-8]
	movss	DWORD PTR [eax+ecx-8], xmm0
	mov	eax, DWORD PTR [edx+56]
	movss	xmm0, DWORD PTR [eax+ecx-4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax+ecx-4], xmm0
	sub	edi, 1
	jne	SHORT $LL46@normalize_
$LC45@normalize_:

; 2722 :           for (m=0; m < n; m++)

	cmp	esi, ebx
	jge	SHORT $LN44@normalize_

; 2723 :             f_matrix[n*N + m] *= target_factor;

	mov	ecx, DWORD PTR tv2222[ebp]
	mov	edi, ebx
	sub	edi, esi
	lea	ecx, DWORD PTR [ecx+esi]
	shl	ecx, 2
	add	esi, edi
	npad	10
$LC32@normalize_:
	mov	eax, DWORD PTR [edx+56]
	lea	ecx, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [ecx+eax-4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx+eax-4], xmm0
	sub	edi, 1
	jne	SHORT $LC32@normalize_
$LN44@normalize_:

; 2724 : 
; 2725 :           // Scale floating point offsets
; 2726 :           f_offsets[m] *= target_factor;

	mov	eax, DWORD PTR [edx+60]
	mov	edi, DWORD PTR tv2222[ebp]
	mulss	xmm1, DWORD PTR [eax+esi*4]
	movss	DWORD PTR [eax+esi*4], xmm1
	mov	esi, DWORD PTR _N$1$[ebp]
	mov	eax, DWORD PTR tv2153[ebp]
$LN2@normalize_:

; 2697 :   bool need_precise=false;
; 2698 :   for (n=0; n < N; n++)

	add	DWORD PTR tv2221[ebp], 60		; 0000003cH
	inc	ebx
	dec	DWORD PTR tv2218[ebp]
	add	edi, esi
	add	DWORD PTR tv2219[ebp], esi
	mov	DWORD PTR _n$1$[ebp], ebx
	mov	DWORD PTR tv2222[ebp], edi
	cmp	ebx, esi
	jl	$LL4@normalize_

; 2727 :         }
; 2728 :     }
; 2729 : 
; 2730 :   if (need_precise)

	test	al, al
	je	SHORT $LN58@normalize_

; 2731 :     for (n=0; n < N; n++)

	xor	ecx, ecx
	xor	edi, edi
$LL13@normalize_:

; 2732 :       {
; 2733 :         components[n].need_precise = true;

	mov	eax, DWORD PTR [edx+12]
	mov	BYTE PTR [eax+edi+34], 1

; 2734 :         if (dependencies[n] != NULL)

	mov	eax, DWORD PTR [edx+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN11@normalize_

; 2735 :           dependencies[n]->need_precise = true;

	mov	BYTE PTR [eax+34], 1
$LN11@normalize_:

; 2731 :     for (n=0; n < N; n++)

	inc	ecx
	add	edi, 60					; 0000003cH
	cmp	ecx, esi
	jl	SHORT $LL13@normalize_
$LN58@normalize_:
	pop	edi
$LN56@normalize_:
	pop	esi
	pop	ebx
$LN12@normalize_:

; 2736 :       }
; 2737 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@normalize_:

; 2707 :         }
; 2708 :       else if ((dep != NULL) && (dep->bit_depth == 0))

	test	eax, eax
	je	$LN55@normalize_
	mov	ebx, DWORD PTR tv2153[ebp]
	cmp	DWORD PTR [eax+36], 0
	movzx	ebx, bl
	mov	eax, ebx
	mov	DWORD PTR tv2153[ebp], ebx
	mov	ebx, 1
	cmove	eax, ebx
	mov	ebx, DWORD PTR _n$1$[ebp]
	jmp	$LN18@normalize_
?normalize_coefficients@kd_multi_dependency_block@@UAEXXZ ENDP ; kd_multi_dependency_block::normalize_coefficients
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?initialize@kd_multi_dependency_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z
_TEXT	SEGMENT
_num_stage_inputs$ = -52				; size = 4
_num_stage_outputs$ = -48				; size = 4
_output_indices$1$ = -44				; size = 4
_input_indices$1$ = -40					; size = 4
tv2403 = -36						; size = 4
tv2422 = -32						; size = 4
tv2396 = -28						; size = 4
tv2313 = -28						; size = 4
tv2418 = -24						; size = 4
tv2395 = -24						; size = 4
tv2421 = -20						; size = 4
_m$2$ = -16						; size = 4
_i_cf$1$ = -16						; size = 4
_active_outputs$1$ = -12				; size = 4
_N$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
tv2426 = 8						; size = 4
tv2416 = 8						; size = 4
tv2414 = 8						; size = 4
_n$2$ = 8						; size = 4
_stage_idx$ = 8						; size = 4
tv2434 = 12						; size = 4
tv2398 = 12						; size = 4
_m$1$ = 12						; size = 4
_block_idx$ = 12					; size = 4
_tile$ = 16						; size = 4
_num_block_inputs$ = 20					; size = 4
_num_block_outputs$ = 24				; size = 4
_input_collection$ = 28					; size = 4
_output_collection$ = 32				; size = 4
tv2420 = 36						; size = 4
tv2401 = 36						; size = 4
_f_cf$1$ = 36						; size = 4
$T1 = 36						; size = 4
_owner$ = 36						; size = 4
?initialize@kd_multi_dependency_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z PROC ; kd_multi_dependency_block::initialize, COMDAT
; _this$ = ecx

; 2545 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi

; 2546 :   int N = num_block_inputs;

	mov	edi, DWORD PTR _num_block_inputs$[ebp]
	mov	ebx, ecx

; 2547 :   assert(N >= num_block_outputs); // Some outputs might not be used
; 2548 :   int *scratch = owner->get_scratch_ints(3*N); // Safe upper bound

	mov	ecx, DWORD PTR _owner$[ebp]
	mov	DWORD PTR _this$1$[ebp], ebx
	mov	DWORD PTR _N$1$[ebp], edi
	lea	eax, DWORD PTR [edi+edi*2]
	push	eax
	call	?get_scratch_ints@kd_multi_transform@@QAEPAHH@Z ; kd_multi_transform::get_scratch_ints

; 2549 :   int *input_indices = scratch;

	mov	edx, eax

; 2550 :   int *output_indices = input_indices + N;
; 2551 :   int *active_outputs = output_indices + N;
; 2552 :   int m, n, num_stage_inputs, num_stage_outputs;
; 2553 :   tile.get_mct_block_info(stage_idx,block_idx,num_stage_inputs,

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR [edx+edi*4]
	mov	DWORD PTR _input_indices$1$[ebp], edx
	push	ecx
	lea	eax, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR _output_indices$1$[ebp], ecx
	push	edx
	mov	DWORD PTR _active_outputs$1$[ebp], eax
	lea	ecx, DWORD PTR _tile$[ebp]
	lea	eax, DWORD PTR _num_block_outputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_block_inputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_outputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_inputs$[ebp]
	push	eax
	push	DWORD PTR _block_idx$[ebp]
	push	DWORD PTR _stage_idx$[ebp]
	call	?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z ; kdu_tile::get_mct_block_info

; 2560 :   components = new kd_multi_line[N];

	xor	ecx, ecx
	mov	DWORD PTR [ebx+16], edi
	mov	eax, edi
	mov	DWORD PTR [ebx+8], edi
	mov	edx, 60					; 0000003cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], edx
	test	edx, edx
	je	$LN41@initialize
	mov	ecx, edi
	test	edi, edi
	je	SHORT $LN42@initialize
	lea	eax, DWORD PTR [edx+6]
	npad	2
$LL47@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [eax-6], 0
	lea	eax, DWORD PTR [eax+60]
	mov	WORD PTR [eax-60], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [eax-58], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [eax-54], 0
	mov	DWORD PTR [eax-50], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 87   :         row_idx = -1;  num_consumers = outstanding_consumers = 0;

	mov	DWORD PTR [eax-46], -1
	mov	DWORD PTR [eax-38], 0
	mov	DWORD PTR [eax-42], 0

; 88   :         reversible = need_irreversible = need_precise = is_constant = false;

	mov	DWORD PTR [eax-34], 0

; 89   :         bit_depth = 0;  rev_offset = 0;  irrev_offset = 0.0F;

	mov	DWORD PTR [eax-30], 0
	mov	DWORD PTR [eax-26], 0
	mov	DWORD PTR [eax-22], 0

; 90   :         bypass=NULL;  block=NULL;  collection_idx = -1;

	mov	DWORD PTR [eax-18], 0
	mov	DWORD PTR [eax-14], 0
	mov	DWORD PTR [eax-10], -1
	sub	ecx, 1
	jne	SHORT $LL47@initialize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2560 :   components = new kd_multi_line[N];

	jmp	SHORT $LN42@initialize
$LN41@initialize:
	xor	edx, edx
$LN42@initialize:

; 2561 :   dependencies = new kd_multi_line *[N];

	xor	ecx, ecx
	mov	DWORD PTR [ebx+12], edx
	mov	eax, edi
	mov	esi, 4
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+20], eax

; 2562 :   if (is_reversible)
; 2563 :     {
; 2564 :       i_matrix = new int[N*N];

	xor	ecx, ecx
	lea	eax, DWORD PTR [ebx+40]
	add	esp, 4
	mov	DWORD PTR tv2422[ebp], eax
	cmp	BYTE PTR [eax], cl
	je	$LN32@initialize
	mov	edx, edi
	lea	eax, DWORD PTR [ebx+48]
	imul	edx, edi
	mov	DWORD PTR tv2420[ebp], eax
	mov	eax, edx
	mov	DWORD PTR tv2421[ebp], edx
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx+48], eax

; 2565 :       i_offsets = new int[N];

	xor	ecx, ecx
	mov	eax, edi
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 2566 :       int num_triang_coeffs = (N*(N+1) / 2) - 1;
; 2567 :       int *i_cf = i_matrix + (N*N-num_triang_coeffs);

	mov	ecx, DWORD PTR tv2421[ebp]
	mov	esi, eax
	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR [ebx+52], esi
	imul	eax, edi
	add	esp, 8

; 2568 :       tile.get_mct_dependency_info(stage_idx,block_idx,is_reversible,

	push	DWORD PTR _active_outputs$1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	mov	eax, DWORD PTR [ebx+48]
	push	esi
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, 4
	lea	ecx, DWORD PTR _tile$[ebp]
	mov	esi, eax
	mov	DWORD PTR _i_cf$1$[ebp], eax
	push	esi
	push	0
	push	0
	lea	eax, DWORD PTR [ebx+40]
	push	eax
	mov	eax, DWORD PTR _block_idx$[ebp]
	push	eax
	mov	eax, DWORD PTR _stage_idx$[ebp]
	push	eax
	call	?get_mct_dependency_info@kdu_tile@@QAE_NHHAA_NPAM1PAH22@Z ; kdu_tile::get_mct_dependency_info

; 2569 :                                    NULL,NULL,i_cf,i_offsets,
; 2570 :                                    active_outputs);
; 2571 :       assert(is_reversible);
; 2572 : 
; 2573 :       // Reorganize triangular coefficients into a square matrix
; 2574 :       for (m=0; m < N; m++)

	xor	ebx, ebx
	mov	DWORD PTR _m$1$[ebp], ebx
	test	edi, edi
	jle	$LN12@initialize
	lea	eax, DWORD PTR [edi*4+4]
	mov	DWORD PTR tv2418[ebp], eax
$LL4@initialize:

; 2575 :         { // Scan rows of matrix
; 2576 :           for (n=0; n < m; n++)

	test	ebx, ebx
	jle	SHORT $LN137@initialize

; 2577 :             i_matrix[m*N+n] = *(i_cf++);

	mov	edx, ebx
	imul	edx, edi
	mov	edi, ebx
	mov	ebx, DWORD PTR _this$1$[ebp]
	shl	edx, 2
$LL81@initialize:
	mov	ecx, DWORD PTR [ebx+48]
	lea	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [esi]
	add	esi, 4
	mov	DWORD PTR [edx+ecx-4], eax
	sub	edi, 1
	jne	SHORT $LL81@initialize

; 2578 :           i_matrix[m*N+m] = (m==0)?1:(*(i_cf++));

	mov	ebx, DWORD PTR _m$1$[ebp]
	test	ebx, ebx
	mov	edi, DWORD PTR _N$1$[ebp]
	mov	eax, DWORD PTR tv2418[ebp]
	mov	DWORD PTR _i_cf$1$[ebp], esi
$LN137@initialize:
	jne	SHORT $LN43@initialize
	mov	edx, 1
	jmp	SHORT $LN44@initialize
$LN43@initialize:
	mov	edx, DWORD PTR [esi]
	add	esi, 4
	mov	DWORD PTR _i_cf$1$[ebp], esi
$LN44@initialize:
	mov	ecx, eax
	mov	eax, DWORD PTR _this$1$[ebp]
	imul	ecx, ebx
	mov	eax, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx+eax], edx

; 2579 :           for (n=m+1; n < N; n++)

	lea	edx, DWORD PTR [ebx+1]
	mov	eax, edi
	mov	DWORD PTR tv2434[ebp], edx
	sub	eax, edx
	mov	esi, edx
	mov	DWORD PTR tv2313[ebp], eax
	cmp	edx, edi
	jge	$LN130@initialize
	cmp	eax, 4
	jb	$LN130@initialize

; 2580 :             i_matrix[m*N+n] = 0;

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	edx, ebx
	imul	edx, edi
	mov	ecx, DWORD PTR [eax+48]
	mov	eax, esi
	add	eax, edx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv2416[ebp], eax
	lea	eax, DWORD PTR [edx+edi]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR tv2420[ebp]
	add	ecx, -4					; fffffffcH
	cmp	DWORD PTR tv2416[ebp], eax
	ja	SHORT $LN85@initialize
	cmp	ecx, eax
	jae	SHORT $LN132@initialize
$LN85@initialize:
	mov	eax, DWORD PTR tv2313[ebp]
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN135@initialize
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN135@initialize:
	sub	edi, eax
$LL10@initialize:

; 2579 :           for (n=m+1; n < N; n++)

	add	esi, 4
	cmp	esi, edi
	jl	SHORT $LL10@initialize

; 2580 :             i_matrix[m*N+n] = 0;

	sub	edi, DWORD PTR tv2434[ebp]
	lea	eax, DWORD PTR [edi+3]
	mov	edi, DWORD PTR tv2416[ebp]
	cdq
	and	edx, 3
	lea	ecx, DWORD PTR [edx+eax]
	sar	ecx, 2
	shl	ecx, 4
	shr	ecx, 2
	xor	eax, eax
	rep stosd
	mov	edi, DWORD PTR _N$1$[ebp]
	mov	eax, DWORD PTR tv2420[ebp]
$LN132@initialize:
	mov	edx, DWORD PTR tv2434[ebp]
$LN84@initialize:

; 2579 :           for (n=m+1; n < N; n++)

	cmp	esi, edi
	jge	SHORT $LN2@initialize

; 2580 :             i_matrix[m*N+n] = 0;

	imul	ebx, edi
$LL83@initialize:
	mov	eax, DWORD PTR [eax]
	lea	ecx, DWORD PTR [ebx+esi]
	inc	esi
	mov	DWORD PTR [eax+ecx*4], 0
	mov	eax, DWORD PTR tv2420[ebp]
	cmp	esi, edi
	jl	SHORT $LL83@initialize
$LN2@initialize:

; 2569 :                                    NULL,NULL,i_cf,i_offsets,
; 2570 :                                    active_outputs);
; 2571 :       assert(is_reversible);
; 2572 : 
; 2573 :       // Reorganize triangular coefficients into a square matrix
; 2574 :       for (m=0; m < N; m++)

	mov	esi, DWORD PTR _i_cf$1$[ebp]
	mov	ebx, edx
	mov	eax, DWORD PTR tv2418[ebp]
	mov	DWORD PTR _m$1$[ebp], ebx
	cmp	ebx, edi
	jl	$LL4@initialize

; 2581 :         }
; 2582 :       assert((i_cf-i_matrix) == (N*N));
; 2583 :     }
; 2584 :   else

	jmp	$LN12@initialize
$LN130@initialize:
	mov	eax, DWORD PTR tv2420[ebp]
	jmp	SHORT $LN84@initialize
$LN32@initialize:

; 2585 :     {
; 2586 :       f_matrix = new float[N*N];

	mov	eax, edi
	add	ebx, 56					; 00000038H
	imul	eax, edi
	mov	DWORD PTR tv2421[ebp], eax
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [ebx], eax

; 2587 :       f_offsets = new float[N];

	xor	ecx, ecx
	mov	eax, edi
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax

; 2588 :       int num_triang_coeffs = (N*(N-1)) / 2;
; 2589 :       float *f_cf = f_matrix + (N*N-num_triang_coeffs);

	mov	ecx, DWORD PTR tv2421[ebp]
	mov	eax, DWORD PTR _this$1$[ebp]
	add	esp, 8

; 2590 :       tile.get_mct_dependency_info(stage_idx,block_idx,is_reversible,

	push	DWORD PTR _active_outputs$1$[ebp]
	mov	DWORD PTR [eax+60], esi
	lea	eax, DWORD PTR [edi-1]
	imul	eax, edi
	push	0
	push	0
	push	esi
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	mov	eax, DWORD PTR [ebx]
	lea	eax, DWORD PTR [eax+ecx*4]
	push	eax
	mov	DWORD PTR _f_cf$1$[ebp], eax
	lea	ecx, DWORD PTR _tile$[ebp]
	mov	eax, DWORD PTR tv2422[ebp]
	push	eax
	mov	eax, DWORD PTR _block_idx$[ebp]
	push	eax
	mov	eax, DWORD PTR _stage_idx$[ebp]
	push	eax
	call	?get_mct_dependency_info@kdu_tile@@QAE_NHHAA_NPAM1PAH22@Z ; kdu_tile::get_mct_dependency_info

; 2591 :                                    f_cf,f_offsets,NULL,NULL,
; 2592 :                                    active_outputs);
; 2593 :       assert(!is_reversible);
; 2594 : 
; 2595 :       // Reorganize triangular coefficients into a square matrix
; 2596 :       for (m=0; m < N; m++)

	xor	ecx, ecx
	mov	DWORD PTR _m$2$[ebp], ecx
	test	edi, edi
	jle	$LN12@initialize

; 2585 :     {
; 2586 :       f_matrix = new float[N*N];

	xor	eax, eax
	lea	esi, DWORD PTR [edi*4-4]
	xor	edx, edx
	mov	DWORD PTR tv2398[ebp], eax
	mov	DWORD PTR tv2396[ebp], edx
	mov	DWORD PTR tv2395[ebp], esi
$LL13@initialize:

; 2597 :         { // Scan rows of matrix
; 2598 :           for (n=0; n < m; n++)

	xor	esi, esi
	cmp	ecx, 4
	jl	SHORT $LN129@initialize

; 2599 :             f_matrix[m*N+n] = *(f_cf++);

	lea	eax, DWORD PTR [ecx-4]
	mov	edi, edx
	mov	edx, DWORD PTR _f_cf$1$[ebp]
	shr	eax, 2
	inc	eax
	mov	DWORD PTR tv2403[ebp], eax
	lea	esi, DWORD PTR [eax*4]
	mov	DWORD PTR _n$2$[ebp], esi
	mov	esi, eax
$LL110@initialize:
	mov	ecx, DWORD PTR [ebx]
	lea	edi, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edi+ecx-16], eax
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+ecx-12], eax
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [edi+ecx-8], eax
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+12]
	add	edx, 16					; 00000010H
	mov	DWORD PTR [edi+ecx-4], eax
	sub	esi, 1
	jne	SHORT $LL110@initialize
	mov	esi, DWORD PTR _n$2$[ebp]
	mov	edi, DWORD PTR _N$1$[ebp]
	mov	eax, DWORD PTR tv2398[ebp]
	mov	ecx, DWORD PTR _m$2$[ebp]
	mov	DWORD PTR _f_cf$1$[ebp], edx
	jmp	SHORT $LC109@initialize
$LN129@initialize:
	mov	edx, DWORD PTR _f_cf$1$[ebp]
$LC109@initialize:

; 2597 :         { // Scan rows of matrix
; 2598 :           for (n=0; n < m; n++)

	cmp	esi, ecx
	jge	SHORT $LN108@initialize

; 2599 :             f_matrix[m*N+n] = *(f_cf++);

	lea	edi, DWORD PTR [eax+esi]
	mov	eax, ecx
	sub	eax, esi
	shl	edi, 2
	add	esi, eax
	mov	DWORD PTR tv2401[ebp], eax
	mov	DWORD PTR _n$2$[ebp], esi
	mov	esi, eax
$LC86@initialize:
	mov	ecx, DWORD PTR [ebx]
	lea	edi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx]
	add	edx, 4
	mov	DWORD PTR [edi+ecx-4], eax
	sub	esi, 1
	jne	SHORT $LC86@initialize
	mov	esi, DWORD PTR _n$2$[ebp]
	mov	edi, DWORD PTR _N$1$[ebp]
	mov	DWORD PTR _f_cf$1$[ebp], edx
$LN108@initialize:

; 2600 :           for (; n < N; n++)

	mov	ecx, edi
	sub	ecx, esi
	cmp	esi, edi
	jge	$LN11@initialize
	cmp	ecx, 4
	jb	SHORT $LN89@initialize

; 2601 :             f_matrix[m*N+n] = 0.0F;

	mov	eax, DWORD PTR tv2398[ebp]
	mov	edx, DWORD PTR [ebx]
	add	eax, esi
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	eax, ebx
	ja	SHORT $LN90@initialize
	mov	eax, DWORD PTR tv2395[ebp]
	mov	edi, DWORD PTR _N$1$[ebp]
	add	eax, edx
	cmp	eax, ebx
	jae	SHORT $LN89@initialize
$LN90@initialize:
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN136@initialize
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN136@initialize:
	mov	eax, esi
	sub	edi, ecx
	mov	DWORD PTR tv2426[ebp], eax
	npad	3
$LL19@initialize:

; 2600 :           for (; n < N; n++)

	add	esi, 4
	cmp	esi, edi
	jl	SHORT $LL19@initialize

; 2601 :             f_matrix[m*N+n] = 0.0F;

	sub	edi, eax
	lea	eax, DWORD PTR [edi+3]
	mov	edi, DWORD PTR [ebx]
	cdq
	and	edx, 3
	lea	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR tv2398[ebp]
	sar	ecx, 2
	xor	eax, eax
	shl	ecx, 4
	shr	ecx, 2
	add	edx, DWORD PTR tv2426[ebp]
	lea	edi, DWORD PTR [edi+edx*4]
	rep stosd
	mov	edi, DWORD PTR _N$1$[ebp]
$LN89@initialize:
	cmp	esi, edi
	jge	$LN11@initialize
	mov	eax, edi
	sub	eax, esi

; 2600 :           for (; n < N; n++)

	cmp	eax, 4
	jl	SHORT $LC112@initialize

; 2601 :             f_matrix[m*N+n] = 0.0F;

	lea	eax, DWORD PTR [edi-3]
	mov	edi, DWORD PTR tv2398[ebp]
	mov	DWORD PTR tv2414[ebp], eax
	lea	eax, DWORD PTR [edi+esi]
	lea	edx, DWORD PTR [eax*4+12]
$LL113@initialize:
	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [edi+esi]
	add	esi, 4
	lea	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+ecx*4], 0
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [eax+ecx*4+4], 0
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [edx+eax-20], 0
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [edx+eax-16], 0
	cmp	esi, DWORD PTR tv2414[ebp]
	jl	SHORT $LL113@initialize
	mov	edi, DWORD PTR _N$1$[ebp]
$LC112@initialize:

; 2600 :           for (; n < N; n++)

	cmp	esi, edi
	jge	SHORT $LN11@initialize
	npad	2
$LC88@initialize:

; 2601 :             f_matrix[m*N+n] = 0.0F;

	mov	ecx, DWORD PTR tv2398[ebp]
	mov	eax, DWORD PTR [ebx]
	add	ecx, esi
	inc	esi
	mov	DWORD PTR [eax+ecx*4], 0
	cmp	esi, edi
	jl	SHORT $LC88@initialize
$LN11@initialize:

; 2591 :                                    f_cf,f_offsets,NULL,NULL,
; 2592 :                                    active_outputs);
; 2593 :       assert(!is_reversible);
; 2594 : 
; 2595 :       // Reorganize triangular coefficients into a square matrix
; 2596 :       for (m=0; m < N; m++)

	mov	ecx, DWORD PTR _m$2$[ebp]
	lea	esi, DWORD PTR [edi*4]
	mov	eax, DWORD PTR tv2398[ebp]
	inc	ecx
	mov	edx, DWORD PTR tv2396[ebp]
	add	eax, edi
	add	DWORD PTR tv2395[ebp], esi
	add	edx, esi
	mov	DWORD PTR _m$2$[ebp], ecx
	mov	DWORD PTR tv2398[ebp], eax
	mov	DWORD PTR tv2396[ebp], edx
	cmp	ecx, edi
	jl	$LL13@initialize
$LN12@initialize:

; 2602 :         }
; 2603 :       assert((f_cf-f_matrix) == (N*N));
; 2604 :     }
; 2605 : 
; 2606 :   // For reversible transforms, see if the coefficients can be represented
; 2607 :   // as short integers; if not, we will need to use a more precise
; 2608 :   // sample representation.
; 2609 :   bool need_precise = false;
; 2610 :   if (is_reversible)

	mov	eax, DWORD PTR tv2422[ebp]
	xor	bl, bl
	cmp	BYTE PTR [eax], bl
	je	SHORT $LN21@initialize

; 2611 :     for (n=0; n < (N*N); n++)

	mov	esi, DWORD PTR tv2421[ebp]
	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN21@initialize

; 2612 :       if ((i_matrix[n] > 0x7FFF) || (i_matrix[n] < -0x7FFF))

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	edx, DWORD PTR [edx+48]
$LL91@initialize:
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	ecx, 32767				; 00007fffH
	jg	SHORT $LN92@initialize
	cmp	ecx, -32767				; ffff8001H
	jge	SHORT $LN93@initialize
$LN92@initialize:

; 2613 :         need_precise = true;

	mov	bl, 1
$LN93@initialize:

; 2611 :     for (n=0; n < (N*N); n++)

	inc	eax
	cmp	eax, esi
	jl	SHORT $LL91@initialize
$LN21@initialize:
	mov	ecx, DWORD PTR _this$1$[ebp]

; 2614 : 
; 2615 :   // Configure dependencies
; 2616 :   for (n=0; n < N; n++)

	xor	esi, esi
	test	edi, edi
	jle	$LN27@initialize
	npad	5
$LL25@initialize:

; 2617 :     {
; 2618 :       dependencies[n] = input_collection->components[input_indices[n]];

	mov	eax, DWORD PTR _input_indices$1$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _input_collection$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+esi*4], eax

; 2619 :       if (dependencies[n] == NULL)

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, eax
	je	SHORT $LN23@initialize

; 2620 :         continue;
; 2621 :       dependencies[n]->num_consumers++;

	inc	DWORD PTR [eax+24]

; 2622 :       if (is_reversible)

	cmp	BYTE PTR [ecx+40], 0
	je	SHORT $LN38@initialize

; 2623 :         dependencies[n]->reversible = true;

	mov	eax, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	BYTE PTR [eax+32], 1
$LN38@initialize:

; 2624 :       if (need_precise)

	test	bl, bl
	je	SHORT $LN23@initialize

; 2625 :         dependencies[n]->need_precise = true;

	mov	eax, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	BYTE PTR [eax+34], 1
$LN23@initialize:

; 2614 : 
; 2615 :   // Configure dependencies
; 2616 :   for (n=0; n < N; n++)

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL25@initialize

; 2626 :     }
; 2627 : 
; 2628 :   // Configure transform components
; 2629 :   for (n=0; n < N; n++)

	test	edi, edi
	jle	SHORT $LN27@initialize
	xor	edx, edx
	lea	esi, DWORD PTR [ecx+40]
	jmp	SHORT $LN28@initialize
$LL133@initialize:
	mov	ecx, DWORD PTR _this$1$[ebp]
$LN28@initialize:

; 2630 :     {
; 2631 :       kd_multi_line *line = components + n;

	mov	ecx, DWORD PTR [ecx+12]

; 2632 :       line->block = this;

	mov	eax, DWORD PTR _this$1$[ebp]
	add	ecx, edx
	mov	DWORD PTR [ecx+52], eax

; 2633 :       line->need_precise = need_precise;

	mov	BYTE PTR [ecx+34], bl

; 2634 :       line->reversible = is_reversible;

	mov	al, BYTE PTR [esi]
	mov	BYTE PTR [ecx+32], al

; 2635 :       line->need_irreversible = !is_reversible;

	cmp	BYTE PTR [esi], 0
	sete	al
	add	edx, 60					; 0000003cH
	mov	BYTE PTR [ecx+33], al
	sub	edi, 1
	jne	SHORT $LL133@initialize
$LN27@initialize:

; 2636 :     }
; 2637 : 
; 2638 :   // Configure outputs; note that we leave the output offsets equal to 0, since
; 2639 :   // offsets are applied prior to dependency transforms -- they are captured
; 2640 :   // by the `f_offsets' and `i_offsets' members.  There may still be output
; 2641 :   // offsets, applied by the framework, to account for the fact that final
; 2642 :   // output components should have a signed representation.  Both types of
; 2643 :   // offsets need to be taken into account when applying the transform.
; 2644 :   for (n=0; n < num_block_outputs; n++)

	xor	esi, esi
	cmp	DWORD PTR _num_block_outputs$[ebp], esi
	jle	SHORT $LN30@initialize
	mov	eax, DWORD PTR _active_outputs$1$[ebp]
	mov	ebx, DWORD PTR _output_indices$1$[ebp]
	sub	eax, ebx
	mov	edi, DWORD PTR _output_collection$[ebp]
	mov	DWORD PTR _active_outputs$1$[ebp], eax
	npad	1
$LL31@initialize:

; 2645 :     {
; 2646 :       kd_multi_line *line = components + active_outputs[n];

	mov	eax, DWORD PTR [eax+ebx]
	lea	ebx, DWORD PTR [ebx+4]
	mov	ecx, eax
	inc	esi
	shl	ecx, 4
	sub	ecx, eax
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+12]
	lea	edx, DWORD PTR [eax+ecx*4]

; 2647 :       output_collection->components[output_indices[n]] = line;

	mov	ecx, DWORD PTR [ebx-4]
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _active_outputs$1$[ebp]
	cmp	esi, DWORD PTR _num_block_outputs$[ebp]
	jl	SHORT $LL31@initialize
$LN30@initialize:
	pop	edi
	pop	esi
	pop	ebx

; 2648 :     }
; 2649 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?initialize@kd_multi_dependency_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z ENDP ; kd_multi_dependency_block::initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??1kd_multi_dependency_block@@UAE@XZ
_TEXT	SEGMENT
??1kd_multi_dependency_block@@UAE@XZ PROC		; kd_multi_dependency_block::~kd_multi_dependency_block, COMDAT
; _this$ = ecx

; 460  :       {

	push	esi
	mov	esi, ecx

; 461  :         if (i_matrix != NULL) delete[] i_matrix;

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_dependency_block@@6B@
	test	eax, eax
	je	SHORT $LN2@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_multi_d:

; 462  :         if (i_offsets != NULL) delete[] i_offsets;

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN3@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@kd_multi_d:

; 463  :         if (f_matrix != NULL) delete[] f_matrix;

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN4@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN4@kd_multi_d:

; 464  :         if (f_offsets != NULL) delete[] f_offsets;

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN5@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@kd_multi_d:

; 465  :         if (short_matrix != NULL) delete[] short_matrix;

	mov	eax, DWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN6@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@kd_multi_d:

; 466  :         if (accumulator != NULL) delete[] accumulator;

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN7@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@kd_multi_d:

; 199  :         if (components != NULL) delete[] components;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_block@@6B@
	test	eax, eax
	je	SHORT $LN10@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN10@kd_multi_d:

; 200  :         if (dependencies != NULL) delete[] dependencies;

	mov	eax, DWORD PTR [esi+20]
	pop	esi
	test	eax, eax
	je	SHORT $LN11@kd_multi_d
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN11@kd_multi_d:

; 467  :       }

	ret	0
??1kd_multi_dependency_block@@UAE@XZ ENDP		; kd_multi_dependency_block::~kd_multi_dependency_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??0kd_multi_dependency_block@@QAE@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_is_reversible$ = 8					; size = 1
??0kd_multi_dependency_block@@QAE@_N@Z PROC		; kd_multi_dependency_block::kd_multi_dependency_block, COMDAT
; _this$ = ecx

; 453  :     kd_multi_dependency_block(bool is_reversible)

	push	ebp
	mov	ebp, esp
	push	ecx

; 455  :         is_null_transform=false;  this->is_reversible = is_reversible;

	mov	al, BYTE PTR _is_reversible$[ebp]
	mov	BYTE PTR [ecx+40], al

; 458  :       }

	mov	eax, ecx
	mov	DWORD PTR _this$[ebp], ecx

; 193  :         num_components = 0;  components = NULL;  next = prev = NULL;

	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+32], 0

; 194  :         num_dependencies = num_available_dependencies = 0; dependencies = NULL;

	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0

; 195  :         outstanding_consumers = 0;

	mov	DWORD PTR [ecx+28], 0

; 454  :       {

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_dependency_block@@6B@

; 455  :         is_null_transform=false;  this->is_reversible = is_reversible;

	mov	BYTE PTR [ecx+4], 0

; 456  :         num_coeffs=0; short_matrix=NULL;  short_downshift=0; accumulator=NULL;

	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+64], 0
	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+72], 0

; 457  :         i_matrix = i_offsets = NULL;  f_matrix = f_offsets = NULL;

	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+56], 0

; 458  :       }

	mov	esp, ebp
	pop	ebp
	ret	4
??0kd_multi_dependency_block@@QAE@_N@Z ENDP		; kd_multi_dependency_block::kd_multi_dependency_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??_Gkd_multi_rxform_block@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_multi_rxform_block@@UAEPAXI@Z PROC		; kd_multi_rxform_block::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 430  :         if (coefficients != NULL) delete[] coefficients;

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_rxform_block@@6B@
	test	eax, eax
	je	SHORT $LN5@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@scalar:

; 431  :         if (accumulator != NULL) delete[] accumulator;

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN6@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@scalar:

; 199  :         if (components != NULL) delete[] components;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_block@@6B@
	test	eax, eax
	je	SHORT $LN10@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN10@scalar:

; 200  :         if (dependencies != NULL) delete[] dependencies;

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN11@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN11@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN14@scalar
	push	48					; 00000030H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN14@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_multi_rxform_block@@UAEPAXI@Z ENDP		; kd_multi_rxform_block::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?perform_inverse@kd_multi_rxform_block@@UAEXXZ
_TEXT	SEGMENT
_e$2 = -184						; size = 20
tv1167 = -164						; size = 4
tv1166 = -160						; size = 4
_divisor$1$ = -156					; size = 4
tv1149 = -152						; size = 4
_factor$1$ = -148					; size = 4
_factor$1$ = -148					; size = 4
_n$1$ = -144						; size = 4
tv1084 = -140						; size = 4
tv1083 = -136						; size = 4
_dst_idx$1$ = -132					; size = 4
tv1144 = -128						; size = 4
_downshift$1$ = -124					; size = 4
_this$GSCopy$1$ = -120					; size = 4
tv1168 = -116						; size = 4
_m$2$ = -116						; size = 4
_m$1$ = -116						; size = 4
tv1151 = -112						; size = 4
tv1145 = -112						; size = 4
tv1150 = -108						; size = 4
tv1146 = -108						; size = 4
_N$1$ = -104						; size = 4
tv1148 = -100						; size = 4
tv1147 = -100						; size = 4
_offset$1$ = -100					; size = 4
_text$3 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?perform_inverse@kd_multi_rxform_block@@UAEXXZ PROC	; kd_multi_rxform_block::perform_inverse, COMDAT
; _this$ = ecx

; 2435 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?perform_inverse@kd_multi_rxform_block@@UAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx

; 2436 :   int N = num_components;

	mov	ecx, DWORD PTR [ebx+8]

; 2437 :   int m, n;
; 2438 : 
; 2439 :   // Execute the transform steps in reverse order
; 2440 :   for (n=N; n >= 0; n--)

	mov	eax, ecx
	mov	DWORD PTR _N$1$[ebp], ecx
	mov	DWORD PTR _n$1$[ebp], eax
	test	ecx, ecx
	js	$LN3@perform_in
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR tv1166[ebp], edx
	lea	edi, DWORD PTR [ebx+44]
	lea	edx, DWORD PTR [ecx*4]
	mov	DWORD PTR tv1167[ebp], edi
	mov	DWORD PTR tv1149[ebp], edx
	mov	DWORD PTR tv1144[ebp], edx
	npad	5
$LL4@perform_in:

; 2441 :     { // Walk through the columns of the coefficient matrix
; 2442 :       int dst_idx = (N-1)-(n % N);

	cdq
	idiv	ecx

; 2443 :       kd_multi_line *line = components + dst_idx;

	mov	esi, DWORD PTR [ebx+12]
	mov	eax, ecx
	sub	eax, edx
	mov	DWORD PTR tv1084[ebp], esi
	dec	eax
	mov	ecx, eax
	mov	DWORD PTR _dst_idx$1$[ebp], eax
	shl	ecx, 4
	sub	ecx, eax

; 2445 :       if (accumulator == NULL)

	cmp	DWORD PTR [edi], 0
	mov	DWORD PTR tv1083[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 544  :         return width;

	mov	esi, DWORD PTR [esi+ecx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2445 :       if (accumulator == NULL)

	jne	SHORT $LN37@perform_in

; 2446 :         accumulator = new kdu_int32[width];

	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi], eax
	add	esp, 4
	mov	eax, DWORD PTR _dst_idx$1$[ebp]
$LN37@perform_in:

; 2447 :       kdu_int32 divisor = coefficients[dst_idx*(N+1)+n];

	mov	ecx, DWORD PTR tv1166[ebp]
	mov	edx, DWORD PTR _n$1$[ebp]
	imul	ecx, eax
	mov	eax, DWORD PTR [ebx+40]
	add	ecx, edx
	mov	ebx, DWORD PTR [eax+ecx*4]

; 2448 :       kdu_int32 abs_divisor = divisor;

	mov	ecx, ebx
	mov	DWORD PTR _divisor$1$[ebp], ebx
	mov	DWORD PTR _offset$1$[ebp], ecx

; 2449 :       if ((n==N) && (divisor < 0))

	cmp	edx, DWORD PTR _N$1$[ebp]
	jne	SHORT $LN38@perform_in
	test	ebx, ebx
	jns	SHORT $LN38@perform_in

; 2450 :         abs_divisor = -divisor;

	neg	ecx
	mov	DWORD PTR _offset$1$[ebp], ecx
$LN38@perform_in:

; 2451 :       kdu_int32 downshift = 0;

	xor	edx, edx
	mov	DWORD PTR _downshift$1$[ebp], edx
	lea	eax, DWORD PTR [edx+1]

; 2452 :       while ((1<<downshift) < abs_divisor)

	cmp	ecx, eax
	jle	SHORT $LN6@perform_in
	npad	5
$LL5@perform_in:

; 2453 :         downshift++;

	rol	eax, 1
	inc	edx
	cmp	eax, ecx
	jl	SHORT $LL5@perform_in
	mov	DWORD PTR _downshift$1$[ebp], edx
$LN6@perform_in:

; 2454 :       if ((1<<downshift) != abs_divisor)

	cmp	eax, ecx
	je	$LN39@perform_in

; 2455 :         { KDU_ERROR(e,0x23090502); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0LJ@PJJIHOJD@Multi?9component?5reversible?5decor@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2455 :         { KDU_ERROR(e,0x23090502); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$2[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	ebx
	push	eax
	lea	eax, DWORD PTR _text$3[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$3[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	eax
	mov	eax, DWORD PTR _e$2[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2460 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _offset$1$[ebp]
$LN39@perform_in:

; 2461 :       kdu_int32 offset = abs_divisor >> 1;

	sar	ecx, 1

; 2462 :       for (w=0; w < width; w++)

	xor	ebx, ebx
	mov	DWORD PTR _offset$1$[ebp], ecx
	test	esi, esi
	jle	SHORT $LN8@perform_in
	cmp	esi, 4
	jb	SHORT $LN106@perform_in

; 2463 :         accumulator[w] = offset;

	mov	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi-1]
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	edx, edi
	ja	SHORT $LN107@perform_in
	cmp	eax, edi
	jae	SHORT $LN106@perform_in
$LN107@perform_in:
	mov	eax, esi
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN139@perform_in
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN139@perform_in:
	mov	ecx, esi
	sub	ecx, eax
	npad	3
$LL9@perform_in:

; 2462 :       for (w=0; w < width; w++)

	add	ebx, 4
	cmp	ebx, ecx
	jl	SHORT $LL9@perform_in

; 2463 :         accumulator[w] = offset;

	mov	edi, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+3]
	cdq
	and	edx, 3
	lea	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _offset$1$[ebp]
	sar	ecx, 2
	shl	ecx, 4
	shr	ecx, 2
	rep stosd
	mov	edi, DWORD PTR tv1167[ebp]
	mov	ecx, eax
$LN106@perform_in:

; 2462 :       for (w=0; w < width; w++)

	cmp	ebx, esi
	jge	SHORT $LN8@perform_in
	npad	3
$LL105@perform_in:

; 2463 :         accumulator[w] = offset;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+ebx*4], ecx
	inc	ebx
	cmp	ebx, esi
	jl	SHORT $LL105@perform_in
$LN8@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	eax, DWORD PTR tv1083[ebp]
	mov	edx, DWORD PTR tv1084[ebp]
	test	BYTE PTR [edx+eax*4+6], 2
	jne	$LN40@perform_in
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2464 :       if (line->line.get_buf32() != NULL)

	cmp	DWORD PTR [edx+eax*4+8], 0
	je	$LN40@perform_in

; 2465 :         { // Processing with 32-bit integers
; 2466 :           for (m=0; m < N; m++)

	xor	ecx, ecx
	mov	DWORD PTR _m$1$[ebp], ecx
	cmp	DWORD PTR _N$1$[ebp], ecx
	jle	$LN11@perform_in
	mov	edx, DWORD PTR tv1149[ebp]
	xor	ebx, ebx
	add	edx, 4
	mov	DWORD PTR tv1151[ebp], ebx
	mov	DWORD PTR tv1148[ebp], edx
	mov	edx, DWORD PTR tv1144[ebp]
	mov	eax, DWORD PTR tv1148[ebp]
	mov	DWORD PTR tv1150[ebp], edx
$LL12@perform_in:

; 2467 :             {
; 2468 :               if (m == dst_idx)

	cmp	ecx, DWORD PTR _dst_idx$1$[ebp]
	je	SHORT $LN10@perform_in

; 2469 :                 continue;
; 2470 :               kdu_int32 factor = coefficients[m*(N+1)+n];

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _factor$1$[ebp], eax

; 2471 :               if (factor == 0)

	test	eax, eax
	je	SHORT $LN137@perform_in

; 2472 :                 continue;
; 2473 :               kdu_sample32 *src = components[m].line.get_buf32();

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [eax+ebx+6], 2
	je	SHORT $LN67@perform_in
	xor	ebx, ebx
	jmp	SHORT $LN68@perform_in
$LN67@perform_in:
	mov	ebx, DWORD PTR [eax+ebx+8]
$LN68@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2474 :               for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN135@perform_in
	npad	6
$LL15@perform_in:

; 2475 :                 accumulator[w] += src[w].ival * factor;

	mov	eax, DWORD PTR [ebx+edx*4]
	imul	eax, DWORD PTR _factor$1$[ebp]
	mov	ecx, DWORD PTR [edi]
	add	DWORD PTR [ecx+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL15@perform_in
	mov	ecx, DWORD PTR _m$1$[ebp]
$LN135@perform_in:
	mov	ebx, DWORD PTR tv1151[ebp]
	mov	edx, DWORD PTR tv1150[ebp]
$LN137@perform_in:
	mov	eax, DWORD PTR tv1148[ebp]
$LN10@perform_in:

; 2465 :         { // Processing with 32-bit integers
; 2466 :           for (m=0; m < N; m++)

	inc	ecx
	add	edx, eax
	add	ebx, 60					; 0000003cH
	mov	DWORD PTR _m$1$[ebp], ecx
	mov	DWORD PTR tv1150[ebp], edx
	mov	DWORD PTR tv1151[ebp], ebx
	cmp	ecx, DWORD PTR _N$1$[ebp]
	jl	SHORT $LL12@perform_in
	mov	eax, DWORD PTR tv1083[ebp]
	mov	edx, DWORD PTR tv1084[ebp]
$LN11@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edx+eax*4+6], 2
	je	SHORT $LN71@perform_in
	xor	ebx, ebx
	jmp	SHORT $LN72@perform_in
$LN71@perform_in:
	mov	ebx, DWORD PTR [edx+eax*4+8]
$LN72@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2481 :               for (w=0; w < width; w++)

	xor	edx, edx
	cmp	DWORD PTR _divisor$1$[ebp], edx
	jge	SHORT $LN44@perform_in
	test	esi, esi
	jle	$LN2@perform_in
	mov	ecx, DWORD PTR _downshift$1$[ebp]
$LL18@perform_in:

; 2482 :                 dst[w].ival = (-dst[w].ival) + (accumulator[w]>>downshift);

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	sub	eax, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [ebx+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL18@perform_in

; 2483 :             }
; 2484 :           else

	jmp	$LN2@perform_in
$LN44@perform_in:

; 2485 :             { // Usual case, with a positive divisor
; 2486 :               for (w=0; w < width; w++)

	test	esi, esi
	jle	$LN2@perform_in
	mov	ecx, DWORD PTR _downshift$1$[ebp]
$LL21@perform_in:

; 2487 :                 dst[w].ival += (accumulator[w]>>downshift);

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	add	DWORD PTR [ebx+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL21@perform_in

; 2488 :             }
; 2489 :         }
; 2490 :       else

	jmp	$LN2@perform_in
$LN40@perform_in:

; 2491 :         { // Processing with 16-bit integers
; 2492 :           for (m=0; m < N; m++)

	xor	ecx, ecx
	mov	DWORD PTR _m$2$[ebp], ecx
	cmp	DWORD PTR _N$1$[ebp], ecx
	jle	$LN23@perform_in
	mov	edx, DWORD PTR tv1149[ebp]
	xor	ebx, ebx
	add	edx, 4
	mov	DWORD PTR tv1146[ebp], ebx
	mov	DWORD PTR tv1147[ebp], edx
	mov	edx, DWORD PTR tv1144[ebp]
	mov	eax, DWORD PTR tv1147[ebp]
	mov	DWORD PTR tv1145[ebp], edx
$LL24@perform_in:

; 2493 :             {
; 2494 :               if (m == dst_idx)

	cmp	ecx, DWORD PTR _dst_idx$1$[ebp]
	je	SHORT $LN22@perform_in

; 2495 :                 continue;
; 2496 :               kdu_int32 factor = coefficients[m*(N+1)+n];

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _factor$1$[ebp], eax

; 2497 :               if (factor == 0)

	test	eax, eax
	je	SHORT $LN136@perform_in

; 2498 :                 continue;
; 2499 :               kdu_sample16 *src = components[m].line.get_buf16();

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [eax+ebx+6], 2
	je	SHORT $LN75@perform_in
	mov	ebx, DWORD PTR [eax+ebx+8]
	jmp	SHORT $LN76@perform_in
$LN75@perform_in:
	xor	ebx, ebx
$LN76@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2500 :               for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN134@perform_in
	npad	8
$LL27@perform_in:

; 2501 :                 accumulator[w] += ((kdu_int32) src[w].ival) * factor;

	movsx	eax, WORD PTR [ebx+edx*2]
	imul	eax, DWORD PTR _factor$1$[ebp]
	mov	ecx, DWORD PTR [edi]
	add	DWORD PTR [ecx+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL27@perform_in
	mov	ecx, DWORD PTR _m$2$[ebp]
$LN134@perform_in:
	mov	ebx, DWORD PTR tv1146[ebp]
	mov	edx, DWORD PTR tv1145[ebp]
$LN136@perform_in:
	mov	eax, DWORD PTR tv1147[ebp]
$LN22@perform_in:

; 2491 :         { // Processing with 16-bit integers
; 2492 :           for (m=0; m < N; m++)

	inc	ecx
	add	edx, eax
	add	ebx, 60					; 0000003cH
	mov	DWORD PTR _m$2$[ebp], ecx
	mov	DWORD PTR tv1145[ebp], edx
	mov	DWORD PTR tv1146[ebp], ebx
	cmp	ecx, DWORD PTR _N$1$[ebp]
	jl	SHORT $LL24@perform_in
	mov	eax, DWORD PTR tv1083[ebp]
	mov	edx, DWORD PTR tv1084[ebp]
$LN23@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [edx+eax*4+6], 2
	je	SHORT $LN79@perform_in
	mov	ebx, DWORD PTR [edx+eax*4+8]
	jmp	SHORT $LN80@perform_in
$LN79@perform_in:
	xor	ebx, ebx
$LN80@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2507 :               for (w=0; w < width; w++)

	xor	edx, edx
	cmp	DWORD PTR _divisor$1$[ebp], edx
	jge	SHORT $LN48@perform_in
	test	esi, esi
	jle	SHORT $LN2@perform_in
	mov	ecx, DWORD PTR _downshift$1$[ebp]
$LL30@perform_in:

; 2508 :                 dst[w].ival = (-dst[w].ival) +

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	sub	ax, WORD PTR [ebx+edx*2]
	mov	WORD PTR [ebx+edx*2], ax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL30@perform_in

; 2509 :                   (kdu_int16)(accumulator[w]>>downshift);
; 2510 :             }
; 2511 :           else

	jmp	SHORT $LN2@perform_in
$LN48@perform_in:

; 2512 :             { // Usual case, with a positive divisor
; 2513 :               for (w=0; w < width; w++)

	test	esi, esi
	jle	SHORT $LN2@perform_in
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	npad	2
$LL33@perform_in:

; 2514 :                 dst[w].ival += (kdu_int16)(accumulator[w]>>downshift);

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	add	WORD PTR [ebx+edx*2], ax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL33@perform_in
$LN2@perform_in:

; 2437 :   int m, n;
; 2438 : 
; 2439 :   // Execute the transform steps in reverse order
; 2440 :   for (n=N; n >= 0; n--)

	mov	eax, DWORD PTR _n$1$[ebp]
	sub	DWORD PTR tv1144[ebp], 4
	dec	eax
	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR _N$1$[ebp]
	mov	DWORD PTR _n$1$[ebp], eax
	test	eax, eax
	jns	$LL4@perform_in
$LN3@perform_in:

; 2515 :             }
; 2516 :         }
; 2517 :     }
; 2518 : 
; 2519 :   // Finally, write the results to any non-NULL dependencies, applying
; 2520 :   // offsets as required
; 2521 :   for (m=0; m < N; m++)

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN35@perform_in
	xor	edi, edi
$LL36@perform_in:

; 2522 :     {
; 2523 :       kd_multi_line *line = components + m;
; 2524 :       kd_multi_line *dep = dependencies[m];

	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [eax+esi*4]

; 2525 :       if (dep != NULL)

	test	ecx, ecx
	je	SHORT $LN34@perform_in

; 2526 :         dep->copy(line,-dep->rev_offset,0.0F);

	mov	eax, DWORD PTR [ecx+40]
	push	ecx
	neg	eax
	mov	DWORD PTR [esp], 0
	push	eax
	mov	eax, DWORD PTR [ebx+12]
	add	eax, edi
	push	eax
	call	?copy@kd_multi_line@@QAEXPAU1@HM@Z	; kd_multi_line::copy
$LN34@perform_in:

; 2515 :             }
; 2516 :         }
; 2517 :     }
; 2518 : 
; 2519 :   // Finally, write the results to any non-NULL dependencies, applying
; 2520 :   // offsets as required
; 2521 :   for (m=0; m < N; m++)

	inc	esi
	add	edi, 60					; 0000003cH
	cmp	esi, DWORD PTR _N$1$[ebp]
	jl	SHORT $LL36@perform_in
$LN35@perform_in:

; 2527 :     }
; 2528 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?perform_inverse@kd_multi_rxform_block@@UAEXXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?perform_inverse@kd_multi_rxform_block@@UAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?perform_inverse@kd_multi_rxform_block@@UAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?perform_inverse@kd_multi_rxform_block@@UAEXXZ ENDP	; kd_multi_rxform_block::perform_inverse
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?prepare_for_inversion@kd_multi_rxform_block@@UAEPBDXZ
_TEXT	SEGMENT
?prepare_for_inversion@kd_multi_rxform_block@@UAEPBDXZ PROC ; kd_multi_rxform_block::prepare_for_inversion, COMDAT
; _this$ = ecx

; 2305 : {

	push	esi

; 2306 :   int n;
; 2307 : 
; 2308 :   // Need only check that all components will be available.
; 2309 :   for (n=0; n < num_components; n++)

	mov	esi, DWORD PTR [ecx+8]
	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN3@prepare_fo

; 2310 :     if (components[n].num_consumers < 1)

	mov	eax, DWORD PTR [ecx+12]
	add	eax, 24					; 00000018H
$LL4@prepare_fo:
	cmp	DWORD PTR [eax], 1
	jl	SHORT $LN8@prepare_fo

; 2306 :   int n;
; 2307 : 
; 2308 :   // Need only check that all components will be available.
; 2309 :   for (n=0; n < num_components; n++)

	inc	edx
	add	eax, 60					; 0000003cH
	cmp	edx, esi
	jl	SHORT $LL4@prepare_fo
$LN3@prepare_fo:

; 2312 :              "inverted unless all of its outputs can be computed by "
; 2313 :              "downstream transform blocks, or by the application supplying "
; 2314 :              "them.";
; 2315 :   outstanding_consumers = num_components;

	mov	DWORD PTR [ecx+28], esi

; 2316 :   return NULL;

	xor	eax, eax
	pop	esi

; 2317 : }

	ret	0
$LN8@prepare_fo:

; 2311 :       return "Reversible decorrelation transform block cannot be "

	mov	eax, OFFSET ??_C@_0KM@JOCABHJL@Reversible?5decorrelation?5transfo@
	pop	esi

; 2317 : }

	ret	0
?prepare_for_inversion@kd_multi_rxform_block@@UAEPBDXZ ENDP ; kd_multi_rxform_block::prepare_for_inversion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?perform_transform@kd_multi_rxform_block@@UAEXXZ
_TEXT	SEGMENT
_e$2 = -176						; size = 20
tv1198 = -156						; size = 4
_factor$1$ = -152					; size = 4
_factor$1$ = -152					; size = 4
_n$1$ = -148						; size = 4
_divisor$1$ = -144					; size = 4
tv1113 = -140						; size = 4
tv1112 = -136						; size = 4
_dst_idx$1$ = -132					; size = 4
tv1177 = -128						; size = 4
_N$1$ = -124						; size = 4
_downshift$1$ = -120					; size = 4
tv1204 = -116						; size = 4
_m$3$ = -116						; size = 4
_m$2$ = -116						; size = 4
tv1183 = -112						; size = 4
tv1178 = -112						; size = 4
tv1182 = -108						; size = 4
tv1179 = -108						; size = 4
_this$GSCopy$1$ = -104					; size = 4
tv1181 = -100						; size = 4
tv1180 = -100						; size = 4
_offset$1$ = -100					; size = 4
_text$3 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?perform_transform@kd_multi_rxform_block@@UAEXXZ PROC	; kd_multi_rxform_block::perform_transform, COMDAT
; _this$ = ecx

; 2325 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?perform_transform@kd_multi_rxform_block@@UAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], eax

; 2326 :   int N = num_components;

	mov	ebx, DWORD PTR [eax+8]

; 2327 :   int m, n;
; 2328 : 
; 2329 :   // Start by initializing the `components' array with values from the
; 2330 :   // input `dependencies'.
; 2331 :   assert(num_dependencies == N);
; 2332 :   for (m=0; m < N; m++)

	xor	esi, esi
	mov	DWORD PTR _N$1$[ebp], ebx
	test	ebx, ebx
	jle	SHORT $LN3@perform_tr
	xor	edi, edi
$LL4@perform_tr:

; 2333 :     {
; 2334 :       kd_multi_line *line = components + m;

	mov	ecx, DWORD PTR [eax+12]

; 2335 :       if (dependencies[m] == NULL)

	mov	eax, DWORD PTR [eax+20]
	add	ecx, edi

; 2336 :         line->reset(0,0.0F);

	push	ecx
	mov	DWORD PTR [esp], 0
	push	0
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, eax
	jne	SHORT $LN40@perform_tr
	call	?reset@kd_multi_line@@QAEXHM@Z		; kd_multi_line::reset

; 2337 :       else

	jmp	SHORT $LN2@perform_tr
$LN40@perform_tr:

; 2338 :         line->copy(dependencies[m],0,0.0F);

	push	eax
	call	?copy@kd_multi_line@@QAEXPAU1@HM@Z	; kd_multi_line::copy
$LN2@perform_tr:

; 2327 :   int m, n;
; 2328 : 
; 2329 :   // Start by initializing the `components' array with values from the
; 2330 :   // input `dependencies'.
; 2331 :   assert(num_dependencies == N);
; 2332 :   for (m=0; m < N; m++)

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	inc	esi
	add	edi, 60					; 0000003cH
	cmp	esi, ebx
	jl	SHORT $LL4@perform_tr
$LN3@perform_tr:

; 2339 :     }
; 2340 : 
; 2341 :   // Execute the reversible transform steps
; 2342 :   for (n=0; n <= N; n++)

	xor	ecx, ecx
	mov	DWORD PTR _n$1$[ebp], ecx
	test	ebx, ebx
	js	$LN148@perform_tr
	lea	edi, DWORD PTR [eax+44]
	mov	DWORD PTR tv1177[ebp], ecx
	mov	DWORD PTR tv1198[ebp], edi
	npad	2
$LL7@perform_tr:

; 2343 :     { // Walk through the columns of the coefficient matrix
; 2344 :       int dst_idx = (N-1)-(n % N);

	mov	eax, ecx
	cdq
	idiv	ebx
	mov	eax, ebx
	sub	eax, edx
	dec	eax

; 2345 :       kd_multi_line *line = components + dst_idx;

	mov	ecx, eax
	mov	DWORD PTR _dst_idx$1$[ebp], eax
	shl	ecx, 4
	sub	ecx, eax

; 2347 :       if (accumulator == NULL)

	cmp	DWORD PTR [edi], 0
	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR tv1112[ebp], ecx
	mov	esi, DWORD PTR [eax+12]
	mov	DWORD PTR tv1113[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 544  :         return width;

	mov	esi, DWORD PTR [esi+ecx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2347 :       if (accumulator == NULL)

	jne	SHORT $LN42@perform_tr

; 2348 :         accumulator = new kdu_int32[width];

	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi], eax
	add	esp, 4
	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
$LN42@perform_tr:

; 2349 :       kdu_int32 divisor = coefficients[dst_idx*(N+1)+n];

	mov	eax, DWORD PTR [eax+40]
	lea	ecx, DWORD PTR [ebx+1]
	imul	ecx, DWORD PTR _dst_idx$1$[ebp]
	add	ecx, DWORD PTR _n$1$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2350 :       kdu_int32 abs_divisor = divisor;

	mov	ecx, eax
	mov	DWORD PTR _divisor$1$[ebp], eax
	mov	DWORD PTR _offset$1$[ebp], ecx

; 2351 :       if ((n==N) && (divisor < 0))

	cmp	DWORD PTR _n$1$[ebp], ebx
	jne	SHORT $LN43@perform_tr
	test	eax, eax
	jns	SHORT $LN43@perform_tr

; 2352 :         abs_divisor = -divisor;

	neg	ecx
	mov	DWORD PTR _offset$1$[ebp], ecx
$LN43@perform_tr:

; 2353 :       kdu_int32 downshift = 0;

	xor	edx, edx
	mov	DWORD PTR _downshift$1$[ebp], edx
	lea	eax, DWORD PTR [edx+1]

; 2354 :       while ((1<<downshift) < abs_divisor)

	cmp	ecx, eax
	jle	SHORT $LN9@perform_tr
	npad	1
$LL8@perform_tr:

; 2355 :         downshift++;

	rol	eax, 1
	inc	edx
	cmp	eax, ecx
	jl	SHORT $LL8@perform_tr
	mov	DWORD PTR _downshift$1$[ebp], edx
$LN9@perform_tr:

; 2356 :       if ((1<<downshift) != abs_divisor)

	cmp	eax, ecx
	je	$LN44@perform_tr

; 2357 :         { KDU_ERROR(e,0x23090501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0LJ@PJJIHOJD@Multi?9component?5reversible?5decor@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2357 :         { KDU_ERROR(e,0x23090501); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$2[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _divisor$1$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$3[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$3[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	eax
	mov	eax, DWORD PTR _e$2[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2362 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _offset$1$[ebp]
$LN44@perform_tr:

; 2363 :       kdu_int32 offset = abs_divisor >> 1;

	sar	ecx, 1

; 2364 :       for (w=0; w < width; w++)

	xor	ebx, ebx
	mov	DWORD PTR _offset$1$[ebp], ecx
	test	esi, esi
	jle	SHORT $LN11@perform_tr
	cmp	esi, 4
	jb	SHORT $LN112@perform_tr

; 2365 :         accumulator[w] = offset;

	mov	eax, DWORD PTR [edi]
	lea	edx, DWORD PTR [esi-1]
	lea	edx, DWORD PTR [eax+edx*4]
	cmp	eax, edi
	ja	SHORT $LN113@perform_tr
	cmp	edx, edi
	jae	SHORT $LN112@perform_tr
$LN113@perform_tr:
	mov	eax, esi
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN147@perform_tr
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN147@perform_tr:
	mov	ecx, esi
	sub	ecx, eax
$LL12@perform_tr:

; 2364 :       for (w=0; w < width; w++)

	add	ebx, 4
	cmp	ebx, ecx
	jl	SHORT $LL12@perform_tr

; 2365 :         accumulator[w] = offset;

	mov	edi, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+3]
	cdq
	and	edx, 3
	lea	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _offset$1$[ebp]
	sar	ecx, 2
	shl	ecx, 4
	shr	ecx, 2
	rep stosd
	mov	edi, DWORD PTR tv1198[ebp]
	mov	ecx, eax
$LN112@perform_tr:

; 2364 :       for (w=0; w < width; w++)

	cmp	ebx, esi
	jge	SHORT $LN11@perform_tr
	npad	1
$LL111@perform_tr:

; 2365 :         accumulator[w] = offset;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+ebx*4], ecx
	inc	ebx
	cmp	ebx, esi
	jl	SHORT $LL111@perform_tr
$LN11@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	edx, DWORD PTR tv1112[ebp]
	mov	ebx, DWORD PTR tv1113[ebp]
	test	BYTE PTR [ebx+edx*4+6], 2
	jne	$LN45@perform_tr
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2366 :       if (line->line.get_buf32() != NULL)

	cmp	DWORD PTR [ebx+edx*4+8], 0
	je	$LN45@perform_tr

; 2367 :         { // Processing with 32-bit integers
; 2368 :           for (m=0; m < N; m++)

	mov	eax, DWORD PTR _N$1$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _m$2$[ebp], ecx
	test	eax, eax
	jle	$LN14@perform_tr
	lea	edx, DWORD PTR [eax*4+4]
	xor	ebx, ebx
	mov	DWORD PTR tv1181[ebp], edx
	mov	edx, DWORD PTR tv1177[ebp]
	mov	eax, DWORD PTR tv1181[ebp]
	mov	DWORD PTR tv1183[ebp], ebx
	mov	DWORD PTR tv1182[ebp], edx
$LL15@perform_tr:

; 2369 :             {
; 2370 :               if (m == dst_idx)

	cmp	ecx, DWORD PTR _dst_idx$1$[ebp]
	je	SHORT $LN13@perform_tr

; 2371 :                 continue;
; 2372 :               kdu_int32 factor = coefficients[m*(N+1)+n];

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _factor$1$[ebp], eax

; 2373 :               if (factor == 0)

	test	eax, eax
	je	SHORT $LN145@perform_tr

; 2374 :                 continue;
; 2375 :               kdu_sample32 *src = components[m].line.get_buf32();

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [eax+ebx+6], 2
	je	SHORT $LN71@perform_tr
	xor	ebx, ebx
	jmp	SHORT $LN72@perform_tr
$LN71@perform_tr:
	mov	ebx, DWORD PTR [eax+ebx+8]
$LN72@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2376 :               for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN143@perform_tr
	npad	6
$LL18@perform_tr:

; 2377 :                 accumulator[w] += src[w].ival * factor;

	mov	eax, DWORD PTR [ebx+edx*4]
	imul	eax, DWORD PTR _factor$1$[ebp]
	mov	ecx, DWORD PTR [edi]
	add	DWORD PTR [ecx+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL18@perform_tr
	mov	ecx, DWORD PTR _m$2$[ebp]
$LN143@perform_tr:
	mov	ebx, DWORD PTR tv1183[ebp]
	mov	edx, DWORD PTR tv1182[ebp]
$LN145@perform_tr:
	mov	eax, DWORD PTR tv1181[ebp]
$LN13@perform_tr:

; 2367 :         { // Processing with 32-bit integers
; 2368 :           for (m=0; m < N; m++)

	inc	ecx
	add	edx, eax
	add	ebx, 60					; 0000003cH
	mov	DWORD PTR _m$2$[ebp], ecx
	mov	DWORD PTR tv1182[ebp], edx
	mov	DWORD PTR tv1183[ebp], ebx
	cmp	ecx, DWORD PTR _N$1$[ebp]
	jl	SHORT $LL15@perform_tr
	mov	edx, DWORD PTR tv1112[ebp]
	mov	ebx, DWORD PTR tv1113[ebp]
$LN14@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ebx+edx*4+6], 2
	je	SHORT $LN75@perform_tr
	xor	ebx, ebx
	jmp	SHORT $LN76@perform_tr
$LN75@perform_tr:
	mov	ebx, DWORD PTR [ebx+edx*4+8]
$LN76@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2383 :               for (w=0; w < width; w++)

	xor	edx, edx
	cmp	DWORD PTR _divisor$1$[ebp], edx
	jge	SHORT $LN49@perform_tr
	test	esi, esi
	jle	$LN5@perform_tr
	mov	ecx, DWORD PTR _downshift$1$[ebp]
$LL21@perform_tr:

; 2384 :                 dst[w].ival = -(dst[w].ival - (accumulator[w]>>downshift));

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	sub	eax, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [ebx+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL21@perform_tr

; 2385 :             }
; 2386 :           else

	jmp	$LN5@perform_tr
$LN49@perform_tr:

; 2387 :             { // Usual case, with a positive divisor
; 2388 :               for (w=0; w < width; w++)

	test	esi, esi
	jle	$LN5@perform_tr
	mov	ecx, DWORD PTR _downshift$1$[ebp]
$LL24@perform_tr:

; 2389 :                 dst[w].ival -= (accumulator[w]>>downshift);

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	sub	DWORD PTR [ebx+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL24@perform_tr

; 2390 :             }
; 2391 :         }
; 2392 :       else

	jmp	$LN5@perform_tr
$LN45@perform_tr:

; 2393 :         { // Processing with 16-bit integers
; 2394 :           for (m=0; m < N; m++)

	mov	eax, DWORD PTR _N$1$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _m$3$[ebp], ecx
	test	eax, eax
	jle	$LN26@perform_tr
	lea	edx, DWORD PTR [eax*4+4]
	xor	ebx, ebx
	mov	DWORD PTR tv1180[ebp], edx
	mov	edx, DWORD PTR tv1177[ebp]
	mov	eax, DWORD PTR tv1180[ebp]
	mov	DWORD PTR tv1179[ebp], ebx
	mov	DWORD PTR tv1178[ebp], edx
$LL27@perform_tr:

; 2395 :             {
; 2396 :               if (m == dst_idx)

	cmp	ecx, DWORD PTR _dst_idx$1$[ebp]
	je	SHORT $LN25@perform_tr

; 2397 :                 continue;
; 2398 :               kdu_int32 factor = coefficients[m*(N+1)+n];

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	eax, DWORD PTR [edx+eax]
	mov	DWORD PTR _factor$1$[ebp], eax

; 2399 :               if (factor == 0)

	test	eax, eax
	je	SHORT $LN144@perform_tr

; 2400 :                 continue;
; 2401 :               kdu_sample16 *src = components[m].line.get_buf16();

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [eax+ebx+6], 2
	je	SHORT $LN79@perform_tr
	mov	ebx, DWORD PTR [eax+ebx+8]
	jmp	SHORT $LN80@perform_tr
$LN79@perform_tr:
	xor	ebx, ebx
$LN80@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2402 :               for (w=0; w < width; w++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN142@perform_tr
	npad	8
$LL30@perform_tr:

; 2403 :                 accumulator[w] += ((kdu_int32) src[w].ival) * factor;

	movsx	eax, WORD PTR [ebx+edx*2]
	imul	eax, DWORD PTR _factor$1$[ebp]
	mov	ecx, DWORD PTR [edi]
	add	DWORD PTR [ecx+edx*4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL30@perform_tr
	mov	ecx, DWORD PTR _m$3$[ebp]
$LN142@perform_tr:
	mov	ebx, DWORD PTR tv1179[ebp]
	mov	edx, DWORD PTR tv1178[ebp]
$LN144@perform_tr:
	mov	eax, DWORD PTR tv1180[ebp]
$LN25@perform_tr:

; 2393 :         { // Processing with 16-bit integers
; 2394 :           for (m=0; m < N; m++)

	inc	ecx
	add	edx, eax
	add	ebx, 60					; 0000003cH
	mov	DWORD PTR _m$3$[ebp], ecx
	mov	DWORD PTR tv1178[ebp], edx
	mov	DWORD PTR tv1179[ebp], ebx
	cmp	ecx, DWORD PTR _N$1$[ebp]
	jl	SHORT $LL27@perform_tr
	mov	edx, DWORD PTR tv1112[ebp]
	mov	ebx, DWORD PTR tv1113[ebp]
$LN26@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ebx+edx*4+6], 2
	je	SHORT $LN83@perform_tr
	mov	ebx, DWORD PTR [ebx+edx*4+8]
	jmp	SHORT $LN84@perform_tr
$LN83@perform_tr:
	xor	ebx, ebx
$LN84@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2409 :               for (w=0; w < width; w++)

	xor	edx, edx
	cmp	DWORD PTR _divisor$1$[ebp], edx
	jge	SHORT $LN53@perform_tr
	test	esi, esi
	jle	SHORT $LN5@perform_tr
	mov	ecx, DWORD PTR _downshift$1$[ebp]
$LL33@perform_tr:

; 2410 :                 dst[w].ival =

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	sub	ax, WORD PTR [ebx+edx*2]
	mov	WORD PTR [ebx+edx*2], ax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL33@perform_tr

; 2411 :                   - (dst[w].ival - (kdu_int16)(accumulator[w]>>downshift));
; 2412 :             }
; 2413 :           else

	jmp	SHORT $LN5@perform_tr
$LN53@perform_tr:

; 2414 :             { // Usual case, with a positive divisor
; 2415 :               for (w=0; w < width; w++)

	test	esi, esi
	jle	SHORT $LN5@perform_tr
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	npad	2
$LL36@perform_tr:

; 2416 :                 dst[w].ival -= (kdu_int16)(accumulator[w]>>downshift);

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+edx*4]
	sar	eax, cl
	sub	WORD PTR [ebx+edx*2], ax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL36@perform_tr
$LN5@perform_tr:

; 2339 :     }
; 2340 : 
; 2341 :   // Execute the reversible transform steps
; 2342 :   for (n=0; n <= N; n++)

	mov	ecx, DWORD PTR _n$1$[ebp]
	add	DWORD PTR tv1177[ebp], 4
	inc	ecx
	mov	ebx, DWORD PTR _N$1$[ebp]
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	ecx, ebx
	jle	$LL7@perform_tr

; 2417 :             }
; 2418 :         }
; 2419 :     }
; 2420 : 
; 2421 :   // Finally apply offsets, as required
; 2422 :   for (m=0; m < N; m++)

	test	ebx, ebx
$LN148@perform_tr:
	jle	SHORT $LN38@perform_tr
	xor	esi, esi
$LL39@perform_tr:

; 2423 :     {
; 2424 :       kd_multi_line *line = components + m;

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, esi

; 2425 :       line->apply_offset(line->rev_offset,0.0F);

	push	ecx
	mov	DWORD PTR [esp], 0
	push	DWORD PTR [ecx+40]
	call	?apply_offset@kd_multi_line@@QAEXHM@Z	; kd_multi_line::apply_offset
	add	esi, 60					; 0000003cH
	sub	ebx, 1
	jne	SHORT $LL39@perform_tr
$LN38@perform_tr:

; 2426 :     }
; 2427 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?perform_transform@kd_multi_rxform_block@@UAEXXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?perform_transform@kd_multi_rxform_block@@UAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-180]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?perform_transform@kd_multi_rxform_block@@UAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?perform_transform@kd_multi_rxform_block@@UAEXXZ ENDP	; kd_multi_rxform_block::perform_transform
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?initialize@kd_multi_rxform_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z
_TEXT	SEGMENT
_num_stage_inputs$ = -28				; size = 4
_num_stage_outputs$ = -24				; size = 4
_input_indices$1$ = -20					; size = 4
$T1 = -16						; size = 4
_output_indices$1$ = -12				; size = 4
_rev_offsets$1$ = -8					; size = 4
_N$1$ = -4						; size = 4
_stage_idx$ = 8						; size = 4
_block_idx$ = 12					; size = 4
_need_precise$1$ = 15					; size = 1
_tile$ = 16						; size = 4
_num_block_inputs$ = 20					; size = 4
_num_block_outputs$ = 24				; size = 4
_input_collection$ = 28					; size = 4
_output_collection$ = 32				; size = 4
_active_outputs$1$ = 36					; size = 4
_owner$ = 36						; size = 4
?initialize@kd_multi_rxform_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z PROC ; kd_multi_rxform_block::initialize, COMDAT
; _this$ = ecx

; 2243 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi

; 2244 :   int N = num_block_inputs;

	mov	esi, DWORD PTR _num_block_inputs$[ebp]
	push	edi
	mov	DWORD PTR _N$1$[ebp], esi
	mov	edi, ecx

; 2245 :   assert(N >= num_block_outputs); // Some outputs might not be used
; 2246 :   int *scratch = owner->get_scratch_ints(4*N); // Safe upper bound

	mov	ecx, DWORD PTR _owner$[ebp]
	shl	esi, 2
	push	esi
	call	?get_scratch_ints@kd_multi_transform@@QAEPAHH@Z ; kd_multi_transform::get_scratch_ints

; 2247 :   int *input_indices = scratch;

	mov	edx, eax

; 2248 :   int *output_indices = input_indices + N;
; 2249 :   int *rev_offsets = output_indices + N;
; 2250 :   int *active_outputs = rev_offsets + N;
; 2251 : 
; 2252 :   int n, num_stage_inputs, num_stage_outputs;
; 2253 :   tile.get_mct_block_info(stage_idx,block_idx,num_stage_inputs,

	push	0
	mov	DWORD PTR _input_indices$1$[ebp], edx
	lea	ebx, DWORD PTR [esi+edx]
	lea	eax, DWORD PTR [esi+ebx]
	mov	DWORD PTR _output_indices$1$[ebp], ebx
	push	eax
	push	0
	push	ebx
	lea	ecx, DWORD PTR [esi+eax]
	mov	DWORD PTR _rev_offsets$1$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _num_block_outputs$[ebp]
	mov	DWORD PTR _active_outputs$1$[ebp], ecx
	push	eax
	lea	eax, DWORD PTR _num_block_inputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_outputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_inputs$[ebp]
	push	eax
	push	DWORD PTR _block_idx$[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	push	DWORD PTR _stage_idx$[ebp]
	call	?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z ; kdu_tile::get_mct_block_info

; 2254 :                           num_stage_outputs,num_block_inputs,num_block_outputs,
; 2255 :                           input_indices,output_indices,NULL,rev_offsets);
; 2256 :   assert((num_stage_inputs == input_collection->num_components) &&
; 2257 :          (num_stage_outputs == output_collection->num_components));
; 2258 : 
; 2259 :   num_components = num_dependencies = N;

	mov	esi, DWORD PTR _N$1$[ebp]

; 2260 :   components = new kd_multi_line[N];

	xor	ecx, ecx
	mov	eax, esi
	mov	DWORD PTR [edi+16], esi
	mov	edx, 60					; 0000003cH
	mov	DWORD PTR [edi+8], esi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN19@initialize
	mov	edx, esi
	test	esi, esi
	je	SHORT $LN20@initialize
	lea	ecx, DWORD PTR [eax+6]
	npad	3
$LL23@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx-6], 0
	lea	ecx, DWORD PTR [ecx+60]
	mov	WORD PTR [ecx-60], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx-58], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx-54], 0
	mov	DWORD PTR [ecx-50], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 87   :         row_idx = -1;  num_consumers = outstanding_consumers = 0;

	mov	DWORD PTR [ecx-46], -1
	mov	DWORD PTR [ecx-38], 0
	mov	DWORD PTR [ecx-42], 0

; 88   :         reversible = need_irreversible = need_precise = is_constant = false;

	mov	DWORD PTR [ecx-34], 0

; 89   :         bit_depth = 0;  rev_offset = 0;  irrev_offset = 0.0F;

	mov	DWORD PTR [ecx-30], 0
	mov	DWORD PTR [ecx-26], 0
	mov	DWORD PTR [ecx-22], 0

; 90   :         bypass=NULL;  block=NULL;  collection_idx = -1;

	mov	DWORD PTR [ecx-18], 0
	mov	DWORD PTR [ecx-14], 0
	mov	DWORD PTR [ecx-10], -1
	sub	edx, 1
	jne	SHORT $LL23@initialize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2260 :   components = new kd_multi_line[N];

	jmp	SHORT $LN20@initialize
$LN19@initialize:
	xor	eax, eax
$LN20@initialize:
	mov	DWORD PTR [edi+12], eax

; 2261 :   dependencies = new kd_multi_line *[N];

	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+20], eax

; 2262 :   int num_coeffs = N*(N+1);
; 2263 :   coefficients = new kdu_int32[num_coeffs];

	xor	ecx, ecx
	lea	eax, DWORD PTR [esi+1]
	mov	edx, 4
	imul	eax, esi
	mov	esi, eax
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 8
	mov	DWORD PTR [edi+40], eax

; 2264 :   tile.get_mct_rxform_info(stage_idx,block_idx,coefficients,active_outputs);

	lea	ecx, DWORD PTR _tile$[ebp]
	push	DWORD PTR _active_outputs$1$[ebp]
	push	eax
	push	DWORD PTR _block_idx$[ebp]
	push	DWORD PTR _stage_idx$[ebp]
	call	?get_mct_rxform_info@kdu_tile@@QAE_NHHPAH0@Z ; kdu_tile::get_mct_rxform_info

; 2265 : 
; 2266 :   // See if the coefficients can be represented as short integers
; 2267 :   bool need_precise = false;
; 2268 :   for (n=0; n < num_coeffs; n++)

	xor	eax, eax
	mov	BYTE PTR _need_precise$1$[ebp], 0
	test	esi, esi
	jle	SHORT $LN3@initialize

; 2269 :     if ((coefficients[n] > 0x7FFF) || (coefficients[n] < -0x7FFF))

	mov	edx, DWORD PTR [edi+40]
$LL45@initialize:
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	ecx, 32767				; 00007fffH
	jg	SHORT $LN46@initialize
	cmp	ecx, -32767				; ffff8001H
	jge	SHORT $LN47@initialize
$LN46@initialize:

; 2270 :       need_precise = true;

	mov	BYTE PTR _need_precise$1$[ebp], 1
$LN47@initialize:

; 2265 : 
; 2266 :   // See if the coefficients can be represented as short integers
; 2267 :   bool need_precise = false;
; 2268 :   for (n=0; n < num_coeffs; n++)

	inc	eax
	cmp	eax, esi
	jl	SHORT $LL45@initialize
$LN3@initialize:

; 2271 : 
; 2272 :   for (n=0; n < N; n++)

	mov	ecx, DWORD PTR _N$1$[ebp]
	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN9@initialize
	mov	ebx, ecx
	npad	4
$LL7@initialize:

; 2273 :     {
; 2274 :       dependencies[n] = input_collection->components[input_indices[n]];

	mov	eax, DWORD PTR _input_indices$1$[ebp]
	mov	ecx, DWORD PTR [edi+20]
	mov	edx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _input_collection$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+esi*4], eax

; 2275 :       if (dependencies[n] == NULL)

	mov	eax, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, eax
	je	SHORT $LN5@initialize

; 2276 :         continue;
; 2277 :       dependencies[n]->num_consumers++;

	inc	DWORD PTR [eax+24]

; 2278 :       dependencies[n]->reversible = true;
; 2279 :       if (need_precise)

	cmp	BYTE PTR _need_precise$1$[ebp], 0
	mov	eax, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	BYTE PTR [eax+32], 1
	je	SHORT $LN5@initialize

; 2280 :         dependencies[n]->need_precise = true;

	mov	eax, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	BYTE PTR [eax+34], 1
$LN5@initialize:

; 2271 : 
; 2272 :   for (n=0; n < N; n++)

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL7@initialize

; 2281 :     }
; 2282 : 
; 2283 :   for (n=0; n < N; n++)

	mov	ecx, DWORD PTR _N$1$[ebp]
	mov	ebx, DWORD PTR _output_indices$1$[ebp]
	test	ecx, ecx
	jle	SHORT $LN9@initialize
	mov	bl, BYTE PTR _need_precise$1$[ebp]
	xor	edx, edx
$LL10@initialize:

; 2284 :     {
; 2285 :       kd_multi_line *line = components + n;

	mov	eax, DWORD PTR [edi+12]
	lea	edx, DWORD PTR [edx+60]

; 2286 :       line->block = this;

	mov	DWORD PTR [eax+edx-8], edi

; 2287 :       line->reversible = true;

	mov	BYTE PTR [eax+edx-28], 1

; 2288 :       line->need_precise = need_precise;

	mov	BYTE PTR [eax+edx-26], bl
	sub	ecx, 1
	jne	SHORT $LL10@initialize
	mov	ebx, DWORD PTR _output_indices$1$[ebp]
$LN9@initialize:

; 2289 :     }
; 2290 : 
; 2291 :   for (n=0; n < num_block_outputs; n++)

	xor	esi, esi
	cmp	DWORD PTR _num_block_outputs$[ebp], esi
	jle	SHORT $LN12@initialize
	mov	eax, DWORD PTR _active_outputs$1$[ebp]
	sub	eax, ebx
	sub	DWORD PTR _rev_offsets$1$[ebp], ebx
	mov	DWORD PTR _active_outputs$1$[ebp], eax
	npad	3
$LL13@initialize:

; 2292 :     {
; 2293 :       kd_multi_line *line = components + active_outputs[n];

	mov	eax, DWORD PTR [eax+ebx]
	lea	ebx, DWORD PTR [ebx+4]
	mov	ecx, eax
	inc	esi
	shl	ecx, 4
	sub	ecx, eax
	mov	eax, DWORD PTR [edi+12]
	lea	edx, DWORD PTR [eax+ecx*4]

; 2294 :       output_collection->components[output_indices[n]] = line;

	mov	eax, DWORD PTR _output_collection$[ebp]
	mov	ecx, DWORD PTR [ebx-4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+ecx*4], edx

; 2295 :       line->rev_offset = rev_offsets[n];

	mov	eax, DWORD PTR _rev_offsets$1$[ebp]
	mov	eax, DWORD PTR [eax+ebx-4]
	mov	DWORD PTR [edx+40], eax
	mov	eax, DWORD PTR _active_outputs$1$[ebp]
	cmp	esi, DWORD PTR _num_block_outputs$[ebp]
	jl	SHORT $LL13@initialize
$LN12@initialize:
	pop	edi
	pop	esi
	pop	ebx

; 2296 :     }
; 2297 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?initialize@kd_multi_rxform_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z ENDP ; kd_multi_rxform_block::initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??1kd_multi_rxform_block@@UAE@XZ
_TEXT	SEGMENT
??1kd_multi_rxform_block@@UAE@XZ PROC			; kd_multi_rxform_block::~kd_multi_rxform_block, COMDAT
; _this$ = ecx

; 429  :       {

	push	esi
	mov	esi, ecx

; 430  :         if (coefficients != NULL) delete[] coefficients;

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_rxform_block@@6B@
	test	eax, eax
	je	SHORT $LN2@kd_multi_r
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_multi_r:

; 431  :         if (accumulator != NULL) delete[] accumulator;

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN3@kd_multi_r
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@kd_multi_r:

; 199  :         if (components != NULL) delete[] components;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_block@@6B@
	test	eax, eax
	je	SHORT $LN6@kd_multi_r
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@kd_multi_r:

; 200  :         if (dependencies != NULL) delete[] dependencies;

	mov	eax, DWORD PTR [esi+20]
	pop	esi
	test	eax, eax
	je	SHORT $LN7@kd_multi_r
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN7@kd_multi_r:

; 432  :       }

	ret	0
??1kd_multi_rxform_block@@UAE@XZ ENDP			; kd_multi_rxform_block::~kd_multi_rxform_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??0kd_multi_rxform_block@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0kd_multi_rxform_block@@QAE@XZ PROC			; kd_multi_rxform_block::kd_multi_rxform_block, COMDAT
; _this$ = ecx

; 423  :     kd_multi_rxform_block()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  :       }

	mov	eax, ecx

; 193  :         num_components = 0;  components = NULL;  next = prev = NULL;

	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+32], 0

; 194  :         num_dependencies = num_available_dependencies = 0; dependencies = NULL;

	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0

; 195  :         outstanding_consumers = 0;

	mov	DWORD PTR [ecx+28], 0

; 424  :       {

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_rxform_block@@6B@

; 425  :         is_null_transform = false;

	mov	BYTE PTR [ecx+4], 0

; 426  :         coefficients = NULL;  accumulator = NULL;

	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0

; 427  :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??0kd_multi_rxform_block@@QAE@XZ ENDP			; kd_multi_rxform_block::kd_multi_rxform_block
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_multi_matrix_block@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_multi_matrix_block@@UAEPAXI@Z PROC		; kd_multi_matrix_block::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_multi_matrix_block@@UAE@XZ	; kd_multi_matrix_block::~kd_multi_matrix_block
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	64					; 00000040H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_multi_matrix_block@@UAEPAXI@Z ENDP		; kd_multi_matrix_block::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?create_short_inverse_coefficients@kd_multi_matrix_block@@AAEXH@Z
_TEXT	SEGMENT
tv419 = -12						; size = 4
_factor$1$ = -12					; size = 4
tv448 = -8						; size = 8
tv442 = -8						; size = 8
_max_val$1$ = -4					; size = 4
_m$2$ = 8						; size = 4
_width$ = 8						; size = 4
?create_short_inverse_coefficients@kd_multi_matrix_block@@AAEXH@Z PROC ; kd_multi_matrix_block::create_short_inverse_coefficients, COMDAT
; _this$ = ecx

; 2185 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 2186 :   if (short_coefficients != NULL)

	cmp	DWORD PTR [esi+48], 0
	jne	$LN12@create_sho

; 2187 :     return;
; 2188 : 
; 2189 :   int m, n;
; 2190 :   float val, max_val = 0.00001F;

	movss	xmm0, DWORD PTR __real@3727c5ac

; 2191 :   for (m=0; m < num_dependencies; m++)

	mov	ecx, DWORD PTR [esi+16]
	push	edi
	xor	edi, edi
	movss	DWORD PTR _max_val$1$[ebp], xmm0
	test	ecx, ecx
	jle	SHORT $LN3@create_sho

; 2192 :     {
; 2193 :       if (dependencies[m] == NULL)

	mov	eax, DWORD PTR [esi+20]

; 2196 :         {
; 2197 :           val = inverse_coefficients[m*num_components + n];

	movss	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	mov	DWORD PTR tv419[ebp], eax
$LL4@create_sho:

; 2192 :     {
; 2193 :       if (dependencies[m] == NULL)

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@create_sho

; 2194 :         continue;
; 2195 :       for (n=0; n < num_components; n++)

	mov	edx, DWORD PTR [esi+8]
	test	edx, edx
	jle	SHORT $LN2@create_sho

; 2196 :         {
; 2197 :           val = inverse_coefficients[m*num_components + n];

	mov	ecx, DWORD PTR [esi+44]
	mov	eax, edx
	imul	eax, edi
	lea	eax, DWORD PTR [ecx+eax*4]
	npad	1
$LL7@create_sho:
	movss	xmm1, DWORD PTR [eax]

; 2198 :           if (val > max_val)

	comiss	xmm1, xmm0
	jbe	SHORT $LN19@create_sho

; 2199 :             max_val = val;

	movaps	xmm0, xmm1
	movss	DWORD PTR _max_val$1$[ebp], xmm0
	jmp	SHORT $LN5@create_sho
$LN19@create_sho:

; 2200 :           else if (val < -max_val)

	xorps	xmm0, xmm2
	comiss	xmm0, xmm1
	jbe	SHORT $LN48@create_sho

; 2201 :             max_val = -val;

	movaps	xmm0, xmm1
	xorps	xmm0, xmm2
	movss	DWORD PTR _max_val$1$[ebp], xmm0
	jmp	SHORT $LN5@create_sho
$LN48@create_sho:
	movss	xmm0, DWORD PTR _max_val$1$[ebp]
$LN5@create_sho:

; 2194 :         continue;
; 2195 :       for (n=0; n < num_components; n++)

	add	eax, 4
	sub	edx, 1
	jne	SHORT $LL7@create_sho
	mov	eax, DWORD PTR tv419[ebp]
	mov	ecx, DWORD PTR [esi+16]
$LN2@create_sho:

; 2191 :   for (m=0; m < num_dependencies; m++)

	inc	edi
	add	eax, 4
	mov	DWORD PTR tv419[ebp], eax
	cmp	edi, ecx
	jl	SHORT $LL4@create_sho
$LN3@create_sho:

; 2202 :         }
; 2203 :     }
; 2204 : 
; 2205 :   short_coefficients = new kdu_int16[num_dependencies*num_components];

	mov	eax, DWORD PTR [esi+8]
	mov	edx, 2
	imul	eax, ecx
	xor	ecx, ecx
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+48], eax

; 2206 :   short_accumulator = new kdu_int32[width];

	xor	ecx, ecx
	mov	eax, DWORD PTR _width$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 2207 : 
; 2208 :   float factor = 1.0F;
; 2209 :   for (short_downshift=0; (factor*max_val) <= 16383.0F; factor*=2.0F)

	movss	xmm4, DWORD PTR __real@467ffc00
	add	esp, 8
	movss	xmm1, DWORD PTR _max_val$1$[ebp]
	comiss	xmm4, xmm1
	mov	DWORD PTR [esi+52], eax
	mov	DWORD PTR [esi+56], 0
	movss	xmm2, DWORD PTR __real@3f800000
	movss	DWORD PTR _factor$1$[ebp], xmm2
	jb	SHORT $LN9@create_sho
	movss	xmm3, DWORD PTR __real@40000000
	xor	eax, eax
$LL10@create_sho:
	mulss	xmm2, xmm3

; 2210 :     short_downshift++;

	inc	eax
	movaps	xmm0, xmm2
	mulss	xmm0, xmm1
	comiss	xmm4, xmm0
	jae	SHORT $LL10@create_sho
	movss	DWORD PTR _factor$1$[ebp], xmm2
	mov	DWORD PTR [esi+56], eax
$LN9@create_sho:

; 2211 : 
; 2212 :   for (m=0; m < num_dependencies; m++)

	xor	edx, edx
	mov	DWORD PTR _m$2$[ebp], edx
	cmp	DWORD PTR [esi+16], edx
	jle	$LN49@create_sho
	npad	5
$LL13@create_sho:

; 2213 :     for (n=0; n < num_components; n++)

	xor	edi, edi
	cmp	DWORD PTR [esi+8], edi
	jle	$LN11@create_sho
	npad	5
$LL16@create_sho:

; 2214 :       {
; 2215 :         if (dependencies[m] == NULL)

	mov	eax, DWORD PTR [esi+20]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $LN22@create_sho
	xorps	xmm0, xmm0

; 2216 :           val = 0.0F;
; 2217 :         else

	jmp	SHORT $LN23@create_sho
$LN22@create_sho:

; 2218 :           val = inverse_coefficients[m*num_components + n] * factor;

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+44]
	imul	ecx, edx
	add	ecx, edi
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, xmm2
$LN23@create_sho:

; 2219 :         int ival = (int) floor(val+0.5);

	cvtps2pd xmm0, xmm0
	sub	esp, 8
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv448[ebp], xmm0
	fld	QWORD PTR tv448[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv442[ebp]
	cvttsd2si edx, QWORD PTR tv442[ebp]
	add	esp, 8

; 2220 :         if (ival >= (1<<15))

	cmp	edx, 32768				; 00008000H
	jl	SHORT $LN24@create_sho

; 2221 :           ival = (1<<15)-1;

	mov	edx, 32767				; 00007fffH
	jmp	SHORT $LN26@create_sho
$LN24@create_sho:

; 2222 :         else if (ival < -(1<<15))

	cmp	edx, -32768				; ffff8000H
	mov	eax, -32768				; ffff8000H
	cmovl	edx, eax
$LN26@create_sho:

; 2223 :           ival = -(1<<15);
; 2224 :         short_coefficients[m*num_components + n] = (kdu_int16) ival;

	mov	ecx, DWORD PTR [esi+8]
	imul	ecx, DWORD PTR _m$2$[ebp]
	mov	eax, DWORD PTR [esi+48]
	movss	xmm2, DWORD PTR _factor$1$[ebp]
	add	ecx, edi
	inc	edi
	mov	WORD PTR [eax+ecx*2], dx
	mov	edx, DWORD PTR _m$2$[ebp]
	cmp	edi, DWORD PTR [esi+8]
	jl	$LL16@create_sho
$LN11@create_sho:

; 2211 : 
; 2212 :   for (m=0; m < num_dependencies; m++)

	inc	edx
	mov	DWORD PTR _m$2$[ebp], edx
	cmp	edx, DWORD PTR [esi+16]
	jl	$LL13@create_sho
$LN49@create_sho:
	pop	edi
$LN12@create_sho:
	pop	esi

; 2225 :       }
; 2226 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?create_short_inverse_coefficients@kd_multi_matrix_block@@AAEXH@Z ENDP ; kd_multi_matrix_block::create_short_inverse_coefficients
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?create_short_coefficients@kd_multi_matrix_block@@AAEXH@Z
_TEXT	SEGMENT
tv421 = -16						; size = 8
tv415 = -16						; size = 8
_factor$1$ = -8						; size = 4
_m$1$ = -8						; size = 4
tv396 = -4						; size = 4
_max_val$1$ = -4					; size = 4
_m$2$ = 8						; size = 4
_width$ = 8						; size = 4
?create_short_coefficients@kd_multi_matrix_block@@AAEXH@Z PROC ; kd_multi_matrix_block::create_short_coefficients, COMDAT
; _this$ = ecx

; 2137 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	esi, ecx

; 2138 :   if (short_coefficients != NULL)

	cmp	DWORD PTR [esi+48], 0
	jne	$LN12@create_sho

; 2139 :     return;
; 2140 : 
; 2141 :   int n, m;
; 2142 :   float val, max_val = 0.00001F;

	movss	xmm0, DWORD PTR __real@3727c5ac

; 2143 :   for (m=0; m < num_components; m++)

	xor	ecx, ecx
	push	edi
	mov	edi, DWORD PTR [esi+8]
	movss	DWORD PTR _max_val$1$[ebp], xmm0
	mov	DWORD PTR _m$1$[ebp], ecx
	test	edi, edi
	jle	SHORT $LN3@create_sho

; 2147 :           continue;
; 2148 :         val = coefficients[m*num_dependencies+n];

	movss	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
$LL4@create_sho:

; 2144 :     for (n=0; n < num_dependencies; n++)

	xor	edx, edx
	cmp	DWORD PTR [esi+16], edx
	jle	SHORT $LN2@create_sho

; 2145 :       {
; 2146 :         if (dependencies[n] == NULL)

	mov	edi, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi+16]
$LL7@create_sho:
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN5@create_sho

; 2147 :           continue;
; 2148 :         val = coefficients[m*num_dependencies+n];

	mov	ecx, eax
	mov	eax, DWORD PTR [esi+40]
	imul	ecx, DWORD PTR _m$1$[ebp]
	add	ecx, edx
	movss	xmm1, DWORD PTR [eax+ecx*4]

; 2149 :         if (val > max_val)

	comiss	xmm1, xmm0
	jbe	SHORT $LN19@create_sho

; 2150 :           max_val = val;

	movaps	xmm0, xmm1
	movss	DWORD PTR _max_val$1$[ebp], xmm0
	jmp	SHORT $LN49@create_sho
$LN19@create_sho:

; 2151 :         else if (val < -max_val)

	xorps	xmm0, xmm2
	comiss	xmm0, xmm1
	jbe	SHORT $LN47@create_sho

; 2152 :           max_val = -val;

	movaps	xmm0, xmm1
	xorps	xmm0, xmm2
	movss	DWORD PTR _max_val$1$[ebp], xmm0
	jmp	SHORT $LN49@create_sho
$LN47@create_sho:
	movss	xmm0, DWORD PTR _max_val$1$[ebp]
$LN49@create_sho:
	mov	eax, DWORD PTR [esi+16]
$LN5@create_sho:

; 2144 :     for (n=0; n < num_dependencies; n++)

	inc	edx
	add	edi, 4
	cmp	edx, eax
	jl	SHORT $LL7@create_sho
	mov	ecx, DWORD PTR _m$1$[ebp]
	mov	edi, DWORD PTR [esi+8]
$LN2@create_sho:

; 2143 :   for (m=0; m < num_components; m++)

	inc	ecx
	mov	DWORD PTR _m$1$[ebp], ecx
	cmp	ecx, edi
	jl	SHORT $LL4@create_sho
$LN3@create_sho:

; 2153 :       }
; 2154 : 
; 2155 :   short_coefficients = new kdu_int16[num_components*num_dependencies];

	mov	eax, DWORD PTR [esi+16]
	xor	ecx, ecx
	imul	eax, edi
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+48], eax

; 2156 :   short_accumulator = new kdu_int32[width];

	xor	ecx, ecx
	mov	eax, DWORD PTR _width$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 2157 : 
; 2158 :   float factor = 1.0F;
; 2159 :   for (short_downshift=0; (factor*max_val) <= 16383.0F; factor*=2.0F)

	movss	xmm4, DWORD PTR __real@467ffc00
	add	esp, 8
	movss	xmm1, DWORD PTR _max_val$1$[ebp]
	comiss	xmm4, xmm1
	mov	DWORD PTR [esi+52], eax
	mov	DWORD PTR [esi+56], 0
	movss	xmm2, DWORD PTR __real@3f800000
	movss	DWORD PTR _factor$1$[ebp], xmm2
	jb	SHORT $LN9@create_sho
	movss	xmm3, DWORD PTR __real@40000000
	xor	eax, eax
$LL10@create_sho:
	mulss	xmm2, xmm3

; 2160 :     short_downshift++;

	inc	eax
	movaps	xmm0, xmm2
	mulss	xmm0, xmm1
	comiss	xmm4, xmm0
	jae	SHORT $LL10@create_sho
	movss	DWORD PTR _factor$1$[ebp], xmm2
	mov	DWORD PTR [esi+56], eax
$LN9@create_sho:

; 2161 :   for (m=0; m < num_components; m++)

	xor	edx, edx
	mov	DWORD PTR _m$2$[ebp], edx
	cmp	DWORD PTR [esi+8], edx
	jle	$LN48@create_sho
	npad	2
$LL13@create_sho:

; 2162 :     for (n=0; n < num_dependencies; n++)

	xor	edi, edi
	cmp	DWORD PTR [esi+16], edi
	jle	$LN11@create_sho
	npad	5
$LL16@create_sho:

; 2163 :       {
; 2164 :         if (dependencies[n] == NULL)
; 2165 :           {
; 2166 :             short_coefficients[m*num_dependencies+n] = 0;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+20]
	imul	ecx, edx
	add	ecx, edi
	cmp	DWORD PTR [eax+edi*4], 0
	jne	SHORT $LN22@create_sho
	mov	eax, DWORD PTR [esi+48]
	xor	edx, edx
	mov	WORD PTR [eax+ecx*2], dx

; 2167 :             continue;

	jmp	SHORT $LN50@create_sho
$LN22@create_sho:

; 2168 :           }
; 2169 :         val = coefficients[m*num_dependencies+n] * factor;

	mov	eax, DWORD PTR [esi+40]

; 2170 :         int ival = (int) floor(val+0.5);

	sub	esp, 8
	mov	DWORD PTR tv396[ebp], ecx
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, xmm2
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv421[ebp], xmm0
	fld	QWORD PTR tv421[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv415[ebp]
	cvttsd2si ecx, QWORD PTR tv415[ebp]
	add	esp, 8

; 2171 :         if (ival >= (1<<15))

	cmp	ecx, 32768				; 00008000H
	jl	SHORT $LN23@create_sho

; 2172 :           ival = (1<<15)-1;

	mov	ecx, 32767				; 00007fffH
	jmp	SHORT $LN25@create_sho
$LN23@create_sho:

; 2173 :         else if (ival < -(1<<15))

	cmp	ecx, -32768				; ffff8000H
	mov	eax, -32768				; ffff8000H
	cmovl	ecx, eax
$LN25@create_sho:

; 2174 :           ival = -(1<<15);
; 2175 :         short_coefficients[m*num_dependencies+n] = (kdu_int16) ival;

	mov	eax, DWORD PTR [esi+48]
	mov	edx, DWORD PTR tv396[ebp]
	movss	xmm2, DWORD PTR _factor$1$[ebp]
	mov	WORD PTR [eax+edx*2], cx
$LN50@create_sho:

; 2162 :     for (n=0; n < num_dependencies; n++)

	mov	edx, DWORD PTR _m$2$[ebp]
	inc	edi
	cmp	edi, DWORD PTR [esi+16]
	jl	$LL16@create_sho
$LN11@create_sho:

; 2161 :   for (m=0; m < num_components; m++)

	inc	edx
	mov	DWORD PTR _m$2$[ebp], edx
	cmp	edx, DWORD PTR [esi+8]
	jl	$LL13@create_sho
$LN48@create_sho:
	pop	edi
$LN12@create_sho:
	pop	esi

; 2176 :       }
; 2177 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?create_short_coefficients@kd_multi_matrix_block@@AAEXH@Z ENDP ; kd_multi_matrix_block::create_short_coefficients
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?perform_inverse@kd_multi_matrix_block@@UAEXXZ
_TEXT	SEGMENT
tv1247 = -36						; size = 8
tv1241 = -36						; size = 8
tv1217 = -32						; size = 4
tv1211 = -32						; size = 4
_downshift$1$ = -28					; size = 4
tv1204 = -28						; size = 4
_factor$1 = -28						; size = 4
_dst$1$ = -24						; size = 4
_width$1$ = -24						; size = 4
_offset$1$ = -20					; size = 4
_n$1$ = -20						; size = 4
tv1202 = -20						; size = 4
_w$1$ = -16						; size = 4
_line$1$ = -16						; size = 4
_m$1$ = -12						; size = 4
_n$2$ = -8						; size = 4
_dst$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
?perform_inverse@kd_multi_matrix_block@@UAEXXZ PROC	; kd_multi_matrix_block::perform_inverse, COMDAT
; _this$ = ecx

; 2078 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	edx, ecx
	push	esi

; 2079 :   assert(inverse_coefficients != NULL);
; 2080 : 
; 2081 :   int m, n;
; 2082 :   for (m=0; m < num_dependencies; m++)

	xor	esi, esi
	mov	DWORD PTR _this$1$[ebp], edx
	mov	DWORD PTR _m$1$[ebp], esi
	cmp	DWORD PTR [edx+16], esi
	jle	$LN3@perform_in
	push	edi
	npad	5
$LL4@perform_in:

; 2083 :     {
; 2084 :       kd_multi_line *line=dependencies[m];

	mov	eax, DWORD PTR [edx+20]
	mov	esi, DWORD PTR [eax+esi*4]
	mov	DWORD PTR _line$1$[ebp], esi

; 2085 :       if (line == NULL)

	test	esi, esi
	je	$LN2@perform_in
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [esi+6], 2

; 414  :       }
; 415  :     bool get_floats(float *buffer, int first_idx, int num_samples)
; 416  :       {
; 417  :       /* [SYNOPSIS]
; 418  :            Returns false if the object does not hold a 32-bit normalized
; 419  :            (floating point) sample representation.  Otherwise, returns true
; 420  :            and copies the floating point samples into the supplied `buffer'.
; 421  :            The first copied sample is `first_idx' positions from the start
; 422  :            of the line.  There may be little or no checking that the
; 423  :            sample range represented by `first_idx' and `num_samples' is
; 424  :            legal, so be careful.
; 425  :            [//]
; 426  :            For native C/C++ interfacing, it is more efficient to explicitly
; 427  :            access the internal buffer using `get_buf32'.
; 428  :       */
; 429  :         if (flags & (KD_LINE_BUF_ABSOLUTE | KD_LINE_BUF_ABSOLUTE))
; 430  :           return false;
; 431  :         for (int i=0; i < num_samples; i++)
; 432  :           buffer[i] = buf32[first_idx+i].fval;
; 433  :         return true;
; 434  :       }
; 435  :     bool set_floats(float *buffer, int first_idx, int num_samples)
; 436  :       {
; 437  :       /* [SYNOPSIS]
; 438  :            Returns false if the object does not hold a 32-bit normalized
; 439  :            (floating point) sample representation.  Otherwise, returns true
; 440  :            and copies the floating point samples from the supplied `buffer'.
; 441  :            The first sample in `buffer' is stored `first_idx' positions from
; 442  :            the start of the line.  There may be little or no checking that
; 443  :            the sample range represented by `first_idx' and `num_samples' is
; 444  :            legal, so be careful.
; 445  :            [//]
; 446  :            For native C/C++ interfacing, it is more efficient to explicitly
; 447  :            access the internal buffer using `get_buf32'.
; 448  :       */
; 449  :         if (flags & (KD_LINE_BUF_ABSOLUTE | KD_LINE_BUF_ABSOLUTE))
; 450  :           return false;
; 451  :         for (int i=0; i < num_samples; i++)
; 452  :           buf32[i+first_idx].fval = buffer[i];
; 453  :         return true;
; 454  :       }
; 455  :     bool get_ints(kdu_int32 *buffer, int first_idx, int num_samples)
; 456  :       {
; 457  :       /* [SYNOPSIS]
; 458  :            Returns false if the object does not hold a 32-bit absolute
; 459  :            (integer) sample representation.  Otherwise, returns true
; 460  :            and copies the integer samples into the supplied `buffer'.
; 461  :            The first copied sample is `first_idx' positions from the start
; 462  :            of the line.  There may be little or no checking that the
; 463  :            sample range represented by `first_idx' and `num_samples' is
; 464  :            legal, so be careful.
; 465  :            [//]
; 466  :            For native C/C++ interfacing, it is more efficient to explicitly
; 467  :            access the internal buffer using `get_buf32'.
; 468  :       */
; 469  :         if ((flags & KD_LINE_BUF_SHORTS) || !(flags & KD_LINE_BUF_ABSOLUTE))
; 470  :           return false;
; 471  :         for (int i=0; i < num_samples; i++)
; 472  :           buffer[i] = buf32[first_idx+i].ival;
; 473  :         return true;
; 474  :       }
; 475  :     bool set_ints(kdu_int32 *buffer, int first_idx, int num_samples)
; 476  :       {
; 477  :       /* [SYNOPSIS]
; 478  :            Returns false if the object does not hold a 32-bit absolute
; 479  :            (integer) sample representation.  Otherwise, returns true
; 480  :            and copies the integer samples from the supplied `buffer'.
; 481  :            The first sample in `buffer' is stored `first_idx' positions from
; 482  :            the start of the line.  There may be little or no checking that
; 483  :            the sample range represented by `first_idx' and `num_samples' is
; 484  :            legal, so be careful.
; 485  :            [//]
; 486  :            For native C/C++ interfacing, it is more efficient to explicitly
; 487  :            access the internal buffer using `get_buf32'.
; 488  :       */
; 489  :         if ((flags & KD_LINE_BUF_SHORTS) || !(flags & KD_LINE_BUF_ABSOLUTE))
; 490  :           return false;
; 491  :         for (int i=0; i < num_samples; i++)
; 492  :           buf32[i+first_idx].ival = buffer[i];
; 493  :         return true;
; 494  :       }
; 495  :     bool get_ints(kdu_int16 *buffer, int first_idx, int num_samples)
; 496  :       {
; 497  :       /* [SYNOPSIS]
; 498  :            Returns false if the object does not hold a 16-bit sample
; 499  :            representation (either fixed point or absolute integers).
; 500  :            Otherwise, returns true and copies the 16-bit samples into the
; 501  :            supplied `buffer'.  The first copied sample is `first_idx'
; 502  :            positions from the start of the line.  There may be little or no
; 503  :            checking that the sample range represented by `first_idx' and
; 504  :            `num_samples' is legal, so be careful.
; 505  :            [//]
; 506  :            For native C/C++ interfacing, it is more efficient to explicitly
; 507  :            access the internal buffer using `get_buf16'.
; 508  :       */
; 509  :         if (!(flags & KD_LINE_BUF_SHORTS))
; 510  :           return false;
; 511  :         for (int i=0; i < num_samples; i++)
; 512  :           buffer[i] = buf16[first_idx+i].ival;
; 513  :         return true;
; 514  :       }
; 515  :     bool set_ints(kdu_int16 *buffer, int first_idx, int num_samples)
; 516  :       {
; 517  :       /* [SYNOPSIS]
; 518  :            Returns false if the object does not hold a 16-bit sample
; 519  :            representation (either fixed point or absolute integers).
; 520  :            Otherwise, returns true and copies the integer samples from the
; 521  :            supplied `buffer'.  The first sample in `buffer' is stored
; 522  :            `first_idx' positions from the start of the line.  There may be
; 523  :            little or no checking that the sample range represented by
; 524  :            `first_idx' and `num_samples' is legal, so be careful.
; 525  :            [//]
; 526  :            For native C/C++ interfacing, it is more efficient to explicitly
; 527  :            access the internal buffer using `get_buf16'.
; 528  :       */
; 529  :         if (!(flags & KD_LINE_BUF_SHORTS))
; 530  :           return false;
; 531  :         for (int i=0; i < num_samples; i++)
; 532  :           buf16[i+first_idx].ival = buffer[i];
; 533  :         return true;
; 534  :       }
; 535  :     int get_width()
; 536  :       {
; 537  :       /* [SYNOPSIS]
; 538  :            Returns 0 if the object has not been created.  Otherwise, returns
; 539  :            the nominal width of the line.  Remember that the arrays returned
; 540  :            by `get_buf16' and `get_buf32' are typically larger than the actual
; 541  :            line width, as explained in the comments appearing with the
; 542  :            `pre_create' function.
; 543  :       */
; 544  :         return width;

	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR _width$1$[ebp], edi

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	jne	$LN24@perform_in
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _dst$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2089 :       if (line->line.get_buf32() != NULL)

	test	eax, eax
	je	$LN24@perform_in

; 2090 :         { // Floating point implementation
; 2091 :           float factor = -line->irrev_offset;

	movss	xmm0, DWORD PTR [esi+44]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _factor$1[ebp], xmm0

; 2092 :           kdu_sample32 *dst=line->line.get_buf32();
; 2093 :           for (w=0; w < width; w++)

	test	edi, edi
	jle	SHORT $LN7@perform_in
	mov	eax, DWORD PTR _factor$1[ebp]
	mov	ecx, edi
	mov	edi, DWORD PTR _dst$1$[ebp]
	rep stosd
	mov	edi, DWORD PTR _width$1$[ebp]
$LN7@perform_in:

; 2094 :             dst[w].fval = factor;
; 2095 :           for (n=0; n < num_components; n++)

	mov	ecx, DWORD PTR [edx+8]
	xor	eax, eax
	mov	DWORD PTR _n$1$[ebp], eax
	test	ecx, ecx
	jle	$LN2@perform_in
	xor	esi, esi
	mov	DWORD PTR tv1204[ebp], esi
	npad	11
$LL10@perform_in:

; 2096 :             {
; 2097 :               if (components[n].num_consumers < 1)

	mov	edx, DWORD PTR [edx+12]
	cmp	DWORD PTR [edx+esi+24], 1
	jl	$LN8@perform_in
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edx+esi+6], 2
	je	SHORT $LN42@perform_in
	xor	edx, edx
	jmp	SHORT $LN43@perform_in
$LN42@perform_in:
	mov	edx, DWORD PTR [edx+esi+8]
$LN43@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2100 :               factor = inverse_coefficients[m*num_components+n];

	imul	ecx, DWORD PTR _m$1$[ebp]
	add	ecx, eax
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+44]
	movss	xmm1, DWORD PTR [eax+ecx*4]

; 2101 :               for (w=0; w < width; w++)

	xor	eax, eax
	mov	DWORD PTR _w$1$[ebp], eax
	cmp	edi, 4
	jl	$LC74@perform_in

; 2100 :               factor = inverse_coefficients[m*num_components+n];

	mov	eax, DWORD PTR _dst$1$[ebp]
	lea	ecx, DWORD PTR [edx+12]
	mov	esi, edx
	add	eax, 4
	sub	esi, DWORD PTR _dst$1$[ebp]
	mov	DWORD PTR tv1211[ebp], esi
	lea	esi, DWORD PTR [edi-4]
	shr	esi, 2
	inc	esi
	lea	edi, DWORD PTR [esi*4]
	mov	DWORD PTR _w$1$[ebp], edi
	mov	edi, DWORD PTR tv1211[ebp]

; 2101 :               for (w=0; w < width; w++)

$LL75@perform_in:

; 2102 :                 dst[w].fval += factor * src[w].fval;

	movss	xmm0, DWORD PTR [ecx-12]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax-4]
	movss	DWORD PTR [eax-4], xmm0
	movss	xmm0, DWORD PTR [edi+eax]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [ecx-4]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [eax+8], xmm0
	add	eax, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL75@perform_in
	mov	edi, DWORD PTR _width$1$[ebp]
	mov	esi, DWORD PTR tv1204[ebp]
	mov	eax, DWORD PTR _w$1$[ebp]
$LC74@perform_in:

; 2101 :               for (w=0; w < width; w++)

	cmp	eax, edi
	jge	SHORT $LN86@perform_in
	mov	ecx, DWORD PTR _dst$1$[ebp]
	sub	edx, ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, edi
	sub	ecx, DWORD PTR _w$1$[ebp]
	npad	1
$LC13@perform_in:

; 2102 :                 dst[w].fval += factor * src[w].fval;

	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LC13@perform_in
$LN86@perform_in:
	mov	eax, DWORD PTR _n$1$[ebp]
$LN8@perform_in:

; 2094 :             dst[w].fval = factor;
; 2095 :           for (n=0; n < num_components; n++)

	mov	edx, DWORD PTR _this$1$[ebp]
	inc	eax
	add	esi, 60					; 0000003cH
	mov	DWORD PTR _n$1$[ebp], eax
	mov	DWORD PTR tv1204[ebp], esi
	mov	ecx, DWORD PTR [edx+8]
	cmp	eax, ecx
	jl	$LL10@perform_in

; 2103 :             }
; 2104 :         }
; 2105 :       else

	jmp	$LN2@perform_in
$LN24@perform_in:

; 2106 :         {
; 2107 :           if (short_coefficients == NULL)

	cmp	DWORD PTR [edx+48], 0
	jne	SHORT $LN27@perform_in

; 2108 :             create_short_inverse_coefficients(width);

	push	edi
	mov	ecx, edx
	call	?create_short_inverse_coefficients@kd_multi_matrix_block@@AAEXH@Z ; kd_multi_matrix_block::create_short_inverse_coefficients
	mov	edx, DWORD PTR _this$1$[ebp]
$LN27@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [esi+6], 2
	je	SHORT $LN46@perform_in
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _dst$1$[ebp], eax
	jmp	SHORT $LN47@perform_in
$LN46@perform_in:
	mov	DWORD PTR _dst$1$[ebp], 0
$LN47@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2110 :           kdu_int32 *acc = short_accumulator;

	mov	esi, DWORD PTR [edx+52]

; 2111 :           memset(acc,0,(size_t)(width<<2));

	lea	eax, DWORD PTR [edi*4]
	push	eax
	push	0
	push	esi
	call	_memset

; 2112 :           for (n=0; n < num_components; n++)

	mov	edx, DWORD PTR _this$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _n$2$[ebp], 0
	mov	ecx, DWORD PTR [edx+8]
	test	ecx, ecx
	jle	SHORT $LN15@perform_in

; 2110 :           kdu_int32 *acc = short_accumulator;

	xor	eax, eax
	mov	DWORD PTR tv1202[ebp], eax
	npad	5
$LL16@perform_in:

; 2113 :             {
; 2114 :               if (components[n].num_consumers < 1)

	mov	edx, DWORD PTR [edx+12]
	cmp	DWORD PTR [edx+eax+24], 1
	jl	SHORT $LN14@perform_in
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [edx+eax+6], 2
	je	SHORT $LN50@perform_in
	mov	edx, DWORD PTR [edx+eax+8]
	jmp	SHORT $LN51@perform_in
$LN50@perform_in:
	xor	edx, edx
$LN51@perform_in:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 2117 :               kdu_int16 factor = short_coefficients[m*num_components+n];

	imul	ecx, DWORD PTR _m$1$[ebp]
	mov	eax, DWORD PTR _this$1$[ebp]
	add	ecx, DWORD PTR _n$2$[ebp]
	mov	eax, DWORD PTR [eax+48]
	movzx	eax, WORD PTR [eax+ecx*2]

; 2118 :               for (w=0; w < width; w++)

	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN84@perform_in
	cwde
	mov	DWORD PTR tv1217[ebp], eax
$LL19@perform_in:

; 2119 :                 acc[w] += ((kdu_int32) src[w].ival) * factor;

	movsx	eax, WORD PTR [edx+ecx*2]
	imul	eax, DWORD PTR tv1217[ebp]
	add	DWORD PTR [esi+ecx*4], eax
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LL19@perform_in
$LN84@perform_in:
	mov	eax, DWORD PTR tv1202[ebp]
$LN14@perform_in:

; 2112 :           for (n=0; n < num_components; n++)

	mov	edx, DWORD PTR _this$1$[ebp]
	add	eax, 60					; 0000003cH
	inc	DWORD PTR _n$2$[ebp]
	mov	DWORD PTR tv1202[ebp], eax
	mov	ecx, DWORD PTR [edx+8]
	cmp	DWORD PTR _n$2$[ebp], ecx
	jl	SHORT $LL16@perform_in
$LN15@perform_in:

; 2120 :             }
; 2121 :           kdu_int32 downshift = this->short_downshift;

	mov	eax, DWORD PTR [edx+56]

; 2122 :           kdu_int32 offset = (kdu_int32)
; 2123 :             floor(0.5 + line->irrev_offset * (1<<KDU_FIX_POINT));

	sub	esp, 8
	mov	DWORD PTR _downshift$1$[ebp], eax
	mov	eax, DWORD PTR _line$1$[ebp]
	movss	xmm0, DWORD PTR [eax+44]
	mulss	xmm0, DWORD PTR __real@46000000
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv1247[ebp], xmm0
	fld	QWORD PTR tv1247[ebp]
	fstp	QWORD PTR [esp]
	call	_floor

; 2124 :           offset = ((-offset) << downshift) + ((1 << downshift) >> 1);

	mov	ecx, DWORD PTR _downshift$1$[ebp]
	mov	edx, 1
	fstp	QWORD PTR tv1241[ebp]
	cvttsd2si eax, QWORD PTR tv1241[ebp]
	shl	edx, cl
	add	esp, 8
	mov	DWORD PTR _offset$1$[ebp], edx
	shl	eax, cl
	mov	ecx, edx
	sar	ecx, 1

; 2125 :           for (w=0; w < width; w++)

	xor	edx, edx
	sub	ecx, eax
	mov	DWORD PTR _offset$1$[ebp], ecx
	test	edi, edi
	jle	SHORT $LN85@perform_in
$LL22@perform_in:

; 2126 :             dst[w].ival = (kdu_int16)((acc[w]+offset) >> downshift);

	mov	eax, DWORD PTR [esi+edx*4]
	add	eax, ecx
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sar	eax, cl
	mov	ecx, DWORD PTR _dst$1$[ebp]
	mov	WORD PTR [ecx+edx*2], ax
	inc	edx
	mov	ecx, DWORD PTR _offset$1$[ebp]
	cmp	edx, edi
	jl	SHORT $LL22@perform_in
$LN85@perform_in:
	mov	edx, DWORD PTR _this$1$[ebp]
$LN2@perform_in:

; 2079 :   assert(inverse_coefficients != NULL);
; 2080 : 
; 2081 :   int m, n;
; 2082 :   for (m=0; m < num_dependencies; m++)

	mov	esi, DWORD PTR _m$1$[ebp]
	inc	esi
	mov	DWORD PTR _m$1$[ebp], esi
	cmp	esi, DWORD PTR [edx+16]
	jl	$LL4@perform_in
	pop	edi
$LN3@perform_in:
	pop	esi

; 2127 :         }
; 2128 :     }
; 2129 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?perform_inverse@kd_multi_matrix_block@@UAEXXZ ENDP	; kd_multi_matrix_block::perform_inverse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?prepare_for_inversion@kd_multi_matrix_block@@UAEPBDXZ
_TEXT	SEGMENT
_available_outputs$1$ = -128				; size = 4
_inv_G$1$ = -124					; size = 4
_G$1$ = -120						; size = 4
_available_inputs$1$ = -116				; size = 4
_this$1$ = -112						; size = 4
_A$1$ = -108						; size = 4
_m$3$ = -104						; size = 4
_m$2$ = -104						; size = 4
tv8627 = -104						; size = 4
tv8614 = -104						; size = 4
_dp$2$ = -100						; size = 4
_n$5$ = -100						; size = 4
tv8653 = -100						; size = 4
_AtA$1$ = -96						; size = 4
tv8629 = -96						; size = 4
tv8687 = -92						; size = 4
tv8654 = -92						; size = 4
tv8637 = -92						; size = 4
tv8686 = -88						; size = 4
tv8651 = -88						; size = 4
tv8636 = -88						; size = 4
tv8597 = -88						; size = 4
_m$4$ = -84						; size = 4
tv8685 = -84						; size = 4
tv8649 = -84						; size = 4
tv8601 = -84						; size = 4
_m$1$ = -80						; size = 4
_n$6$ = -80						; size = 4
tv8684 = -80						; size = 4
tv8630 = -80						; size = 4
_k$1$ = -76						; size = 4
tv8696 = -76						; size = 4
_n$3$ = -72						; size = 4
tv8628 = -72						; size = 4
tv8596 = -72						; size = 4
tv8675 = -68						; size = 4
tv8631 = -68						; size = 4
tv8593 = -68						; size = 4
tv8673 = -64						; size = 4
tv8648 = -64						; size = 4
tv8626 = -64						; size = 4
tv8602 = -64						; size = 4
tv8674 = -60						; size = 4
tv8652 = -60						; size = 4
tv8632 = -60						; size = 4
tv8615 = -60						; size = 4
tv8603 = -60						; size = 4
tv8670 = -56						; size = 4
tv8656 = -56						; size = 4
tv8640 = -56						; size = 4
tv8610 = -56						; size = 4
tv8606 = -56						; size = 4
tv8668 = -52						; size = 4
tv8657 = -52						; size = 4
tv8639 = -52						; size = 4
tv8617 = -52						; size = 4
tv8605 = -52						; size = 4
tv8692 = -48						; size = 4
tv8669 = -48						; size = 4
tv8658 = -48						; size = 4
tv8642 = -48						; size = 4
tv8619 = -48						; size = 4
tv8608 = -48						; size = 4
_sp$1$ = -44						; size = 4
tv8704 = -40						; size = 4
tv8679 = -40						; size = 4
tv8641 = -40						; size = 4
tv8611 = -40						; size = 4
tv8598 = -40						; size = 4
tv8671 = -36						; size = 4
tv8635 = -36						; size = 4
tv8616 = -36						; size = 4
tv8600 = -36						; size = 4
_dp$1$ = -32						; size = 4
tv8672 = -32						; size = 4
tv8633 = -32						; size = 4
tv8618 = -32						; size = 4
tv8607 = -32						; size = 4
tv8691 = -28						; size = 4
tv8710 = -24						; size = 4
tv8690 = -24						; size = 4
tv8700 = -20						; size = 4
tv8697 = -20						; size = 4
tv8689 = -20						; size = 4
tv8701 = -16						; size = 4
tv8688 = -16						; size = 4
tv8643 = -16						; size = 4
tv8599 = -16						; size = 4
_n$4$ = -12						; size = 4
tv8702 = -12						; size = 4
tv8695 = -12						; size = 4
tv8694 = -12						; size = 4
tv8683 = -12						; size = 4
tv8625 = -12						; size = 4
_max_energy$1$ = -8					; size = 8
?prepare_for_inversion@kd_multi_matrix_block@@UAEPBDXZ PROC ; kd_multi_matrix_block::prepare_for_inversion, COMDAT
; _this$ = ecx

; 1918 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 128				; 00000080H
	mov	edx, ecx

; 1919 :   if (inverse_coefficients != NULL)
; 1920 :     return NULL;

	xor	eax, eax
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[esp+136], edx
	cmp	DWORD PTR [edx+44], eax
	jne	$LN1@prepare_fo

; 1921 : 
; 1922 :   int n, m, k;
; 1923 :   int available_inputs = num_dependencies;
; 1924 :   int available_outputs = 0;
; 1925 :   for (n=0; n < num_components; n++)

	mov	edi, DWORD PTR [edx+8]
	mov	esi, DWORD PTR [edx+16]
	mov	DWORD PTR _available_inputs$1$[esp+136], esi
	mov	DWORD PTR _available_outputs$1$[esp+136], eax
	test	edi, edi
	jle	SHORT $LN3@prepare_fo

; 1926 :     if (components[n].num_consumers > 0)

	mov	eax, DWORD PTR [edx+12]
	mov	ecx, edi
	add	eax, 24					; 00000018H
	xor	esi, esi
	npad	5
$LL4@prepare_fo:
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN2@prepare_fo

; 1927 :       available_outputs++;

	inc	esi
$LN2@prepare_fo:

; 1921 : 
; 1922 :   int n, m, k;
; 1923 :   int available_inputs = num_dependencies;
; 1924 :   int available_outputs = 0;
; 1925 :   for (n=0; n < num_components; n++)

	add	eax, 60					; 0000003cH
	sub	ecx, 1
	jne	SHORT $LL4@prepare_fo
	mov	DWORD PTR _available_outputs$1$[esp+136], esi
	mov	esi, DWORD PTR _available_inputs$1$[esp+136]
	mov	eax, DWORD PTR _available_outputs$1$[esp+136]
$LN3@prepare_fo:

; 1928 :   this->outstanding_consumers = available_outputs;

	mov	DWORD PTR [edx+28], eax

; 1929 :   if (available_outputs < available_inputs)

	cmp	eax, esi
	jge	SHORT $LN76@prepare_fo

; 1930 :     return "Encountered underdetermined system while trying to invert a "

	mov	eax, OFFSET ??_C@_0LC@FOOLOFAN@Encountered?5underdetermined?5syst@

; 2070 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@prepare_fo:

; 1931 :            "multi-component transform block so as to convert MCT output "
; 1932 :            "components into codestream components during compression.";
; 1933 :   for (n=0; n < num_dependencies; n++)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN212@prepare_fo

; 1934 :     if ((dependencies[n] != NULL) && dependencies[n]->reversible)

	mov	edx, DWORD PTR [edx+20]
$LL7@prepare_fo:
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $LN5@prepare_fo
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	BYTE PTR [eax+32], 0
	jne	$LN108@prepare_fo
$LN5@prepare_fo:

; 1931 :            "multi-component transform block so as to convert MCT output "
; 1932 :            "components into codestream components during compression.";
; 1933 :   for (n=0; n < num_dependencies; n++)

	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LL7@prepare_fo
$LN212@prepare_fo:

; 1936 :              "which operates on reversible codestream sample data.  "
; 1937 :              "While we allow such transforms to be processed during "
; 1938 :              "decompression, it is unreasonable to generate reversibly "
; 1939 :              "compressed component samples using an irreversible inverse "
; 1940 :              "multi-component transform during compression.  Kakadu will "
; 1941 :              "not invert this transform during compression.  This can "
; 1942 :              "prevent the compression process from proceeding if there are "
; 1943 :              "no other paths back from the MCT output components to the "
; 1944 :              "codestream components.";
; 1945 : 
; 1946 :   inverse_coefficients = new float[num_dependencies*num_components];

	imul	edi, esi
	xor	ecx, ecx
	mov	edx, 4
	mov	eax, edi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edi, DWORD PTR _this$1$[esp+140]

; 1947 : 
; 1948 :   assert(work == NULL);
; 1949 :   work = new double[3*available_inputs*available_outputs +

	mov	edx, 8
	mov	ecx, DWORD PTR _available_outputs$1$[esp+140]
	mov	DWORD PTR [edi+44], eax
	lea	eax, DWORD PTR [esi+esi]
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, ecx
	xor	ecx, ecx
	imul	eax, esi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 1950 :                     2*available_inputs*available_inputs];
; 1951 :   double *A = work;
; 1952 :   double *pinv_A = A + available_inputs*available_outputs;

	mov	ecx, DWORD PTR _available_outputs$1$[esp+144]
	mov	edx, eax
	imul	ecx, esi
	add	esp, 8
	mov	DWORD PTR [edi+60], edx
	mov	DWORD PTR _A$1$[esp+136], edx

; 1953 :   double *G = pinv_A + available_inputs*available_outputs;
; 1954 :   double *AtA = G + available_inputs*available_outputs;
; 1955 :   double *inv_G = AtA + available_inputs*available_inputs;
; 1956 : 
; 1957 :   // Find matrix A, being the forward transformation from the set of
; 1958 :   // available inputs to the set of available outputs.  Note that A may
; 1959 :   // have more rows than columns.
; 1960 :   double *dp = A;

	mov	DWORD PTR _dp$1$[esp+136], edx
	shl	ecx, 3
	lea	eax, DWORD PTR [ecx+edx]
	lea	edi, DWORD PTR [ecx+eax]
	mov	DWORD PTR _sp$1$[esp+136], eax
	mov	eax, esi
	mov	DWORD PTR _G$1$[esp+136], edi
	imul	eax, esi
	add	ecx, edi
	mov	DWORD PTR _AtA$1$[esp+136], ecx
	lea	eax, DWORD PTR [ecx+eax*8]

; 1961 :   for (m=0; m < num_components; m++)

	xor	ecx, ecx
	mov	DWORD PTR _inv_G$1$[esp+136], eax
	mov	eax, DWORD PTR _this$1$[esp+136]
	mov	DWORD PTR _m$1$[esp+136], ecx
	cmp	DWORD PTR [eax+8], ecx
	jle	SHORT $LN9@prepare_fo

; 1936 :              "which operates on reversible codestream sample data.  "
; 1937 :              "While we allow such transforms to be processed during "
; 1938 :              "decompression, it is unreasonable to generate reversibly "
; 1939 :              "compressed component samples using an irreversible inverse "
; 1940 :              "multi-component transform during compression.  Kakadu will "
; 1941 :              "not invert this transform during compression.  This can "
; 1942 :              "prevent the compression process from proceeding if there are "
; 1943 :              "no other paths back from the MCT output components to the "
; 1944 :              "codestream components.";
; 1945 : 
; 1946 :   inverse_coefficients = new float[num_dependencies*num_components];

	xor	esi, esi
	mov	edi, edx
	mov	DWORD PTR tv8692[esp+136], esi
	npad	11
$LL10@prepare_fo:

; 1962 :     {
; 1963 :       if (components[m].num_consumers < 1)

	mov	eax, DWORD PTR [eax+12]
	cmp	DWORD PTR [eax+esi+24], 1

; 1964 :         continue;
; 1965 :       for (n=0; n < num_dependencies; n++)

	mov	eax, DWORD PTR _this$1$[esp+136]
	jl	SHORT $LN8@prepare_fo
	xor	edx, edx
	cmp	DWORD PTR [eax+16], edx
	jle	SHORT $LN8@prepare_fo
	mov	esi, DWORD PTR _m$1$[esp+136]
	npad	7
$LL13@prepare_fo:

; 1966 :         *(dp++) = coefficients[m*num_dependencies+n];

	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+40]
	imul	ecx, esi
	add	ecx, edx
	inc	edx
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$1$[esp+136]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [edi], xmm0
	add	edi, 8
	cmp	edx, DWORD PTR [eax+16]
	jl	SHORT $LL13@prepare_fo
	mov	ecx, DWORD PTR _m$1$[esp+136]
	mov	esi, DWORD PTR tv8692[esp+136]
$LN8@prepare_fo:

; 1961 :   for (m=0; m < num_components; m++)

	inc	ecx
	add	esi, 60					; 0000003cH
	mov	DWORD PTR _m$1$[esp+136], ecx
	mov	DWORD PTR tv8692[esp+136], esi
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $LL10@prepare_fo
	mov	esi, DWORD PTR _available_inputs$1$[esp+136]
	mov	edi, DWORD PTR _G$1$[esp+136]
$LN9@prepare_fo:

; 1973 :   dp = AtA;

	mov	edx, DWORD PTR _AtA$1$[esp+136]
	xorps	xmm4, xmm4
	mov	DWORD PTR _dp$2$[esp+136], edx
	movaps	xmm1, xmm4
	movsd	QWORD PTR _max_energy$1$[esp+136], xmm1

; 1974 :   for (m=0; m < available_inputs; m++)

	mov	DWORD PTR _m$2$[esp+136], 0
	test	esi, esi
	jle	$LN15@prepare_fo

; 1967 :     }
; 1968 : 
; 1969 :   // Next, evaluate A^t * A.  We will eventually find the pseudo-inverse
; 1970 :   // of the system y = Ax by setting A^t = (A^t*A)*x so that
; 1971 :   // pinv_A = inv(A^t*A) * A^t.
; 1972 :   double max_energy = 0.0;

	mov	ecx, DWORD PTR _A$1$[esp+136]
	lea	edi, DWORD PTR [esi*8]
	mov	DWORD PTR tv8670[esp+136], ecx
	lea	eax, DWORD PTR [edi+ecx]
	mov	DWORD PTR tv8672[esp+136], eax
	lea	eax, DWORD PTR [esi+esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv8671[esp+136], eax
	lea	eax, DWORD PTR [edi+ecx]
	mov	DWORD PTR tv8669[esp+136], eax
	mov	eax, esi
	shl	eax, 4
	add	eax, ecx
	mov	DWORD PTR tv8668[esp+136], eax
	jmp	SHORT $LN16@prepare_fo
$LN108@prepare_fo:

; 1935 :       return "Encountered an irreversible decorrelation transform block "

	mov	eax, OFFSET ??_C@_0CBL@NHJPLOG@Encountered?5an?5irreversible?5deco@

; 2070 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	5
$LL214@prepare_fo:
	mov	ecx, DWORD PTR _A$1$[esp+136]
$LN16@prepare_fo:

; 1975 :     for (n=0; n < available_inputs; n++)

	mov	DWORD PTR tv8675[esp+136], ecx
	xor	eax, eax
	mov	ecx, DWORD PTR tv8672[esp+136]
	mov	DWORD PTR tv8674[esp+136], ecx
	mov	ecx, DWORD PTR tv8671[esp+136]
	mov	DWORD PTR _n$3$[esp+136], eax
	mov	DWORD PTR tv8673[esp+136], ecx
	npad	2
$LL19@prepare_fo:

; 1978 :         for (k=0; k < available_outputs; k++)

	mov	edx, DWORD PTR _dp$2$[esp+136]
	xor	ecx, ecx
	cmp	DWORD PTR _available_outputs$1$[esp+136], 4
	movaps	xmm2, xmm4
	mov	DWORD PTR _k$1$[esp+136], ecx
	jl	$LC165@prepare_fo

; 1976 :       {
; 1977 :         double sum=0.0;

	lea	ecx, DWORD PTR [esi+esi*2]
	mov	edx, esi
	mov	esi, DWORD PTR _A$1$[esp+136]
	add	eax, ecx
	shl	edx, 5
	mov	DWORD PTR tv8683[esp+136], edx
	lea	eax, DWORD PTR [esi+eax*8]
	mov	DWORD PTR tv8689[esp+136], eax
	mov	eax, DWORD PTR _m$2$[esp+136]
	add	eax, ecx
	mov	edi, DWORD PTR tv8689[esp+136]
	mov	ecx, DWORD PTR tv8670[esp+136]
	lea	eax, DWORD PTR [esi+eax*8]
	mov	DWORD PTR tv8688[esp+136], eax
	mov	eax, DWORD PTR tv8673[esp+136]
	mov	esi, DWORD PTR tv8688[esp+136]
	mov	DWORD PTR tv8687[esp+136], eax
	mov	eax, DWORD PTR tv8668[esp+136]
	mov	DWORD PTR tv8686[esp+136], eax
	mov	eax, DWORD PTR tv8674[esp+136]
	mov	DWORD PTR tv8685[esp+136], eax
	mov	eax, DWORD PTR tv8669[esp+136]
	mov	DWORD PTR tv8684[esp+136], eax
	mov	eax, DWORD PTR _available_outputs$1$[esp+136]
	add	eax, -4					; fffffffcH
	shr	eax, 2
	inc	eax
	mov	DWORD PTR tv8679[esp+136], eax
	shl	eax, 2
	mov	DWORD PTR _k$1$[esp+136], eax
	mov	eax, DWORD PTR tv8675[esp+136]

; 1978 :         for (k=0; k < available_outputs; k++)

$LL166@prepare_fo:

; 1979 :           sum += A[m+k*available_inputs] * A[n+k*available_inputs];

	mov	edx, DWORD PTR tv8684[esp+136]
	movsd	xmm1, QWORD PTR [ecx]
	mulsd	xmm1, QWORD PTR [eax]
	movsd	xmm0, QWORD PTR [edx]
	mov	edx, DWORD PTR tv8685[esp+136]
	addsd	xmm2, xmm1
	mulsd	xmm0, QWORD PTR [edx]
	mov	edx, DWORD PTR tv8686[esp+136]
	addsd	xmm2, xmm0
	movsd	xmm0, QWORD PTR [edx]
	mov	edx, DWORD PTR tv8687[esp+136]
	mulsd	xmm0, QWORD PTR [edx]
	mov	edx, DWORD PTR tv8683[esp+136]
	add	ecx, edx
	add	DWORD PTR tv8684[esp+136], edx
	add	eax, edx
	add	DWORD PTR tv8685[esp+136], edx
	add	DWORD PTR tv8686[esp+136], edx
	add	DWORD PTR tv8687[esp+136], edx
	addsd	xmm2, xmm0
	movsd	xmm0, QWORD PTR [esi]
	add	esi, edx
	mulsd	xmm0, QWORD PTR [edi]
	add	edi, edx
	sub	DWORD PTR tv8679[esp+136], 1
	addsd	xmm2, xmm0
	jne	SHORT $LL166@prepare_fo
	movsd	xmm1, QWORD PTR _max_energy$1$[esp+136]
	mov	esi, DWORD PTR _available_inputs$1$[esp+136]
	mov	eax, DWORD PTR _n$3$[esp+136]
	mov	ecx, DWORD PTR _k$1$[esp+136]
	mov	edx, DWORD PTR _dp$2$[esp+136]
$LC165@prepare_fo:

; 1978 :         for (k=0; k < available_outputs; k++)

	lea	edi, DWORD PTR [esi*8]
	cmp	ecx, DWORD PTR _available_outputs$1$[esp+136]
	jge	SHORT $LN164@prepare_fo
	mov	edx, DWORD PTR _A$1$[esp+136]
	imul	ecx, esi
	add	eax, ecx
	lea	edx, DWORD PTR [edx+eax*8]
	mov	eax, DWORD PTR _m$2$[esp+136]
	add	eax, ecx
	mov	ecx, DWORD PTR _A$1$[esp+136]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR _available_outputs$1$[esp+136]
	sub	ecx, DWORD PTR _k$1$[esp+136]
	npad	2
$LC22@prepare_fo:

; 1979 :           sum += A[m+k*available_inputs] * A[n+k*available_inputs];

	movsd	xmm0, QWORD PTR [edx]
	add	edx, edi
	mulsd	xmm0, QWORD PTR [eax]
	add	eax, edi
	addsd	xmm2, xmm0
	sub	ecx, 1
	jne	SHORT $LC22@prepare_fo
	mov	eax, DWORD PTR _n$3$[esp+136]
	mov	edx, DWORD PTR _dp$2$[esp+136]
$LN164@prepare_fo:

; 1980 :         *(dp++) = sum;
; 1981 :         if ((m == n) && (sum > max_energy))

	mov	ecx, DWORD PTR _m$2$[esp+136]
	movsd	QWORD PTR [edx], xmm2
	add	edx, 8
	mov	DWORD PTR _dp$2$[esp+136], edx
	cmp	ecx, eax
	jne	SHORT $LN17@prepare_fo
	comisd	xmm2, xmm1
	jbe	SHORT $LN17@prepare_fo

; 1982 :           max_energy = sum;

	movaps	xmm1, xmm2
	movsd	QWORD PTR _max_energy$1$[esp+136], xmm1
$LN17@prepare_fo:

; 1975 :     for (n=0; n < available_inputs; n++)

	add	DWORD PTR tv8675[esp+136], 8
	inc	eax
	add	DWORD PTR tv8673[esp+136], 8
	add	DWORD PTR tv8674[esp+136], 8
	mov	DWORD PTR _n$3$[esp+136], eax
	cmp	eax, esi
	jl	$LL19@prepare_fo

; 1974 :   for (m=0; m < available_inputs; m++)

	add	DWORD PTR tv8670[esp+136], 8
	inc	ecx
	add	DWORD PTR tv8668[esp+136], 8
	add	DWORD PTR tv8669[esp+136], 8
	mov	DWORD PTR _m$2$[esp+136], ecx
	cmp	ecx, esi
	jl	$LL214@prepare_fo
	mov	edi, DWORD PTR _G$1$[esp+136]
$LN15@prepare_fo:

; 1983 :       }
; 1984 : 
; 1985 :   // Now invert the AtA matrix.  This matrix is guaranteed to be at least
; 1986 :   // positive semi-definite.  Thus, we may use the Cholesky factorization
; 1987 :   // to perform the inversion, while at the same time providing a robust
; 1988 :   // means to test for ill-conditioning.  The Cholesky decomposition
; 1989 :   // represents AtA as G*G^t where G is a lower triangular matrix.  Thus,
; 1990 :   //   | g00  0   0   0   0   0  ...|     |g00 g10 g20 ...|
; 1991 :   //   | g10 g11  0   0   0   0  ...|  *  | 0  g11 g21 ...| = AtA
; 1992 :   //   | g20 g21 g22  0   0   0  ...|     | 0   0  g22 ...|
; 1993 :   //   | ... ... ... ... ... ... ...|     |... ... ... ...|
; 1994 :   for (m=0; m < available_inputs; m++)

	xor	ecx, ecx
	mov	DWORD PTR _m$3$[esp+136], ecx
	test	esi, esi
	jle	$LN24@prepare_fo
	mulsd	xmm1, QWORD PTR __real@3d3c25c268497682
	lea	edx, DWORD PTR [esi*8]
	lea	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv8701[esp+136], edx
	xor	eax, eax
	mov	DWORD PTR tv8697[esp+136], ecx
	add	edx, edi
	mov	DWORD PTR tv8653[esp+136], eax
	sub	DWORD PTR _AtA$1$[esp+136], edi
	mov	ecx, eax
	movsd	QWORD PTR _max_energy$1$[esp+136], xmm1
	mov	DWORD PTR tv8652[esp+136], edi
	mov	DWORD PTR tv8651[esp+136], edi
	mov	DWORD PTR tv8649[esp+136], edi
	mov	DWORD PTR tv8648[esp+136], edx
	npad	3
$LL25@prepare_fo:

; 1995 :     {
; 1996 :       double sum = AtA[m+m*available_inputs];

	mov	edx, DWORD PTR tv8651[esp+136]
	mov	edi, DWORD PTR _AtA$1$[esp+136]
	movsd	xmm4, QWORD PTR [edx+edi]

; 1997 :       for (n=0; n < m; n++)

	xor	edx, edx
	mov	edi, DWORD PTR _G$1$[esp+136]
	cmp	ecx, 4
	jl	SHORT $LC168@prepare_fo

; 1998 :         sum -= G[m*available_inputs+n]*G[m*available_inputs+n];

	mov	eax, DWORD PTR tv8649[esp+136]
	lea	edx, DWORD PTR [ecx-4]
	shr	edx, 2
	inc	edx
	lea	esi, DWORD PTR [edx*4]
	mov	DWORD PTR _n$4$[esp+136], esi
	mov	esi, DWORD PTR _available_inputs$1$[esp+136]
$LL169@prepare_fo:
	movsd	xmm0, QWORD PTR [eax]
	movsd	xmm1, QWORD PTR [eax+8]
	movsd	xmm2, QWORD PTR [eax+16]
	movsd	xmm3, QWORD PTR [eax+24]
	add	eax, 32					; 00000020H
	mulsd	xmm0, xmm0
	mulsd	xmm1, xmm1
	mulsd	xmm2, xmm2
	mulsd	xmm3, xmm3
	subsd	xmm4, xmm0
	subsd	xmm4, xmm1
	subsd	xmm4, xmm2
	subsd	xmm4, xmm3
	sub	edx, 1
	jne	SHORT $LL169@prepare_fo
	movsd	xmm1, QWORD PTR _max_energy$1$[esp+136]
	mov	eax, DWORD PTR tv8653[esp+136]
	mov	edx, DWORD PTR _n$4$[esp+136]
$LC168@prepare_fo:

; 1997 :       for (n=0; n < m; n++)

	cmp	edx, ecx
	jge	SHORT $LN167@prepare_fo

; 1998 :         sum -= G[m*available_inputs+n]*G[m*available_inputs+n];

	add	eax, edx
	sub	ecx, edx
	lea	eax, DWORD PTR [edi+eax*8]
	npad	7
$LC134@prepare_fo:
	movsd	xmm0, QWORD PTR [eax]
	add	eax, 8
	mulsd	xmm0, xmm0
	subsd	xmm4, xmm0
	sub	ecx, 1
	jne	SHORT $LC134@prepare_fo
$LN167@prepare_fo:

; 1999 :       if (sum < (max_energy*0.0000000000001))

	comisd	xmm1, xmm4
	ja	$LN109@prepare_fo

; 2004 :                  "encountered in multi-component transform description.  This "
; 2005 :                  "can prevent the compression process from proceeding if "
; 2006 :                  "there are no other paths back from the MCT output "
; 2007 :                  "components to the codestream components.";
; 2008 :         }
; 2009 :       G[m*available_inputs+m] = sqrt(sum);

	movaps	xmm0, xmm4
	call	__libm_sse2_sqrt_precise
	mov	eax, DWORD PTR tv8651[esp+136]
	xorps	xmm4, xmm4

; 2010 :       double factor = 1.0 / G[m*available_inputs+m];

	movsd	xmm2, QWORD PTR __real@3ff0000000000000

; 2011 :       for (n=0; n < m; n++)

	mov	edx, DWORD PTR _m$3$[esp+136]
	divsd	xmm2, xmm0
	movsd	QWORD PTR [eax], xmm0
	test	edx, edx
	jle	SHORT $LN30@prepare_fo

; 2004 :                  "encountered in multi-component transform description.  This "
; 2005 :                  "can prevent the compression process from proceeding if "
; 2006 :                  "there are no other paths back from the MCT output "
; 2007 :                  "components to the codestream components.";
; 2008 :         }
; 2009 :       G[m*available_inputs+m] = sqrt(sum);

	mov	eax, DWORD PTR tv8652[esp+136]
	mov	ecx, edx
	npad	5
$LL31@prepare_fo:

; 2012 :         G[n*available_inputs+m] = 0.0; // Rest of column above diagonal

	movsd	QWORD PTR [eax], xmm4
	add	eax, DWORD PTR tv8701[esp+136]
	sub	ecx, 1
	jne	SHORT $LL31@prepare_fo
$LN30@prepare_fo:

; 2013 :       for (n=m+1; n < available_inputs; n++)

	lea	ecx, DWORD PTR [edx+1]
	mov	DWORD PTR tv8704[esp+136], ecx
	cmp	ecx, esi
	jge	$LN23@prepare_fo

; 2017 :             sum -= G[n*available_inputs+k] * G[m*available_inputs+k];

	mov	eax, DWORD PTR tv8653[esp+136]
	mov	edi, DWORD PTR tv8648[esp+136]
	add	eax, esi
	mov	DWORD PTR tv8658[esp+136], eax
	add	eax, edx
	mov	DWORD PTR tv8657[esp+136], edi
	mov	edi, DWORD PTR _G$1$[esp+136]
	mov	DWORD PTR tv8654[esp+136], esi
	sub	DWORD PTR tv8654[esp+136], ecx
	lea	eax, DWORD PTR [edi+eax*8]
	mov	DWORD PTR tv8656[esp+136], eax
$LL34@prepare_fo:

; 2014 :         {
; 2015 :           sum = AtA[n*available_inputs+m]; // Column m from AtA

	mov	ecx, DWORD PTR _AtA$1$[esp+136]
	movsd	xmm1, QWORD PTR [ecx+eax]

; 2016 :           for (k=0; k < m; k++)

	xor	ecx, ecx
	cmp	edx, 4
	jl	SHORT $LC171@prepare_fo

; 2017 :             sum -= G[n*available_inputs+k] * G[m*available_inputs+k];

	mov	esi, DWORD PTR tv8649[esp+136]
	mov	edx, DWORD PTR tv8657[esp+136]
	add	esi, 24					; 00000018H
	npad	2
$LL172@prepare_fo:
	mov	eax, DWORD PTR tv8653[esp+136]
	movsd	xmm0, QWORD PTR [edx]
	add	eax, ecx
	add	ecx, 4
	mulsd	xmm0, QWORD PTR [edi+eax*8]
	subsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR [edi+eax*8+8]
	mulsd	xmm0, QWORD PTR [edx+8]
	mov	eax, DWORD PTR tv8704[esp+136]
	add	eax, -4					; fffffffcH
	subsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR [edx+16]
	mulsd	xmm0, QWORD PTR [esi-8]
	subsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR [edx+24]
	mulsd	xmm0, QWORD PTR [esi]
	add	edx, 32					; 00000020H
	add	esi, 32					; 00000020H
	subsd	xmm1, xmm0
	cmp	ecx, eax
	jl	SHORT $LL172@prepare_fo
	mov	esi, DWORD PTR _available_inputs$1$[esp+136]
	mov	edx, DWORD PTR _m$3$[esp+136]
	mov	eax, DWORD PTR tv8656[esp+136]
$LC171@prepare_fo:

; 2016 :           for (k=0; k < m; k++)

	cmp	ecx, edx
	jge	SHORT $LN170@prepare_fo

; 2017 :             sum -= G[n*available_inputs+k] * G[m*available_inputs+k];

	mov	eax, DWORD PTR tv8658[esp+136]
	mov	esi, DWORD PTR _m$3$[esp+136]
	add	eax, ecx
	lea	edx, DWORD PTR [edi+eax*8]
	npad	2
$LC136@prepare_fo:
	mov	eax, DWORD PTR tv8653[esp+136]
	add	eax, ecx
	inc	ecx
	movsd	xmm0, QWORD PTR [edi+eax*8]
	mulsd	xmm0, QWORD PTR [edx]
	add	edx, 8
	subsd	xmm1, xmm0
	cmp	ecx, esi
	jl	SHORT $LC136@prepare_fo
	mov	esi, DWORD PTR _available_inputs$1$[esp+136]
	mov	edx, DWORD PTR _m$3$[esp+136]
	mov	eax, DWORD PTR tv8656[esp+136]
$LN170@prepare_fo:

; 2013 :       for (n=m+1; n < available_inputs; n++)

	add	DWORD PTR tv8658[esp+136], esi
	lea	ecx, DWORD PTR [esi*8]
	add	DWORD PTR tv8657[esp+136], ecx

; 2018 :           G[n*available_inputs+m] = sum * factor;

	movaps	xmm0, xmm2
	mulsd	xmm0, xmm1
	movsd	QWORD PTR [eax], xmm0
	add	eax, ecx
	sub	DWORD PTR tv8654[esp+136], 1
	mov	DWORD PTR tv8656[esp+136], eax
	jne	$LL34@prepare_fo
	mov	ecx, DWORD PTR tv8704[esp+136]
$LN23@prepare_fo:

; 1983 :       }
; 1984 : 
; 1985 :   // Now invert the AtA matrix.  This matrix is guaranteed to be at least
; 1986 :   // positive semi-definite.  Thus, we may use the Cholesky factorization
; 1987 :   // to perform the inversion, while at the same time providing a robust
; 1988 :   // means to test for ill-conditioning.  The Cholesky decomposition
; 1989 :   // represents AtA as G*G^t where G is a lower triangular matrix.  Thus,
; 1990 :   //   | g00  0   0   0   0   0  ...|     |g00 g10 g20 ...|
; 1991 :   //   | g10 g11  0   0   0   0  ...|  *  | 0  g11 g21 ...| = AtA
; 1992 :   //   | g20 g21 g22  0   0   0  ...|     | 0   0  g22 ...|
; 1993 :   //   | ... ... ... ... ... ... ...|     |... ... ... ...|
; 1994 :   for (m=0; m < available_inputs; m++)

	mov	eax, DWORD PTR tv8697[esp+136]
	lea	edx, DWORD PTR [esi*8]
	add	DWORD PTR tv8651[esp+136], eax
	mov	eax, DWORD PTR tv8653[esp+136]
	add	DWORD PTR tv8652[esp+136], 8
	add	eax, esi
	add	DWORD PTR tv8648[esp+136], edx
	add	DWORD PTR tv8649[esp+136], edx
	movsd	xmm1, QWORD PTR _max_energy$1$[esp+136]
	mov	DWORD PTR _m$3$[esp+136], ecx
	mov	DWORD PTR tv8653[esp+136], eax
	cmp	ecx, esi
	jl	$LL25@prepare_fo
$LN24@prepare_fo:

; 2019 :         }
; 2020 :     }
; 2021 : 
; 2022 :   // Now invert G
; 2023 :   for (n=0; n < available_inputs; n++)

	xor	edx, edx
	mov	DWORD PTR _n$5$[esp+136], edx
	test	esi, esi
	jle	$LN39@prepare_fo
	mov	edx, DWORD PTR _inv_G$1$[esp+136]
	lea	ecx, DWORD PTR [esi*8]
	movsd	xmm3, QWORD PTR __xmm@80000000000000008000000000000000
	lea	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR tv8696[esp+136], eax
	mov	eax, edx
	add	edx, ecx
	mov	DWORD PTR tv8627[esp+136], esi
	shl	DWORD PTR tv8627[esp+136], 4
	mov	DWORD PTR tv8628[esp+136], edx
	mov	edx, eax
	add	DWORD PTR tv8627[esp+136], edx
	lea	edx, DWORD PTR [esi+3]
	lea	edx, DWORD PTR [edi+edx*8]
	mov	DWORD PTR tv8700[esp+136], ecx
	mov	DWORD PTR tv8626[esp+136], edx
	mov	edx, eax
	sub	edx, edi
	mov	DWORD PTR tv8631[esp+136], eax
	mov	DWORD PTR tv8625[esp+136], edx
	mov	edx, DWORD PTR _n$5$[esp+136]
	mov	DWORD PTR tv8630[esp+136], esi
	mov	DWORD PTR tv8629[esp+136], edi
$LL40@prepare_fo:

; 2024 :     { // Scan through the columns of inv_G; it is also lower triangular
; 2025 :       for (m=0; m < n; m++)

	test	edx, edx
	jle	SHORT $LN42@prepare_fo
	npad	6
$LL43@prepare_fo:

; 2026 :         inv_G[m*available_inputs+n] = 0.0;

	movsd	QWORD PTR [eax], xmm4
	add	eax, ecx
	sub	edx, 1
	jne	SHORT $LL43@prepare_fo
	mov	edx, DWORD PTR _n$5$[esp+136]
$LN42@prepare_fo:

; 2027 :       inv_G[n*available_inputs+n] = 1.0 / G[n*available_inputs+n];

	mov	eax, DWORD PTR tv8629[esp+136]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	mov	edi, DWORD PTR tv8625[esp+136]
	divsd	xmm0, QWORD PTR [eax]
	movsd	QWORD PTR [edi+eax], xmm0

; 2028 :       for (m=n+1; m < available_inputs; m++)

	lea	eax, DWORD PTR [edx+1]
	mov	edi, DWORD PTR _G$1$[esp+136]
	mov	edx, eax
	mov	DWORD PTR tv8710[esp+136], eax
	mov	DWORD PTR _m$4$[esp+136], edx
	cmp	eax, esi
	jge	$LN38@prepare_fo

; 2027 :       inv_G[n*available_inputs+n] = 1.0 / G[n*available_inputs+n];

	mov	ecx, DWORD PTR tv8630[esp+136]
	add	eax, -3					; fffffffdH
	mov	DWORD PTR tv8636[esp+136], eax
	mov	eax, DWORD PTR tv8696[esp+136]
	add	eax, DWORD PTR tv8629[esp+136]
	mov	DWORD PTR tv8635[esp+136], eax
	mov	eax, DWORD PTR _n$5$[esp+136]
	add	eax, ecx
	mov	DWORD PTR tv8637[esp+136], ecx
	mov	ecx, DWORD PTR _inv_G$1$[esp+136]
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv8633[esp+136], eax
	mov	eax, DWORD PTR tv8626[esp+136]
	mov	DWORD PTR tv8632[esp+136], eax
	mov	eax, DWORD PTR tv8636[esp+136]
	npad	7
$LL46@prepare_fo:

; 2029 :         {
; 2030 :           double sum = 0.0;
; 2031 :           for (k=0; k < m; k++)

	xor	ecx, ecx
	movaps	xmm2, xmm4
	cmp	edx, 4
	jl	$LC174@prepare_fo

; 2032 :             sum += inv_G[k*available_inputs+n] * G[m*available_inputs+k];

	mov	eax, DWORD PTR tv8631[esp+136]
	mov	edx, esi
	mov	DWORD PTR tv8642[esp+136], eax
	mov	eax, DWORD PTR _n$5$[esp+136]
	shl	edx, 5
	lea	eax, DWORD PTR [eax+esi*2]
	add	eax, esi
	mov	esi, DWORD PTR _inv_G$1$[esp+136]
	lea	eax, DWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR tv8632[esp+136]
	mov	DWORD PTR tv8641[esp+136], eax
	mov	eax, DWORD PTR tv8627[esp+136]
	mov	DWORD PTR tv8640[esp+136], eax
	mov	eax, DWORD PTR tv8628[esp+136]
	mov	DWORD PTR tv8639[esp+136], eax
$LL175@prepare_fo:
	mov	eax, DWORD PTR tv8637[esp+136]
	add	eax, ecx
	add	ecx, 4
	movsd	xmm1, QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR tv8642[esp+136]
	add	DWORD PTR tv8642[esp+136], edx
	mulsd	xmm1, QWORD PTR [edi]
	mov	edi, DWORD PTR _G$1$[esp+136]
	movsd	xmm0, QWORD PTR [edi+eax*8+8]
	addsd	xmm2, xmm1
	mov	eax, DWORD PTR tv8639[esp+136]
	add	DWORD PTR tv8639[esp+136], edx
	mulsd	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR tv8640[esp+136]
	add	DWORD PTR tv8640[esp+136], edx
	addsd	xmm2, xmm0
	movsd	xmm0, QWORD PTR [esi-8]
	mulsd	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR tv8641[esp+136]
	addsd	xmm2, xmm0
	movsd	xmm0, QWORD PTR [eax]
	mulsd	xmm0, QWORD PTR [esi]
	add	eax, edx
	mov	DWORD PTR tv8641[esp+136], eax
	add	esi, 32					; 00000020H
	mov	eax, DWORD PTR tv8636[esp+136]
	addsd	xmm2, xmm0
	cmp	ecx, eax
	jl	SHORT $LL175@prepare_fo
	mov	esi, DWORD PTR _available_inputs$1$[esp+136]
	mov	edx, DWORD PTR _m$4$[esp+136]
$LC174@prepare_fo:

; 2029 :         {
; 2030 :           double sum = 0.0;
; 2031 :           for (k=0; k < m; k++)

	cmp	ecx, edx
	jge	SHORT $LN173@prepare_fo

; 2032 :             sum += inv_G[k*available_inputs+n] * G[m*available_inputs+k];

	mov	edx, DWORD PTR _inv_G$1$[esp+136]
	mov	eax, ecx
	imul	eax, esi
	mov	esi, DWORD PTR _m$4$[esp+136]
	add	eax, DWORD PTR _n$5$[esp+136]
	lea	edx, DWORD PTR [edx+eax*8]
$LC49@prepare_fo:
	mov	eax, DWORD PTR tv8637[esp+136]
	add	eax, ecx
	inc	ecx
	movsd	xmm0, QWORD PTR [edi+eax*8]
	mulsd	xmm0, QWORD PTR [edx]
	add	edx, DWORD PTR tv8700[esp+136]
	addsd	xmm2, xmm0
	cmp	ecx, esi
	jl	SHORT $LC49@prepare_fo
	mov	esi, DWORD PTR _available_inputs$1$[esp+136]
	mov	edx, DWORD PTR _m$4$[esp+136]
	mov	eax, DWORD PTR tv8636[esp+136]
$LN173@prepare_fo:

; 2033 :           inv_G[m*available_inputs+n] = -sum / G[m*available_inputs+m];

	mov	ecx, DWORD PTR tv8635[esp+136]
	inc	edx
	mov	edi, DWORD PTR tv8633[esp+136]
	inc	eax
	add	DWORD PTR tv8637[esp+136], esi
	mov	DWORD PTR _m$4$[esp+136], edx
	divsd	xmm2, QWORD PTR [ecx]
	add	ecx, DWORD PTR tv8696[esp+136]
	mov	DWORD PTR tv8635[esp+136], ecx
	lea	ecx, DWORD PTR [esi*8]
	add	DWORD PTR tv8632[esp+136], ecx
	mov	DWORD PTR tv8636[esp+136], eax
	xorps	xmm2, xmm3
	movsd	QWORD PTR [edi], xmm2
	add	edi, ecx
	mov	DWORD PTR tv8633[esp+136], edi
	mov	edi, DWORD PTR _G$1$[esp+136]
	cmp	edx, esi
	jl	$LL46@prepare_fo
	mov	eax, DWORD PTR tv8710[esp+136]
$LN38@prepare_fo:

; 2019 :         }
; 2020 :     }
; 2021 : 
; 2022 :   // Now invert G
; 2023 :   for (n=0; n < available_inputs; n++)

	add	DWORD PTR tv8630[esp+136], esi
	mov	edx, eax
	add	DWORD PTR tv8626[esp+136], ecx
	lea	eax, DWORD PTR [ecx+8]
	add	DWORD PTR tv8629[esp+136], eax
	mov	eax, DWORD PTR tv8631[esp+136]
	add	DWORD PTR tv8627[esp+136], 8
	add	eax, 8
	add	DWORD PTR tv8628[esp+136], 8
	mov	DWORD PTR _n$5$[esp+136], edx
	mov	DWORD PTR tv8631[esp+136], eax
	cmp	edx, esi
	jl	$LL40@prepare_fo
$LN39@prepare_fo:

; 2034 :         }
; 2035 :     }
; 2036 : 
; 2037 :   // Now find pinv_A = inv(G)^t * inv(G) * A^t -- equivalently,
; 2038 :   // pinv_A^t = A * inv(G)^t * inv(G)
; 2039 :   
; 2040 :   // Start by overwriting G with A * inv(G)^t
; 2041 :   for (m=0; m < available_outputs; m++)

	mov	eax, DWORD PTR _available_outputs$1$[esp+136]
	test	eax, eax
	jle	$LN60@prepare_fo
	mov	edx, DWORD PTR _A$1$[esp+136]
	lea	ecx, DWORD PTR [esi*8]
	xor	eax, eax
	mov	DWORD PTR tv8611[esp+136], edi
	mov	DWORD PTR tv8614[esp+136], eax
	add	edx, 24					; 00000018H
	mov	eax, DWORD PTR _available_outputs$1$[esp+136]
	mov	DWORD PTR tv8615[esp+136], eax
	mov	eax, DWORD PTR tv8614[esp+136]
	mov	DWORD PTR tv8610[esp+136], edx
	npad	7
$LL52@prepare_fo:

; 2042 :     for (n=0; n < available_inputs; n++)

	test	esi, esi
	jle	$LN50@prepare_fo

; 2046 :           sum += A[m*available_inputs+k] * inv_G[n*available_inputs+k];

	mov	edx, DWORD PTR _inv_G$1$[esp+136]
	xor	eax, eax
	mov	DWORD PTR tv8618[esp+136], edi
	mov	edi, DWORD PTR tv8614[esp+136]
	mov	DWORD PTR tv8619[esp+136], eax
	mov	DWORD PTR tv8617[esp+136], edx
	mov	DWORD PTR tv8616[esp+136], esi
$LL55@prepare_fo:

; 2043 :       {
; 2044 :         double sum = 0.0;

	xor	ecx, ecx
	movaps	xmm2, xmm4

; 2045 :         for (k=0; k < available_inputs; k++)

	cmp	esi, 4
	jl	$LC177@prepare_fo

; 2046 :           sum += A[m*available_inputs+k] * inv_G[n*available_inputs+k];

	mov	edi, DWORD PTR tv8610[esp+136]
	lea	eax, DWORD PTR [esi-3]
	mov	esi, DWORD PTR tv8614[esp+136]
	mov	DWORD PTR tv8695[esp+136], eax
	npad	1
$LL178@prepare_fo:
	movsd	xmm0, QWORD PTR [edx]
	lea	eax, DWORD PTR [esi+ecx]
	mov	esi, DWORD PTR _A$1$[esp+136]
	add	ecx, 4
	movsd	xmm1, QWORD PTR [edx+8]
	mulsd	xmm0, QWORD PTR [esi+eax*8]
	mulsd	xmm1, QWORD PTR [esi+eax*8+8]
	mov	esi, DWORD PTR tv8614[esp+136]
	addsd	xmm2, xmm0
	movsd	xmm0, QWORD PTR [edx+16]
	mulsd	xmm0, QWORD PTR [edi-8]
	addsd	xmm2, xmm1
	addsd	xmm2, xmm0
	movsd	xmm0, QWORD PTR [edx+24]
	mulsd	xmm0, QWORD PTR [edi]
	add	edx, 32					; 00000020H
	add	edi, 32					; 00000020H
	addsd	xmm2, xmm0
	cmp	ecx, DWORD PTR tv8695[esp+136]
	jl	SHORT $LL178@prepare_fo
	mov	esi, DWORD PTR _available_inputs$1$[esp+136]
	mov	edi, DWORD PTR tv8614[esp+136]
	mov	eax, DWORD PTR tv8619[esp+136]
	mov	edx, DWORD PTR tv8617[esp+136]
$LC177@prepare_fo:

; 2045 :         for (k=0; k < available_inputs; k++)

	cmp	ecx, esi
	jge	SHORT $LN176@prepare_fo

; 2046 :           sum += A[m*available_inputs+k] * inv_G[n*available_inputs+k];

	mov	edx, DWORD PTR _inv_G$1$[esp+136]
	add	eax, ecx
	lea	edx, DWORD PTR [edx+eax*8]
	npad	2
$LC138@prepare_fo:
	lea	eax, DWORD PTR [edi+ecx]
	mov	edi, DWORD PTR _A$1$[esp+136]
	inc	ecx
	movsd	xmm0, QWORD PTR [edi+eax*8]
	mulsd	xmm0, QWORD PTR [edx]
	add	edx, 8
	mov	edi, DWORD PTR tv8614[esp+136]
	addsd	xmm2, xmm0
	cmp	ecx, esi
	jl	SHORT $LC138@prepare_fo
	mov	eax, DWORD PTR tv8619[esp+136]
	mov	edx, DWORD PTR tv8617[esp+136]
$LN176@prepare_fo:

; 2047 :         G[m*available_inputs+n] = sum;

	mov	ecx, DWORD PTR tv8618[esp+136]
	add	eax, esi
	mov	DWORD PTR tv8619[esp+136], eax
	movsd	QWORD PTR [ecx], xmm2
	add	ecx, 8
	mov	DWORD PTR tv8618[esp+136], ecx
	lea	ecx, DWORD PTR [esi*8]
	add	edx, ecx
	sub	DWORD PTR tv8616[esp+136], 1
	mov	DWORD PTR tv8617[esp+136], edx
	jne	$LL55@prepare_fo
	mov	eax, DWORD PTR tv8614[esp+136]
	mov	edx, DWORD PTR tv8610[esp+136]
	mov	edi, DWORD PTR tv8611[esp+136]
$LN50@prepare_fo:

; 2034 :         }
; 2035 :     }
; 2036 : 
; 2037 :   // Now find pinv_A = inv(G)^t * inv(G) * A^t -- equivalently,
; 2038 :   // pinv_A^t = A * inv(G)^t * inv(G)
; 2039 :   
; 2040 :   // Start by overwriting G with A * inv(G)^t
; 2041 :   for (m=0; m < available_outputs; m++)

	add	eax, esi
	add	edx, ecx
	add	edi, ecx
	mov	DWORD PTR tv8614[esp+136], eax
	sub	DWORD PTR tv8615[esp+136], 1
	mov	DWORD PTR tv8610[esp+136], edx
	mov	DWORD PTR tv8611[esp+136], edi
	jne	$LL52@prepare_fo

; 2048 :       }
; 2049 : 
; 2050 :   // Now multiply by inv_G and write the transposed result to pinv_A
; 2051 :   for (m=0; m < available_outputs; m++)

	mov	eax, DWORD PTR _available_outputs$1$[esp+136]
	mov	edi, DWORD PTR _G$1$[esp+136]
	test	eax, eax
	jle	$LN60@prepare_fo
	mov	ecx, DWORD PTR _sp$1$[esp+136]
	lea	edx, DWORD PTR [edi+24]
	xor	eax, eax
	mov	DWORD PTR tv8593[esp+136], edx
	mov	edx, DWORD PTR _available_outputs$1$[esp+136]
	mov	DWORD PTR tv8596[esp+136], ecx
	lea	ecx, DWORD PTR [esi*8]
	mov	DWORD PTR tv8597[esp+136], eax
	mov	DWORD PTR tv8598[esp+136], edx
$LL61@prepare_fo:

; 2052 :     for (n=0; n < available_inputs; n++)

	xor	edx, edx
	mov	DWORD PTR _n$6$[esp+136], edx
	test	esi, esi
	jle	$LN59@prepare_fo

; 2056 :           sum += G[m*available_inputs+k] * inv_G[k*available_inputs+n];

	mov	eax, DWORD PTR _inv_G$1$[esp+136]
	mov	DWORD PTR tv8603[esp+136], eax
	mov	eax, DWORD PTR _available_outputs$1$[esp+136]
	shl	eax, 3
	mov	DWORD PTR tv8599[esp+136], eax
	mov	eax, DWORD PTR _inv_G$1$[esp+136]
	add	eax, ecx
	mov	ecx, DWORD PTR tv8596[esp+136]
	mov	DWORD PTR tv8602[esp+136], eax
	mov	eax, esi
	shl	eax, 4
	add	eax, DWORD PTR _inv_G$1$[esp+136]
	mov	DWORD PTR tv8601[esp+136], eax
	mov	DWORD PTR tv8600[esp+136], ecx
$LL64@prepare_fo:

; 2053 :       {
; 2054 :         double sum = 0.0;

	xor	ecx, ecx
	movaps	xmm2, xmm4

; 2055 :         for (k=0; k < available_inputs; k++)

	cmp	esi, 4
	jl	$LC180@prepare_fo

; 2053 :       {
; 2054 :         double sum = 0.0;

	mov	edi, DWORD PTR tv8593[esp+136]
	lea	eax, DWORD PTR [esi-3]
	mov	DWORD PTR tv8694[esp+136], eax
	mov	edx, esi
	mov	eax, DWORD PTR tv8603[esp+136]
	mov	DWORD PTR tv8608[esp+136], eax
	mov	eax, DWORD PTR _n$6$[esp+136]
	shl	edx, 5
	lea	eax, DWORD PTR [eax+esi*2]
	add	eax, esi
	mov	esi, DWORD PTR _inv_G$1$[esp+136]
	lea	eax, DWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR _G$1$[esp+136]
	mov	DWORD PTR tv8607[esp+136], eax
	mov	eax, DWORD PTR tv8601[esp+136]
	mov	DWORD PTR tv8606[esp+136], eax
	mov	eax, DWORD PTR tv8602[esp+136]
	mov	DWORD PTR tv8605[esp+136], eax

; 2055 :         for (k=0; k < available_inputs; k++)

$LL181@prepare_fo:

; 2056 :           sum += G[m*available_inputs+k] * inv_G[k*available_inputs+n];

	mov	eax, DWORD PTR tv8597[esp+136]
	add	eax, ecx
	add	ecx, 4
	movsd	xmm1, QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR tv8608[esp+136]
	add	DWORD PTR tv8608[esp+136], edx
	mulsd	xmm1, QWORD PTR [esi]
	mov	esi, DWORD PTR _G$1$[esp+136]
	movsd	xmm0, QWORD PTR [esi+eax*8+8]
	addsd	xmm2, xmm1
	mov	eax, DWORD PTR tv8605[esp+136]
	add	DWORD PTR tv8605[esp+136], edx
	mulsd	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR tv8606[esp+136]
	add	DWORD PTR tv8606[esp+136], edx
	addsd	xmm2, xmm0
	movsd	xmm0, QWORD PTR [edi-8]
	mulsd	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR tv8607[esp+136]
	addsd	xmm2, xmm0
	movsd	xmm0, QWORD PTR [eax]
	mulsd	xmm0, QWORD PTR [edi]
	add	eax, edx
	add	edi, 32					; 00000020H
	mov	DWORD PTR tv8607[esp+136], eax
	addsd	xmm2, xmm0
	cmp	ecx, DWORD PTR tv8694[esp+136]
	jl	SHORT $LL181@prepare_fo
	mov	esi, DWORD PTR _available_inputs$1$[esp+136]
	mov	edi, DWORD PTR _G$1$[esp+136]
	mov	edx, DWORD PTR _n$6$[esp+136]
	mov	eax, DWORD PTR tv8601[esp+136]
$LC180@prepare_fo:

; 2055 :         for (k=0; k < available_inputs; k++)

	cmp	ecx, esi
	jge	SHORT $LN179@prepare_fo
	mov	eax, ecx
	imul	eax, esi
	add	eax, edx
	mov	edx, DWORD PTR _inv_G$1$[esp+136]
	lea	edx, DWORD PTR [edx+eax*8]
	npad	2
$LC67@prepare_fo:

; 2056 :           sum += G[m*available_inputs+k] * inv_G[k*available_inputs+n];

	mov	eax, DWORD PTR tv8597[esp+136]
	add	eax, ecx
	inc	ecx
	movsd	xmm0, QWORD PTR [edi+eax*8]
	lea	eax, DWORD PTR [esi*8]
	mulsd	xmm0, QWORD PTR [edx]
	add	edx, eax
	addsd	xmm2, xmm0
	cmp	ecx, esi
	jl	SHORT $LC67@prepare_fo
	mov	edx, DWORD PTR _n$6$[esp+136]
	mov	eax, DWORD PTR tv8601[esp+136]
$LN179@prepare_fo:

; 2057 :         pinv_A[n*available_outputs+m] = sum;

	mov	ecx, DWORD PTR tv8600[esp+136]
	inc	edx
	add	DWORD PTR tv8603[esp+136], 8
	add	eax, 8
	add	DWORD PTR tv8602[esp+136], 8
	mov	DWORD PTR _n$6$[esp+136], edx
	movsd	QWORD PTR [ecx], xmm2
	add	ecx, DWORD PTR tv8599[esp+136]
	mov	DWORD PTR tv8601[esp+136], eax
	mov	DWORD PTR tv8600[esp+136], ecx
	cmp	edx, esi
	jl	$LL64@prepare_fo
	mov	eax, DWORD PTR tv8597[esp+136]
	lea	ecx, DWORD PTR [esi*8]
$LN59@prepare_fo:

; 2048 :       }
; 2049 : 
; 2050 :   // Now multiply by inv_G and write the transposed result to pinv_A
; 2051 :   for (m=0; m < available_outputs; m++)

	add	DWORD PTR tv8593[esp+136], ecx
	add	eax, esi
	add	DWORD PTR tv8596[esp+136], 8
	sub	DWORD PTR tv8598[esp+136], 1
	mov	DWORD PTR tv8597[esp+136], eax
	jne	$LL61@prepare_fo
$LN60@prepare_fo:

; 2058 :       }
; 2059 : 
; 2060 :   // Finally, write the `inverse_coefficients' array
; 2061 :   double *sp = pinv_A;
; 2062 :   for (m=0; m < num_dependencies; m++)

	mov	ecx, DWORD PTR _this$1$[esp+136]
	xor	edi, edi
	cmp	DWORD PTR [ecx+16], edi
	jle	$LN69@prepare_fo
	npad	5
$LL70@prepare_fo:

; 2063 :     for (n=0; n < num_components; n++)

	xor	edx, edx
	cmp	DWORD PTR [ecx+8], edx
	jle	$LN68@prepare_fo
	xor	esi, esi
	npad	3
$LL73@prepare_fo:

; 2064 :       inverse_coefficients[m*num_components + n] =

	mov	eax, DWORD PTR [ecx+12]
	cmp	DWORD PTR [eax+esi+24], 1
	jge	SHORT $LN82@prepare_fo
	xorps	xmm0, xmm0
	jmp	SHORT $LN83@prepare_fo
$LN109@prepare_fo:

; 2000 :         {
; 2001 :           delete[] work;

	mov	esi, DWORD PTR _this$1$[esp+136]
	push	DWORD PTR [esi+60]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 2002 :           work = NULL;

	mov	DWORD PTR [esi+60], 0

; 2003 :           return "Near singular irreversible decorrelation transform block "

	mov	eax, OFFSET ??_C@_0BAH@FNBHAICK@Near?5singular?5irreversible?5decor@

; 2070 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN82@prepare_fo:

; 2064 :       inverse_coefficients[m*num_components + n] =

	mov	eax, DWORD PTR _sp$1$[esp+136]
	movsd	xmm0, QWORD PTR [eax]
	add	eax, 8
	cvtpd2ps xmm0, xmm0
	mov	DWORD PTR _sp$1$[esp+136], eax
$LN83@prepare_fo:
	mov	ecx, DWORD PTR [ecx+8]
	add	esi, 60					; 0000003cH
	mov	eax, DWORD PTR _this$1$[esp+136]
	imul	ecx, edi
	mov	eax, DWORD PTR [eax+44]
	add	ecx, edx
	inc	edx
	movss	DWORD PTR [eax+ecx*4], xmm0
	mov	ecx, DWORD PTR _this$1$[esp+136]
	cmp	edx, DWORD PTR [ecx+8]
	jl	SHORT $LL73@prepare_fo
$LN68@prepare_fo:

; 2058 :       }
; 2059 : 
; 2060 :   // Finally, write the `inverse_coefficients' array
; 2061 :   double *sp = pinv_A;
; 2062 :   for (m=0; m < num_dependencies; m++)

	inc	edi
	cmp	edi, DWORD PTR [ecx+16]
	jl	SHORT $LL70@prepare_fo
$LN69@prepare_fo:

; 2065 :         (components[n].num_consumers < 1)?0.0F:((float) *(sp++));
; 2066 : 
; 2067 :   delete[] work;

	push	DWORD PTR [ecx+60]
	call	??_V@YAXPAX@Z				; operator delete[]

; 2068 :   work = NULL;

	mov	eax, DWORD PTR _this$1$[esp+140]
	add	esp, 4
	mov	DWORD PTR [eax+60], 0

; 2069 :   return NULL;

	xor	eax, eax
$LN1@prepare_fo:

; 2070 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?prepare_for_inversion@kd_multi_matrix_block@@UAEPBDXZ ENDP ; kd_multi_matrix_block::prepare_for_inversion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?perform_transform@kd_multi_matrix_block@@UAEXXZ
_TEXT	SEGMENT
_downshift$1$ = -40					; size = 4
_line$1$ = -40						; size = 4
tv2052 = -36						; size = 4
_dst$1$ = -32						; size = 4
tv2069 = -32						; size = 4
tv2067 = -32						; size = 4
_factor$1 = -32						; size = 4
tv2115 = -28						; size = 8
tv2104 = -28						; size = 8
_n$2$ = -24						; size = 4
_src$1$ = -20						; size = 4
_n$1$ = -20						; size = 4
_width$1$ = -16						; size = 4
_factor$1$ = -12					; size = 4
_dst$1$ = -12						; size = 4
_this$1$ = -8						; size = 4
_m$1$ = -4						; size = 4
?perform_transform@kd_multi_matrix_block@@UAEXXZ PROC	; kd_multi_matrix_block::perform_transform, COMDAT
; _this$ = ecx

; 1834 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1835 :   int m, n;
; 1836 :   for (m=0; m < num_components; m++)

	cmp	DWORD PTR [ecx+8], 0
	mov	DWORD PTR _this$1$[ebp], ecx
	mov	DWORD PTR _m$1$[ebp], 0
	jle	$LN3@perform_tr
	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	push	ebx
	push	esi
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR tv2052[ebp], ebx
	npad	3
$LL4@perform_tr:

; 1837 :     {
; 1838 :       kd_multi_line *line=components+m;

	mov	edi, DWORD PTR [ecx+12]
	add	edi, ebx
	mov	DWORD PTR _line$1$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edi+6], 2

; 414  :       }
; 415  :     bool get_floats(float *buffer, int first_idx, int num_samples)
; 416  :       {
; 417  :       /* [SYNOPSIS]
; 418  :            Returns false if the object does not hold a 32-bit normalized
; 419  :            (floating point) sample representation.  Otherwise, returns true
; 420  :            and copies the floating point samples into the supplied `buffer'.
; 421  :            The first copied sample is `first_idx' positions from the start
; 422  :            of the line.  There may be little or no checking that the
; 423  :            sample range represented by `first_idx' and `num_samples' is
; 424  :            legal, so be careful.
; 425  :            [//]
; 426  :            For native C/C++ interfacing, it is more efficient to explicitly
; 427  :            access the internal buffer using `get_buf32'.
; 428  :       */
; 429  :         if (flags & (KD_LINE_BUF_ABSOLUTE | KD_LINE_BUF_ABSOLUTE))
; 430  :           return false;
; 431  :         for (int i=0; i < num_samples; i++)
; 432  :           buffer[i] = buf32[first_idx+i].fval;
; 433  :         return true;
; 434  :       }
; 435  :     bool set_floats(float *buffer, int first_idx, int num_samples)
; 436  :       {
; 437  :       /* [SYNOPSIS]
; 438  :            Returns false if the object does not hold a 32-bit normalized
; 439  :            (floating point) sample representation.  Otherwise, returns true
; 440  :            and copies the floating point samples from the supplied `buffer'.
; 441  :            The first sample in `buffer' is stored `first_idx' positions from
; 442  :            the start of the line.  There may be little or no checking that
; 443  :            the sample range represented by `first_idx' and `num_samples' is
; 444  :            legal, so be careful.
; 445  :            [//]
; 446  :            For native C/C++ interfacing, it is more efficient to explicitly
; 447  :            access the internal buffer using `get_buf32'.
; 448  :       */
; 449  :         if (flags & (KD_LINE_BUF_ABSOLUTE | KD_LINE_BUF_ABSOLUTE))
; 450  :           return false;
; 451  :         for (int i=0; i < num_samples; i++)
; 452  :           buf32[i+first_idx].fval = buffer[i];
; 453  :         return true;
; 454  :       }
; 455  :     bool get_ints(kdu_int32 *buffer, int first_idx, int num_samples)
; 456  :       {
; 457  :       /* [SYNOPSIS]
; 458  :            Returns false if the object does not hold a 32-bit absolute
; 459  :            (integer) sample representation.  Otherwise, returns true
; 460  :            and copies the integer samples into the supplied `buffer'.
; 461  :            The first copied sample is `first_idx' positions from the start
; 462  :            of the line.  There may be little or no checking that the
; 463  :            sample range represented by `first_idx' and `num_samples' is
; 464  :            legal, so be careful.
; 465  :            [//]
; 466  :            For native C/C++ interfacing, it is more efficient to explicitly
; 467  :            access the internal buffer using `get_buf32'.
; 468  :       */
; 469  :         if ((flags & KD_LINE_BUF_SHORTS) || !(flags & KD_LINE_BUF_ABSOLUTE))
; 470  :           return false;
; 471  :         for (int i=0; i < num_samples; i++)
; 472  :           buffer[i] = buf32[first_idx+i].ival;
; 473  :         return true;
; 474  :       }
; 475  :     bool set_ints(kdu_int32 *buffer, int first_idx, int num_samples)
; 476  :       {
; 477  :       /* [SYNOPSIS]
; 478  :            Returns false if the object does not hold a 32-bit absolute
; 479  :            (integer) sample representation.  Otherwise, returns true
; 480  :            and copies the integer samples from the supplied `buffer'.
; 481  :            The first sample in `buffer' is stored `first_idx' positions from
; 482  :            the start of the line.  There may be little or no checking that
; 483  :            the sample range represented by `first_idx' and `num_samples' is
; 484  :            legal, so be careful.
; 485  :            [//]
; 486  :            For native C/C++ interfacing, it is more efficient to explicitly
; 487  :            access the internal buffer using `get_buf32'.
; 488  :       */
; 489  :         if ((flags & KD_LINE_BUF_SHORTS) || !(flags & KD_LINE_BUF_ABSOLUTE))
; 490  :           return false;
; 491  :         for (int i=0; i < num_samples; i++)
; 492  :           buf32[i+first_idx].ival = buffer[i];
; 493  :         return true;
; 494  :       }
; 495  :     bool get_ints(kdu_int16 *buffer, int first_idx, int num_samples)
; 496  :       {
; 497  :       /* [SYNOPSIS]
; 498  :            Returns false if the object does not hold a 16-bit sample
; 499  :            representation (either fixed point or absolute integers).
; 500  :            Otherwise, returns true and copies the 16-bit samples into the
; 501  :            supplied `buffer'.  The first copied sample is `first_idx'
; 502  :            positions from the start of the line.  There may be little or no
; 503  :            checking that the sample range represented by `first_idx' and
; 504  :            `num_samples' is legal, so be careful.
; 505  :            [//]
; 506  :            For native C/C++ interfacing, it is more efficient to explicitly
; 507  :            access the internal buffer using `get_buf16'.
; 508  :       */
; 509  :         if (!(flags & KD_LINE_BUF_SHORTS))
; 510  :           return false;
; 511  :         for (int i=0; i < num_samples; i++)
; 512  :           buffer[i] = buf16[first_idx+i].ival;
; 513  :         return true;
; 514  :       }
; 515  :     bool set_ints(kdu_int16 *buffer, int first_idx, int num_samples)
; 516  :       {
; 517  :       /* [SYNOPSIS]
; 518  :            Returns false if the object does not hold a 16-bit sample
; 519  :            representation (either fixed point or absolute integers).
; 520  :            Otherwise, returns true and copies the integer samples from the
; 521  :            supplied `buffer'.  The first sample in `buffer' is stored
; 522  :            `first_idx' positions from the start of the line.  There may be
; 523  :            little or no checking that the sample range represented by
; 524  :            `first_idx' and `num_samples' is legal, so be careful.
; 525  :            [//]
; 526  :            For native C/C++ interfacing, it is more efficient to explicitly
; 527  :            access the internal buffer using `get_buf16'.
; 528  :       */
; 529  :         if (!(flags & KD_LINE_BUF_SHORTS))
; 530  :           return false;
; 531  :         for (int i=0; i < num_samples; i++)
; 532  :           buf16[i+first_idx].ival = buffer[i];
; 533  :         return true;
; 534  :       }
; 535  :     int get_width()
; 536  :       {
; 537  :       /* [SYNOPSIS]
; 538  :            Returns 0 if the object has not been created.  Otherwise, returns
; 539  :            the nominal width of the line.  Remember that the arrays returned
; 540  :            by `get_buf16' and `get_buf32' are typically larger than the actual
; 541  :            line width, as explained in the comments appearing with the
; 542  :            `pre_create' function.
; 543  :       */
; 544  :         return width;

	mov	ebx, DWORD PTR [edi]
	mov	DWORD PTR _width$1$[ebp], ebx

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	jne	$LN29@perform_tr
	mov	esi, DWORD PTR [edi+8]
	mov	DWORD PTR _dst$1$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1840 :       if (line->line.get_buf32() != NULL)

	test	esi, esi
	je	$LN29@perform_tr

; 1841 :         { // Floating point implementation
; 1842 :           float factor = line->irrev_offset;

	movss	xmm0, DWORD PTR [edi+44]
	movss	DWORD PTR _factor$1[ebp], xmm0

; 1843 :           kdu_sample32 *dst=line->line.get_buf32();
; 1844 :           for (w=0; w < width; w++)

	test	ebx, ebx
	jle	SHORT $LN7@perform_tr
	mov	eax, DWORD PTR _factor$1[ebp]
	mov	ecx, ebx
	mov	edi, esi
	rep stosd
	mov	ecx, DWORD PTR _this$1$[ebp]
$LN7@perform_tr:

; 1845 :             dst[w].fval = factor;
; 1846 :           for (n=0; n < num_dependencies; n++)

	mov	ecx, DWORD PTR [ecx+16]
	xor	eax, eax
	mov	DWORD PTR _n$1$[ebp], eax
	test	ecx, ecx
	jle	$LN2@perform_tr
	mov	edx, DWORD PTR _this$1$[ebp]
	mov	edi, DWORD PTR _m$1$[ebp]
$LL10@perform_tr:

; 1847 :             {
; 1848 :               factor = coefficients[m*num_dependencies+n];

	imul	ecx, edi
	add	ecx, eax
	mov	eax, DWORD PTR [edx+40]
	movss	xmm2, DWORD PTR [eax+ecx*4]

; 1849 :               if ((dependencies[n] == NULL) || (factor == 0.0F))

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR _n$1$[ebp]
	mov	eax, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR [eax+ecx*4]
	test	ecx, ecx
	je	$LN8@perform_tr
	ucomiss	xmm2, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN8@perform_tr
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN55@perform_tr
	xor	edx, edx
	jmp	SHORT $LN56@perform_tr
$LN55@perform_tr:
	mov	edx, DWORD PTR [ecx+8]
$LN56@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1852 :               if (!dependencies[n]->reversible)

	cmp	BYTE PTR [ecx+32], 0
	jne	$LN33@perform_tr

; 1853 :                 for (w=0; w < width; w++)

	xor	edi, edi
	cmp	ebx, 4
	jl	$LC93@perform_tr
	lea	eax, DWORD PTR [esi+4]
	mov	esi, edx
	sub	esi, DWORD PTR _dst$1$[ebp]
	lea	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR tv2069[ebp], esi
	lea	esi, DWORD PTR [ebx-4]
	mov	ebx, DWORD PTR tv2069[ebp]
	shr	esi, 2
	inc	esi
	lea	edi, DWORD PTR [esi*4]
	npad	12
$LL94@perform_tr:

; 1854 :                   dst[w].fval += factor * src[w].fval;

	movss	xmm0, DWORD PTR [ecx-12]
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax-4]
	movss	DWORD PTR [eax-4], xmm0
	movss	xmm0, DWORD PTR [ebx+eax]
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [ecx-4]
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [eax+4], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
	addss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [eax+8], xmm0
	add	eax, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL94@perform_tr
	mov	ebx, DWORD PTR _width$1$[ebp]
	mov	esi, DWORD PTR _dst$1$[ebp]
$LC93@perform_tr:

; 1853 :                 for (w=0; w < width; w++)

	cmp	edi, ebx
	jge	$LN112@perform_tr
	mov	ecx, ebx
	lea	eax, DWORD PTR [esi+edi*4]
	sub	edx, esi
	sub	ecx, edi
	npad	6
$LC13@perform_tr:

; 1854 :                   dst[w].fval += factor * src[w].fval;

	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LC13@perform_tr

; 1855 :               else

	jmp	$LN112@perform_tr
$LN33@perform_tr:

; 1856 :                 { // Need to convert source samples from ints to floats on
; 1857 :                   // the fly.
; 1858 :                   int src_bit_depth = dependencies[n]->bit_depth;

	mov	ecx, DWORD PTR [ecx+36]

; 1859 :                   if (src_bit_depth > 0)

	test	ecx, ecx
	jle	SHORT $LN35@perform_tr

; 1860 :                     factor *= 1.0F / (1<<src_bit_depth);

	mov	eax, 1
	movaps	xmm1, xmm3
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	mulss	xmm2, xmm1
	xorps	xmm1, xmm1
$LN35@perform_tr:

; 1861 :                   for (w=0; w < width; w++)

	xor	edi, edi
	cmp	ebx, 4
	jl	$LC96@perform_tr
	lea	eax, DWORD PTR [esi+4]
	mov	esi, edx
	sub	esi, DWORD PTR _dst$1$[ebp]
	lea	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR tv2067[ebp], esi
	lea	esi, DWORD PTR [ebx-4]
	mov	ebx, DWORD PTR tv2067[ebp]
	shr	esi, 2
	inc	esi
	lea	edi, DWORD PTR [esi*4]
	npad	5
$LL97@perform_tr:

; 1862 :                     dst[w].fval += factor * (float) src[w].ival;

	movd	xmm0, DWORD PTR [ecx-12]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax-4]
	movss	DWORD PTR [eax-4], xmm0
	movd	xmm0, DWORD PTR [eax+ebx]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	movd	xmm0, DWORD PTR [ecx-4]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [eax+4], xmm0
	movd	xmm0, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [eax+8], xmm0
	add	eax, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL97@perform_tr
	mov	ebx, DWORD PTR _width$1$[ebp]
	mov	esi, DWORD PTR _dst$1$[ebp]
$LC96@perform_tr:

; 1861 :                   for (w=0; w < width; w++)

	cmp	edi, ebx
	jge	SHORT $LN112@perform_tr
	mov	ecx, ebx
	lea	eax, DWORD PTR [esi+edi*4]
	sub	edx, esi
	sub	ecx, edi
$LC16@perform_tr:

; 1862 :                     dst[w].fval += factor * (float) src[w].ival;

	movd	xmm0, DWORD PTR [eax+edx]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LC16@perform_tr
$LN112@perform_tr:
	mov	edi, DWORD PTR _m$1$[ebp]
$LN8@perform_tr:

; 1845 :             dst[w].fval = factor;
; 1846 :           for (n=0; n < num_dependencies; n++)

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR _n$1$[ebp]
	inc	eax
	mov	DWORD PTR _n$1$[ebp], eax
	mov	ecx, DWORD PTR [edx+16]
	cmp	eax, ecx
	jl	$LL10@perform_tr

; 1863 :                 }
; 1864 :             }
; 1865 :         }
; 1866 :       else

	jmp	$LN2@perform_tr
$LN29@perform_tr:

; 1867 :         {
; 1868 :           if (short_coefficients == NULL)

	cmp	DWORD PTR [ecx+48], 0
	jne	SHORT $LN36@perform_tr

; 1869 :             create_short_coefficients(width);

	push	ebx
	call	?create_short_coefficients@kd_multi_matrix_block@@AAEXH@Z ; kd_multi_matrix_block::create_short_coefficients
	mov	ecx, DWORD PTR _this$1$[ebp]
$LN36@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [edi+6], 2
	je	SHORT $LN59@perform_tr
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR _dst$1$[ebp], eax
	jmp	SHORT $LN60@perform_tr
$LN59@perform_tr:
	mov	DWORD PTR _dst$1$[ebp], 0
$LN60@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1871 :           kdu_int32 offset, *acc = short_accumulator;

	mov	esi, DWORD PTR [ecx+52]

; 1872 :           memset(acc,0,(size_t)(width<<2));

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	push	0
	push	esi
	call	_memset

; 1873 :           for (n=0; n < num_dependencies; n++)

	mov	edx, DWORD PTR _this$1$[ebp]
	xor	eax, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _n$2$[ebp], eax
	mov	ecx, DWORD PTR [edx+16]
	test	ecx, ecx
	jle	$LN18@perform_tr
	mov	edi, DWORD PTR _m$1$[ebp]
	npad	4
$LL19@perform_tr:

; 1874 :             {
; 1875 :               kdu_int16 factor = short_coefficients[m*num_dependencies+n];

	imul	ecx, edi
	add	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	movzx	edx, WORD PTR [eax+ecx*2]

; 1876 :               if ((dependencies[n] == NULL) || (factor == 0))

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR _n$2$[ebp]
	mov	DWORD PTR _factor$1$[ebp], edx
	mov	eax, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR [eax+ecx*4]
	test	ecx, ecx
	je	$LN17@perform_tr
	test	dx, dx
	je	$LN17@perform_tr
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN63@perform_tr
	mov	eax, DWORD PTR [ecx+8]
	jmp	SHORT $LN114@perform_tr
$LN63@perform_tr:
	xor	eax, eax
$LN114@perform_tr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1879 :               if (!dependencies[n]->reversible)

	cmp	BYTE PTR [ecx+32], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	mov	DWORD PTR _src$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1879 :               if (!dependencies[n]->reversible)

	jne	SHORT $LN39@perform_tr

; 1880 :                 for (w=0; w < width; w++)

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN17@perform_tr
	movsx	edx, dx
	npad	5
$LL22@perform_tr:

; 1881 :                   acc[w] += ((kdu_int32) src[w].ival) * factor;

	movsx	eax, WORD PTR [eax+ecx*2]
	imul	eax, edx
	add	DWORD PTR [esi+ecx*4], eax
	inc	ecx
	mov	eax, DWORD PTR _src$1$[ebp]
	cmp	ecx, ebx
	jl	SHORT $LL22@perform_tr

; 1882 :               else

	jmp	SHORT $LN17@perform_tr
$LN39@perform_tr:

; 1883 :                 { // Need to convert source samples from reversible short ints
; 1884 :                   // to fixed-point short ints on the fly.
; 1885 :                   int src_bit_depth = dependencies[n]->bit_depth;
; 1886 :                   assert(src_bit_depth > 0); // Else should be using 32-bits
; 1887 :                   int upshift = KDU_FIX_POINT - src_bit_depth;

	mov	edi, 13					; 0000000dH
	sub	edi, DWORD PTR [ecx+36]

; 1888 :                   if (upshift < 0)

	jns	SHORT $LN41@perform_tr

; 1889 :                     { // This case is actually extremely unlikely, since high
; 1890 :                       // bit-depth reversible data will generally be
; 1891 :                       // represented using 32-bit integers, not shorts.  For
; 1892 :                       // this reason, we don't worry about accuracy; just
; 1893 :                       // scale down the value of `factor'
; 1894 :                       factor = (factor + (1<<(-upshift-1))) >> (-upshift);

	mov	eax, DWORD PTR _factor$1$[ebp]
	neg	edi
	mov	edx, 1
	cwde
	lea	ecx, DWORD PTR [edi-1]
	shl	edx, cl
	mov	ecx, edi
	add	edx, eax
	sar	edx, cl

; 1895 :                       upshift=0;

	xor	edi, edi
	movzx	eax, dx
	mov	DWORD PTR _factor$1$[ebp], eax
$LN41@perform_tr:

; 1896 :                     }
; 1897 :                   for (w=0; w < width; w++)

	xor	edx, edx
	test	ebx, ebx
	jle	SHORT $LN113@perform_tr
$LL25@perform_tr:

; 1898 :                     acc[w] += (((kdu_int32) src[w].ival)<<upshift) * factor;

	mov	eax, DWORD PTR _src$1$[ebp]
	mov	ecx, edi
	mov	ebx, DWORD PTR _factor$1$[ebp]
	movsx	eax, WORD PTR [eax+edx*2]
	shl	eax, cl
	movsx	ecx, bx
	mov	ebx, DWORD PTR _width$1$[ebp]
	imul	eax, ecx
	add	DWORD PTR [esi+edx*4], eax
	inc	edx
	cmp	edx, ebx
	jl	SHORT $LL25@perform_tr
$LN113@perform_tr:
	mov	edi, DWORD PTR _m$1$[ebp]
$LN17@perform_tr:

; 1873 :           for (n=0; n < num_dependencies; n++)

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR _n$2$[ebp]
	inc	eax
	mov	DWORD PTR _n$2$[ebp], eax
	mov	ecx, DWORD PTR [edx+16]
	cmp	eax, ecx
	jl	$LL19@perform_tr
	mov	edi, DWORD PTR _line$1$[ebp]
$LN18@perform_tr:

; 1899 :                 }
; 1900 :             }
; 1901 :           kdu_int32 downshift = this->short_downshift;
; 1902 :           offset = (kdu_int32)

	movss	xmm0, DWORD PTR [edi+44]
	sub	esp, 8
	mulss	xmm0, DWORD PTR __real@46000000
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR _downshift$1$[ebp], eax
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv2115[ebp], xmm0
	fld	QWORD PTR tv2115[ebp]
	fstp	QWORD PTR [esp]
	call	_floor

; 1903 :             floor(0.5 + line->irrev_offset * (1<<KDU_FIX_POINT));
; 1904 :           offset <<= downshift;

	mov	ecx, DWORD PTR _downshift$1$[ebp]

; 1905 :           offset += (1 << downshift) >> 1;

	mov	eax, 1
	fstp	QWORD PTR tv2104[ebp]
	cvttsd2si edi, QWORD PTR tv2104[ebp]
	shl	eax, cl
	add	esp, 8
	sar	eax, 1

; 1906 :           for (w=0; w < width; w++)

	xor	edx, edx
	shl	edi, cl
	add	edi, eax
	test	ebx, ebx
	jle	SHORT $LN109@perform_tr
	npad	2
$LL28@perform_tr:

; 1907 :             dst[w].ival = (kdu_int16)((acc[w]+offset) >> downshift);

	mov	eax, DWORD PTR [esi+edx*4]
	mov	ebx, DWORD PTR _dst$1$[ebp]
	add	eax, edi
	sar	eax, cl
	mov	WORD PTR [ebx+edx*2], ax
	inc	edx
	cmp	edx, DWORD PTR _width$1$[ebp]
	jl	SHORT $LL28@perform_tr
$LN109@perform_tr:
	movss	xmm3, DWORD PTR __real@3f800000
$LN2@perform_tr:

; 1835 :   int m, n;
; 1836 :   for (m=0; m < num_components; m++)

	mov	eax, DWORD PTR _m$1$[ebp]
	xorps	xmm1, xmm1
	mov	ecx, DWORD PTR _this$1$[ebp]
	inc	eax
	mov	ebx, DWORD PTR tv2052[ebp]
	add	ebx, 60					; 0000003cH
	mov	DWORD PTR _m$1$[ebp], eax
	mov	DWORD PTR tv2052[ebp], ebx
	cmp	eax, DWORD PTR [ecx+8]
	jl	$LL4@perform_tr
	pop	edi
	pop	esi
	pop	ebx
$LN3@perform_tr:

; 1908 :         }
; 1909 :     }
; 1910 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?perform_transform@kd_multi_matrix_block@@UAEXXZ ENDP	; kd_multi_matrix_block::perform_transform
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?normalize_coefficients@kd_multi_matrix_block@@UAEXXZ
_TEXT	SEGMENT
tv366 = -12						; size = 4
tv362 = -8						; size = 4
tv339 = -4						; size = 4
?normalize_coefficients@kd_multi_matrix_block@@UAEXXZ PROC ; kd_multi_matrix_block::normalize_coefficients, COMDAT
; _this$ = ecx

; 1785 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 1786 :   int n, m;
; 1787 :   bool need_precise=false;

	xor	cl, cl
	push	edi

; 1788 : 
; 1789 :   for (n=0; n < num_dependencies; n++)

	xor	edi, edi
	lea	ebx, DWORD PTR [edi+1]
	cmp	DWORD PTR [esi+16], edi
	jle	SHORT $LN3@normalize_
$LL4@normalize_:

; 1790 :     {
; 1791 :       kd_multi_line *line = dependencies[n];

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax+edi*4]

; 1792 :       if (line == NULL)

	test	eax, eax
	je	SHORT $LN2@normalize_

; 1793 :         continue;
; 1794 :       assert(!line->is_constant);
; 1795 :       if (line->bit_depth == 0)

	mov	edx, DWORD PTR [eax+36]
	test	edx, edx
	jne	SHORT $LN21@normalize_

; 1796 :         { // Unknown dynamic range; can't chance fixed-point overflow
; 1797 :           need_precise = true;  continue;

	mov	cl, bl
	jmp	SHORT $LN2@normalize_
$LN21@normalize_:

; 1798 :         }
; 1799 :       if (line->need_precise)

	cmp	BYTE PTR [eax+34], 0

; 1800 :         need_precise = true;
; 1801 :       float factor = (float)(1 << line->bit_depth);

	mov	eax, ebx
	movzx	ecx, cl
	cmovne	ecx, ebx
	mov	DWORD PTR tv339[ebp], ecx
	mov	ecx, edx
	shl	eax, cl

; 1802 :       for (m=0; m < num_components; m++)

	xor	edx, edx
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	cmp	DWORD PTR [esi+8], edx
	jle	SHORT $LN53@normalize_
	npad	3
$LL7@normalize_:

; 1803 :         coefficients[m*num_dependencies+n] *= factor;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+40]
	imul	ecx, edx
	inc	edx
	add	ecx, edi
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax+ecx*4], xmm0
	cmp	edx, DWORD PTR [esi+8]
	jl	SHORT $LL7@normalize_
$LN53@normalize_:
	mov	ecx, DWORD PTR tv339[ebp]
$LN2@normalize_:

; 1788 : 
; 1789 :   for (n=0; n < num_dependencies; n++)

	inc	edi
	cmp	edi, DWORD PTR [esi+16]
	jl	SHORT $LL4@normalize_
$LN3@normalize_:

; 1804 :     }
; 1805 :   for (m=0; m < num_components; m++)

	xor	edi, edi
	cmp	DWORD PTR [esi+8], edi
	jle	$LN9@normalize_
	mov	ebx, DWORD PTR [esi+16]
	xor	edx, edx
	movss	xmm2, DWORD PTR __real@3f800000
	mov	DWORD PTR tv362[ebp], edx
$LL10@normalize_:

; 1806 :     {
; 1807 :       kd_multi_line *line = components + m;

	mov	eax, DWORD PTR [esi+12]
	add	eax, edx

; 1808 :       if (line->bit_depth == 0)

	mov	edx, DWORD PTR [eax+36]
	test	edx, edx
	mov	DWORD PTR tv366[ebp], edx
	mov	edx, DWORD PTR tv362[ebp]
	jne	SHORT $LN23@normalize_

; 1809 :         { // Unknown dynamic range; can't chance fixed-point overflow
; 1810 :           need_precise = true;  continue;

	mov	cl, 1
	jmp	SHORT $LN8@normalize_
$LN23@normalize_:

; 1811 :         }
; 1812 :       if (line->need_precise)

	mov	dl, BYTE PTR [eax+34]

; 1813 :         need_precise = line->need_precise;
; 1814 :       float factor = 1.0F / (float)(1 << line->bit_depth);

	movaps	xmm1, xmm2
	test	dl, dl
	movzx	eax, dl
	movzx	ecx, cl
	cmovne	ecx, eax
	mov	eax, 1
	mov	BYTE PTR tv339[ebp], cl

; 1815 :       for (n=0; n < num_dependencies; n++)

	xor	edx, edx
	mov	ecx, DWORD PTR tv366[ebp]
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	test	ebx, ebx
	jle	SHORT $LN52@normalize_
	npad	8
$LL13@normalize_:

; 1816 :         coefficients[m*num_dependencies+n] *= factor;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+40]
	imul	ecx, edi
	add	ecx, edx
	inc	edx
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax+ecx*4], xmm0
	mov	ebx, DWORD PTR [esi+16]
	cmp	edx, ebx
	jl	SHORT $LL13@normalize_
$LN52@normalize_:
	mov	edx, DWORD PTR tv362[ebp]
	mov	ecx, DWORD PTR tv339[ebp]
$LN8@normalize_:

; 1804 :     }
; 1805 :   for (m=0; m < num_components; m++)

	inc	edi
	add	edx, 60					; 0000003cH
	mov	DWORD PTR tv362[ebp], edx
	cmp	edi, DWORD PTR [esi+8]
	jl	SHORT $LL10@normalize_
$LN9@normalize_:

; 1817 :     }
; 1818 :   if (need_precise)

	test	cl, cl
	je	SHORT $LN18@normalize_

; 1819 :     {
; 1820 :       for (n=0; n < num_dependencies; n++)

	xor	ecx, ecx
	cmp	DWORD PTR [esi+16], ecx
	jle	SHORT $LN15@normalize_
	npad	2
$LL16@normalize_:

; 1821 :         if (dependencies[n] != NULL)

	mov	eax, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	je	SHORT $LN14@normalize_

; 1822 :           dependencies[n]->need_precise = true;

	mov	BYTE PTR [eax+34], 1
$LN14@normalize_:

; 1819 :     {
; 1820 :       for (n=0; n < num_dependencies; n++)

	inc	ecx
	cmp	ecx, DWORD PTR [esi+16]
	jl	SHORT $LL16@normalize_
$LN15@normalize_:

; 1823 :       for (m=0; m < num_components; m++)

	xor	ecx, ecx
	cmp	DWORD PTR [esi+8], ecx
	jle	SHORT $LN18@normalize_
	xor	edx, edx
	npad	3
$LL19@normalize_:

; 1824 :         components[m].need_precise = true;

	mov	eax, DWORD PTR [esi+12]
	lea	edx, DWORD PTR [edx+60]
	inc	ecx
	mov	BYTE PTR [eax+edx-26], 1
	cmp	ecx, DWORD PTR [esi+8]
	jl	SHORT $LL19@normalize_
$LN18@normalize_:
	pop	edi
	pop	esi
	pop	ebx

; 1825 :     }
; 1826 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?normalize_coefficients@kd_multi_matrix_block@@UAEXXZ ENDP ; kd_multi_matrix_block::normalize_coefficients
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?initialize@kd_multi_matrix_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -20						; size = 4
_num_stage_inputs$ = -16				; size = 4
_num_stage_outputs$ = -12				; size = 4
_irrev_offsets$1$ = -8					; size = 4
_input_indices$1$ = -4					; size = 4
_stage_idx$ = 8						; size = 4
tv1021 = 12						; size = 4
_n$3$ = 12						; size = 4
_block_idx$ = 12					; size = 4
_tile$ = 16						; size = 4
_num_block_inputs$ = 20					; size = 4
_num_block_outputs$ = 24				; size = 4
_input_collection$ = 28					; size = 4
_output_collection$ = 32				; size = 4
_output_indices$1$ = 36					; size = 4
_owner$ = 36						; size = 4
?initialize@kd_multi_matrix_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z PROC ; kd_multi_matrix_block::initialize, COMDAT
; _this$ = ecx

; 1724 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1725 :   int *scratch =
; 1726 :     owner->get_scratch_ints(num_block_inputs+num_block_outputs);

	mov	eax, DWORD PTR _num_block_inputs$[ebp]
	add	eax, DWORD PTR _num_block_outputs$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _owner$[ebp]
	push	edi
	mov	edi, ecx
	mov	ecx, esi
	push	eax
	call	?get_scratch_ints@kd_multi_transform@@QAEPAHH@Z ; kd_multi_transform::get_scratch_ints

; 1727 :   int *input_indices = scratch;
; 1728 :   int *output_indices = input_indices + num_block_inputs;

	mov	edx, DWORD PTR _num_block_inputs$[ebp]

; 1729 :   float *irrev_offsets = owner->get_scratch_floats(num_block_outputs);

	mov	ecx, esi
	push	DWORD PTR _num_block_outputs$[ebp]
	mov	DWORD PTR _input_indices$1$[ebp], eax
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _output_indices$1$[ebp], eax
	call	?get_scratch_floats@kd_multi_transform@@QAEPAMH@Z ; kd_multi_transform::get_scratch_floats

; 1730 :   int n, num_stage_inputs, num_stage_outputs;
; 1731 :   tile.get_mct_block_info(stage_idx,block_idx,num_stage_inputs,

	push	0
	push	0
	mov	ebx, eax
	lea	ecx, DWORD PTR _tile$[ebp]
	push	ebx
	push	DWORD PTR _output_indices$1$[ebp]
	lea	eax, DWORD PTR _num_block_outputs$[ebp]
	mov	DWORD PTR _irrev_offsets$1$[ebp], ebx
	push	DWORD PTR _input_indices$1$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_block_inputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_outputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_inputs$[ebp]
	push	eax
	push	DWORD PTR _block_idx$[ebp]
	push	DWORD PTR _stage_idx$[ebp]
	call	?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z ; kdu_tile::get_mct_block_info

; 1732 :                           num_stage_outputs,num_block_inputs,num_block_outputs,
; 1733 :                           input_indices,output_indices,irrev_offsets,NULL);
; 1734 :   assert((num_stage_inputs == input_collection->num_components) &&
; 1735 :          (num_stage_outputs == output_collection->num_components));
; 1736 : 
; 1737 :   num_components = num_block_outputs;

	mov	esi, DWORD PTR _num_block_outputs$[ebp]

; 1738 :   components = new kd_multi_line[num_components];

	xor	ecx, ecx
	mov	eax, esi
	mov	DWORD PTR [edi+8], esi
	mov	edx, 60					; 0000003cH
	mov	DWORD PTR $T2[ebp], esi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	$LN17@initialize
	test	esi, esi
	je	$LN18@initialize
	lea	ecx, DWORD PTR [eax+6]
	npad	6
$LL21@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx-6], 0
	lea	ecx, DWORD PTR [ecx+60]
	mov	WORD PTR [ecx-60], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx-58], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx-54], 0
	mov	DWORD PTR [ecx-50], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 87   :         row_idx = -1;  num_consumers = outstanding_consumers = 0;

	mov	DWORD PTR [ecx-46], -1
	mov	DWORD PTR [ecx-38], 0
	mov	DWORD PTR [ecx-42], 0

; 88   :         reversible = need_irreversible = need_precise = is_constant = false;

	mov	DWORD PTR [ecx-34], 0

; 89   :         bit_depth = 0;  rev_offset = 0;  irrev_offset = 0.0F;

	mov	DWORD PTR [ecx-30], 0
	mov	DWORD PTR [ecx-26], 0
	mov	DWORD PTR [ecx-22], 0

; 90   :         bypass=NULL;  block=NULL;  collection_idx = -1;

	mov	DWORD PTR [ecx-18], 0
	mov	DWORD PTR [ecx-14], 0
	mov	DWORD PTR [ecx-10], -1
	sub	esi, 1
	jne	SHORT $LL21@initialize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1738 :   components = new kd_multi_line[num_components];

	jmp	SHORT $LN18@initialize
$LN17@initialize:
	xor	eax, eax
$LN18@initialize:
	mov	DWORD PTR [edi+12], eax

; 1739 :   num_dependencies = num_block_inputs;
; 1740 :   dependencies = new kd_multi_line *[num_dependencies];

	xor	ecx, ecx
	mov	eax, DWORD PTR _num_block_inputs$[ebp]
	mov	esi, 4
	mov	DWORD PTR [edi+16], eax
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+20], eax

; 1741 : 
; 1742 :   coefficients = new float[num_block_inputs*num_block_outputs];

	xor	ecx, ecx
	mov	eax, DWORD PTR _num_block_inputs$[ebp]
	imul	eax, DWORD PTR _num_block_outputs$[ebp]
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 8
	mov	DWORD PTR [edi+40], eax

; 1743 :   tile.get_mct_matrix_info(stage_idx,block_idx,coefficients);

	lea	ecx, DWORD PTR _tile$[ebp]
	push	eax
	push	DWORD PTR _block_idx$[ebp]
	push	DWORD PTR _stage_idx$[ebp]
	call	?get_mct_matrix_info@kdu_tile@@QAE_NHHPAM@Z ; kdu_tile::get_mct_matrix_info

; 1744 : 
; 1745 :   for (n=0; n < num_dependencies; n++)

	xor	esi, esi
	cmp	DWORD PTR [edi+16], esi
	jle	SHORT $LN3@initialize
	mov	ebx, DWORD PTR _input_collection$[ebp]
	npad	3
$LL4@initialize:

; 1746 :     {
; 1747 :       dependencies[n] = input_collection->components[input_indices[n]];

	mov	eax, DWORD PTR _input_indices$1$[ebp]
	mov	ecx, DWORD PTR [edi+20]
	mov	edx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+esi*4], eax

; 1748 :       if (dependencies[n] == NULL)

	mov	eax, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, eax
	je	SHORT $LN2@initialize

; 1749 :         continue;
; 1750 :       dependencies[n]->num_consumers++;

	inc	DWORD PTR [eax+24]
$LN2@initialize:

; 1744 : 
; 1745 :   for (n=0; n < num_dependencies; n++)

	inc	esi
	cmp	esi, DWORD PTR [edi+16]
	jl	SHORT $LL4@initialize
	mov	ebx, DWORD PTR _irrev_offsets$1$[ebp]
$LN3@initialize:

; 1751 :     }
; 1752 : 
; 1753 :   for (n=0; n < num_components; n++)

	xor	esi, esi
	cmp	DWORD PTR [edi+8], esi
	jle	SHORT $LN6@initialize
	mov	ecx, DWORD PTR _output_indices$1$[ebp]
	xor	eax, eax
	sub	ecx, ebx
	mov	DWORD PTR tv1021[ebp], eax
	mov	DWORD PTR _output_indices$1$[ebp], ecx
	npad	4
$LL7@initialize:

; 1754 :     {
; 1755 :       kd_multi_line *line = components + n;

	mov	edx, DWORD PTR [edi+12]
	lea	ebx, DWORD PTR [ebx+4]
	add	edx, eax

; 1756 :       line->block = this;
; 1757 :       output_collection->components[output_indices[n]] = line;

	mov	eax, DWORD PTR _output_collection$[ebp]
	inc	esi
	mov	DWORD PTR [edx+52], edi
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ebx+ecx-4]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	ecx, DWORD PTR _output_indices$1$[ebp]

; 1758 :       line->need_irreversible = true;

	mov	BYTE PTR [edx+33], 1

; 1759 :       line->irrev_offset = irrev_offsets[n];

	mov	eax, DWORD PTR [ebx-4]
	mov	DWORD PTR [edx+44], eax
	mov	eax, DWORD PTR tv1021[ebp]
	add	eax, 60					; 0000003cH
	mov	DWORD PTR tv1021[ebp], eax
	cmp	esi, DWORD PTR [edi+8]
	jl	SHORT $LL7@initialize
$LN6@initialize:

; 1760 :     }
; 1761 : 
; 1762 :   // Before returning, see if we can pre-compute the impact of any constant
; 1763 :   // input lines.
; 1764 :   for (n=0; n < num_dependencies; n++)

	xor	ecx, ecx
	mov	DWORD PTR _n$3$[ebp], ecx
	cmp	DWORD PTR [edi+16], ecx
	jle	SHORT $LN9@initialize
	npad	2
$LL10@initialize:

; 1765 :     if (dependencies[n]->is_constant)

	mov	eax, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	BYTE PTR [eax+35], 0
	je	SHORT $LN8@initialize

; 1766 :       {
; 1767 :         int m;
; 1768 :         float off = dependencies[n]->irrev_offset;

	movss	xmm1, DWORD PTR [eax+44]

; 1769 :         for (m=0; m < num_components; m++)

	xor	esi, esi
	cmp	DWORD PTR [edi+8], esi
	jle	SHORT $LN12@initialize

; 1766 :       {
; 1767 :         int m;
; 1768 :         float off = dependencies[n]->irrev_offset;

	xor	ebx, ebx
	npad	6
$LL13@initialize:

; 1770 :           {
; 1771 :             kd_multi_line *line = components + m;
; 1772 :             line->irrev_offset += off * coefficients[m*num_dependencies+n];

	mov	ecx, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [edi+40]
	mov	edx, DWORD PTR [edi+12]
	imul	ecx, esi
	inc	esi
	add	ecx, DWORD PTR _n$3$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [edx+ebx+44]
	movss	DWORD PTR [edx+ebx+44], xmm0
	add	ebx, 60					; 0000003cH
	cmp	esi, DWORD PTR [edi+8]
	jl	SHORT $LL13@initialize
	mov	ecx, DWORD PTR _n$3$[ebp]
$LN12@initialize:

; 1773 :           }
; 1774 :         dependencies[n]->num_consumers--;

	mov	eax, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	dec	DWORD PTR [eax+24]

; 1775 :         dependencies[n] = NULL;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [eax+ecx*4], 0
$LN8@initialize:

; 1760 :     }
; 1761 : 
; 1762 :   // Before returning, see if we can pre-compute the impact of any constant
; 1763 :   // input lines.
; 1764 :   for (n=0; n < num_dependencies; n++)

	inc	ecx
	mov	DWORD PTR _n$3$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+16]
	jl	SHORT $LL10@initialize
$LN9@initialize:
	pop	edi
	pop	esi
	pop	ebx

; 1776 :       }
; 1777 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?initialize@kd_multi_matrix_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z ENDP ; kd_multi_matrix_block::initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??1kd_multi_matrix_block@@UAE@XZ
_TEXT	SEGMENT
??1kd_multi_matrix_block@@UAE@XZ PROC			; kd_multi_matrix_block::~kd_multi_matrix_block, COMDAT
; _this$ = ecx

; 380  :       {

	push	esi
	mov	esi, ecx

; 381  :         if (coefficients != NULL) delete[] coefficients;

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_matrix_block@@6B@
	test	eax, eax
	je	SHORT $LN2@kd_multi_m
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_multi_m:

; 382  :         if (inverse_coefficients != NULL) delete[] inverse_coefficients;

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	je	SHORT $LN3@kd_multi_m
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@kd_multi_m:

; 383  :         if (short_coefficients != NULL) delete[] short_coefficients;

	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN4@kd_multi_m
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN4@kd_multi_m:

; 384  :         if (short_accumulator != NULL) delete[] short_accumulator;

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN5@kd_multi_m
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@kd_multi_m:

; 385  :         if (work != NULL) delete[] work;

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN6@kd_multi_m
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@kd_multi_m:

; 199  :         if (components != NULL) delete[] components;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_block@@6B@
	test	eax, eax
	je	SHORT $LN9@kd_multi_m
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN9@kd_multi_m:

; 200  :         if (dependencies != NULL) delete[] dependencies;

	mov	eax, DWORD PTR [esi+20]
	pop	esi
	test	eax, eax
	je	SHORT $LN10@kd_multi_m
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN10@kd_multi_m:

; 386  :       }

	ret	0
??1kd_multi_matrix_block@@UAE@XZ ENDP			; kd_multi_matrix_block::~kd_multi_matrix_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??0kd_multi_matrix_block@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0kd_multi_matrix_block@@QAE@XZ PROC			; kd_multi_matrix_block::kd_multi_matrix_block, COMDAT
; _this$ = ecx

; 373  :     kd_multi_matrix_block()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 378  :       }

	mov	eax, ecx

; 193  :         num_components = 0;  components = NULL;  next = prev = NULL;

	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+32], 0

; 194  :         num_dependencies = num_available_dependencies = 0; dependencies = NULL;

	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0

; 195  :         outstanding_consumers = 0;

	mov	DWORD PTR [ecx+28], 0

; 374  :       {

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_matrix_block@@6B@

; 375  :         is_null_transform = false;

	mov	BYTE PTR [ecx+4], 0

; 376  :         coefficients = inverse_coefficients = NULL;

	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+40], 0

; 377  :         short_coefficients = NULL;  short_accumulator = NULL;  work = NULL;

	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+60], 0

; 378  :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??0kd_multi_matrix_block@@QAE@XZ ENDP			; kd_multi_matrix_block::kd_multi_matrix_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??_Gkd_multi_null_block@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_multi_null_block@@UAEPAXI@Z PROC			; kd_multi_null_block::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 199  :         if (components != NULL) delete[] components;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_block@@6B@
	test	eax, eax
	je	SHORT $LN8@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@scalar:

; 200  :         if (dependencies != NULL) delete[] dependencies;

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN9@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN9@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN12@scalar
	push	40					; 00000028H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_multi_null_block@@UAEPAXI@Z ENDP			; kd_multi_null_block::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??1kd_multi_null_block@@UAE@XZ
_TEXT	SEGMENT
??1kd_multi_null_block@@UAE@XZ PROC			; kd_multi_null_block::~kd_multi_null_block, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx

; 199  :         if (components != NULL) delete[] components;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_block@@6B@
	test	eax, eax
	je	SHORT $LN4@kd_multi_n
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN4@kd_multi_n:

; 200  :         if (dependencies != NULL) delete[] dependencies;

	mov	eax, DWORD PTR [esi+20]
	pop	esi
	test	eax, eax
	je	SHORT $LN5@kd_multi_n
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN5@kd_multi_n:
	ret	0
??1kd_multi_null_block@@UAE@XZ ENDP			; kd_multi_null_block::~kd_multi_null_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?initialize@kd_multi_null_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z
_TEXT	SEGMENT
_num_stage_inputs$ = -20				; size = 4
_num_stage_outputs$ = -16				; size = 4
_rev_offsets$1$ = -12					; size = 4
_input_indices$1$ = -8					; size = 4
_irrev_offsets$1$ = -4					; size = 4
_stage_idx$ = 8						; size = 4
tv946 = 12						; size = 4
$T1 = 12						; size = 4
$T2 = 12						; size = 4
_block_idx$ = 12					; size = 4
_tile$ = 16						; size = 4
_num_block_inputs$ = 20					; size = 4
_num_block_outputs$ = 24				; size = 4
_input_collection$ = 28					; size = 4
_output_collection$ = 32				; size = 4
_output_indices$1$ = 36					; size = 4
_owner$ = 36						; size = 4
?initialize@kd_multi_null_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z PROC ; kd_multi_null_block::initialize, COMDAT
; _this$ = ecx

; 1658 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1659 :   int *scratch =
; 1660 :     owner->get_scratch_ints(num_block_inputs+2*num_block_outputs);

	mov	edx, DWORD PTR _num_block_outputs$[ebp]
	mov	eax, DWORD PTR _num_block_inputs$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _owner$[ebp]
	push	edi
	lea	eax, DWORD PTR [eax+edx*2]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	call	?get_scratch_ints@kd_multi_transform@@QAEPAHH@Z ; kd_multi_transform::get_scratch_ints

; 1661 :   int *input_indices = scratch;
; 1662 :   int *output_indices = input_indices + num_block_inputs;

	mov	edx, DWORD PTR _num_block_inputs$[ebp]

; 1663 :   int *rev_offsets = output_indices + num_block_outputs;
; 1664 :   float *irrev_offsets = owner->get_scratch_floats(num_block_outputs);

	mov	ecx, esi
	mov	DWORD PTR _input_indices$1$[ebp], eax
	lea	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _num_block_outputs$[ebp]
	push	edx
	mov	DWORD PTR _output_indices$1$[ebp], eax
	lea	ebx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _rev_offsets$1$[ebp], ebx
	call	?get_scratch_floats@kd_multi_transform@@QAEPAMH@Z ; kd_multi_transform::get_scratch_floats

; 1665 :   int n, num_stage_inputs, num_stage_outputs;
; 1666 :   tile.get_mct_block_info(stage_idx,block_idx,num_stage_inputs,

	push	0
	push	ebx
	push	eax
	push	DWORD PTR _output_indices$1$[ebp]
	mov	DWORD PTR _irrev_offsets$1$[ebp], eax
	lea	ecx, DWORD PTR _tile$[ebp]
	push	DWORD PTR _input_indices$1$[ebp]
	lea	eax, DWORD PTR _num_block_outputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_block_inputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_outputs$[ebp]
	push	eax
	lea	eax, DWORD PTR _num_stage_inputs$[ebp]
	push	eax
	push	DWORD PTR _block_idx$[ebp]
	push	DWORD PTR _stage_idx$[ebp]
	call	?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z ; kdu_tile::get_mct_block_info

; 1667 :                           num_stage_outputs,num_block_inputs,num_block_outputs,
; 1668 :                           input_indices,output_indices,irrev_offsets,
; 1669 :                           rev_offsets);
; 1670 :   assert((num_stage_inputs == input_collection->num_components) &&
; 1671 :          (num_stage_outputs == output_collection->num_components));
; 1672 : 
; 1673 :   num_components = num_block_outputs;

	mov	esi, DWORD PTR _num_block_outputs$[ebp]

; 1674 :   components = new kd_multi_line[num_components];

	xor	ecx, ecx
	mov	eax, esi
	mov	DWORD PTR [edi+8], esi
	mov	edx, 60					; 0000003cH
	mov	DWORD PTR $T2[ebp], esi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	$LN14@initialize
	test	esi, esi
	je	SHORT $LN15@initialize
	lea	ecx, DWORD PTR [eax+6]
	npad	3
$LL18@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx-6], 0
	lea	ecx, DWORD PTR [ecx+60]
	mov	WORD PTR [ecx-60], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx-58], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx-54], 0
	mov	DWORD PTR [ecx-50], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 87   :         row_idx = -1;  num_consumers = outstanding_consumers = 0;

	mov	DWORD PTR [ecx-46], -1
	mov	DWORD PTR [ecx-38], 0
	mov	DWORD PTR [ecx-42], 0

; 88   :         reversible = need_irreversible = need_precise = is_constant = false;

	mov	DWORD PTR [ecx-34], 0

; 89   :         bit_depth = 0;  rev_offset = 0;  irrev_offset = 0.0F;

	mov	DWORD PTR [ecx-30], 0
	mov	DWORD PTR [ecx-26], 0
	mov	DWORD PTR [ecx-22], 0

; 90   :         bypass=NULL;  block=NULL;  collection_idx = -1;

	mov	DWORD PTR [ecx-18], 0
	mov	DWORD PTR [ecx-14], 0
	mov	DWORD PTR [ecx-10], -1
	sub	esi, 1
	jne	SHORT $LL18@initialize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1674 :   components = new kd_multi_line[num_components];

	jmp	SHORT $LN15@initialize
$LN14@initialize:
	xor	eax, eax
$LN15@initialize:

; 1675 :   num_dependencies = num_block_inputs;

	mov	ecx, DWORD PTR _num_block_inputs$[ebp]

; 1676 :   if (num_dependencies > num_components)
; 1677 :     num_dependencies = num_components; // The rest are just being discarded
; 1678 :   dependencies = new kd_multi_line *[num_dependencies];

	mov	edx, 4
	cmp	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+12], eax
	cmovg	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+16], ecx
	xor	ecx, ecx
	mov	eax, DWORD PTR [edi+16]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 1679 : 
; 1680 :   for (n=0; n < num_dependencies; n++)

	xor	esi, esi
	mov	DWORD PTR [edi+20], eax
	add	esp, 4
	cmp	DWORD PTR [edi+16], esi
	jle	SHORT $LN3@initialize
	mov	ebx, DWORD PTR _input_collection$[ebp]
	npad	3
$LL4@initialize:

; 1681 :     dependencies[n] = input_collection->components[input_indices[n]];

	mov	eax, DWORD PTR _input_indices$1$[ebp]
	mov	ecx, DWORD PTR [edi+20]
	mov	edx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+esi*4], eax
	inc	esi
	cmp	esi, DWORD PTR [edi+16]
	jl	SHORT $LL4@initialize
	mov	ebx, DWORD PTR _rev_offsets$1$[ebp]
$LN3@initialize:

; 1682 :   for (n=0; n < num_components; n++)

	xor	esi, esi
	cmp	DWORD PTR [edi+8], esi
	jle	$LN6@initialize
	mov	ecx, DWORD PTR _output_indices$1$[ebp]
	xor	eax, eax
	sub	ecx, ebx
	mov	DWORD PTR tv946[ebp], eax
	sub	DWORD PTR _irrev_offsets$1$[ebp], ebx
	mov	DWORD PTR _output_indices$1$[ebp], ecx
$LL7@initialize:

; 1683 :     {
; 1684 :       kd_multi_line *line = components + n;

	mov	edx, DWORD PTR [edi+12]
	add	edx, eax

; 1685 :       line->block = this;
; 1686 :       output_collection->components[output_indices[n]] = line;

	mov	eax, DWORD PTR _output_collection$[ebp]
	mov	DWORD PTR [edx+52], edi
	mov	ecx, DWORD PTR [ecx+ebx]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+ecx*4], edx

; 1687 :       if (n >= num_dependencies)

	cmp	esi, DWORD PTR [edi+16]
	jl	SHORT $LN9@initialize

; 1688 :         line->is_constant = true;

	mov	BYTE PTR [edx+35], 1

; 1689 :       else

	jmp	SHORT $LN12@initialize
$LN9@initialize:

; 1690 :         {
; 1691 :           kd_multi_line *dep = dependencies[n];

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [eax+esi*4]

; 1692 :           line->need_irreversible = dep->need_irreversible;

	movzx	eax, BYTE PTR [ecx+33]
	mov	BYTE PTR [edx+33], al

; 1693 :           line->reversible = dep->reversible;

	movzx	eax, BYTE PTR [ecx+32]
	mov	BYTE PTR [edx+32], al

; 1694 :           if (dep->is_constant)

	cmp	BYTE PTR [ecx+35], 0
	je	SHORT $LN11@initialize

; 1695 :             {
; 1696 :               line->is_constant = true;

	mov	BYTE PTR [edx+35], 1

; 1697 :               line->rev_offset = dep->rev_offset;

	mov	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR [edx+40], eax

; 1698 :               line->irrev_offset = dep->irrev_offset;

	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [edx+44], eax

; 1699 :               dependencies[n] = dep = NULL;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [eax+esi*4], 0

; 1700 :             }
; 1701 :           else

	jmp	SHORT $LN12@initialize
$LN11@initialize:

; 1702 :             dep->num_consumers++;

	inc	DWORD PTR [ecx+24]
$LN12@initialize:

; 1703 :         }
; 1704 :       line->rev_offset += rev_offsets[n];

	mov	eax, DWORD PTR [ebx]
	inc	esi
	add	DWORD PTR [edx+40], eax

; 1705 :       line->irrev_offset += irrev_offsets[n];

	mov	eax, DWORD PTR _irrev_offsets$1$[ebp]
	mov	ecx, DWORD PTR _output_indices$1$[ebp]
	movss	xmm0, DWORD PTR [eax+ebx]
	add	ebx, 4
	addss	xmm0, DWORD PTR [edx+44]
	mov	eax, DWORD PTR tv946[ebp]
	add	eax, 60					; 0000003cH
	mov	DWORD PTR tv946[ebp], eax
	movss	DWORD PTR [edx+44], xmm0
	cmp	esi, DWORD PTR [edi+8]
	jl	$LL7@initialize
$LN6@initialize:
	pop	edi
	pop	esi
	pop	ebx

; 1706 :     }
; 1707 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?initialize@kd_multi_null_block@@UAEXHHVkdu_tile@@HHPAUkd_multi_collection@@1PAVkd_multi_transform@@@Z ENDP ; kd_multi_null_block::initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??0kd_multi_null_block@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0kd_multi_null_block@@QAE@XZ PROC			; kd_multi_null_block::kd_multi_null_block, COMDAT
; _this$ = ecx

; 357  :     kd_multi_null_block()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 358  :       { is_null_transform = true; }

	mov	eax, ecx

; 193  :         num_components = 0;  components = NULL;  next = prev = NULL;

	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+32], 0

; 194  :         num_dependencies = num_available_dependencies = 0; dependencies = NULL;

	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0

; 195  :         outstanding_consumers = 0;

	mov	DWORD PTR [ecx+28], 0

; 358  :       { is_null_transform = true; }

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_null_block@@6B@
	mov	BYTE PTR [ecx+4], 1
	mov	esp, ebp
	pop	ebp
	ret	0
??0kd_multi_null_block@@QAE@XZ ENDP			; kd_multi_null_block::kd_multi_null_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??_Gkd_multi_block@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_multi_block@@UAEPAXI@Z PROC			; kd_multi_block::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 199  :         if (components != NULL) delete[] components;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_block@@6B@
	test	eax, eax
	je	SHORT $LN5@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@scalar:

; 200  :         if (dependencies != NULL) delete[] dependencies;

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN6@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	40					; 00000028H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_multi_block@@UAEPAXI@Z ENDP			; kd_multi_block::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ?perform_inverse@kd_multi_block@@UAEXXZ
_TEXT	SEGMENT
?perform_inverse@kd_multi_block@@UAEXXZ PROC		; kd_multi_block::perform_inverse, COMDAT
; _this$ = ecx

; 282  :     virtual void perform_inverse() { return; }

	ret	0
?perform_inverse@kd_multi_block@@UAEXXZ ENDP		; kd_multi_block::perform_inverse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ?prepare_for_inversion@kd_multi_block@@UAEPBDXZ
_TEXT	SEGMENT
?prepare_for_inversion@kd_multi_block@@UAEPBDXZ PROC	; kd_multi_block::prepare_for_inversion, COMDAT
; _this$ = ecx

; 262  :       { return "Unimplemented multi-component transform block inversion "

	mov	eax, OFFSET ??_C@_0ED@KEGEGAOK@Unimplemented?5multi?9component?5tr@

; 263  :                "procedure."; }

	ret	0
?prepare_for_inversion@kd_multi_block@@UAEPBDXZ ENDP	; kd_multi_block::prepare_for_inversion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ?perform_transform@kd_multi_block@@UAEXXZ
_TEXT	SEGMENT
?perform_transform@kd_multi_block@@UAEXXZ PROC		; kd_multi_block::perform_transform, COMDAT
; _this$ = ecx

; 251  :     virtual void perform_transform() { return; }

	ret	0
?perform_transform@kd_multi_block@@UAEXXZ ENDP		; kd_multi_block::perform_transform
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ?propagate_bit_depths@kd_multi_block@@UAE_N_N0@Z
_TEXT	SEGMENT
_need_input_bit_depth$ = 8				; size = 1
_need_output_bit_depth$ = 12				; size = 1
?propagate_bit_depths@kd_multi_block@@UAE_N_N0@Z PROC	; kd_multi_block::propagate_bit_depths, COMDAT
; _this$ = ecx

; 239  :       { return false; }

	xor	al, al
	ret	8
?propagate_bit_depths@kd_multi_block@@UAE_N_N0@Z ENDP	; kd_multi_block::propagate_bit_depths
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ?normalize_coefficients@kd_multi_block@@UAEXXZ
_TEXT	SEGMENT
?normalize_coefficients@kd_multi_block@@UAEXXZ PROC	; kd_multi_block::normalize_coefficients, COMDAT
; _this$ = ecx

; 222  :     virtual void normalize_coefficients() { return; }

	ret	0
?normalize_coefficients@kd_multi_block@@UAEXXZ ENDP	; kd_multi_block::normalize_coefficients
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??1kd_multi_block@@UAE@XZ
_TEXT	SEGMENT
??1kd_multi_block@@UAE@XZ PROC				; kd_multi_block::~kd_multi_block, COMDAT
; _this$ = ecx

; 198  :       {

	push	esi
	mov	esi, ecx

; 199  :         if (components != NULL) delete[] components;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_block@@6B@
	test	eax, eax
	je	SHORT $LN2@kd_multi_b
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_multi_b:

; 200  :         if (dependencies != NULL) delete[] dependencies;

	mov	eax, DWORD PTR [esi+20]
	pop	esi
	test	eax, eax
	je	SHORT $LN3@kd_multi_b
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN3@kd_multi_b:

; 201  :       }

	ret	0
??1kd_multi_block@@UAE@XZ ENDP				; kd_multi_block::~kd_multi_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??0kd_multi_block@@QAE@XZ
_TEXT	SEGMENT
??0kd_multi_block@@QAE@XZ PROC				; kd_multi_block::kd_multi_block, COMDAT
; _this$ = ecx

; 191  :       {

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_block@@6B@

; 192  :         is_null_transform = true; // Changed by derived constructors
; 193  :         num_components = 0;  components = NULL;  next = prev = NULL;
; 194  :         num_dependencies = num_available_dependencies = 0; dependencies = NULL;
; 195  :         outstanding_consumers = 0;
; 196  :       }

	mov	eax, ecx
	mov	BYTE PTR [ecx+4], 1
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+28], 0
	ret	0
??0kd_multi_block@@QAE@XZ ENDP				; kd_multi_block::kd_multi_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?copy@kd_multi_line@@QAEXPAU1@HM@Z
_TEXT	SEGMENT
tv1685 = -16						; size = 8
tv1679 = -16						; size = 8
_this$1$ = -8						; size = 4
_sp16$1$ = -4						; size = 4
_src$ = 8						; size = 4
_rev_offset$ = 12					; size = 4
_off16$1$ = 16						; size = 4
_off32$1$ = 16						; size = 4
_irrev_offset$ = 16					; size = 4
?copy@kd_multi_line@@QAEXPAU1@HM@Z PROC			; kd_multi_line::copy, COMDAT
; _this$ = ecx

; 200  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	edx, ecx
	push	ebx
	push	esi
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	al, BYTE PTR [edx+6]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 200  : {

	mov	DWORD PTR _this$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	and	al, 2
	je	SHORT $LN45@copy
	xor	esi, esi
	jmp	SHORT $LN46@copy
$LN45@copy:
	mov	esi, DWORD PTR [edx+8]
$LN46@copy:

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	al, al
	je	SHORT $LN49@copy
	mov	ebx, DWORD PTR [edx+8]
	jmp	SHORT $LN50@copy
$LN49@copy:
	xor	ebx, ebx
$LN50@copy:

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	al, BYTE PTR [ecx+6]
	and	al, 2
	je	SHORT $LN53@copy
	xor	edi, edi
	jmp	SHORT $LN54@copy
$LN53@copy:
	mov	edi, DWORD PTR [ecx+8]
$LN54@copy:

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	al, al
	je	SHORT $LN57@copy
	mov	eax, DWORD PTR [ecx+8]
	jmp	SHORT $LN103@copy
$LN57@copy:
	xor	eax, eax
$LN103@copy:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 207  :   if (reversible)

	cmp	BYTE PTR [edx+32], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	mov	DWORD PTR _sp16$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 207  :   if (reversible)

	je	SHORT $LN26@copy

; 208  :     {
; 209  :       assert(src->reversible);
; 210  :       if (dp32 != NULL)
; 211  :         {
; 212  :           for (n=size.x; n > 0; n--, dp32++, sp32++)

	mov	ecx, DWORD PTR [edx+16]
	test	esi, esi
	je	SHORT $LN28@copy
	test	ecx, ecx
	jle	$LN24@copy
	mov	edx, DWORD PTR _rev_offset$[ebp]
	sub	edi, esi
$LL4@copy:

; 213  :             dp32->ival = sp32->ival + rev_offset;

	mov	eax, DWORD PTR [edi+esi]
	lea	esi, DWORD PTR [esi+4]
	add	eax, edx
	dec	ecx
	mov	DWORD PTR [esi-4], eax
	test	ecx, ecx
	jg	SHORT $LL4@copy
	pop	edi
	pop	esi
	pop	ebx

; 268  :             }
; 269  :         }
; 270  :     }
; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN28@copy:

; 214  :         }
; 215  :       else
; 216  :         {
; 217  :           for (n=size.x; n > 0; n--, dp16++, sp16++)

	test	ecx, ecx
	jle	$LN24@copy
	mov	edx, DWORD PTR _rev_offset$[ebp]
	sub	eax, ebx
	mov	DWORD PTR _sp16$1$[ebp], eax
	npad	7
$LL7@copy:

; 218  :             dp16->ival = sp16->ival + rev_offset;

	mov	ax, WORD PTR [eax+ebx]
	lea	ebx, DWORD PTR [ebx+2]
	add	ax, dx
	dec	ecx
	mov	WORD PTR [ebx-2], ax
	mov	eax, DWORD PTR _sp16$1$[ebp]
	test	ecx, ecx
	jg	SHORT $LL7@copy
	pop	edi
	pop	esi
	pop	ebx

; 268  :             }
; 269  :         }
; 270  :     }
; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN26@copy:

; 219  :         }
; 220  :     }
; 221  :   else
; 222  :     {
; 223  :       if (dp32 != NULL)

	test	esi, esi
	je	$LN30@copy

; 224  :         {
; 225  :           if (src->reversible)

	cmp	BYTE PTR [ecx+32], 0
	je	$LN32@copy

; 226  :             { // Convert to irreversible representation on the way through
; 227  :               float factor = 1.0F / (float)(1<<bit_depth);

	mov	ecx, DWORD PTR [edx+36]
	mov	eax, 1
	movss	xmm1, DWORD PTR __real@3f800000

; 228  :               for (n=size.x; n > 0; n--, dp32++, sp32++)

	movss	xmm2, DWORD PTR _irrev_offset$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR [edx+16]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	cmp	ecx, 4
	jl	SHORT $LC84@copy

; 226  :             { // Convert to irreversible representation on the way through
; 227  :               float factor = 1.0F / (float)(1<<bit_depth);

	lea	edx, DWORD PTR [ecx-4]
	shr	edx, 2
	inc	edx
	mov	eax, edx
	neg	eax
	lea	ecx, DWORD PTR [ecx+eax*4]
	npad	7

; 228  :               for (n=size.x; n > 0; n--, dp32++, sp32++)

$LL85@copy:

; 229  :                 dp32->fval = sp32->ival*factor + irrev_offset;

	movd	xmm0, DWORD PTR [edi]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR [esi], xmm0
	movd	xmm0, DWORD PTR [edi+4]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR [esi+4], xmm0
	movd	xmm0, DWORD PTR [edi+8]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR [esi+8], xmm0
	movd	xmm0, DWORD PTR [edi+12]
	add	edi, 16					; 00000010H
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR [esi+12], xmm0
	add	esi, 16					; 00000010H
	sub	edx, 1
	jne	SHORT $LL85@copy
$LC84@copy:

; 228  :               for (n=size.x; n > 0; n--, dp32++, sp32++)

	test	ecx, ecx
	jle	$LN24@copy
$LC10@copy:
	movd	xmm0, DWORD PTR [edi]
	dec	ecx

; 229  :                 dp32->fval = sp32->ival*factor + irrev_offset;

	cvtdq2ps xmm0, xmm0
	add	edi, 4
	mulss	xmm0, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR [esi], xmm0
	add	esi, 4
	test	ecx, ecx
	jg	SHORT $LC10@copy
	pop	edi
	pop	esi
	pop	ebx

; 268  :             }
; 269  :         }
; 270  :     }
; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN32@copy:

; 230  :             }
; 231  :           else
; 232  :             {
; 233  :               if (src->bit_depth == this->bit_depth)

	mov	ecx, DWORD PTR [ecx+36]
	mov	ebx, DWORD PTR [edx+36]
	cmp	ecx, ebx
	jne	$LN34@copy

; 234  :                 {
; 235  :                   for (n=size.x; n > 0; n--, dp32++, sp32++)

	mov	ecx, DWORD PTR [edx+16]
	movss	xmm1, DWORD PTR _irrev_offset$[ebp]
	cmp	ecx, 4
	jl	SHORT $LC87@copy
	lea	edx, DWORD PTR [ecx-4]
	shr	edx, 2
	inc	edx
	mov	eax, edx
	neg	eax
	lea	ecx, DWORD PTR [ecx+eax*4]
	npad	11
$LL88@copy:

; 236  :                     dp32->fval = sp32->fval + irrev_offset;

	movss	xmm0, DWORD PTR [edi]
	addss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0
	movss	xmm0, DWORD PTR [edi+4]
	addss	xmm0, xmm1
	movss	DWORD PTR [esi+4], xmm0
	movss	xmm0, DWORD PTR [edi+8]
	addss	xmm0, xmm1
	movss	DWORD PTR [esi+8], xmm0
	movss	xmm0, DWORD PTR [edi+12]
	add	edi, 16					; 00000010H
	addss	xmm0, xmm1
	movss	DWORD PTR [esi+12], xmm0
	add	esi, 16					; 00000010H
	sub	edx, 1
	jne	SHORT $LL88@copy
$LC87@copy:

; 234  :                 {
; 235  :                   for (n=size.x; n > 0; n--, dp32++, sp32++)

	test	ecx, ecx
	jle	$LN24@copy
	npad	7
$LC13@copy:

; 236  :                     dp32->fval = sp32->fval + irrev_offset;

	movss	xmm0, DWORD PTR [edi]
	dec	ecx
	addss	xmm0, xmm1
	add	edi, 4
	movss	DWORD PTR [esi], xmm0
	add	esi, 4
	test	ecx, ecx
	jg	SHORT $LC13@copy
	pop	edi
	pop	esi
	pop	ebx

; 268  :             }
; 269  :         }
; 270  :     }
; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN34@copy:

; 241  :                   for (n=size.x; n > 0; n--, dp32++, sp32++)

	movss	xmm2, DWORD PTR _irrev_offset$[ebp]
	mov	edx, 1
	mov	eax, edx
	shl	eax, cl
	mov	ecx, ebx
	shl	edx, cl
	movd	xmm1, eax
	movd	xmm0, edx
	mov	edx, DWORD PTR _this$1$[ebp]
	cvtdq2ps xmm1, xmm1
	mov	ecx, DWORD PTR [edx+16]
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	cmp	ecx, 4
	jl	SHORT $LC90@copy

; 237  :                 }
; 238  :               else
; 239  :                 {
; 240  :                   float factor = (1<<src->bit_depth) / (float)(1<<bit_depth);

	lea	edx, DWORD PTR [ecx-4]
	shr	edx, 2
	inc	edx
	mov	eax, edx
	neg	eax
	lea	ecx, DWORD PTR [ecx+eax*4]
	npad	3

; 241  :                   for (n=size.x; n > 0; n--, dp32++, sp32++)

$LL91@copy:

; 242  :                     dp32->fval = sp32->fval*factor + irrev_offset;

	movss	xmm0, DWORD PTR [edi]
	mulss	xmm0, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR [esi], xmm0
	movss	xmm0, DWORD PTR [edi+4]
	mulss	xmm0, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR [esi+4], xmm0
	movss	xmm0, DWORD PTR [edi+8]
	mulss	xmm0, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR [esi+8], xmm0
	movss	xmm0, DWORD PTR [edi+12]
	add	edi, 16					; 00000010H
	mulss	xmm0, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR [esi+12], xmm0
	add	esi, 16					; 00000010H
	sub	edx, 1
	jne	SHORT $LL91@copy
$LC90@copy:

; 241  :                   for (n=size.x; n > 0; n--, dp32++, sp32++)

	test	ecx, ecx
	jle	$LN24@copy
	npad	7
$LC16@copy:

; 242  :                     dp32->fval = sp32->fval*factor + irrev_offset;

	movss	xmm0, DWORD PTR [edi]
	dec	ecx
	mulss	xmm0, xmm1
	add	edi, 4
	addss	xmm0, xmm2
	movss	DWORD PTR [esi], xmm0
	add	esi, 4
	test	ecx, ecx
	jg	SHORT $LC16@copy
	pop	edi
	pop	esi
	pop	ebx

; 268  :             }
; 269  :         }
; 270  :     }
; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN30@copy:

; 243  :                 }
; 244  :             }
; 245  :         }
; 246  :       else
; 247  :         {
; 248  :           kdu_int16 off16 = (kdu_int16)
; 249  :             floor(0.5 + irrev_offset*(1<<KDU_FIX_POINT));

	movss	xmm0, DWORD PTR _irrev_offset$[ebp]
	sub	esp, 8
	mulss	xmm0, DWORD PTR __real@46000000
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv1685[ebp], xmm0
	fld	QWORD PTR tv1685[ebp]
	fstp	QWORD PTR [esp]
	call	_floor

; 250  :           int upshift = ((src->reversible)?KDU_FIX_POINT:(src->bit_depth))
; 251  :                       - this->bit_depth;

	mov	esi, DWORD PTR _src$[ebp]
	add	esp, 8
	fstp	QWORD PTR tv1679[ebp]
	cvttsd2si eax, QWORD PTR tv1679[ebp]
	cmp	BYTE PTR [esi+32], 0
	movzx	edi, ax
	mov	DWORD PTR _off16$1$[ebp], edi
	je	SHORT $LN41@copy
	mov	esi, 13					; 0000000dH
	jmp	SHORT $LN42@copy
$LN41@copy:
	mov	esi, DWORD PTR [esi+36]
$LN42@copy:
	mov	edx, DWORD PTR _this$1$[ebp]
	sub	esi, DWORD PTR [edx+36]

; 252  :           if (upshift == 0)

	jne	SHORT $LN36@copy

; 253  :             {
; 254  :               for (n=size.x; n > 0; n--, dp16++, sp16++)

	mov	ecx, DWORD PTR [edx+16]
	test	ecx, ecx
	jle	$LN24@copy
	mov	edx, DWORD PTR _sp16$1$[ebp]
	npad	7
$LL19@copy:

; 255  :                 dp16->ival = sp16->ival + off16;

	mov	ax, WORD PTR [edx]
	lea	ebx, DWORD PTR [ebx+2]
	add	ax, di
	lea	edx, DWORD PTR [edx+2]
	dec	ecx
	mov	WORD PTR [ebx-2], ax
	test	ecx, ecx
	jg	SHORT $LL19@copy
	pop	edi
	pop	esi
	pop	ebx

; 268  :             }
; 269  :         }
; 270  :     }
; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN36@copy:

; 256  :             }
; 257  :           else if (upshift > 0)

	test	esi, esi
	jle	SHORT $LN38@copy

; 258  :             {
; 259  :               for (n=size.x; n > 0; n--, dp16++, sp16++)

	mov	edi, DWORD PTR [edx+16]
	test	edi, edi
	jle	SHORT $LN24@copy
	mov	edx, DWORD PTR _sp16$1$[ebp]
	npad	4
$LL22@copy:

; 260  :                 dp16->ival = (sp16->ival<<upshift) + off16;

	mov	ax, WORD PTR [edx]
	lea	ebx, DWORD PTR [ebx+2]
	mov	ecx, esi
	lea	edx, DWORD PTR [edx+2]
	shl	ax, cl
	dec	edi
	add	ax, WORD PTR _off16$1$[ebp]
	mov	WORD PTR [ebx-2], ax
	test	edi, edi
	jg	SHORT $LL22@copy
	pop	edi
	pop	esi
	pop	ebx

; 268  :             }
; 269  :         }
; 270  :     }
; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN38@copy:

; 261  :             }
; 262  :           else
; 263  :             {
; 264  :               int downshift = -upshift;

	neg	esi

; 265  :               int off32 = (((int) off16) << downshift) + (1<<(downshift-1));

	mov	eax, 1
	lea	ecx, DWORD PTR [esi-1]
	shl	eax, cl
	mov	ecx, esi
	mov	DWORD PTR _off32$1$[ebp], eax
	movsx	eax, di

; 266  :               for (n=size.x; n > 0; n--, dp16++, sp16++)

	mov	edi, DWORD PTR [edx+16]
	shl	eax, cl
	mov	ecx, DWORD PTR _off32$1$[ebp]
	add	ecx, eax
	mov	DWORD PTR _off32$1$[ebp], ecx
	test	edi, edi
	jle	SHORT $LN24@copy
	mov	edx, DWORD PTR _sp16$1$[ebp]
	npad	4
$LL25@copy:

; 267  :                 dp16->ival = (kdu_int16)((off32+sp16->ival)>>downshift);

	movsx	eax, WORD PTR [edx]
	lea	ebx, DWORD PTR [ebx+2]
	add	eax, ecx
	lea	edx, DWORD PTR [edx+2]
	mov	ecx, esi
	dec	edi
	sar	eax, cl
	mov	ecx, DWORD PTR _off32$1$[ebp]
	mov	WORD PTR [ebx-2], ax
	test	edi, edi
	jg	SHORT $LL25@copy
$LN24@copy:
	pop	edi
	pop	esi
	pop	ebx

; 268  :             }
; 269  :         }
; 270  :     }
; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?copy@kd_multi_line@@QAEXPAU1@HM@Z ENDP			; kd_multi_line::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?apply_offset@kd_multi_line@@QAEXHM@Z
_TEXT	SEGMENT
tv505 = -8						; size = 8
tv499 = -8						; size = 8
_rev_off$ = 8						; size = 4
_irrev_off$ = 12					; size = 4
?apply_offset@kd_multi_line@@QAEXHM@Z PROC		; kd_multi_line::apply_offset, COMDAT
; _this$ = ecx

; 156  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	al, BYTE PTR [edi+6]
	and	al, 2
	je	SHORT $LN25@apply_offs
	xor	edx, edx
	jmp	SHORT $LN26@apply_offs
$LN25@apply_offs:
	mov	edx, DWORD PTR [edi+8]
$LN26@apply_offs:

; 402  :       }
; 403  :     kdu_sample16 *get_buf16()
; 404  :       {
; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	al, al
	je	SHORT $LN29@apply_offs
	mov	esi, DWORD PTR [edi+8]
	jmp	SHORT $LN30@apply_offs
$LN29@apply_offs:
	xor	esi, esi
$LN30@apply_offs:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 160  :   if (reversible)

	cmp	BYTE PTR [edi+32], 0
	je	SHORT $LN14@apply_offs

; 161  :     {
; 162  :       if (rev_off == 0)

	mov	ecx, DWORD PTR _rev_off$[ebp]
	test	ecx, ecx
	je	$LN12@apply_offs

; 163  :         return;
; 164  :       if (dp32 != NULL)
; 165  :         {
; 166  :           for (n=size.x; n > 0; n--, dp32++)

	mov	eax, DWORD PTR [edi+16]
	test	edx, edx
	je	SHORT $LN17@apply_offs
	test	eax, eax
	jle	$LN12@apply_offs
$LL4@apply_offs:

; 167  :             dp32->ival += rev_off;

	add	DWORD PTR [edx], ecx
	lea	edx, DWORD PTR [edx+4]
	dec	eax
	test	eax, eax
	jg	SHORT $LL4@apply_offs
	pop	edi
	pop	esi

; 190  :         }
; 191  :     }
; 192  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN17@apply_offs:

; 168  :         }
; 169  :       else
; 170  :         {
; 171  :           for (n=size.x; n > 0; n--, dp16++)

	test	eax, eax
	jle	$LN12@apply_offs
	npad	3
$LL7@apply_offs:

; 172  :             dp16->ival += (kdu_int16) rev_off;

	add	WORD PTR [esi], cx
	lea	esi, DWORD PTR [esi+2]
	dec	eax
	test	eax, eax
	jg	SHORT $LL7@apply_offs
	pop	edi
	pop	esi

; 190  :         }
; 191  :     }
; 192  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN14@apply_offs:

; 173  :         }
; 174  :     }
; 175  :   else
; 176  :     {
; 177  :       if (irrev_off == 0.0F)

	movss	xmm1, DWORD PTR _irrev_off$[ebp]
	shufps	xmm1, xmm1, 0
	ucomiss	xmm1, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN12@apply_offs

; 178  :         return;
; 179  :       if (dp32 != NULL)

	test	edx, edx
	je	SHORT $LN20@apply_offs

; 180  :         {
; 181  :           for (n=size.x; n > 0; n--, dp32++)

	mov	ecx, DWORD PTR [edi+16]
	cmp	ecx, 4
	jl	SHORT $LC44@apply_offs
	lea	esi, DWORD PTR [ecx-4]
	shr	esi, 2
	inc	esi
	mov	eax, esi
	neg	eax
	lea	ecx, DWORD PTR [ecx+eax*4]
$LL45@apply_offs:

; 182  :             dp32->fval += irrev_off;

	movups	xmm0, XMMWORD PTR [edx]
	addps	xmm0, xmm1
	movups	XMMWORD PTR [edx], xmm0
	add	edx, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL45@apply_offs
$LC44@apply_offs:

; 180  :         {
; 181  :           for (n=size.x; n > 0; n--, dp32++)

	test	ecx, ecx
	jle	SHORT $LN12@apply_offs
	npad	4
$LC10@apply_offs:

; 182  :             dp32->fval += irrev_off;

	movss	xmm0, DWORD PTR [edx]
	dec	ecx
	addss	xmm0, xmm1
	movss	DWORD PTR [edx], xmm0
	add	edx, 4
	test	ecx, ecx
	jg	SHORT $LC10@apply_offs
	pop	edi
	pop	esi

; 190  :         }
; 191  :     }
; 192  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN20@apply_offs:

; 183  :         }
; 184  :       else
; 185  :         {
; 186  :           kdu_int16 off = (kdu_int16)
; 187  :             floor(0.5 + irrev_off*(1<<KDU_FIX_POINT));

	mulss	xmm1, DWORD PTR __real@46000000
	sub	esp, 8
	cvtps2pd xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv505[ebp], xmm0
	fld	QWORD PTR tv505[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv499[ebp]
	cvttsd2si eax, QWORD PTR tv499[ebp]
	add	esp, 8
	movzx	ecx, ax

; 188  :           for (n=size.x; n > 0; n--, dp16++)

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	jle	SHORT $LN12@apply_offs
$LL13@apply_offs:

; 189  :             dp16->ival += off;

	add	WORD PTR [esi], cx
	lea	esi, DWORD PTR [esi+2]
	dec	eax
	test	eax, eax
	jg	SHORT $LL13@apply_offs
$LN12@apply_offs:
	pop	edi
	pop	esi

; 190  :         }
; 191  :     }
; 192  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?apply_offset@kd_multi_line@@QAEXHM@Z ENDP		; kd_multi_line::apply_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?reset@kd_multi_line@@QAEXHM@Z
_TEXT	SEGMENT
tv372 = -8						; size = 8
tv365 = -8						; size = 8
_rev_off$ = 8						; size = 4
_irrev_off$ = 12					; size = 4
?reset@kd_multi_line@@QAEXHM@Z PROC			; kd_multi_line::reset, COMDAT
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	al, BYTE PTR [esi+6]
	and	al, 2
	je	SHORT $LN31@reset
	xor	edx, edx
	jmp	SHORT $LN32@reset
$LN31@reset:
	mov	edx, DWORD PTR [esi+8]
$LN32@reset:

; 402  :       }
; 403  :     kdu_sample16 *get_buf16()
; 404  :       {
; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	al, al
	je	SHORT $LN35@reset
	mov	edi, DWORD PTR [esi+8]
	jmp	SHORT $LN36@reset
$LN35@reset:
	xor	edi, edi
$LN36@reset:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 107  :   if (reversible)

	cmp	BYTE PTR [esi+32], 0
	je	$LN14@reset

; 108  :     {
; 109  :       if (dp16 != NULL)

	test	edi, edi
	je	SHORT $LN16@reset

; 110  :         { // Reversible 16-bit integers
; 111  :           if (rev_off == 0)

	mov	eax, DWORD PTR _rev_off$[ebp]
	test	eax, eax
	jne	SHORT $LN18@reset
$LN54@reset:

; 112  :             memset(dp16,0,(size_t)(size.x<<1));

	mov	eax, DWORD PTR [esi+16]
	add	eax, eax
	push	eax
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 145  :             (dp32++)->fval = irrev_off;
; 146  :         }
; 147  :     }
; 148  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN18@reset:

; 113  :           else
; 114  :             for (int n=size.x; n > 0; n--)

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	jle	$LN13@reset
	movzx	edx, ax
	mov	eax, edx
	shl	edx, 16					; 00000010H
	or	eax, edx
	shr	ecx, 1
	rep stosd
	adc	ecx, ecx
	rep stosw
	pop	edi
	pop	esi

; 145  :             (dp32++)->fval = irrev_off;
; 146  :         }
; 147  :     }
; 148  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN16@reset:

; 115  :               (dp16++)->ival = (kdu_int16) rev_off;
; 116  :         }
; 117  :       else if (dp32 != NULL)

	test	edx, edx
	je	$LN13@reset

; 118  :         { // Reversible 32-bit integers
; 119  :           if (rev_off == 0)

	mov	eax, DWORD PTR _rev_off$[ebp]
	test	eax, eax
	jne	SHORT $LN22@reset

; 120  :             memset(dp32,0,(size_t)(size.x<<2));

	mov	eax, DWORD PTR [esi+16]
	shl	eax, 2
	push	eax
	push	0
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 145  :             (dp32++)->fval = irrev_off;
; 146  :         }
; 147  :     }
; 148  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN22@reset:

; 121  :           else
; 122  :             for (int n=size.x; n > 0; n--)

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	jle	$LN13@reset

; 139  :                 (dp16++)->ival = off;
; 140  :             }
; 141  :         }
; 142  :       else
; 143  :         { // Irreversible floating-point words
; 144  :           for (int n=size.x; n > 0; n--)

	mov	edi, edx
	rep stosd
	pop	edi
	pop	esi

; 145  :             (dp32++)->fval = irrev_off;
; 146  :         }
; 147  :     }
; 148  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN14@reset:

; 123  :               (dp32++)->ival = rev_off;
; 124  :         }
; 125  :       else
; 126  :         assert(0);
; 127  :     }
; 128  :   else
; 129  :     {
; 130  :       if (dp16 != NULL)

	test	edi, edi
	je	SHORT $LN24@reset

; 131  :         { // Irreversible fixed-point words
; 132  :           if (irrev_off == 0.0F)

	movss	xmm0, DWORD PTR _irrev_off$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN54@reset

; 133  :             memset(dp16,0,(size_t)(size.x<<1));
; 134  :           else
; 135  :             {
; 136  :               kdu_int16 off = (kdu_int16)
; 137  :                 floor(0.5+irrev_off*(1<<KDU_FIX_POINT));

	mulss	xmm0, DWORD PTR __real@46000000
	sub	esp, 8
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv372[ebp], xmm0
	fld	QWORD PTR tv372[ebp]
	fstp	QWORD PTR [esp]
	call	_floor

; 138  :               for (int n=size.x; n > 0; n--)

	mov	ecx, DWORD PTR [esi+16]
	add	esp, 8
	fstp	QWORD PTR tv365[ebp]
	cvttsd2si eax, QWORD PTR tv365[ebp]
	movzx	eax, ax
	test	ecx, ecx
	jle	SHORT $LN13@reset

; 133  :             memset(dp16,0,(size_t)(size.x<<1));
; 134  :           else
; 135  :             {
; 136  :               kdu_int16 off = (kdu_int16)
; 137  :                 floor(0.5+irrev_off*(1<<KDU_FIX_POINT));

	mov	edx, eax
	shl	edx, 16					; 00000010H
	or	eax, edx
	shr	ecx, 1
	rep stosd
	adc	ecx, ecx
	rep stosw
	pop	edi
	pop	esi

; 145  :             (dp32++)->fval = irrev_off;
; 146  :         }
; 147  :     }
; 148  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN24@reset:

; 139  :                 (dp16++)->ival = off;
; 140  :             }
; 141  :         }
; 142  :       else
; 143  :         { // Irreversible floating-point words
; 144  :           for (int n=size.x; n > 0; n--)

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	jle	SHORT $LN13@reset
	mov	eax, DWORD PTR _irrev_off$[ebp]
	mov	edi, edx
	rep stosd
$LN13@reset:
	pop	edi
	pop	esi

; 145  :             (dp32++)->fval = irrev_off;
; 146  :         }
; 147  :     }
; 148  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?reset@kd_multi_line@@QAEXHM@Z ENDP			; kd_multi_line::reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ?initialize@kd_multi_line@@QAEXXZ
_TEXT	SEGMENT
?initialize@kd_multi_line@@QAEXXZ PROC			; kd_multi_line::initialize, COMDAT
; _this$ = ecx

; 92   :     void initialize() { reset(rev_offset,irrev_offset); }

	movss	xmm0, DWORD PTR [ecx+44]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR [ecx+40]
	call	?reset@kd_multi_line@@QAEXHM@Z		; kd_multi_line::reset
	ret	0
?initialize@kd_multi_line@@QAEXXZ ENDP			; kd_multi_line::initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
;	COMDAT ??0kd_multi_line@@QAE@XZ
_TEXT	SEGMENT
??0kd_multi_line@@QAE@XZ PROC				; kd_multi_line::kd_multi_line, COMDAT
; _this$ = ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 91   :       }

	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 386  :         width=0; flags=0; pre_created=false;

	mov	WORD PTR [ecx+6], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 87   :         row_idx = -1;  num_consumers = outstanding_consumers = 0;

	mov	DWORD PTR [ecx+20], -1
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+24], 0

; 88   :         reversible = need_irreversible = need_precise = is_constant = false;

	mov	DWORD PTR [ecx+32], 0

; 89   :         bit_depth = 0;  rev_offset = 0;  irrev_offset = 0.0F;

	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0

; 90   :         bypass=NULL;  block=NULL;  collection_idx = -1;

	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], -1

; 91   :       }

	ret	0
??0kd_multi_line@@QAE@XZ ENDP				; kd_multi_line::kd_multi_line
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?create@kdu_multi_synthesis@@QAE_JVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_codestream$ = 8					; size = 4
_tile$ = 12						; size = 4
_force_precise$ = 16					; size = 1
_skip_ycc$ = 20						; size = 1
_want_fastest$ = 24					; size = 1
_processing_stripe_height$ = 28				; size = 4
_env$ = 32						; size = 4
_env_queue$ = 36					; size = 4
_double_buffering$ = 40					; size = 1
?create@kdu_multi_synthesis@@QAE_JVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z PROC ; kdu_multi_synthesis::create, COMDAT
; _this$ = ecx

; 888  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 889  :   kd_multi_synthesis *obj = new kd_multi_synthesis;

	push	84					; 00000054H
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], ecx
	test	ecx, ecx
	je	$LN4@create
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 737  :       {

	mov	DWORD PTR [ecx+4], OFFSET ??_7kd_multi_transform@@6B@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 150  :       { bytes_reserved = bytes_used = buffer_size = 0;

	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+40], 0

; 151  :         pre_creation_phase=true; buffer = buf_handle = NULL; }

	mov	BYTE PTR [ecx+36], 1
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+52], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 738  :         use_ycc=false; xform_blocks=block_tail=NULL;

	mov	BYTE PTR [ecx+8], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+12], 0

; 739  :         codestream_collection=output_collection=NULL;

	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+24], 0

; 740  :         constant_output_lines=NULL; codestream_components = NULL;

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+20], 0

; 741  :         env_queue = NULL;  max_scratch_ints = max_scratch_floats = 0;

	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+72], 0
	mov	DWORD PTR [ecx+64], 0

; 742  :         scratch_ints=NULL;  scratch_floats=NULL;

	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+76], 0

; 743  :       }
; 744  :     virtual ~kd_multi_transform();
; 745  :     int *get_scratch_ints(int num_elts);
; 746  :     float *get_scratch_floats(int num_elts);
; 747  :   protected: // Utility functions
; 748  :     void construct(kdu_codestream codestream, kdu_tile tile,
; 749  :                    bool force_precise, bool skip_ycc, bool want_fastest,
; 750  :                    int processing_stripe_height, kdu_thread_env *env,
; 751  :                    kdu_thread_queue *env_queue, bool double_buffering);
; 752  :       /* Does almost all the work of `kd_multi_analysis::create' and
; 753  :          `kd_multi_synthesis::create'. */
; 754  :     void create_resources();
; 755  :       /* Called from within `kd_multi_analysis::create' or
; 756  :          `kd_multi_synthesis::create' after first calling `construct' and
; 757  :          then creating all `kdu_push_ifc'- and `kdu_pull_ifc'-derived engines.
; 758  :          This function pre-creates all the `kdu_line_buf' resources, then
; 759  :          finalizes the `allocator' object and finalizes the creation
; 760  :          of all `kdu_line_buf' resources.  The function also initializes
; 761  :          the contents of all lines which have no generator. */
; 762  :   private: // Helper functions for `construct'
; 763  :     bool propagate_knowledge(bool force_precise);
; 764  :       /* This function is called from `construct' once all transform blocks
; 765  :          and lines have been constructed.  At this point, the bit-depth of
; 766  :          each codestream component line and each output component line should
; 767  :          be known; all other lines should have a 0 bit-depth.  Also, at this
; 768  :          point, the `reversible', `need_irreversible' and `need_precise'
; 769  :          flags might have been set only for some lines -- typically
; 770  :          codestream component lines, or lines produced by transform blocks
; 771  :          with known requirements.  Finally, dimensions should be known only
; 772  :          for output image components and codestream image components.  Each
; 773  :          time this function is called, it passes through the network,
; 774  :          propagating the available knowledge wherever possible.  If nothing
; 775  :          changes, the function returns false and does not need to be called
; 776  :          again.  Otherwise, it must be invoked iteratively. */
; 777  :   protected: // Data
; 778  :     bool use_ycc;
; 779  :     kd_multi_block *xform_blocks;
; 780  :     kd_multi_block *block_tail; // Tail of `xform_blocks' list
; 781  :     kd_multi_component *codestream_components;
; 782  :     kd_multi_collection *codestream_collection; // Linked list of collections
; 783  :     kd_multi_collection *output_collection;
; 784  :     kd_multi_line *constant_output_lines;
; 785  :     kdu_sample_allocator allocator;
; 786  :     kdu_thread_queue *env_queue; // Parent of the above queues.
; 787  :   private:
; 788  :     int max_scratch_ints;
; 789  :     int *scratch_ints;
; 790  :     int max_scratch_floats;
; 791  :     float *scratch_floats;
; 792  :   };
; 793  : 
; 794  : /*****************************************************************************/
; 795  : /*                            kd_multi_synthesis                             */
; 796  : /*****************************************************************************/
; 797  : 
; 798  : class kd_multi_synthesis : public kd_multi_synthesis_base,
; 799  :                            public kd_multi_transform {
; 800  :   public: // Member functions
; 801  :     kd_multi_synthesis() { output_row_counters=NULL; }

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_synthesis@@6Bkd_multi_synthesis_base@@@
	mov	DWORD PTR [ecx+4], OFFSET ??_7kd_multi_synthesis@@6Bkd_multi_transform@@@
	mov	DWORD PTR [ecx+80], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 889  :   kd_multi_synthesis *obj = new kd_multi_synthesis;

	jmp	SHORT $LN5@create
$LN4@create:
	xor	ecx, ecx
$LN5@create:

; 890  :   state = obj;
; 891  :   if (processing_stripe_height < 1)
; 892  :     processing_stripe_height = 1;
; 893  :   return obj->create(codestream,tile,force_precise,skip_ycc,want_fastest,

	push	DWORD PTR _double_buffering$[ebp]
	mov	eax, DWORD PTR _processing_stripe_height$[ebp]
	mov	edx, 1
	push	DWORD PTR _env_queue$[ebp]
	cmp	eax, edx
	mov	DWORD PTR [esi], ecx
	push	DWORD PTR _env$[ebp]
	cmovl	eax, edx
	push	eax
	push	DWORD PTR _want_fastest$[ebp]
	push	DWORD PTR _skip_ycc$[ebp]
	push	DWORD PTR _force_precise$[ebp]
	push	DWORD PTR _tile$[ebp]
	push	DWORD PTR _codestream$[ebp]
	call	?create@kd_multi_synthesis@@QAE_JVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ; kd_multi_synthesis::create
	pop	esi

; 894  :                      processing_stripe_height,env,env_queue,
; 895  :                      double_buffering);
; 896  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?create@kdu_multi_synthesis@@QAE_JVkdu_codestream@@Vkdu_tile@@_N22HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ENDP ; kdu_multi_synthesis::create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??_Gkd_multi_synthesis_base@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_multi_synthesis_base@@UAEPAXI@Z PROC		; kd_multi_synthesis_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 1659 :     virtual ~kd_multi_synthesis_base() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_synthesis_base@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_multi_synthesis_base@@UAEPAXI@Z ENDP		; kd_multi_synthesis_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0kd_multi_synthesis_base@@QAE@XZ
_TEXT	SEGMENT
??0kd_multi_synthesis_base@@QAE@XZ PROC			; kd_multi_synthesis_base::kd_multi_synthesis_base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_synthesis_base@@6B@
	mov	eax, ecx
	ret	0
??0kd_multi_synthesis_base@@QAE@XZ ENDP			; kd_multi_synthesis_base::kd_multi_synthesis_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??1kd_multi_synthesis_base@@UAE@XZ
_TEXT	SEGMENT
??1kd_multi_synthesis_base@@UAE@XZ PROC			; kd_multi_synthesis_base::~kd_multi_synthesis_base, COMDAT
; _this$ = ecx

; 1659 :     virtual ~kd_multi_synthesis_base() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_synthesis_base@@6B@
	ret	0
??1kd_multi_synthesis_base@@UAE@XZ ENDP			; kd_multi_synthesis_base::~kd_multi_synthesis_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?create@kdu_multi_analysis@@QAE_JVkdu_codestream@@Vkdu_tile@@_NPAVkdu_roi_image@@2HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_codestream$ = 8					; size = 4
_tile$ = 12						; size = 4
_force_precise$ = 16					; size = 1
_roi$ = 20						; size = 4
_want_fastest$ = 24					; size = 1
_processing_stripe_height$ = 28				; size = 4
_env$ = 32						; size = 4
_env_queue$ = 36					; size = 4
_double_buffering$ = 40					; size = 1
?create@kdu_multi_analysis@@QAE_JVkdu_codestream@@Vkdu_tile@@_NPAVkdu_roi_image@@2HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z PROC ; kdu_multi_analysis::create, COMDAT
; _this$ = ecx

; 1229 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 1230 :   kd_multi_analysis *obj = new kd_multi_analysis;

	push	84					; 00000054H
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], ecx
	test	ecx, ecx
	je	$LN4@create
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 737  :       {

	mov	DWORD PTR [ecx+4], OFFSET ??_7kd_multi_transform@@6B@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 150  :       { bytes_reserved = bytes_used = buffer_size = 0;

	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+40], 0

; 151  :         pre_creation_phase=true; buffer = buf_handle = NULL; }

	mov	BYTE PTR [ecx+36], 1
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+52], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform_local.h

; 738  :         use_ycc=false; xform_blocks=block_tail=NULL;

	mov	BYTE PTR [ecx+8], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+12], 0

; 739  :         codestream_collection=output_collection=NULL;

	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+24], 0

; 740  :         constant_output_lines=NULL; codestream_components = NULL;

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+20], 0

; 741  :         env_queue = NULL;  max_scratch_ints = max_scratch_floats = 0;

	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+72], 0
	mov	DWORD PTR [ecx+64], 0

; 742  :         scratch_ints=NULL;  scratch_floats=NULL;

	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+76], 0

; 743  :       }
; 744  :     virtual ~kd_multi_transform();
; 745  :     int *get_scratch_ints(int num_elts);
; 746  :     float *get_scratch_floats(int num_elts);
; 747  :   protected: // Utility functions
; 748  :     void construct(kdu_codestream codestream, kdu_tile tile,
; 749  :                    bool force_precise, bool skip_ycc, bool want_fastest,
; 750  :                    int processing_stripe_height, kdu_thread_env *env,
; 751  :                    kdu_thread_queue *env_queue, bool double_buffering);
; 752  :       /* Does almost all the work of `kd_multi_analysis::create' and
; 753  :          `kd_multi_synthesis::create'. */
; 754  :     void create_resources();
; 755  :       /* Called from within `kd_multi_analysis::create' or
; 756  :          `kd_multi_synthesis::create' after first calling `construct' and
; 757  :          then creating all `kdu_push_ifc'- and `kdu_pull_ifc'-derived engines.
; 758  :          This function pre-creates all the `kdu_line_buf' resources, then
; 759  :          finalizes the `allocator' object and finalizes the creation
; 760  :          of all `kdu_line_buf' resources.  The function also initializes
; 761  :          the contents of all lines which have no generator. */
; 762  :   private: // Helper functions for `construct'
; 763  :     bool propagate_knowledge(bool force_precise);
; 764  :       /* This function is called from `construct' once all transform blocks
; 765  :          and lines have been constructed.  At this point, the bit-depth of
; 766  :          each codestream component line and each output component line should
; 767  :          be known; all other lines should have a 0 bit-depth.  Also, at this
; 768  :          point, the `reversible', `need_irreversible' and `need_precise'
; 769  :          flags might have been set only for some lines -- typically
; 770  :          codestream component lines, or lines produced by transform blocks
; 771  :          with known requirements.  Finally, dimensions should be known only
; 772  :          for output image components and codestream image components.  Each
; 773  :          time this function is called, it passes through the network,
; 774  :          propagating the available knowledge wherever possible.  If nothing
; 775  :          changes, the function returns false and does not need to be called
; 776  :          again.  Otherwise, it must be invoked iteratively. */
; 777  :   protected: // Data
; 778  :     bool use_ycc;
; 779  :     kd_multi_block *xform_blocks;
; 780  :     kd_multi_block *block_tail; // Tail of `xform_blocks' list
; 781  :     kd_multi_component *codestream_components;
; 782  :     kd_multi_collection *codestream_collection; // Linked list of collections
; 783  :     kd_multi_collection *output_collection;
; 784  :     kd_multi_line *constant_output_lines;
; 785  :     kdu_sample_allocator allocator;
; 786  :     kdu_thread_queue *env_queue; // Parent of the above queues.
; 787  :   private:
; 788  :     int max_scratch_ints;
; 789  :     int *scratch_ints;
; 790  :     int max_scratch_floats;
; 791  :     float *scratch_floats;
; 792  :   };
; 793  : 
; 794  : /*****************************************************************************/
; 795  : /*                            kd_multi_synthesis                             */
; 796  : /*****************************************************************************/
; 797  : 
; 798  : class kd_multi_synthesis : public kd_multi_synthesis_base,
; 799  :                            public kd_multi_transform {
; 800  :   public: // Member functions
; 801  :     kd_multi_synthesis() { output_row_counters=NULL; }
; 802  :     virtual ~kd_multi_synthesis();
; 803  :     virtual void terminate_queues(kdu_thread_env *env);
; 804  :     kdu_long create(kdu_codestream codestream, kdu_tile tile,
; 805  :                     bool force_precise, bool skip_ycc, bool want_fastest,
; 806  :                     int processing_stripe_height, kdu_thread_env *env,
; 807  :                     kdu_thread_queue *env_queue, bool double_buffering);
; 808  :     virtual kdu_coords get_size(int comp_idx);
; 809  :     virtual kdu_line_buf *get_line(int comp_idx, kdu_thread_env *env);
; 810  :     virtual bool is_line_precise(int comp_idx);
; 811  :     virtual bool is_line_absolute(int comp_idx);
; 812  :   private: // Helper functions
; 813  :     kdu_line_buf *get_line(kd_multi_line *line, int tgt_row_idx,
; 814  :                            kdu_thread_env *env);
; 815  :       /* Recursive function which does all the work of the public `get_line'
; 816  :          function. */
; 817  :   private: // Data
; 818  :     int *output_row_counters;
; 819  :   };
; 820  : 
; 821  : /*****************************************************************************/
; 822  : /*                             kd_multi_analysis                             */
; 823  : /*****************************************************************************/
; 824  : 
; 825  : class kd_multi_analysis : public kd_multi_analysis_base,
; 826  :                           public kd_multi_transform {
; 827  :   public: // Member functions
; 828  :     kd_multi_analysis() { source_row_counters=NULL; }

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_analysis@@6Bkd_multi_analysis_base@@@
	mov	DWORD PTR [ecx+4], OFFSET ??_7kd_multi_analysis@@6Bkd_multi_transform@@@
	mov	DWORD PTR [ecx+80], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp

; 1230 :   kd_multi_analysis *obj = new kd_multi_analysis;

	jmp	SHORT $LN5@create
$LN4@create:
	xor	ecx, ecx
$LN5@create:

; 1231 :   state = obj;
; 1232 :   if (processing_stripe_height < 1)
; 1233 :     processing_stripe_height = 1;
; 1234 :   return obj->create(codestream,tile,force_precise,roi,want_fastest,

	push	DWORD PTR _double_buffering$[ebp]
	mov	eax, DWORD PTR _processing_stripe_height$[ebp]
	mov	edx, 1
	push	DWORD PTR _env_queue$[ebp]
	cmp	eax, edx
	mov	DWORD PTR [esi], ecx
	push	DWORD PTR _env$[ebp]
	cmovl	eax, edx
	push	eax
	push	DWORD PTR _want_fastest$[ebp]
	push	DWORD PTR _roi$[ebp]
	push	DWORD PTR _force_precise$[ebp]
	push	DWORD PTR _tile$[ebp]
	push	DWORD PTR _codestream$[ebp]
	call	?create@kd_multi_analysis@@QAE_JVkdu_codestream@@Vkdu_tile@@_NPAVkdu_roi_image@@2HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ; kd_multi_analysis::create
	pop	esi

; 1235 :                      processing_stripe_height,env,env_queue,
; 1236 :                      double_buffering);
; 1237 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?create@kdu_multi_analysis@@QAE_JVkdu_codestream@@Vkdu_tile@@_NPAVkdu_roi_image@@2HPAVkdu_thread_env@@PAUkdu_thread_queue@@2@Z ENDP ; kdu_multi_analysis::create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??_Gkd_multi_analysis_base@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_multi_analysis_base@@UAEPAXI@Z PROC		; kd_multi_analysis_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 1260 :     virtual ~kd_multi_analysis_base() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kd_multi_analysis_base@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_multi_analysis_base@@UAEPAXI@Z ENDP		; kd_multi_analysis_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0kd_multi_analysis_base@@QAE@XZ
_TEXT	SEGMENT
??0kd_multi_analysis_base@@QAE@XZ PROC			; kd_multi_analysis_base::kd_multi_analysis_base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_analysis_base@@6B@
	mov	eax, ecx
	ret	0
??0kd_multi_analysis_base@@QAE@XZ ENDP			; kd_multi_analysis_base::kd_multi_analysis_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??1kd_multi_analysis_base@@UAE@XZ
_TEXT	SEGMENT
??1kd_multi_analysis_base@@UAE@XZ PROC			; kd_multi_analysis_base::~kd_multi_analysis_base, COMDAT
; _this$ = ecx

; 1260 :     virtual ~kd_multi_analysis_base() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kd_multi_analysis_base@@6B@
	ret	0
??1kd_multi_analysis_base@@UAE@XZ ENDP			; kd_multi_analysis_base::~kd_multi_analysis_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?pull@kdu_pull_ifc@@QAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_line$ = 8						; size = 4
_env$ = 12						; size = 4
?pull@kdu_pull_ifc@@QAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z PROC ; kdu_pull_ifc::pull, COMDAT
; _this$ = ecx

; 766  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 767  :              Fills out the supplied `line' buffer's sample values before
; 768  :              returning.
; 769  :            [ARG: env]
; 770  :              If the object was constructed for multi-threaded processing
; 771  :              (see the constructors for `kdu_synthesis' and `kdu_decoder'),
; 772  :              you MUST pass a non-NULL `env' argument in here, identifying
; 773  :              the thread which is performing the `pull' call.  Otherwise,
; 774  :              the `env' argument should be ignored.
; 775  :         */
; 776  :         state->pull(line,env);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]

; 777  :       }

	pop	ebp

; 767  :              Fills out the supplied `line' buffer's sample values before
; 768  :              returning.
; 769  :            [ARG: env]
; 770  :              If the object was constructed for multi-threaded processing
; 771  :              (see the constructors for `kdu_synthesis' and `kdu_decoder'),
; 772  :              you MUST pass a non-NULL `env' argument in here, identifying
; 773  :              the thread which is performing the `pull' call.  Otherwise,
; 774  :              the `env' argument should be ignored.
; 775  :         */
; 776  :         state->pull(line,env);

	jmp	DWORD PTR [eax+8]
?pull@kdu_pull_ifc@@QAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z ENDP ; kdu_pull_ifc::pull
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??4kdu_pull_ifc@@QAEAAV0@Vkdu_decoder@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4kdu_pull_ifc@@QAEAAV0@Vkdu_decoder@@@Z PROC		; kdu_pull_ifc::operator=, COMDAT
; _this$ = ecx

; 2055 :   { state = rhs.state; return *this; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4kdu_pull_ifc@@QAEAAV0@Vkdu_decoder@@@Z ENDP		; kdu_pull_ifc::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??4kdu_pull_ifc@@QAEAAV0@Vkdu_synthesis@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4kdu_pull_ifc@@QAEAAV0@Vkdu_synthesis@@@Z PROC	; kdu_pull_ifc::operator=, COMDAT
; _this$ = ecx

; 2053 :   { state = rhs.state; return *this; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4kdu_pull_ifc@@QAEAAV0@Vkdu_synthesis@@@Z ENDP	; kdu_pull_ifc::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?exists@kdu_pull_ifc@@QAE_NXZ
_TEXT	SEGMENT
?exists@kdu_pull_ifc@@QAE_NXZ PROC			; kdu_pull_ifc::exists, COMDAT
; _this$ = ecx

; 741  :     bool exists() { return (state==NULL)?false:true; }

	cmp	DWORD PTR [ecx], 0
	setne	al
	ret	0
?exists@kdu_pull_ifc@@QAE_NXZ ENDP			; kdu_pull_ifc::exists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?start@kdu_pull_ifc@@QAEXPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_env$ = 8						; size = 4
?start@kdu_pull_ifc@@QAEXPAVkdu_thread_env@@@Z PROC	; kdu_pull_ifc::start, COMDAT
; _this$ = ecx

; 714  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 715  :              This function may be called at any point after construction
; 716  :              of a `kdu_synthesis' or `kdu_decoder' object, once you have
; 717  :              invoked the `kdu_sample_allocator::finalize' function on the
; 718  :              `kdu_sample_allocator' object used during construction.  In
; 719  :              particular, this means that you will not be creating any
; 720  :              further objects to share the storage offered by the sample
; 721  :              allocator.
; 722  :              [//]
; 723  :              It is never necessary to call this function, since it will be
; 724  :              invoked automatically, if required, when `pull' is first called.
; 725  :              Indeed for applications which are not multi-threaded (i.e.,
; 726  :              when `env' is NULL) it is pretty pointless to call this function,
; 727  :              but you can if you like.
; 728  :              [//]
; 729  :              For multi-threaded applications (i.e., when `env' is non-NULL),
; 730  :              this function enables you to get the most benefit from
; 731  :              multi-threading, since it allows the code-block processing
; 732  :              associated with any number of tile-component-subbands to be
; 733  :              started immediately.  By contrast, the `pull' function will
; 734  :              not be invoked on a subband's `kdu_decoder' object until
; 735  :              dependencies have been satisfied in other subbands, which
; 736  :              cannot generally happen until a full row of code-blocks have
; 737  :              been decoded in a first subband.
; 738  :         */
; 739  :         state->start(env);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]

; 740  :       }

	pop	ebp

; 715  :              This function may be called at any point after construction
; 716  :              of a `kdu_synthesis' or `kdu_decoder' object, once you have
; 717  :              invoked the `kdu_sample_allocator::finalize' function on the
; 718  :              `kdu_sample_allocator' object used during construction.  In
; 719  :              particular, this means that you will not be creating any
; 720  :              further objects to share the storage offered by the sample
; 721  :              allocator.
; 722  :              [//]
; 723  :              It is never necessary to call this function, since it will be
; 724  :              invoked automatically, if required, when `pull' is first called.
; 725  :              Indeed for applications which are not multi-threaded (i.e.,
; 726  :              when `env' is NULL) it is pretty pointless to call this function,
; 727  :              but you can if you like.
; 728  :              [//]
; 729  :              For multi-threaded applications (i.e., when `env' is non-NULL),
; 730  :              this function enables you to get the most benefit from
; 731  :              multi-threading, since it allows the code-block processing
; 732  :              associated with any number of tile-component-subbands to be
; 733  :              started immediately.  By contrast, the `pull' function will
; 734  :              not be invoked on a subband's `kdu_decoder' object until
; 735  :              dependencies have been satisfied in other subbands, which
; 736  :              cannot generally happen until a full row of code-blocks have
; 737  :              been decoded in a first subband.
; 738  :         */
; 739  :         state->start(env);

	jmp	DWORD PTR [eax+4]
?start@kdu_pull_ifc@@QAEXPAVkdu_thread_env@@@Z ENDP	; kdu_pull_ifc::start
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?destroy@kdu_pull_ifc@@QAEXXZ
_TEXT	SEGMENT
?destroy@kdu_pull_ifc@@QAEXXZ PROC			; kdu_pull_ifc::destroy, COMDAT
; _this$ = ecx

; 703  :       {

	push	esi
	mov	esi, ecx

; 704  :         if (state != NULL) delete state;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@destroy
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN6@destroy:

; 705  :         state = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 706  :       }

	ret	0
?destroy@kdu_pull_ifc@@QAEXXZ ENDP			; kdu_pull_ifc::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??0kdu_pull_ifc@@QAE@XZ
_TEXT	SEGMENT
??0kdu_pull_ifc@@QAE@XZ PROC				; kdu_pull_ifc::kdu_pull_ifc, COMDAT
; _this$ = ecx

; 696  :     kdu_pull_ifc() { state = NULL; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0kdu_pull_ifc@@QAE@XZ ENDP				; kdu_pull_ifc::kdu_pull_ifc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?push@kdu_push_ifc@@QAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_line$ = 8						; size = 4
_env$ = 12						; size = 4
?push@kdu_push_ifc@@QAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z PROC ; kdu_push_ifc::push, COMDAT
; _this$ = ecx

; 641  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 642  :              Delivers all samples from the `line' buffer across the interface.
; 643  :            [ARG: env]
; 644  :              If the object was constructed for multi-threaded processing
; 645  :              (see the constructors for `kdu_analysis' and `kdu_encoder'),
; 646  :              you MUST pass a non-NULL `env' argument in here, identifying
; 647  :              the thread which is performing the `push' call.  Otherwise,
; 648  :              the `env' argument should be ignored.
; 649  :         */
; 650  :         state->push(line,env);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]

; 651  :       }

	pop	ebp

; 642  :              Delivers all samples from the `line' buffer across the interface.
; 643  :            [ARG: env]
; 644  :              If the object was constructed for multi-threaded processing
; 645  :              (see the constructors for `kdu_analysis' and `kdu_encoder'),
; 646  :              you MUST pass a non-NULL `env' argument in here, identifying
; 647  :              the thread which is performing the `push' call.  Otherwise,
; 648  :              the `env' argument should be ignored.
; 649  :         */
; 650  :         state->push(line,env);

	jmp	DWORD PTR [eax+4]
?push@kdu_push_ifc@@QAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z ENDP ; kdu_push_ifc::push
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??4kdu_push_ifc@@QAEAAV0@Vkdu_encoder@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4kdu_push_ifc@@QAEAAV0@Vkdu_encoder@@@Z PROC		; kdu_push_ifc::operator=, COMDAT
; _this$ = ecx

; 2050 :   { state = rhs.state; return *this; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4kdu_push_ifc@@QAEAAV0@Vkdu_encoder@@@Z ENDP		; kdu_push_ifc::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??4kdu_push_ifc@@QAEAAV0@Vkdu_analysis@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4kdu_push_ifc@@QAEAAV0@Vkdu_analysis@@@Z PROC		; kdu_push_ifc::operator=, COMDAT
; _this$ = ecx

; 2048 :   { state = rhs.state; return *this; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4kdu_push_ifc@@QAEAAV0@Vkdu_analysis@@@Z ENDP		; kdu_push_ifc::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?exists@kdu_push_ifc@@QAE_NXZ
_TEXT	SEGMENT
?exists@kdu_push_ifc@@QAE_NXZ PROC			; kdu_push_ifc::exists, COMDAT
; _this$ = ecx

; 616  :     bool exists() { return (state==NULL)?false:true; }

	cmp	DWORD PTR [ecx], 0
	setne	al
	ret	0
?exists@kdu_push_ifc@@QAE_NXZ ENDP			; kdu_push_ifc::exists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?destroy@kdu_push_ifc@@QAEXXZ
_TEXT	SEGMENT
?destroy@kdu_push_ifc@@QAEXXZ PROC			; kdu_push_ifc::destroy, COMDAT
; _this$ = ecx

; 605  :       {

	push	esi
	mov	esi, ecx

; 606  :         if (state != NULL) delete state;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@destroy
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN6@destroy:

; 607  :         state = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 608  :       }

	ret	0
?destroy@kdu_push_ifc@@QAEXXZ ENDP			; kdu_push_ifc::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??0kdu_push_ifc@@QAE@XZ
_TEXT	SEGMENT
??0kdu_push_ifc@@QAE@XZ PROC				; kdu_push_ifc::kdu_push_ifc, COMDAT
; _this$ = ecx

; 598  :     kdu_push_ifc() { state = NULL; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0kdu_push_ifc@@QAE@XZ ENDP				; kdu_push_ifc::kdu_push_ifc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_width@kdu_line_buf@@QAEHXZ
_TEXT	SEGMENT
?get_width@kdu_line_buf@@QAEHXZ PROC			; kdu_line_buf::get_width, COMDAT
; _this$ = ecx

; 537  :       /* [SYNOPSIS]
; 538  :            Returns 0 if the object has not been created.  Otherwise, returns
; 539  :            the nominal width of the line.  Remember that the arrays returned
; 540  :            by `get_buf16' and `get_buf32' are typically larger than the actual
; 541  :            line width, as explained in the comments appearing with the
; 542  :            `pre_create' function.
; 543  :       */
; 544  :         return width;

	mov	eax, DWORD PTR [ecx]

; 545  :       }

	ret	0
?get_width@kdu_line_buf@@QAEHXZ ENDP			; kdu_line_buf::get_width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ
_TEXT	SEGMENT
?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ PROC	; kdu_line_buf::get_buf16, COMDAT
; _this$ = ecx

; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN3@get_buf16
	mov	eax, DWORD PTR [ecx+8]

; 414  :       }

	ret	0
$LN3@get_buf16:

; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	xor	eax, eax

; 414  :       }

	ret	0
?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ ENDP	; kdu_line_buf::get_buf16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ
_TEXT	SEGMENT
?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ PROC	; kdu_line_buf::get_buf32, COMDAT
; _this$ = ecx

; 393  :       /* [SYNOPSIS]
; 394  :            Returns NULL if the sample values are of type `kdu_sample16'
; 395  :            instead of `kdu_sample32', or the buffer has not yet been
; 396  :            created.  Otherwise, returns an array which supports accesses
; 397  :            at least with indices in the range 0 to `width'-1, but typically
; 398  :            beyond these bounds -- see `pre_create' for an explanation of
; 399  :            extended access bounds.
; 400  :       */
; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN3@get_buf32
	xor	eax, eax

; 402  :       }

	ret	0
$LN3@get_buf32:

; 393  :       /* [SYNOPSIS]
; 394  :            Returns NULL if the sample values are of type `kdu_sample16'
; 395  :            instead of `kdu_sample32', or the buffer has not yet been
; 396  :            created.  Otherwise, returns an array which supports accesses
; 397  :            at least with indices in the range 0 to `width'-1, but typically
; 398  :            beyond these bounds -- see `pre_create' for an explanation of
; 399  :            extended access bounds.
; 400  :       */
; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	eax, DWORD PTR [ecx+8]

; 402  :       }

	ret	0
?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ ENDP	; kdu_line_buf::get_buf32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?destroy@kdu_line_buf@@QAEXXZ
_TEXT	SEGMENT
?destroy@kdu_line_buf@@QAEXXZ PROC			; kdu_line_buf::destroy, COMDAT
; _this$ = ecx

; 380  :       /* [SYNOPSIS]
; 381  :            Restores the object to its uninitialized state ready for a new
; 382  :            `pre_create' call.  Does not actually destroy any storage, since
; 383  :            the `kdu_sample_allocator' object from which storage is served
; 384  :            does not permit individual deallocation of storage blocks.
; 385  :       */
; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx], 0
	mov	WORD PTR [ecx+6], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx+8], 0

; 388  :       }

	ret	0
?destroy@kdu_line_buf@@QAEXXZ ENDP			; kdu_line_buf::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?create@kdu_line_buf@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?create@kdu_line_buf@@QAEXXZ PROC			; kdu_line_buf::create, COMDAT
; _this$ = ecx

; 361  :       {

	push	ebp
	mov	ebp, esp
	push	ecx

; 362  :       /* [SYNOPSIS]
; 363  :            Finalizes creation of storage which was initiated by `pre_create'.
; 364  :            Does nothing at all if the `pre_create' function was not called,
; 365  :            or the object was previously created and has not been destroyed.
; 366  :            Otherwise, you may not call this function until the
; 367  :            `kdu_sample_allocator' object supplied to `pre_create' has had
; 368  :            its `finalize' member function called.
; 369  :       */
; 370  :         if (!pre_created)

	cmp	BYTE PTR [ecx+7], 0
	mov	DWORD PTR _this$1$[ebp], ecx
	je	SHORT $LN4@create

; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)

	test	BYTE PTR [ecx+6], 2
	push	ebx

; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);

	mov	ebx, DWORD PTR [ecx+8]
	push	esi
	mov	BYTE PTR [ecx+7], 0
	push	edi
	movzx	edi, BYTE PTR [ecx+4]

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.
; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+16]

; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);

	movzx	ecx, BYTE PTR [ecx+5]
	je	SHORT $LN3@create

; 217  :         before = (before+7)&~7; // Round up to nearest multiple of 16 bytes.

	add	edi, 7
	and	edi, -8					; fffffff8H

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.
; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	lea	esi, DWORD PTR [eax+edi*2]
	mov	eax, DWORD PTR _this$1$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR [eax]
	add	eax, 7
	add	eax, ecx
	and	eax, -8					; fffffff8H
	add	eax, edi
	pop	edi
	lea	eax, DWORD PTR [edx+eax*2]

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.
; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	DWORD PTR [ebx+8], eax

; 375  :         else
; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [eax+8], esi
	pop	esi
	pop	ebx

; 377  :       }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@create:

; 221  :         assert(bytes_used <= bytes_reserved);
; 222  :         return result;
; 223  :       }
; 224  :     kdu_sample32 *alloc32(int before, int after)
; 225  :       {
; 226  :       /* [SYNOPSIS]
; 227  :            Same as `alloc16', except that it allocates storage for arrays of
; 228  :            32-bit quantities.  Again, the returned pointer is guaranteed to
; 229  :            be aligned on a 16-byte boundary.
; 230  :       */
; 231  :         assert(!pre_creation_phase);
; 232  :         before = (before+3)&~3; // Round up to nearest multiple of 16 bytes.

	add	edi, 3
	and	edi, -4					; fffffffcH

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.
; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	lea	esi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _this$1$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR [eax]
	add	eax, 3
	add	eax, ecx
	and	eax, -4					; fffffffcH
	add	eax, edi
	pop	edi
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ebx+8], eax

; 375  :         else
; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [eax+8], esi
	pop	esi
	pop	ebx
$LN4@create:

; 377  :       }

	mov	esp, ebp
	pop	ebp
	ret	0
?create@kdu_line_buf@@QAEXXZ ENDP			; kdu_line_buf::create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z
_TEXT	SEGMENT
_allocator$ = 8						; size = 4
_width$ = 12						; size = 4
_absolute$ = 16						; size = 1
_use_shorts$ = 20					; size = 1
_extend_left$ = 24					; size = 4
_extend_right$ = 28					; size = 4
?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z PROC ; kdu_line_buf::pre_create, COMDAT
; _this$ = ecx

; 294  :       {

	push	ebp
	mov	ebp, esp

; 295  :       /* [SYNOPSIS]
; 296  :            Declares the characteristics of the internal storage which will
; 297  :            later be created by `create'.  If `use_shorts' is true, the sample
; 298  :            values will have 16 bits each and normalized values will use a
; 299  :            fixed point representation with KDU_FIX_POINT fraction bits.
; 300  :            Otherwise, the sample values have 32 bits each and normalized
; 301  :            values use a true floating point representation.
; 302  :            [//]
; 303  :            This function essentially calls `allocator->pre_create', requesting
; 304  :            enough storage for a line with `width' samples, providing for legal
; 305  :            accesses up to `extend_left' samples before the beginning of the
; 306  :            line and `extend_right' samples beyond the end of the line.
; 307  :            [//]
; 308  :            Moreover, the returned line buffer is aligned on a 16-byte
; 309  :            boundary, the `extend_left' and `extend_right' values are rounded
; 310  :            up to the nearest multiple of 16 bytes, and the length of the
; 311  :            right-extended buffer is also rounded up to a multiple of 16 bytes.
; 312  :            Finally, it is possible to read at least 16 bytes beyond the
; 313  :            end of the extended region, although writes to these extra 16
; 314  :            bytes might overwrite data belonging to a different line.
; 315  :          [ARG: allocator]
; 316  :            Pointer to the object which will later be used to complete the
; 317  :            allocation of storage for the line.  The pointer is saved
; 318  :            internally until such time as the `create' function is called, so
; 319  :            you must be careful not to delete this object.  You must also be
; 320  :            careful to call its `kdu_sample_allocator::finalize' function
; 321  :            before calling `create'.
; 322  :          [ARG: width]
; 323  :            Nominal width of (number of samples in) the line.  Note that space
; 324  :            reserved for access to `extend_left' samples to the left and
; 325  :            `extend_right' samples to the right.  Moreover, additional
; 326  :            samples may often be accessed to the left and right of the nominal
; 327  :            line boundaries due to the alignment policy discussed above.
; 328  :          [ARG: absolute]
; 329  :            If true, the sample values in the line buffer are to be used in
; 330  :            JPEG2000's reversible processing path, which works with absolute
; 331  :            integers.  otherwise, the line is prepared for use with the
; 332  :            irreversible processing path, which works with normalized
; 333  :            (floating or fixed point) quantities.
; 334  :          [ARG: use_shorts]
; 335  :            If true, space is allocated for 16-bit sample values
; 336  :            (array entries will be of type `kdu_sample16').  Otherwise, the
; 337  :            line buffer will hold samples of type `kdu_sample32'.
; 338  :          [ARG: extend_left]
; 339  :            This quantity should be small, since it will be represented
; 340  :            internally using 8-bit numbers, after rounding up to an
; 341  :            appropriately aligned value.  It would be unusual to select
; 342  :            values larger than 16 or perhaps 32.
; 343  :          [ARG: extend_right]
; 344  :            This quantity should be small, since it will be represented
; 345  :            internally using 8-bit numbers, after rounding up to an
; 346  :            appropriately aligned value.  It would be unusual to select
; 347  :            values larger than 16 or perhaps 32.
; 348  :       */
; 349  :         assert((!pre_created) && (this->allocator == NULL)); this->width=width;
; 350  :         flags = (use_shorts)?KD_LINE_BUF_SHORTS:0; 
; 351  :         flags |= (absolute)?KD_LINE_BUF_ABSOLUTE:0;

	cmp	BYTE PTR _absolute$[ebp], 0
	mov	eax, DWORD PTR _width$[ebp]
	push	ebx
	setne	dl
	push	esi
	mov	esi, ecx
	mov	cl, BYTE PTR _use_shorts$[ebp]
	push	edi

; 352  :         this->allocator = allocator;

	mov	edi, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [esi], eax
	mov	al, cl
	neg	al
	mov	DWORD PTR [esi+8], edi
	sbb	al, al
	and	al, 2
	or	dl, al

; 353  :         buf_before = (kdu_byte) extend_left; // Rounded up automatically
; 354  :         buf_after = (kdu_byte)

	test	cl, cl
	mov	ecx, DWORD PTR _extend_right$[ebp]
	mov	al, cl
	setne	bl
	mov	BYTE PTR [esi+6], dl
	mov	edx, DWORD PTR _extend_left$[ebp]
	neg	al
	mov	BYTE PTR [esi+4], dl
	lea	ebx, DWORD PTR [ebx*4+3]
	and	bl, al
	add	bl, cl

; 355  :           (extend_right + ((-extend_right) & ((use_shorts)?7:3)));
; 356  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);

	movzx	ecx, dl

; 180  :         if (!use_shorts)

	mov	dl, BYTE PTR _use_shorts$[ebp]
	add	ecx, ecx

; 355  :           (extend_right + ((-extend_right) & ((use_shorts)?7:3)));
; 356  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);

	movzx	eax, bl
	mov	BYTE PTR [esi+5], bl

; 179  :         before+=before; after+=after; // Two bytes per sample

	mov	ebx, DWORD PTR _width$[ebp]
	add	eax, ebx
	add	eax, eax

; 180  :         if (!use_shorts)

	test	dl, dl
	jne	SHORT $LN4@pre_create

; 181  :           { before+=before; after+=after; } // Four bytes per sample

	add	ecx, ecx
	add	eax, eax
$LN4@pre_create:

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	ecx, 15					; 0000000fH
	add	eax, 15					; 0000000fH
	and	eax, -16				; fffffff0H
	and	ecx, -16				; fffffff0H
	add	ecx, eax
	add	DWORD PTR [edi+4], ecx

; 357  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);

	movzx	eax, BYTE PTR [esi+5]
	movzx	ecx, BYTE PTR [esi+4]

; 179  :         before+=before; after+=after; // Two bytes per sample

	add	eax, ebx
	add	ecx, ecx
	add	eax, eax

; 180  :         if (!use_shorts)

	test	dl, dl
	jne	SHORT $LN7@pre_create

; 181  :           { before+=before; after+=after; } // Four bytes per sample

	add	ecx, ecx
	add	eax, eax
$LN7@pre_create:

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	ecx, 15					; 0000000fH
	add	eax, 15					; 0000000fH
	and	ecx, -16				; fffffff0H
	and	eax, -16				; fffffff0H
	add	ecx, DWORD PTR [edi+4]
	add	eax, ecx
	mov	DWORD PTR [edi+4], eax
	pop	edi

; 358  :         pre_created = true;

	mov	BYTE PTR [esi+7], 1
	pop	esi
	pop	ebx

; 359  :       }

	pop	ebp
	ret	24					; 00000018H
?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ENDP ; kdu_line_buf::pre_create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??0kdu_line_buf@@QAE@XZ
_TEXT	SEGMENT
??0kdu_line_buf@@QAE@XZ PROC				; kdu_line_buf::kdu_line_buf, COMDAT
; _this$ = ecx

; 291  :     void pre_create(kdu_sample_allocator *allocator,
; 292  :                     int width, bool absolute, bool use_shorts,
; 293  :                     int extend_left=2, int extend_right=2)
; 294  :       {
; 295  :       /* [SYNOPSIS]
; 296  :            Declares the characteristics of the internal storage which will
; 297  :            later be created by `create'.  If `use_shorts' is true, the sample
; 298  :            values will have 16 bits each and normalized values will use a
; 299  :            fixed point representation with KDU_FIX_POINT fraction bits.
; 300  :            Otherwise, the sample values have 32 bits each and normalized
; 301  :            values use a true floating point representation.
; 302  :            [//]
; 303  :            This function essentially calls `allocator->pre_create', requesting
; 304  :            enough storage for a line with `width' samples, providing for legal
; 305  :            accesses up to `extend_left' samples before the beginning of the
; 306  :            line and `extend_right' samples beyond the end of the line.
; 307  :            [//]
; 308  :            Moreover, the returned line buffer is aligned on a 16-byte
; 309  :            boundary, the `extend_left' and `extend_right' values are rounded
; 310  :            up to the nearest multiple of 16 bytes, and the length of the
; 311  :            right-extended buffer is also rounded up to a multiple of 16 bytes.
; 312  :            Finally, it is possible to read at least 16 bytes beyond the
; 313  :            end of the extended region, although writes to these extra 16
; 314  :            bytes might overwrite data belonging to a different line.
; 315  :          [ARG: allocator]
; 316  :            Pointer to the object which will later be used to complete the
; 317  :            allocation of storage for the line.  The pointer is saved
; 318  :            internally until such time as the `create' function is called, so
; 319  :            you must be careful not to delete this object.  You must also be
; 320  :            careful to call its `kdu_sample_allocator::finalize' function
; 321  :            before calling `create'.
; 322  :          [ARG: width]
; 323  :            Nominal width of (number of samples in) the line.  Note that space
; 324  :            reserved for access to `extend_left' samples to the left and
; 325  :            `extend_right' samples to the right.  Moreover, additional
; 326  :            samples may often be accessed to the left and right of the nominal
; 327  :            line boundaries due to the alignment policy discussed above.
; 328  :          [ARG: absolute]
; 329  :            If true, the sample values in the line buffer are to be used in
; 330  :            JPEG2000's reversible processing path, which works with absolute
; 331  :            integers.  otherwise, the line is prepared for use with the
; 332  :            irreversible processing path, which works with normalized
; 333  :            (floating or fixed point) quantities.
; 334  :          [ARG: use_shorts]
; 335  :            If true, space is allocated for 16-bit sample values
; 336  :            (array entries will be of type `kdu_sample16').  Otherwise, the
; 337  :            line buffer will hold samples of type `kdu_sample32'.
; 338  :          [ARG: extend_left]
; 339  :            This quantity should be small, since it will be represented
; 340  :            internally using 8-bit numbers, after rounding up to an
; 341  :            appropriately aligned value.  It would be unusual to select
; 342  :            values larger than 16 or perhaps 32.
; 343  :          [ARG: extend_right]
; 344  :            This quantity should be small, since it will be represented
; 345  :            internally using 8-bit numbers, after rounding up to an
; 346  :            appropriately aligned value.  It would be unusual to select
; 347  :            values larger than 16 or perhaps 32.
; 348  :       */
; 349  :         assert((!pre_created) && (this->allocator == NULL)); this->width=width;
; 350  :         flags = (use_shorts)?KD_LINE_BUF_SHORTS:0; 
; 351  :         flags |= (absolute)?KD_LINE_BUF_ABSOLUTE:0;
; 352  :         this->allocator = allocator;
; 353  :         buf_before = (kdu_byte) extend_left; // Rounded up automatically
; 354  :         buf_after = (kdu_byte)
; 355  :           (extend_right + ((-extend_right) & ((use_shorts)?7:3)));
; 356  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);
; 357  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);
; 358  :         pre_created = true;
; 359  :       }
; 360  :     void create()
; 361  :       {
; 362  :       /* [SYNOPSIS]
; 363  :            Finalizes creation of storage which was initiated by `pre_create'.
; 364  :            Does nothing at all if the `pre_create' function was not called,
; 365  :            or the object was previously created and has not been destroyed.
; 366  :            Otherwise, you may not call this function until the
; 367  :            `kdu_sample_allocator' object supplied to `pre_create' has had
; 368  :            its `finalize' member function called.
; 369  :       */
; 370  :         if (!pre_created)
; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)
; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);
; 375  :         else
; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);
; 377  :       }
; 378  :     void destroy()
; 379  :       {
; 380  :       /* [SYNOPSIS]
; 381  :            Restores the object to its uninitialized state ready for a new
; 382  :            `pre_create' call.  Does not actually destroy any storage, since
; 383  :            the `kdu_sample_allocator' object from which storage is served
; 384  :            does not permit individual deallocation of storage blocks.
; 385  :       */
; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx], 0

; 290  :     kdu_line_buf() { destroy(); }

	mov	eax, ecx

; 291  :     void pre_create(kdu_sample_allocator *allocator,
; 292  :                     int width, bool absolute, bool use_shorts,
; 293  :                     int extend_left=2, int extend_right=2)
; 294  :       {
; 295  :       /* [SYNOPSIS]
; 296  :            Declares the characteristics of the internal storage which will
; 297  :            later be created by `create'.  If `use_shorts' is true, the sample
; 298  :            values will have 16 bits each and normalized values will use a
; 299  :            fixed point representation with KDU_FIX_POINT fraction bits.
; 300  :            Otherwise, the sample values have 32 bits each and normalized
; 301  :            values use a true floating point representation.
; 302  :            [//]
; 303  :            This function essentially calls `allocator->pre_create', requesting
; 304  :            enough storage for a line with `width' samples, providing for legal
; 305  :            accesses up to `extend_left' samples before the beginning of the
; 306  :            line and `extend_right' samples beyond the end of the line.
; 307  :            [//]
; 308  :            Moreover, the returned line buffer is aligned on a 16-byte
; 309  :            boundary, the `extend_left' and `extend_right' values are rounded
; 310  :            up to the nearest multiple of 16 bytes, and the length of the
; 311  :            right-extended buffer is also rounded up to a multiple of 16 bytes.
; 312  :            Finally, it is possible to read at least 16 bytes beyond the
; 313  :            end of the extended region, although writes to these extra 16
; 314  :            bytes might overwrite data belonging to a different line.
; 315  :          [ARG: allocator]
; 316  :            Pointer to the object which will later be used to complete the
; 317  :            allocation of storage for the line.  The pointer is saved
; 318  :            internally until such time as the `create' function is called, so
; 319  :            you must be careful not to delete this object.  You must also be
; 320  :            careful to call its `kdu_sample_allocator::finalize' function
; 321  :            before calling `create'.
; 322  :          [ARG: width]
; 323  :            Nominal width of (number of samples in) the line.  Note that space
; 324  :            reserved for access to `extend_left' samples to the left and
; 325  :            `extend_right' samples to the right.  Moreover, additional
; 326  :            samples may often be accessed to the left and right of the nominal
; 327  :            line boundaries due to the alignment policy discussed above.
; 328  :          [ARG: absolute]
; 329  :            If true, the sample values in the line buffer are to be used in
; 330  :            JPEG2000's reversible processing path, which works with absolute
; 331  :            integers.  otherwise, the line is prepared for use with the
; 332  :            irreversible processing path, which works with normalized
; 333  :            (floating or fixed point) quantities.
; 334  :          [ARG: use_shorts]
; 335  :            If true, space is allocated for 16-bit sample values
; 336  :            (array entries will be of type `kdu_sample16').  Otherwise, the
; 337  :            line buffer will hold samples of type `kdu_sample32'.
; 338  :          [ARG: extend_left]
; 339  :            This quantity should be small, since it will be represented
; 340  :            internally using 8-bit numbers, after rounding up to an
; 341  :            appropriately aligned value.  It would be unusual to select
; 342  :            values larger than 16 or perhaps 32.
; 343  :          [ARG: extend_right]
; 344  :            This quantity should be small, since it will be represented
; 345  :            internally using 8-bit numbers, after rounding up to an
; 346  :            appropriately aligned value.  It would be unusual to select
; 347  :            values larger than 16 or perhaps 32.
; 348  :       */
; 349  :         assert((!pre_created) && (this->allocator == NULL)); this->width=width;
; 350  :         flags = (use_shorts)?KD_LINE_BUF_SHORTS:0; 
; 351  :         flags |= (absolute)?KD_LINE_BUF_ABSOLUTE:0;
; 352  :         this->allocator = allocator;
; 353  :         buf_before = (kdu_byte) extend_left; // Rounded up automatically
; 354  :         buf_after = (kdu_byte)
; 355  :           (extend_right + ((-extend_right) & ((use_shorts)?7:3)));
; 356  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);
; 357  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);
; 358  :         pre_created = true;
; 359  :       }
; 360  :     void create()
; 361  :       {
; 362  :       /* [SYNOPSIS]
; 363  :            Finalizes creation of storage which was initiated by `pre_create'.
; 364  :            Does nothing at all if the `pre_create' function was not called,
; 365  :            or the object was previously created and has not been destroyed.
; 366  :            Otherwise, you may not call this function until the
; 367  :            `kdu_sample_allocator' object supplied to `pre_create' has had
; 368  :            its `finalize' member function called.
; 369  :       */
; 370  :         if (!pre_created)
; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)
; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);
; 375  :         else
; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);
; 377  :       }
; 378  :     void destroy()
; 379  :       {
; 380  :       /* [SYNOPSIS]
; 381  :            Restores the object to its uninitialized state ready for a new
; 382  :            `pre_create' call.  Does not actually destroy any storage, since
; 383  :            the `kdu_sample_allocator' object from which storage is served
; 384  :            does not permit individual deallocation of storage blocks.
; 385  :       */
; 386  :         width=0; flags=0; pre_created=false;

	mov	WORD PTR [ecx+6], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx+8], 0

; 290  :     kdu_line_buf() { destroy(); }

	ret	0
??0kdu_line_buf@@QAE@XZ ENDP				; kdu_line_buf::kdu_line_buf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_size@kdu_sample_allocator@@QAEHXZ
_TEXT	SEGMENT
?get_size@kdu_sample_allocator@@QAEHXZ PROC		; kdu_sample_allocator::get_size, COMDAT
; _this$ = ecx

; 241  :       /* [SYNOPSIS]
; 242  :            For memory consumption statistics.  Returns the total amount of
; 243  :            heap memory allocated by this object.  The heap memory is allocated
; 244  :            within calls to `finalize'; it either grows or stays the same in
; 245  :            each successive call to `finalize', such calls being interspersed
; 246  :            by invocations of the `restart' member.
; 247  :       */
; 248  :         return buffer_size;

	mov	eax, DWORD PTR [ecx+12]

; 249  :       }

	ret	0
?get_size@kdu_sample_allocator@@QAEHXZ ENDP		; kdu_sample_allocator::get_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z
_TEXT	SEGMENT
_before$ = 8						; size = 4
_after$ = 12						; size = 4
?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z PROC ; kdu_sample_allocator::alloc32, COMDAT
; _this$ = ecx

; 225  :       {

	push	ebp
	mov	ebp, esp
	push	esi

; 226  :       /* [SYNOPSIS]
; 227  :            Same as `alloc16', except that it allocates storage for arrays of
; 228  :            32-bit quantities.  Again, the returned pointer is guaranteed to
; 229  :            be aligned on a 16-byte boundary.
; 230  :       */
; 231  :         assert(!pre_creation_phase);
; 232  :         before = (before+3)&~3; // Round up to nearest multiple of 16 bytes.

	mov	esi, DWORD PTR _before$[ebp]
	push	edi
	mov	edi, ecx
	add	esi, 3

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.

	mov	ecx, DWORD PTR _after$[ebp]
	and	esi, -4					; fffffffcH
	add	ecx, 3
	and	ecx, -4					; fffffffcH

; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+esi*4]
	add	eax, edx
	add	ecx, esi
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [edi+8], ecx
	pop	edi
	pop	esi

; 236  :         assert(bytes_used <= bytes_reserved);
; 237  :         return result;
; 238  :       }

	pop	ebp
	ret	8
?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z ENDP ; kdu_sample_allocator::alloc32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z
_TEXT	SEGMENT
_before$ = 8						; size = 4
_after$ = 12						; size = 4
?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z PROC ; kdu_sample_allocator::alloc16, COMDAT
; _this$ = ecx

; 203  :       {

	push	ebp
	mov	ebp, esp
	push	esi

; 204  :       /* [SYNOPSIS]
; 205  :            Allocate an array with space for `before' entries prior to the
; 206  :            returned pointer and `after' entries after the returned pointer
; 207  :            (including the entry to which the pointer refers).  The returned
; 208  :            pointer is guaranteed to be aligned on a 16-byte boundary.
; 209  :            The pointer may be interpreted as the location of an array which
; 210  :            can accept signed indices, n, in the range -`before' <= n < `after'.
; 211  :            [//]
; 212  :            Before calling this function, you must have pre-allocated sufficient
; 213  :            space through calls to `pre_alloc' and you must have called the
; 214  :            `finalize' member function.
; 215  :       */
; 216  :         assert(!pre_creation_phase);
; 217  :         before = (before+7)&~7; // Round up to nearest multiple of 16 bytes.

	mov	esi, DWORD PTR _before$[ebp]
	push	edi
	mov	edi, ecx
	add	esi, 7

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.

	mov	ecx, DWORD PTR _after$[ebp]
	and	esi, -8					; fffffff8H
	add	ecx, 7
	and	ecx, -8					; fffffff8H

; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+esi*2]
	add	eax, edx
	add	ecx, esi
	lea	ecx, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR [edi+8], ecx
	pop	edi
	pop	esi

; 221  :         assert(bytes_used <= bytes_reserved);
; 222  :         return result;
; 223  :       }

	pop	ebp
	ret	8
?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z ENDP ; kdu_sample_allocator::alloc16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?finalize@kdu_sample_allocator@@QAEXXZ
_TEXT	SEGMENT
?finalize@kdu_sample_allocator@@QAEXXZ PROC		; kdu_sample_allocator::finalize, COMDAT
; _this$ = ecx

; 185  :       {

	push	esi
	mov	esi, ecx

; 186  :       /* [SYNOPSIS]
; 187  :            Call this function after all pre-allocation (calls to `pre_alloc')
; 188  :            has been completed.  It performs the actual allocation of heap
; 189  :            memory, if necessary.
; 190  :       */
; 191  :         assert(pre_creation_phase); pre_creation_phase = false;
; 192  :         if (bytes_reserved > buffer_size)

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [esi], 0
	cmp	eax, DWORD PTR [esi+12]
	jle	SHORT $LN4@finalize

; 193  :           { // Otherwise, use the previously allocated buffer.
; 194  :             buffer_size = bytes_reserved;

	mov	DWORD PTR [esi+12], eax

; 195  :             if (buf_handle != NULL) delete[] buf_handle;

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN3@finalize
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@finalize:

; 196  :             buffer = buf_handle = new kdu_byte[buffer_size+24];

	mov	eax, DWORD PTR [esi+12]
	add	eax, 24					; 00000018H
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+16], eax

; 197  :             if (_addr_to_kdu_int32(buffer) & 8)

	test	al, 8
	je	SHORT $LN4@finalize

; 198  :               buffer += 8; // Align on 16-byte boundary

	add	eax, 8
	mov	DWORD PTR [esi+16], eax
$LN4@finalize:
	pop	esi

; 199  :           }
; 200  :         assert((bytes_reserved == 0) || (buffer != NULL));
; 201  :       }

	ret	0
?finalize@kdu_sample_allocator@@QAEXXZ ENDP		; kdu_sample_allocator::finalize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z
_TEXT	SEGMENT
_use_shorts$ = 8					; size = 1
_before$ = 12						; size = 4
_after$ = 16						; size = 4
_num_requests$ = 20					; size = 4
?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z PROC	; kdu_sample_allocator::pre_alloc, COMDAT
; _this$ = ecx

; 168  :       {

	push	ebp
	mov	ebp, esp

; 169  :       /* [SYNOPSIS]
; 170  :            Reserves enough storage for `num_requests' later calls to `alloc16'
; 171  :            (if `use_shorts' is true) or `alloc32' (if `use_shorts' is false).
; 172  :            Space is reserved such that each of these `num_requests' allocations
; 173  :            can return an appropriately aligned pointer to an array which offers
; 174  :            entries at locations n in the range -`before' <= n < `after', where
; 175  :            each entry is of type `kdu_sample16' (if `use_shorts'=true) or
; 176  :            `kdu_sample32' (if `use_shorts'=false).
; 177  :       */
; 178  :         assert(pre_creation_phase);
; 179  :         before+=before; after+=after; // Two bytes per sample

	mov	eax, DWORD PTR _before$[ebp]
	mov	edx, ecx
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _after$[ebp]
	add	eax, eax

; 180  :         if (!use_shorts)

	cmp	BYTE PTR _use_shorts$[ebp], 0
	jne	SHORT $LN2@pre_alloc

; 181  :           { before+=before; after+=after; } // Four bytes per sample

	add	ecx, ecx
	add	eax, eax
$LN2@pre_alloc:

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	ecx, 15					; 0000000fH
	add	eax, 15					; 0000000fH
	and	ecx, -16				; fffffff0H
	and	eax, -16				; fffffff0H
	add	ecx, eax
	imul	ecx, DWORD PTR _num_requests$[ebp]
	add	DWORD PTR [edx+4], ecx

; 183  :       }

	pop	ebp
	ret	16					; 00000010H
?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z ENDP	; kdu_sample_allocator::pre_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??1kdu_sample_allocator@@QAE@XZ
_TEXT	SEGMENT
??1kdu_sample_allocator@@QAE@XZ PROC			; kdu_sample_allocator::~kdu_sample_allocator, COMDAT
; _this$ = ecx

; 154  :       { if (buf_handle != NULL) delete[] buf_handle; }

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN2@kdu_sample
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN2@kdu_sample:
	ret	0
??1kdu_sample_allocator@@QAE@XZ ENDP			; kdu_sample_allocator::~kdu_sample_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??0kdu_sample_allocator@@QAE@XZ
_TEXT	SEGMENT
??0kdu_sample_allocator@@QAE@XZ PROC			; kdu_sample_allocator::kdu_sample_allocator, COMDAT
; _this$ = ecx

; 150  :       { bytes_reserved = bytes_used = buffer_size = 0;

	mov	DWORD PTR [ecx+12], 0

; 151  :         pre_creation_phase=true; buffer = buf_handle = NULL; }

	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+4], 0
	mov	BYTE PTR [ecx], 1
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+16], 0
	ret	0
??0kdu_sample_allocator@@QAE@XZ ENDP			; kdu_sample_allocator::kdu_sample_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??7kdu_dims@@QAE_NXZ
_TEXT	SEGMENT
??7kdu_dims@@QAE_NXZ PROC				; kdu_dims::operator!, COMDAT
; _this$ = ecx

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR [ecx+12], 0
	jle	SHORT $LN3@operator
	cmp	DWORD PTR [ecx+8], 0
	jle	SHORT $LN3@operator
	xor	al, al
	ret	0
$LN3@operator:
	mov	al, 1
	ret	0
??7kdu_dims@@QAE_NXZ ENDP				; kdu_dims::operator!
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_dims@@QAE@XZ
_TEXT	SEGMENT
??0kdu_dims@@QAE@XZ PROC				; kdu_dims::kdu_dims, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0

; 304  :     kdu_dims() {};

	mov	eax, ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0

; 304  :     kdu_dims() {};

	ret	0
??0kdu_dims@@QAE@XZ ENDP				; kdu_dims::kdu_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??9kdu_coords@@QAE_NABU0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??9kdu_coords@@QAE_NABU0@@Z PROC			; kdu_coords::operator!=, COMDAT
; _this$ = ecx

; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@operator
	xor	al, al
	pop	ebp
	ret	4
$LN3@operator:
	mov	al, 1
	pop	ebp
	ret	4
??9kdu_coords@@QAE_NABU0@@Z ENDP			; kdu_coords::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_coords@@QAE@XZ
_TEXT	SEGMENT
??0kdu_coords@@QAE@XZ PROC				; kdu_coords::kdu_coords, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kdu_coords@@QAE@XZ ENDP				; kdu_coords::kdu_coords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ?get_lifting_factors@kdu_kernels@@QAEPBMAAHAAM1@Z
_TEXT	SEGMENT
_num_steps$ = 8						; size = 4
_dc_scale$ = 12						; size = 4
_nyq_scale$ = 16					; size = 4
?get_lifting_factors@kdu_kernels@@QAEPBMAAHAAM1@Z PROC	; kdu_kernels::get_lifting_factors, COMDAT
; _this$ = ecx

; 246  :         {

	push	ebp
	mov	ebp, esp

; 247  :           num_steps = this->num_steps; dc_scale = this->low_scale;

	mov	eax, DWORD PTR _num_steps$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _dc_scale$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 248  :           nyq_scale = this->high_scale; return lifting_factors;

	mov	eax, DWORD PTR _nyq_scale$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR [ecx+20]

; 249  :         }

	pop	ebp
	ret	12					; 0000000cH
?get_lifting_factors@kdu_kernels@@QAEPBMAAHAAM1@Z ENDP	; kdu_kernels::get_lifting_factors
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ??1kdu_kernels@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kdu_kernels@@QAE@XZ PROC				; kdu_kernels::~kdu_kernels, COMDAT
; _this$ = ecx

; 147  :     ~kdu_kernels() { reset(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kdu_kernels@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	call	?reset@kdu_kernels@@AAEXXZ		; kdu_kernels::reset
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kdu_kernels@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kdu_kernels@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kdu_kernels@@QAE@XZ ENDP				; kdu_kernels::~kdu_kernels
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ??0kdu_kernels@@QAE@XZ
_TEXT	SEGMENT
??0kdu_kernels@@QAE@XZ PROC				; kdu_kernels::kdu_kernels, COMDAT
; _this$ = ecx

; 135  :     kdu_kernels() { clear(); }

	push	esi
	mov	esi, ecx
	call	?clear@kdu_kernels@@AAEXXZ		; kdu_kernels::clear
	mov	eax, esi
	pop	esi
	ret	0
??0kdu_kernels@@QAE@XZ ENDP				; kdu_kernels::kdu_kernels
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ??_Gkdu_worker@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkdu_worker@@UAEPAXI@Z PROC				; kdu_worker::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 106  :     virtual ~kdu_worker() { return; } // Prevent compiler warnings

	mov	DWORD PTR [esi], OFFSET ??_7kdu_worker@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkdu_worker@@UAEPAXI@Z ENDP				; kdu_worker::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0kdu_worker@@QAE@XZ
_TEXT	SEGMENT
??0kdu_worker@@QAE@XZ PROC				; kdu_worker::kdu_worker, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kdu_worker@@6B@
	mov	eax, ecx
	ret	0
??0kdu_worker@@QAE@XZ ENDP				; kdu_worker::kdu_worker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ??1kdu_worker@@UAE@XZ
_TEXT	SEGMENT
??1kdu_worker@@UAE@XZ PROC				; kdu_worker::~kdu_worker, COMDAT
; _this$ = ecx

; 106  :     virtual ~kdu_worker() { return; } // Prevent compiler warnings

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_worker@@6B@
	ret	0
??1kdu_worker@@UAE@XZ ENDP				; kdu_worker::~kdu_worker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@H@Z
_TEXT	SEGMENT
_text$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_val$ = 8						; size = 4
??6kdu_message@@QAEAAV0@H@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 261  :       { char text[80];

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	push	DWORD PTR _val$[ebp]
	mov	esi, ecx
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	BYTE PTR [esi+4], 0
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_sprintf

; 263  :         put_text(text); return *this; }

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _text$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, esi
	push	eax
	call	DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@H@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
??6kdu_message@@QAEAAV0@PBD@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 257  :       { put_text(string); return *this; }

	push	ebp
	mov	ebp, esp
	push	esi
	push	DWORD PTR _string$[ebp]
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@PBD@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1391 : }

	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\visual studio\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\multi_transform.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
