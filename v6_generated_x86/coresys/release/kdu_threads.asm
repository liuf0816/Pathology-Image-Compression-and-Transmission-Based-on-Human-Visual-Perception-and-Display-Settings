; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\threads\kdu_threads.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?unlock@kdu_mutex@@QAE_NXZ			; kdu_mutex::unlock
PUBLIC	??0kdu_event@@QAE@XZ				; kdu_event::kdu_event
PUBLIC	?destroy@kdu_event@@QAE_NXZ			; kdu_event::destroy
PUBLIC	??0kd_thread_lock@@QAE@XZ			; kd_thread_lock::kd_thread_lock
PUBLIC	??0kdu_thread_entity@@QAE@XZ			; kdu_thread_entity::kdu_thread_entity
PUBLIC	??1kdu_thread_entity@@UAE@XZ			; kdu_thread_entity::~kdu_thread_entity
PUBLIC	??2kdu_thread_entity@@SAPAXI@Z			; kdu_thread_entity::operator new
PUBLIC	??3kdu_thread_entity@@SAXPAX@Z			; kdu_thread_entity::operator delete
PUBLIC	?new_instance@kdu_thread_entity@@UAEPAV1@XZ	; kdu_thread_entity::new_instance
PUBLIC	?get_current_thread_entity@kdu_thread_entity@@QAEPAV1@XZ ; kdu_thread_entity::get_current_thread_entity
PUBLIC	?get_num_locks@kdu_thread_entity@@UAEHXZ	; kdu_thread_entity::get_num_locks
PUBLIC	?create@kdu_thread_entity@@QAEX_J@Z		; kdu_thread_entity::create
PUBLIC	?destroy@kdu_thread_entity@@QAE_NXZ		; kdu_thread_entity::destroy
PUBLIC	?get_num_threads@kdu_thread_entity@@QAEHXZ	; kdu_thread_entity::get_num_threads
PUBLIC	?add_thread@kdu_thread_entity@@QAE_NH@Z		; kdu_thread_entity::add_thread
PUBLIC	?add_queue@kdu_thread_entity@@QAEPAUkdu_thread_queue@@PAVkdu_worker@@PAU2@PBD_J@Z ; kdu_thread_entity::add_queue
PUBLIC	?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z ; kdu_thread_entity::add_jobs
PUBLIC	?synchronize@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z ; kdu_thread_entity::synchronize
PUBLIC	?terminate@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_NPAH@Z ; kdu_thread_entity::terminate
PUBLIC	?register_synchronized_job@kdu_thread_entity@@QAEXPAVkdu_worker@@PAUkdu_thread_queue@@_N@Z ; kdu_thread_entity::register_synchronized_job
PUBLIC	?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z ; kdu_thread_entity::process_jobs
PUBLIC	?handle_exception@kdu_thread_entity@@UAEXH@Z	; kdu_thread_entity::handle_exception
PUBLIC	?do_sync@kdu_thread_entity@@MAEX_N@Z		; kdu_thread_entity::do_sync
PUBLIC	?need_sync@kdu_thread_entity@@MAE_NXZ		; kdu_thread_entity::need_sync
PUBLIC	?on_finished@kdu_thread_entity@@MAEX_N@Z	; kdu_thread_entity::on_finished
PUBLIC	?wake_idle_thread@kdu_thread_entity@@AAEXPAUkdu_thread_queue@@@Z ; kdu_thread_entity::wake_idle_thread
PUBLIC	?process_outstanding_sync_points@kdu_thread_entity@@AAE_NPAUkdu_thread_queue@@@Z ; kdu_thread_entity::process_outstanding_sync_points
PUBLIC	?worker_startproc@@YGKPAX@Z			; worker_startproc
PUBLIC	??_Gkdu_thread_entity@@UAEPAXI@Z		; kdu_thread_entity::`scalar deleting destructor'
PUBLIC	?find_unassigned_job@kdu_thread_queue@@QAEPAU1@H@Z ; kdu_thread_queue::find_unassigned_job
PUBLIC	?make_subtree_jobs_runnable@kdu_thread_queue@@QAEXXZ ; kdu_thread_queue::make_subtree_jobs_runnable
PUBLIC	?make_primary_jobs_runnable@kdu_thread_queue@@QAEXXZ ; kdu_thread_queue::make_primary_jobs_runnable
PUBLIC	?make_secondary_job_runnable@kdu_thread_queue@@QAEPAU1@XZ ; kdu_thread_queue::make_secondary_job_runnable
PUBLIC	?finalize@kdu_thread_queue@@QAEXPAUkd_thread_group@@@Z ; kdu_thread_queue::finalize
PUBLIC	?install_synchronization_point@kdu_thread_queue@@QAE_NPAVkdu_worker@@_NH11PAUkd_thread_group@@@Z ; kdu_thread_queue::install_synchronization_point
PUBLIC	?handle_exception@kdu_thread_queue@@QAEXH@Z	; kdu_thread_queue::handle_exception
PUBLIC	??0kd_thread_group@@QAE@XZ			; kd_thread_group::kd_thread_group
PUBLIC	?get_queue@kd_thread_group@@QAEPAUkdu_thread_queue@@XZ ; kd_thread_group::get_queue
PUBLIC	?release_queues@kd_thread_group@@QAEXPAUkdu_thread_queue@@_N@Z ; kd_thread_group::release_queues
PUBLIC	?activate_dormant_queues@kd_thread_group@@QAEXXZ ; kd_thread_group::activate_dormant_queues
PUBLIC	??_7kdu_thread_entity@@6B@			; kdu_thread_entity::`vftable'
PUBLIC	__TI1H
PUBLIC	__CTA1H
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
PUBLIC	__CT??_R0H@84
PUBLIC	??_C@_04BNGIIOIP@ROOT?$AA@			; `string'
PUBLIC	??_R4kdu_thread_entity@@6B@			; kdu_thread_entity::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_thread_entity@@@8			; kdu_thread_entity `RTTI Type Descriptor'
PUBLIC	??_R3kdu_thread_entity@@8			; kdu_thread_entity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_thread_entity@@8			; kdu_thread_entity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_thread_entity@@8		; kdu_thread_entity::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	___std_terminate:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__ResetEvent@4:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__SetThreadAffinityMask@8:PROC
EXTRN	??_Ekdu_thread_entity@@UAEPAXI@Z:PROC		; kdu_thread_entity::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@kdu_thread_entity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_thread_entity@@8 DD FLAT:??_R0?AVkdu_thread_entity@@@8 ; kdu_thread_entity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_thread_entity@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_thread_entity@@8
rdata$r	SEGMENT
??_R2kdu_thread_entity@@8 DD FLAT:??_R1A@?0A@EA@kdu_thread_entity@@8 ; kdu_thread_entity::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_thread_entity@@8
rdata$r	SEGMENT
??_R3kdu_thread_entity@@8 DD 00H			; kdu_thread_entity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_thread_entity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_thread_entity@@@8
data$r	SEGMENT
??_R0?AVkdu_thread_entity@@@8 DD FLAT:??_7type_info@@6B@ ; kdu_thread_entity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_thread_entity@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_thread_entity@@6B@
rdata$r	SEGMENT
??_R4kdu_thread_entity@@6B@ DD 00H			; kdu_thread_entity::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_thread_entity@@@8
	DD	FLAT:??_R3kdu_thread_entity@@8
rdata$r	ENDS
;	COMDAT ??_C@_04BNGIIOIP@ROOT?$AA@
CONST	SEGMENT
??_C@_04BNGIIOIP@ROOT?$AA@ DB 'ROOT', 00H		; `string'
CONST	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0H@8
data$r	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
data$r	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
;	COMDAT ??_7kdu_thread_entity@@6B@
CONST	SEGMENT
??_7kdu_thread_entity@@6B@ DD FLAT:??_R4kdu_thread_entity@@6B@ ; kdu_thread_entity::`vftable'
	DD	FLAT:??_Ekdu_thread_entity@@UAEPAXI@Z
	DD	FLAT:?new_instance@kdu_thread_entity@@UAEPAV1@XZ
	DD	FLAT:?get_num_locks@kdu_thread_entity@@UAEHXZ
	DD	FLAT:?handle_exception@kdu_thread_entity@@UAEXH@Z
	DD	FLAT:?do_sync@kdu_thread_entity@@MAEX_N@Z
	DD	FLAT:?need_sync@kdu_thread_entity@@MAE_NXZ
	DD	FLAT:?on_finished@kdu_thread_entity@@MAEX_N@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gkdu_thread_entity@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gkdu_thread_entity@@UAEPAXI@Z$1
__ehfuncinfo$??_Gkdu_thread_entity@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Gkdu_thread_entity@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$15 DD 00H
	DD	FLAT:??_R0H@8
	DD	0ffffffb8H
	DD	FLAT:__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$9
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$10
__catchsym$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$14 DD 00H
	DD	FLAT:??_R0H@8
	DD	0ffffffbcH
	DD	FLAT:__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$6
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$7
__catchsym$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$13 DD 00H
	DD	FLAT:??_R0H@8
	DD	0ffffffc0H
	DD	FLAT:__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$3
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$4
__catchsym$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$12 DD 00H
	DD	FLAT:??_R0H@8
	DD	0ffffffc4H
	DD	FLAT:__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$1
__ehfuncinfo$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z
	DD	04H
	DD	FLAT:__tryblocktable$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$12
	DD	02H
	DD	02H
	DD	03H
	DD	02H
	DD	FLAT:__catchsym$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$13
	DD	04H
	DD	04H
	DD	05H
	DD	02H
	DD	FLAT:__catchsym$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$14
	DD	06H
	DD	06H
	DD	07H
	DD	02H
	DD	FLAT:__catchsym$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$15
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kdu_thread_entity@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
;	COMDAT ??_Gkd_thread_group@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_thread_group@@QAEPAXI@Z PROC			; kd_thread_group::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 371  :         while ((tmp=queue_blocks) != NULL)

	mov	edx, DWORD PTR [esi+1596]
	test	edx, edx
	je	SHORT $LN6@scalar
	push	edi
	mov	edi, DWORD PTR __imp__free
$LL5@scalar:

; 372  :           { queue_blocks=tmp->next; free(tmp); }

	mov	eax, DWORD PTR [edx]
	push	edx
	mov	DWORD PTR [esi+1596], eax
	call	edi
	mov	edx, DWORD PTR [esi+1596]
	add	esp, 4
	test	edx, edx
	jne	SHORT $LL5@scalar
	pop	edi
$LN6@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN13@scalar
	push	1728					; 000006c0H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_thread_group@@QAEPAXI@Z ENDP			; kd_thread_group::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?activate_dormant_queues@kd_thread_group@@QAEXXZ
_TEXT	SEGMENT
_n$1$ = -4						; size = 4
?activate_dormant_queues@kd_thread_group@@QAEXXZ PROC	; kd_thread_group::activate_dormant_queues, COMDAT
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 183  :   int num_new_jobs = 0;

	xor	ebx, ebx

; 184  :   while ((dormant_head != NULL) &&

	cmp	DWORD PTR [esi+1228], ebx
	je	$LN31@activate_d
	npad	10
$LL2@activate_d:
	mov	eax, DWORD PTR [esi+756]
	cmp	eax, DWORD PTR [esi+136]
	jl	SHORT $LN30@activate_d
	mov	ecx, DWORD PTR [esi+1228]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [esi+1244]
	jg	$LN31@activate_d
	jl	SHORT $LN30@activate_d
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [esi+1240]
	jae	$LN31@activate_d
$LN30@activate_d:

; 185  :          ((queue_base.subtree_working_leaves < num_threads) ||
; 186  :           (dormant_head->bank_idx < min_dormant_bank_idx)))
; 187  :     {
; 188  :       kdu_thread_queue *queue = dormant_head;

	mov	edx, DWORD PTR [esi+1228]

; 189  :       min_dormant_bank_idx = queue->bank_idx+1;

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+12]
	add	ecx, 1
	mov	DWORD PTR [esi+1240], ecx
	adc	eax, 0
	mov	DWORD PTR [esi+1244], eax

; 190  :       if ((dormant_head = queue->sibling_next) == NULL)

	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [esi+1228], eax
	test	eax, eax
	jne	SHORT $LN8@activate_d

; 191  :         dormant_tail = NULL;

	mov	DWORD PTR [esi+1232], eax

; 192  :       else

	jmp	SHORT $LN9@activate_d
$LN8@activate_d:

; 193  :         dormant_head->sibling_prev = NULL;

	mov	DWORD PTR [eax+28], 0
$LN9@activate_d:

; 194  :       queue->sibling_prev = NULL;

	mov	DWORD PTR [edx+28], 0

; 195  :       if ((queue->sibling_next = queue_base.children) != NULL)

	mov	eax, DWORD PTR [esi+696]
	mov	DWORD PTR [edx+24], eax
	test	eax, eax
	je	SHORT $LN10@activate_d

; 196  :         queue->sibling_next->sibling_prev = queue;

	mov	DWORD PTR [eax+28], edx
$LN10@activate_d:

; 197  :       queue->parent = &queue_base;

	lea	eax, DWORD PTR [esi+664]
	mov	DWORD PTR [edx+20], eax

; 198  :       queue_base.children = queue;

	mov	DWORD PTR [esi+696], edx

; 199  :       queue_base.subtree_unassigned_jobs += queue->subtree_unassigned_jobs;

	mov	eax, DWORD PTR [edx+76]
	add	DWORD PTR [esi+740], eax

; 200  :       queue_base.subtree_primary_jobs += queue->subtree_primary_jobs;

	mov	eax, DWORD PTR [edx+80]
	add	DWORD PTR [esi+744], eax

; 201  :       queue_base.subtree_runnable_jobs += queue->subtree_runnable_jobs;

	mov	eax, DWORD PTR [edx+84]
	add	DWORD PTR [esi+748], eax

; 202  :       if (queue_base.subtree_secondary_pref < queue->subtree_secondary_pref)

	mov	eax, DWORD PTR [edx+88]
	cmp	DWORD PTR [esi+752], eax
	jae	SHORT $LN11@activate_d

; 203  :         queue_base.subtree_secondary_pref = queue->subtree_secondary_pref;

	mov	DWORD PTR [esi+752], eax
$LN11@activate_d:

; 204  :       if (queue->subtree_working_leaves > 0)

	mov	eax, DWORD PTR [edx+92]
	test	eax, eax
	jle	SHORT $LN12@activate_d

; 205  :         queue_base.subtree_working_leaves += queue->subtree_working_leaves;

	add	DWORD PTR [esi+756], eax
	jmp	SHORT $LN14@activate_d
$LN12@activate_d:

; 206  :       else if (queue->worker != NULL)

	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN14@activate_d

; 207  :         queue_base.subtree_working_leaves++;

	inc	DWORD PTR [esi+756]
$LN14@activate_d:

; 208  :       num_new_jobs += queue->subtree_unassigned_jobs;

	add	ebx, DWORD PTR [edx+76]
	cmp	DWORD PTR [esi+1228], 0
	jne	$LL2@activate_d
$LN31@activate_d:

; 209  :     }
; 210  :   if (num_idle_threads > 0)

	cmp	DWORD PTR [esi+396], 0
	jle	SHORT $LN32@activate_d

; 211  :     { // Wake up idle threads to run newly available jobs
; 212  :       for (int n=0; (n < num_threads) && (num_new_jobs > 0); n++)

	xor	eax, eax
	mov	DWORD PTR _n$1$[ebp], eax
	cmp	DWORD PTR [esi+136], eax
	jle	SHORT $LN32@activate_d
	push	edi
	lea	edi, DWORD PTR [esi+1264]
$LL6@activate_d:
	test	ebx, ebx
	jle	SHORT $LN33@activate_d

; 213  :         if (thread_activity[n] == NULL)

	cmp	DWORD PTR [edi-864], 0
	jne	SHORT $LN4@activate_d
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 687  :           return ((event != NULL) && (SetEvent(event) == TRUE));

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN20@activate_d
	push	ecx
	call	DWORD PTR __imp__SetEvent@4
	mov	eax, DWORD PTR _n$1$[ebp]
$LN20@activate_d:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 216  :             num_new_jobs--;

	dec	ebx
$LN4@activate_d:

; 211  :     { // Wake up idle threads to run newly available jobs
; 212  :       for (int n=0; (n < num_threads) && (num_new_jobs > 0); n++)

	inc	eax
	add	edi, 4
	mov	DWORD PTR _n$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+136]
	jl	SHORT $LL6@activate_d
$LN33@activate_d:
	pop	edi
$LN32@activate_d:
	pop	esi
	pop	ebx

; 217  :           }
; 218  :     }
; 219  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?activate_dormant_queues@kd_thread_group@@QAEXXZ ENDP	; kd_thread_group::activate_dormant_queues
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?release_queues@kd_thread_group@@QAEXPAUkdu_thread_queue@@_N@Z
_TEXT	SEGMENT
_root$ = 8						; size = 4
_leave_root$ = 12					; size = 1
?release_queues@kd_thread_group@@QAEXPAUkdu_thread_queue@@_N@Z PROC ; kd_thread_group::release_queues, COMDAT
; _this$ = ecx

; 161  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 162  :   kdu_thread_queue *child;
; 163  :   while ((child=root->children) != NULL)

	mov	esi, DWORD PTR _root$[ebp]
	push	edi
	mov	edi, ecx
	mov	edx, DWORD PTR [esi+32]
	test	edx, edx
	je	SHORT $LN3@release_qu
$LL2@release_qu:

; 164  :     { // Recursively release children
; 165  :       root->children = child->sibling_next;

	mov	eax, DWORD PTR [edx+24]

; 166  :       release_queues(child,false);

	mov	ecx, edi
	push	0
	push	edx
	mov	DWORD PTR [esi+32], eax
	call	?release_queues@kd_thread_group@@QAEXPAUkdu_thread_queue@@_N@Z ; kd_thread_group::release_queues
	mov	edx, DWORD PTR [esi+32]
	test	edx, edx
	jne	SHORT $LL2@release_qu
$LN3@release_qu:

; 167  :     }
; 168  :   if (!leave_root)

	cmp	BYTE PTR _leave_root$[ebp], 0
	jne	SHORT $LN4@release_qu

; 169  :     {
; 170  :       memset(root,0,sizeof(kdu_thread_queue));

	push	304					; 00000130H
	push	0
	push	esi
	call	_memset

; 171  :       root->free_next = free_queues;

	mov	eax, DWORD PTR [edi+1592]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+36], eax

; 172  :       free_queues = root;

	mov	DWORD PTR [edi+1592], esi
$LN4@release_qu:
	pop	edi
	pop	esi

; 173  :     }
; 174  : }

	pop	ebp
	ret	8
?release_queues@kd_thread_group@@QAEXPAUkdu_thread_queue@@_N@Z ENDP ; kd_thread_group::release_queues
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?get_queue@kd_thread_group@@QAEPAUkdu_thread_queue@@XZ
_TEXT	SEGMENT
?get_queue@kd_thread_group@@QAEPAUkdu_thread_queue@@XZ PROC ; kd_thread_group::get_queue, COMDAT
; _this$ = ecx

; 114  : {

	push	edi
	mov	edi, ecx

; 115  :   if (free_queues == NULL)

	cmp	DWORD PTR [edi+1592], 0
	jne	SHORT $LN5@get_queue

; 116  :     {
; 117  :       int mask = KDU_MAX_L2_CACHE_LINE-1;
; 118  :       assert(!(mask & (mask+1))); // KDU_MAX_L2_CACHE_LINE must be power of 2!
; 119  :       int queue_size = sizeof(kd_thread_group);
; 120  :       int aligned_queue_size=KDU_MAX_L2_CACHE_LINE;
; 121  :       while (aligned_queue_size >= 2*queue_size)
; 122  :         aligned_queue_size <<= 1;
; 123  :       if (aligned_queue_size < queue_size)
; 124  :         aligned_queue_size *= 1+((queue_size-1)/aligned_queue_size);
; 125  :       assert((aligned_queue_size >= queue_size) &&
; 126  :              (aligned_queue_size < 2*queue_size));
; 127  :       int block_bytes = mask + aligned_queue_size*32;
; 128  :       kd_thread_queue_alloc *alloc = (kd_thread_queue_alloc *)
; 129  :         malloc(sizeof(kd_thread_queue_alloc *)+(size_t) block_bytes);

	push	esi
	push	57475					; 0000e083H
	call	DWORD PTR __imp__malloc

; 130  :       alloc->next = queue_blocks;

	mov	ecx, DWORD PTR [edi+1596]

; 131  :       queue_blocks = alloc;
; 132  :       kdu_byte *block = alloc->block;
; 133  :       memset(block,0,(size_t) block_bytes);

	push	57471					; 0000e07fH
	push	0
	lea	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ecx
	push	esi
	mov	DWORD PTR [edi+1596], eax
	call	_memset

; 134  :       int offset = (- _addr_to_kdu_int32(block)) & mask;

	mov	eax, esi

; 135  :       block += offset;
; 136  :       block_bytes -= offset;

	mov	ecx, 57471				; 0000e07fH
	neg	eax
	add	esp, 16					; 00000010H
	and	eax, 127				; 0000007fH
	sub	ecx, eax
	add	esi, eax

; 137  :       for (; block_bytes >= aligned_queue_size;

	cmp	ecx, 1792				; 00000700H
	jl	SHORT $LN19@get_queue

; 116  :     {
; 117  :       int mask = KDU_MAX_L2_CACHE_LINE-1;
; 118  :       assert(!(mask & (mask+1))); // KDU_MAX_L2_CACHE_LINE must be power of 2!
; 119  :       int queue_size = sizeof(kd_thread_group);
; 120  :       int aligned_queue_size=KDU_MAX_L2_CACHE_LINE;
; 121  :       while (aligned_queue_size >= 2*queue_size)
; 122  :         aligned_queue_size <<= 1;
; 123  :       if (aligned_queue_size < queue_size)
; 124  :         aligned_queue_size *= 1+((queue_size-1)/aligned_queue_size);
; 125  :       assert((aligned_queue_size >= queue_size) &&
; 126  :              (aligned_queue_size < 2*queue_size));
; 127  :       int block_bytes = mask + aligned_queue_size*32;
; 128  :       kd_thread_queue_alloc *alloc = (kd_thread_queue_alloc *)
; 129  :         malloc(sizeof(kd_thread_queue_alloc *)+(size_t) block_bytes);

	mov	eax, 613566757				; 24924925H
	mul	ecx
	sub	ecx, edx
	shr	ecx, 1
	add	ecx, edx
	shr	ecx, 10					; 0000000aH
$LL6@get_queue:

; 138  :            block+=aligned_queue_size, block_bytes-=aligned_queue_size)
; 139  :         {
; 140  :           kdu_thread_queue *elt = (kdu_thread_queue *) block;
; 141  :           elt->free_next = free_queues;

	mov	eax, DWORD PTR [edi+1592]
	mov	DWORD PTR [esi+36], eax

; 142  :           free_queues = elt;

	mov	DWORD PTR [edi+1592], esi
	add	esi, 1792				; 00000700H
	sub	ecx, 1
	jne	SHORT $LL6@get_queue
$LN19@get_queue:
	pop	esi
$LN5@get_queue:

; 143  :         }
; 144  :     }
; 145  :   kdu_thread_queue *result = free_queues;

	mov	eax, DWORD PTR [edi+1592]

; 146  :   free_queues = result->free_next;

	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edi+1592], ecx

; 147  :   result->free_next = NULL;
; 148  :   result->group = this;

	mov	DWORD PTR [eax+16], edi
	mov	DWORD PTR [eax+36], 0

; 149  :   result->thread_awaiting_sync = -1;

	mov	DWORD PTR [eax+292], -1

; 150  :   result->thread_awaiting_complete = -1;

	mov	DWORD PTR [eax+296], -1

; 151  :   result->prescheduled_job_idx = -1;

	mov	DWORD PTR [eax+72], -1
	pop	edi

; 152  :   return result;
; 153  : }

	ret	0
?get_queue@kd_thread_group@@QAEPAUkdu_thread_queue@@XZ ENDP ; kd_thread_group::get_queue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
;	COMDAT ??1kd_thread_group@@QAE@XZ
_TEXT	SEGMENT
??1kd_thread_group@@QAE@XZ PROC				; kd_thread_group::~kd_thread_group, COMDAT
; _this$ = ecx

; 369  :       { // Only cleans up private resources

	push	esi
	mov	esi, ecx

; 370  :         kd_thread_queue_alloc *tmp;
; 371  :         while ((tmp=queue_blocks) != NULL)

	mov	eax, DWORD PTR [esi+1596]
	test	eax, eax
	je	SHORT $LN3@kd_thread_
	push	edi
	mov	edi, DWORD PTR __imp__free
$LL2@kd_thread_:

; 372  :           { queue_blocks=tmp->next; free(tmp); }

	mov	ecx, DWORD PTR [eax]
	push	eax
	mov	DWORD PTR [esi+1596], ecx
	call	edi
	mov	eax, DWORD PTR [esi+1596]
	add	esp, 4
	test	eax, eax
	jne	SHORT $LL2@kd_thread_
	pop	edi
$LN3@kd_thread_:
	pop	esi

; 373  :       }

	ret	0
??1kd_thread_group@@QAE@XZ ENDP				; kd_thread_group::~kd_thread_group
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
;	COMDAT ??0kd_thread_group@@QAE@XZ
_TEXT	SEGMENT
??0kd_thread_group@@QAE@XZ PROC				; kd_thread_group::kd_thread_group, COMDAT
; _this$ = ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 601  :           event = NULL;

	xor	eax, eax
	push	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h

; 353  :     kd_thread_group()

	mov	esi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 601  :           event = NULL;

	mov	ecx, 64					; 00000040H
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h

; 358  :         memset(&queue_base,0,sizeof(queue_base));

	push	304					; 00000130H
	push	eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 469  :           mutex=NULL;

	mov	DWORD PTR [esi+1260], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h

; 354  :       {

	lea	edi, DWORD PTR [esi+1264]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 601  :           event = NULL;

	rep stosd

; 469  :           mutex=NULL;

	mov	DWORD PTR [esi+1528], eax
	mov	DWORD PTR [esi+1536], eax
	mov	DWORD PTR [esi+1544], eax
	mov	DWORD PTR [esi+1552], eax
	mov	DWORD PTR [esi+1560], eax
	mov	DWORD PTR [esi+1568], eax
	mov	DWORD PTR [esi+1576], eax
	mov	DWORD PTR [esi+1584], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h

; 355  :         cpu_affinity = 0;

	mov	DWORD PTR [esi+128], eax
	mov	DWORD PTR [esi+132], eax

; 356  :         free_queues = NULL;  queue_blocks = NULL;  num_deferred_jobs = 0;

	mov	DWORD PTR [esi+1592], eax
	mov	DWORD PTR [esi+1596], eax
	mov	DWORD PTR [esi+968], eax

; 357  :         num_threads = num_idle_threads = num_finished_threads = 0;

	mov	DWORD PTR [esi+656], eax
	mov	DWORD PTR [esi+396], eax
	mov	DWORD PTR [esi+136], eax

; 358  :         memset(&queue_base,0,sizeof(queue_base));

	lea	eax, DWORD PTR [esi+664]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 359  :         queue_base.name = "ROOT";

	mov	DWORD PTR [esi+668], OFFSET ??_C@_04BNGIIOIP@ROOT?$AA@

; 360  :         queue_base.group = this;

	mov	DWORD PTR [esi+680], esi

; 361  :         queue_base.prescheduled_job_idx=-1;
; 362  :         queue_base.thread_awaiting_sync=queue_base.thread_awaiting_complete=-1;
; 363  :         dormant_head = dormant_tail = NULL;  min_dormant_bank_idx = 1;
; 364  :         grouperr.failed=false;  grouperr.failure_code=-1;
; 365  :         finish_requested = destruction_requested = false;
; 366  :         locks=NULL;  num_locks=0;
; 367  :       }

	mov	eax, esi
	mov	DWORD PTR [esi+736], -1
	mov	DWORD PTR [esi+960], -1
	pop	edi
	mov	DWORD PTR [esi+956], -1
	mov	DWORD PTR [esi+1232], 0
	mov	DWORD PTR [esi+1228], 0
	mov	DWORD PTR [esi+1240], 1
	mov	DWORD PTR [esi+1244], 0
	mov	BYTE PTR [esi+1248], 0
	mov	DWORD PTR [esi+1252], -1
	mov	WORD PTR [esi+1256], 0
	mov	DWORD PTR [esi+1524], 0
	mov	DWORD PTR [esi+1520], 0
	pop	esi
	ret	0
??0kd_thread_group@@QAE@XZ ENDP				; kd_thread_group::kd_thread_group
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?handle_exception@kdu_thread_queue@@QAEXH@Z
_TEXT	SEGMENT
tv477 = -4						; size = 4
_calling_thread_idx$ = 8				; size = 4
?handle_exception@kdu_thread_queue@@QAEXH@Z PROC	; kdu_thread_queue::handle_exception, COMDAT
; _this$ = ecx

; 506  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 507  :   for (kdu_thread_queue *child=children;

	mov	edi, DWORD PTR [esi+32]

; 508  :        child != NULL; child=child->sibling_next)

	test	edi, edi
	je	SHORT $LN3@handle_exc
$LL4@handle_exc:

; 509  :     child->handle_exception(calling_thread_idx);

	push	DWORD PTR _calling_thread_idx$[ebp]
	mov	ecx, edi
	call	?handle_exception@kdu_thread_queue@@QAEXH@Z ; kdu_thread_queue::handle_exception
	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL4@handle_exc
$LN3@handle_exc:
	mov	eax, DWORD PTR [esi+52]

; 512  :   first_unassigned_job_idx += num_unassigned_jobs;
; 513  :   num_unassigned_jobs = num_primary_jobs = num_runnable_jobs = 0;
; 514  :   num_active_jobs = 0;
; 515  :   prescheduled_job_idx = -1;
; 516  :   max_jobs_in_queue = first_unassigned_job_idx;
; 517  :   worker = NULL;
; 518  :   subtree_secondary_pref = 0;
; 519  :   subtree_working_leaves = 0;
; 520  :   subtree_unassigned_jobs = 0;
; 521  :   subtree_primary_jobs = 0;
; 522  :   subtree_runnable_jobs = 0;
; 523  : 
; 524  :   int n, k;
; 525  :   for (n=0; n < num_sync_points; n++)

	xor	ebx, ebx
	add	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR [esi+64]
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+72], -1
	mov	DWORD PTR [esi+68], eax
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+88], 0
	mov	DWORD PTR [esi+92], 0
	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+80], 0
	mov	DWORD PTR [esi+84], 0
	cmp	DWORD PTR [esi+96], ebx
	jle	SHORT $LN6@handle_exc

; 510  : 
; 511  :   secondary_pref = 0;

	lea	ecx, DWORD PTR [esi+124]
	lea	edi, DWORD PTR [ebx+1]
	mov	DWORD PTR tv477[ebp], ecx
	lea	eax, DWORD PTR [esi+100]
$LL7@handle_exc:

; 526  :     {
; 527  :       kd_thread_sync_point *sp = sync_points + n;
; 528  :       sp->num_unsynchronized_children = 0;
; 529  :       sp->synchronization_downcounter = 0;
; 530  :       sp->synchronized_worker = NULL;
; 531  :       if ((sp->synchronizing_thread_idx < 0) ||

	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+16], 0
	test	edx, edx
	js	SHORT $LN12@handle_exc
	cmp	edx, DWORD PTR _calling_thread_idx$[ebp]
	jne	SHORT $LN5@handle_exc
$LN12@handle_exc:

; 532  :           (sp->synchronizing_thread_idx == calling_thread_idx))
; 533  :         { // Completely remove this `sync_point'
; 534  :           for (k=n+1; k < num_sync_points; k++)

	mov	edx, edi
	cmp	edi, DWORD PTR [esi+96]
	jge	SHORT $LN9@handle_exc
	npad	4
$LL10@handle_exc:

; 535  :             *sp = sync_points[k];

	movups	xmm0, XMMWORD PTR [ecx]
	inc	edx
	lea	ecx, DWORD PTR [ecx+24]
	movups	XMMWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [ecx-8]
	movq	QWORD PTR [eax+16], xmm0
	cmp	edx, DWORD PTR [esi+96]
	jl	SHORT $LL10@handle_exc
	mov	ecx, DWORD PTR tv477[ebp]
$LN9@handle_exc:

; 536  :           n--;

	dec	ebx
	sub	eax, 24					; 00000018H
	dec	edi
	sub	ecx, 24					; 00000018H

; 537  :           num_sync_points--;

	dec	DWORD PTR [esi+96]
$LN5@handle_exc:

; 512  :   first_unassigned_job_idx += num_unassigned_jobs;
; 513  :   num_unassigned_jobs = num_primary_jobs = num_runnable_jobs = 0;
; 514  :   num_active_jobs = 0;
; 515  :   prescheduled_job_idx = -1;
; 516  :   max_jobs_in_queue = first_unassigned_job_idx;
; 517  :   worker = NULL;
; 518  :   subtree_secondary_pref = 0;
; 519  :   subtree_working_leaves = 0;
; 520  :   subtree_unassigned_jobs = 0;
; 521  :   subtree_primary_jobs = 0;
; 522  :   subtree_runnable_jobs = 0;
; 523  : 
; 524  :   int n, k;
; 525  :   for (n=0; n < num_sync_points; n++)

	inc	ebx
	add	ecx, 24					; 00000018H
	add	eax, 24					; 00000018H
	mov	DWORD PTR tv477[ebp], ecx
	inc	edi
	cmp	ebx, DWORD PTR [esi+96]
	jl	SHORT $LL7@handle_exc
$LN6@handle_exc:

; 538  :         }
; 539  :     }
; 540  : 
; 541  :   if (thread_awaiting_sync >= 0)

	mov	ecx, DWORD PTR [esi+292]
	mov	edi, DWORD PTR __imp__SetEvent@4

; 542  :     {
; 543  :       if (thread_awaiting_sync != calling_thread_idx)

	mov	ebx, DWORD PTR _calling_thread_idx$[ebp]
	test	ecx, ecx
	js	SHORT $LN13@handle_exc
	cmp	ecx, ebx
	je	SHORT $LN20@handle_exc

; 544  :         group->thread_events[thread_awaiting_sync].set();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 687  :           return ((event != NULL) && (SetEvent(event) == TRUE));

	mov	eax, DWORD PTR [eax+ecx*4+1264]
	test	eax, eax
	je	SHORT $LN20@handle_exc
	push	eax
	call	edi
$LN20@handle_exc:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 545  :       thread_awaiting_sync = -1;

	mov	DWORD PTR [esi+292], -1
$LN13@handle_exc:

; 546  :     }
; 547  :   if (thread_awaiting_complete >= 0)

	mov	ecx, DWORD PTR [esi+296]
	test	ecx, ecx
	js	SHORT $LN15@handle_exc

; 548  :     {
; 549  :       if (thread_awaiting_complete != calling_thread_idx)

	cmp	ecx, ebx
	je	SHORT $LN24@handle_exc

; 550  :         group->thread_events[thread_awaiting_complete].set();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 687  :           return ((event != NULL) && (SetEvent(event) == TRUE));

	mov	eax, DWORD PTR [eax+ecx*4+1264]
	test	eax, eax
	je	SHORT $LN24@handle_exc
	push	eax
	call	edi
$LN24@handle_exc:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 551  :       thread_awaiting_complete = -1;

	mov	DWORD PTR [esi+296], -1
$LN15@handle_exc:
	pop	edi
	pop	esi
	pop	ebx

; 552  :     }
; 553  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?handle_exception@kdu_thread_queue@@QAEXH@Z ENDP	; kdu_thread_queue::handle_exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?install_synchronization_point@kdu_thread_queue@@QAE_NPAVkdu_worker@@_NH11PAUkd_thread_group@@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_job$ = 8						; size = 4
_run_deferred$ = 12					; size = 1
_thread_idx$ = 16					; size = 4
_finalize_children$ = 20				; size = 1
_finalize_current$ = 24					; size = 1
_group$ = 28						; size = 4
?install_synchronization_point@kdu_thread_queue@@QAE_NPAVkdu_worker@@_NH11PAUkd_thread_group@@@Z PROC ; kdu_thread_queue::install_synchronization_point, COMDAT
; _this$ = ecx

; 457  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	edx, ecx
	mov	DWORD PTR _this$1$[ebp], edx

; 458  :   if (subtree_runnable_jobs < subtree_unassigned_jobs)

	mov	eax, DWORD PTR [edx+84]
	cmp	eax, DWORD PTR [edx+76]
	jge	SHORT $LN8@install_sy

; 459  :     make_subtree_jobs_runnable();

	call	?make_subtree_jobs_runnable@kdu_thread_queue@@QAEXXZ ; kdu_thread_queue::make_subtree_jobs_runnable
	mov	edx, DWORD PTR _this$1$[ebp]
$LN8@install_sy:

; 460  :   assert(num_sync_points < KDU_MAX_SYNC_NESTING);
; 461  :   kd_thread_sync_point *sp = sync_points + (num_sync_points++);

	mov	ecx, DWORD PTR [edx+96]
	push	ebx

; 462  :   sp->num_unsynchronized_children = 0;
; 463  :   sp->synchronization_threshold =
; 464  :     first_unassigned_job_idx + num_unassigned_jobs;
; 465  :   sp->synchronization_downcounter = num_active_jobs + num_unassigned_jobs;
; 466  :   sp->synchronizing_thread_idx = thread_idx;
; 467  :   sp->synchronized_worker = job;
; 468  :   sp->synchronized_job_deferred = run_deferred;
; 469  :   sp->synchronized_job_in_progress = false;
; 470  :   sp->finalize_children = finalize_children;

	mov	ebx, DWORD PTR _finalize_children$[ebp]
	push	esi
	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	esi, DWORD PTR [eax*8+100]
	add	esi, edx
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [edx+96], eax

; 471  :   sp->finalize_current = finalize_current;

	mov	cl, BYTE PTR _finalize_current$[ebp]
	mov	DWORD PTR [esi+8], 0
	mov	eax, DWORD PTR [edx+64]
	add	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+48]
	add	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [esi+4], eax

; 472  :   if ((sp->synchronization_downcounter > 0) || (sp != sync_points))

	cmp	DWORD PTR [esi+4], 0
	mov	eax, DWORD PTR _thread_idx$[ebp]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR _job$[ebp]
	mov	DWORD PTR [esi+16], eax
	mov	al, BYTE PTR _run_deferred$[ebp]
	mov	BYTE PTR [esi+20], al
	mov	BYTE PTR [esi+21], 0
	mov	BYTE PTR [esi+22], bl
	mov	BYTE PTR [esi+23], cl
	jg	$LN10@install_sy
	lea	eax, DWORD PTR [edx+100]
	cmp	esi, eax
	jne	$LN10@install_sy

; 474  : 
; 475  :   if (finalize_current && (worker != NULL))

	test	cl, cl
	je	SHORT $LN11@install_sy
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN11@install_sy

; 476  :     this->finalize(group);

	push	DWORD PTR _group$[ebp]
	mov	ecx, edx
	call	?finalize@kdu_thread_queue@@QAEXPAUkd_thread_group@@@Z ; kdu_thread_queue::finalize
	mov	edx, DWORD PTR _this$1$[ebp]
$LN11@install_sy:

; 477  : 
; 478  :   kdu_thread_queue *child;
; 479  :   for (child=children; child != NULL; child=child->sibling_next)

	push	edi
	mov	edi, DWORD PTR [edx+32]
	test	edi, edi
	je	SHORT $LN3@install_sy
	npad	2
$LL4@install_sy:

; 480  :     if (child->install_synchronization_point(NULL,false,-1,

	push	DWORD PTR _group$[ebp]
	mov	ecx, edi
	push	ebx
	push	ebx
	push	-1
	push	0
	push	0
	call	?install_synchronization_point@kdu_thread_queue@@QAE_NPAVkdu_worker@@_NH11PAUkd_thread_group@@@Z ; kdu_thread_queue::install_synchronization_point
	test	al, al
	je	SHORT $LN2@install_sy

; 481  :                        finalize_children,finalize_children,group))
; 482  :       sp->num_unsynchronized_children++;

	inc	DWORD PTR [esi+8]
$LN2@install_sy:

; 477  : 
; 478  :   kdu_thread_queue *child;
; 479  :   for (child=children; child != NULL; child=child->sibling_next)

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL4@install_sy
	mov	edx, DWORD PTR _this$1$[ebp]
$LN3@install_sy:

; 483  :   if ((parent == NULL) && (this == &group->queue_base))

	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN6@install_sy
	mov	ecx, DWORD PTR _group$[ebp]
	lea	eax, DWORD PTR [ecx+664]
	cmp	edx, eax
	jne	SHORT $LN6@install_sy

; 484  :     { // Consider dormant queues as though they belonged to the root of the
; 485  :       // queue hierarchy, for the purpose of installing synchronization
; 486  :       // conditions.
; 487  :       for (child=group->dormant_head; child != NULL; child=child->sibling_next)

	mov	edi, DWORD PTR [ecx+1228]
	test	edi, edi
	je	SHORT $LN6@install_sy
$LL7@install_sy:

; 488  :         if (child->install_synchronization_point(NULL,false,-1,

	push	ecx
	push	ebx
	push	ebx
	push	-1
	push	0
	push	0
	mov	ecx, edi
	call	?install_synchronization_point@kdu_thread_queue@@QAE_NPAVkdu_worker@@_NH11PAUkd_thread_group@@@Z ; kdu_thread_queue::install_synchronization_point
	test	al, al
	je	SHORT $LN5@install_sy

; 489  :                         finalize_children,finalize_children,group))
; 490  :           sp->num_unsynchronized_children++;

	inc	DWORD PTR [esi+8]
$LN5@install_sy:

; 484  :     { // Consider dormant queues as though they belonged to the root of the
; 485  :       // queue hierarchy, for the purpose of installing synchronization
; 486  :       // conditions.
; 487  :       for (child=group->dormant_head; child != NULL; child=child->sibling_next)

	mov	edi, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR _group$[ebp]
	test	edi, edi
	jne	SHORT $LL7@install_sy
	mov	edx, DWORD PTR _this$1$[ebp]
$LN6@install_sy:

; 491  :     }
; 492  :   if (sp->num_unsynchronized_children > 0)

	cmp	DWORD PTR [esi+8], 0
	pop	edi
	jg	SHORT $LN10@install_sy

; 493  :     return true;
; 494  : 
; 495  :   // Synchronization condition already reached; uninstall condition
; 496  :   num_sync_points = 0;

	pop	esi
	mov	DWORD PTR [edx+96], 0

; 497  :   return false;

	xor	al, al
	pop	ebx

; 498  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN10@install_sy:
	pop	esi

; 473  :     return true;

	mov	al, 1
	pop	ebx

; 498  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?install_synchronization_point@kdu_thread_queue@@QAE_NPAVkdu_worker@@_NH11PAUkd_thread_group@@@Z ENDP ; kdu_thread_queue::install_synchronization_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?finalize@kdu_thread_queue@@QAEXPAUkd_thread_group@@@Z
_TEXT	SEGMENT
_group$ = 8						; size = 4
?finalize@kdu_thread_queue@@QAEXPAUkd_thread_group@@@Z PROC ; kdu_thread_queue::finalize, COMDAT
; _this$ = ecx

; 424  : {

	push	ebp
	mov	ebp, esp

; 425  :   if (worker == NULL)

	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN7@finalize

; 426  :     return;
; 427  :   max_jobs_in_queue = first_unassigned_job_idx+num_unassigned_jobs;

	mov	eax, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR [ecx+64]
	add	eax, edx

; 428  :   if ((num_active_jobs > 0) || (max_jobs_in_queue > first_unassigned_job_idx))

	cmp	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+68], eax
	jg	SHORT $LN7@finalize
	cmp	eax, edx
	jg	SHORT $LN7@finalize

; 429  :     return; // Queue is still active
; 430  :   worker = NULL;
; 431  :   if (subtree_working_leaves > 0)

	cmp	DWORD PTR [ecx+92], 0
	mov	DWORD PTR [ecx+40], 0
	jg	SHORT $LN7@finalize

; 432  :     return; // Queue was not a working leaf
; 433  :   for (kdu_thread_queue *scan=parent; scan != NULL; scan=scan->parent)

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN13@finalize
$LL4@finalize:

; 434  :     {
; 435  :       assert(scan->subtree_working_leaves > 0);
; 436  :       scan->subtree_working_leaves--;

	add	DWORD PTR [eax+92], -1

; 437  :       if ((scan->subtree_working_leaves == 0) && (scan->worker != NULL))

	jne	SHORT $LN2@finalize
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN13@finalize
$LN2@finalize:

; 432  :     return; // Queue was not a working leaf
; 433  :   for (kdu_thread_queue *scan=parent; scan != NULL; scan=scan->parent)

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL4@finalize
$LN13@finalize:

; 438  :         break; // Num working leaves along this branch is still exactly 1,
; 439  :                // because `scan' is now a working leaf.
; 440  :     }
; 441  :   if ((group->dormant_head != NULL) &&

	mov	ecx, DWORD PTR _group$[ebp]
	cmp	DWORD PTR [ecx+1228], 0
	je	SHORT $LN7@finalize
	mov	eax, DWORD PTR [ecx+756]
	cmp	eax, DWORD PTR [ecx+136]
	jge	SHORT $LN7@finalize

; 442  :       (group->queue_base.subtree_working_leaves < group->num_threads))
; 443  :     group->activate_dormant_queues();

	call	?activate_dormant_queues@kd_thread_group@@QAEXXZ ; kd_thread_group::activate_dormant_queues
$LN7@finalize:

; 444  : }

	pop	ebp
	ret	4
?finalize@kdu_thread_queue@@QAEXPAUkd_thread_group@@@Z ENDP ; kdu_thread_queue::finalize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?make_secondary_job_runnable@kdu_thread_queue@@QAEPAU1@XZ
_TEXT	SEGMENT
?make_secondary_job_runnable@kdu_thread_queue@@QAEPAU1@XZ PROC ; kdu_thread_queue::make_secondary_job_runnable, COMDAT
; _this$ = ecx

; 357  : {

	push	edi
	mov	edi, ecx

; 358  :   kdu_thread_queue *scan;
; 359  : 
; 360  :   assert((subtree_unassigned_jobs > 0) && (subtree_secondary_pref != 0) &&
; 361  :          (subtree_runnable_jobs == 0) && (subtree_primary_jobs == 0));
; 362  :   if (subtree_unassigned_jobs == num_unassigned_jobs)

	mov	eax, DWORD PTR [edi+52]
	cmp	DWORD PTR [edi+76], eax
	jne	SHORT $LN8@make_secon

; 363  :     { // This is the queue we want
; 364  :       assert(secondary_pref != 0);
; 365  :       num_runnable_jobs++;

	inc	DWORD PTR [edi+60]

; 366  :       if (num_runnable_jobs == num_unassigned_jobs)

	cmp	DWORD PTR [edi+60], eax
	jne	SHORT $LN9@make_secon

; 367  :         secondary_pref = 0; // No more secondary jobs

	mov	DWORD PTR [edi+44], 0
$LN9@make_secon:

; 368  :       for (scan=this; scan != NULL; scan=scan->parent)

	mov	eax, edi
	npad	4
$LL4@make_secon:

; 369  :         {
; 370  :           scan->subtree_runnable_jobs++;

	inc	DWORD PTR [eax+84]

; 371  :           if ((scan->subtree_runnable_jobs+scan->subtree_primary_jobs) ==

	mov	ecx, DWORD PTR [eax+80]
	add	ecx, DWORD PTR [eax+84]
	cmp	ecx, DWORD PTR [eax+76]
	jne	SHORT $LN2@make_secon

; 372  :               scan->subtree_unassigned_jobs)
; 373  :             scan->subtree_secondary_pref = 0;

	mov	DWORD PTR [eax+88], 0
$LN2@make_secon:

; 368  :       for (scan=this; scan != NULL; scan=scan->parent)

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL4@make_secon

; 374  :         }
; 375  :       return this;

	mov	eax, edi
	pop	edi

; 414  :   assert(result != NULL);
; 415  :   return result;
; 416  : }

	ret	0
$LN8@make_secon:

; 376  :     }
; 377  : 
; 378  :   // If we get here, the queue we seek must be one of our children
; 379  :   kdu_uint32 sp, best_pref=0, second_best_pref=0;
; 380  :   kdu_thread_queue *best_child=NULL;
; 381  :   for (scan=children; scan != NULL; scan=scan->sibling_next)

	mov	eax, DWORD PTR [edi+32]
	xor	edx, edx
	push	ebx
	push	esi
	xor	esi, esi
	xor	ebx, ebx
	test	eax, eax
	je	SHORT $LN6@make_secon
	npad	1
$LL7@make_secon:

; 382  :     {
; 383  :       if ((sp = scan->subtree_secondary_pref) == 0)

	mov	ecx, DWORD PTR [eax+88]
	test	ecx, ecx
	je	SHORT $LN5@make_secon

; 384  :         continue;
; 385  :       if (scan->subtree_unassigned_jobs == 0)

	cmp	DWORD PTR [eax+76], 0
	jne	SHORT $LN12@make_secon

; 386  :         { // Secondary_pref values should all be 0.
; 387  :           scan->subtree_secondary_pref = 0;

	mov	DWORD PTR [eax+88], 0

; 388  :           continue;

	jmp	SHORT $LN5@make_secon
$LN12@make_secon:

; 389  :         }
; 390  :       assert((scan->subtree_runnable_jobs == 0) &&
; 391  :              (scan->subtree_primary_jobs == 0) &&
; 392  :              (scan->num_runnable_jobs == 0) && (scan->num_primary_jobs == 0));
; 393  :       if ((sp > best_pref) || (best_child == NULL))

	cmp	ecx, edx
	ja	SHORT $LN15@make_secon
	test	ebx, ebx
	je	SHORT $LN15@make_secon

; 397  :         }
; 398  :       else if (sp > second_best_pref)

	cmp	ecx, esi
	jbe	SHORT $LN5@make_secon

; 399  :         second_best_pref = sp;

	mov	esi, ecx
	jmp	SHORT $LN5@make_secon
$LN15@make_secon:

; 394  :         {
; 395  :           second_best_pref = best_pref;  best_pref = sp;

	mov	esi, edx

; 396  :           best_child = scan;

	mov	ebx, eax
	mov	edx, ecx
$LN5@make_secon:

; 376  :     }
; 377  : 
; 378  :   // If we get here, the queue we seek must be one of our children
; 379  :   kdu_uint32 sp, best_pref=0, second_best_pref=0;
; 380  :   kdu_thread_queue *best_child=NULL;
; 381  :   for (scan=children; scan != NULL; scan=scan->sibling_next)

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL7@make_secon
$LN6@make_secon:

; 400  :     }
; 401  :   assert(best_child != NULL);
; 402  :   kdu_thread_queue *result = best_child->make_secondary_job_runnable();

	mov	ecx, ebx
	call	?make_secondary_job_runnable@kdu_thread_queue@@QAEPAU1@XZ ; kdu_thread_queue::make_secondary_job_runnable

; 403  :   best_pref = best_child->subtree_secondary_pref;

	mov	ecx, DWORD PTR [ebx+88]

; 404  :   if (second_best_pref > best_pref)

	cmp	esi, ecx

; 405  :     best_pref = second_best_pref;
; 406  :   if (this->secondary_pref != 0)

	mov	edx, DWORD PTR [edi+44]
	cmova	ecx, esi
	pop	esi
	pop	ebx
	test	edx, edx
	je	SHORT $LN19@make_secon

; 407  :     { // current node itself has secondary jobs; check them as well.
; 408  :       assert(this->num_unassigned_jobs >
; 409  :              (this->num_runnable_jobs+this->num_primary_jobs));
; 410  :       if (this->secondary_pref > best_pref)

	cmp	edx, ecx
	cmova	ecx, edx
$LN19@make_secon:

; 411  :         best_pref = this->secondary_pref;
; 412  :     }
; 413  :   this->subtree_secondary_pref = best_pref;

	mov	DWORD PTR [edi+88], ecx
	pop	edi

; 414  :   assert(result != NULL);
; 415  :   return result;
; 416  : }

	ret	0
?make_secondary_job_runnable@kdu_thread_queue@@QAEPAU1@XZ ENDP ; kdu_thread_queue::make_secondary_job_runnable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?make_primary_jobs_runnable@kdu_thread_queue@@QAEXXZ
_TEXT	SEGMENT
?make_primary_jobs_runnable@kdu_thread_queue@@QAEXXZ PROC ; kdu_thread_queue::make_primary_jobs_runnable, COMDAT
; _this$ = ecx

; 328  : {

	push	esi
	mov	esi, ecx

; 329  :   if (subtree_primary_jobs > num_primary_jobs)

	mov	eax, DWORD PTR [esi+80]
	cmp	eax, DWORD PTR [esi+56]
	jle	SHORT $LN3@make_prima

; 330  :     { // One or more children must have non-runnable primary jobs
; 331  :       kdu_thread_queue *child;
; 332  :       for (child=children; child != NULL; child=child->sibling_next)

	push	edi
	mov	edi, DWORD PTR [esi+32]
	test	edi, edi
	je	SHORT $LN20@make_prima
$LL4@make_prima:

; 333  :         if (child->subtree_primary_jobs > 0)

	cmp	DWORD PTR [edi+80], 0
	jle	SHORT $LN2@make_prima

; 334  :           child->make_primary_jobs_runnable();

	mov	ecx, edi
	call	?make_primary_jobs_runnable@kdu_thread_queue@@QAEXXZ ; kdu_thread_queue::make_primary_jobs_runnable
$LN2@make_prima:

; 330  :     { // One or more children must have non-runnable primary jobs
; 331  :       kdu_thread_queue *child;
; 332  :       for (child=children; child != NULL; child=child->sibling_next)

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL4@make_prima
$LN20@make_prima:
	pop	edi
$LN3@make_prima:

; 335  :     }
; 336  :   int n = num_primary_jobs;

	mov	eax, DWORD PTR [esi+56]

; 337  :   if (n > 0)

	test	eax, eax
	jle	SHORT $LN6@make_prima

; 338  :     {
; 339  :       kdu_thread_queue *qscn;
; 340  :       num_runnable_jobs += n;

	add	DWORD PTR [esi+60], eax

; 341  :       num_primary_jobs = 0;

	mov	DWORD PTR [esi+56], 0
	npad	7
$LL7@make_prima:

; 342  :       for (qscn=this; qscn != NULL; qscn=qscn->parent)
; 343  :         {
; 344  :           qscn->subtree_runnable_jobs += n;

	add	DWORD PTR [esi+84], eax

; 345  :           qscn->subtree_primary_jobs -= n;

	sub	DWORD PTR [esi+80], eax
	mov	esi, DWORD PTR [esi+20]
	test	esi, esi
	jne	SHORT $LL7@make_prima
$LN6@make_prima:
	pop	esi

; 346  :         }
; 347  :     }
; 348  :   assert(subtree_primary_jobs == 0);
; 349  : }

	ret	0
?make_primary_jobs_runnable@kdu_thread_queue@@QAEXXZ ENDP ; kdu_thread_queue::make_primary_jobs_runnable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?make_subtree_jobs_runnable@kdu_thread_queue@@QAEXXZ
_TEXT	SEGMENT
?make_subtree_jobs_runnable@kdu_thread_queue@@QAEXXZ PROC ; kdu_thread_queue::make_subtree_jobs_runnable, COMDAT
; _this$ = ecx

; 291  : {

	push	esi
	mov	esi, ecx
	push	edi

; 292  :   if ((subtree_unassigned_jobs - subtree_runnable_jobs) >

	mov	ecx, DWORD PTR [esi+76]
	mov	eax, DWORD PTR [esi+52]
	sub	ecx, DWORD PTR [esi+84]
	sub	eax, DWORD PTR [esi+60]
	cmp	ecx, eax
	jle	SHORT $LN3@make_subtr

; 293  :       (num_unassigned_jobs - num_runnable_jobs))
; 294  :     { // One or more children must have more unassigned than runnable jobs
; 295  :       kdu_thread_queue *child;
; 296  :       for (child=children; child != NULL; child=child->sibling_next)

	mov	edi, DWORD PTR [esi+32]
	test	edi, edi
	je	SHORT $LN3@make_subtr
	npad	5
$LL4@make_subtr:

; 297  :         if (child->subtree_unassigned_jobs > child->subtree_runnable_jobs)

	mov	eax, DWORD PTR [edi+76]
	cmp	eax, DWORD PTR [edi+84]
	jle	SHORT $LN2@make_subtr

; 298  :           child->make_subtree_jobs_runnable();

	mov	ecx, edi
	call	?make_subtree_jobs_runnable@kdu_thread_queue@@QAEXXZ ; kdu_thread_queue::make_subtree_jobs_runnable
$LN2@make_subtr:

; 293  :       (num_unassigned_jobs - num_runnable_jobs))
; 294  :     { // One or more children must have more unassigned than runnable jobs
; 295  :       kdu_thread_queue *child;
; 296  :       for (child=children; child != NULL; child=child->sibling_next)

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL4@make_subtr
$LN3@make_subtr:

; 299  :     }
; 300  :   int n = num_unassigned_jobs - num_runnable_jobs;

	mov	edx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [esi+60]
	sub	edx, eax

; 301  :   if (n > 0)

	test	edx, edx
	jle	SHORT $LN6@make_subtr

; 302  :     {
; 303  :       int p = num_primary_jobs;

	mov	edi, DWORD PTR [esi+56]

; 304  :       kdu_thread_queue *qscn;
; 305  :       num_runnable_jobs += n;

	add	eax, edx
	mov	DWORD PTR [esi+60], eax

; 306  :       num_primary_jobs = 0;

	mov	DWORD PTR [esi+56], 0

; 307  :       secondary_pref = 0;

	mov	DWORD PTR [esi+44], 0
	npad	8
$LL7@make_subtr:

; 309  :         {
; 310  :           qscn->subtree_runnable_jobs += n;
; 311  :           qscn->subtree_primary_jobs -= p;

	sub	DWORD PTR [esi+80], edi
	add	DWORD PTR [esi+84], edx
	mov	eax, DWORD PTR [esi+80]

; 312  :           if ((qscn->subtree_runnable_jobs+qscn->subtree_primary_jobs) ==

	add	eax, DWORD PTR [esi+84]
	cmp	eax, DWORD PTR [esi+76]
	jne	SHORT $LN5@make_subtr

; 313  :               qscn->subtree_unassigned_jobs)
; 314  :             qscn->subtree_secondary_pref = 0;

	mov	DWORD PTR [esi+88], 0
$LN5@make_subtr:

; 308  :       for (qscn=this; qscn != NULL; qscn=qscn->parent)

	mov	esi, DWORD PTR [esi+20]
	test	esi, esi
	jne	SHORT $LL7@make_subtr
$LN6@make_subtr:
	pop	edi
	pop	esi

; 315  :         }
; 316  :     }
; 317  :   assert((subtree_runnable_jobs == subtree_unassigned_jobs) &&
; 318  :          (num_runnable_jobs == num_unassigned_jobs) &&
; 319  :          (subtree_primary_jobs == 0));
; 320  : }

	ret	0
?make_subtree_jobs_runnable@kdu_thread_queue@@QAEXXZ ENDP ; kdu_thread_queue::make_subtree_jobs_runnable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?find_unassigned_job@kdu_thread_queue@@QAEPAU1@H@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
_best_secondary$1$ = -4					; size = 4
_thread_idx$ = 8					; size = 4
?find_unassigned_job@kdu_thread_queue@@QAEPAU1@H@Z PROC	; kdu_thread_queue::find_unassigned_job, COMDAT
; _this$ = ecx

; 232  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	edx, ecx

; 233  :   kdu_thread_queue *scan, *next=NULL, *best_secondary=NULL;

	xor	ecx, ecx
	push	ebx
	push	esi

; 234  :   kdu_uint32 best_secondary_pref=0;

	xor	ebx, ebx
	mov	DWORD PTR _this$1$[ebp], edx

; 235  :   for (scan=this; (scan->subtree_runnable_jobs == 0); scan=next)

	mov	eax, edx
	mov	DWORD PTR _best_secondary$1$[ebp], ecx
	push	edi
	cmp	DWORD PTR [edx+84], ecx
	jne	SHORT $LN26@find_unass
	mov	edi, DWORD PTR _thread_idx$[ebp]
	npad	1
$LL4@find_unass:

; 236  :     {
; 237  :       if (scan->subtree_secondary_pref > best_secondary_pref)

	mov	ecx, DWORD PTR [eax+88]
	cmp	ecx, ebx
	jbe	SHORT $LN13@find_unass

; 238  :         {
; 239  :           best_secondary = scan;

	mov	DWORD PTR _best_secondary$1$[ebp], eax

; 240  :           best_secondary_pref = scan->subtree_secondary_pref;

	mov	ebx, ecx
$LN13@find_unass:

; 241  :         }
; 242  :       int n;
; 243  :       for (n=0; n < scan->num_sync_points; n++)

	mov	esi, DWORD PTR [eax+96]
	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN42@find_unass
	lea	edx, DWORD PTR [eax+112]
$LL7@find_unass:

; 244  :         if (scan->sync_points[n].synchronizing_thread_idx == thread_idx)

	cmp	DWORD PTR [edx], edi
	je	SHORT $LN42@find_unass

; 241  :         }
; 242  :       int n;
; 243  :       for (n=0; n < scan->num_sync_points; n++)

	inc	ecx
	add	edx, 24					; 00000018H
	cmp	ecx, esi
	jl	SHORT $LL7@find_unass
$LN42@find_unass:

; 245  :           break;
; 246  :       next = scan->parent;

	mov	edx, DWORD PTR [eax+20]

; 247  :       if ((n < scan->num_sync_points) || (next == NULL))

	cmp	ecx, esi
	jl	SHORT $LN16@find_unass
	test	edx, edx
	jne	SHORT $LN2@find_unass
$LN16@find_unass:

; 248  :         { // Can't go above this point and haven't found any runnable jobs
; 249  :           if (scan->subtree_primary_jobs > 0)

	cmp	DWORD PTR [eax+80], 0
	jle	SHORT $LN17@find_unass

; 250  :             { // Make all primary jobs in the tree runnable and scan again.
; 251  :               scan->make_primary_jobs_runnable();

	mov	ecx, eax
	call	?make_primary_jobs_runnable@kdu_thread_queue@@QAEXXZ ; kdu_thread_queue::make_primary_jobs_runnable

; 252  :               next = this;

	mov	edx, DWORD PTR _this$1$[ebp]
$LN2@find_unass:

; 235  :   for (scan=this; (scan->subtree_runnable_jobs == 0); scan=next)

	cmp	DWORD PTR [edx+84], 0
	mov	eax, edx
	je	SHORT $LL4@find_unass
$LN26@find_unass:

; 263  :             }
; 264  :         }
; 265  :     }
; 266  : 
; 267  :   while (scan->subtree_runnable_jobs > scan->num_runnable_jobs)

	mov	ecx, DWORD PTR [eax+84]
	cmp	ecx, DWORD PTR [eax+60]
	jle	SHORT $LN1@find_unass
	npad	1
$LL8@find_unass:

; 268  :     { // Push down into the descendants as far as we can.
; 269  :       kdu_thread_queue *child, *first_runnable_child=NULL;
; 270  :       for (child = scan->children; child != NULL; child=child->sibling_next)

	mov	eax, DWORD PTR [eax+32]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN44@find_unass
	npad	7
$LL12@find_unass:

; 271  :         if (child->subtree_runnable_jobs > 0)

	cmp	DWORD PTR [eax+84], 0
	jle	SHORT $LN10@find_unass

; 272  :           {
; 273  :             first_runnable_child = child; // We can always follow this child
; 274  :             if (child->num_active_jobs == 0)

	cmp	DWORD PTR [eax+48], 0
	mov	ecx, eax
	je	SHORT $LN43@find_unass
$LN10@find_unass:

; 268  :     { // Push down into the descendants as far as we can.
; 269  :       kdu_thread_queue *child, *first_runnable_child=NULL;
; 270  :       for (child = scan->children; child != NULL; child=child->sibling_next)

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL12@find_unass
$LN43@find_unass:

; 275  :               break; // Immediately follow this child if it has no active jobs;
; 276  :                      // this helps to keep threads working in disjoint queues
; 277  :                      // where possible.
; 278  :           }
; 279  :       assert(first_runnable_child != NULL);
; 280  :       scan = (child==NULL)?first_runnable_child:child;

	test	eax, eax
$LN44@find_unass:
	cmove	eax, ecx
	mov	ecx, DWORD PTR [eax+84]
	cmp	ecx, DWORD PTR [eax+60]
	jg	SHORT $LL8@find_unass
$LN1@find_unass:
	pop	edi
	pop	esi
	pop	ebx

; 281  :     }
; 282  :   return scan;
; 283  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN17@find_unass:

; 253  :             }
; 254  :           else if (best_secondary != NULL)

	mov	ecx, DWORD PTR _best_secondary$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN19@find_unass

; 255  :             {
; 256  :               assert(best_secondary->subtree_unassigned_jobs > 0);
; 257  :               return best_secondary->make_secondary_job_runnable();

	call	?make_secondary_job_runnable@kdu_thread_queue@@QAEPAU1@XZ ; kdu_thread_queue::make_secondary_job_runnable
	pop	edi
	pop	esi
	pop	ebx

; 281  :     }
; 282  :   return scan;
; 283  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN19@find_unass:
	pop	edi
	pop	esi

; 258  :             }
; 259  :           else
; 260  :             {
; 261  :               assert(scan->subtree_unassigned_jobs == 0);
; 262  :               return NULL; // No unassigned jobs available anywhere

	xor	eax, eax
	pop	ebx

; 281  :     }
; 282  :   return scan;
; 283  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?find_unassigned_job@kdu_thread_queue@@QAEPAU1@H@Z ENDP	; kdu_thread_queue::find_unassigned_job
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
;	COMDAT ?check_condition@kdu_thread_queue@@QAE_N_NH@Z
_TEXT	SEGMENT
_waiting_for_sync$ = 8					; size = 1
_thread_idx$ = 12					; size = 4
?check_condition@kdu_thread_queue@@QAE_N_NH@Z PROC	; kdu_thread_queue::check_condition, COMDAT
; _this$ = ecx

; 99   :       { // Returns true if a condition on which the indicated `thread' is

	push	ebp
	mov	ebp, esp

; 100  :         // waiting has been achieved.  This is either a synchronization point,
; 101  :         // installed in the current queue, or completion of all outstanding
; 102  :         // (non-secondary) jobs on the queue.
; 103  :         if (waiting_for_sync)

	cmp	BYTE PTR _waiting_for_sync$[ebp], 0
	je	SHORT $LN2@check_cond

; 104  :           {
; 105  :             assert(num_sync_points > 0);
; 106  :             return (sync_points[0].synchronizing_thread_idx == thread_idx) &&

	mov	eax, DWORD PTR [ecx+112]
	cmp	eax, DWORD PTR _thread_idx$[ebp]
	jne	SHORT $LN4@check_cond
	cmp	DWORD PTR [ecx+104], 0
	jne	SHORT $LN4@check_cond
	cmp	DWORD PTR [ecx+108], 0
	jne	SHORT $LN4@check_cond
	mov	eax, 1

; 112  :       }

	pop	ebp
	ret	8
$LN4@check_cond:

; 104  :           {
; 105  :             assert(num_sync_points > 0);
; 106  :             return (sync_points[0].synchronizing_thread_idx == thread_idx) &&

	xor	eax, eax

; 112  :       }

	pop	ebp
	ret	8
$LN2@check_cond:

; 107  :                    (sync_points[0].synchronization_downcounter == 0) &&
; 108  :                    (sync_points[0].num_unsynchronized_children == 0);
; 109  :           }
; 110  :         assert(num_primary_jobs == 0);
; 111  :         return ((num_runnable_jobs+num_active_jobs) == 0);

	mov	eax, DWORD PTR [ecx+60]
	add	eax, DWORD PTR [ecx+48]
	neg	eax
	sbb	eax, eax
	inc	eax

; 112  :       }

	pop	ebp
	ret	8
?check_condition@kdu_thread_queue@@QAE_N_NH@Z ENDP	; kdu_thread_queue::check_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ??_Gkdu_thread_entity@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gkdu_thread_entity@@UAEPAXI@Z PROC			; kdu_thread_entity::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Gkdu_thread_entity@@UAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	cmp	DWORD PTR [esi+16], 0

; 188  :       { if (is_group_owner()) destroy();

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7kdu_thread_entity@@6B@

; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	je	SHORT $LN8@scalar
	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN8@scalar

; 188  :       { if (is_group_owner()) destroy();

	call	?destroy@kdu_thread_entity@@QAE_NXZ	; kdu_thread_entity::destroy
$LN8@scalar:
	mov	eax, DWORD PTR ___flags$[ebp]
	test	al, 1
	je	SHORT $LN16@scalar
	test	al, 4
	jne	SHORT $LN3@scalar
	push	esi
	call	??3kdu_thread_entity@@SAXPAX@Z		; kdu_thread_entity::operator delete
	add	esp, 4
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN3@scalar:
	push	40					; 00000028H
	push	esi
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN16@scalar:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gkdu_thread_entity@@UAEPAXI@Z$1:
	call	___std_terminate
	ret	0
__ehhandler$??_Gkdu_thread_entity@@UAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Gkdu_thread_entity@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Gkdu_thread_entity@@UAEPAXI@Z ENDP			; kdu_thread_entity::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?worker_startproc@@YGKPAX@Z
_TEXT	SEGMENT
_param$ = 8						; size = 4
?worker_startproc@@YGKPAX@Z PROC			; worker_startproc, COMDAT

; 89   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 90   :   kdu_thread_entity *ent = (kdu_thread_entity *) param;
; 91   : #if (defined _WIN32 && defined _DEBUG && defined _MSC_VER && (_MSC_VER>=1300))
; 92   :   kd_set_threadname("Kakadu Worker Thread");
; 93   : #endif // .NET debug compilation
; 94   :   if (ent->group->cpu_affinity != 0)

	mov	esi, DWORD PTR _param$[ebp]
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+128]
	or	eax, DWORD PTR [ecx+132]
	je	SHORT $LN2@worker_sta
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 385  :                SetThreadAffinityMask(thread,(DWORD) affinity_mask); 

	push	DWORD PTR [ecx+128]
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__SetThreadAffinityMask@8
$LN2@worker_sta:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 96   :   bool result = ent->process_jobs(NULL,false,false);

	push	0
	push	0
	push	0
	mov	ecx, esi
	call	?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z ; kdu_thread_entity::process_jobs
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN12@worker_sta
	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN16@worker_sta
$LN12@worker_sta:

; 182  :     void pre_destroy() { if (!is_group_owner()) group = NULL; }

	mov	DWORD PTR [esi+16], 0
$LN16@worker_sta:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 100  :   return KDU_THREAD_STARTPROC_ZERO_RESULT;

	xor	eax, eax
	pop	esi

; 101  : }

	pop	ebp
	ret	4
?worker_startproc@@YGKPAX@Z ENDP			; worker_startproc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?process_outstanding_sync_points@kdu_thread_entity@@AAE_NPAUkdu_thread_queue@@@Z
_TEXT	SEGMENT
tv733 = -12						; size = 4
tv730 = -8						; size = 4
_propagate_to_parent$1$ = -2				; size = 1
_removed_something$1$ = -1				; size = 1
_queue$ = 8						; size = 4
?process_outstanding_sync_points@kdu_thread_entity@@AAE_NPAUkdu_thread_queue@@@Z PROC ; kdu_thread_entity::process_outstanding_sync_points, COMDAT
; _this$ = ecx

; 1273 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	edi

; 1274 :   bool removed_something = false;
; 1275 :   while (queue->num_sync_points > 0)

	mov	edi, DWORD PTR _queue$[ebp]
	xor	al, al
	mov	ebx, ecx
	mov	BYTE PTR _removed_something$1$[ebp], al
	cmp	DWORD PTR [edi+96], 0
	jle	$LN38@process_ou
	push	esi
	lea	esi, DWORD PTR [edi+100]
$LL2@process_ou:

; 1276 :     {
; 1277 :       kd_thread_sync_point *sp = queue->sync_points;
; 1278 :       if ((sp->synchronization_downcounter > 0) ||

	cmp	DWORD PTR [esi+4], 0
	jg	$LN77@process_ou
	cmp	DWORD PTR [esi+8], 0
	jg	$LN77@process_ou

; 1279 :           (sp->num_unsynchronized_children > 0))
; 1280 :         break;
; 1281 :       if (sp->synchronizing_thread_idx >= 0)

	cmp	DWORD PTR [esi+12], 0
	jge	$LN59@process_ou

; 1286 :           break;
; 1287 :         }
; 1288 : 
; 1289 :       int n;
; 1290 :       bool propagate_to_parent = false;
; 1291 :       if (sp->synchronized_worker != NULL)

	mov	edx, DWORD PTR [esi+16]
	mov	BYTE PTR _propagate_to_parent$1$[ebp], 0
	test	edx, edx
	je	$LN20@process_ou

; 1292 :         {
; 1293 :           if (sp->synchronized_job_in_progress)

	cmp	BYTE PTR [esi+21], 0
	jne	$LN77@process_ou

; 1294 :             break; // Someone else will take it from here
; 1295 :           if (sp->synchronized_job_deferred && (group->num_threads > 1) &&

	cmp	BYTE PTR [esi+20], 0
	je	$LN23@process_ou
	mov	eax, DWORD PTR [ebx+16]
	cmp	DWORD PTR [eax+136], 1
	jle	$LN23@process_ou
	mov	ecx, DWORD PTR [eax+968]
	cmp	ecx, 64					; 00000040H
	jge	$LN23@process_ou

; 1296 :               (group->num_deferred_jobs < KDU_MAX_THREADS))
; 1297 :             { // Add to deferred job queue
; 1298 :               group->deferred_jobs[group->num_deferred_jobs++] =

	mov	DWORD PTR [eax+ecx*4+972], edx
	mov	eax, DWORD PTR [ebx+16]
	inc	DWORD PTR [eax+968]

; 1299 :                 sp->synchronized_worker;
; 1300 :               if (group->num_idle_threads > 0)

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [eax+396]
	mov	DWORD PTR tv730[ebp], ecx
	test	ecx, ecx
	jle	$LN24@process_ou

; 1301 :                 { // Wake up an idle thread
; 1302 :                   for (n=1; n < group->num_threads; n++)

	mov	ecx, DWORD PTR [eax+136]
	mov	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN82@process_ou

; 1303 :                     if (group->thread_activity[n] == NULL)

	add	eax, 404				; 00000194H
$LL6@process_ou:
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN82@process_ou

; 1301 :                 { // Wake up an idle thread
; 1302 :                   for (n=1; n < group->num_threads; n++)

	inc	edx
	add	eax, 4
	cmp	edx, ecx
	jl	SHORT $LL6@process_ou
$LN82@process_ou:

; 1304 :                       break;
; 1305 :                   assert(n < group->num_threads);
; 1306 :                   group->num_idle_threads--;

	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR tv730[ebp]
	dec	eax
	mov	DWORD PTR [ecx+396], eax

; 1307 :                   group->thread_activity[n] = &(group->queue_base);

	mov	ecx, DWORD PTR [ebx+16]
	lea	eax, DWORD PTR [ecx+664]
	mov	DWORD PTR [ecx+edx*4+400], eax

; 1308 :                   group->thread_events[n].set();

	mov	eax, DWORD PTR [ebx+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 687  :           return ((event != NULL) && (SetEvent(event) == TRUE));

	mov	eax, DWORD PTR [eax+edx*4+1264]
	test	eax, eax
	je	SHORT $LN24@process_ou
	push	eax
	call	DWORD PTR __imp__SetEvent@4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1321 :           sp->synchronized_worker = NULL;

	mov	DWORD PTR [esi+16], 0

; 1322 :         }
; 1323 :       else

	jmp	SHORT $LN21@process_ou
$LN23@process_ou:

; 1309 :                 }
; 1310 :             }
; 1311 :           else
; 1312 :             {
; 1313 :               sp->synchronized_job_in_progress = true;

	mov	BYTE PTR [esi+21], 1

; 1314 :               group->mutex.unlock();

	mov	eax, DWORD PTR [ebx+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN46@process_ou
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN46@process_ou:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1315 :               sp->synchronized_worker->do_job(this,-1);

	mov	ecx, DWORD PTR [esi+16]
	push	-1
	push	ebx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]

; 1316 :               if (need_sync())

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	mov	eax, DWORD PTR [eax+20]
	call	eax
	test	al, al
	je	SHORT $LN27@process_ou

; 1317 :                 do_sync(grouperr->failed);

	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, ebx
	mov	edx, DWORD PTR [ebx]
	movzx	eax, BYTE PTR [eax]
	push	eax
	call	DWORD PTR [edx+16]
$LN27@process_ou:

; 1318 :               group->mutex.lock();

	mov	eax, DWORD PTR [ebx+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN50@process_ou
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN50@process_ou:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1319 :               sp->synchronized_job_in_progress = false;

	mov	BYTE PTR [esi+21], 0
$LN24@process_ou:

; 1321 :           sp->synchronized_worker = NULL;

	mov	DWORD PTR [esi+16], 0

; 1322 :         }
; 1323 :       else

	jmp	SHORT $LN21@process_ou
$LN20@process_ou:

; 1324 :         propagate_to_parent = (queue->parent != NULL);

	cmp	DWORD PTR [edi+20], 0
	setne	BYTE PTR _propagate_to_parent$1$[ebp]
$LN21@process_ou:

; 1325 :       queue->num_sync_points--;

	dec	DWORD PTR [edi+96]

; 1326 :       for (n=0; n < queue->num_sync_points; n++)

	xor	ecx, ecx
	cmp	DWORD PTR [edi+96], ecx
	jle	SHORT $LN8@process_ou

; 1325 :       queue->num_sync_points--;

	mov	eax, esi
$LL9@process_ou:

; 1327 :         queue->sync_points[n] = queue->sync_points[n+1];

	movups	xmm0, XMMWORD PTR [eax+24]
	inc	ecx
	movups	XMMWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR [eax+40]
	movq	QWORD PTR [eax+16], xmm0
	add	eax, 24					; 00000018H
	cmp	ecx, DWORD PTR [edi+96]
	jl	SHORT $LL9@process_ou
$LN8@process_ou:

; 1328 :       removed_something = true;
; 1329 : 
; 1330 :       if ((queue->num_sync_points > 0) &&

	cmp	DWORD PTR [edi+96], 0
	mov	BYTE PTR _removed_something$1$[ebp], 1
	jle	$LN14@process_ou
	cmp	DWORD PTR [edi+104], 0
	jne	$LN14@process_ou

; 1331 :           (queue->sync_points[0].synchronization_downcounter == 0))
; 1332 :         {
; 1333 :           sp = queue->sync_points;
; 1334 :           if (sp->finalize_current && (queue->worker != NULL))

	cmp	BYTE PTR [esi+23], 0
	je	SHORT $LN29@process_ou
	cmp	DWORD PTR [edi+40], 0
	je	SHORT $LN29@process_ou

; 1335 :             queue->finalize(group);

	push	DWORD PTR [ebx+16]
	mov	ecx, edi
	call	?finalize@kdu_thread_queue@@QAEXPAUkd_thread_group@@@Z ; kdu_thread_queue::finalize
$LN29@process_ou:

; 1336 : 
; 1337 :           // Install synchronization requirements into children.
; 1338 :           kdu_thread_queue *qscn;
; 1339 :           assert(sp->num_unsynchronized_children == 0);
; 1340 :           for (qscn=queue->children; qscn != NULL; qscn=qscn->sibling_next)

	mov	edi, DWORD PTR [edi+32]
	test	edi, edi
	je	SHORT $LN11@process_ou
$LL12@process_ou:

; 1341 :             if (qscn->install_synchronization_point(NULL,false,-1,

	push	DWORD PTR [ebx+16]
	mov	al, BYTE PTR [esi+22]
	mov	ecx, edi
	push	eax
	push	eax
	push	-1
	push	0
	push	0
	call	?install_synchronization_point@kdu_thread_queue@@QAE_NPAVkdu_worker@@_NH11PAUkd_thread_group@@@Z ; kdu_thread_queue::install_synchronization_point
	test	al, al
	je	SHORT $LN10@process_ou

; 1342 :                            sp->finalize_children,sp->finalize_children,group))
; 1343 :               sp->num_unsynchronized_children++;

	inc	DWORD PTR [esi+8]
$LN10@process_ou:

; 1336 : 
; 1337 :           // Install synchronization requirements into children.
; 1338 :           kdu_thread_queue *qscn;
; 1339 :           assert(sp->num_unsynchronized_children == 0);
; 1340 :           for (qscn=queue->children; qscn != NULL; qscn=qscn->sibling_next)

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL12@process_ou
$LN11@process_ou:

; 1344 :           if (queue->parent == NULL)

	mov	edi, DWORD PTR _queue$[ebp]
	cmp	DWORD PTR [edi+20], 0
	jne	SHORT $LN14@process_ou

; 1345 :             { // Consider dormant queues as though they belonged to the root of
; 1346 :               // the queue hierarchy, for the purpose of installing
; 1347 :               // synchronization conditions.
; 1348 :               assert(queue == &group->queue_base);
; 1349 :               for (qscn=group->dormant_head;

	mov	eax, DWORD PTR [ebx+16]
	mov	edi, DWORD PTR [eax+1228]

; 1350 :                    qscn != NULL; qscn=qscn->sibling_next)

	test	edi, edi
	je	SHORT $LN83@process_ou
	npad	3
$LL15@process_ou:

; 1351 :                 if (qscn->install_synchronization_point(NULL,false,-1,

	push	DWORD PTR [ebx+16]
	mov	al, BYTE PTR [esi+22]
	mov	ecx, edi
	push	eax
	push	eax
	push	-1
	push	0
	push	0
	call	?install_synchronization_point@kdu_thread_queue@@QAE_NPAVkdu_worker@@_NH11PAUkd_thread_group@@@Z ; kdu_thread_queue::install_synchronization_point
	test	al, al
	je	SHORT $LN13@process_ou

; 1352 :                           sp->finalize_children,sp->finalize_children,group))
; 1353 :                   sp->num_unsynchronized_children++;

	inc	DWORD PTR [esi+8]
$LN13@process_ou:

; 1350 :                    qscn != NULL; qscn=qscn->sibling_next)

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL15@process_ou
$LN83@process_ou:
	mov	edi, DWORD PTR _queue$[ebp]
$LN14@process_ou:

; 1354 :             }
; 1355 :         }
; 1356 : 
; 1357 :       if (propagate_to_parent)

	cmp	BYTE PTR _propagate_to_parent$1$[ebp], 0
	je	SHORT $LN34@process_ou

; 1358 :         {
; 1359 :           kdu_thread_queue *parent = queue->parent;

	mov	eax, DWORD PTR [edi+20]

; 1360 :           assert((parent->num_sync_points > 0) &&
; 1361 :                  (parent->sync_points[0].num_unsynchronized_children > 0) &&
; 1362 :                  (parent->sync_points[0].synchronization_downcounter == 0));
; 1363 :           parent->sync_points[0].num_unsynchronized_children--;

	add	DWORD PTR [eax+108], -1

; 1364 :           if (parent->sync_points[0].num_unsynchronized_children == 0)

	jne	SHORT $LN34@process_ou

; 1365 :             process_outstanding_sync_points(parent);

	push	eax
	mov	ecx, ebx
	call	?process_outstanding_sync_points@kdu_thread_entity@@AAE_NPAUkdu_thread_queue@@@Z ; kdu_thread_entity::process_outstanding_sync_points
$LN34@process_ou:

; 1274 :   bool removed_something = false;
; 1275 :   while (queue->num_sync_points > 0)

	cmp	DWORD PTR [edi+96], 0
	jg	$LL2@process_ou

; 1368 :   return removed_something;

	mov	al, BYTE PTR _removed_something$1$[ebp]
	pop	esi
	pop	edi
	pop	ebx

; 1369 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN59@process_ou:

; 1282 :         {
; 1283 :           assert(sp->synchronized_worker == NULL);
; 1284 :           if (sp->synchronizing_thread_idx == queue->thread_awaiting_sync)

	mov	ecx, DWORD PTR [edi+292]
	cmp	DWORD PTR [esi+12], ecx
	jne	SHORT $LN77@process_ou

; 1285 :             group->thread_events[queue->thread_awaiting_sync].set();

	mov	eax, DWORD PTR [ebx+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 687  :           return ((event != NULL) && (SetEvent(event) == TRUE));

	mov	eax, DWORD PTR [eax+ecx*4+1264]
	test	eax, eax
	je	SHORT $LN77@process_ou
	push	eax
	call	DWORD PTR __imp__SetEvent@4
$LN77@process_ou:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1368 :   return removed_something;

	mov	al, BYTE PTR _removed_something$1$[ebp]
	pop	esi
$LN38@process_ou:
	pop	edi
	pop	ebx

; 1369 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?process_outstanding_sync_points@kdu_thread_entity@@AAE_NPAUkdu_thread_queue@@@Z ENDP ; kdu_thread_entity::process_outstanding_sync_points
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?wake_idle_thread@kdu_thread_entity@@AAEXPAUkdu_thread_queue@@@Z
_TEXT	SEGMENT
_this$1$ = -20						; size = 4
_best_thread_idx$1$ = -16				; size = 4
_min_distance$1$ = -12					; size = 4
$T1 = -8						; size = 4
tv477 = -4						; size = 4
_queue$ = 8						; size = 4
?wake_idle_thread@kdu_thread_entity@@AAEXPAUkdu_thread_queue@@@Z PROC ; kdu_thread_entity::wake_idle_thread, COMDAT
; _this$ = ecx

; 1212 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, ecx

; 1213 :   assert((group->num_idle_threads > 0) && (queue->num_runnable_jobs > 0) &&
; 1214 :          (queue->num_active_jobs == 0) && (queue->prescheduled_job_idx < 0));
; 1215 : 
; 1216 :   // Find a good thread to wake up; we do this by measuring the "distance"
; 1217 :   // between each idle thread's most recent queue and the current queue.
; 1218 :   // Here, the "distance" of interest is the minimum number of branches
; 1219 :   // in the tree hierarchy which must be traversed, in order to walk up
; 1220 :   // the tree from one queue and back down to the other queue.  The
; 1221 :   // distance between a node and its parent is thus 1, the distance
; 1222 :   // between two sibling nodes is 2, the distance between a nephew and
; 1223 :   // an uncle is 3, etc.
; 1224 :   int n;
; 1225 :   int best_thread_idx = -1;

	or	edx, -1
	push	ebx
	push	esi
	push	edi

; 1226 :   int min_distance = INT_MAX;
; 1227 :   for (n=0; n < group->num_threads; n++)

	mov	esi, DWORD PTR [eax+16]
	mov	ecx, 2147483647				; 7fffffffH
	xor	ebx, ebx
	mov	DWORD PTR _this$1$[ebp], eax
	mov	DWORD PTR _best_thread_idx$1$[ebp], edx
	mov	DWORD PTR _min_distance$1$[ebp], ecx
	mov	edi, DWORD PTR [esi+136]
	mov	DWORD PTR $T1[ebp], edi
	test	edi, edi
	jle	SHORT $LN3@wake_idle_

; 1228 :     if (group->thread_activity[n] == NULL)

	add	esi, 140				; 0000008cH
	mov	DWORD PTR tv477[ebp], esi
$LL4@wake_idle_:
	cmp	DWORD PTR [esi+260], 0
	jne	SHORT $LN2@wake_idle_

; 1229 :       {
; 1230 :         kdu_thread_entity *thrd = group->threads[n];
; 1231 :         kdu_thread_queue *scan1=queue, *scan2=thrd->recent_queue;

	mov	eax, DWORD PTR [esi]

; 1232 :         int distance=0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [eax+32]

; 1233 :         if (scan2 != NULL)

	test	eax, eax
	je	SHORT $LN12@wake_idle_

; 1234 :           {
; 1235 :             for (; scan1->depth > scan2->depth; scan1=scan1->parent)

	mov	edi, DWORD PTR [eax]
	mov	esi, edx
	cmp	DWORD PTR [esi], edi
	jle	SHORT $LN6@wake_idle_
$LL7@wake_idle_:
	mov	edx, DWORD PTR [edx+20]

; 1236 :               distance++;

	inc	ecx
	cmp	DWORD PTR [edx], edi
	jg	SHORT $LL7@wake_idle_
$LN6@wake_idle_:
	mov	esi, DWORD PTR [edx]

; 1237 :             for (; scan2->depth > scan1->depth; scan2=scan2->parent)

	cmp	edi, esi
	jle	SHORT $LN9@wake_idle_
$LL10@wake_idle_:
	mov	eax, DWORD PTR [eax+20]

; 1238 :               distance++;

	inc	ecx
	cmp	DWORD PTR [eax], esi
	jg	SHORT $LL10@wake_idle_
$LN9@wake_idle_:

; 1239 :             for (; scan1!=scan2; scan1=scan1->parent, scan2=scan2->parent)

	cmp	edx, eax
	je	SHORT $LN45@wake_idle_
$LL13@wake_idle_:
	mov	edx, DWORD PTR [edx+20]

; 1240 :               distance+=2;

	add	ecx, 2
	mov	eax, DWORD PTR [eax+20]
	cmp	edx, eax
	jne	SHORT $LL13@wake_idle_
$LN45@wake_idle_:
	mov	edi, DWORD PTR $T1[ebp]
	mov	esi, DWORD PTR tv477[ebp]
$LN12@wake_idle_:

; 1241 :           }
; 1242 :         if (distance < min_distance)

	cmp	ecx, DWORD PTR _min_distance$1$[ebp]
	jge	SHORT $LN46@wake_idle_

; 1243 :           {
; 1244 :             min_distance = distance;
; 1245 :             best_thread_idx = n;

	mov	edx, ebx
	mov	DWORD PTR _min_distance$1$[ebp], ecx
	mov	DWORD PTR _best_thread_idx$1$[ebp], edx
	jmp	SHORT $LN2@wake_idle_
$LN46@wake_idle_:
	mov	edx, DWORD PTR _best_thread_idx$1$[ebp]
$LN2@wake_idle_:

; 1226 :   int min_distance = INT_MAX;
; 1227 :   for (n=0; n < group->num_threads; n++)

	inc	ebx
	add	esi, 4
	mov	DWORD PTR tv477[ebp], esi
	cmp	ebx, edi
	jl	SHORT $LL4@wake_idle_
$LN3@wake_idle_:

; 1246 :           }
; 1247 :       }
; 1248 : 
; 1249 :   // Pre-schedule this thread to do the next job on the present queue.
; 1250 :   assert((best_thread_idx > 0) &&
; 1251 :          (group->thread_activity[best_thread_idx]==NULL));
; 1252 :   queue->num_active_jobs++;

	mov	ecx, DWORD PTR _queue$[ebp]

; 1253 :   queue->num_unassigned_jobs--;
; 1254 :   queue->num_runnable_jobs--;
; 1255 :   kdu_thread_queue *scan;
; 1256 :   for (scan=queue; scan != NULL; scan=scan->parent)

	mov	eax, ecx
	inc	DWORD PTR [ecx+48]
	dec	DWORD PTR [ecx+52]
	dec	DWORD PTR [ecx+60]
	npad	2
$LL16@wake_idle_:

; 1257 :     {
; 1258 :       scan->subtree_unassigned_jobs--;

	dec	DWORD PTR [eax+76]

; 1259 :       scan->subtree_runnable_jobs--;

	dec	DWORD PTR [eax+84]
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL16@wake_idle_

; 1260 :     }
; 1261 :   queue->prescheduled_job_idx = queue->first_unassigned_job_idx++;

	mov	eax, DWORD PTR [ecx+64]

; 1262 :   group->thread_activity[best_thread_idx] = queue;

	mov	esi, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [ecx+72], eax
	inc	eax
	mov	DWORD PTR [ecx+64], eax
	pop	edi
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+edx*4+400], ecx

; 1263 :   group->num_idle_threads--; // Pre-scheduled threads are no longer idle

	mov	eax, DWORD PTR [esi+16]
	dec	DWORD PTR [eax+396]

; 1264 :   group->thread_events[best_thread_idx].set();

	mov	eax, DWORD PTR [esi+16]
	pop	esi
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 687  :           return ((event != NULL) && (SetEvent(event) == TRUE));

	mov	eax, DWORD PTR [eax+edx*4+1264]
	test	eax, eax
	je	SHORT $LN23@wake_idle_
	push	eax
	call	DWORD PTR __imp__SetEvent@4
$LN23@wake_idle_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1265 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?wake_idle_thread@kdu_thread_entity@@AAEXPAUkdu_thread_queue@@@Z ENDP ; kdu_thread_entity::wake_idle_thread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?on_finished@kdu_thread_entity@@MAEX_N@Z
_TEXT	SEGMENT
_exception_handled$ = 8					; size = 1
?on_finished@kdu_thread_entity@@MAEX_N@Z PROC		; kdu_thread_entity::on_finished, COMDAT
; _this$ = ecx

; 1119 :       on_finished(bool exception_handled) { return; }

	ret	4
?on_finished@kdu_thread_entity@@MAEX_N@Z ENDP		; kdu_thread_entity::on_finished
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?need_sync@kdu_thread_entity@@MAE_NXZ
_TEXT	SEGMENT
?need_sync@kdu_thread_entity@@MAE_NXZ PROC		; kdu_thread_entity::need_sync, COMDAT
; _this$ = ecx

; 1097 :     virtual bool need_sync() { return true; }

	mov	al, 1
	ret	0
?need_sync@kdu_thread_entity@@MAE_NXZ ENDP		; kdu_thread_entity::need_sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?do_sync@kdu_thread_entity@@MAEX_N@Z
_TEXT	SEGMENT
_exception_handled$ = 8					; size = 1
?do_sync@kdu_thread_entity@@MAEX_N@Z PROC		; kdu_thread_entity::do_sync, COMDAT
; _this$ = ecx

; 1073 :       do_sync(bool exception_handled) { return; }

	ret	4
?do_sync@kdu_thread_entity@@MAEX_N@Z ENDP		; kdu_thread_entity::do_sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?release_lock@kdu_thread_entity@@QAEXH@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
?release_lock@kdu_thread_entity@@QAEXH@Z PROC		; kdu_thread_entity::release_lock, COMDAT
; _this$ = ecx

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _lock_id$[ebp]

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [ecx+eax*8+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN5@release_lo
	mov	DWORD PTR _lock_id$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	jmp	DWORD PTR __imp__ReleaseMutex@4
$LN5@release_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
	ret	4
?release_lock@kdu_thread_entity@@QAEXH@Z ENDP		; kdu_thread_entity::release_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?handle_exception@kdu_thread_entity@@UAEXH@Z
_TEXT	SEGMENT
__exception_code$ = 8					; size = 4
?handle_exception@kdu_thread_entity@@UAEXH@Z PROC	; kdu_thread_entity::handle_exception, COMDAT
; _this$ = ecx

; 1169 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 217  :     bool exists() { return (group != NULL); }

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1170 :   if (!exists())

	je	$LN30@handle_exc

; 1174 :   for (n=0; n < group->num_locks; n++)

	push	ebx
	mov	ebx, DWORD PTR __imp__ReleaseMutex@4
	push	edi
	xor	edi, edi
	cmp	DWORD PTR [eax+1520], edi
	jle	SHORT $LN3@handle_exc
$LL4@handle_exc:

; 1175 :     if (group->locks[n].holder == this)

	mov	eax, DWORD PTR [eax+1524]
	lea	ecx, DWORD PTR [edi*8]
	cmp	DWORD PTR [eax+ecx+4], esi
	jne	SHORT $LN2@handle_exc

; 1174 :   for (n=0; n < group->num_locks; n++)

	mov	eax, DWORD PTR [esi+28]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+ecx+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+ecx]
	test	eax, eax
	je	SHORT $LN2@handle_exc
	push	eax
	call	ebx
$LN2@handle_exc:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1174 :   for (n=0; n < group->num_locks; n++)

	mov	eax, DWORD PTR [esi+16]
	inc	edi
	cmp	edi, DWORD PTR [eax+1520]
	jl	SHORT $LL4@handle_exc
$LN3@handle_exc:

; 1176 :       release_lock(n);
; 1177 : 
; 1178 :   group->mutex.lock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN26@handle_exc
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN26@handle_exc:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1179 :   group->num_deferred_jobs = 0;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+968], 0

; 1180 :   group->queue_base.handle_exception(thread_idx);

	mov	ecx, DWORD PTR [esi+16]
	push	DWORD PTR [esi+4]
	add	ecx, 664				; 00000298H
	call	?handle_exception@kdu_thread_queue@@QAEXH@Z ; kdu_thread_queue::handle_exception

; 1181 :   for (kdu_thread_queue *dormant=group->dormant_head;

	mov	eax, DWORD PTR [esi+16]
	mov	edi, DWORD PTR [eax+1228]

; 1182 :        dormant != NULL; dormant=dormant->sibling_next)

	test	edi, edi
	je	SHORT $LN6@handle_exc
	npad	8
$LL7@handle_exc:

; 1183 :     dormant->handle_exception(thread_idx);

	push	DWORD PTR [esi+4]
	mov	ecx, edi
	call	?handle_exception@kdu_thread_queue@@QAEXH@Z ; kdu_thread_queue::handle_exception
	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	SHORT $LL7@handle_exc
$LN6@handle_exc:

; 1184 :   group->activate_dormant_queues(); // Should leave all queues active

	mov	ecx, DWORD PTR [esi+16]
	call	?activate_dormant_queues@kd_thread_group@@QAEXXZ ; kd_thread_group::activate_dormant_queues

; 1185 :   assert((group->dormant_head == NULL) && (group->dormant_tail == NULL));
; 1186 :   
; 1187 :   for (n=0; n < group->num_threads; n++)

	mov	eax, DWORD PTR [esi+16]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+136], ecx
	jle	SHORT $LN9@handle_exc

; 1184 :   group->activate_dormant_queues(); // Should leave all queues active

	mov	edx, 400				; 00000190H
	npad	5
$LL10@handle_exc:

; 1188 :     if ((group->thread_activity[n] != NULL) &&

	lea	edi, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN8@handle_exc
	cmp	eax, 1
	je	SHORT $LN8@handle_exc

; 1189 :         (group->thread_activity[n] != KD_THREAD_ACTIVE))
; 1190 :       { // Found a pre-scheduled thread; the prescheduled job has been
; 1191 :         // destroyed already, so return this thread to the idle state.
; 1192 :         assert(n > 0); // Can't preschedule the group owner
; 1193 :         group->thread_activity[n] = NULL;

	mov	DWORD PTR [edi], 0

; 1194 :         group->num_idle_threads++;

	mov	eax, DWORD PTR [esi+16]
	inc	DWORD PTR [eax+396]
$LN8@handle_exc:

; 1185 :   assert((group->dormant_head == NULL) && (group->dormant_tail == NULL));
; 1186 :   
; 1187 :   for (n=0; n < group->num_threads; n++)

	mov	eax, DWORD PTR [esi+16]
	inc	ecx
	add	edx, 4
	cmp	ecx, DWORD PTR [eax+136]
	jl	SHORT $LL10@handle_exc
$LN9@handle_exc:

; 1195 :         assert(group->num_idle_threads < group->num_threads);
; 1196 :       }
; 1197 :   if (!grouperr->failed)

	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN14@handle_exc

; 1198 :     { // Failing for the first time
; 1199 :       grouperr->failed = true;

	mov	BYTE PTR [eax], 1

; 1200 :       grouperr->failure_code = exception_code;

	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR __exception_code$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN14@handle_exc:

; 1201 :     }
; 1202 : 
; 1203 :   group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN44@handle_exc
	push	eax
	call	ebx
$LN44@handle_exc:
	pop	edi
	pop	ebx
$LN30@handle_exc:
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1204 : }

	pop	ebp
	ret	4
?handle_exception@kdu_thread_entity@@UAEXH@Z ENDP	; kdu_thread_entity::handle_exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z
_TEXT	SEGMENT
_exc$2 = -72						; size = 4
_exc$3 = -68						; size = 4
_exc$4 = -64						; size = 4
_exc$5 = -60						; size = 4
$T6 = -56						; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
$T9 = -44						; size = 4
_job$1$ = -40						; size = 4
_ep$1$ = -40						; size = 4
_n$2$ = -40						; size = 4
_last_queue$ = -40					; size = 4
_mutex$1$ = -36						; size = 4
_run_queue$1$ = -36					; size = 4
_job_number$10 = -32					; size = 4
_this$ = -28						; size = 4
_run_queue$ = -24					; size = 4
_search_start$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_wait_queue$ = 8					; size = 4
_waiting_for_sync$ = 12					; size = 1
_throw_on_failure$ = 16					; size = 1
?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z PROC ; kdu_thread_entity::process_jobs, COMDAT
; _this$ = ecx

; 1379 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 1380 :   assert((wait_queue != NULL) || !is_group_owner());
; 1381 :         // Owner can only call this function with `wait_queue' non-NULL.
; 1382 : 
; 1383 :   group->mutex.lock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN306@process_jo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN306@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1388 :   if ((wait_queue != NULL) && (!waiting_for_sync) &&

	mov	ebx, DWORD PTR _wait_queue$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@process_jo
	cmp	BYTE PTR _waiting_for_sync$[ebp], 0
	jne	SHORT $LN3@process_jo
	mov	ecx, DWORD PTR [ebx+56]
	test	ecx, ecx
	jle	SHORT $LN3@process_jo

; 1389 :       ((n=wait_queue->num_primary_jobs) > 0))
; 1390 :     { // Make all primary jobs runnable
; 1391 :       wait_queue->num_runnable_jobs += n;

	add	DWORD PTR [ebx+60], ecx

; 1392 :       wait_queue->num_primary_jobs = 0;
; 1393 :       for (qscn=wait_queue; qscn != NULL; qscn=qscn->parent)

	mov	eax, ebx
	mov	DWORD PTR [ebx+56], 0
$LL4@process_jo:

; 1394 :         {
; 1395 :           qscn->subtree_runnable_jobs += n;

	add	DWORD PTR [eax+84], ecx

; 1396 :           qscn->subtree_primary_jobs -= n;

	sub	DWORD PTR [eax+80], ecx
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL4@process_jo
$LN3@process_jo:

; 1397 :         }
; 1398 :     }
; 1399 : 
; 1400 :   kdu_thread_queue *run_queue=NULL; // Queue selected for running the next job

	xor	edi, edi
	mov	DWORD PTR _run_queue$[ebp], edi
$LN171@process_jo:

; 1401 :   kdu_thread_queue *last_queue=NULL; // Queue used to run the last job

	xor	ecx, ecx
	mov	DWORD PTR _search_start$1$[ebp], ecx
	npad	3
$LL5@process_jo:

; 1402 : 
; 1403 :   while (1)
; 1404 :     {
; 1405 :       // First, find a queue on which to run a new job, unless a condition
; 1406 :       // on which we are waiting occurs in the meantime, in which case, set
; 1407 :       // `run_queue' to NULL.
; 1408 :       kdu_thread_queue *search_start = last_queue;
; 1409 :       if (search_start == NULL)

	test	ecx, ecx
	jne	SHORT $LN275@process_jo

; 1410 :         search_start = wait_queue;

	mov	ecx, ebx
	mov	DWORD PTR _search_start$1$[ebp], ecx

; 1411 :       if ((search_start == NULL) ||

	test	ebx, ebx
	je	SHORT $LN298@process_jo
$LN275@process_jo:
	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+1244]
	jl	SHORT $LN29@process_jo
	jg	SHORT $LN298@process_jo
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+1240]
	jb	SHORT $LN29@process_jo
$LN298@process_jo:

; 1412 :           (search_start->bank_idx >= group->min_dormant_bank_idx))
; 1413 :         search_start = recent_queue;

	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR _search_start$1$[ebp], ecx
$LN29@process_jo:

; 1414 :       if (search_start == NULL)

	test	ecx, ecx
	jne	SHORT $LL7@process_jo
$LN143@process_jo:

; 1415 :         search_start = &(group->queue_base);

	mov	ecx, DWORD PTR [esi+16]
	add	ecx, 664				; 00000298H
$LN323@process_jo:
	mov	DWORD PTR _search_start$1$[ebp], ecx
	npad	2
$LL7@process_jo:

; 1419 :               !wait_queue->check_condition(waiting_for_sync,thread_idx)) &&

	test	edi, edi
	jne	SHORT $LN8@process_jo
	test	ebx, ebx
	jne	SHORT $LN274@process_jo
	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+968], ebx
	jmp	SHORT $LN321@process_jo
$LN274@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h

; 103  :         if (waiting_for_sync)

	cmp	BYTE PTR _waiting_for_sync$[ebp], 0
	je	SHORT $LN125@process_jo

; 104  :           {
; 105  :             assert(num_sync_points > 0);
; 106  :             return (sync_points[0].synchronizing_thread_idx == thread_idx) &&

	mov	eax, DWORD PTR [ebx+112]
	cmp	eax, DWORD PTR [esi+4]
	jne	SHORT $LN33@process_jo
	cmp	DWORD PTR [ebx+104], 0
	jne	SHORT $LN33@process_jo
	cmp	DWORD PTR [ebx+108], 0
	jne	SHORT $LN33@process_jo
$LN8@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1513 :       if (grouperr->failed && throw_on_failure)

	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	je	$LN54@process_jo
	cmp	BYTE PTR _throw_on_failure$[ebp], 0
	je	$LN54@process_jo

; 1514 :         {
; 1515 :           group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN163@process_jo
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN163@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1516 :           throw grouperr->failure_code;

	mov	eax, DWORD PTR [esi+20]
	push	OFFSET __TI1H
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T8[ebp], eax
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	call	__CxxThrowException@8
$LN326@process_jo:
$LN125@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h

; 111  :         return ((num_runnable_jobs+num_active_jobs) == 0);

	mov	eax, DWORD PTR [ebx+60]
	add	eax, DWORD PTR [ebx+48]
	sete	al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1419 :               !wait_queue->check_condition(waiting_for_sync,thread_idx)) &&

	test	al, al
$LN321@process_jo:
	jne	SHORT $LN8@process_jo
$LN33@process_jo:
	push	DWORD PTR [esi+4]
	call	?find_unassigned_job@kdu_thread_queue@@QAEPAU1@H@Z ; kdu_thread_queue::find_unassigned_job
	mov	edi, eax
	mov	DWORD PTR _run_queue$[ebp], edi
	test	edi, edi
	jne	SHORT $LN8@process_jo

; 1420 :              ((run_queue=search_start->find_unassigned_job(thread_idx))==NULL))
; 1421 :         { // Can't return true yet and can't find a suitable unassigned job;
; 1422 :           // we will need to block
; 1423 :           if (group->destruction_requested ||

	mov	ecx, DWORD PTR [esi+16]
	cmp	BYTE PTR [ecx+1257], al
	jne	$LN35@process_jo
	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN37@process_jo
	cmp	BYTE PTR _throw_on_failure$[ebp], 0
	jne	$LN35@process_jo
$LN37@process_jo:

; 1431 :             }
; 1432 :           if (wait_queue != NULL)

	test	ebx, ebx
	je	SHORT $LN38@process_jo

; 1433 :             {
; 1434 :               if (waiting_for_sync)

	cmp	BYTE PTR _waiting_for_sync$[ebp], 0

; 1435 :                 {
; 1436 :                   assert((wait_queue->num_sync_points > 0) &&
; 1437 :                          (wait_queue->sync_points[0].synchronizing_thread_idx==
; 1438 :                           this->thread_idx)); // Can't have multiple threads
; 1439 :                                    // trying to sync on exactly the same queue
; 1440 :                   wait_queue->thread_awaiting_sync = this->thread_idx;

	mov	eax, DWORD PTR [esi+4]
	je	SHORT $LN40@process_jo
	mov	DWORD PTR [ebx+292], eax

; 1441 :                 }
; 1442 :               else

	jmp	$LN43@process_jo
$LN40@process_jo:

; 1443 :                 wait_queue->thread_awaiting_complete = this->thread_idx;

	mov	DWORD PTR [ebx+296], eax
	jmp	$LN43@process_jo
$LN38@process_jo:

; 1444 :             }
; 1445 :           else if (group->finish_requested && !this->finished)

	cmp	BYTE PTR [ecx+1256], 0
	je	$LN42@process_jo
	cmp	BYTE PTR [esi+36], 0
	jne	$LN42@process_jo
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx+1260]
	test	eax, eax
	je	SHORT $LN135@process_jo
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN135@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1449 :                   on_finished(grouperr->failed);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	movzx	eax, BYTE PTR [eax]
	push	eax
	call	DWORD PTR [edx+24]
	jmp	SHORT $LN322@process_jo
__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$0:

; 1450 :                 }
; 1451 :               catch (int exc) {
; 1452 :                   handle_exception(exc);

	mov	ecx, DWORD PTR _this$[ebp]
	push	DWORD PTR _exc$5[ebp]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 1453 :                 }

	mov	eax, $LN107@process_jo
	ret	0
$LN107@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
	mov	edi, DWORD PTR _run_queue$[ebp]
	mov	ebx, DWORD PTR _wait_queue$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
$LN322@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1457 :               group->mutex.lock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN139@process_jo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN139@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1459 :               group->num_finished_threads++;

	mov	eax, DWORD PTR [esi+16]
	mov	BYTE PTR [esi+36], 1
	inc	DWORD PTR [eax+656]

; 1460 :               if (group->num_finished_threads == group->num_threads)

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+656]
	cmp	eax, DWORD PTR [ecx+136]
	jne	$LN143@process_jo
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 687  :           return ((event != NULL) && (SetEvent(event) == TRUE));

	mov	eax, DWORD PTR [ecx+1264]
	test	eax, eax
	je	$LN143@process_jo
	push	eax
	call	DWORD PTR __imp__SetEvent@4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1464 :               continue;

	jmp	$LN143@process_jo
__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$1:

; 1454 :               catch (...) {
; 1455 :                   handle_exception(0);

	mov	ecx, DWORD PTR _this$[ebp]
	push	0
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 1456 :                 }

	mov	eax, $LN107@process_jo
	ret	0
$LN42@process_jo:

; 1465 :             }
; 1466 :           else
; 1467 :             { // Put ourselves on the idle list; we don't do this if we are
; 1468 :               // waiting on a `wait_queue', in part because the queue must be
; 1469 :               // very nearly ready -- after all, there are no unassigned jobs.
; 1470 :               assert(!is_group_owner());
; 1471 :               assert(group->thread_activity[thread_idx] != NULL);
; 1472 :               group->num_idle_threads++;

	inc	DWORD PTR [ecx+396]

; 1473 :               group->thread_activity[thread_idx] = NULL;

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+ecx*4+400], 0
$LN43@process_jo:

; 1474 :             }
; 1475 :           kdu_event *ep = group->thread_events + thread_idx;

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, 1264				; 000004f0H
	mov	DWORD PTR _ep$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 705  :           return ((event != NULL) && (ResetEvent(event) == TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN147@process_jo
	push	eax
	call	DWORD PTR __imp__ResetEvent@4
$LN147@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1477 :           ep->wait(group->mutex);

	mov	eax, DWORD PTR [esi+16]
	add	eax, 1260				; 000004ecH
	mov	DWORD PTR _mutex$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN155@process_jo
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN155@process_jo:

; 706  : #       elif defined KDU_PTHREADS
; 707  :           event_is_set = false;  return true;
; 708  : #       else
; 709  :           return false;
; 710  : #       endif
; 711  :       }
; 712  :     bool wait(kdu_mutex &mutex)
; 713  :       { /* [SYNOPSIS]
; 714  :              Blocks the caller until the synchronization object becomes
; 715  :              signalled by a prior or future call to `set'.  If the object
; 716  :              is already signalled, the function returns immediately.  In
; 717  :              the case of an auto-reset object (`create'd with `manual_reset'
; 718  :              = false), the function returns the object to the non-singalled
; 719  :              state after a successful return.
; 720  :              [//]
; 721  :              The supplied `mutex' must have been locked by the caller;
; 722  :              moreover all threads which call this event's `wait' function
; 723  :              must lock the same mutex.  Upon return the `mutex' will again
; 724  :              be locked.  If a blocking wait is required, the mutex will
; 725  :              be unlocked during the wait.
; 726  :            [RETURNS]
; 727  :              False if the event has not been successfully created, or if
; 728  :              an error (e.g., deadlock) is detected by the kernel. */
; 729  : #       if defined KDU_WIN_THREADS
; 730  :           mutex.unlock();
; 731  :           bool result = (event != NULL) &&

	mov	eax, DWORD PTR _ep$1$[ebp]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN151@process_jo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN151@process_jo:

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR _mutex$1$[ebp]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN159@process_jo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN159@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1478 :           if (wait_queue == NULL)

	test	ebx, ebx
	jne	SHORT $LN46@process_jo

; 1479 :             { // We have been woken up from the idle state; let's check to see
; 1480 :               // if a job has been pre-scheduled for us by `add_jobs', or if
; 1481 :               // we have been woken up to run a deferred job.
; 1482 :               if (group->thread_activity[thread_idx] != NULL)

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+16]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+400]
	test	eax, eax
	je	SHORT $LN48@process_jo

; 1483 :                 { // Must be pre-scheduled.
; 1484 :                   run_queue = group->thread_activity[thread_idx];

	mov	edi, eax

; 1485 :                   assert(run_queue != KD_THREAD_ACTIVE);
; 1486 :                   if (run_queue == &group->queue_base)

	lea	eax, DWORD PTR [edx+664]
	mov	DWORD PTR _run_queue$[ebp], edi
	cmp	edi, eax
	jne	$LN8@process_jo

; 1487 :                     { // We have been woken up to run a deferred job; we will
; 1488 :                       // have to check that it has not already been serviced
; 1489 :                       // by another thread.  To do this, we mark ourselves
; 1490 :                       // as active and go back to the beginning of the loop.
; 1491 :                       group->thread_activity[thread_idx] = KD_THREAD_ACTIVE;
; 1492 :                       run_queue = NULL;

	xor	edi, edi
	mov	DWORD PTR [ecx+400], 1

; 1493 :                       continue;

	mov	ecx, DWORD PTR _search_start$1$[ebp]
	mov	DWORD PTR _run_queue$[ebp], edi
	jmp	$LL7@process_jo
$LN48@process_jo:

; 1494 :                     }
; 1495 :                   assert(run_queue->prescheduled_job_idx >= 0);
; 1496 :                   break;
; 1497 :                 }
; 1498 :               else
; 1499 :                 { // Thread must still be idle
; 1500 :                   assert(group->num_idle_threads > 0);
; 1501 :                   group->thread_activity[thread_idx] = KD_THREAD_ACTIVE;

	mov	DWORD PTR [ecx+400], 1

; 1502 :                   group->num_idle_threads--;

	mov	eax, DWORD PTR [esi+16]

; 1503 :                   if (group->finish_requested)

	mov	ecx, DWORD PTR _search_start$1$[ebp]
	dec	DWORD PTR [eax+396]
	mov	eax, DWORD PTR [esi+16]
	cmp	BYTE PTR [eax+1256], 0
	je	$LL7@process_jo

; 1504 :                     search_start = &(group->queue_base);

	lea	ecx, DWORD PTR [eax+664]

; 1505 :                 }

	jmp	$LN323@process_jo
$LN46@process_jo:

; 1506 :             }
; 1507 :           else if (waiting_for_sync)

	cmp	BYTE PTR _waiting_for_sync$[ebp], 0

; 1509 :           else

	mov	ecx, DWORD PTR _search_start$1$[ebp]
	je	SHORT $LN52@process_jo

; 1508 :             wait_queue->thread_awaiting_sync = -1;

	mov	DWORD PTR [ebx+292], -1

; 1509 :           else

	jmp	$LL7@process_jo
$LN52@process_jo:

; 1510 :             wait_queue->thread_awaiting_complete = -1;

	mov	DWORD PTR [ebx+296], -1

; 1511 :         }

	jmp	$LL7@process_jo
$LN35@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx+1260]
	test	eax, eax
	je	SHORT $LN131@process_jo
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN131@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1427 :               if (throw_on_failure)

	cmp	BYTE PTR _throw_on_failure$[ebp], 0
	je	SHORT $LN36@process_jo

; 1428 :                 throw grouperr->failure_code;

	mov	eax, DWORD PTR [esi+20]
	push	OFFSET __TI1H
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T9[ebp], eax
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	call	__CxxThrowException@8
$LN327@process_jo:
$LN36@process_jo:

; 1429 :               else
; 1430 :                 return false;

	xor	al, al

; 1789 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN54@process_jo:

; 1517 :         }
; 1518 : 
; 1519 :       // At this point, we can either run something or break out of the loop.
; 1520 :       // Start by checking if we can run a deferred job.  If we can, we will
; 1521 :       // have to first run `do_sync' and set `run_queue' to NULL to force a
; 1522 :       // complete re-evaluation (when we return) of jobs which can be run.
; 1523 :       if ((wait_queue == NULL) && (group->num_deferred_jobs > 0) &&

	test	ebx, ebx
	jne	$LN55@process_jo
	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+968]
	test	edx, edx
	jle	$LN55@process_jo
	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [ecx+eax*4+400], 1
	jne	$LN55@process_jo

; 1524 :           (group->thread_activity[thread_idx] == KD_THREAD_ACTIVE))
; 1525 :         {
; 1526 :           assert(group->num_threads > 1);
; 1527 :           kdu_worker *job = group->deferred_jobs[0];

	mov	eax, DWORD PTR [ecx+972]

; 1528 :           for (int j=1; j < group->num_deferred_jobs; j++)

	lea	edi, DWORD PTR [ebx+1]
	mov	DWORD PTR _job$1$[ebp], eax
	cmp	edx, edi
	jle	SHORT $LN10@process_jo

; 1524 :           (group->thread_activity[thread_idx] == KD_THREAD_ACTIVE))
; 1525 :         {
; 1526 :           assert(group->num_threads > 1);
; 1527 :           kdu_worker *job = group->deferred_jobs[0];

	mov	edx, 972				; 000003ccH
	npad	1
$LL11@process_jo:

; 1529 :             group->deferred_jobs[j-1] = group->deferred_jobs[j];

	mov	ecx, DWORD PTR [esi+16]
	lea	edx, DWORD PTR [edx+4]
	inc	edi
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR [edx+ecx-4], eax
	mov	eax, DWORD PTR [esi+16]
	cmp	edi, DWORD PTR [eax+968]
	jl	SHORT $LL11@process_jo
$LN10@process_jo:

; 1530 :           group->num_deferred_jobs--;

	mov	eax, DWORD PTR [esi+16]

; 1531 :           run_queue = NULL; // Can't trust any job selected by the scheduler

	xor	edi, edi
	mov	DWORD PTR _run_queue$[ebp], edi
	dec	DWORD PTR [eax+968]

; 1532 :                             // to still be unassigned by the time we return
; 1533 :                             // from running the deferred job.
; 1534 :           group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN167@process_jo
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN167@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1536 :               if (need_sync())

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	mov	eax, DWORD PTR [eax+20]
	call	eax
	test	al, al
	je	SHORT $LN57@process_jo

; 1537 :                 do_sync(grouperr->failed);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	movzx	eax, BYTE PTR [eax]
	push	eax
	call	DWORD PTR [edx+16]
$LN57@process_jo:

; 1538 :               job->do_job(this,-1);

	mov	ecx, DWORD PTR _job$1$[ebp]
	push	-1
	push	esi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	jmp	SHORT $LN324@process_jo
__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$3:

; 1539 :             }
; 1540 :           catch (int exc) {
; 1541 :               handle_exception(exc);

	mov	ecx, DWORD PTR _this$[ebp]
	push	DWORD PTR _exc$4[ebp]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 1542 :             }

	mov	eax, $LN111@process_jo
	ret	0
$LN111@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
	mov	edi, DWORD PTR _run_queue$[ebp]
	mov	ebx, DWORD PTR _wait_queue$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
$LN324@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1546 :           group->mutex.lock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	$LN171@process_jo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1548 :           continue;

	jmp	$LN171@process_jo
__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$4:

; 1543 :           catch (...) {
; 1544 :               handle_exception(0);

	mov	ecx, DWORD PTR _this$[ebp]
	push	0
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 1545 :             }

	mov	eax, $LN111@process_jo
	ret	0
$LN55@process_jo:

; 1549 :         }
; 1550 : 
; 1551 :       // At this point `run_queue' is NULL only if a condition on which we
; 1552 :       // are waiting has occurred.  Otherwise, `run_queue' identifies the
; 1553 :       // queue from which the next job is to be scheduled -- it is possible
; 1554 :       // that this is a pre-scheduled job.
; 1555 :       if (run_queue == NULL)

	test	edi, edi
	je	$LN6@process_jo

; 1556 :         break; // Break out of the `while' loop and return true
; 1557 : 
; 1558 :       int job_number=-1;
; 1559 :       if (group->thread_activity[thread_idx] == run_queue)

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+ecx*4+400], edi
	jne	SHORT $LN59@process_jo

; 1560 :         {
; 1561 :           assert(run_queue->prescheduled_job_idx >= 0);
; 1562 :           job_number = run_queue->prescheduled_job_idx;

	mov	eax, DWORD PTR [edi+72]

; 1563 :           run_queue->prescheduled_job_idx = -1;

	mov	DWORD PTR [edi+72], -1

; 1564 :           group->thread_activity[thread_idx] = KD_THREAD_ACTIVE;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _job_number$10[ebp], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+ecx*4+400], 1

; 1565 :         }
; 1566 :       else

	jmp	SHORT $LN60@process_jo
$LN59@process_jo:

; 1567 :         {
; 1568 :           assert((run_queue->num_unassigned_jobs > 0) &&
; 1569 :                  (run_queue->num_runnable_jobs > 0));
; 1570 :           run_queue->num_unassigned_jobs--;

	dec	DWORD PTR [edi+52]

; 1571 :           run_queue->num_runnable_jobs--;
; 1572 :           for (qscn=run_queue; qscn != NULL; qscn=qscn->parent)

	mov	eax, edi
	dec	DWORD PTR [edi+60]
	npad	7
$LL14@process_jo:

; 1573 :             {
; 1574 :               qscn->subtree_unassigned_jobs--;

	dec	DWORD PTR [eax+76]

; 1575 :               qscn->subtree_runnable_jobs--;

	dec	DWORD PTR [eax+84]
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL14@process_jo

; 1576 :             }
; 1577 :           run_queue->num_active_jobs++;
; 1578 :           job_number = run_queue->first_unassigned_job_idx++;

	mov	edx, DWORD PTR [edi+64]
	inc	DWORD PTR [edi+48]
	mov	DWORD PTR _job_number$10[ebp], edx
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [edi+64], eax
$LN60@process_jo:

; 1579 :         }
; 1580 : 
; 1581 :       // Now run the job
; 1582 :       group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN175@process_jo
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN175@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1583 :       if (!throw_on_failure)

	cmp	BYTE PTR _throw_on_failure$[ebp], 0

; 1584 :         { // Catch exceptions thrown from `do_job'
; 1585 :           try {
; 1586 :               run_queue->worker->do_job(this,job_number);

	mov	ecx, DWORD PTR [edi+40]
	push	DWORD PTR _job_number$10[ebp]
	push	esi
	mov	eax, DWORD PTR [ecx]
	jne	SHORT $LN61@process_jo
	mov	DWORD PTR __$EHRec$[ebp+12], 4
	call	DWORD PTR [eax+4]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN62@process_jo
__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$6:

; 1587 :             }
; 1588 :           catch (int exc) {
; 1589 :               handle_exception(exc);

	mov	ecx, DWORD PTR _this$[ebp]
	push	DWORD PTR _exc$3[ebp]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 1590 :             }

	mov	eax, $LN115@process_jo
	ret	0
__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$7:

; 1591 :           catch (...) {
; 1592 :               handle_exception(0);

	mov	ecx, DWORD PTR _this$[ebp]
	push	0
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 1593 :             }

	mov	eax, $LN115@process_jo
	ret	0
$LN115@process_jo:

; 1594 :         }
; 1595 :       else

	mov	esi, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR _wait_queue$[ebp]
	mov	edi, DWORD PTR _run_queue$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN62@process_jo
$LN61@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1596 :         run_queue->worker->do_job(this,job_number);

	call	DWORD PTR [eax+4]
$LN62@process_jo:

; 1597 :       group->mutex.lock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN179@process_jo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN179@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1600 :       if (grouperr->failed)

	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN64@process_jo

; 1601 :         { // Someone must have called `handle_exception'
; 1602 :           assert(run_queue->num_active_jobs == 0);
; 1603 :           run_queue = NULL; // All active jobs should have been cleared by the

	xor	edi, edi

; 1604 :                             // call to `handle_exception'
; 1605 :           if (!throw_on_failure)

	cmp	BYTE PTR _throw_on_failure$[ebp], 0
	mov	DWORD PTR _run_queue$[ebp], edi
	je	$LN171@process_jo

; 1606 :             {
; 1607 :               last_queue = NULL;
; 1608 :               continue; // Just keep looping
; 1609 :             }
; 1610 :           group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN183@process_jo
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN183@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1611 :           throw grouperr->failure_code;

	mov	eax, DWORD PTR [esi+20]
	push	OFFSET __TI1H
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T7[ebp], eax
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	__CxxThrowException@8
$LN328@process_jo:
$LN64@process_jo:

; 1612 :         }
; 1613 : 
; 1614 :       // If we get here, a job has been successfully run and must now be
; 1615 :       // cleared from its queue.  This may trigger all sorts of happy
; 1616 :       // occurrences based on installed synchronization points.
; 1617 :       last_queue = run_queue;

	mov	ecx, edi

; 1618 :       run_queue = NULL; // We may pre-assign a run-queue for the next job here

	xor	edi, edi
	mov	DWORD PTR _search_start$1$[ebp], ecx
	mov	DWORD PTR _last_queue$[ebp], ecx
	mov	DWORD PTR _run_queue$1$[ebp], edi
	mov	DWORD PTR _run_queue$[ebp], edi

; 1619 :       assert(last_queue->num_active_jobs > 0);
; 1620 : 
; 1621 :       // Need to determine whether or not `do_sync' is needed.  If true,
; 1622 :       // it should be called now, before we mark the current job as
; 1623 :       // finished.  Here are the conditions under which `do_sync' may
; 1624 :       // need to be called:
; 1625 :       //   (I) `last_queue' is not a leaf node; or
; 1626 :       //  (II) there are no runnable jobs which can be allocated to the current
; 1627 :       //       thread either from `last_queue', or from its parent or
; 1628 :       //       any of its siblings; or
; 1629 :       //  (III) `last_queue' is a leaf node which is associated with a
; 1630 :       //        synchronization condition (its parent must have the same
; 1631 :       //        synchronization condition) and the synchronization condition
; 1632 :       //        might occur before any further jobs are run on the current
; 1633 :       //        thread.  This can happen if the conditions required for the
; 1634 :       //        synchronization condition with respect to `last_queue' have
; 1635 :       //        just been satisfied and we are not about to run any job in
; 1636 :       //        a sibling queue which is required for the synchronization
; 1637 :       //        condition to be fulfilled.  If this condition is tested and
; 1638 :       //        rejected, `run_queue' is left pointing to the queue from which
; 1639 :       //        the next job must be taken -- it will be picked up in the next
; 1640 :       //        execution of the `while' loop.
; 1641 :       bool need_do_sync =
; 1642 :         (last_queue->children != NULL) || // Case I
; 1643 :         (last_queue->parent == NULL) ||

	cmp	DWORD PTR [ecx+32], edi
	jne	$LN273@process_jo
	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN273@process_jo
	cmp	DWORD PTR [eax+84], edi
	je	SHORT $LN273@process_jo

; 1644 :         (last_queue->parent->subtree_runnable_jobs == 0); // Case II
; 1645 :       if ((!need_do_sync) && (last_queue->num_sync_points > 0) &&

	cmp	DWORD PTR [ecx+96], edi
	jle	$LN74@process_jo
	mov	edx, DWORD PTR [ecx+100]
	cmp	DWORD PTR _job_number$10[ebp], edx
	jge	$LN74@process_jo

; 1646 :           (job_number < last_queue->sync_points[0].synchronization_threshold))
; 1647 :         { // Considering Case III.
; 1648 :           assert((last_queue->parent->num_sync_points > 0) &&
; 1649 :            (last_queue->parent->sync_points[0].num_unsynchronized_children>0));
; 1650 :                // Above assertion should be true because synchronization
; 1651 :                // points cannot be directly installed in leaf nodes and
; 1652 :                // we have already verified that we are a leaf node.
; 1653 :           if (last_queue->num_runnable_jobs > 0)

	cmp	DWORD PTR [ecx+60], edi
	jle	SHORT $LN67@process_jo

; 1654 :             { // The next job will come from the current queue unless we
; 1655 :               // have to execute a synchronization handler, in which case we
; 1656 :               // will run `do_sync' separately at that point.
; 1657 :               need_do_sync =

	cmp	DWORD PTR [ecx+64], edx
	setge	al

; 1679 :                     (run_queue->first_unassigned_job_idx <
; 1680 :                      run_queue->sync_points[0].synchronization_threshold))
; 1681 :                   { need_do_sync = false; break; }
; 1682 :             }
; 1683 :         }
; 1684 :       if (need_do_sync && need_sync())

	test	al, al
	je	$LN74@process_jo
	jmp	SHORT $LN273@process_jo
$LN67@process_jo:

; 1658 :                 (last_queue->first_unassigned_job_idx >=
; 1659 :                last_queue->sync_points[0].synchronization_threshold);
; 1660 :             }
; 1661 :           else if ((wait_queue == last_queue) && (!waiting_for_sync) &&

	cmp	ebx, ecx
	jne	SHORT $LN69@process_jo
	cmp	BYTE PTR _waiting_for_sync$[ebp], 0
	jne	SHORT $LN69@process_jo
	cmp	DWORD PTR [ebx+48], 1
	je	$LN74@process_jo
$LN69@process_jo:

; 1662 :                    (wait_queue->num_active_jobs == 1))
; 1663 :             { // In this case, we are about to quit the loop and return,
; 1664 :               // since we have just satisfied the simple non-synchronizing
; 1665 :               // wait condition with which we entered.  In this case, there
; 1666 :               // is no point in hunting for a next job to run and we will
; 1667 :               // be running `do_sync' right before returning from the function
; 1668 :               // so there is no need to mark `need_do_sync' as true here.
; 1669 :               need_do_sync = false;
; 1670 :             }
; 1671 :           else
; 1672 :             { // See if there is a sibling which has a job to run, on which
; 1673 :               // our parent is waiting.
; 1674 :               need_do_sync = true;
; 1675 :               for (run_queue=last_queue->parent->children;

	mov	edi, DWORD PTR [eax+32]
	mov	DWORD PTR _run_queue$1$[ebp], edi
	mov	DWORD PTR _run_queue$[ebp], edi

; 1676 :                    run_queue != NULL; run_queue=run_queue->sibling_next)

	test	edi, edi
	je	SHORT $LN273@process_jo
$LL17@process_jo:

; 1677 :                 if ((run_queue->num_sync_points > 0) &&
; 1678 :                     (run_queue->num_runnable_jobs > 0) &&

	cmp	DWORD PTR [edi+96], 0
	jle	SHORT $LN15@process_jo
	cmp	DWORD PTR [edi+60], 0
	jle	SHORT $LN15@process_jo
	mov	eax, DWORD PTR [edi+64]
	cmp	eax, DWORD PTR [edi+100]
	jl	$LN74@process_jo
$LN15@process_jo:

; 1676 :                    run_queue != NULL; run_queue=run_queue->sibling_next)

	mov	edi, DWORD PTR [edi+24]
	mov	DWORD PTR _run_queue$1$[ebp], edi
	mov	DWORD PTR _run_queue$[ebp], edi
	test	edi, edi
	jne	SHORT $LL17@process_jo
$LN273@process_jo:

; 1679 :                     (run_queue->first_unassigned_job_idx <
; 1680 :                      run_queue->sync_points[0].synchronization_threshold))
; 1681 :                   { need_do_sync = false; break; }
; 1682 :             }
; 1683 :         }
; 1684 :       if (need_do_sync && need_sync())

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	eax, DWORD PTR [eax+20]
	call	eax
	test	al, al
	je	$LN317@process_jo

; 1685 :         {
; 1686 :           assert(run_queue == NULL);
; 1687 :           group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN187@process_jo
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN187@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1689 :               do_sync(grouperr->failed);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[ebp+12], 6
	movzx	eax, BYTE PTR [eax]
	push	eax
	call	DWORD PTR [edx+16]
	jmp	SHORT $LN325@process_jo
__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$9:

; 1690 :             }
; 1691 :           catch (int exc) {
; 1692 :               handle_exception(exc);

	mov	ecx, DWORD PTR _this$[ebp]
	push	DWORD PTR _exc$2[ebp]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 1693 :             }

	mov	eax, $LN119@process_jo
	ret	0
$LN119@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
	mov	eax, DWORD PTR _last_queue$[ebp]
	mov	edi, DWORD PTR _run_queue$[ebp]
	mov	ebx, DWORD PTR _wait_queue$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	DWORD PTR _search_start$1$[ebp], eax
	mov	DWORD PTR _run_queue$1$[ebp], edi
$LN325@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1697 :           group->mutex.lock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN191@process_jo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN191@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1698 :           if (grouperr->failed)

	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN317@process_jo

; 1699 :             { // Someone must have called `handle_exception'
; 1700 :               assert(last_queue->num_active_jobs == 0);
; 1701 :               last_queue = NULL; // All active jobs should have been cleared by
; 1702 :                                  // the call to `handle_exception'
; 1703 :               last_queue = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _search_start$1$[ebp], ecx

; 1704 :               if (!throw_on_failure)

	cmp	BYTE PTR _throw_on_failure$[ebp], cl
	je	$LL5@process_jo

; 1705 :                 continue; // Just keep looping
; 1706 :               group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN195@process_jo
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN195@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1707 :               throw grouperr->failure_code;

	mov	eax, DWORD PTR [esi+20]
	push	OFFSET __TI1H
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T6[ebp], eax
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	__CxxThrowException@8
$LN329@process_jo:
__catch$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z$10:

; 1694 :           catch (...) {
; 1695 :               handle_exception(0);

	mov	ecx, DWORD PTR _this$[ebp]
	push	0
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 1696 :             }

	mov	eax, $LN119@process_jo
	ret	0
$LN317@process_jo:
	mov	ecx, DWORD PTR _search_start$1$[ebp]
$LN74@process_jo:

; 1708 :             }
; 1709 :         }
; 1710 : 
; 1711 :       last_queue->num_active_jobs--;

	add	DWORD PTR [ecx+48], -1

; 1712 : 
; 1713 :       // Check to see if the queue is all finished
; 1714 :       if ((last_queue->num_active_jobs == 0) &&

	jne	SHORT $LN79@process_jo
	mov	eax, DWORD PTR [ecx+64]
	cmp	eax, DWORD PTR [ecx+68]
	jne	SHORT $LN79@process_jo

; 1715 :           (last_queue->first_unassigned_job_idx ==
; 1716 :            last_queue->max_jobs_in_queue))
; 1717 :         {
; 1718 :           last_queue->worker = NULL;
; 1719 :           if (last_queue->subtree_working_leaves == 0)

	cmp	DWORD PTR [ecx+92], 0
	mov	DWORD PTR [ecx+40], 0
	jne	SHORT $LN79@process_jo

; 1720 :             { // `last_queue' was a working leaf, which is no longer working
; 1721 :               for (qscn=last_queue->parent; qscn != NULL; qscn=qscn->parent)

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN226@process_jo
$LL20@process_jo:

; 1722 :                 {
; 1723 :                   qscn->subtree_working_leaves--;

	add	DWORD PTR [eax+92], -1

; 1724 :                   if ((qscn->subtree_working_leaves == 0) &&

	jne	SHORT $LN18@process_jo
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN226@process_jo
$LN18@process_jo:

; 1720 :             { // `last_queue' was a working leaf, which is no longer working
; 1721 :               for (qscn=last_queue->parent; qscn != NULL; qscn=qscn->parent)

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL20@process_jo
$LN226@process_jo:

; 1725 :                       (qscn->worker != NULL))
; 1726 :                     break;  // Num working leaves along this branch is still
; 1727 :                       // exactly 1, because `qscn' is now a working leaf.
; 1728 :                 }
; 1729 :               if ((group->dormant_head != NULL) &&

	mov	edx, DWORD PTR [esi+16]
	cmp	DWORD PTR [edx+1228], 0
	je	SHORT $LN79@process_jo
	mov	eax, DWORD PTR [edx+756]
	cmp	eax, DWORD PTR [edx+136]
	jge	SHORT $LN79@process_jo

; 1730 :                   (group->queue_base.subtree_working_leaves <
; 1731 :                    group->num_threads))
; 1732 :                 group->activate_dormant_queues();

	mov	ecx, edx
	call	?activate_dormant_queues@kd_thread_group@@QAEXXZ ; kd_thread_group::activate_dormant_queues
	mov	ecx, DWORD PTR _search_start$1$[ebp]
$LN79@process_jo:

; 1733 :             }
; 1734 :         }
; 1735 : 
; 1736 :       // Check to see if a synchronization condition has been
; 1737 :       // reached for the first time.
; 1738 :       for (n=0; n < last_queue->num_sync_points; n++)

	xor	edx, edx
	mov	DWORD PTR _n$2$[ebp], edx
	cmp	DWORD PTR [ecx+96], edx
	jle	$LN22@process_jo
	npad	4
$LL23@process_jo:

; 1739 :         if (job_number < last_queue->sync_points[n].synchronization_threshold)

	lea	eax, DWORD PTR [edx+edx*2]
	lea	edi, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _job_number$10[ebp]
	cmp	eax, DWORD PTR [edi+100]
	jge	SHORT $LN21@process_jo

; 1740 :           {
; 1741 :             kd_thread_sync_point *sp = last_queue->sync_points+n;
; 1742 :             assert(sp->synchronization_downcounter > 0);
; 1743 :             sp->synchronization_downcounter--;

	dec	DWORD PTR [edi+104]

; 1744 :             if ((n == 0) && (sp->synchronization_downcounter == 0))

	test	edx, edx
	jne	SHORT $LN21@process_jo
	cmp	DWORD PTR [edi+104], edx
	jne	SHORT $LN21@process_jo

; 1745 :               {
; 1746 :                 if (sp->finalize_current && (last_queue->worker != NULL))

	cmp	BYTE PTR [edi+123], dl
	je	SHORT $LN82@process_jo
	cmp	DWORD PTR [ecx+40], edx
	je	SHORT $LN82@process_jo

; 1747 :                   last_queue->finalize(group);

	push	DWORD PTR [esi+16]
	call	?finalize@kdu_thread_queue@@QAEXPAUkd_thread_group@@@Z ; kdu_thread_queue::finalize
	mov	ecx, DWORD PTR _search_start$1$[ebp]
$LN82@process_jo:

; 1748 :                 assert(sp->num_unsynchronized_children == 0);
; 1749 :                 for (qscn=last_queue->children;

	mov	ebx, DWORD PTR [ecx+32]

; 1750 :                      qscn != NULL; qscn=qscn->sibling_next)

	test	ebx, ebx
	je	SHORT $LN25@process_jo
$LL26@process_jo:

; 1751 :                   if (qscn->install_synchronization_point(NULL,false,-1,

	push	DWORD PTR [esi+16]
	mov	al, BYTE PTR [edi+122]
	mov	ecx, ebx
	push	eax
	push	eax
	push	-1
	push	0
	push	0
	call	?install_synchronization_point@kdu_thread_queue@@QAE_NPAVkdu_worker@@_NH11PAUkd_thread_group@@@Z ; kdu_thread_queue::install_synchronization_point
	test	al, al
	je	SHORT $LN24@process_jo

; 1752 :                              sp->finalize_children,sp->finalize_children,group))
; 1753 :                     sp->num_unsynchronized_children++;

	inc	DWORD PTR [edi+108]
$LN24@process_jo:

; 1750 :                      qscn != NULL; qscn=qscn->sibling_next)

	mov	ebx, DWORD PTR [ebx+24]
	test	ebx, ebx
	jne	SHORT $LL26@process_jo
	mov	ecx, DWORD PTR _search_start$1$[ebp]
$LN25@process_jo:

; 1754 :                 if ((sp->num_unsynchronized_children == 0) &&

	cmp	DWORD PTR [edi+108], 0
	jne	SHORT $LN318@process_jo
	push	ecx
	mov	ecx, esi
	call	?process_outstanding_sync_points@kdu_thread_entity@@AAE_NPAUkdu_thread_queue@@@Z ; kdu_thread_entity::process_outstanding_sync_points
	mov	edx, DWORD PTR _n$2$[ebp]
	test	al, al
	mov	ecx, DWORD PTR _search_start$1$[ebp]
	mov	eax, -1
	cmovne	edx, eax
	jmp	SHORT $LN21@process_jo
$LN318@process_jo:
	mov	edx, DWORD PTR _n$2$[ebp]
$LN21@process_jo:

; 1733 :             }
; 1734 :         }
; 1735 : 
; 1736 :       // Check to see if a synchronization condition has been
; 1737 :       // reached for the first time.
; 1738 :       for (n=0; n < last_queue->num_sync_points; n++)

	inc	edx
	mov	DWORD PTR _n$2$[ebp], edx
	cmp	edx, DWORD PTR [ecx+96]
	jl	$LL23@process_jo
	mov	edi, DWORD PTR _run_queue$1$[ebp]
	mov	ebx, DWORD PTR _wait_queue$[ebp]
$LN22@process_jo:

; 1762 :       if ((last_queue->thread_awaiting_complete >= 0) &&

	mov	edx, DWORD PTR [ecx+296]
	test	edx, edx
	js	SHORT $LN204@process_jo
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h

; 111  :         return ((num_runnable_jobs+num_active_jobs) == 0);

	mov	eax, DWORD PTR [ecx+60]
	add	eax, DWORD PTR [ecx+48]
	sete	al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1762 :       if ((last_queue->thread_awaiting_complete >= 0) &&

	test	al, al
	je	SHORT $LN204@process_jo

; 1763 :           last_queue->check_condition(false,-1))
; 1764 :         {
; 1765 :           assert(last_queue->thread_awaiting_complete != this->thread_idx);
; 1766 :                   // We only mark ourselves as `waiting_complete' while we are
; 1767 :                   // blocked on our thread event object.
; 1768 :           group->thread_events[last_queue->thread_awaiting_complete].set();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 687  :           return ((event != NULL) && (SetEvent(event) == TRUE));

	mov	eax, DWORD PTR [eax+edx*4+1264]
	test	eax, eax
	je	SHORT $LN204@process_jo
	push	eax
	call	DWORD PTR __imp__SetEvent@4
	mov	ecx, DWORD PTR _search_start$1$[ebp]
$LN204@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1771 :       if ((wait_queue != NULL) &&

	test	ebx, ebx
	je	SHORT $LN86@process_jo
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h

; 103  :         if (waiting_for_sync)

	cmp	BYTE PTR _waiting_for_sync$[ebp], 0
	je	SHORT $LN207@process_jo

; 104  :           {
; 105  :             assert(num_sync_points > 0);
; 106  :             return (sync_points[0].synchronizing_thread_idx == thread_idx) &&

	mov	eax, DWORD PTR [ebx+112]
	cmp	eax, DWORD PTR [esi+4]
	jne	SHORT $LN86@process_jo
	cmp	DWORD PTR [ebx+104], 0
	jne	SHORT $LN86@process_jo
	cmp	DWORD PTR [ebx+108], 0
	jne	SHORT $LN86@process_jo
$LN6@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1785 :   group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN213@process_jo
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN213@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1786 :   if (need_sync())

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	eax, DWORD PTR [eax+20]
	call	eax
	test	al, al
	je	SHORT $LN88@process_jo

; 1787 :     do_sync(grouperr->failed);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	movzx	eax, BYTE PTR [eax]
	push	eax
	call	DWORD PTR [edx+16]
$LN88@process_jo:

; 1788 :   return true;

	mov	al, 1

; 1789 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN207@process_jo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h

; 111  :         return ((num_runnable_jobs+num_active_jobs) == 0);

	mov	eax, DWORD PTR [ebx+60]
	add	eax, DWORD PTR [ebx+48]
	sete	al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1771 :       if ((wait_queue != NULL) &&

	test	al, al
	jne	SHORT $LN6@process_jo
$LN86@process_jo:

; 1772 :           wait_queue->check_condition(waiting_for_sync,thread_idx))
; 1773 :         {
; 1774 :           break; // Break out of `while' loop to return true
; 1775 :         }
; 1776 : 
; 1777 :       if ((run_queue == NULL) && (last_queue->num_runnable_jobs > 0))

	test	edi, edi
	jne	SHORT $LN87@process_jo
	cmp	DWORD PTR [ecx+60], edi
	cmovg	edi, ecx
	mov	DWORD PTR _run_queue$[ebp], edi
$LN87@process_jo:

; 1778 :         run_queue = last_queue; // Move on to next job in the same queue.
; 1779 : 
; 1780 :       // Mark `last_queue' as our most `recent_queue'.
; 1781 :       this->recent_queue = last_queue;

	mov	DWORD PTR [esi+32], ecx

; 1782 :     }

	jmp	$LL5@process_jo
$LN320@process_jo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z ENDP ; kdu_thread_entity::process_jobs
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?register_synchronized_job@kdu_thread_entity@@QAEXPAVkdu_worker@@PAUkdu_thread_queue@@_N@Z
_TEXT	SEGMENT
_sync_worker$ = 8					; size = 4
_runnable_now$1$ = 11					; size = 1
_root$ = 12						; size = 4
_run_deferred$ = 16					; size = 1
?register_synchronized_job@kdu_thread_entity@@QAEXPAVkdu_worker@@PAUkdu_thread_queue@@_N@Z PROC ; kdu_thread_entity::register_synchronized_job, COMDAT
; _this$ = ecx

; 1037 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 217  :     bool exists() { return (group != NULL); }

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1038 :   if (!exists())

	je	$LN11@register_s

; 1039 :     return;
; 1040 : 
; 1041 :   int n;
; 1042 :   for (n=0; n < group->num_locks; n++)

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [eax+1520], edi
	jle	SHORT $LN3@register_s
	npad	4
$LL4@register_s:

; 1043 :     if (group->locks[n].holder == this)

	mov	eax, DWORD PTR [eax+1524]
	cmp	DWORD PTR [eax+edi*8+4], esi
	jne	SHORT $LN2@register_s

; 1044 :       handle_exception(0); // Must have forgotten to handle an exception

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	0
	call	DWORD PTR [eax+12]
$LN2@register_s:

; 1039 :     return;
; 1040 : 
; 1041 :   int n;
; 1042 :   for (n=0; n < group->num_locks; n++)

	mov	eax, DWORD PTR [esi+16]
	inc	edi
	cmp	edi, DWORD PTR [eax+1520]
	jl	SHORT $LL4@register_s
$LN3@register_s:

; 1045 : 
; 1046 :   if (root == NULL)

	mov	edi, DWORD PTR _root$[ebp]
	test	edi, edi
	jne	SHORT $LN8@register_s

; 1047 :     {
; 1048 :       root = &(group->queue_base);

	mov	edi, DWORD PTR [esi+16]
	add	edi, 664				; 00000298H

; 1049 :       if (root->children == NULL)

	cmp	DWORD PTR [edi+32], 0
	jne	SHORT $LN8@register_s

; 1050 :         { // Just execute the synchronized job immediately and return
; 1051 :           if (!grouperr->failed)

	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	jne	$LN27@register_s

; 1052 :             sync_worker->do_job(this,-1);

	mov	ecx, DWORD PTR _sync_worker$[ebp]
	push	-1
	push	esi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	pop	edi
	pop	esi

; 1077 : }

	pop	ebp
	ret	12					; 0000000cH
$LN8@register_s:

; 1053 :           return;
; 1054 :         }
; 1055 :     }
; 1056 : 
; 1057 :   group->mutex.lock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN17@register_s
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN17@register_s:
	push	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1065 :     !root->install_synchronization_point(sync_worker,run_deferred,-1,

	push	DWORD PTR [esi+16]
	mov	ebx, DWORD PTR _sync_worker$[ebp]
	mov	ecx, edi
	push	0
	push	0
	push	-1
	push	DWORD PTR _run_deferred$[ebp]
	push	ebx
	call	?install_synchronization_point@kdu_thread_queue@@QAE_NPAVkdu_worker@@_NH11PAUkd_thread_group@@@Z ; kdu_thread_queue::install_synchronization_point
	test	al, al
	sete	cl
	mov	BYTE PTR _runnable_now$1$[ebp], cl

; 1066 :                                          false,false,group);
; 1067 :   if (runnable_now && run_deferred && (group->num_threads > 1) &&

	test	cl, cl
	je	SHORT $LN10@register_s
	cmp	BYTE PTR _run_deferred$[ebp], 0
	je	SHORT $LN10@register_s
	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+136], 1
	jle	SHORT $LN10@register_s
	mov	ecx, DWORD PTR [eax+968]
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN10@register_s

; 1068 :       (group->num_deferred_jobs < KDU_MAX_THREADS))
; 1069 :     {
; 1070 :       group->deferred_jobs[group->num_deferred_jobs++] = sync_worker;

	mov	DWORD PTR [eax+ecx*4+972], ebx
	mov	eax, DWORD PTR [esi+16]

; 1071 :       runnable_now = false;

	mov	BYTE PTR _runnable_now$1$[ebp], 0
	inc	DWORD PTR [eax+968]
$LN10@register_s:

; 1072 :     }
; 1073 : 
; 1074 :   group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN21@register_s
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN21@register_s:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1075 :   if (runnable_now && !grouperr->failed)

	cmp	BYTE PTR _runnable_now$1$[ebp], 0
	je	SHORT $LN28@register_s
	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN28@register_s

; 1076 :     sync_worker->do_job(this,-1);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	push	-1
	push	esi
	call	DWORD PTR [eax+4]
$LN28@register_s:
	pop	ebx
$LN27@register_s:
	pop	edi
$LN11@register_s:
	pop	esi

; 1077 : }

	pop	ebp
	ret	12					; 0000000cH
?register_synchronized_job@kdu_thread_entity@@QAEXPAVkdu_worker@@PAUkdu_thread_queue@@_N@Z ENDP ; kdu_thread_entity::register_synchronized_job
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?terminate@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_NPAH@Z
_TEXT	SEGMENT
_root$ = 8						; size = 4
_failed$1$ = 11						; size = 1
_leave_root$ = 12					; size = 1
__exception_code$ = 16					; size = 4
?terminate@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_NPAH@Z PROC ; kdu_thread_entity::terminate, COMDAT
; _this$ = ecx

; 1086 : {

	push	ebp
	mov	ebp, esp

; 1087 :   synchronize(root,true,!leave_root);

	cmp	BYTE PTR _leave_root$[ebp], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR _root$[ebp]
	sete	al
	movzx	eax, al
	mov	esi, ecx
	push	eax
	push	1
	push	edi
	call	?synchronize@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z ; kdu_thread_entity::synchronize

; 1088 :   bool failed = grouperr->failed;

	mov	eax, DWORD PTR [esi+20]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _failed$1$[ebp], cl

; 1089 :   if (failed && (exception_code != NULL))

	test	cl, cl
	je	SHORT $LN16@terminate
	mov	ecx, DWORD PTR __exception_code$[ebp]
	test	ecx, ecx
	je	SHORT $LN101@terminate

; 1090 :     *exception_code = grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], eax
$LN101@terminate:
	mov	cl, BYTE PTR _failed$1$[ebp]
$LN16@terminate:

; 1091 :   if (root == NULL)

	test	edi, edi
	jne	SHORT $LN18@terminate

; 1092 :     {
; 1093 :       root = &(group->queue_base);

	mov	edi, DWORD PTR [esi+16]
	add	edi, 664				; 00000298H

; 1094 :       leave_root = true;

	mov	BYTE PTR _leave_root$[ebp], 1

; 1095 :       if (root->children == NULL)

	cmp	DWORD PTR [edi+32], 0
	jne	SHORT $LN18@terminate

; 1096 :         return !failed; // Nothing to do.

	xor	eax, eax
	test	cl, cl
	pop	edi

; 1160 :   return !failed;

	sete	al
	pop	esi

; 1161 : }

	pop	ebp
	ret	12					; 0000000cH
$LN18@terminate:

; 1097 :     }
; 1098 :   
; 1099 :   group->mutex.lock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN31@terminate
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN31@terminate:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1105 :   for (n=0; n < group->num_threads; n++)

	mov	eax, DWORD PTR [esi+16]
	xor	ecx, ecx
	push	ebx
	cmp	DWORD PTR [eax+136], ecx
	jle	SHORT $LN3@terminate
	mov	edx, 140				; 0000008cH
$LL4@terminate:

; 1106 :     {
; 1107 :       kdu_thread_entity *thrd = group->threads[n];

	mov	eax, DWORD PTR [esi+16]
	mov	ebx, DWORD PTR [edx+eax]

; 1108 :       kdu_thread_queue *qp = thrd->recent_queue;

	mov	eax, DWORD PTR [ebx+32]

; 1109 :       if ((qp == NULL) || ((qp == root) && leave_root))

	test	eax, eax
	je	SHORT $LN2@terminate
	cmp	eax, edi
	jne	SHORT $LN108@terminate
	cmp	BYTE PTR _leave_root$[ebp], 0
	jne	SHORT $LN2@terminate
	npad	4
$LL97@terminate:

; 1112 :         if (qp == root)

	cmp	eax, edi
	je	SHORT $LN66@terminate
$LN108@terminate:

; 1110 :         continue;
; 1111 :       for (; (qp != NULL); qp=qp->parent)

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL97@terminate

; 1113 :           break;
; 1114 :       if (qp != NULL)

	jmp	SHORT $LN2@terminate
$LN66@terminate:
	test	eax, eax
	je	SHORT $LN2@terminate

; 1115 :         thrd->recent_queue = NULL;

	mov	DWORD PTR [ebx+32], 0
$LN2@terminate:

; 1105 :   for (n=0; n < group->num_threads; n++)

	mov	eax, DWORD PTR [esi+16]
	inc	ecx
	add	edx, 4
	cmp	ecx, DWORD PTR [eax+136]
	jl	SHORT $LL4@terminate
$LN3@terminate:

; 1116 :     }
; 1117 : 
; 1118 :   // Release all terminated queues
; 1119 :   if (!leave_root)

	cmp	BYTE PTR _leave_root$[ebp], 0
	jne	SHORT $LN26@terminate

; 1120 :     { // Detach root queue from the hierarchy
; 1121 :       assert(root->num_unassigned_jobs == 0);
; 1122 :       if (root->sibling_prev == NULL)

	mov	ecx, DWORD PTR [edi+28]

; 1123 :         {
; 1124 :           assert(root->parent->children == root);
; 1125 :           root->parent->children = root->sibling_next;

	mov	eax, DWORD PTR [edi+24]
	test	ecx, ecx
	jne	SHORT $LN24@terminate
	mov	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR [ecx+32], eax

; 1126 :         }
; 1127 :       else

	jmp	SHORT $LN25@terminate
$LN24@terminate:

; 1128 :         root->sibling_prev->sibling_next = root->sibling_next;

	mov	DWORD PTR [ecx+24], eax
$LN25@terminate:

; 1129 :       if (root->sibling_next != NULL)

	mov	ecx, DWORD PTR [edi+24]
	test	ecx, ecx
	je	SHORT $LN26@terminate

; 1130 :         root->sibling_next->sibling_prev = root->sibling_prev;

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [ecx+28], eax
$LN26@terminate:

; 1131 :     }
; 1132 :   group->release_queues(root,leave_root);

	push	DWORD PTR _leave_root$[ebp]
	mov	ecx, DWORD PTR [esi+16]
	push	edi
	call	?release_queues@kd_thread_group@@QAEXPAUkdu_thread_queue@@_N@Z ; kd_thread_group::release_queues

; 1133 : 
; 1134 :   group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	ebx, DWORD PTR __imp__ReleaseMutex@4
	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN35@terminate
	push	eax
	call	ebx
$LN35@terminate:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1136 :   if (group->queue_base.children == NULL)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+696], 0
	jne	$LN59@terminate

; 1137 :     { // Need to get all threads to execute their `on_finished' function.
; 1138 :       assert(this->is_group_owner() && (group->num_finished_threads == 0));
; 1139 :       this->on_finished(grouperr->failed);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	movzx	eax, BYTE PTR [eax]
	push	eax
	call	DWORD PTR [edx+24]

; 1140 :       this->finished = true;
; 1141 :       group->mutex.lock();

	mov	eax, DWORD PTR [esi+16]
	mov	BYTE PTR [esi+36], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN39@terminate
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN39@terminate:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1142 :       group->num_finished_threads = 1;

	mov	eax, DWORD PTR [esi+16]

; 1144 :       for (n=1; n < group->num_threads; n++)

	mov	edi, 1
	mov	DWORD PTR [eax+656], 1
	mov	eax, DWORD PTR [esi+16]
	mov	BYTE PTR [eax+1256], 1
	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+136], edi
	jle	SHORT $LN64@terminate

; 1142 :       group->num_finished_threads = 1;

	mov	ebx, 1268				; 000004f4H
$LL10@terminate:

; 1144 :       for (n=1; n < group->num_threads; n++)

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 687  :           return ((event != NULL) && (SetEvent(event) == TRUE));

	mov	eax, DWORD PTR [eax+ebx]
	test	eax, eax
	je	SHORT $LN8@terminate
	push	eax
	call	DWORD PTR __imp__SetEvent@4
$LN8@terminate:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1144 :       for (n=1; n < group->num_threads; n++)

	mov	eax, DWORD PTR [esi+16]
	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR [eax+136]
	jl	SHORT $LL10@terminate
	mov	ebx, DWORD PTR __imp__ReleaseMutex@4
$LN64@terminate:

; 1146 :       while (group->num_finished_threads < group->num_threads)

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+656]
	cmp	eax, DWORD PTR [ecx+136]
	jge	SHORT $LN12@terminate
	npad	4
$LL11@terminate:

; 1147 :         group->thread_events[0].wait(group->mutex);

	mov	edi, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [edi+1260]
	test	eax, eax
	je	SHORT $LN51@terminate
	push	eax
	call	ebx
$LN51@terminate:

; 688  : #       elif defined KDU_PTHREADS
; 689  :           if (event_is_set) return true;
; 690  :           event_is_set = true;
; 691  :           if (manual_reset)
; 692  :             return (pthread_cond_broadcast(&cond) == 0);
; 693  :           else
; 694  :             return (pthread_cond_signal(&cond) == 0);
; 695  : #       else
; 696  :           return false;
; 697  : #       endif
; 698  :       }
; 699  :     bool reset()
; 700  :       { /* [SYNOPSIS]
; 701  :              See `set' and `create' for an explanation.
; 702  :            [RETURNS]
; 703  :              False if the event has not been successfully created. */
; 704  : #       if defined KDU_WIN_THREADS
; 705  :           return ((event != NULL) && (ResetEvent(event) == TRUE));
; 706  : #       elif defined KDU_PTHREADS
; 707  :           event_is_set = false;  return true;
; 708  : #       else
; 709  :           return false;
; 710  : #       endif
; 711  :       }
; 712  :     bool wait(kdu_mutex &mutex)
; 713  :       { /* [SYNOPSIS]
; 714  :              Blocks the caller until the synchronization object becomes
; 715  :              signalled by a prior or future call to `set'.  If the object
; 716  :              is already signalled, the function returns immediately.  In
; 717  :              the case of an auto-reset object (`create'd with `manual_reset'
; 718  :              = false), the function returns the object to the non-singalled
; 719  :              state after a successful return.
; 720  :              [//]
; 721  :              The supplied `mutex' must have been locked by the caller;
; 722  :              moreover all threads which call this event's `wait' function
; 723  :              must lock the same mutex.  Upon return the `mutex' will again
; 724  :              be locked.  If a blocking wait is required, the mutex will
; 725  :              be unlocked during the wait.
; 726  :            [RETURNS]
; 727  :              False if the event has not been successfully created, or if
; 728  :              an error (e.g., deadlock) is detected by the kernel. */
; 729  : #       if defined KDU_WIN_THREADS
; 730  :           mutex.unlock();
; 731  :           bool result = (event != NULL) &&

	mov	eax, DWORD PTR [edi+1264]
	test	eax, eax
	je	SHORT $LN47@terminate
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN47@terminate:

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi+1260]
	test	eax, eax
	je	SHORT $LN55@terminate
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN55@terminate:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1146 :       while (group->num_finished_threads < group->num_threads)

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+656]
	cmp	eax, DWORD PTR [ecx+136]
	jl	SHORT $LL11@terminate
$LN12@terminate:

; 1148 :       assert(group->num_deferred_jobs == 0);
; 1149 :       group->finish_requested = 0;

	mov	eax, DWORD PTR [esi+16]

; 1150 :       group->num_finished_threads = 0;
; 1151 :       for (n=0; n < group->num_threads; n++)

	xor	edx, edx
	mov	BYTE PTR [eax+1256], 0
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+656], 0
	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+136], edx
	jle	SHORT $LN14@terminate

; 1148 :       assert(group->num_deferred_jobs == 0);
; 1149 :       group->finish_requested = 0;

	mov	ecx, 140				; 0000008cH
$LL15@terminate:

; 1152 :         {
; 1153 :           assert(group->threads[n]->finished);
; 1154 :           group->threads[n]->finished = false;

	mov	eax, DWORD PTR [esi+16]
	lea	ecx, DWORD PTR [ecx+4]
	inc	edx
	mov	eax, DWORD PTR [ecx+eax-4]
	mov	BYTE PTR [eax+36], 0
	mov	eax, DWORD PTR [esi+16]
	cmp	edx, DWORD PTR [eax+136]
	jl	SHORT $LL15@terminate
$LN14@terminate:

; 1155 :         }
; 1156 :       grouperr->failed = false;

	mov	eax, DWORD PTR [esi+20]
	mov	BYTE PTR [eax], 0

; 1157 :       grouperr->failure_code = -1;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+4], -1

; 1158 :       group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN59@terminate
	push	eax
	call	ebx
$LN59@terminate:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1160 :   return !failed;

	xor	eax, eax
	cmp	BYTE PTR _failed$1$[ebp], al
	pop	ebx
	pop	edi
	sete	al
	pop	esi

; 1161 : }

	pop	ebp
	ret	12					; 0000000cH
?terminate@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_NPAH@Z ENDP ; kdu_thread_entity::terminate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?synchronize@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z
_TEXT	SEGMENT
_root$ = 8						; size = 4
_success$1$ = 11					; size = 1
_finalize_descendants$ = 12				; size = 1
_finalize_root$ = 16					; size = 1
?synchronize@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z PROC ; kdu_thread_entity::synchronize, COMDAT
; _this$ = ecx

; 973  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 217  :     bool exists() { return (group != NULL); }

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 975  :   if (!exists())

	jne	SHORT $LN8@synchroniz

; 976  :     return true;

	mov	al, 1
	pop	esi

; 1027 : }

	pop	ebp
	ret	12					; 0000000cH
$LN8@synchroniz:
	push	edi

; 977  : 
; 978  :   for (n=0; n < group->num_locks; n++)

	xor	edi, edi
	cmp	DWORD PTR [eax+1520], edi
	jle	SHORT $LN3@synchroniz
	npad	1
$LL4@synchroniz:

; 979  :     if (group->locks[n].holder == this)

	mov	eax, DWORD PTR [eax+1524]
	cmp	DWORD PTR [eax+edi*8+4], esi
	jne	SHORT $LN2@synchroniz

; 980  :       handle_exception(0); // Must have forgotten to handle an exception

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	0
	call	DWORD PTR [eax+12]
$LN2@synchroniz:

; 977  : 
; 978  :   for (n=0; n < group->num_locks; n++)

	mov	eax, DWORD PTR [esi+16]
	inc	edi
	cmp	edi, DWORD PTR [eax+1520]
	jl	SHORT $LL4@synchroniz
$LN3@synchroniz:

; 981  : 
; 982  :   if (root == NULL)

	mov	edi, DWORD PTR _root$[ebp]
	test	edi, edi
	jne	SHORT $LN11@synchroniz

; 983  :     {
; 984  :       root = &(group->queue_base);

	mov	eax, DWORD PTR [esi+16]

; 985  :       if ((root->children == NULL) && (group->dormant_head == NULL))

	cmp	DWORD PTR [eax+696], 0
	lea	edi, DWORD PTR [eax+664]
	jne	SHORT $LN11@synchroniz
	cmp	DWORD PTR [eax+1228], 0
	je	$LN33@synchroniz
$LN11@synchroniz:

; 986  :         return !grouperr->failed; // Nothing to synchronize
; 987  :     }
; 988  : 
; 989  :   group->mutex.lock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN21@synchroniz
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN21@synchroniz:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 997  :   if (root->install_synchronization_point(NULL,false,thread_idx,

	push	DWORD PTR [esi+16]
	mov	ecx, edi
	push	DWORD PTR _finalize_root$[ebp]
	push	DWORD PTR _finalize_descendants$[ebp]
	push	DWORD PTR [esi+4]
	push	0
	push	0
	call	?install_synchronization_point@kdu_thread_queue@@QAE_NPAVkdu_worker@@_NH11PAUkd_thread_group@@@Z ; kdu_thread_queue::install_synchronization_point
	mov	ecx, DWORD PTR __imp__ReleaseMutex@4
	test	al, al
	je	SHORT $LN15@synchroniz

; 998  :                                     finalize_descendants,finalize_root,group))
; 999  :     {
; 1000 :       group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN25@synchroniz
	push	eax
	call	ecx
$LN25@synchroniz:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1001 :       bool success = process_jobs(root,true,false);

	push	0
	push	1
	push	edi
	mov	ecx, esi
	call	?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z ; kdu_thread_entity::process_jobs

; 1002 :       group->mutex.lock();

	mov	ecx, DWORD PTR [esi+16]
	mov	BYTE PTR _success$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	ecx, DWORD PTR [ecx+1260]
	test	ecx, ecx
	je	SHORT $LN29@synchroniz
	push	-1
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	al, BYTE PTR _success$1$[ebp]
$LN29@synchroniz:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1004 :       if (!success)

	test	al, al
	je	SHORT $LN44@synchroniz

; 1018 :           for (n=0; n < root->num_sync_points; n++)

	dec	DWORD PTR [edi+96]
	xor	ecx, ecx
	cmp	DWORD PTR [edi+96], ecx
	jle	SHORT $LN6@synchroniz

; 1005 :         { // Synchronization condition should have been removed by the
; 1006 :           // call to `handle_exception' from within `process_jobs'
; 1007 :           assert((root->num_sync_points == 0) ||
; 1008 :                  (root->sync_points[0].synchronizing_thread_idx!=thread_idx));
; 1009 :         }
; 1010 :       else
; 1011 :         { // Need to remove the synchronization condition and take a look at
; 1012 :           // any other sync points on the list, possibly running synchronized
; 1013 :           // jobs and/or waking up other synchronizing threads.
; 1014 :           assert((root->num_sync_points > 0) &&
; 1015 :                  (root->sync_points[0].synchronizing_thread_idx==thread_idx) &&
; 1016 :                  root->check_condition(true,thread_idx));
; 1017 :           root->num_sync_points--;

	lea	eax, DWORD PTR [edi+100]
$LL7@synchroniz:

; 1019 :             root->sync_points[n] = root->sync_points[n+1];

	movups	xmm0, XMMWORD PTR [eax+24]
	inc	ecx
	lea	eax, DWORD PTR [eax+24]
	movups	XMMWORD PTR [eax-24], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [eax-8], xmm0
	cmp	ecx, DWORD PTR [edi+96]
	jl	SHORT $LL7@synchroniz
$LN6@synchroniz:

; 1020 :           if (root->num_sync_points > 0)

	cmp	DWORD PTR [edi+96], 0
	jle	SHORT $LN44@synchroniz

; 1021 :             process_outstanding_sync_points(root);

	push	edi
	mov	ecx, esi
	call	?process_outstanding_sync_points@kdu_thread_entity@@AAE_NPAUkdu_thread_queue@@@Z ; kdu_thread_entity::process_outstanding_sync_points
$LN44@synchroniz:
	mov	ecx, DWORD PTR __imp__ReleaseMutex@4
$LN15@synchroniz:

; 1022 :         }
; 1023 :     }
; 1024 : 
; 1025 :   group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN33@synchroniz
	push	eax
	call	ecx
$LN33@synchroniz:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 1026 :   return !grouperr->failed;

	mov	ecx, DWORD PTR [esi+20]
	xor	eax, eax
	pop	edi
	pop	esi
	cmp	BYTE PTR [ecx], al
	sete	al

; 1027 : }

	pop	ebp
	ret	12					; 0000000cH
?synchronize@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z ENDP ; kdu_thread_entity::synchronize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z
_TEXT	SEGMENT
tv511 = -20						; size = 4
_this$1$ = -16						; size = 4
_delta_runnable_jobs$1$ = -12				; size = 4
_delta_primary_jobs$1$ = -8				; size = 4
_delta_secondary_jobs$1$ = -4				; size = 4
_queue$ = 8						; size = 4
_num_jobs$ = 12						; size = 4
$T1 = 16						; size = 4
_finalize_queue$ = 16					; size = 1
_is_dormant$1$ = 19					; size = 1
_secondary_seq$ = 20					; size = 4
?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z PROC ; kdu_thread_entity::add_jobs, COMDAT
; _this$ = ecx

; 860  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 861  :   if (queue->worker == NULL)

	mov	esi, DWORD PTR _queue$[ebp]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi
	cmp	DWORD PTR [esi+40], 0
	je	$LN43@add_jobs

; 862  :     {
; 863  :       assert(num_jobs == 0);
; 864  :       return;
; 865  :     }
; 866  :   group->mutex.lock();

	mov	eax, DWORD PTR [edi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN31@add_jobs
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN31@add_jobs:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 867  :   if (queue->worker == NULL)

	cmp	DWORD PTR [esi+40], 0
	jne	SHORT $LN9@add_jobs

; 868  :     { // We have to check again while the mutex is locked, just to be sure.
; 869  :       group->mutex.unlock();

	mov	eax, DWORD PTR [edi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	$LN43@add_jobs
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	pop	edi
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 964  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN9@add_jobs:

; 870  :       return;
; 871  :     }
; 872  :   if (grouperr->failed)

	mov	eax, DWORD PTR [edi+20]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN10@add_jobs

; 873  :     { // We don't want to go adding jobs to a queue after a thread has
; 874  :       // already called its `handle_exception' function, since beyond that
; 875  :       // point no queue should have any unassigned jobs.
; 876  :       group->mutex.unlock();

	mov	eax, DWORD PTR [edi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	$LN39@add_jobs
	jmp	$LN57@add_jobs
$LN10@add_jobs:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 879  :   if (finalize_queue)

	cmp	BYTE PTR _finalize_queue$[ebp], 0
	push	ebx
	mov	ebx, DWORD PTR _num_jobs$[ebp]
	je	SHORT $LN14@add_jobs

; 880  :     {
; 881  :       if (num_jobs == 0)

	test	ebx, ebx
	jne	SHORT $LN13@add_jobs

; 882  :         queue->finalize(group);

	push	DWORD PTR [edi+16]
	mov	ecx, esi
	call	?finalize@kdu_thread_queue@@QAEXPAUkd_thread_group@@@Z ; kdu_thread_queue::finalize

; 883  :       else

	jmp	SHORT $LN14@add_jobs
$LN13@add_jobs:

; 884  :         queue->max_jobs_in_queue = num_jobs +

	mov	eax, DWORD PTR [esi+64]
	add	eax, DWORD PTR [esi+52]
	add	eax, ebx
	mov	DWORD PTR [esi+68], eax
$LN14@add_jobs:

; 885  :           queue->first_unassigned_job_idx + queue->num_unassigned_jobs;
; 886  :     }
; 887  :   else
; 888  :     assert(queue->max_jobs_in_queue == 0);
; 889  : 
; 890  :   kdu_thread_queue *scan;
; 891  :   int delta_runnable_jobs = 0;
; 892  :   int delta_secondary_jobs = 0;
; 893  :   int delta_primary_jobs = queue->num_unassigned_jobs -

	mov	eax, DWORD PTR [esi+52]
	mov	edx, eax
	sub	edx, DWORD PTR [esi+56]
	sub	edx, DWORD PTR [esi+60]
	mov	DWORD PTR _delta_runnable_jobs$1$[ebp], 0
	mov	DWORD PTR _delta_secondary_jobs$1$[ebp], 0
	mov	DWORD PTR _delta_primary_jobs$1$[ebp], edx

; 894  :         (queue->num_primary_jobs + queue->num_runnable_jobs);
; 895  :             // Make any existing secondary jobs primary.
; 896  :   assert(delta_primary_jobs >= 0);
; 897  :   if ((delta_primary_jobs == 0) && (num_jobs == 0))

	jne	SHORT $LN15@add_jobs
	test	ebx, ebx
	jne	SHORT $LN15@add_jobs

; 898  :     { // Nothing more to do
; 899  :       group->mutex.unlock();

	mov	ecx, DWORD PTR [edi+16]
	add	ecx, 1260				; 000004ecH
	call	?unlock@kdu_mutex@@QAE_NXZ		; kdu_mutex::unlock
	pop	ebx
	pop	edi
	pop	esi

; 964  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN15@add_jobs:

; 900  :       return;
; 901  :     }
; 902  : 
; 903  :   if (secondary_seq != 0)

	mov	ecx, DWORD PTR _secondary_seq$[ebp]
	test	ecx, ecx
	je	SHORT $LN16@add_jobs

; 904  :     delta_secondary_jobs = num_jobs;

	mov	DWORD PTR _delta_secondary_jobs$1$[ebp], ebx

; 905  :   else

	jmp	SHORT $LN17@add_jobs
$LN16@add_jobs:

; 906  :     delta_primary_jobs += num_jobs;

	add	edx, ebx
	mov	DWORD PTR _delta_primary_jobs$1$[ebp], edx
$LN17@add_jobs:

; 907  :   queue->num_unassigned_jobs += num_jobs;
; 908  :   queue->num_primary_jobs += delta_primary_jobs;

	add	DWORD PTR [esi+56], edx
	add	eax, ebx
	mov	DWORD PTR [esi+52], eax

; 909  :   bool is_dormant = (queue->bank_idx >= group->min_dormant_bank_idx);

	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR tv511[ebp], eax
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [ecx+1244]
	mov	ecx, DWORD PTR _secondary_seq$[ebp]
	jl	SHORT $LN27@add_jobs
	jg	SHORT $LN53@add_jobs
	mov	ebx, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [ebx+1240]
	mov	ebx, DWORD PTR _num_jobs$[ebp]
	jb	SHORT $LN27@add_jobs
$LN53@add_jobs:
	mov	BYTE PTR _is_dormant$1$[ebp], 1
	jmp	SHORT $LN28@add_jobs
$LN27@add_jobs:
	mov	BYTE PTR _is_dormant$1$[ebp], 0
$LN28@add_jobs:

; 910  :   if ((group->num_idle_threads > 0) && (queue->num_unassigned_jobs > 0) &&

	mov	eax, DWORD PTR [edi+16]
	cmp	DWORD PTR [eax+396], 0
	jle	SHORT $LN18@add_jobs
	cmp	DWORD PTR tv511[ebp], 0
	jle	SHORT $LN18@add_jobs
	cmp	BYTE PTR _is_dormant$1$[ebp], 0
	jne	SHORT $LN18@add_jobs

; 911  :       !is_dormant)
; 912  :     { // Make the appropriate number of jobs runnable
; 913  :       delta_runnable_jobs = queue->num_primary_jobs;

	mov	eax, DWORD PTR [esi+56]

; 914  :       delta_primary_jobs -= delta_runnable_jobs;

	sub	edx, eax
	mov	DWORD PTR _delta_runnable_jobs$1$[ebp], eax
	mov	DWORD PTR _delta_primary_jobs$1$[ebp], edx

; 915  :       queue->num_primary_jobs = 0;

	mov	DWORD PTR [esi+56], 0

; 916  :       if (delta_runnable_jobs == 0)

	test	eax, eax
	jne	SHORT $LN19@add_jobs

; 917  :         {
; 918  :           assert(delta_secondary_jobs > 0);
; 919  :           delta_secondary_jobs--;

	dec	DWORD PTR _delta_secondary_jobs$1$[ebp]

; 920  :           delta_runnable_jobs++;

	mov	eax, 1
	mov	DWORD PTR _delta_runnable_jobs$1$[ebp], eax
$LN19@add_jobs:

; 921  :         }
; 922  :       queue->num_runnable_jobs += delta_runnable_jobs;

	add	DWORD PTR [esi+60], eax
$LN18@add_jobs:

; 923  :     }
; 924  : 
; 925  :   if (delta_secondary_jobs > 0)

	cmp	DWORD PTR _delta_secondary_jobs$1$[ebp], 0
	mov	edi, DWORD PTR _delta_runnable_jobs$1$[ebp]
	jle	SHORT $LN20@add_jobs

; 926  :     {
; 927  :       assert(secondary_seq != 0);
; 928  :       kdu_uint32 sp, secondary_pref = (~secondary_seq) + 1;

	not	ecx

; 929  :       queue->secondary_pref = secondary_pref;
; 930  :       for (scan=queue; scan != NULL; scan=scan->parent)

	mov	eax, esi
	inc	ecx
	mov	DWORD PTR [esi+44], ecx
	mov	esi, DWORD PTR _delta_primary_jobs$1$[ebp]
	npad	4
$LL4@add_jobs:

; 931  :         {
; 932  :           scan->subtree_unassigned_jobs += num_jobs;

	add	DWORD PTR [eax+76], ebx

; 933  :           scan->subtree_primary_jobs += delta_primary_jobs;

	add	DWORD PTR [eax+80], esi

; 934  :           scan->subtree_runnable_jobs += delta_runnable_jobs;

	add	DWORD PTR [eax+84], edi

; 935  :           if ((sp = scan->subtree_secondary_pref) < secondary_pref)

	mov	edx, DWORD PTR [eax+88]
	cmp	edx, ecx
	jae	SHORT $LN22@add_jobs

; 936  :             scan->subtree_secondary_pref = secondary_pref;

	mov	DWORD PTR [eax+88], ecx

; 937  :           else

	jmp	SHORT $LN2@add_jobs
$LN22@add_jobs:

; 938  :             secondary_pref = sp;

	mov	ecx, edx
$LN2@add_jobs:

; 929  :       queue->secondary_pref = secondary_pref;
; 930  :       for (scan=queue; scan != NULL; scan=scan->parent)

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL4@add_jobs

; 939  :         }
; 940  :     }
; 941  :   else

	jmp	SHORT $LN56@add_jobs
$LN20@add_jobs:

; 942  :     {
; 943  :       assert((queue->num_runnable_jobs + queue->num_primary_jobs) ==
; 944  :              queue->num_unassigned_jobs);
; 945  :       queue->secondary_pref = 0;

	mov	DWORD PTR [esi+44], 0

; 946  :       for (scan=queue; scan != NULL; scan=scan->parent)

	mov	edx, esi
	mov	esi, DWORD PTR _delta_primary_jobs$1$[ebp]
	npad	4
$LL7@add_jobs:

; 947  :         {
; 948  :           scan->subtree_unassigned_jobs += num_jobs;
; 949  :           scan->subtree_primary_jobs += delta_primary_jobs;
; 950  :           scan->subtree_runnable_jobs += delta_runnable_jobs;

	add	DWORD PTR [edx+84], edi
	add	DWORD PTR [edx+80], esi
	mov	eax, DWORD PTR [edx+84]

; 951  :           if ((scan->subtree_runnable_jobs + scan->subtree_primary_jobs) ==

	add	eax, DWORD PTR [edx+80]
	add	DWORD PTR [edx+76], ebx
	cmp	eax, DWORD PTR [edx+76]
	jne	SHORT $LN5@add_jobs

; 952  :               scan->subtree_unassigned_jobs)
; 953  :             scan->subtree_secondary_pref = 0;

	mov	DWORD PTR [edx+88], 0
$LN5@add_jobs:

; 946  :       for (scan=queue; scan != NULL; scan=scan->parent)

	mov	edx, DWORD PTR [edx+20]
	test	edx, edx
	jne	SHORT $LL7@add_jobs
$LN56@add_jobs:
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	esi, DWORD PTR _queue$[ebp]

; 954  :         }
; 955  :     }
; 956  : 
; 957  :   if ((group->num_idle_threads > 0) && (queue->num_runnable_jobs > 0) &&
; 958  :       (queue->num_active_jobs == 0) && (queue->prescheduled_job_idx < 0) &&

	mov	eax, DWORD PTR [edi+16]
	cmp	DWORD PTR [eax+396], 0
	jle	SHORT $LN25@add_jobs
	cmp	DWORD PTR [esi+60], 0
	jle	SHORT $LN25@add_jobs
	cmp	DWORD PTR [esi+48], 0
	jne	SHORT $LN25@add_jobs
	cmp	DWORD PTR [esi+72], 0
	jge	SHORT $LN25@add_jobs
	cmp	BYTE PTR _is_dormant$1$[ebp], 0
	jne	SHORT $LN25@add_jobs

; 959  :       !is_dormant)
; 960  :     { // Wake up an idle worker thread now that there is more work to do.
; 961  :       wake_idle_thread(queue);

	push	esi
	mov	ecx, edi
	call	?wake_idle_thread@kdu_thread_entity@@AAEXPAUkdu_thread_queue@@@Z ; kdu_thread_entity::wake_idle_thread
$LN25@add_jobs:

; 962  :     }
; 963  :   group->mutex.unlock();

	mov	eax, DWORD PTR [edi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN54@add_jobs
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN54@add_jobs:
	pop	ebx
$LN43@add_jobs:
	pop	edi
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 964  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN57@add_jobs:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN39@add_jobs:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 877  :       throw grouperr->failure_code;

	mov	eax, DWORD PTR [edi+20]
	push	OFFSET __TI1H
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__CxxThrowException@8
$LN59@add_jobs:
$LN55@add_jobs:
	int	3
?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z ENDP ; kdu_thread_entity::add_jobs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?add_queue@kdu_thread_entity@@QAEPAUkdu_thread_queue@@PAVkdu_worker@@PAU2@PBD_J@Z
_TEXT	SEGMENT
_queue_bank_idx$2$ = -8					; size = 4
_depth$1$ = -4						; size = 4
_worker$ = 8						; size = 4
_queue_bank_idx$1$ = 12					; size = 4
_parent$ = 12						; size = 4
_name$ = 16						; size = 4
_queue_bank_idx$ = 20					; size = 8
?add_queue@kdu_thread_entity@@QAEPAUkdu_thread_queue@@PAVkdu_worker@@PAU2@PBD_J@Z PROC ; kdu_thread_entity::add_queue, COMDAT
; _this$ = ecx

; 802  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 217  :     bool exists() { return (group != NULL); }

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 803  :   if (!exists())

	jne	SHORT $LN5@add_queue
	pop	ebx

; 851  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN5@add_queue:
	push	esi
	push	edi

; 804  :     return NULL;
; 805  :   int depth = 1;
; 806  :   if (parent != NULL)

	mov	edi, DWORD PTR _parent$[ebp]
	mov	DWORD PTR _depth$1$[ebp], 1
	test	edi, edi
	je	SHORT $LN6@add_queue

; 807  :     {
; 808  :       depth = parent->depth+1;

	mov	edx, DWORD PTR [edi]

; 809  :       queue_bank_idx = parent->bank_idx;

	mov	ecx, DWORD PTR [edi+8]
	inc	edx
	mov	DWORD PTR _queue_bank_idx$1$[ebp], ecx
	mov	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR _depth$1$[ebp], edx
	mov	DWORD PTR _queue_bank_idx$2$[ebp], ecx
	jmp	SHORT $LN8@add_queue
$LN6@add_queue:

; 810  :     }
; 811  :   else if (queue_bank_idx < group->min_dormant_bank_idx)

	mov	edx, DWORD PTR _queue_bank_idx$[ebp+4]
	mov	ecx, DWORD PTR _queue_bank_idx$[ebp]
	mov	DWORD PTR _queue_bank_idx$2$[ebp], edx
	mov	DWORD PTR _queue_bank_idx$1$[ebp], ecx
	cmp	edx, DWORD PTR [eax+1244]
	jg	SHORT $LN8@add_queue
	jl	SHORT $LN34@add_queue
	cmp	ecx, DWORD PTR [eax+1240]
	jae	SHORT $LN8@add_queue
$LN34@add_queue:

; 812  :     parent = &(group->queue_base);

	lea	edi, DWORD PTR [eax+664]
$LN8@add_queue:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN22@add_queue
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN22@add_queue:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 814  :   kdu_thread_queue *queue = group->get_queue();

	mov	ecx, DWORD PTR [ebx+16]
	call	?get_queue@kd_thread_group@@QAEPAUkdu_thread_queue@@XZ ; kd_thread_group::get_queue

; 815  :   queue->depth = depth;
; 816  :   queue->name = name;

	mov	ecx, DWORD PTR _name$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _depth$1$[ebp]
	mov	DWORD PTR [esi], eax

; 817  :   queue->worker = worker;
; 818  :   queue->parent = parent;
; 819  :   queue->bank_idx = queue_bank_idx;

	mov	eax, DWORD PTR _queue_bank_idx$1$[ebp]
	mov	DWORD PTR [esi+4], ecx
	mov	ecx, DWORD PTR _worker$[ebp]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR _queue_bank_idx$2$[ebp]
	mov	DWORD PTR [esi+40], ecx
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+12], eax

; 820  :   if (worker != NULL)

	test	ecx, ecx
	je	SHORT $LN36@add_queue

; 821  :     {
; 822  :       kdu_thread_queue *scan;
; 823  :       for (scan=parent; scan != NULL; scan=scan->parent)

	mov	eax, edi
	test	edi, edi
	je	SHORT $LN33@add_queue
$LL4@add_queue:

; 824  :         {
; 825  :           scan->subtree_working_leaves++;

	inc	DWORD PTR [eax+92]

; 826  :           if ((scan->subtree_working_leaves == 1) && (scan->worker != NULL))

	cmp	DWORD PTR [eax+92], 1
	jne	SHORT $LN2@add_queue
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN36@add_queue
$LN2@add_queue:

; 821  :     {
; 822  :       kdu_thread_queue *scan;
; 823  :       for (scan=parent; scan != NULL; scan=scan->parent)

	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL4@add_queue
$LN36@add_queue:

; 827  :             break; // Number of working leaves along this branch is still 1,
; 828  :                    // since `scan' was previously a working leaf.
; 829  :         }
; 830  :     }
; 831  :   if (parent == NULL)

	test	edi, edi
	jne	SHORT $LN11@add_queue
$LN33@add_queue:

; 832  :     { // Add to the end of the dormant list
; 833  :       queue->sibling_next = NULL;

	mov	DWORD PTR [esi+24], 0

; 834  :       if ((queue->sibling_prev = group->dormant_tail) != NULL)

	mov	eax, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [eax+1232]
	mov	DWORD PTR [esi+28], eax
	test	eax, eax
	je	SHORT $LN13@add_queue

; 835  :         queue->sibling_prev->sibling_next = queue;

	mov	DWORD PTR [eax+24], esi

; 836  :       else

	jmp	SHORT $LN14@add_queue
$LN13@add_queue:

; 837  :         group->dormant_head = queue;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [eax+1228], esi
$LN14@add_queue:

; 838  :       group->dormant_tail = queue;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [eax+1232], esi

; 839  :       if (group->queue_base.subtree_working_leaves < group->num_threads)

	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [ecx+756]
	cmp	eax, DWORD PTR [ecx+136]
	jge	SHORT $LN12@add_queue

; 840  :         group->activate_dormant_queues(); // This will not make any new jobs

	call	?activate_dormant_queues@kd_thread_group@@QAEXXZ ; kd_thread_group::activate_dormant_queues

; 841  :              // schedulable, since we have not added jobs yet to the new queue.
; 842  :     }
; 843  :   else

	jmp	SHORT $LN12@add_queue
$LN11@add_queue:

; 844  :     {
; 845  :       if ((queue->sibling_next = parent->children) != NULL)

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+24], eax
	test	eax, eax
	je	SHORT $LN16@add_queue

; 846  :         queue->sibling_next->sibling_prev = queue;

	mov	DWORD PTR [eax+28], esi
$LN16@add_queue:

; 847  :       parent->children = queue;

	mov	DWORD PTR [edi+32], esi
$LN12@add_queue:

; 848  :     }
; 849  :   group->mutex.unlock();

	mov	eax, DWORD PTR [ebx+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN26@add_queue
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN26@add_queue:
	pop	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 850  :   return queue;

	mov	eax, esi
	pop	esi
	pop	ebx

; 851  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?add_queue@kdu_thread_entity@@QAEPAUkdu_thread_queue@@PAVkdu_worker@@PAU2@PBD_J@Z ENDP ; kdu_thread_entity::add_queue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?add_thread@kdu_thread_entity@@QAE_NH@Z
_TEXT	SEGMENT
tv366 = -8						; size = 4
_thrd$1$ = -8						; size = 4
tv368 = -4						; size = 4
_thread_concurrency$ = 8				; size = 4
?add_thread@kdu_thread_entity@@QAE_NH@Z PROC		; kdu_thread_entity::add_thread, COMDAT
; _this$ = ecx

; 738  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 217  :     bool exists() { return (group != NULL); }

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 739  :   if (!exists())

	jne	SHORT $LN2@add_thread

; 740  :     return false;

	xor	al, al
	pop	esi

; 791  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@add_thread:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN15@add_thread
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN15@add_thread:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 744  :   int thrd_idx = group->num_threads;

	mov	eax, DWORD PTR [esi+16]
	push	ebx
	push	edi
	mov	DWORD PTR tv368[ebp], eax
	mov	edi, DWORD PTR [eax+136]

; 745  :   bool success = (thrd_idx < KDU_MAX_THREADS);

	cmp	edi, 64					; 00000040H
	setl	bl

; 746  :   if (success)

	test	bl, bl
	je	$LN7@add_thread
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 647  :           event = CreateEvent(NULL,(manual_reset?TRUE:FALSE),FALSE,NULL);

	push	0
	push	0
	push	0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 748  :       success = group->thread_events[thrd_idx].create(false);

	lea	ebx, DWORD PTR [edi*4+1264]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 647  :           event = CreateEvent(NULL,(manual_reset?TRUE:FALSE),FALSE,NULL);

	push	0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 748  :       success = group->thread_events[thrd_idx].create(false);

	mov	DWORD PTR tv366[ebp], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 647  :           event = CreateEvent(NULL,(manual_reset?TRUE:FALSE),FALSE,NULL);

	call	DWORD PTR __imp__CreateEventA@16
	mov	ecx, DWORD PTR tv368[ebp]

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }
; 573  :   private: // Data
; 574  : #   if defined KDU_WIN_THREADS
; 575  :       HANDLE mutex; // NULL if empty
; 576  : #   elif defined KDU_PTHREADS
; 577  :       friend class kdu_event;
; 578  :       pthread_mutex_t mutex;
; 579  :       bool mutex_valid; // False if empty
; 580  : #   endif
; 581  :   };
; 582  : 
; 583  : /*****************************************************************************/
; 584  : /*                                 kdu_event                                 */
; 585  : /*****************************************************************************/
; 586  : 
; 587  : class kdu_event {
; 588  :   /* [SYNOPSIS]
; 589  :        The `kdu_event' object provides similar functionality to the Windows
; 590  :        Event object, except that you must supply a locked mutex to the
; 591  :        `wait' function.  In most cases, this actually simplifies
; 592  :        synchronization with Windows Event objects.  Perhaps more importantly,
; 593  :        though, it enables the behaviour to be correctly implemented also
; 594  :        with pthreads condition objects in Unix.
; 595  :   */
; 596  :   public: // Member functions
; 597  :     kdu_event()
; 598  :       { /* [SYNOPSIS] You need to call `create' explicitly, or else the
; 599  :                       `exists' function will continue to return false. */
; 600  : #       if defined KDU_WIN_THREADS
; 601  :           event = NULL;
; 602  : #       elif defined KDU_PTHREADS
; 603  :           cond_exists = manual_reset = event_is_set = false;
; 604  : #       endif
; 605  :       }
; 606  :     bool exists()
; 607  :       { /* [SYNOPSIS]
; 608  :              Returns true if the object has been successfully created in
; 609  :              a call to `create' that has not been matched by a call to
; 610  :              `destroy'. */
; 611  : #       if defined KDU_WIN_THREADS
; 612  :           return (event != NULL);

	test	eax, eax

; 647  :           event = CreateEvent(NULL,(manual_reset?TRUE:FALSE),FALSE,NULL);

	mov	DWORD PTR [ebx+ecx], eax

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }
; 573  :   private: // Data
; 574  : #   if defined KDU_WIN_THREADS
; 575  :       HANDLE mutex; // NULL if empty
; 576  : #   elif defined KDU_PTHREADS
; 577  :       friend class kdu_event;
; 578  :       pthread_mutex_t mutex;
; 579  :       bool mutex_valid; // False if empty
; 580  : #   endif
; 581  :   };
; 582  : 
; 583  : /*****************************************************************************/
; 584  : /*                                 kdu_event                                 */
; 585  : /*****************************************************************************/
; 586  : 
; 587  : class kdu_event {
; 588  :   /* [SYNOPSIS]
; 589  :        The `kdu_event' object provides similar functionality to the Windows
; 590  :        Event object, except that you must supply a locked mutex to the
; 591  :        `wait' function.  In most cases, this actually simplifies
; 592  :        synchronization with Windows Event objects.  Perhaps more importantly,
; 593  :        though, it enables the behaviour to be correctly implemented also
; 594  :        with pthreads condition objects in Unix.
; 595  :   */
; 596  :   public: // Member functions
; 597  :     kdu_event()
; 598  :       { /* [SYNOPSIS] You need to call `create' explicitly, or else the
; 599  :                       `exists' function will continue to return false. */
; 600  : #       if defined KDU_WIN_THREADS
; 601  :           event = NULL;
; 602  : #       elif defined KDU_PTHREADS
; 603  :           cond_exists = manual_reset = event_is_set = false;
; 604  : #       endif
; 605  :       }
; 606  :     bool exists()
; 607  :       { /* [SYNOPSIS]
; 608  :              Returns true if the object has been successfully created in
; 609  :              a call to `create' that has not been matched by a call to
; 610  :              `destroy'. */
; 611  : #       if defined KDU_WIN_THREADS
; 612  :           return (event != NULL);

	setne	bl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 749  :       if (success)

	test	bl, bl
	je	$LN7@add_thread

; 750  :         {
; 751  :           if ((group->threads[thrd_idx] = this->new_instance()) == NULL)

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+16]
	test	ecx, ecx
	mov	DWORD PTR [eax+edi*4+140], ecx

; 752  :             {
; 753  :               success = false;
; 754  :               group->thread_events[thrd_idx].destroy();

	mov	ecx, DWORD PTR [esi+16]
	jne	SHORT $LN5@add_thread
	add	ecx, DWORD PTR tv366[ebp]
	xor	bl, bl
	call	?destroy@kdu_event@@QAE_NXZ		; kdu_event::destroy

; 755  :             }
; 756  :         }
; 757  :       if (success)

	jmp	$LN7@add_thread
$LN5@add_thread:

; 758  :         {
; 759  :           kdu_thread_entity *thrd = group->threads[thrd_idx];

	mov	ebx, DWORD PTR [ecx+edi*4+140]

; 760  :           group->num_threads = thrd_idx+1;

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR [ecx+136], eax
	mov	DWORD PTR _thrd$1$[ebp], ebx

; 761  :           thrd->thread_idx = thrd_idx;

	mov	DWORD PTR [ebx+4], edi

; 762  :           thrd->group = this->group;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ebx+16], eax

; 763  :           thrd->grouperr = this->grouperr;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [ebx+20], eax

; 764  :           thrd->num_locks = this->num_locks;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ebx+24], eax

; 765  :           thrd->locks = this->locks;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [ebx+28], eax

; 766  :           group->thread_activity[thrd_idx] = KD_THREAD_ACTIVE;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+edi*4+400], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 337  :           thread = CreateThread(NULL,0,start_proc,start_arg,0,&thread_id);

	lea	eax, DWORD PTR [ebx+12]
	push	eax
	push	0
	push	ebx
	push	OFFSET ?worker_startproc@@YGKPAX@Z	; worker_startproc
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24

; 275  :           return (thread != NULL);

	test	eax, eax

; 337  :           thread = CreateThread(NULL,0,start_proc,start_arg,0,&thread_id);

	mov	DWORD PTR [ebx+8], eax

; 275  :           return (thread != NULL);

	setne	bl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 768  :           if (!success)

	test	bl, bl
	jne	SHORT $LN7@add_thread

; 769  :             { // Unable to create the new thread
; 770  :               assert(group->thread_activity[thrd_idx]==KD_THREAD_ACTIVE);
; 771  :               group->thread_events[thrd_idx].destroy();

	mov	ecx, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [edi*4+1264]
	add	ecx, eax
	call	?destroy@kdu_event@@QAE_NXZ		; kdu_event::destroy

; 772  :               thrd->group = NULL; // So `delete' passes verification test

	mov	ecx, DWORD PTR _thrd$1$[ebp]

; 773  :               delete thrd;

	push	1
	mov	DWORD PTR [ecx+16], 0
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax]

; 774  :               group->threads[thrd_idx] = NULL;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+edi*4+140], 0

; 775  :               group->num_threads--;

	mov	eax, DWORD PTR [esi+16]
	dec	DWORD PTR [eax+136]
$LN7@add_thread:

; 776  :             }
; 777  :         }
; 778  :     }
; 779  : 
; 780  : #ifdef KDU_PTHREADS
; 781  :   if (thread_concurrency > 0)
; 782  :     pthread_setconcurrency(thread_concurrency);
; 783  :   else if ((thread_concurrency == 0) && success)
; 784  :     pthread_setconcurrency(group->num_threads);
; 785  :                  // Make sure we have one kernel thread for each user thread
; 786  : #endif // KDU_PTHREADS
; 787  : 
; 788  :   group->mutex.unlock();

	mov	ecx, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx+1260]
	test	eax, eax
	je	SHORT $LN27@add_thread
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN27@add_thread:
	pop	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 790  :   return success;

	mov	al, bl
	pop	ebx
	pop	esi

; 791  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?add_thread@kdu_thread_entity@@QAE_NH@Z ENDP		; kdu_thread_entity::add_thread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?get_num_threads@kdu_thread_entity@@QAEHXZ
_TEXT	SEGMENT
?get_num_threads@kdu_thread_entity@@QAEHXZ PROC		; kdu_thread_entity::get_num_threads, COMDAT
; _this$ = ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 217  :     bool exists() { return (group != NULL); }

	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 727  :   if (!exists())

	jne	SHORT $LN2@get_num_th

; 730  : }

	ret	0
$LN2@get_num_th:

; 728  :     return 0;
; 729  :   return group->num_threads;

	mov	eax, DWORD PTR [eax+136]

; 730  : }

	ret	0
?get_num_threads@kdu_thread_entity@@QAEHXZ ENDP		; kdu_thread_entity::get_num_threads
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?destroy@kdu_thread_entity@@QAE_NXZ
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
tv568 = -8						; size = 4
_result$1$ = -1						; size = 1
?destroy@kdu_thread_entity@@QAE_NXZ PROC		; kdu_thread_entity::destroy, COMDAT
; _this$ = ecx

; 677  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 217  :     bool exists() { return (group != NULL); }

	cmp	DWORD PTR [esi+16], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 678  :   if (!exists())

	jne	SHORT $LN14@destroy

; 679  :     return true;

	mov	al, 1
	pop	esi

; 718  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@destroy:

; 680  :   assert(is_group_owner());
; 681  : 
; 682  :   int n;
; 683  :   bool result = !grouperr->failed;

	mov	eax, DWORD PTR [esi+20]

; 684  :   handle_exception(-1); // Forces threads to terminate as soon as possible.

	push	-1
	cmp	BYTE PTR [eax], 0
	mov	eax, DWORD PTR [esi]
	sete	BYTE PTR _result$1$[ebp]
	call	DWORD PTR [eax+12]

; 685  :   terminate(NULL,false,NULL); // Wait until all work is done and delete queues.

	push	0
	push	0
	push	0
	mov	ecx, esi
	call	?terminate@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_NPAH@Z ; kdu_thread_entity::terminate

; 686  :   assert(group->queue_base.children == NULL);
; 687  :   group->mutex.lock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN26@destroy
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN26@destroy:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 688  :   group->destruction_requested = true;

	mov	eax, DWORD PTR [esi+16]
	push	ebx
	push	edi

; 689  :   for (n=0; n < group->num_threads; n++)

	xor	edi, edi
	mov	BYTE PTR [eax+1257], 1
	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+136], edi
	jle	SHORT $LN3@destroy

; 688  :   group->destruction_requested = true;

	mov	ebx, 1264				; 000004f0H
$LL4@destroy:

; 689  :   for (n=0; n < group->num_threads; n++)

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 687  :           return ((event != NULL) && (SetEvent(event) == TRUE));

	mov	eax, DWORD PTR [eax+ebx]
	test	eax, eax
	je	SHORT $LN2@destroy
	push	eax
	call	DWORD PTR __imp__SetEvent@4
$LN2@destroy:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 689  :   for (n=0; n < group->num_threads; n++)

	mov	eax, DWORD PTR [esi+16]
	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR [eax+136]
	jl	SHORT $LL4@destroy
$LN3@destroy:

; 690  :     group->thread_events[n].set();
; 691  :   group->mutex.unlock();

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN34@destroy
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN34@destroy:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 692  :   for (n=1; n < group->num_threads; n++)

	mov	eax, DWORD PTR [esi+16]
	mov	ebx, 1
	cmp	DWORD PTR [eax+136], ebx
	jle	SHORT $LN6@destroy
	mov	edi, 144				; 00000090H
	mov	DWORD PTR tv568[ebp], edi
$LL7@destroy:

; 693  :     group->threads[n]->thread.destroy(); // Waits for the thread to exit

	mov	eax, DWORD PTR [esi+16]
	mov	edi, DWORD PTR [edi+eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 352  :           result = ((thread != NULL) &&

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN38@destroy
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	SHORT $LN38@destroy
	push	DWORD PTR [edi+8]
	call	DWORD PTR __imp__CloseHandle@4
$LN38@destroy:

; 353  :                     (WaitForSingleObject(thread,INFINITE)==WAIT_OBJECT_0) &&
; 354  :                     (CloseHandle(thread)==TRUE));
; 355  :           thread = NULL;

	mov	DWORD PTR [edi+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 692  :   for (n=1; n < group->num_threads; n++)

	inc	ebx
	mov	eax, DWORD PTR [esi+16]
	mov	edi, DWORD PTR tv568[ebp]
	add	edi, 4
	mov	DWORD PTR tv568[ebp], edi
	cmp	ebx, DWORD PTR [eax+136]
	jl	SHORT $LL7@destroy
$LN6@destroy:

; 694  :   for (n=0; n < group->num_threads; n++)

	mov	eax, DWORD PTR [esi+16]
	xor	ebx, ebx
	cmp	DWORD PTR [eax+136], ebx
	jle	SHORT $LN9@destroy
	mov	edi, 140				; 0000008cH
$LL10@destroy:

; 695  :     {
; 696  :       if (n > 0)

	test	ebx, ebx
	jle	SHORT $LN18@destroy

; 697  :         delete group->threads[n];

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [edi+eax]
	test	ecx, ecx
	je	SHORT $LN18@destroy
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN18@destroy:

; 698  :       group->threads[n] = NULL;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+eax], 0

; 699  :       group->thread_events[n].destroy();

	mov	eax, DWORD PTR [esi+16]
	add	eax, 1124				; 00000464H
	add	eax, edi
	mov	DWORD PTR _this$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 665  :           result = (event != NULL) && (CloseHandle(event) == TRUE);

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN42@destroy
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN42@destroy:

; 666  :           event = NULL;

	mov	eax, DWORD PTR _this$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 694  :   for (n=0; n < group->num_threads; n++)

	inc	ebx
	add	edi, 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 666  :           event = NULL;

	mov	DWORD PTR [eax], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 694  :   for (n=0; n < group->num_threads; n++)

	mov	eax, DWORD PTR [esi+16]
	cmp	ebx, DWORD PTR [eax+136]
	jl	SHORT $LL10@destroy
$LN9@destroy:

; 700  :     }
; 701  :   group->num_threads = group->num_idle_threads = 0;

	mov	eax, DWORD PTR [esi+16]

; 702  :   for (n=0; n < group->num_locks; n++)

	xor	edi, edi
	mov	DWORD PTR [eax+396], 0
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+136], 0
	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+1520], edi
	jle	SHORT $LN12@destroy
	npad	4
$LL13@destroy:
	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+1524]
	lea	ebx, DWORD PTR [eax+edi*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 518  :           result = ((mutex != NULL) && (CloseHandle(mutex)==TRUE));

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN46@destroy
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN46@destroy:

; 519  :           mutex = NULL;

	mov	DWORD PTR [ebx], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 702  :   for (n=0; n < group->num_locks; n++)

	inc	edi
	mov	eax, DWORD PTR [esi+16]
	cmp	edi, DWORD PTR [eax+1520]
	jl	SHORT $LL13@destroy
$LN12@destroy:

; 703  :     {
; 704  :       assert(group->locks[n].holder == NULL);
; 705  :       group->locks[n].mutex.destroy();
; 706  :     }
; 707  :   if ((group->locks != NULL) && (group->locks != group->lock_store))

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax+1524]
	test	ecx, ecx
	je	SHORT $LN16@destroy
	add	eax, 1528				; 000005f8H
	cmp	ecx, eax
	je	SHORT $LN16@destroy

; 708  :     delete[] group->locks;

	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN16@destroy:

; 709  :   group->num_locks = 0;  group->locks = NULL;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+1520], 0
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+1524], 0

; 710  :   group->mutex.destroy();

	mov	edi, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 518  :           result = ((mutex != NULL) && (CloseHandle(mutex)==TRUE));

	mov	eax, DWORD PTR [edi+1260]
	test	eax, eax
	je	SHORT $LN50@destroy
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN50@destroy:

; 519  :           mutex = NULL;

	mov	DWORD PTR [edi+1260], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 711  :   delete group;

	mov	edi, DWORD PTR [esi+16]
	test	edi, edi
	je	SHORT $LN53@destroy
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\threads_local.h

; 371  :         while ((tmp=queue_blocks) != NULL)

	mov	ecx, DWORD PTR [edi+1596]
	test	ecx, ecx
	je	SHORT $LN58@destroy
	mov	ebx, DWORD PTR __imp__free
	npad	7
$LL57@destroy:

; 372  :           { queue_blocks=tmp->next; free(tmp); }

	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR [edi+1596], eax
	call	ebx
	mov	ecx, DWORD PTR [edi+1596]
	add	esp, 4
	test	ecx, ecx
	jne	SHORT $LL57@destroy
$LN58@destroy:
	push	1728					; 000006c0H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN53@destroy:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 717  :   return result;

	mov	al, BYTE PTR _result$1$[ebp]
	pop	edi
	pop	ebx
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+32], 0
	pop	esi

; 718  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?destroy@kdu_thread_entity@@QAE_NXZ ENDP		; kdu_thread_entity::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?create@kdu_thread_entity@@QAEX_J@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
$T2 = -4						; size = 4
$T3 = -4						; size = 4
_cpu_affinity$ = 8					; size = 8
?create@kdu_thread_entity@@QAEX_J@Z PROC		; kdu_thread_entity::create, COMDAT
; _this$ = ecx

; 640  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 641  :   assert(!exists());
; 642  :   thread_idx = 0;

	mov	DWORD PTR [esi+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 316  :           thread = GetCurrentThread();  thread_id = GetCurrentThreadId();

	call	DWORD PTR __imp__GetCurrentThread@0
	mov	DWORD PTR [esi+8], eax
	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR [esi+12], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 644  :   num_locks = get_num_locks();

	mov	ecx, esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]

; 645  :   group = new kd_thread_group;

	push	1728					; 000006c0H
	mov	DWORD PTR [esi+24], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	test	eax, eax
	je	SHORT $LN9@create
	mov	ecx, eax
	call	??0kd_thread_group@@QAE@XZ		; kd_thread_group::kd_thread_group
	jmp	SHORT $LN10@create
$LN9@create:
	xor	eax, eax
$LN10@create:

; 646  : 
; 647  :   group->cpu_affinity = cpu_affinity;

	mov	ecx, DWORD PTR _cpu_affinity$[ebp]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [eax+128], ecx
	mov	ecx, DWORD PTR _cpu_affinity$[ebp+4]
	mov	DWORD PTR [eax+132], ecx

; 648  :   group->num_threads = 1;

	mov	eax, DWORD PTR [esi+16]
	push	ebx
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 647  :           event = CreateEvent(NULL,(manual_reset?TRUE:FALSE),FALSE,NULL);

	push	0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 648  :   group->num_threads = 1;

	mov	DWORD PTR [eax+136], 1

; 649  :   group->threads[0] = this;

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 647  :           event = CreateEvent(NULL,(manual_reset?TRUE:FALSE),FALSE,NULL);

	push	0
	push	0
	push	0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 649  :   group->threads[0] = this;

	mov	DWORD PTR [eax+140], esi

; 650  :   group->thread_events[0].create(false);

	mov	edi, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 647  :           event = CreateEvent(NULL,(manual_reset?TRUE:FALSE),FALSE,NULL);

	call	DWORD PTR __imp__CreateEventA@16
	mov	DWORD PTR [edi+1264], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 651  :   group->thread_activity[0] = KD_THREAD_ACTIVE;

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 502  :           mutex = CreateMutex(NULL,FALSE,NULL);

	push	0
	push	0
	push	0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 651  :   group->thread_activity[0] = KD_THREAD_ACTIVE;

	mov	DWORD PTR [eax+400], 1

; 652  :   group->mutex.create();

	mov	edi, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 502  :           mutex = CreateMutex(NULL,FALSE,NULL);

	call	DWORD PTR __imp__CreateMutexA@12
	mov	DWORD PTR [edi+1260], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 653  :   group->num_locks = num_locks;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx+1520], eax

; 654  :   if (num_locks < 8)

	mov	edi, DWORD PTR [esi+24]
	cmp	edi, 8
	jge	SHORT $LN5@create

; 655  :     group->locks = group->lock_store;

	mov	ecx, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [ecx+1528]
	mov	DWORD PTR [ecx+1524], eax

; 656  :   else

	jmp	SHORT $LN6@create
$LN5@create:

; 657  :     group->locks = new kd_thread_lock[num_locks];

	xor	ecx, ecx
	mov	DWORD PTR $T2[ebp], edi
	mov	eax, edi
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], edx
	test	edx, edx
	je	SHORT $LN11@create
	mov	ecx, edx
	test	edi, edi
	je	SHORT $LN12@create
$LL26@create:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 469  :           mutex=NULL;

	mov	DWORD PTR [ecx], 0
	lea	ecx, DWORD PTR [ecx+8]
	sub	edi, 1
	jne	SHORT $LL26@create
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 657  :     group->locks = new kd_thread_lock[num_locks];

	jmp	SHORT $LN12@create
$LN11@create:
	xor	edx, edx
$LN12@create:
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+1524], edx
$LN6@create:

; 658  :   for (int n=0; n < num_locks; n++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+24], ebx
	jle	SHORT $LN3@create
$LL4@create:

; 660  :       group->locks[n].holder = NULL;

	mov	eax, DWORD PTR [esi+16]
	lea	ecx, DWORD PTR [ebx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 502  :           mutex = CreateMutex(NULL,FALSE,NULL);

	push	0
	push	0
	push	0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 660  :       group->locks[n].holder = NULL;

	mov	eax, DWORD PTR [eax+1524]
	mov	DWORD PTR [eax+ecx+4], 0
	mov	eax, DWORD PTR [esi+16]
	mov	edi, DWORD PTR [eax+1524]
	add	edi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 502  :           mutex = CreateMutex(NULL,FALSE,NULL);

	call	DWORD PTR __imp__CreateMutexA@12
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 658  :   for (int n=0; n < num_locks; n++)

	inc	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 502  :           mutex = CreateMutex(NULL,FALSE,NULL);

	mov	DWORD PTR [edi], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 658  :   for (int n=0; n < num_locks; n++)

	cmp	ebx, DWORD PTR [esi+24]
	jl	SHORT $LL4@create
$LN3@create:

; 661  :       group->locks[n].mutex.create();
; 662  :     }
; 663  : 
; 664  :   this->locks = group->locks;

	mov	ecx, DWORD PTR [esi+16]
	pop	edi
	pop	ebx
	mov	eax, DWORD PTR [ecx+1524]
	mov	DWORD PTR [esi+28], eax

; 665  :   this->grouperr = &(group->grouperr);

	lea	eax, DWORD PTR [ecx+1248]

; 666  : 
; 667  :   if (cpu_affinity != 0)

	mov	ecx, DWORD PTR _cpu_affinity$[ebp]
	mov	DWORD PTR [esi+20], eax
	mov	eax, ecx
	or	eax, DWORD PTR _cpu_affinity$[ebp+4]
	je	SHORT $LN7@create
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 385  :                SetThreadAffinityMask(thread,(DWORD) affinity_mask); 

	push	ecx
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__SetThreadAffinityMask@8
$LN7@create:
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 669  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?create@kdu_thread_entity@@QAEX_J@Z ENDP		; kdu_thread_entity::create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?get_num_locks@kdu_thread_entity@@UAEHXZ
_TEXT	SEGMENT
?get_num_locks@kdu_thread_entity@@UAEHXZ PROC		; kdu_thread_entity::get_num_locks, COMDAT
; _this$ = ecx

; 244  :     virtual int get_num_locks() { return (group==NULL)?1:this->num_locks; }

	cmp	DWORD PTR [ecx+16], 0
	mov	eax, 1
	je	SHORT $LN4@get_num_lo
	mov	eax, DWORD PTR [ecx+24]
$LN4@get_num_lo:
	ret	0
?get_num_locks@kdu_thread_entity@@UAEHXZ ENDP		; kdu_thread_entity::get_num_locks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?get_current_thread_entity@kdu_thread_entity@@QAEPAV1@XZ
_TEXT	SEGMENT
_me$1$ = -4						; size = 4
?get_current_thread_entity@kdu_thread_entity@@QAEPAV1@XZ PROC ; kdu_thread_entity::get_current_thread_entity, COMDAT
; _this$ = ecx

; 613  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	edi
	mov	edi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 316  :           thread = GetCurrentThread();  thread_id = GetCurrentThreadId();

	call	DWORD PTR __imp__GetCurrentThread@0
	mov	DWORD PTR _me$1$[ebp], eax
	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	ebx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 618  :   if (group == NULL)

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	jne	SHORT $LN6@get_curren
	pop	edi
	pop	ebx

; 632  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@get_curren:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [eax+1260]
	test	eax, eax
	je	SHORT $LN15@get_curren
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN15@get_curren:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 624  :   for (int n=0; n < group->num_threads; n++)

	mov	edi, DWORD PTR [edi+16]
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR [edi+136]
	test	esi, esi
	jle	SHORT $LN34@get_curren

; 625  :     if (group->threads[n]->thread.equals(me))

	lea	edx, DWORD PTR [edi+140]
	npad	1
$LL4@get_curren:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 290  :           return ((rhs.thread != NULL) && (this->thread != NULL) &&

	cmp	DWORD PTR _me$1$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 625  :     if (group->threads[n]->thread.equals(me))

	mov	eax, DWORD PTR [edx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 290  :           return ((rhs.thread != NULL) && (this->thread != NULL) &&

	je	SHORT $LN19@get_curren
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN19@get_curren
	cmp	ebx, DWORD PTR [eax+12]
	je	SHORT $LN26@get_curren
$LN19@get_curren:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 624  :   for (int n=0; n < group->num_threads; n++)

	inc	ecx
	add	edx, 4
	cmp	ecx, esi
	jl	SHORT $LL4@get_curren
$LN34@get_curren:
	xor	ebx, ebx
$LN3@get_curren:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	ecx, DWORD PTR [edi+1260]
	pop	esi
	test	ecx, ecx
	je	SHORT $LN23@get_curren
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
$LN23@get_curren:
	pop	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 631  :   return result;

	mov	eax, ebx
	pop	ebx

; 632  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@get_curren:

; 626  :       {
; 627  :         result = group->threads[n];

	mov	ebx, DWORD PTR [edi+ecx*4+140]
	jmp	SHORT $LN3@get_curren
?get_current_thread_entity@kdu_thread_entity@@QAEPAV1@XZ ENDP ; kdu_thread_entity::get_current_thread_entity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?is_group_owner@kdu_thread_entity@@QAE_NXZ
_TEXT	SEGMENT
?is_group_owner@kdu_thread_entity@@QAE_NXZ PROC		; kdu_thread_entity::is_group_owner, COMDAT
; _this$ = ecx

; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN3@is_group_o
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN3@is_group_o
	mov	al, 1
	ret	0
$LN3@is_group_o:
	xor	al, al
	ret	0
?is_group_owner@kdu_thread_entity@@QAE_NXZ ENDP		; kdu_thread_entity::is_group_owner
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?exists@kdu_thread_entity@@QAE_NXZ
_TEXT	SEGMENT
?exists@kdu_thread_entity@@QAE_NXZ PROC			; kdu_thread_entity::exists, COMDAT
; _this$ = ecx

; 217  :     bool exists() { return (group != NULL); }

	xor	eax, eax
	cmp	DWORD PTR [ecx+16], eax
	setne	al
	ret	0
?exists@kdu_thread_entity@@QAE_NXZ ENDP			; kdu_thread_entity::exists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?new_instance@kdu_thread_entity@@UAEPAV1@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?new_instance@kdu_thread_entity@@UAEPAV1@XZ PROC	; kdu_thread_entity::new_instance, COMDAT
; _this$ = ecx

; 205  :     virtual kdu_thread_entity *new_instance() { return new kdu_thread_entity; }

	push	ebp
	mov	ebp, esp
	push	ecx
	push	40					; 00000028H
	call	??2kdu_thread_entity@@SAPAXI@Z		; kdu_thread_entity::operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN3@new_instan
	mov	ecx, eax
	call	??0kdu_thread_entity@@QAE@XZ		; kdu_thread_entity::kdu_thread_entity
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_instan:
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?new_instance@kdu_thread_entity@@UAEPAV1@XZ ENDP	; kdu_thread_entity::new_instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ??3kdu_thread_entity@@SAXPAX@Z
_TEXT	SEGMENT
_base$ = 8						; size = 4
??3kdu_thread_entity@@SAXPAX@Z PROC			; kdu_thread_entity::operator delete, COMDAT

; 602  : {

	push	ebp
	mov	ebp, esp

; 603  :   kdu_byte *handle = ((kdu_byte **) base)[-1];
; 604  :   free(handle);

	mov	eax, DWORD PTR _base$[ebp]
	push	DWORD PTR [eax-4]
	call	DWORD PTR __imp__free
	add	esp, 4

; 605  : }

	pop	ebp
	ret	0
??3kdu_thread_entity@@SAXPAX@Z ENDP			; kdu_thread_entity::operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ??2kdu_thread_entity@@SAPAXI@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
??2kdu_thread_entity@@SAPAXI@Z PROC			; kdu_thread_entity::operator new, COMDAT

; 581  : {

	push	ebp
	mov	ebp, esp

; 582  :   size += sizeof(kdu_byte *); // Leave room to store deallocation pointer

	mov	ecx, DWORD PTR _size$[ebp]

; 583  :   int mask = KDU_MAX_L2_CACHE_LINE-1;
; 584  :   assert(!(mask & (mask+1))); // KDU_MAX_L2_CACHE_LINE must be power of 2!
; 585  :   int offset = (KDU_MAX_L2_CACHE_LINE - (int) size) & mask;
; 586  :   size += offset; // Pad to nearest multiple of max L2 cache line size.
; 587  :   size += KDU_MAX_L2_CACHE_LINE; // Allow for incorrectly aligned result
; 588  :   kdu_byte *handle = (kdu_byte *) malloc(size);

	lea	eax, DWORD PTR [ecx+4]
	sub	ecx, -132				; ffffff7cH
	neg	eax
	and	eax, 127				; 0000007fH
	add	eax, ecx
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4

; 589  :   kdu_byte *base = handle + sizeof(kdu_byte *);

	lea	edx, DWORD PTR [eax+4]

; 590  :   offset = (- _addr_to_kdu_int32(base)) & mask;

	mov	ecx, edx
	neg	ecx
	and	ecx, 127				; 0000007fH

; 591  :   base += offset; // Aligned base of object

	add	edx, ecx

; 592  :   ((kdu_byte **) base)[-1] = handle;

	mov	DWORD PTR [edx-4], eax

; 593  :   return (void *) base;

	mov	eax, edx

; 594  : }

	pop	ebp
	ret	0
??2kdu_thread_entity@@SAPAXI@Z ENDP			; kdu_thread_entity::operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ??1kdu_thread_entity@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kdu_thread_entity@@UAE@XZ PROC			; kdu_thread_entity::~kdu_thread_entity, COMDAT
; _this$ = ecx

; 188  :       { if (is_group_owner()) destroy();

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kdu_thread_entity@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 190  :       /* [SYNOPSIS]
; 191  :            While the destructor will perform all required cleanup, the
; 192  :            caller may be suspended for some time while waiting for worker
; 193  :            threads to complete.  For this reason, you are encouraged to
; 194  :            explicitly call the `destroy' function first.  This also provides
; 195  :            you with information on whether all threads terminated normally
; 196  :            or a failure was caught.
; 197  :       */
; 198  :     KDU_EXPORT void *operator new(size_t size);
; 199  :       /* This function allocates the thread object in such a way that it
; 200  :          occupies a whole number of L2 cache lines, thereby maximizing
; 201  :          cache utilization efficiency. */
; 202  :     KDU_EXPORT void operator delete(void *ptr);
; 203  :       /* This function deletes the memory allocated using the custom new
; 204  :          operator defined above. */
; 205  :     virtual kdu_thread_entity *new_instance() { return new kdu_thread_entity; }
; 206  :       /* [SYNOPSIS]
; 207  :            The `add_thread' function uses this function to create new
; 208  :            `kdu_thread_entity' objects for each new worker thread.  You
; 209  :            can override this virtual function to create objects of your own
; 210  :            derived class, thereby ensuring that all worker threads will
; 211  :            also use the derived class.  This is particularly convenient if
; 212  :            you want each thread in a group to manage additional
; 213  :            thread-specific data.  By careful implementation of the function
; 214  :            override, you can also arrange to inherit parameters from the
; 215  :            thread which creates new workers.
; 216  :       */
; 217  :     bool exists() { return (group != NULL); }
; 218  :       /* [SYNOPSIS]
; 219  :            Returns true only between calls to `create' and `destroy'.
; 220  :            You should not use a `kdu_thread_entity' object until it has
; 221  :            been created.
; 222  :       */
; 223  :     bool operator!() { return !exists(); }
; 224  :       /* [SYNOPSIS]
; 225  :            Opposite of `exists'.
; 226  :       */
; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	cmp	DWORD PTR [ecx+16], 0

; 188  :       { if (is_group_owner()) destroy();

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_thread_entity@@6B@

; 190  :       /* [SYNOPSIS]
; 191  :            While the destructor will perform all required cleanup, the
; 192  :            caller may be suspended for some time while waiting for worker
; 193  :            threads to complete.  For this reason, you are encouraged to
; 194  :            explicitly call the `destroy' function first.  This also provides
; 195  :            you with information on whether all threads terminated normally
; 196  :            or a failure was caught.
; 197  :       */
; 198  :     KDU_EXPORT void *operator new(size_t size);
; 199  :       /* This function allocates the thread object in such a way that it
; 200  :          occupies a whole number of L2 cache lines, thereby maximizing
; 201  :          cache utilization efficiency. */
; 202  :     KDU_EXPORT void operator delete(void *ptr);
; 203  :       /* This function deletes the memory allocated using the custom new
; 204  :          operator defined above. */
; 205  :     virtual kdu_thread_entity *new_instance() { return new kdu_thread_entity; }
; 206  :       /* [SYNOPSIS]
; 207  :            The `add_thread' function uses this function to create new
; 208  :            `kdu_thread_entity' objects for each new worker thread.  You
; 209  :            can override this virtual function to create objects of your own
; 210  :            derived class, thereby ensuring that all worker threads will
; 211  :            also use the derived class.  This is particularly convenient if
; 212  :            you want each thread in a group to manage additional
; 213  :            thread-specific data.  By careful implementation of the function
; 214  :            override, you can also arrange to inherit parameters from the
; 215  :            thread which creates new workers.
; 216  :       */
; 217  :     bool exists() { return (group != NULL); }
; 218  :       /* [SYNOPSIS]
; 219  :            Returns true only between calls to `create' and `destroy'.
; 220  :            You should not use a `kdu_thread_entity' object until it has
; 221  :            been created.
; 222  :       */
; 223  :     bool operator!() { return !exists(); }
; 224  :       /* [SYNOPSIS]
; 225  :            Opposite of `exists'.
; 226  :       */
; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	je	SHORT $LN2@kdu_thread
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN2@kdu_thread

; 188  :       { if (is_group_owner()) destroy();

	call	?destroy@kdu_thread_entity@@QAE_NXZ	; kdu_thread_entity::destroy
$LN2@kdu_thread:

; 189  :         assert(group == NULL); }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kdu_thread_entity@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kdu_thread_entity@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kdu_thread_entity@@UAE@XZ ENDP			; kdu_thread_entity::~kdu_thread_entity
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?pre_destroy@kdu_thread_entity@@QAEXXZ
_TEXT	SEGMENT
?pre_destroy@kdu_thread_entity@@QAEXXZ PROC		; kdu_thread_entity::pre_destroy, COMDAT
; _this$ = ecx

; 183  :       /* This function is called automatically when a non-group-owner
; 184  :          thread finishes so that the safety check in the destructor will
; 185  :          not fail.  This is done only for code verification purposes.  You
; 186  :          should not call the function yourself from an application. */
; 187  :     virtual ~kdu_thread_entity()
; 188  :       { if (is_group_owner()) destroy();
; 189  :         assert(group == NULL); }
; 190  :       /* [SYNOPSIS]
; 191  :            While the destructor will perform all required cleanup, the
; 192  :            caller may be suspended for some time while waiting for worker
; 193  :            threads to complete.  For this reason, you are encouraged to
; 194  :            explicitly call the `destroy' function first.  This also provides
; 195  :            you with information on whether all threads terminated normally
; 196  :            or a failure was caught.
; 197  :       */
; 198  :     KDU_EXPORT void *operator new(size_t size);
; 199  :       /* This function allocates the thread object in such a way that it
; 200  :          occupies a whole number of L2 cache lines, thereby maximizing
; 201  :          cache utilization efficiency. */
; 202  :     KDU_EXPORT void operator delete(void *ptr);
; 203  :       /* This function deletes the memory allocated using the custom new
; 204  :          operator defined above. */
; 205  :     virtual kdu_thread_entity *new_instance() { return new kdu_thread_entity; }
; 206  :       /* [SYNOPSIS]
; 207  :            The `add_thread' function uses this function to create new
; 208  :            `kdu_thread_entity' objects for each new worker thread.  You
; 209  :            can override this virtual function to create objects of your own
; 210  :            derived class, thereby ensuring that all worker threads will
; 211  :            also use the derived class.  This is particularly convenient if
; 212  :            you want each thread in a group to manage additional
; 213  :            thread-specific data.  By careful implementation of the function
; 214  :            override, you can also arrange to inherit parameters from the
; 215  :            thread which creates new workers.
; 216  :       */
; 217  :     bool exists() { return (group != NULL); }
; 218  :       /* [SYNOPSIS]
; 219  :            Returns true only between calls to `create' and `destroy'.
; 220  :            You should not use a `kdu_thread_entity' object until it has
; 221  :            been created.
; 222  :       */
; 223  :     bool operator!() { return !exists(); }
; 224  :       /* [SYNOPSIS]
; 225  :            Opposite of `exists'.
; 226  :       */
; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN6@pre_destro
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN2@pre_destro
$LN6@pre_destro:

; 182  :     void pre_destroy() { if (!is_group_owner()) group = NULL; }

	mov	DWORD PTR [ecx+16], 0
$LN2@pre_destro:
	ret	0
?pre_destroy@kdu_thread_entity@@QAEXXZ ENDP		; kdu_thread_entity::pre_destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ??0kdu_thread_entity@@QAE@XZ
_TEXT	SEGMENT
??0kdu_thread_entity@@QAE@XZ PROC			; kdu_thread_entity::kdu_thread_entity, COMDAT
; _this$ = ecx

; 565  : {

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_thread_entity@@6B@

; 573  : }

	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 263  :           thread=NULL; thread_id=0;

	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp

; 566  :   thread_idx=0;

	mov	DWORD PTR [ecx+4], 0

; 567  :   group=NULL;

	mov	DWORD PTR [ecx+16], 0

; 568  :   locks=NULL;

	mov	DWORD PTR [ecx+28], 0

; 569  :   grouperr=NULL;

	mov	DWORD PTR [ecx+20], 0

; 570  :   num_locks=0;

	mov	DWORD PTR [ecx+24], 0

; 571  :   finished=false;

	mov	BYTE PTR [ecx+36], 0

; 572  :   recent_queue=NULL;

	mov	DWORD PTR [ecx+32], 0

; 573  : }

	ret	0
??0kdu_thread_entity@@QAE@XZ ENDP			; kdu_thread_entity::kdu_thread_entity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ??0kd_thread_lock@@QAE@XZ
_TEXT	SEGMENT
??0kd_thread_lock@@QAE@XZ PROC				; kd_thread_lock::kd_thread_lock, COMDAT
; _this$ = ecx

; 469  :           mutex=NULL;

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0kd_thread_lock@@QAE@XZ ENDP				; kd_thread_lock::kd_thread_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?wait@kdu_event@@QAE_NAAVkdu_mutex@@@Z
_TEXT	SEGMENT
_mutex$ = 8						; size = 4
?wait@kdu_event@@QAE_NAAVkdu_mutex@@@Z PROC		; kdu_event::wait, COMDAT
; _this$ = ecx

; 713  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }
; 542  :     bool try_lock()
; 543  :       { /* [SYNOPSIS]
; 544  :              Same as `lock', except that the call is non-blocking.  If the
; 545  :              mutex is already locked by another thread, the function returns
; 546  :              false immediately.
; 547  :            [RETURNS]
; 548  :              False if the mutex is currently locked by another thread, or
; 549  :              has not been successfully created. */
; 550  : #       if defined KDU_WIN_THREADS
; 551  :           return ((mutex != NULL) &&
; 552  :                   (WaitForSingleObject(mutex,0) == WAIT_OBJECT_0));
; 553  : #       elif defined KDU_PTHREADS
; 554  :           return (mutex_valid && (pthread_mutex_trylock(&mutex)==0));
; 555  : #       else
; 556  :           return false;
; 557  : #       endif
; 558  :       }
; 559  :     bool unlock()
; 560  :       { /* [SYNOPSIS]
; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	edi, DWORD PTR _mutex$[ebp]

; 713  :       { /* [SYNOPSIS]

	mov	esi, ecx

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }
; 542  :     bool try_lock()
; 543  :       { /* [SYNOPSIS]
; 544  :              Same as `lock', except that the call is non-blocking.  If the
; 545  :              mutex is already locked by another thread, the function returns
; 546  :              false immediately.
; 547  :            [RETURNS]
; 548  :              False if the mutex is currently locked by another thread, or
; 549  :              has not been successfully created. */
; 550  : #       if defined KDU_WIN_THREADS
; 551  :           return ((mutex != NULL) &&
; 552  :                   (WaitForSingleObject(mutex,0) == WAIT_OBJECT_0));
; 553  : #       elif defined KDU_PTHREADS
; 554  :           return (mutex_valid && (pthread_mutex_trylock(&mutex)==0));
; 555  : #       else
; 556  :           return false;
; 557  : #       endif
; 558  :       }
; 559  :     bool unlock()
; 560  :       { /* [SYNOPSIS]
; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN7@wait
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN7@wait:

; 714  :              Blocks the caller until the synchronization object becomes
; 715  :              signalled by a prior or future call to `set'.  If the object
; 716  :              is already signalled, the function returns immediately.  In
; 717  :              the case of an auto-reset object (`create'd with `manual_reset'
; 718  :              = false), the function returns the object to the non-singalled
; 719  :              state after a successful return.
; 720  :              [//]
; 721  :              The supplied `mutex' must have been locked by the caller;
; 722  :              moreover all threads which call this event's `wait' function
; 723  :              must lock the same mutex.  Upon return the `mutex' will again
; 724  :              be locked.  If a blocking wait is required, the mutex will
; 725  :              be unlocked during the wait.
; 726  :            [RETURNS]
; 727  :              False if the event has not been successfully created, or if
; 728  :              an error (e.g., deadlock) is detected by the kernel. */
; 729  : #       if defined KDU_WIN_THREADS
; 730  :           mutex.unlock();
; 731  :           bool result = (event != NULL) &&

	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	je	SHORT $LN3@wait
	push	-1
	push	eax
	call	esi
	test	eax, eax
	jne	SHORT $LN3@wait
	mov	bl, 1
	jmp	SHORT $LN4@wait
$LN3@wait:
	xor	bl, bl
$LN4@wait:

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN13@wait
	push	-1
	push	eax
	call	esi
$LN13@wait:
	pop	edi
	pop	esi

; 732  :             (WaitForSingleObject(event,INFINITE) == WAIT_OBJECT_0);
; 733  :           mutex.lock();
; 734  :           return result;

	mov	al, bl
	pop	ebx

; 735  : #       elif defined KDU_PTHREADS
; 736  :           bool result = cond_exists;
; 737  :           while (result && !event_is_set)
; 738  :             result = (pthread_cond_wait(&cond,&(mutex.mutex)) == 0);
; 739  :           if (!manual_reset) event_is_set = false;
; 740  :           return result;
; 741  : #       else
; 742  :           return false;
; 743  : #       endif
; 744  :       }

	pop	ebp
	ret	4
?wait@kdu_event@@QAE_NAAVkdu_mutex@@@Z ENDP		; kdu_event::wait
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?reset@kdu_event@@QAE_NXZ
_TEXT	SEGMENT
?reset@kdu_event@@QAE_NXZ PROC				; kdu_event::reset, COMDAT
; _this$ = ecx

; 701  :              See `set' and `create' for an explanation.
; 702  :            [RETURNS]
; 703  :              False if the event has not been successfully created. */
; 704  : #       if defined KDU_WIN_THREADS
; 705  :           return ((event != NULL) && (ResetEvent(event) == TRUE));

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@reset
	push	eax
	call	DWORD PTR __imp__ResetEvent@4
	cmp	eax, 1
	jne	SHORT $LN3@reset
	mov	al, al

; 706  : #       elif defined KDU_PTHREADS
; 707  :           event_is_set = false;  return true;
; 708  : #       else
; 709  :           return false;
; 710  : #       endif
; 711  :       }

	ret	0
$LN3@reset:

; 701  :              See `set' and `create' for an explanation.
; 702  :            [RETURNS]
; 703  :              False if the event has not been successfully created. */
; 704  : #       if defined KDU_WIN_THREADS
; 705  :           return ((event != NULL) && (ResetEvent(event) == TRUE));

	xor	al, al

; 706  : #       elif defined KDU_PTHREADS
; 707  :           event_is_set = false;  return true;
; 708  : #       else
; 709  :           return false;
; 710  : #       endif
; 711  :       }

	ret	0
?reset@kdu_event@@QAE_NXZ ENDP				; kdu_event::reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?set@kdu_event@@QAE_NXZ
_TEXT	SEGMENT
?set@kdu_event@@QAE_NXZ PROC				; kdu_event::set, COMDAT
; _this$ = ecx

; 675  :              Set the synchronization object to the signalled state.  This
; 676  :              causes any waiting thread to wake up and return from its call
; 677  :              to `wait'.  Any future call to `wait' by this or any other
; 678  :              thread will also return immediately, until such point as
; 679  :              `reset' is called.  If the `create' function was supplied with
; 680  :              `manual_reset' = false, the condition created by this present
; 681  :              function is reset as soon as any single thread returns
; 682  :              from a current or future `wait' call.  See `create' for more
; 683  :              on this.
; 684  :            [RETURNS]
; 685  :              False if the event has not been successfully created. */
; 686  : #       if defined KDU_WIN_THREADS
; 687  :           return ((event != NULL) && (SetEvent(event) == TRUE));

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@set
	push	eax
	call	DWORD PTR __imp__SetEvent@4
	cmp	eax, 1
	jne	SHORT $LN3@set
	mov	al, al

; 688  : #       elif defined KDU_PTHREADS
; 689  :           if (event_is_set) return true;
; 690  :           event_is_set = true;
; 691  :           if (manual_reset)
; 692  :             return (pthread_cond_broadcast(&cond) == 0);
; 693  :           else
; 694  :             return (pthread_cond_signal(&cond) == 0);
; 695  : #       else
; 696  :           return false;
; 697  : #       endif
; 698  :       }

	ret	0
$LN3@set:

; 675  :              Set the synchronization object to the signalled state.  This
; 676  :              causes any waiting thread to wake up and return from its call
; 677  :              to `wait'.  Any future call to `wait' by this or any other
; 678  :              thread will also return immediately, until such point as
; 679  :              `reset' is called.  If the `create' function was supplied with
; 680  :              `manual_reset' = false, the condition created by this present
; 681  :              function is reset as soon as any single thread returns
; 682  :              from a current or future `wait' call.  See `create' for more
; 683  :              on this.
; 684  :            [RETURNS]
; 685  :              False if the event has not been successfully created. */
; 686  : #       if defined KDU_WIN_THREADS
; 687  :           return ((event != NULL) && (SetEvent(event) == TRUE));

	xor	al, al

; 688  : #       elif defined KDU_PTHREADS
; 689  :           if (event_is_set) return true;
; 690  :           event_is_set = true;
; 691  :           if (manual_reset)
; 692  :             return (pthread_cond_broadcast(&cond) == 0);
; 693  :           else
; 694  :             return (pthread_cond_signal(&cond) == 0);
; 695  : #       else
; 696  :           return false;
; 697  : #       endif
; 698  :       }

	ret	0
?set@kdu_event@@QAE_NXZ ENDP				; kdu_event::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?destroy@kdu_event@@QAE_NXZ
_TEXT	SEGMENT
?destroy@kdu_event@@QAE_NXZ PROC			; kdu_event::destroy, COMDAT
; _this$ = ecx

; 656  :       { /* [SYNOPSIS]

	push	esi
	mov	esi, ecx

; 657  :              You must explicitly call `create' and `destroy'.
; 658  :              The constructor and and destructor for the `kdu_mutex' object
; 659  :              do not create or destroy the underlying synchronization
; 660  :              primitive itself.
; 661  :            [RETURNS]
; 662  :              False if the event has not been successfully created. */
; 663  :         bool result = false;
; 664  : #       if defined KDU_WIN_THREADS
; 665  :           result = (event != NULL) && (CloseHandle(event) == TRUE);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@destroy
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	eax, 1
	jne	SHORT $LN3@destroy

; 666  :           event = NULL;

	mov	DWORD PTR [esi], 0
	mov	al, al
	pop	esi

; 667  : #       elif defined KDU_PTHREADS
; 668  :           result = (cond_exists && (pthread_cond_destroy(&cond)==0));
; 669  :           cond_exists = event_is_set = manual_reset = false;
; 670  : #       endif
; 671  :         return result;
; 672  :       }

	ret	0
$LN3@destroy:

; 666  :           event = NULL;

	mov	DWORD PTR [esi], 0
	xor	al, al
	pop	esi

; 667  : #       elif defined KDU_PTHREADS
; 668  :           result = (cond_exists && (pthread_cond_destroy(&cond)==0));
; 669  :           cond_exists = event_is_set = manual_reset = false;
; 670  : #       endif
; 671  :         return result;
; 672  :       }

	ret	0
?destroy@kdu_event@@QAE_NXZ ENDP			; kdu_event::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?create@kdu_event@@QAE_N_N@Z
_TEXT	SEGMENT
_manual_reset$ = 8					; size = 1
?create@kdu_event@@QAE_N_N@Z PROC			; kdu_event::create, COMDAT
; _this$ = ecx

; 645  :       {

	push	ebp
	mov	ebp, esp
	push	esi

; 646  : #       if defined KDU_WIN_THREADS
; 647  :           event = CreateEvent(NULL,(manual_reset?TRUE:FALSE),FALSE,NULL);

	xor	eax, eax
	mov	esi, ecx
	cmp	BYTE PTR _manual_reset$[ebp], al
	push	0
	push	0
	setne	al
	push	eax
	push	0
	call	DWORD PTR __imp__CreateEventA@16

; 612  :           return (event != NULL);

	xor	ecx, ecx

; 646  : #       if defined KDU_WIN_THREADS
; 647  :           event = CreateEvent(NULL,(manual_reset?TRUE:FALSE),FALSE,NULL);

	mov	DWORD PTR [esi], eax

; 612  :           return (event != NULL);

	test	eax, eax
	pop	esi
	setne	al

; 648  : #       elif defined KDU_PTHREADS
; 649  :           cond_exists = (pthread_cond_init(&cond,NULL) == 0);
; 650  :           this->manual_reset = manual_reset;
; 651  :           this->event_is_set = false;
; 652  : #       endif
; 653  :         return exists();
; 654  :       }

	pop	ebp
	ret	4
?create@kdu_event@@QAE_N_N@Z ENDP			; kdu_event::create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?exists@kdu_event@@QAE_NXZ
_TEXT	SEGMENT
?exists@kdu_event@@QAE_NXZ PROC				; kdu_event::exists, COMDAT
; _this$ = ecx

; 608  :              Returns true if the object has been successfully created in
; 609  :              a call to `create' that has not been matched by a call to
; 610  :              `destroy'. */
; 611  : #       if defined KDU_WIN_THREADS
; 612  :           return (event != NULL);

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 613  : #       elif defined KDU_PTHREADS
; 614  :           return cond_exists;
; 615  : #       else
; 616  :           return false;
; 617  : #       endif
; 618  :       }

	ret	0
?exists@kdu_event@@QAE_NXZ ENDP				; kdu_event::exists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ??0kdu_event@@QAE@XZ
_TEXT	SEGMENT
??0kdu_event@@QAE@XZ PROC				; kdu_event::kdu_event, COMDAT
; _this$ = ecx

; 598  :       { /* [SYNOPSIS] You need to call `create' explicitly, or else the
; 599  :                       `exists' function will continue to return false. */
; 600  : #       if defined KDU_WIN_THREADS
; 601  :           event = NULL;

	mov	DWORD PTR [ecx], 0

; 602  : #       elif defined KDU_PTHREADS
; 603  :           cond_exists = manual_reset = event_is_set = false;
; 604  : #       endif
; 605  :       }

	mov	eax, ecx
	ret	0
??0kdu_event@@QAE@XZ ENDP				; kdu_event::kdu_event
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?unlock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?unlock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::unlock, COMDAT
; _this$ = ecx

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@unlock
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	cmp	eax, 1
	jne	SHORT $LN3@unlock
	mov	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
$LN3@unlock:

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	xor	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
?unlock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?lock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?lock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::lock, COMDAT
; _this$ = ecx

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@lock
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	SHORT $LN3@lock
	mov	al, 1

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
$LN3@lock:

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	xor	al, al

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
?lock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?destroy@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?destroy@kdu_mutex@@QAE_NXZ PROC			; kdu_mutex::destroy, COMDAT
; _this$ = ecx

; 509  :       { /* [SYNOPSIS]

	push	esi
	mov	esi, ecx

; 510  :              You must explicitly call `create' and `destroy'.
; 511  :              The constructor and and destructor for the `kdu_mutex' object
; 512  :              do not create or destroy the underlying synchronization
; 513  :              primitive itself.
; 514  :            [RETURNS]
; 515  :              False if the mutex has not been successfully created. */
; 516  :         bool result = false;
; 517  : #       if defined KDU_WIN_THREADS
; 518  :           result = ((mutex != NULL) && (CloseHandle(mutex)==TRUE));

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@destroy
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	eax, 1
	jne	SHORT $LN3@destroy

; 519  :           mutex = NULL;

	mov	DWORD PTR [esi], 0
	mov	al, al
	pop	esi

; 520  : #       elif defined KDU_PTHREADS
; 521  :           result = (mutex_valid && (pthread_mutex_destroy(&mutex)==0));
; 522  :           mutex_valid = false;
; 523  : #       endif
; 524  :         return result;
; 525  :       }

	ret	0
$LN3@destroy:

; 519  :           mutex = NULL;

	mov	DWORD PTR [esi], 0
	xor	al, al
	pop	esi

; 520  : #       elif defined KDU_PTHREADS
; 521  :           result = (mutex_valid && (pthread_mutex_destroy(&mutex)==0));
; 522  :           mutex_valid = false;
; 523  : #       endif
; 524  :         return result;
; 525  :       }

	ret	0
?destroy@kdu_mutex@@QAE_NXZ ENDP			; kdu_mutex::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?create@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?create@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::create, COMDAT
; _this$ = ecx

; 490  :       { /* [SYNOPSIS]

	push	esi

; 491  :              You must explicitly call `create' and `destroy'.
; 492  :              The constructor and and destructor for the `kdu_mutex' object
; 493  :              do not create or destroy the underlying synchronization
; 494  :              primitive itself.
; 495  :            [RETURNS]
; 496  :              False if mutex creation is not supported on the current platform
; 497  :              or if the operating system is unwilling to allocate any more
; 498  :              synchronization primitives to the process.  The former problem
; 499  :              may be resolved by creating the appropriate definitions in
; 500  :              "kdu_elementary.h". */
; 501  : #       if defined KDU_WIN_THREADS
; 502  :           mutex = CreateMutex(NULL,FALSE,NULL);

	push	0
	push	0
	push	0
	mov	esi, ecx
	call	DWORD PTR __imp__CreateMutexA@12

; 480  :           return (mutex != NULL);

	xor	ecx, ecx

; 491  :              You must explicitly call `create' and `destroy'.
; 492  :              The constructor and and destructor for the `kdu_mutex' object
; 493  :              do not create or destroy the underlying synchronization
; 494  :              primitive itself.
; 495  :            [RETURNS]
; 496  :              False if mutex creation is not supported on the current platform
; 497  :              or if the operating system is unwilling to allocate any more
; 498  :              synchronization primitives to the process.  The former problem
; 499  :              may be resolved by creating the appropriate definitions in
; 500  :              "kdu_elementary.h". */
; 501  : #       if defined KDU_WIN_THREADS
; 502  :           mutex = CreateMutex(NULL,FALSE,NULL);

	mov	DWORD PTR [esi], eax

; 480  :           return (mutex != NULL);

	test	eax, eax
	pop	esi
	setne	al

; 503  : #       elif defined KDU_PTHREADS
; 504  :           mutex_valid = (pthread_mutex_init(&mutex,NULL) == 0);
; 505  : #       endif
; 506  :         return exists();
; 507  :       }

	ret	0
?create@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?exists@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?exists@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::exists, COMDAT
; _this$ = ecx

; 476  :              Returns true if the object has been successfully created in
; 477  :              a call to `create' that has not been matched by a call to
; 478  :              `destroy'. */
; 479  : #       if defined KDU_WIN_THREADS
; 480  :           return (mutex != NULL);

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 481  : #       elif defined KDU_PTHREADS
; 482  :           return mutex_valid;
; 483  : #       else
; 484  :           return false;
; 485  : #       endif
; 486  :       }

	ret	0
?exists@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::exists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ??0kdu_mutex@@QAE@XZ
_TEXT	SEGMENT
??0kdu_mutex@@QAE@XZ PROC				; kdu_mutex::kdu_mutex, COMDAT
; _this$ = ecx

; 466  :       { /* [SYNOPSIS] You need to call `create' explicitly, or else the
; 467  :                       `exists' function will continue to return false. */
; 468  : #       if defined KDU_WIN_THREADS
; 469  :           mutex=NULL;

	mov	DWORD PTR [ecx], 0

; 470  : #       elif defined KDU_PTHREADS
; 471  :           mutex_valid=false;
; 472  : #       endif
; 473  :       }

	mov	eax, ecx
	ret	0
??0kdu_mutex@@QAE@XZ ENDP				; kdu_mutex::kdu_mutex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?set_cpu_affinity@kdu_thread@@QAE_N_J@Z
_TEXT	SEGMENT
_affinity_mask$ = 8					; size = 8
?set_cpu_affinity@kdu_thread@@QAE_N_J@Z PROC		; kdu_thread::set_cpu_affinity, COMDAT
; _this$ = ecx

; 363  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 364  :              If supported, this function requests the scheduler to run the
; 365  :              thread only on one of the CPU's whose bit is set in the supplied
; 366  :              `cpu_mask'.  CPU n is included if bit n is set in `affinity_mask'.
; 367  :              The function returns true if the request is accepted.  Although
; 368  :              this function should be executable from any thread in the system,
; 369  :              experience shows that some platforms do not behave correctly
; 370  :              unless the function is invoked from within the thread whose
; 371  :              processor affinity is being modified.
; 372  :            [RETURNS]
; 373  :              False if the thread has not been successfully created, or the
; 374  :              `affinity_mask' is invalid, or the calling thread does not
; 375  :              have permission to set the CPU affinity of another thread, or
; 376  :              operating support has not yet been extended to offer this
; 377  :              specific feature.
; 378  :         */
; 379  : #       if (defined KDU_WIN_THREADS)
; 380  : #         if (defined _WIN64)
; 381  :              ULONG_PTR result =
; 382  :                SetThreadAffinityMask(thread,(ULONG_PTR) affinity_mask);
; 383  : #         else
; 384  :              int result = (int)
; 385  :                SetThreadAffinityMask(thread,(DWORD) affinity_mask); 

	push	DWORD PTR _affinity_mask$[ebp]
	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__SetThreadAffinityMask@8

; 386  : #         endif
; 387  :           return (result != 0);

	neg	eax
	sbb	eax, eax
	neg	eax

; 388  : #       else
; 389  :           return false;
; 390  : #       endif
; 391  :       }

	pop	ebp
	ret	8
?set_cpu_affinity@kdu_thread@@QAE_N_J@Z ENDP		; kdu_thread::set_cpu_affinity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?destroy@kdu_thread@@QAE_NXZ
_TEXT	SEGMENT
?destroy@kdu_thread@@QAE_NXZ PROC			; kdu_thread::destroy, COMDAT
; _this$ = ecx

; 345  :       { /* [SYNOPSIS]

	push	esi
	mov	esi, ecx

; 346  :              Suspends the caller until the thread has terminated.
; 347  :            [RETURNS]
; 348  :              False if the thread has not been successfully created.
; 349  :         */
; 350  :         bool result = false;
; 351  : #       if defined KDU_WIN_THREADS
; 352  :           result = ((thread != NULL) &&

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@destroy
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	SHORT $LN3@destroy
	push	DWORD PTR [esi]
	call	DWORD PTR __imp__CloseHandle@4
	cmp	eax, 1
	jne	SHORT $LN3@destroy

; 353  :                     (WaitForSingleObject(thread,INFINITE)==WAIT_OBJECT_0) &&
; 354  :                     (CloseHandle(thread)==TRUE));
; 355  :           thread = NULL;

	mov	DWORD PTR [esi], 0
	mov	al, al
	pop	esi

; 356  : #       elif defined KDU_PTHREADS
; 357  :           result = (thread_valid && (pthread_join(thread,NULL) == 0));
; 358  :           thread_valid = false;
; 359  : #       endif
; 360  :         return result;
; 361  :       }

	ret	0
$LN3@destroy:

; 353  :                     (WaitForSingleObject(thread,INFINITE)==WAIT_OBJECT_0) &&
; 354  :                     (CloseHandle(thread)==TRUE));
; 355  :           thread = NULL;

	mov	DWORD PTR [esi], 0
	xor	al, al
	pop	esi

; 356  : #       elif defined KDU_PTHREADS
; 357  :           result = (thread_valid && (pthread_join(thread,NULL) == 0));
; 358  :           thread_valid = false;
; 359  : #       endif
; 360  :         return result;
; 361  :       }

	ret	0
?destroy@kdu_thread@@QAE_NXZ ENDP			; kdu_thread::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?create@kdu_thread@@QAE_NP6GKPAX@Z0@Z
_TEXT	SEGMENT
_start_proc$ = 8					; size = 4
_start_arg$ = 12					; size = 4
?create@kdu_thread@@QAE_NP6GKPAX@Z0@Z PROC		; kdu_thread::create, COMDAT
; _this$ = ecx

; 326  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 327  :              Creates a new thread of execution, with `start_proc' as its
; 328  :              entry-point and `start_arg' as the parameter passed to
; 329  :              `start_proc' on entry.
; 330  :            [RETURNS]
; 331  :              False if thread creation is not supported on the current platform
; 332  :              or if the operating system is unwilling to allocate any more
; 333  :              threads to the process.  The former problem may be resolved by
; 334  :              creating the appropriate definitions in "kdu_elementary.h".
; 335  :         */
; 336  : #       if defined KDU_WIN_THREADS
; 337  :           thread = CreateThread(NULL,0,start_proc,start_arg,0,&thread_id);

	lea	eax, DWORD PTR [esi+4]
	push	eax
	push	0
	push	DWORD PTR _start_arg$[ebp]
	push	DWORD PTR _start_proc$[ebp]
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24

; 275  :           return (thread != NULL);

	xor	ecx, ecx

; 327  :              Creates a new thread of execution, with `start_proc' as its
; 328  :              entry-point and `start_arg' as the parameter passed to
; 329  :              `start_proc' on entry.
; 330  :            [RETURNS]
; 331  :              False if thread creation is not supported on the current platform
; 332  :              or if the operating system is unwilling to allocate any more
; 333  :              threads to the process.  The former problem may be resolved by
; 334  :              creating the appropriate definitions in "kdu_elementary.h".
; 335  :         */
; 336  : #       if defined KDU_WIN_THREADS
; 337  :           thread = CreateThread(NULL,0,start_proc,start_arg,0,&thread_id);

	mov	DWORD PTR [esi], eax

; 275  :           return (thread != NULL);

	test	eax, eax
	pop	esi
	setne	al

; 338  : #       elif defined KDU_PTHREADS
; 339  :           thread_valid =
; 340  :             (pthread_create(&thread,NULL,start_proc,start_arg) == 0);
; 341  : #       endif
; 342  :         return exists();
; 343  :       }

	pop	ebp
	ret	8
?create@kdu_thread@@QAE_NP6GKPAX@Z0@Z ENDP		; kdu_thread::create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?set_to_self@kdu_thread@@QAE_NXZ
_TEXT	SEGMENT
?set_to_self@kdu_thread@@QAE_NXZ PROC			; kdu_thread::set_to_self, COMDAT
; _this$ = ecx

; 304  :       { /* [SYNOPSIS]

	push	esi
	mov	esi, ecx

; 305  :              You can use this function to create a reference to the
; 306  :              caller's own thread.  The resulting object can be passed to
; 307  :              `equals', `get_priority', `set_priority' and `set_cpu_affinity'.
; 308  :              Do not invoke the `destroy' function on a `kdu_thread' object
; 309  :              created in this way.
; 310  :            [RETURNS]
; 311  :              False if thread functionality is not supported on the current
; 312  :              platform.  This problem can usually be resolved by
; 313  :              creating the appropriate definitions in "kdu_elementary.h".
; 314  :         */
; 315  : #       if defined KDU_WIN_THREADS
; 316  :           thread = GetCurrentThread();  thread_id = GetCurrentThreadId();

	call	DWORD PTR __imp__GetCurrentThread@0
	mov	DWORD PTR [esi], eax
	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR [esi+4], eax

; 317  :           return true;

	mov	al, 1
	pop	esi

; 318  : #       elif defined KDU_PTHREADS
; 319  :           thread = pthread_self();
; 320  :           return thread_valid = true;
; 321  : #       else
; 322  :           return false;
; 323  : #       endif
; 324  :       }

	ret	0
?set_to_self@kdu_thread@@QAE_NXZ ENDP			; kdu_thread::set_to_self
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?equals@kdu_thread@@QAE_NAAV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?equals@kdu_thread@@QAE_NAAV1@@Z PROC			; kdu_thread::equals, COMDAT
; _this$ = ecx

; 285  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 286  :              You can use this function to reliably determine whether or
; 287  :              not two `kdu_thread' objects refer to the same underlying
; 288  :              threads. */
; 289  : #       if defined KDU_WIN_THREADS
; 290  :           return ((rhs.thread != NULL) && (this->thread != NULL) &&

	mov	eax, DWORD PTR _rhs$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@equals
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@equals
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [ecx+4]
	jne	SHORT $LN3@equals
	mov	al, 1

; 291  :                   (rhs.thread_id == this->thread_id));
; 292  : #       elif defined KDU_PTHREADS
; 293  :           return (rhs.thread_valid && this->thread_valid &&
; 294  :                   (pthread_equal(rhs.thread,this->thread) != 0));
; 295  : #       else
; 296  :           return false;
; 297  : #       endif
; 298  :       }

	pop	ebp
	ret	4
$LN3@equals:

; 286  :              You can use this function to reliably determine whether or
; 287  :              not two `kdu_thread' objects refer to the same underlying
; 288  :              threads. */
; 289  : #       if defined KDU_WIN_THREADS
; 290  :           return ((rhs.thread != NULL) && (this->thread != NULL) &&

	xor	al, al

; 291  :                   (rhs.thread_id == this->thread_id));
; 292  : #       elif defined KDU_PTHREADS
; 293  :           return (rhs.thread_valid && this->thread_valid &&
; 294  :                   (pthread_equal(rhs.thread,this->thread) != 0));
; 295  : #       else
; 296  :           return false;
; 297  : #       endif
; 298  :       }

	pop	ebp
	ret	4
?equals@kdu_thread@@QAE_NAAV1@@Z ENDP			; kdu_thread::equals
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?exists@kdu_thread@@QAE_NXZ
_TEXT	SEGMENT
?exists@kdu_thread@@QAE_NXZ PROC			; kdu_thread::exists, COMDAT
; _this$ = ecx

; 270  :              Returns true if the thread has been successfully created by
; 271  :              a call to `create' that has not been matched by a completed
; 272  :              call to `destroy', or if a successful call to
; 273  :              `set_to_self' has been processed. */
; 274  : #       if defined KDU_WIN_THREADS
; 275  :           return (thread != NULL);

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 276  : #       elif defined KDU_PTHREADS
; 277  :           return thread_valid;
; 278  : #       else
; 279  :           return false;
; 280  : #       endif
; 281  :       }

	ret	0
?exists@kdu_thread@@QAE_NXZ ENDP			; kdu_thread::exists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ??0kdu_thread@@QAE@XZ
_TEXT	SEGMENT
??0kdu_thread@@QAE@XZ PROC				; kdu_thread::kdu_thread, COMDAT
; _this$ = ecx

; 260  :       { /* [SYNOPSIS] You need to call `create' explicitly, or else the
; 261  :                       `exists' function will continue to return false. */
; 262  : #       if defined KDU_WIN_THREADS
; 263  :           thread=NULL; thread_id=0;

	mov	DWORD PTR [ecx], 0

; 264  : #       elif defined KDU_PTHREADS
; 265  :           thread_valid=false;
; 266  : #       endif
; 267  :       }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kdu_thread@@QAE@XZ ENDP				; kdu_thread::kdu_thread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\threads\kdu_threads.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
