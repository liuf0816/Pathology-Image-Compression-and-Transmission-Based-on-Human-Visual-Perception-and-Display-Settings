; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\coding\decoder.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	??1kdu_worker@@UAE@XZ				; kdu_worker::~kdu_worker
PUBLIC	??_Gkdu_worker@@UAEPAXI@Z			; kdu_worker::`scalar deleting destructor'
PUBLIC	??1kdu_pull_ifc_base@@MAE@XZ			; kdu_pull_ifc_base::~kdu_pull_ifc_base
PUBLIC	??_Gkdu_pull_ifc_base@@MAEPAXI@Z		; kdu_pull_ifc_base::`scalar deleting destructor'
PUBLIC	??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_decoder::kdu_decoder
PUBLIC	??0kd_decoder@@QAE@XZ				; kd_decoder::kd_decoder
PUBLIC	?init@kd_decoder@@QAEXVkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kd_decoder::init
PUBLIC	??1kd_decoder@@MAE@XZ				; kd_decoder::~kd_decoder
PUBLIC	?start@kd_decoder@@MAEXPAVkdu_thread_env@@@Z	; kd_decoder::start
PUBLIC	?pull@kd_decoder@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z ; kd_decoder::pull
PUBLIC	?do_job@kd_decoder@@EAEXPAVkdu_thread_entity@@H@Z ; kd_decoder::do_job
PUBLIC	?adjust_roi_background@kd_decoder@@AAEXPAUkdu_block@@@Z ; kd_decoder::adjust_roi_background
PUBLIC	??_Gkd_decoder@@MAEPAXI@Z			; kd_decoder::`scalar deleting destructor'
PUBLIC	??_Ekd_decoder@@O3AEPAXI@Z			; [thunk]:kd_decoder::`vector deleting destructor'
PUBLIC	??_7kdu_worker@@6B@				; kdu_worker::`vftable'
PUBLIC	__TI1H
PUBLIC	__CTA1H
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
PUBLIC	__CT??_R0H@84
PUBLIC	??_7kdu_pull_ifc_base@@6B@			; kdu_pull_ifc_base::`vftable'
PUBLIC	??_7kd_decoder@@6Bkdu_pull_ifc_base@@@		; kd_decoder::`vftable'
PUBLIC	??_7kd_decoder@@6Bkdu_worker@@@			; kd_decoder::`vftable'
PUBLIC	??_C@_0O@BAMEPCPN@block?5decoder?$AA@		; `string'
PUBLIC	??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@	; `string'
PUBLIC	??_C@_0FA@ENJPJF@Insufficient?5implementation?5prec@ ; `string'
PUBLIC	??_R4kdu_worker@@6B@				; kdu_worker::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_worker@@@8				; kdu_worker `RTTI Type Descriptor'
PUBLIC	??_R3kdu_worker@@8				; kdu_worker::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_worker@@8				; kdu_worker::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_worker@@8			; kdu_worker::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kdu_pull_ifc_base@@6B@			; kdu_pull_ifc_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_pull_ifc_base@@@8			; kdu_pull_ifc_base `RTTI Type Descriptor'
PUBLIC	??_R3kdu_pull_ifc_base@@8			; kdu_pull_ifc_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_pull_ifc_base@@8			; kdu_pull_ifc_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_pull_ifc_base@@8		; kdu_pull_ifc_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_decoder@@6Bkdu_pull_ifc_base@@@		; kd_decoder::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_decoder@@@8				; kd_decoder `RTTI Type Descriptor'
PUBLIC	??_R3kd_decoder@@8				; kd_decoder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_decoder@@8				; kd_decoder::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_decoder@@8			; kd_decoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@kdu_worker@@8			; kdu_worker::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R4kd_decoder@@6Bkdu_worker@@@		; kd_decoder::`RTTI Complete Object Locator'
PUBLIC	__real@3f000000
PUBLIC	__real@46000000
PUBLIC	__real@4f800000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	??0kdu_error@@QAE@PBD@Z:PROC			; kdu_error::kdu_error
EXTRN	??1kdu_error@@UAE@XZ:PROC			; kdu_error::~kdu_error
EXTRN	??_Ekdu_worker@@UAEPAXI@Z:PROC			; kdu_worker::`vector deleting destructor'
EXTRN	?get_num_threads@kdu_thread_entity@@QAEHXZ:PROC	; kdu_thread_entity::get_num_threads
EXTRN	?add_queue@kdu_thread_entity@@QAEPAUkdu_thread_queue@@PAVkdu_worker@@PAU2@PBD_J@Z:PROC ; kdu_thread_entity::add_queue
EXTRN	?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z:PROC ; kdu_thread_entity::add_jobs
EXTRN	?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z:PROC ; kdu_thread_entity::process_jobs
EXTRN	?get_dwt_level@kdu_resolution@@QAEHXZ:PROC	; kdu_resolution::get_dwt_level
EXTRN	?get_band_idx@kdu_subband@@QAEHXZ:PROC		; kdu_subband::get_band_idx
EXTRN	?access_resolution@kdu_subband@@QAE?AVkdu_resolution@@XZ:PROC ; kdu_subband::access_resolution
EXTRN	?get_K_max@kdu_subband@@QAEHXZ:PROC		; kdu_subband::get_K_max
EXTRN	?get_K_max_prime@kdu_subband@@QAEHXZ:PROC	; kdu_subband::get_K_max_prime
EXTRN	?get_reversible@kdu_subband@@QAE_NXZ:PROC	; kdu_subband::get_reversible
EXTRN	?get_delta@kdu_subband@@QAEMXZ:PROC		; kdu_subband::get_delta
EXTRN	?get_dims@kdu_subband@@QAEXAAUkdu_dims@@@Z:PROC	; kdu_subband::get_dims
EXTRN	?get_valid_blocks@kdu_subband@@QAEXAAUkdu_dims@@@Z:PROC ; kdu_subband::get_valid_blocks
EXTRN	?get_block_size@kdu_subband@@QAEXAAUkdu_coords@@0@Z:PROC ; kdu_subband::get_block_size
EXTRN	?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z:PROC ; kdu_subband::open_block
EXTRN	?close_block@kdu_subband@@QAEXPAUkdu_block@@PAVkdu_thread_env@@@Z:PROC ; kdu_subband::close_block
EXTRN	??_Ekdu_pull_ifc_base@@MAEPAXI@Z:PROC		; kdu_pull_ifc_base::`vector deleting destructor'
EXTRN	??0kdu_block_decoder@@QAE@XZ:PROC		; kdu_block_decoder::kdu_block_decoder
EXTRN	??_Ekd_decoder@@MAEPAXI@Z:PROC			; kd_decoder::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	_memcpy:PROC
EXTRN	?kdu_mmx_level@@3HA:DWORD			; kdu_mmx_level
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+09
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_R4kd_decoder@@6Bkdu_worker@@@
rdata$r	SEGMENT
??_R4kd_decoder@@6Bkdu_worker@@@ DD 00H			; kd_decoder::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVkd_decoder@@@8
	DD	FLAT:??_R3kd_decoder@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@kdu_worker@@8
rdata$r	SEGMENT
??_R13?0A@EA@kdu_worker@@8 DD FLAT:??_R0?AVkdu_worker@@@8 ; kdu_worker::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_decoder@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_decoder@@8 DD FLAT:??_R0?AVkd_decoder@@@8 ; kd_decoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_decoder@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_decoder@@8
rdata$r	SEGMENT
??_R2kd_decoder@@8 DD FLAT:??_R1A@?0A@EA@kd_decoder@@8	; kd_decoder::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_pull_ifc_base@@8
	DD	FLAT:??_R13?0A@EA@kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_decoder@@8
rdata$r	SEGMENT
??_R3kd_decoder@@8 DD 00H				; kd_decoder::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2kd_decoder@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_decoder@@@8
data$r	SEGMENT
??_R0?AVkd_decoder@@@8 DD FLAT:??_7type_info@@6B@	; kd_decoder `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_decoder@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_decoder@@6Bkdu_pull_ifc_base@@@
rdata$r	SEGMENT
??_R4kd_decoder@@6Bkdu_pull_ifc_base@@@ DD 00H		; kd_decoder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_decoder@@@8
	DD	FLAT:??_R3kd_decoder@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_pull_ifc_base@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_pull_ifc_base@@8 DD FLAT:??_R0?AVkdu_pull_ifc_base@@@8 ; kdu_pull_ifc_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_pull_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_pull_ifc_base@@8
rdata$r	SEGMENT
??_R2kdu_pull_ifc_base@@8 DD FLAT:??_R1A@?0A@EA@kdu_pull_ifc_base@@8 ; kdu_pull_ifc_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_pull_ifc_base@@8
rdata$r	SEGMENT
??_R3kdu_pull_ifc_base@@8 DD 00H			; kdu_pull_ifc_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_pull_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_pull_ifc_base@@@8
data$r	SEGMENT
??_R0?AVkdu_pull_ifc_base@@@8 DD FLAT:??_7type_info@@6B@ ; kdu_pull_ifc_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_pull_ifc_base@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_pull_ifc_base@@6B@
rdata$r	SEGMENT
??_R4kdu_pull_ifc_base@@6B@ DD 00H			; kdu_pull_ifc_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_pull_ifc_base@@@8
	DD	FLAT:??_R3kdu_pull_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_worker@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_worker@@8 DD FLAT:??_R0?AVkdu_worker@@@8 ; kdu_worker::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_worker@@8
rdata$r	SEGMENT
??_R2kdu_worker@@8 DD FLAT:??_R1A@?0A@EA@kdu_worker@@8	; kdu_worker::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_worker@@8
rdata$r	SEGMENT
??_R3kdu_worker@@8 DD 00H				; kdu_worker::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_worker@@@8
data$r	SEGMENT
??_R0?AVkdu_worker@@@8 DD FLAT:??_7type_info@@6B@	; kdu_worker `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_worker@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_worker@@6B@
rdata$r	SEGMENT
??_R4kdu_worker@@6B@ DD 00H				; kdu_worker::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_worker@@@8
	DD	FLAT:??_R3kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_C@_0FA@ENJPJF@Insufficient?5implementation?5prec@
CONST	SEGMENT
??_C@_0FA@ENJPJF@Insufficient?5implementation?5prec@ DB 'Insufficient imp'
	DB	'lementation precision available for true reversible processin'
	DB	'g!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
CONST	SEGMENT
??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@ DB 'Kakadu Core Error:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BAMEPCPN@block?5decoder?$AA@
CONST	SEGMENT
??_C@_0O@BAMEPCPN@block?5decoder?$AA@ DB 'block decoder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7kd_decoder@@6Bkdu_worker@@@
CONST	SEGMENT
??_7kd_decoder@@6Bkdu_worker@@@ DD FLAT:??_R4kd_decoder@@6Bkdu_worker@@@ ; kd_decoder::`vftable'
	DD	FLAT:??_Ekd_decoder@@O3AEPAXI@Z
	DD	FLAT:?do_job@kd_decoder@@EAEXPAVkdu_thread_entity@@H@Z
CONST	ENDS
;	COMDAT ??_7kd_decoder@@6Bkdu_pull_ifc_base@@@
CONST	SEGMENT
??_7kd_decoder@@6Bkdu_pull_ifc_base@@@ DD FLAT:??_R4kd_decoder@@6Bkdu_pull_ifc_base@@@ ; kd_decoder::`vftable'
	DD	FLAT:??_Ekd_decoder@@MAEPAXI@Z
	DD	FLAT:?start@kd_decoder@@MAEXPAVkdu_thread_env@@@Z
	DD	FLAT:?pull@kd_decoder@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z
CONST	ENDS
;	COMDAT ??_7kdu_pull_ifc_base@@6B@
CONST	SEGMENT
??_7kdu_pull_ifc_base@@6B@ DD FLAT:??_R4kdu_pull_ifc_base@@6B@ ; kdu_pull_ifc_base::`vftable'
	DD	FLAT:??_Ekdu_pull_ifc_base@@MAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0H@8
data$r	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
data$r	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
;	COMDAT ??_7kdu_worker@@6B@
CONST	SEGMENT
??_7kdu_worker@@6B@ DD FLAT:??_R4kdu_worker@@6B@	; kdu_worker::`vftable'
	DD	FLAT:??_Ekdu_worker@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_job@kd_decoder@@EAEXPAVkdu_thread_entity@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_job@kd_decoder@@EAEXPAVkdu_thread_entity@@H@Z$0
__ehfuncinfo$?do_job@kd_decoder@@EAEXPAVkdu_thread_entity@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_job@kd_decoder@@EAEXPAVkdu_thread_entity@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0kd_decoder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0kd_decoder@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0kd_decoder@@QAE@XZ$1
__ehfuncinfo$??0kd_decoder@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0kd_decoder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z$0
__ehfuncinfo$??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_Ekd_decoder@@O3AEPAXI@Z
_TEXT	SEGMENT
??_Ekd_decoder@@O3AEPAXI@Z PROC				; [thunk]:kd_decoder::`vector deleting destructor', COMDAT
	sub	ecx, 4
	jmp	??_Ekd_decoder@@MAEPAXI@Z
??_Ekd_decoder@@O3AEPAXI@Z ENDP				; [thunk]:kd_decoder::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_decoder@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_decoder@@MAEPAXI@Z PROC				; kd_decoder::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_decoder@@MAE@XZ			; kd_decoder::~kd_decoder
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	92					; 0000005cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_decoder@@MAEPAXI@Z ENDP				; kd_decoder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
;	COMDAT ?adjust_roi_background@kd_decoder@@AAEXPAUkdu_block@@@Z
_TEXT	SEGMENT
_block$ = 8						; size = 4
?adjust_roi_background@kd_decoder@@AAEXPAUkdu_block@@@Z PROC ; kd_decoder::adjust_roi_background, COMDAT
; _this$ = ecx

; 736  : {

	push	ebp
	mov	ebp, esp

; 737  :   kdu_int32 upshift = K_max_prime - K_max;

	movsx	eax, WORD PTR [ecx+16]
	push	ebx
	push	esi
	push	edi
	movsx	edi, WORD PTR [ecx+18]

; 738  :   kdu_int32 mask = (-1)<<(31-K_max); mask &= KDU_INT32_MAX;

	or	ebx, -1
	sub	edi, eax
	mov	ecx, 31					; 0000001fH
	sub	ecx, eax

; 739  :   kdu_int32 *sp = block->sample_buffer;

	mov	eax, DWORD PTR _block$[ebp]
	shl	ebx, cl
	and	ebx, 2147483647				; 7fffffffH

; 740  :   kdu_int32 val;
; 741  :   int num_samples = ((block->size.y+3)>>2) * (block->size.x<<2);

	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+108]
	add	esi, 3
	mov	eax, DWORD PTR [eax+4]
	sar	esi, 2
	shl	eax, 2
	imul	esi, eax

; 742  : 
; 743  :   for (int n=num_samples; n--; sp++)

	test	esi, esi
	je	SHORT $LN10@adjust_roi
	npad	3
$LL4@adjust_roi:

; 744  :     if ((((val=*sp) & mask) == 0) && (val != 0))

	mov	eax, DWORD PTR [edx]
	dec	esi
	test	eax, ebx
	jne	SHORT $LN2@adjust_roi
	test	eax, eax
	je	SHORT $LN2@adjust_roi

; 747  :           *sp = (val << upshift) | KDU_INT32_MIN;

	mov	ecx, edi

; 745  :       {
; 746  :         if (val < 0)

	jns	SHORT $LN6@adjust_roi

; 747  :           *sp = (val << upshift) | KDU_INT32_MIN;

	shl	eax, cl
	or	eax, -2147483648			; 80000000H

; 748  :         else

	jmp	SHORT $LN14@adjust_roi
$LN6@adjust_roi:

; 749  :           *sp <<= upshift;

	shl	eax, cl
$LN14@adjust_roi:
	mov	DWORD PTR [edx], eax
$LN2@adjust_roi:

; 742  : 
; 743  :   for (int n=num_samples; n--; sp++)

	add	edx, 4
	test	esi, esi
	jne	SHORT $LL4@adjust_roi
$LN10@adjust_roi:
	pop	edi
	pop	esi
	pop	ebx

; 750  :       }
; 751  : }

	pop	ebp
	ret	4
?adjust_roi_background@kd_decoder@@AAEXPAUkdu_block@@@Z ENDP ; kd_decoder::adjust_roi_background
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
;	COMDAT ?do_job@kd_decoder@@EAEXPAVkdu_thread_entity@@H@Z
_TEXT	SEGMENT
_e$2 = -100						; size = 20
tv1417 = -80						; size = 4
_downshift$1$ = -76					; size = 4
tv1407 = -76						; size = 4
tv1397 = -76						; size = 4
tv1396 = -76						; size = 4
tv1393 = -76						; size = 4
tv1390 = -76						; size = 4
tv1386 = -76						; size = 4
tv1408 = -72						; size = 4
tv1406 = -72						; size = 4
tv1405 = -72						; size = 4
tv1399 = -72						; size = 4
tv1395 = -72						; size = 4
tv1384 = -72						; size = 4
tv1382 = -72						; size = 4
tv1381 = -72						; size = 4
_scale$1$ = -68						; size = 4
_downshift$1$ = -68					; size = 4
tv1400 = -68						; size = 4
tv1383 = -68						; size = 4
_idx$1$ = -64						; size = 4
_offset$1$ = -60					; size = 4
_idx$2$ = -56						; size = 4
_buf16$1$ = -52						; size = 4
_buf32$1$ = -48						; size = 4
_blocks_remaining$1$ = -44				; size = 4
_this$1$ = -40						; size = 4
_row_gap$1$ = -36					; size = 4
_n_inc$1$ = -32						; size = 4
_block$1$ = -28						; size = 4
_dpp$1$ = -24						; size = 4
_dpp$1$ = -24						; size = 4
_xfer_size$1$ = -20					; size = 4
_spp$2$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ent$ = 8						; size = 4
_m$10$ = 12						; size = 4
_job_idx$ = 12						; size = 4
?do_job@kd_decoder@@EAEXPAVkdu_thread_entity@@H@Z PROC	; kd_decoder::do_job, COMDAT
; _this$ = ecx

; 495  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_job@kd_decoder@@EAEXPAVkdu_thread_entity@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 496  :   kdu_thread_env *env = (kdu_thread_env *) ent;
; 497  :   int jobs_per_row = num_jobs_per_row;
; 498  :   int blocks_remaining = block_indices.size.x;
; 499  :   int offset = 0; // Horizontal offset into line buffers
; 500  :   kdu_coords idx = block_indices.pos; // Index of first block to process

	mov	eax, DWORD PTR [ebx+24]

; 501  :   kdu_sample32 **buf32 = lines32; // First buffer line to process (32-bit)
; 502  :   kdu_sample16 **buf16 = lines16; // First buffer line to process (16-bit)
; 503  : 
; 504  :   // Start by using `job_idx' to find where we are
; 505  :   int decoder_block_row = job_idx / jobs_per_row;

	mov	edi, DWORD PTR _job_idx$[ebp]
	movzx	esi, BYTE PTR [ebx+19]
	mov	DWORD PTR _idx$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR _idx$2$[ebp], eax
	mov	eax, DWORD PTR [ebx+76]
	mov	DWORD PTR _buf32$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+72]
	mov	DWORD PTR _buf16$1$[ebp], eax
	mov	eax, edi
	cdq
	idiv	esi
	mov	ecx, DWORD PTR [ebx+36]
	mov	edx, eax
	mov	DWORD PTR _blocks_remaining$1$[ebp], ecx
	mov	DWORD PTR _offset$1$[ebp], 0

; 506  :   if ((decoder_block_row & 1) && (buffer_height > nominal_block_height))

	test	dl, 1
	je	SHORT $LN70@do_job
	movzx	ecx, WORD PTR [ebx+56]
	cmp	WORD PTR [ebx+58], cx
	jle	SHORT $LN274@do_job

; 507  :     { // Select memory bank 1
; 508  :       if (buf32 != NULL) buf32 += nominal_block_height;

	mov	ebx, DWORD PTR _buf32$1$[ebp]
	test	ebx, ebx
	je	SHORT $LN69@do_job
	movsx	eax, cx
	lea	ebx, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR _buf32$1$[ebp], ebx
$LN69@do_job:

; 509  :       if (buf16 != NULL) buf16 += nominal_block_height;

	cmp	DWORD PTR _buf16$1$[ebp], 0
	je	SHORT $LN274@do_job
	movsx	eax, cx
	mov	ecx, DWORD PTR _buf16$1$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _buf16$1$[ebp], ecx
$LN274@do_job:
	mov	ecx, DWORD PTR _blocks_remaining$1$[ebp]
$LN70@do_job:

; 510  :     }
; 511  :   idx.y += decoder_block_row;

	add	DWORD PTR _idx$1$[ebp], edx

; 512  :   assert(idx.y < (block_indices.pos.y + block_indices.size.y));
; 513  :   if (jobs_per_row > 1)

	cmp	esi, 1
	jle	SHORT $LN270@do_job

; 514  :     {
; 515  :       int job_idx_in_row = job_idx - (decoder_block_row*jobs_per_row);

	imul	edx, esi
	sub	edi, edx

; 516  :       int skip_blocks = (blocks_remaining*job_idx_in_row) / jobs_per_row;

	mov	eax, edi
	imul	eax, ecx
	cdq
	idiv	esi
	mov	ecx, eax

; 517  :       blocks_remaining =

	lea	eax, DWORD PTR [edi+1]
	imul	eax, DWORD PTR _blocks_remaining$1$[ebp]

; 518  :         ((blocks_remaining*(job_idx_in_row+1))/jobs_per_row)-skip_blocks;
; 519  :       assert(blocks_remaining > 0);
; 520  :       if (skip_blocks > 0)
; 521  :         {
; 522  :           idx.x += skip_blocks;
; 523  :           offset += first_block_width +

	mov	edi, DWORD PTR _this$1$[ebp]
	cdq
	idiv	esi
	mov	edx, DWORD PTR _idx$2$[ebp]
	mov	ebx, eax
	sub	ebx, ecx
	mov	DWORD PTR _blocks_remaining$1$[ebp], ebx
	test	ecx, ecx
	jle	SHORT $LN271@do_job
	movsx	esi, WORD PTR [edi+54]
	add	edx, ecx
	movsx	eax, WORD PTR [edi+50]
	dec	ecx
	imul	esi, ecx
	mov	DWORD PTR _idx$2$[ebp], edx
	add	esi, eax
	mov	DWORD PTR _offset$1$[ebp], esi
	jmp	SHORT $LN72@do_job
$LN270@do_job:
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	ebx, DWORD PTR _blocks_remaining$1$[ebp]
	mov	edx, DWORD PTR _idx$2$[ebp]
$LN271@do_job:
	xor	esi, esi
$LN72@do_job:

; 524  :             (skip_blocks-1) * (int) nominal_block_width;
; 525  :         }
; 526  :     }
; 527  : 
; 528  :   // Now scan through the blocks to process
; 529  :   kdu_coords xfer_size;
; 530  :   kdu_block *block;
; 531  : 
; 532  :   for (; blocks_remaining > 0; blocks_remaining--,

	test	ebx, ebx
	jle	$LN3@do_job
	lea	eax, DWORD PTR [edi+8]
	mov	DWORD PTR tv1417[ebp], eax
$LL4@do_job:

; 534  :     {
; 535  :       block = band.open_block(idx,NULL,env);

	push	DWORD PTR _ent$[ebp]
	mov	ecx, eax
	push	0
	push	edx
	push	DWORD PTR _idx$1$[ebp]
	call	?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z ; kdu_subband::open_block
	mov	edx, eax
	mov	DWORD PTR _block$1$[ebp], edx

; 536  : 
; 537  : 	  if (block->num_passes > 0)

	cmp	DWORD PTR [edx+48], 0
	jle	SHORT $LN73@do_job
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h

; 214  :         state->decode(block);

	mov	ecx, DWORD PTR [edi+4]
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+4]
	mov	edx, DWORD PTR _block$1$[ebp]
$LN73@do_job:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 540  :       if (block->transpose)

	cmp	BYTE PTR [edx+24], 0
	mov	ebx, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR _m$10$[ebp], ebx
	mov	DWORD PTR _xfer_size$1$[ebp], ecx
	je	SHORT $LN74@do_job
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, ebx
	mov	DWORD PTR _m$10$[ebp], ecx
	mov	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR _xfer_size$1$[ebp], ecx
$LN74@do_job:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 544  :       if (block->num_passes == 0)

	cmp	DWORD PTR [edx+48], 0
	jne	$LN75@do_job

; 545  :         { /* Fill block region with 0's.  Note the unrolled loops and the
; 546  :              fact that there is no need to worry if the code zeros out as
; 547  :              many as 3 samples beyond the end of each block line, since the
; 548  :              buffers were allocated with a bit of extra space at the end. */
; 549  :           if (buf32 != NULL)

	mov	eax, DWORD PTR _buf32$1$[ebp]

; 550  :             { // 32-bit samples
; 551  :               kdu_sample32 *dp;
; 552  :               for (m=0; m < xfer_size.y; m++)

	xor	edx, edx
	test	eax, eax
	je	$LN77@do_job
	test	ebx, ebx
	jle	$LN184@do_job
	shl	esi, 2
	npad	2
$LL7@do_job:

; 553  :                 if (reversible)

	cmp	BYTE PTR [edi+16], 0
	je	SHORT $LN79@do_job

; 554  :                   for (dp=buf32[m]+offset, n=xfer_size.x; n>0; n-=4, dp+=4)

	mov	edi, DWORD PTR [eax+edx*4]
	add	edi, esi
	test	ecx, ecx
	jle	SHORT $LN269@do_job
	dec	ecx
	and	ecx, -4					; fffffffcH
	add	ecx, 4
	and	ecx, 1073741820				; 3ffffffcH
	xor	eax, eax
	rep stosd

; 555  :                     { dp[0].ival=0; dp[1].ival=0; dp[2].ival=0; dp[3].ival=0;}
; 556  :                 else

	mov	ecx, DWORD PTR _xfer_size$1$[ebp]
	mov	edi, DWORD PTR _this$1$[ebp]
$LN272@do_job:
	mov	eax, DWORD PTR _buf32$1$[ebp]
$LN5@do_job:

; 550  :             { // 32-bit samples
; 551  :               kdu_sample32 *dp;
; 552  :               for (m=0; m < xfer_size.y; m++)

	inc	edx
	cmp	edx, ebx
	jl	SHORT $LL7@do_job

; 559  :                       dp[2].fval = 0.0F; dp[3].fval = 0.0F; }
; 560  :             }
; 561  :           else

	jmp	$LN184@do_job
$LN79@do_job:

; 557  :                   for (dp=buf32[m]+offset, n=xfer_size.x; n>0; n-=4, dp+=4)

	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	test	ecx, ecx
	jle	SHORT $LN272@do_job
	dec	ecx
	shr	ecx, 2
	inc	ecx
	npad	15
$LL13@do_job:

; 558  :                     { dp[0].fval = 0.0F; dp[1].fval = 0.0F;

	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [eax-12], 0
	mov	DWORD PTR [eax-8], 0
	mov	DWORD PTR [eax-4], 0
	sub	ecx, 1
	jne	SHORT $LL13@do_job
	mov	ecx, DWORD PTR _xfer_size$1$[ebp]
	jmp	SHORT $LN272@do_job
$LN269@do_job:
	mov	edi, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LN5@do_job
$LN77@do_job:

; 562  :             { // 16-bit samples
; 563  :               kdu_sample16 *dp;
; 564  :               for (m=0; m < xfer_size.y; m++)

	test	ebx, ebx
	jle	$LN184@do_job
	add	esi, esi
$LL16@do_job:

; 565  :                 for (dp=buf16[m]+offset, n=xfer_size.x; n>0; n-=4, dp+=4)

	mov	eax, DWORD PTR _buf16$1$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	add	eax, esi
	test	ecx, ecx
	jle	SHORT $LN14@do_job
	dec	ecx
	shr	ecx, 2
	inc	ecx
$LL19@do_job:

; 566  :                   { dp[0].ival=0; dp[1].ival=0; dp[2].ival=0; dp[3].ival=0;}

	xor	edi, edi
	lea	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [eax-8], edi
	mov	DWORD PTR [eax-4], edi
	sub	ecx, 1
	jne	SHORT $LL19@do_job
	mov	ecx, DWORD PTR _xfer_size$1$[ebp]
$LN14@do_job:

; 562  :             { // 16-bit samples
; 563  :               kdu_sample16 *dp;
; 564  :               for (m=0; m < xfer_size.y; m++)

	inc	edx
	cmp	edx, ebx
	jl	SHORT $LL16@do_job

; 567  :             }
; 568  :         }
; 569  :       else

	jmp	$LN184@do_job
$LN75@do_job:

; 570  :         { // Need to dequantize and/or convert quantization indices.
; 571  :           if (K_max_prime > K_max)

	mov	ax, WORD PTR [edi+14]
	cmp	ax, WORD PTR [edi+12]
	jle	SHORT $LN81@do_job

; 572  :             adjust_roi_background(block);

	push	edx
	lea	ecx, DWORD PTR [edi-4]
	call	?adjust_roi_background@kd_decoder@@AAEXPAUkdu_block@@@Z ; kd_decoder::adjust_roi_background
	mov	edx, DWORD PTR _block$1$[ebp]
$LN81@do_job:

; 573  :           int row_gap = block->size.x;

	mov	ebx, DWORD PTR [edx+4]

; 574  :           kdu_int32 *spp = block->sample_buffer + block->region.pos.y*row_gap;

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+108]
	imul	ecx, ebx

; 575  : #ifdef KDU_SIMD_OPTIMIZATIONS
; 576  :           if ((block->region.pos.x == 0) && (row_gap == xfer_size.x) &&
; 577  :               ((xfer_size.x == 32) || (xfer_size.x == 64)) &&
; 578  :               (!(block->vflip | block->hflip | block->transpose)) &&
; 579  :               (buf16 != NULL) &&

	cmp	DWORD PTR [edx+12], 0
	mov	DWORD PTR _row_gap$1$[ebp], ebx
	lea	esi, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _xfer_size$1$[ebp]
	jne	SHORT $LN82@do_job
	cmp	ebx, ecx
	jne	SHORT $LN82@do_job
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN83@do_job
	cmp	ecx, 64					; 00000040H
	jne	SHORT $LN82@do_job
$LN83@do_job:
	mov	al, BYTE PTR [edx+26]
	or	al, BYTE PTR [edx+25]
	or	al, BYTE PTR [edx+24]
	jne	SHORT $LN82@do_job
	cmp	DWORD PTR _buf16$1$[ebp], 0
	je	SHORT $LN82@do_job
	movss	xmm0, DWORD PTR [edi+20]
	movsx	eax, WORD PTR [edi+12]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	eax
	movzx	eax, BYTE PTR [edi+16]
	push	eax
	push	DWORD PTR _m$10$[ebp]
	push	ecx
	push	DWORD PTR _offset$1$[ebp]
	push	DWORD PTR _buf16$1$[ebp]
	push	esi
	call	?simd_xfer_decoded_block@@YA_NPAHPAPATkdu_sample16@@HHH_NHM@Z ; simd_xfer_decoded_block
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN267@do_job

; 580  :               simd_xfer_decoded_block(spp,buf16,offset,xfer_size.x,
; 581  :                                       xfer_size.y,reversible,K_max,delta))
; 582  :             {
; 583  :               band.close_block(block,env);

	mov	eax, DWORD PTR _ent$[ebp]
	lea	ecx, DWORD PTR [edi+8]
	push	eax
	push	DWORD PTR _block$1$[ebp]
	call	?close_block@kdu_subband@@QAEXPAUkdu_block@@PAVkdu_thread_env@@@Z ; kdu_subband::close_block

; 584  :               continue;

	jmp	$LN2@do_job
$LN267@do_job:
	mov	ecx, DWORD PTR _xfer_size$1$[ebp]
	mov	edx, DWORD PTR _block$1$[ebp]
$LN82@do_job:

; 585  :             }
; 586  : #endif // KDU_SIMD_OPTIMIZATIONS
; 587  :           spp += block->region.pos.x;

	mov	eax, DWORD PTR [edx+12]

; 588  :           kdu_int32 *sp;
; 589  :           int m_start = 0, m_inc = 1, n_start=offset, n_inc = 1;

	mov	edi, DWORD PTR _offset$1$[ebp]
	lea	eax, DWORD PTR [esi+eax*4]
	mov	esi, 1
	mov	DWORD PTR _spp$2$[ebp], eax
	xor	eax, eax
	mov	DWORD PTR _n_inc$1$[ebp], esi

; 590  :           if (block->vflip)

	cmp	BYTE PTR [edx+25], al
	je	SHORT $LN84@do_job

; 591  :             { m_start += xfer_size.y-1; m_inc = -1; }

	mov	eax, DWORD PTR _m$10$[ebp]
	dec	eax
	or	esi, -1
$LN84@do_job:

; 592  :           if (block->hflip)

	cmp	BYTE PTR [edx+26], 0
	je	SHORT $LN85@do_job

; 593  :             { n_start += xfer_size.x-1; n_inc = -1; }

	mov	edi, DWORD PTR _offset$1$[ebp]
	dec	edi
	mov	DWORD PTR _n_inc$1$[ebp], -1
	add	edi, ecx
$LN85@do_job:

; 594  :           if (buf32 != NULL)

	mov	ecx, DWORD PTR _buf32$1$[ebp]
	test	ecx, ecx
	je	$LN86@do_job

; 595  :             { // Need to generate 32-bit dequantized values.
; 596  :               kdu_sample32 *dp, **dpp = buf32+m_start;        

	lea	edx, DWORD PTR [ecx+eax*4]

; 597  :               if (reversible)

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _dpp$1$[ebp], edx
	cmp	BYTE PTR [eax+16], 0
	je	$LN88@do_job

; 598  :                 { // Output is 32-bit absolute integers.
; 599  :                   kdu_int32 val;
; 600  :                   kdu_int32 downshift = 31-K_max;

	movsx	eax, WORD PTR [eax+12]
	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	mov	DWORD PTR _downshift$1$[ebp], ecx

; 601  :                   if (downshift < 0)

	jns	SHORT $LN90@do_job

; 602  :                     { KDU_ERROR(e,0); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0FA@ENJPJF@Insufficient?5implementation?5prec@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 602  :                     { KDU_ERROR(e,0); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 605  :                     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	mov	edx, DWORD PTR _dpp$1$[ebp]
$LN90@do_job:

; 606  :                   if (!block->transpose)

	mov	eax, DWORD PTR _block$1$[ebp]
	cmp	BYTE PTR [eax+24], 0
	jne	$LN91@do_job

; 607  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp+=row_gap)

	cmp	DWORD PTR _m$10$[ebp], 0
	je	$LN184@do_job
	mov	edx, DWORD PTR _m$10$[ebp]
	lea	ebx, DWORD PTR [edi*4]
	mov	edi, DWORD PTR _spp$2$[ebp]
	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR tv1408[ebp], ebx
	mov	DWORD PTR tv1400[ebp], eax
$LL22@do_job:
	dec	edx

; 608  :                       for (dp=(*dpp)+n_start, sp=spp,

	mov	esi, edi
	mov	edi, DWORD PTR _xfer_size$1$[ebp]
	mov	DWORD PTR _m$10$[ebp], edx
	mov	edx, DWORD PTR _dpp$1$[ebp]
	mov	edx, DWORD PTR [edx]
	add	edx, ebx

; 609  :                            n=xfer_size.x; n--; sp++, dp+=n_inc)

	test	edi, edi
	je	SHORT $LN154@do_job
	mov	eax, DWORD PTR _n_inc$1$[ebp]
	lea	ebx, DWORD PTR [eax*4]
$LL25@do_job:

; 610  :                         {
; 611  :                           val = *sp;

	mov	eax, DWORD PTR [esi]
	dec	edi

; 612  :                           if (val < 0)

	test	eax, eax
	jns	SHORT $LN93@do_job

; 613  :                             dp->ival = -((val & KDU_INT32_MAX) >> downshift);

	and	eax, 2147483647				; 7fffffffH
	sar	eax, cl
	neg	eax

; 614  :                           else

	jmp	SHORT $LN276@do_job
$LN93@do_job:

; 615  :                             dp->ival = val >> downshift;

	sar	eax, cl
$LN276@do_job:
	mov	DWORD PTR [edx], eax
	add	esi, 4
	add	edx, ebx
	test	edi, edi
	jne	SHORT $LL25@do_job
	mov	eax, DWORD PTR tv1400[ebp]
	mov	ebx, DWORD PTR tv1408[ebp]
$LN154@do_job:

; 607  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp+=row_gap)

	mov	esi, DWORD PTR _row_gap$1$[ebp]
	mov	edi, DWORD PTR _spp$2$[ebp]
	add	DWORD PTR _dpp$1$[ebp], eax
	lea	edx, DWORD PTR [esi*4]
	add	edi, edx
	mov	edx, DWORD PTR _m$10$[ebp]
	mov	DWORD PTR _spp$2$[ebp], edi
	test	edx, edx
	jne	SHORT $LL22@do_job

; 616  :                         }
; 617  :                   else

	jmp	$LN184@do_job
$LN91@do_job:

; 618  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp++)

	cmp	DWORD PTR _m$10$[ebp], 0
	je	$LN184@do_job
	lea	ebx, DWORD PTR [edi*4]
	mov	edi, DWORD PTR _m$10$[ebp]
	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR tv1407[ebp], ebx
	mov	esi, DWORD PTR _spp$2$[ebp]
	mov	DWORD PTR tv1399[ebp], eax
	npad	2
$LL28@do_job:

; 619  :                       for (dp=(*dpp)+n_start, sp=spp,

	mov	edx, DWORD PTR [edx]
	dec	edi
	mov	DWORD PTR _m$10$[ebp], edi
	add	edx, ebx
	mov	edi, DWORD PTR _xfer_size$1$[ebp]

; 620  :                            n=xfer_size.x; n--; sp+=row_gap, dp+=n_inc)

	test	edi, edi
	je	SHORT $LN158@do_job
	mov	eax, DWORD PTR _row_gap$1$[ebp]
	lea	ebx, DWORD PTR [eax*4]
	npad	7
$LL31@do_job:

; 621  :                         {
; 622  :                           val = *sp;

	mov	eax, DWORD PTR [esi]
	dec	edi

; 623  :                           if (val < 0)

	test	eax, eax
	jns	SHORT $LN95@do_job

; 624  :                             dp->ival = -((val & KDU_INT32_MAX) >> downshift);

	and	eax, 2147483647				; 7fffffffH
	sar	eax, cl
	neg	eax

; 625  :                           else

	jmp	SHORT $LN277@do_job
$LN95@do_job:

; 626  :                             dp->ival = val >> downshift;

	sar	eax, cl
$LN277@do_job:

; 620  :                            n=xfer_size.x; n--; sp+=row_gap, dp+=n_inc)

	mov	ecx, DWORD PTR _n_inc$1$[ebp]
	add	esi, ebx

; 626  :                             dp->ival = val >> downshift;

	mov	DWORD PTR [edx], eax
	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	add	edx, eax
	test	edi, edi
	jne	SHORT $LL31@do_job
	mov	eax, DWORD PTR tv1399[ebp]
	mov	ebx, DWORD PTR tv1407[ebp]
$LN158@do_job:

; 618  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp++)

	mov	edx, DWORD PTR _dpp$1$[ebp]
	mov	esi, DWORD PTR _spp$2$[ebp]
	add	edx, eax
	mov	edi, DWORD PTR _m$10$[ebp]
	add	esi, 4
	mov	DWORD PTR _dpp$1$[ebp], edx
	mov	DWORD PTR _spp$2$[ebp], esi
	test	edi, edi
	jne	SHORT $LL28@do_job

; 627  :                         }
; 628  :                 }
; 629  :               else

	jmp	$LN184@do_job
$LN88@do_job:

; 630  :                 { // Output is true floating point values.
; 631  :                   kdu_int32 val;
; 632  :                   float scale = delta;

	movss	xmm1, DWORD PTR [eax+20]

; 633  :                   if (K_max <= 31)

	movzx	eax, WORD PTR [eax+12]
	cmp	ax, 31					; 0000001fH
	jg	SHORT $LN97@do_job

; 634  :                     scale /= (float)(1<<(31-K_max));

	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0

; 635  :                   else

	jmp	SHORT $LN98@do_job
$LN97@do_job:

; 636  :                     scale *= (float)(1<<(K_max-31)); // Can't decode all planes

	lea	ecx, DWORD PTR [eax-31]
	mov	eax, 1
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm1, xmm0
$LN98@do_job:

; 637  :                   if (!block->transpose)

	mov	eax, DWORD PTR _block$1$[ebp]
	cmp	BYTE PTR [eax+24], 0
	jne	$LN99@do_job

; 638  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp+=row_gap)

	cmp	DWORD PTR _m$10$[ebp], 0
	je	$LN184@do_job
	mov	eax, DWORD PTR _row_gap$1$[ebp]
	lea	ecx, DWORD PTR [edi*4]
	mov	edi, DWORD PTR _xfer_size$1$[ebp]
	lea	ebx, DWORD PTR [esi*4]
	mov	esi, DWORD PTR _m$10$[ebp]
	shl	eax, 2
	mov	DWORD PTR tv1406[ebp], ecx
	mov	DWORD PTR tv1390[ebp], eax
$LL34@do_job:
	dec	esi
	mov	DWORD PTR _m$10$[ebp], esi

; 639  :                       for (dp=(*dpp)+n_start, sp=spp,

	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR _spp$2$[ebp]
	add	esi, ecx
	mov	ecx, edi

; 640  :                            n=xfer_size.x; n--; sp++, dp+=n_inc)

	test	edi, edi
	je	SHORT $LN162@do_job
	mov	eax, DWORD PTR _n_inc$1$[ebp]
	lea	edi, DWORD PTR [eax*4]
	npad	1
$LL37@do_job:

; 641  :                         {
; 642  :                           val = *sp;

	mov	eax, DWORD PTR [edx]
	dec	ecx

; 643  :                           if (val < 0)

	test	eax, eax
	jns	SHORT $LN101@do_job

; 644  :                             val = -(val & KDU_INT32_MAX);

	and	eax, 2147483647				; 7fffffffH
	neg	eax
$LN101@do_job:

; 640  :                            n=xfer_size.x; n--; sp++, dp+=n_inc)

	movd	xmm0, eax
	add	edx, 4

; 645  :                           dp->fval = scale * val;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0
	add	esi, edi
	test	ecx, ecx
	jne	SHORT $LL37@do_job
	mov	eax, DWORD PTR tv1390[ebp]
	mov	edi, DWORD PTR _xfer_size$1$[ebp]
$LN162@do_job:

; 638  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp+=row_gap)

	mov	edx, DWORD PTR _dpp$1$[ebp]
	add	DWORD PTR _spp$2$[ebp], eax
	add	edx, ebx
	mov	esi, DWORD PTR _m$10$[ebp]
	mov	ecx, DWORD PTR tv1406[ebp]
	mov	DWORD PTR _dpp$1$[ebp], edx
	test	esi, esi
	jne	SHORT $LL34@do_job

; 646  :                         }
; 647  :                   else

	jmp	$LN184@do_job
$LN99@do_job:

; 648  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp++)

	cmp	DWORD PTR _m$10$[ebp], 0
	je	$LN184@do_job
	lea	ecx, DWORD PTR [edi*4]
	mov	edi, DWORD PTR _xfer_size$1$[ebp]
	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR tv1405[ebp], ecx
	mov	esi, DWORD PTR _m$10$[ebp]
	mov	DWORD PTR tv1397[ebp], eax
	npad	6
$LL40@do_job:
	dec	esi
	mov	DWORD PTR _m$10$[ebp], esi

; 649  :                       for (dp=(*dpp)+n_start, sp=spp,

	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR _spp$2$[ebp]
	add	esi, ecx
	mov	ecx, edi

; 650  :                            n=xfer_size.x; n--; sp+=row_gap, dp+=n_inc)

	test	edi, edi
	je	SHORT $LN166@do_job
	mov	eax, DWORD PTR _n_inc$1$[ebp]
	lea	edi, DWORD PTR [ebx*4]
	lea	ebx, DWORD PTR [eax*4]
$LL43@do_job:

; 651  :                         {
; 652  :                           val = *sp;

	mov	eax, DWORD PTR [edx]
	dec	ecx

; 653  :                           if (val < 0)

	test	eax, eax
	jns	SHORT $LN102@do_job

; 654  :                             val = -(val & KDU_INT32_MAX);

	and	eax, 2147483647				; 7fffffffH
	neg	eax
$LN102@do_job:

; 650  :                            n=xfer_size.x; n--; sp+=row_gap, dp+=n_inc)

	movd	xmm0, eax
	add	edx, edi

; 655  :                           dp->fval = scale * val;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0
	add	esi, ebx
	test	ecx, ecx
	jne	SHORT $LL43@do_job
	mov	eax, DWORD PTR tv1397[ebp]
	mov	ebx, DWORD PTR _row_gap$1$[ebp]
	mov	edi, DWORD PTR _xfer_size$1$[ebp]
$LN166@do_job:

; 648  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp++)

	mov	edx, DWORD PTR _dpp$1$[ebp]
	add	DWORD PTR _spp$2$[ebp], 4
	add	edx, eax
	mov	esi, DWORD PTR _m$10$[ebp]
	mov	ecx, DWORD PTR tv1405[ebp]
	mov	DWORD PTR _dpp$1$[ebp], edx
	test	esi, esi
	jne	SHORT $LL40@do_job

; 656  :                         }
; 657  :                 }
; 658  :             }
; 659  :           else

	jmp	$LN184@do_job
$LN86@do_job:

; 660  :             { // Need to produce 16-bit dequantized values.
; 661  :               kdu_sample16 *dp, **dpp = buf16+m_start;        

	mov	ecx, DWORD PTR _buf16$1$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]

; 662  :               if (reversible)

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _dpp$1$[ebp], edx
	cmp	BYTE PTR [eax+16], 0
	je	$LN103@do_job

; 663  :                 { // Output is 16-bit absolute integers.
; 664  :                   kdu_int32 val;
; 665  :                   kdu_int32 downshift = 31-K_max;

	movsx	eax, WORD PTR [eax+12]
	mov	ecx, 31					; 0000001fH
	sub	ecx, eax

; 666  :                   assert(downshift >= 0); // Otherwise should be using 32 bits.
; 667  :                   if (!block->transpose)

	mov	eax, DWORD PTR _block$1$[ebp]
	mov	DWORD PTR _downshift$1$[ebp], ecx
	cmp	BYTE PTR [eax+24], 0
	jne	$LN105@do_job

; 668  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp+=row_gap)

	cmp	DWORD PTR _m$10$[ebp], 0
	je	$LN184@do_job
	mov	edx, DWORD PTR _m$10$[ebp]
	lea	ebx, DWORD PTR [edi+edi]
	mov	edi, DWORD PTR _spp$2$[ebp]
	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR tv1384[ebp], ebx
	mov	DWORD PTR tv1396[ebp], eax
	npad	4
$LL46@do_job:
	dec	edx

; 669  :                       for (dp=(*dpp)+n_start, sp=spp,

	mov	esi, edi
	mov	edi, DWORD PTR _xfer_size$1$[ebp]
	mov	DWORD PTR _m$10$[ebp], edx
	mov	edx, DWORD PTR _dpp$1$[ebp]
	mov	edx, DWORD PTR [edx]
	add	edx, ebx

; 670  :                            n=xfer_size.x; n--; sp++, dp+=n_inc)

	test	edi, edi
	je	SHORT $LN170@do_job
	mov	eax, DWORD PTR _n_inc$1$[ebp]
	lea	ebx, DWORD PTR [eax+eax]
	npad	6
$LL49@do_job:

; 671  :                         {
; 672  :                           val = *sp;

	mov	eax, DWORD PTR [esi]
	dec	edi

; 673  :                           if (val < 0)

	test	eax, eax
	jns	SHORT $LN107@do_job

; 674  :                             dp->ival = (kdu_int16)

	and	eax, 2147483647				; 7fffffffH
	sar	eax, cl
	neg	eax

; 675  :                               -((val & KDU_INT32_MAX) >> downshift);
; 676  :                           else

	jmp	SHORT $LN278@do_job
$LN107@do_job:

; 677  :                             dp->ival = (kdu_int16)(val >> downshift);

	sar	eax, cl
$LN278@do_job:
	mov	WORD PTR [edx], ax
	add	esi, 4
	add	edx, ebx
	test	edi, edi
	jne	SHORT $LL49@do_job
	mov	eax, DWORD PTR tv1396[ebp]
	mov	ebx, DWORD PTR tv1384[ebp]
$LN170@do_job:

; 668  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp+=row_gap)

	mov	esi, DWORD PTR _row_gap$1$[ebp]
	mov	edi, DWORD PTR _spp$2$[ebp]
	add	DWORD PTR _dpp$1$[ebp], eax
	lea	edx, DWORD PTR [esi*4]
	add	edi, edx
	mov	edx, DWORD PTR _m$10$[ebp]
	mov	DWORD PTR _spp$2$[ebp], edi
	test	edx, edx
	jne	SHORT $LL46@do_job

; 678  :                         }
; 679  :                   else

	jmp	$LN184@do_job
$LN105@do_job:

; 680  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp++)

	cmp	DWORD PTR _m$10$[ebp], 0
	je	$LN184@do_job
	lea	ebx, DWORD PTR [edi+edi]
	mov	edi, DWORD PTR _m$10$[ebp]
	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR tv1383[ebp], ebx
	mov	esi, DWORD PTR _spp$2$[ebp]
	mov	DWORD PTR tv1395[ebp], eax
$LL52@do_job:

; 681  :                       for (dp=(*dpp)+n_start, sp=spp,

	mov	edx, DWORD PTR [edx]
	dec	edi
	mov	DWORD PTR _m$10$[ebp], edi
	add	edx, ebx
	mov	edi, DWORD PTR _xfer_size$1$[ebp]

; 682  :                            n=xfer_size.x; n--; sp+=row_gap, dp+=n_inc)

	test	edi, edi
	je	SHORT $LN174@do_job
	mov	eax, DWORD PTR _row_gap$1$[ebp]
	lea	ebx, DWORD PTR [eax*4]
$LL55@do_job:

; 683  :                         {
; 684  :                           val = *sp;

	mov	eax, DWORD PTR [esi]
	dec	edi

; 685  :                           if (val < 0)

	test	eax, eax
	jns	SHORT $LN109@do_job

; 686  :                             dp->ival = (kdu_int16)

	and	eax, 2147483647				; 7fffffffH
	sar	eax, cl
	neg	eax

; 687  :                               -((val & KDU_INT32_MAX) >> downshift);
; 688  :                           else

	jmp	SHORT $LN279@do_job
$LN109@do_job:

; 689  :                             dp->ival = (kdu_int16)(val >> downshift);

	sar	eax, cl
$LN279@do_job:

; 682  :                            n=xfer_size.x; n--; sp+=row_gap, dp+=n_inc)

	mov	ecx, DWORD PTR _n_inc$1$[ebp]
	add	esi, ebx

; 689  :                             dp->ival = (kdu_int16)(val >> downshift);

	mov	WORD PTR [edx], ax
	lea	edx, DWORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	test	edi, edi
	jne	SHORT $LL55@do_job
	mov	eax, DWORD PTR tv1395[ebp]
	mov	ebx, DWORD PTR tv1383[ebp]
$LN174@do_job:

; 680  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp++)

	mov	edx, DWORD PTR _dpp$1$[ebp]
	mov	esi, DWORD PTR _spp$2$[ebp]
	add	edx, eax
	mov	edi, DWORD PTR _m$10$[ebp]
	add	esi, 4
	mov	DWORD PTR _dpp$1$[ebp], edx
	mov	DWORD PTR _spp$2$[ebp], esi
	test	edi, edi
	jne	SHORT $LL52@do_job

; 690  :                         }
; 691  :                 }
; 692  :               else

	jmp	$LN184@do_job
$LN103@do_job:

; 693  :                 { // Output is 16-bit fixed point values.
; 694  :                   float fscale = delta * (float)(1<<KDU_FIX_POINT);

	movss	xmm1, DWORD PTR [eax+20]

; 695  :                   if (K_max <= 31)

	movzx	eax, WORD PTR [eax+12]
	mulss	xmm1, DWORD PTR __real@46000000
	cmp	ax, 31					; 0000001fH
	jg	SHORT $LN111@do_job

; 696  :                     fscale /= (float)(1<<(31-K_max));

	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0

; 697  :                   else

	jmp	SHORT $LN112@do_job
$LN111@do_job:

; 698  :                     fscale *= (float)(1<<(K_max-31));

	lea	ecx, DWORD PTR [eax-31]
	mov	eax, 1
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm1, xmm0
$LN112@do_job:

; 699  :                   fscale *= (float)(1<<16) * (float)(1<<16);

	mulss	xmm1, DWORD PTR __real@4f800000

; 700  :                   kdu_int32 val, scale = ((kdu_int32)(fscale+0.5F));

	addss	xmm1, DWORD PTR __real@3f000000
	cvttss2si eax, xmm1
	mov	DWORD PTR _scale$1$[ebp], eax

; 701  :                   if (!block->transpose)

	mov	eax, DWORD PTR _block$1$[ebp]
	cmp	BYTE PTR [eax+24], 0
	jne	$LN113@do_job

; 702  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp+=row_gap)

	cmp	DWORD PTR _m$10$[ebp], 0
	je	$LN184@do_job
	mov	eax, DWORD PTR _row_gap$1$[ebp]
	lea	ecx, DWORD PTR [edi+edi]
	mov	edi, DWORD PTR _xfer_size$1$[ebp]
	lea	ebx, DWORD PTR [esi*4]
	mov	esi, DWORD PTR _m$10$[ebp]
	shl	eax, 2
	mov	DWORD PTR tv1382[ebp], ecx
	mov	DWORD PTR tv1386[ebp], eax
	npad	6
$LL58@do_job:
	dec	esi
	mov	DWORD PTR _m$10$[ebp], esi

; 703  :                       for (dp=(*dpp)+n_start, sp=spp,

	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR _spp$2$[ebp]
	add	esi, ecx
	mov	ecx, edi

; 704  :                            n=xfer_size.x; n--; sp++, dp+=n_inc)

	test	edi, edi
	je	SHORT $LN178@do_job
	mov	eax, DWORD PTR _n_inc$1$[ebp]
	lea	edi, DWORD PTR [eax+eax]
$LL61@do_job:

; 705  :                         {
; 706  :                           val = *sp;

	mov	eax, DWORD PTR [edx]
	dec	ecx

; 707  :                           if (val < 0)

	test	eax, eax
	jns	SHORT $LN115@do_job

; 708  :                             val = -(val & KDU_INT32_MAX);

	and	eax, 2147483647				; 7fffffffH
	neg	eax
$LN115@do_job:

; 709  :                           val = (val+(1<<15))>>16; val *= scale;

	add	eax, 32768				; 00008000H
	add	edx, 4
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scale$1$[ebp]

; 710  :                           dp->ival = (kdu_int16)((val+(1<<15))>>16);

	add	eax, 32768				; 00008000H
	sar	eax, 16					; 00000010H
	mov	WORD PTR [esi], ax
	add	esi, edi
	test	ecx, ecx
	jne	SHORT $LL61@do_job
	mov	eax, DWORD PTR tv1386[ebp]
	mov	edi, DWORD PTR _xfer_size$1$[ebp]
$LN178@do_job:

; 702  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp+=row_gap)

	mov	edx, DWORD PTR _dpp$1$[ebp]
	add	DWORD PTR _spp$2$[ebp], eax
	add	edx, ebx
	mov	esi, DWORD PTR _m$10$[ebp]
	mov	ecx, DWORD PTR tv1382[ebp]
	mov	DWORD PTR _dpp$1$[ebp], edx
	test	esi, esi
	jne	SHORT $LL58@do_job

; 711  :                         }
; 712  :                   else

	jmp	$LN184@do_job
$LN113@do_job:

; 713  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp++)

	cmp	DWORD PTR _m$10$[ebp], 0
	je	$LN184@do_job
	lea	ecx, DWORD PTR [edi+edi]
	mov	edi, DWORD PTR _xfer_size$1$[ebp]
	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR tv1381[ebp], ecx
	mov	esi, DWORD PTR _m$10$[ebp]
	mov	DWORD PTR tv1393[ebp], eax
$LL64@do_job:
	dec	esi
	mov	DWORD PTR _m$10$[ebp], esi

; 714  :                       for (dp=(*dpp)+n_start, sp=spp,

	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR _spp$2$[ebp]
	add	esi, ecx
	mov	ecx, edi

; 715  :                            n=xfer_size.x; n--; sp+=row_gap, dp+=n_inc)

	test	edi, edi
	je	SHORT $LN182@do_job
	mov	eax, DWORD PTR _n_inc$1$[ebp]
	lea	edi, DWORD PTR [ebx*4]
	lea	ebx, DWORD PTR [eax+eax]
$LL67@do_job:

; 716  :                         {
; 717  :                           val = *sp;

	mov	eax, DWORD PTR [edx]
	dec	ecx

; 718  :                           if (val < 0)

	test	eax, eax
	jns	SHORT $LN116@do_job

; 719  :                             val = -(val & KDU_INT32_MAX);

	and	eax, 2147483647				; 7fffffffH
	neg	eax
$LN116@do_job:

; 720  :                           val = (val+(1<<15))>>16; val *= scale;

	add	eax, 32768				; 00008000H
	add	edx, edi
	sar	eax, 16					; 00000010H
	imul	eax, DWORD PTR _scale$1$[ebp]

; 721  :                           dp->ival = (kdu_int16)((val+(1<<15))>>16);

	add	eax, 32768				; 00008000H
	sar	eax, 16					; 00000010H
	mov	WORD PTR [esi], ax
	add	esi, ebx
	test	ecx, ecx
	jne	SHORT $LL67@do_job
	mov	eax, DWORD PTR tv1393[ebp]
	mov	ebx, DWORD PTR _row_gap$1$[ebp]
	mov	edi, DWORD PTR _xfer_size$1$[ebp]
$LN182@do_job:

; 713  :                     for (m=xfer_size.y; m--; dpp+=m_inc, spp++)

	mov	edx, DWORD PTR _dpp$1$[ebp]
	add	DWORD PTR _spp$2$[ebp], 4
	add	edx, eax
	mov	esi, DWORD PTR _m$10$[ebp]
	mov	ecx, DWORD PTR tv1381[ebp]
	mov	DWORD PTR _dpp$1$[ebp], edx
	test	esi, esi
	jne	SHORT $LL64@do_job
$LN184@do_job:

; 722  :                         }
; 723  :                 }
; 724  :             }
; 725  :         }
; 726  :       band.close_block(block,env);

	mov	eax, DWORD PTR _ent$[ebp]
	mov	ecx, DWORD PTR tv1417[ebp]
	push	eax
	push	DWORD PTR _block$1$[ebp]
	call	?close_block@kdu_subband@@QAEXPAUkdu_block@@PAVkdu_thread_env@@@Z ; kdu_subband::close_block
	mov	edi, DWORD PTR _this$1$[ebp]
$LN2@do_job:

; 524  :             (skip_blocks-1) * (int) nominal_block_width;
; 525  :         }
; 526  :     }
; 527  : 
; 528  :   // Now scan through the blocks to process
; 529  :   kdu_coords xfer_size;
; 530  :   kdu_block *block;
; 531  : 
; 532  :   for (; blocks_remaining > 0; blocks_remaining--,

	mov	ebx, DWORD PTR _blocks_remaining$1$[ebp]
	lea	eax, DWORD PTR [edi+8]

; 533  :        idx.x++, offset+=xfer_size.x)

	mov	edx, DWORD PTR _idx$2$[ebp]
	dec	ebx
	mov	esi, DWORD PTR _offset$1$[ebp]
	inc	edx
	add	esi, DWORD PTR _xfer_size$1$[ebp]
	mov	DWORD PTR _blocks_remaining$1$[ebp], ebx
	mov	DWORD PTR _idx$2$[ebp], edx
	mov	DWORD PTR _offset$1$[ebp], esi
	test	ebx, ebx
	jg	$LL4@do_job
$LN3@do_job:

; 727  :     }
; 728  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_job@kd_decoder@@EAEXPAVkdu_thread_entity@@H@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?do_job@kd_decoder@@EAEXPAVkdu_thread_entity@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_job@kd_decoder@@EAEXPAVkdu_thread_entity@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_job@kd_decoder@@EAEXPAVkdu_thread_entity@@H@Z ENDP	; kd_decoder::do_job
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
;	COMDAT ?pull@kd_decoder@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_line$ = 8						; size = 4
_env$ = 12						; size = 4
?pull@kd_decoder@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z PROC ; kd_decoder::pull, COMDAT
; _this$ = ecx

; 406  : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 407  :   assert((queue == NULL) || (env != NULL));
; 408  :   if (line.get_width() <= pull_offset)

	mov	ebx, DWORD PTR _line$[ebp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR [esi+84]
	jle	$LN18@pull

; 409  :     return;
; 410  : 
; 411  :   if (!initialized)

	cmp	BYTE PTR [esi+21], 0
	push	edi
	mov	edi, DWORD PTR _env$[ebp]
	jne	SHORT $LN3@pull

; 412  :     start(env);

	mov	eax, DWORD PTR [esi]
	push	edi
	call	DWORD PTR [eax+4]
$LN3@pull:

; 413  : 
; 414  :   assert(subband_rows > 0);
; 415  :   if (next_buffered_line == buffered_line_lim)

	movzx	ecx, WORD PTR [esi+66]
	cmp	WORD PTR [esi+64], cx
	jne	$LN4@pull

; 416  :     { // Perform block decoding (or wait until it is done) as required
; 417  :       next_buffered_line = 0;
; 418  :       if (queue != NULL)

	mov	edx, DWORD PTR [esi+88]
	xor	eax, eax
	mov	WORD PTR [esi+64], ax
	test	edx, edx
	je	SHORT $LN5@pull

; 419  :         {
; 420  :           if (secondary_seq != 0)

	movzx	eax, WORD PTR [esi+52]
	test	ax, ax
	je	SHORT $LN10@pull

; 421  :             { // Double buffering in use
; 422  :               assert(buffer_height > nominal_block_height);
; 423  :               if (next_pull_block_row == 0)

	cmp	DWORD PTR [esi+68], 0
	jne	SHORT $LN8@pull

; 424  :                 { // `start' created jobs for bank 0; add bank 1 jobs here.
; 425  :                   bool finalize = (subband_rows <= (int)

	movsx	ecx, WORD PTR [esi+60]

; 426  :                                    (first_block_height+nominal_block_height));
; 427  :                   env->add_jobs(queue,num_jobs_per_row,finalize,secondary_seq);

	push	eax
	movsx	eax, WORD PTR [esi+56]
	add	ecx, eax
	cmp	DWORD PTR [esi+44], ecx
	mov	ecx, edi
	setle	al
	movzx	eax, al
	push	eax
	movzx	eax, BYTE PTR [esi+23]
	push	eax
	push	edx
	call	?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z ; kdu_thread_entity::add_jobs

; 431  :             }
; 432  :           env->process_jobs(queue); // Waits for primary jobs.

	push	1
	push	0
	push	DWORD PTR [esi+88]
	mov	ecx, edi
	call	?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z ; kdu_thread_entity::process_jobs

; 433  :         }
; 434  :       else

	jmp	SHORT $LN6@pull
$LN8@pull:

; 428  :                 }
; 429  :               else if (buffered_line_lim <= nominal_block_height)

	movzx	eax, WORD PTR [esi+60]
	cmp	cx, ax
	jg	SHORT $LN10@pull

; 430  :                 next_buffered_line = nominal_block_height;

	mov	WORD PTR [esi+64], ax
$LN10@pull:

; 431  :             }
; 432  :           env->process_jobs(queue); // Waits for primary jobs.

	push	1
	push	0
	push	DWORD PTR [esi+88]
	mov	ecx, edi
	call	?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z ; kdu_thread_entity::process_jobs

; 433  :         }
; 434  :       else

	jmp	SHORT $LN6@pull
$LN5@pull:

; 435  :         {
; 436  :           assert(num_jobs_per_row == 1);
; 437  :           do_job(env,next_pull_block_row);

	push	DWORD PTR [esi+68]
	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [esi+4]
	push	edi
	call	DWORD PTR [eax+4]
$LN6@pull:

; 438  :         }
; 439  :       if (next_pull_block_row == 0)

	mov	ecx, DWORD PTR [esi+68]
	test	ecx, ecx
	jne	SHORT $LN11@pull

; 440  :         buffered_line_lim = first_block_height;

	mov	ax, WORD PTR [esi+56]
	jmp	SHORT $LN36@pull
$LN11@pull:

; 441  :       else if (subband_rows < (int) nominal_block_height)

	movzx	edx, WORD PTR [esi+60]
	movsx	eax, dx
	cmp	DWORD PTR [esi+44], eax

; 442  :         buffered_line_lim = next_buffered_line + (kdu_int16) subband_rows;

	mov	ax, WORD PTR [esi+64]
	jge	SHORT $LN13@pull
	add	ax, WORD PTR [esi+44]

; 443  :       else

	jmp	SHORT $LN36@pull
$LN13@pull:

; 444  :         buffered_line_lim = next_buffered_line + nominal_block_height;

	add	ax, dx
$LN36@pull:
	mov	WORD PTR [esi+66], ax

; 445  :       assert(buffered_line_lim <= buffer_height);
; 446  :       next_pull_block_row++;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+68], eax
$LN4@pull:

; 447  :     }
; 448  : 
; 449  :   // Transfer data
; 450  :   assert(line.get_width() == (subband_cols+pull_offset));
; 451  :   if (lines32 != NULL)

	mov	edx, DWORD PTR [esi+80]
	test	edx, edx
	je	SHORT $LN15@pull
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ebx+6], 2
	je	SHORT $LN29@pull
	xor	ecx, ecx
	jmp	SHORT $LN30@pull
$LN29@pull:
	mov	ecx, DWORD PTR [ebx+8]
$LN30@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 452  :     memcpy(line.get_buf32()+pull_offset,lines32[next_buffered_line],

	mov	eax, DWORD PTR [esi+48]
	shl	eax, 2
	push	eax
	movsx	eax, WORD PTR [esi+64]
	push	DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [esi+84]
	lea	eax, DWORD PTR [ecx+eax*4]

; 453  :            (size_t)(subband_cols<<2));
; 454  :   else

	jmp	SHORT $LN37@pull
$LN15@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ebx+6], 2
	je	SHORT $LN33@pull
	mov	edx, DWORD PTR [ebx+8]
	jmp	SHORT $LN34@pull
$LN33@pull:
	xor	edx, edx
$LN34@pull:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 455  :     memcpy(line.get_buf16()+pull_offset,lines16[next_buffered_line],

	mov	eax, DWORD PTR [esi+48]
	movsx	ecx, WORD PTR [esi+64]
	add	eax, eax
	push	eax
	mov	eax, DWORD PTR [esi+76]
	push	DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [esi+84]
	lea	eax, DWORD PTR [edx+eax*2]
$LN37@pull:
	push	eax
	call	_memcpy

; 456  :            (size_t)(subband_cols<<1));
; 457  : 
; 458  :   // Finally, update the line buffer management state.
; 459  :   subband_rows--;

	dec	DWORD PTR [esi+44]
	add	esp, 12					; 0000000cH

; 460  :   next_buffered_line++;

	inc	WORD PTR [esi+64]

; 461  :   if ((queue == NULL)  || (next_buffered_line < buffered_line_lim))

	mov	edx, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+44]
	mov	ax, WORD PTR [esi+64]
	test	edx, edx
	je	SHORT $LN35@pull
	cmp	ax, WORD PTR [esi+66]
	jl	SHORT $LN35@pull

; 462  :     return;
; 463  : 
; 464  :   // We have finished with this memory bank; can use it to launch more jobs
; 465  :   if (subband_rows <= 0)

	test	ecx, ecx
	jle	SHORT $LN35@pull

; 466  :     return; // Should never actually be < 0.
; 467  :   if (secondary_seq != 0)

	movzx	eax, WORD PTR [esi+52]
	test	ax, ax
	je	SHORT $LN20@pull

; 468  :     { // Using double buffering within this subband
; 469  :       assert(buffer_height > nominal_block_height);
; 470  :       if (subband_rows <= (int) nominal_block_height)

	movsx	ebx, WORD PTR [esi+60]
	cmp	ecx, ebx
	jg	SHORT $LN22@pull

; 471  :         { // There are no more block rows to decode, but we need to promote
; 472  :           // any existing secondary jobs to the primary service state
; 473  :           env->add_jobs(queue,0,true);

	push	0
	push	1
	push	0

; 485  :       env->add_jobs(queue,num_jobs_per_row,finalize);

	push	edx
	mov	ecx, edi
	call	?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z ; kdu_thread_entity::add_jobs
	pop	edi
	pop	esi
	pop	ebx

; 486  :     }
; 487  : }

	pop	ebp
	ret	8
$LN22@pull:

; 474  :         }
; 475  :       else
; 476  :         { // Add a new set of block decoding jobs in the secondary service
; 477  :           // state, promoting the jobs we added last time to the primary state.
; 478  :           bool finalize = (subband_rows <= (int)(nominal_block_height<<1));
; 479  :           env->add_jobs(queue,num_jobs_per_row,finalize,secondary_seq);

	push	eax
	lea	eax, DWORD PTR [ebx+ebx]

; 480  :         }
; 481  :     }
; 482  :   else

	jmp	SHORT $LN39@pull
$LN20@pull:

; 483  :     { // Single-buffered; just add jobs in the primary service state.
; 484  :       bool finalize = (subband_rows <= (int)(nominal_block_height));

	movsx	eax, WORD PTR [esi+60]

; 485  :       env->add_jobs(queue,num_jobs_per_row,finalize);

	push	0
$LN39@pull:
	cmp	ecx, eax
	mov	ecx, edi
	setle	al
	movzx	eax, al
	push	eax
	movzx	eax, BYTE PTR [esi+23]
	push	eax
	push	edx
	call	?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z ; kdu_thread_entity::add_jobs
$LN35@pull:
	pop	edi
$LN18@pull:
	pop	esi
	pop	ebx

; 486  :     }
; 487  : }

	pop	ebp
	ret	8
?pull@kd_decoder@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z ENDP ; kd_decoder::pull
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
;	COMDAT ?start@kd_decoder@@MAEXPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_n$2$ = -4						; size = 4
_n$1$ = -4						; size = 4
$T1 = 8							; size = 4
_env$ = 8						; size = 4
?start@kd_decoder@@MAEXPAVkdu_thread_env@@@Z PROC	; kd_decoder::start, COMDAT
; _this$ = ecx

; 372  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 373  :   if (initialized || (subband_cols==0) || (subband_rows==0))

	cmp	BYTE PTR [esi+21], 0
	jne	$LN9@start
	cmp	DWORD PTR [esi+48], 0
	je	$LN9@start
	cmp	DWORD PTR [esi+44], 0
	je	$LN9@start

; 376  :       return;
; 377  :     }
; 378  : 
; 379  :   if (env != NULL)

	push	ebx
	mov	ebx, DWORD PTR _env$[ebp]
	push	edi
	test	ebx, ebx
	je	SHORT $LN17@start
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [ebx+28]
	cmp	BYTE PTR [eax], 0
	jne	$LN44@start
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN20@start
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN20@start:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+28], ebx
$LN17@start:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 383  :     for (n=0; n < buffer_height; n++)

	xor	eax, eax
	mov	DWORD PTR _n$1$[ebp], 0
	cmp	DWORD PTR [esi+76], eax
	je	SHORT $LN11@start
	cmp	ax, WORD PTR [esi+62]
	jge	$LN6@start
	npad	8
$LL4@start:

; 384  :       lines16[n] = allocator->alloc16(0,subband_cols+3+(int)alignment_offset)

	mov	ebx, DWORD PTR [esi+72]
	movzx	ecx, BYTE PTR [esi+22]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.

	mov	eax, DWORD PTR [esi+48]
	add	ecx, 10					; 0000000aH
	add	eax, ecx

; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	edx, DWORD PTR [ebx+8]
	and	eax, -8					; fffffff8H
	mov	edi, DWORD PTR [ebx+16]
	add	edi, edx
	lea	eax, DWORD PTR [edx+eax*2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 384  :       lines16[n] = allocator->alloc16(0,subband_cols+3+(int)alignment_offset)

	mov	edx, DWORD PTR _n$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	DWORD PTR [ebx+8], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 384  :       lines16[n] = allocator->alloc16(0,subband_cols+3+(int)alignment_offset)

	movzx	eax, BYTE PTR [esi+22]
	lea	ecx, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR [eax+edx*4], ecx
	inc	edx
	movsx	eax, WORD PTR [esi+62]
	mov	DWORD PTR _n$1$[ebp], edx
	cmp	edx, eax
	jl	SHORT $LL4@start

; 385  :                  + alignment_offset;
; 386  :   else

	jmp	SHORT $LN43@start
$LN11@start:

; 387  :     for (n=0; n < buffer_height; n++)

	cmp	ax, WORD PTR [esi+62]
	jge	SHORT $LN6@start
$LL7@start:

; 388  :       lines32[n] = allocator->alloc32(0,subband_cols+3+(int)alignment_offset)

	mov	ebx, DWORD PTR [esi+72]
	movzx	ecx, BYTE PTR [esi+22]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.

	mov	eax, DWORD PTR [esi+48]
	add	ecx, 6
	add	eax, ecx

; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	edx, DWORD PTR [ebx+8]
	and	eax, -4					; fffffffcH
	mov	edi, DWORD PTR [ebx+16]
	add	edi, edx
	lea	eax, DWORD PTR [edx+eax*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 388  :       lines32[n] = allocator->alloc32(0,subband_cols+3+(int)alignment_offset)

	mov	edx, DWORD PTR _n$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	DWORD PTR [ebx+8], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 388  :       lines32[n] = allocator->alloc32(0,subband_cols+3+(int)alignment_offset)

	movzx	eax, BYTE PTR [esi+22]
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [eax+edx*4], ecx
	inc	edx
	movsx	eax, WORD PTR [esi+62]
	mov	DWORD PTR _n$2$[ebp], edx
	cmp	edx, eax
	jl	SHORT $LL7@start
$LN43@start:
	mov	ebx, DWORD PTR _env$[ebp]
$LN6@start:

; 389  :                  + alignment_offset;
; 390  :   initialized = true;

	mov	BYTE PTR [esi+21], 1

; 391  :   if (env != NULL)

	test	ebx, ebx
	je	SHORT $LN41@start
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [ebx+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+28], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN31@start
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN31@start:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 394  :       bool finalize_queue = (subband_rows <= ((int) first_block_height));

	movsx	eax, WORD PTR [esi+56]

; 395  :       env->add_jobs(queue,num_jobs_per_row,finalize_queue);

	mov	ecx, ebx
	cmp	DWORD PTR [esi+44], eax
	push	0
	setle	al
	movzx	eax, al
	push	eax
	movzx	eax, BYTE PTR [esi+23]
	push	eax
	push	DWORD PTR [esi+88]
	call	?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z ; kdu_thread_entity::add_jobs
$LN41@start:
	pop	edi
	pop	ebx
	pop	esi

; 398  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN9@start:

; 374  :     {
; 375  :       initialized = true;

	mov	BYTE PTR [esi+21], 1
	pop	esi

; 398  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN44@start:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN46@start:
$LN42@start:
	int	3
?start@kd_decoder@@MAEXPAVkdu_thread_env@@@Z ENDP	; kd_decoder::start
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
;	COMDAT ??1kd_decoder@@MAE@XZ
_TEXT	SEGMENT
??1kd_decoder@@MAE@XZ PROC				; kd_decoder::~kd_decoder, COMDAT
; _this$ = ecx

; 359  : {

	push	esi
	mov	esi, ecx

; 360  :   if (lines16 != NULL)

	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR [esi], OFFSET ??_7kd_decoder@@6Bkdu_pull_ifc_base@@@
	mov	DWORD PTR [esi+4], OFFSET ??_7kd_decoder@@6Bkdu_worker@@@
	test	eax, eax
	je	SHORT $LN2@kd_decoder

; 361  :     delete[] lines16;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_decoder:

; 362  :   if (lines32 != NULL)

	mov	eax, DWORD PTR [esi+80]
	test	eax, eax
	je	SHORT $LN3@kd_decoder

; 363  :     delete[] lines32;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@kd_decoder:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h

; 180  :     ~kdu_block_decoder() { delete state; }

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN16@kd_decoder
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN16@kd_decoder:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 669  :     virtual ~kdu_pull_ifc_base() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_pull_ifc_base@@6B@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 106  :     virtual ~kdu_worker() { return; } // Prevent compiler warnings

	mov	DWORD PTR [esi+4], OFFSET ??_7kdu_worker@@6B@
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 364  : }

	ret	0
??1kd_decoder@@MAE@XZ ENDP				; kd_decoder::~kd_decoder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
;	COMDAT ?init@kd_decoder@@QAEXVkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
_TEXT	SEGMENT
_dims$ = -32						; size = 16
_nominal_block_size$ = -16				; size = 8
_first_block_size$ = -8					; size = 8
_band$ = 8						; size = 4
_allocator$ = 12					; size = 4
_use_shorts$ = 16					; size = 1
_block_row_samples$3$ = 20				; size = 4
$T1 = 20						; size = 4
_normalization$ = 20					; size = 4
_pull_offset$ = 24					; size = 4
_env$ = 28						; size = 4
_env_queue$ = 32					; size = 4
?init@kd_decoder@@QAEXVkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z PROC ; kd_decoder::init, COMDAT
; _this$ = ecx

; 259  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 260  :   assert((this->allocator == NULL) && (this->queue == NULL));
; 261  :   this->band = band;

	mov	eax, DWORD PTR _band$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 262  :   
; 263  :   K_max = (kdu_int16) band.get_K_max();

	lea	ecx, DWORD PTR _band$[ebp]
	mov	DWORD PTR [edi+12], eax
	call	?get_K_max@kdu_subband@@QAEHXZ		; kdu_subband::get_K_max

; 264  :   K_max_prime = (kdu_int16) band.get_K_max_prime();

	lea	ecx, DWORD PTR _band$[ebp]
	mov	WORD PTR [edi+16], ax
	call	?get_K_max_prime@kdu_subband@@QAEHXZ	; kdu_subband::get_K_max_prime

; 265  :   assert(K_max_prime >= K_max);
; 266  :   reversible = band.get_reversible();

	lea	ecx, DWORD PTR _band$[ebp]
	mov	WORD PTR [edi+18], ax
	call	?get_reversible@kdu_subband@@QAE_NXZ	; kdu_subband::get_reversible

; 267  :   initialized = false;
; 268  :   delta = band.get_delta() * normalization;

	lea	ecx, DWORD PTR _band$[ebp]
	mov	BYTE PTR [edi+20], al
	mov	BYTE PTR [edi+21], 0
	call	?get_delta@kdu_subband@@QAEMXZ		; kdu_subband::get_delta
	fmul	DWORD PTR _normalization$[ebp]

; 269  : 
; 270  :   kdu_dims dims;
; 271  :   band.get_dims(dims);

	lea	eax, DWORD PTR _dims$[ebp]
	xorps	xmm0, xmm0
	lea	ecx, DWORD PTR _band$[ebp]
	push	eax
	movups	XMMWORD PTR _dims$[ebp], xmm0
	fstp	DWORD PTR [edi+24]
	call	?get_dims@kdu_subband@@QAEXAAUkdu_dims@@@Z ; kdu_subband::get_dims

; 273  :   band.get_block_size(nominal_block_size,first_block_size);

	lea	eax, DWORD PTR _first_block_size$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _nominal_block_size$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 273  :   band.get_block_size(nominal_block_size,first_block_size);

	push	eax
	lea	eax, DWORD PTR _nominal_block_size$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _nominal_block_size$[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 273  :   band.get_block_size(nominal_block_size,first_block_size);

	push	eax
	lea	ecx, DWORD PTR _band$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _first_block_size$[ebp], 0
	mov	DWORD PTR _first_block_size$[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 273  :   band.get_block_size(nominal_block_size,first_block_size);

	call	?get_block_size@kdu_subband@@QAEXAAUkdu_coords@@0@Z ; kdu_subband::get_block_size

; 274  :   band.get_valid_blocks(block_indices);

	lea	eax, DWORD PTR [edi+28]
	push	eax
	lea	ecx, DWORD PTR _band$[ebp]
	call	?get_valid_blocks@kdu_subband@@QAEXAAUkdu_dims@@@Z ; kdu_subband::get_valid_blocks

; 275  : 
; 276  :   subband_cols = dims.size.x;
; 277  :   subband_rows = dims.size.y;
; 278  :   first_block_width = (kdu_int16) first_block_size.x;

	movzx	eax, WORD PTR _first_block_size$[ebp+4]

; 279  :   first_block_height = (kdu_int16) first_block_size.y;
; 280  :   nominal_block_width = (kdu_int16) nominal_block_size.x;
; 281  :   nominal_block_height = (kdu_int16) nominal_block_size.y;
; 282  : 
; 283  :   if ((env != NULL) && (subband_rows > 0) && (subband_cols > 0))

	mov	esi, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR _dims$[ebp+12]
	mov	edx, DWORD PTR _dims$[ebp+8]
	mov	WORD PTR [edi+54], ax
	movzx	eax, WORD PTR _first_block_size$[ebp]
	mov	WORD PTR [edi+56], ax
	movzx	eax, WORD PTR _nominal_block_size$[ebp+4]
	mov	WORD PTR [edi+58], ax
	movzx	eax, WORD PTR _nominal_block_size$[ebp]
	mov	DWORD PTR [edi+48], ecx
	mov	DWORD PTR [edi+44], edx
	mov	WORD PTR [edi+60], ax
	test	esi, esi
	je	SHORT $LN2@init
	test	edx, edx
	jle	SHORT $LN2@init
	test	ecx, ecx
	jle	SHORT $LN2@init

; 284  :     queue = env->add_queue(this,env_queue,"block decoder");

	push	0
	push	0
	push	OFFSET ??_C@_0O@BAMEPCPN@block?5decoder?$AA@
	push	DWORD PTR _env_queue$[ebp]
	lea	eax, DWORD PTR [edi+4]
	mov	ecx, esi
	push	eax
	call	?add_queue@kdu_thread_entity@@QAEPAUkdu_thread_queue@@PAVkdu_worker@@PAU2@PBD_J@Z ; kdu_thread_entity::add_queue
	mov	DWORD PTR [edi+88], eax
$LN2@init:

; 285  : 
; 286  :   // Determine how to partition a row of code-blocks into decoding jobs
; 287  :   num_jobs_per_row = 1;
; 288  :   if ((queue != NULL) && (env->get_num_threads() > 1))

	cmp	DWORD PTR [edi+88], 0
	mov	BYTE PTR [edi+23], 1
	je	SHORT $LN42@init
	mov	ecx, esi
	call	?get_num_threads@kdu_thread_entity@@QAEHXZ ; kdu_thread_entity::get_num_threads
	cmp	eax, 1
	jle	SHORT $LN42@init

; 289  :     { // See if we should split up the code-blocks on a row
; 290  :       kdu_long block_row_samples = subband_cols;

	mov	eax, DWORD PTR [edi+48]

; 291  :       if (subband_rows < (int) nominal_block_height)

	mov	ecx, DWORD PTR [edi+44]
	cdq
	mov	ebx, eax
	mov	DWORD PTR _block_row_samples$3$[ebp], edx
	movsx	eax, WORD PTR [edi+60]

; 292  :         block_row_samples *= subband_rows;

	push	edx
	push	ebx
	cmp	ecx, eax
	jge	SHORT $LN4@init
	mov	eax, ecx
$LN4@init:

; 293  :       else
; 294  :         block_row_samples *= nominal_block_height;

	cdq
	push	edx
	push	eax
	call	__allmul

; 295  :       int num_per_row = (int)(block_row_samples / 8192);

	push	0
	push	8192					; 00002000H
	push	edx
	push	eax
	call	__alldiv

; 296  :       assert(num_per_row <= block_indices.size.x);
; 297  :       if (num_per_row > 32)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN6@init

; 298  :         num_per_row = 32;

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN8@init
$LN6@init:

; 299  :       else if (num_per_row < 1)

	mov	ecx, 1
	cmp	eax, ecx
	cmovl	eax, ecx
$LN8@init:

; 300  :         num_per_row = 1;
; 301  :       num_jobs_per_row = (kdu_byte) num_per_row;

	mov	BYTE PTR [edi+23], al
$LN42@init:

; 302  :     }
; 303  : 
; 304  :   // Determine whether or not to use double buffering, and hence buffer height
; 305  :   secondary_seq = 0; // Changed further down if we settle on double buffering

	xor	eax, eax
	mov	WORD PTR [edi+52], ax

; 306  :   buffer_height = nominal_block_height;

	movzx	eax, WORD PTR [edi+60]
	mov	WORD PTR [edi+62], ax

; 307  :   if (subband_rows <= (int) buffer_height)

	cwde
	cmp	DWORD PTR [edi+44], eax
	jg	SHORT $LN9@init

; 308  :     buffer_height = (kdu_int16) subband_rows;

	mov	ax, WORD PTR [edi+44]
	mov	WORD PTR [edi+62], ax
	jmp	SHORT $LN43@init
$LN9@init:

; 309  :   else if ((queue != NULL) && (env->get_num_threads() > 1))

	cmp	DWORD PTR [edi+88], 0
	je	SHORT $LN43@init
	mov	ecx, esi
	call	?get_num_threads@kdu_thread_entity@@QAEHXZ ; kdu_thread_entity::get_num_threads
	cmp	eax, 1
	jle	SHORT $LN43@init

; 310  :     { // We might want to use double buffering in this case.
; 311  :       int ideal_double_buffered_bands = // ceil(9/num_jobs_per_row)
; 312  :                                         1 + (8/ num_jobs_per_row);      

	movzx	ecx, BYTE PTR [edi+23]
	mov	eax, 8
	cdq
	idiv	ecx

; 313  :       if (band.get_band_idx() <= ideal_double_buffered_bands)

	lea	ecx, DWORD PTR _band$[ebp]
	lea	esi, DWORD PTR [eax+1]
	call	?get_band_idx@kdu_subband@@QAEHXZ	; kdu_subband::get_band_idx
	cmp	eax, esi
	jg	SHORT $LN43@init

; 314  :         { // Decided to use double buffering for this subband.  Note that,
; 315  :           // except for the LL subband, band indices start at 1.
; 316  :           if ((subband_rows-first_block_height) < (int) nominal_block_height)

	movzx	esi, WORD PTR [edi+56]
	mov	ecx, DWORD PTR [edi+44]
	movzx	edx, WORD PTR [edi+60]
	movsx	eax, si
	sub	ecx, eax
	movsx	eax, dx
	cmp	ecx, eax
	jge	SHORT $LN13@init

; 317  :             buffer_height += (kdu_int16)(subband_rows-first_block_height);

	mov	ax, WORD PTR [edi+44]
	sub	ax, si
	add	WORD PTR [edi+62], ax

; 318  :           else

	jmp	SHORT $LN14@init
$LN13@init:

; 319  :             buffer_height += nominal_block_height;

	add	WORD PTR [edi+62], dx
$LN14@init:

; 320  :           secondary_seq = (kdu_uint16)

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _band$[ebp]
	call	?access_resolution@kdu_subband@@QAE?AVkdu_resolution@@XZ ; kdu_subband::access_resolution
	mov	ecx, eax
	call	?get_dwt_level@kdu_resolution@@QAEHXZ	; kdu_resolution::get_dwt_level
	mov	ecx, 64					; 00000040H
	sub	ecx, eax
	mov	WORD PTR [edi+52], cx
$LN43@init:

; 321  :             (64 - band.access_resolution().get_dwt_level());
; 322  :         }
; 323  :     }
; 324  : 
; 325  :   // Set up counters
; 326  :   next_buffered_line = 0;
; 327  :   buffered_line_lim = 0; // No available buffered lines right now
; 328  :   next_pull_block_row = 0;
; 329  : 
; 330  :   // Establish buffer configuration
; 331  :   alignment_offset = 0;
; 332  :   if (first_block_size.x < subband_cols)

	mov	esi, DWORD PTR [edi+48]
	xor	eax, eax
	mov	cl, BYTE PTR _use_shorts$[ebp]
	mov	DWORD PTR [edi+64], eax
	mov	DWORD PTR [edi+68], eax
	mov	BYTE PTR [edi+22], al
	mov	eax, DWORD PTR _first_block_size$[ebp+4]
	cmp	eax, esi
	jge	SHORT $LN15@init

; 333  :     alignment_offset = (kdu_byte)

	test	cl, cl
	je	SHORT $LN22@init
	neg	eax
	and	eax, 7
	jmp	SHORT $LN23@init
$LN22@init:
	mov	eax, DWORD PTR _first_block_size$[ebp+4]
	neg	eax
	and	eax, 3
$LN23@init:
	mov	BYTE PTR [edi+22], al
$LN15@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR _dims$[ebp+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 336  :   lines16 = NULL;

	mov	DWORD PTR [edi+76], 0

; 337  :   lines32 = NULL;

	mov	DWORD PTR [edi+80], 0

; 338  :   this->allocator = NULL;

	mov	DWORD PTR [edi+72], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	jle	$LN36@init
	cmp	DWORD PTR _dims$[ebp+8], 0
	jle	$LN36@init
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 341  :   this->allocator = allocator;

	movzx	eax, BYTE PTR [edi+22]
	mov	edx, DWORD PTR _allocator$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 179  :         before+=before; after+=after; // Two bytes per sample

	add	eax, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 342  :   allocator->pre_alloc(use_shorts,0,subband_cols+3+((int)alignment_offset),

	movsx	ebx, WORD PTR [edi+62]
	mov	DWORD PTR [edi+72], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 179  :         before+=before; after+=after; // Two bytes per sample

	lea	eax, DWORD PTR [eax*2+6]

; 180  :         if (!use_shorts)

	test	cl, cl
	jne	SHORT $LN39@init

; 181  :           { before+=before; after+=after; } // Four bytes per sample

	add	eax, eax
$LN39@init:

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	eax, 15					; 0000000fH
	and	eax, -16				; fffffff0H
	imul	eax, ebx
	add	DWORD PTR [edx+4], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 348  :     lines16 = new kdu_sample16 *[buffer_height];

	mov	edx, 4
	movsx	eax, WORD PTR [edi+62]
	test	cl, cl
	je	SHORT $LN17@init
	xor	ecx, ecx
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 349  :   else
; 350  :     lines32 = new kdu_sample32 *[buffer_height];

	add	esp, 4
	mov	DWORD PTR [edi+76], eax

; 351  :   this->pull_offset = pull_offset;

	mov	eax, DWORD PTR _pull_offset$[ebp]
	mov	DWORD PTR [edi+84], eax
	pop	edi
	pop	esi
	pop	ebx

; 352  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN17@init:

; 349  :   else
; 350  :     lines32 = new kdu_sample32 *[buffer_height];

	xor	ecx, ecx
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [edi+80], eax

; 351  :   this->pull_offset = pull_offset;

	mov	eax, DWORD PTR _pull_offset$[ebp]
	mov	DWORD PTR [edi+84], eax
	pop	edi
	pop	esi
	pop	ebx

; 352  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN36@init:

; 339  :   if (!dims)
; 340  :     { subband_rows = 0; return; }

	mov	DWORD PTR [edi+44], 0
	pop	edi
	pop	esi
	pop	ebx

; 352  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?init@kd_decoder@@QAEXVkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ENDP ; kd_decoder::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
;	COMDAT ??0kd_decoder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0kd_decoder@@QAE@XZ PROC				; kd_decoder::kd_decoder, COMDAT
; _this$ = ecx

; 123  :     kd_decoder()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0kd_decoder@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 124  :       { allocator=NULL; initialized=false; queue=NULL;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi+4], OFFSET ??_7kdu_worker@@6B@
	lea	ecx, DWORD PTR [esi+8]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR [esi], OFFSET ??_7kd_decoder@@6Bkdu_pull_ifc_base@@@
	mov	DWORD PTR [esi+4], OFFSET ??_7kd_decoder@@6Bkdu_worker@@@
	call	??0kdu_block_decoder@@QAE@XZ		; kdu_block_decoder::kdu_block_decoder
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 5274 :     kdu_subband() { state = NULL; }

	mov	DWORD PTR [esi+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 125  :         lines16=NULL; lines32=NULL; }

	mov	eax, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 124  :       { allocator=NULL; initialized=false; queue=NULL;

	mov	DWORD PTR [esi+72], 0
	mov	BYTE PTR [esi+21], 0
	mov	DWORD PTR [esi+88], 0

; 125  :         lines16=NULL; lines32=NULL; }

	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+80], 0
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0kd_decoder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_pull_ifc_base@@MAE@XZ		; kdu_pull_ifc_base::~kdu_pull_ifc_base
__unwindfunclet$??0kd_decoder@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1kdu_worker@@UAE@XZ			; kdu_worker::~kdu_worker
__ehhandler$??0kd_decoder@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0kd_decoder@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0kd_decoder@@QAE@XZ ENDP				; kd_decoder::kd_decoder
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\msvc_coder_mmx_local.h
;	COMDAT ?simd_xfer_decoded_block@@YA_NPAHPAPATkdu_sample16@@HHH_NHM@Z
_TEXT	SEGMENT
_vec_scale$1 = -24					; size = 16
_mxcsr_cur$2 = -8					; size = 4
_mxcsr_orig$3 = -4					; size = 4
_src$ = 8						; size = 4
_dst_refs$ = 12						; size = 4
_dst_offset$ = 16					; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
_reversible$ = 28					; size = 1
_K_max$ = 32						; size = 4
_delta$ = 36						; size = 4
?simd_xfer_decoded_block@@YA_NPAHPAPATkdu_sample16@@HHH_NHM@Z PROC ; simd_xfer_decoded_block, COMDAT

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 66   :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	jge	SHORT $LN2@simd_xfer_

; 67   :     return false;

	xor	al, al

; 184  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_xfer_:

; 68   :   assert(((width == 32) || (width == 64)) && (height > 0));
; 69   :   if (reversible)

	cmp	BYTE PTR _reversible$[ebp], 0
	push	ebx
	push	esi
	push	edi
	je	$LN3@simd_xfer_

; 72   :           MOV EAX,31

	mov	eax, 31					; 0000001fH

; 73   :           SUB EAX,K_max

	sub	eax, DWORD PTR _K_max$[ebp]

; 74   :           MOVD XMM0,EAX      // This is the downshift value

	movd	xmm0, eax

; 75   :           MOV ESI,src

	mov	esi, DWORD PTR _src$[ebp]

; 76   :           MOV EAX,height     // EAX is the vertical counter

	mov	eax, DWORD PTR _height$[ebp]

; 77   :           MOV EBX,dst_offset

	mov	ebx, DWORD PTR _dst_offset$[ebp]

; 78   :           ADD EBX,EBX        // EBX holds the row offset

	add	ebx, ebx

; 79   :           MOV EDX,dst_refs   // EDX points to the next output row

	mov	edx, DWORD PTR _dst_refs$[ebp]

; 80   :           PCMPEQD XMM2,XMM2  // Fill XMM2 with 1's

	pcmpeqd	xmm2, xmm2

; 81   :           PCMPEQD XMM1,XMM1  // Also fill XMM1 with 1's

	pcmpeqd	xmm1, xmm1

; 82   :           PSRLD XMM1,31      // Set each dword in XMM1 equal to 1

	psrld	xmm1, 31				; 0000001fH

; 83   :           MOVD XMM3,K_max    // Temporary value

	movd	xmm3, DWORD PTR _K_max$[ebp]

; 84   :           PSLLD XMM2,XMM3    // Set XMM2 dwords to have 1+downshift 1's in MSBs

	pslld	xmm2, xmm3

; 85   :           POR XMM1,XMM2      // XMM1 now holds the amount we have to add after

	por	xmm1, xmm2
$outer_loop_reversible$20:

; 86   :              // inverting the bits of a downshifted sign-mag quantity which
; 87   :              // was negative, to restore the correct 2's complement value.
; 88   : outer_loop_reversible:
; 89   :           MOV EDI,[EDX]

	mov	edi, DWORD PTR [edx]

; 90   :           ADD EDI,EBX        // Get the address of the next output sample

	add	edi, ebx

; 91   :           MOV ECX,width

	mov	ecx, DWORD PTR _width$[ebp]
$inner_loop_reversible$21:

; 92   : inner_loop_reversible:
; 93   :           MOVDQA XMM4,[ESI]

	movdqa	xmm4, XMMWORD PTR [esi]

; 94   :           PXOR XMM5,XMM5

	pxor	xmm5, xmm5

; 95   :           PCMPGTD XMM5,XMM4  // Fills dwords in XMM5 with 1s if XMM4 dwords < 0

	pcmpgtd	xmm5, xmm4

; 96   :           PXOR XMM4,XMM5

	pxor	xmm4, xmm5

; 97   :           PSRAD XMM4,XMM0

	psrad	xmm4, xmm0

; 98   :           PAND XMM5,XMM1     // Leave the bits we need to add

	pand	xmm5, xmm1

; 99   :           PADDD XMM4,XMM5    // Finish conversion from sign-mag to 2's comp

	paddd	xmm4, xmm5

; 100  : 
; 101  :           MOVDQA XMM6,[ESI+16]

	movdqa	xmm6, XMMWORD PTR [esi+16]

; 102  :           PXOR XMM7,XMM7

	pxor	xmm7, xmm7

; 103  :           PCMPGTD XMM7,XMM6  // Fills dwords in XMM7 with 1s if XMM6 dwords < 0

	pcmpgtd	xmm7, xmm6

; 104  :           PXOR XMM6,XMM7

	pxor	xmm6, xmm7

; 105  :           PSRAD XMM6,XMM0    // Apply the downshift value

	psrad	xmm6, xmm0

; 106  :           PAND XMM7,XMM1     // Leave the bits we need to add

	pand	xmm7, xmm1

; 107  :           PADDD XMM6,XMM7    // Finish conversion from sign-mag to 2's comp

	paddd	xmm6, xmm7

; 108  : 
; 109  :           PACKSSDW XMM4,XMM6 // Get packed 8 words

	packssdw xmm4, xmm6

; 110  :           MOVDQA [EDI],XMM4  // Write result

	movdqa	XMMWORD PTR [edi], xmm4

; 111  :           ADD ESI,32

	add	esi, 32					; 00000020H

; 112  :           ADD EDI,16

	add	edi, 16					; 00000010H

; 113  :           SUB ECX,8

	sub	ecx, 8

; 114  :           JG inner_loop_reversible

	jg	SHORT $inner_loop_reversible$21

; 115  :           ADD EDX,4          // Point to next output row

	add	edx, 4

; 116  :           SUB EAX,1

	sub	eax, 1

; 117  :           JG outer_loop_reversible

	jg	SHORT $outer_loop_reversible$20

; 70   :     {
; 71   :       __asm {

	pop	edi
	pop	esi

; 181  :         }
; 182  :     }
; 183  :   return true;

	mov	al, 1
	pop	ebx

; 184  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@simd_xfer_:

; 118  :         }
; 119  :     }
; 120  :   else
; 121  :     {
; 122  :       float fscale = delta * (float)(1<<KDU_FIX_POINT);

	movss	xmm1, DWORD PTR _delta$[ebp]

; 123  :       if (K_max <= 31)

	mov	eax, DWORD PTR _K_max$[ebp]
	mulss	xmm1, DWORD PTR __real@46000000
	cmp	eax, 31					; 0000001fH
	jg	SHORT $LN5@simd_xfer_

; 124  :         fscale /= (float)(1<<(31-K_max));

	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0

; 125  :       else

	jmp	SHORT $LN6@simd_xfer_
$LN5@simd_xfer_:

; 126  :         fscale *= (float)(1<<(K_max-31));

	lea	ecx, DWORD PTR [eax-31]
	mov	eax, 1
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm1, xmm0
$LN6@simd_xfer_:

; 127  :       float vec_scale[4] = {fscale,fscale,fscale,fscale};

	shufps	xmm1, xmm1, 0
	movups	XMMWORD PTR _vec_scale$1[ebp], xmm1

; 128  :       int mxcsr_orig, mxcsr_cur;
; 129  :       __asm STMXCSR mxcsr_orig;

	stmxcsr	DWORD PTR _mxcsr_orig$3[ebp]

; 130  :       mxcsr_cur = mxcsr_orig & ~(3<<13); // Reset rounding control bits

	mov	eax, DWORD PTR _mxcsr_orig$3[ebp]
	and	eax, -24577				; ffff9fffH
	mov	DWORD PTR _mxcsr_cur$2[ebp], eax

; 132  :           LDMXCSR mxcsr_cur;

	ldmxcsr	DWORD PTR _mxcsr_cur$2[ebp]

; 133  :           MOV ESI,src

	mov	esi, DWORD PTR _src$[ebp]

; 134  :           MOV EAX,height     // EAX is the vertical counter

	mov	eax, DWORD PTR _height$[ebp]

; 135  :           MOV EBX,dst_offset

	mov	ebx, DWORD PTR _dst_offset$[ebp]

; 136  :           ADD EBX,EBX        // EBX holds the row offset

	add	ebx, ebx

; 137  :           MOV EDX,dst_refs   // EDX points to the next output row

	mov	edx, DWORD PTR _dst_refs$[ebp]

; 138  :           MOVUPS XMM0,vec_scale

	movups	xmm0, XMMWORD PTR _vec_scale$1[ebp]

; 139  :           PCMPEQD XMM2,XMM2  // Fill XMM2 with 1's

	pcmpeqd	xmm2, xmm2

; 140  :           PCMPEQD XMM1,XMM1  // Also fill XMM1 with 1's

	pcmpeqd	xmm1, xmm1

; 141  :           PSRLD XMM1,31      // Set each dword in XMM1 equal to 1

	psrld	xmm1, 31				; 0000001fH

; 142  :           PSLLD XMM2,31      // Set each dword in XMM2 equal to 0x80000000

	pslld	xmm2, 31				; 0000001fH

; 143  :           POR XMM1,XMM2      // XMM1 now holds 0x80000001

	por	xmm1, xmm2
$outer_loop_irreversible$22:

; 144  :           
; 145  : outer_loop_irreversible:
; 146  :           MOV EDI,[EDX]

	mov	edi, DWORD PTR [edx]

; 147  :           ADD EDI,EBX        // Get the address of the next output sample

	add	edi, ebx

; 148  :           MOV ECX,width

	mov	ecx, DWORD PTR _width$[ebp]
$inner_loop_irreversible$23:

; 149  : inner_loop_irreversible:
; 150  :           MOVDQA XMM4,[ESI]

	movdqa	xmm4, XMMWORD PTR [esi]

; 151  :           PXOR XMM5,XMM5

	pxor	xmm5, xmm5

; 152  :           PCMPGTD XMM5,XMM4  // Fills dwords in XMM5 with 1s if XMM4 dwords < 0

	pcmpgtd	xmm5, xmm4

; 153  :           PXOR XMM4,XMM5

	pxor	xmm4, xmm5

; 154  :           PAND XMM5,XMM1     // AND off all but MSB and LSB in each dword

	pand	xmm5, xmm1

; 155  :           PADDD XMM4,XMM5    // Finish conversion from sign-mag to 2's comp

	paddd	xmm4, xmm5

; 156  :           CVTDQ2PS XMM4,XMM4 // Convert dwords to single precision floats

	cvtdq2ps xmm4, xmm4

; 157  :           MULPS XMM4,XMM0    // Scale by adjusted quantization step size

	mulps	xmm4, xmm0

; 158  :           CVTPS2DQ XMM4,XMM4

	cvtps2dq xmm4, xmm4

; 159  : 
; 160  :           MOVDQA XMM6,[ESI+16]

	movdqa	xmm6, XMMWORD PTR [esi+16]

; 161  :           PXOR XMM7,XMM7

	pxor	xmm7, xmm7

; 162  :           PCMPGTD XMM7,XMM6  // Fills dwords in XMM7 with 1s if XMM6 dwords < 0

	pcmpgtd	xmm7, xmm6

; 163  :           PXOR XMM6,XMM7

	pxor	xmm6, xmm7

; 164  :           PAND XMM7,XMM1     // AND off all but MSB and LSB in each word

	pand	xmm7, xmm1

; 165  :           PADDD XMM6,XMM7    // Finish conversion from sign-mag to 2's comp

	paddd	xmm6, xmm7

; 166  :           CVTDQ2PS XMM6,XMM6 // Convert dwords to single precision floats

	cvtdq2ps xmm6, xmm6

; 167  :           MULPS XMM6,XMM0    // Scale by adjusted quantization step size

	mulps	xmm6, xmm0

; 168  :           CVTPS2DQ XMM6,XMM6

	cvtps2dq xmm6, xmm6

; 169  : 
; 170  :           PACKSSDW XMM4,XMM6 // Get packed 8 words

	packssdw xmm4, xmm6

; 171  :           MOVDQA [EDI],XMM4  // Write result

	movdqa	XMMWORD PTR [edi], xmm4

; 172  :           ADD ESI,32

	add	esi, 32					; 00000020H

; 173  :           ADD EDI,16

	add	edi, 16					; 00000010H

; 174  :           SUB ECX,8

	sub	ecx, 8

; 175  :           JG inner_loop_irreversible

	jg	SHORT $inner_loop_irreversible$23

; 176  :           ADD EDX,4          // Point to next output row

	add	edx, 4

; 177  :           SUB EAX,1

	sub	eax, 1

; 178  :           JG outer_loop_irreversible

	jg	SHORT $outer_loop_irreversible$22

; 179  : 
; 180  :           LDMXCSR mxcsr_orig;// Restore rounding control bits

	ldmxcsr	DWORD PTR _mxcsr_orig$3[ebp]

; 131  :       __asm {

	pop	edi
	pop	esi

; 181  :         }
; 182  :     }
; 183  :   return true;

	mov	al, 1
	pop	ebx

; 184  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?simd_xfer_decoded_block@@YA_NPAHPAPATkdu_sample16@@HHH_NHM@Z ENDP ; simd_xfer_decoded_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
;	COMDAT ?decode@kdu_block_decoder@@QAEXPAUkdu_block@@@Z
_TEXT	SEGMENT
_block$ = 8						; size = 4
?decode@kdu_block_decoder@@QAEXPAUkdu_block@@@Z PROC	; kdu_block_decoder::decode, COMDAT
; _this$ = ecx

; 182  :       {

	push	ebp
	mov	ebp, esp

; 183  :       /* [SYNOPSIS]
; 184  :            Decodes a single block of samples.  The dimensions of the block
; 185  :            are in `block->size' -- none of the geometric transformation
; 186  :            flags in `block->size' have any meaning here.
; 187  :            [//]
; 188  :            On entry, `block->num_passes' indicates the number of coding
; 189  :            passes which are to be decoded and `block->missing_msbs' the
; 190  :            number of most significant bit-planes which are to be skipped.
; 191  :            The function processes all coding passes, unless unable to do so
; 192  :            for reasons of available implementation precision limitations, or
; 193  :            an error was detected by error resilience mechanisms and corrected
; 194  :            by discarding passes believed to be erroneous.
; 195  :            [//]
; 196  :            On exit, the decoded samples are in the `block->sample_buffer'
; 197  :            array, organized in scan-line order.  The sample values themselves
; 198  :            have a sign-magnitude representation, with the most significant
; 199  :            magnitude bit-plane appearing in bit position 30 and the sign
; 200  :            (1 for -ve) in bit position 31.  At each sample location, if p is
; 201  :            the index of the least significant decoded magnitude bit and the
; 202  :            sample is non-zero, the function sets bit p-1.  This has the effect
; 203  :            of both signalling the location of the least significant decoded
; 204  :            magnitude bit-plane and also implementing the default mid-point
; 205  :            rounding rule for dequantization.
; 206  :            [//]
; 207  :            The value of `block->K_max_prime' identifies the maximum number of
; 208  :            magnitude bit-planes (including missing MSB's) which could have
; 209  :            been coded.  Knowledge of this value allows the function to
; 210  :            determine whether or not all coding passes have been decoded,
; 211  :            without truncation -- this in turn, affects the behaviour of
; 212  :            the error resilience mechanisms.
; 213  :         */
; 214  :         state->decode(block);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]

; 215  :       }

	pop	ebp

; 183  :       /* [SYNOPSIS]
; 184  :            Decodes a single block of samples.  The dimensions of the block
; 185  :            are in `block->size' -- none of the geometric transformation
; 186  :            flags in `block->size' have any meaning here.
; 187  :            [//]
; 188  :            On entry, `block->num_passes' indicates the number of coding
; 189  :            passes which are to be decoded and `block->missing_msbs' the
; 190  :            number of most significant bit-planes which are to be skipped.
; 191  :            The function processes all coding passes, unless unable to do so
; 192  :            for reasons of available implementation precision limitations, or
; 193  :            an error was detected by error resilience mechanisms and corrected
; 194  :            by discarding passes believed to be erroneous.
; 195  :            [//]
; 196  :            On exit, the decoded samples are in the `block->sample_buffer'
; 197  :            array, organized in scan-line order.  The sample values themselves
; 198  :            have a sign-magnitude representation, with the most significant
; 199  :            magnitude bit-plane appearing in bit position 30 and the sign
; 200  :            (1 for -ve) in bit position 31.  At each sample location, if p is
; 201  :            the index of the least significant decoded magnitude bit and the
; 202  :            sample is non-zero, the function sets bit p-1.  This has the effect
; 203  :            of both signalling the location of the least significant decoded
; 204  :            magnitude bit-plane and also implementing the default mid-point
; 205  :            rounding rule for dequantization.
; 206  :            [//]
; 207  :            The value of `block->K_max_prime' identifies the maximum number of
; 208  :            magnitude bit-planes (including missing MSB's) which could have
; 209  :            been coded.  Knowledge of this value allows the function to
; 210  :            determine whether or not all coding passes have been decoded,
; 211  :            without truncation -- this in turn, affects the behaviour of
; 212  :            the error resilience mechanisms.
; 213  :         */
; 214  :         state->decode(block);

	jmp	DWORD PTR [eax+4]
?decode@kdu_block_decoder@@QAEXPAUkdu_block@@@Z ENDP	; kdu_block_decoder::decode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
;	COMDAT ??1kdu_block_decoder@@QAE@XZ
_TEXT	SEGMENT
??1kdu_block_decoder@@QAE@XZ PROC			; kdu_block_decoder::~kdu_block_decoder, COMDAT
; _this$ = ecx

; 180  :     ~kdu_block_decoder() { delete state; }

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN3@kdu_block_
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN3@kdu_block_:
	ret	0
??1kdu_block_decoder@@QAE@XZ ENDP			; kdu_block_decoder::~kdu_block_decoder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
;	COMDAT ??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_band$ = 8						; size = 4
_allocator$ = 12					; size = 4
_use_shorts$ = 16					; size = 1
_normalization$ = 20					; size = 4
_pull_offset$ = 24					; size = 4
_env$ = 28						; size = 4
_env_queue$ = 32					; size = 4
??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z PROC ; kdu_decoder::kdu_decoder, COMDAT
; _this$ = ecx

; 241  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 242  :   kd_decoder *dec = new kd_decoder;

	push	92					; 0000005cH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 696  :     kdu_pull_ifc() { state = NULL; }

	mov	DWORD PTR [esi], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp

; 242  :   kd_decoder *dec = new kd_decoder;

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@kdu_decode
	mov	ecx, eax
	call	??0kd_decoder@@QAE@XZ			; kd_decoder::kd_decoder
	jmp	SHORT $LN4@kdu_decode
$LN3@kdu_decode:
	xor	eax, eax
$LN4@kdu_decode:

; 243  :   state = dec;
; 244  :   dec->init(band,allocator,use_shorts,normalization,pull_offset,env,env_queue);

	push	DWORD PTR _env_queue$[ebp]
	movss	xmm0, DWORD PTR _normalization$[ebp]
	push	DWORD PTR _env$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	DWORD PTR _pull_offset$[ebp]
	mov	DWORD PTR [esi], eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, eax
	push	DWORD PTR _use_shorts$[ebp]
	push	DWORD PTR _allocator$[ebp]
	push	DWORD PTR _band$[ebp]
	call	?init@kd_decoder@@QAEXVkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kd_decoder::init

; 245  : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z$0:
	push	92					; 0000005cH
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0kdu_decoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMHPAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ENDP ; kdu_decoder::kdu_decoder
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??0kdu_pull_ifc@@QAE@XZ
_TEXT	SEGMENT
??0kdu_pull_ifc@@QAE@XZ PROC				; kdu_pull_ifc::kdu_pull_ifc, COMDAT
; _this$ = ecx

; 696  :     kdu_pull_ifc() { state = NULL; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0kdu_pull_ifc@@QAE@XZ ENDP				; kdu_pull_ifc::kdu_pull_ifc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??_Gkdu_pull_ifc_base@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkdu_pull_ifc_base@@MAEPAXI@Z PROC			; kdu_pull_ifc_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 669  :     virtual ~kdu_pull_ifc_base() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_pull_ifc_base@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkdu_pull_ifc_base@@MAEPAXI@Z ENDP			; kdu_pull_ifc_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0kdu_pull_ifc_base@@QAE@XZ
_TEXT	SEGMENT
??0kdu_pull_ifc_base@@QAE@XZ PROC			; kdu_pull_ifc_base::kdu_pull_ifc_base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kdu_pull_ifc_base@@6B@
	mov	eax, ecx
	ret	0
??0kdu_pull_ifc_base@@QAE@XZ ENDP			; kdu_pull_ifc_base::kdu_pull_ifc_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??1kdu_pull_ifc_base@@MAE@XZ
_TEXT	SEGMENT
??1kdu_pull_ifc_base@@MAE@XZ PROC			; kdu_pull_ifc_base::~kdu_pull_ifc_base, COMDAT
; _this$ = ecx

; 669  :     virtual ~kdu_pull_ifc_base() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_pull_ifc_base@@6B@
	ret	0
??1kdu_pull_ifc_base@@MAE@XZ ENDP			; kdu_pull_ifc_base::~kdu_pull_ifc_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_width@kdu_line_buf@@QAEHXZ
_TEXT	SEGMENT
?get_width@kdu_line_buf@@QAEHXZ PROC			; kdu_line_buf::get_width, COMDAT
; _this$ = ecx

; 537  :       /* [SYNOPSIS]
; 538  :            Returns 0 if the object has not been created.  Otherwise, returns
; 539  :            the nominal width of the line.  Remember that the arrays returned
; 540  :            by `get_buf16' and `get_buf32' are typically larger than the actual
; 541  :            line width, as explained in the comments appearing with the
; 542  :            `pre_create' function.
; 543  :       */
; 544  :         return width;

	mov	eax, DWORD PTR [ecx]

; 545  :       }

	ret	0
?get_width@kdu_line_buf@@QAEHXZ ENDP			; kdu_line_buf::get_width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ
_TEXT	SEGMENT
?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ PROC	; kdu_line_buf::get_buf16, COMDAT
; _this$ = ecx

; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN3@get_buf16
	mov	eax, DWORD PTR [ecx+8]

; 414  :       }

	ret	0
$LN3@get_buf16:

; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	xor	eax, eax

; 414  :       }

	ret	0
?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ ENDP	; kdu_line_buf::get_buf16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ
_TEXT	SEGMENT
?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ PROC	; kdu_line_buf::get_buf32, COMDAT
; _this$ = ecx

; 393  :       /* [SYNOPSIS]
; 394  :            Returns NULL if the sample values are of type `kdu_sample16'
; 395  :            instead of `kdu_sample32', or the buffer has not yet been
; 396  :            created.  Otherwise, returns an array which supports accesses
; 397  :            at least with indices in the range 0 to `width'-1, but typically
; 398  :            beyond these bounds -- see `pre_create' for an explanation of
; 399  :            extended access bounds.
; 400  :       */
; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN3@get_buf32
	xor	eax, eax

; 402  :       }

	ret	0
$LN3@get_buf32:

; 393  :       /* [SYNOPSIS]
; 394  :            Returns NULL if the sample values are of type `kdu_sample16'
; 395  :            instead of `kdu_sample32', or the buffer has not yet been
; 396  :            created.  Otherwise, returns an array which supports accesses
; 397  :            at least with indices in the range 0 to `width'-1, but typically
; 398  :            beyond these bounds -- see `pre_create' for an explanation of
; 399  :            extended access bounds.
; 400  :       */
; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	eax, DWORD PTR [ecx+8]

; 402  :       }

	ret	0
?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ ENDP	; kdu_line_buf::get_buf32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z
_TEXT	SEGMENT
_before$ = 8						; size = 4
_after$ = 12						; size = 4
?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z PROC ; kdu_sample_allocator::alloc32, COMDAT
; _this$ = ecx

; 225  :       {

	push	ebp
	mov	ebp, esp
	push	esi

; 226  :       /* [SYNOPSIS]
; 227  :            Same as `alloc16', except that it allocates storage for arrays of
; 228  :            32-bit quantities.  Again, the returned pointer is guaranteed to
; 229  :            be aligned on a 16-byte boundary.
; 230  :       */
; 231  :         assert(!pre_creation_phase);
; 232  :         before = (before+3)&~3; // Round up to nearest multiple of 16 bytes.

	mov	esi, DWORD PTR _before$[ebp]
	push	edi
	mov	edi, ecx
	add	esi, 3

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.

	mov	ecx, DWORD PTR _after$[ebp]
	and	esi, -4					; fffffffcH
	add	ecx, 3
	and	ecx, -4					; fffffffcH

; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+esi*4]
	add	eax, edx
	add	ecx, esi
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [edi+8], ecx
	pop	edi
	pop	esi

; 236  :         assert(bytes_used <= bytes_reserved);
; 237  :         return result;
; 238  :       }

	pop	ebp
	ret	8
?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z ENDP ; kdu_sample_allocator::alloc32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z
_TEXT	SEGMENT
_before$ = 8						; size = 4
_after$ = 12						; size = 4
?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z PROC ; kdu_sample_allocator::alloc16, COMDAT
; _this$ = ecx

; 203  :       {

	push	ebp
	mov	ebp, esp
	push	esi

; 204  :       /* [SYNOPSIS]
; 205  :            Allocate an array with space for `before' entries prior to the
; 206  :            returned pointer and `after' entries after the returned pointer
; 207  :            (including the entry to which the pointer refers).  The returned
; 208  :            pointer is guaranteed to be aligned on a 16-byte boundary.
; 209  :            The pointer may be interpreted as the location of an array which
; 210  :            can accept signed indices, n, in the range -`before' <= n < `after'.
; 211  :            [//]
; 212  :            Before calling this function, you must have pre-allocated sufficient
; 213  :            space through calls to `pre_alloc' and you must have called the
; 214  :            `finalize' member function.
; 215  :       */
; 216  :         assert(!pre_creation_phase);
; 217  :         before = (before+7)&~7; // Round up to nearest multiple of 16 bytes.

	mov	esi, DWORD PTR _before$[ebp]
	push	edi
	mov	edi, ecx
	add	esi, 7

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.

	mov	ecx, DWORD PTR _after$[ebp]
	and	esi, -8					; fffffff8H
	add	ecx, 7
	and	ecx, -8					; fffffff8H

; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+esi*2]
	add	eax, edx
	add	ecx, esi
	lea	ecx, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR [edi+8], ecx
	pop	edi
	pop	esi

; 221  :         assert(bytes_used <= bytes_reserved);
; 222  :         return result;
; 223  :       }

	pop	ebp
	ret	8
?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z ENDP ; kdu_sample_allocator::alloc16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z
_TEXT	SEGMENT
_use_shorts$ = 8					; size = 1
_before$ = 12						; size = 4
_after$ = 16						; size = 4
_num_requests$ = 20					; size = 4
?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z PROC	; kdu_sample_allocator::pre_alloc, COMDAT
; _this$ = ecx

; 168  :       {

	push	ebp
	mov	ebp, esp

; 169  :       /* [SYNOPSIS]
; 170  :            Reserves enough storage for `num_requests' later calls to `alloc16'
; 171  :            (if `use_shorts' is true) or `alloc32' (if `use_shorts' is false).
; 172  :            Space is reserved such that each of these `num_requests' allocations
; 173  :            can return an appropriately aligned pointer to an array which offers
; 174  :            entries at locations n in the range -`before' <= n < `after', where
; 175  :            each entry is of type `kdu_sample16' (if `use_shorts'=true) or
; 176  :            `kdu_sample32' (if `use_shorts'=false).
; 177  :       */
; 178  :         assert(pre_creation_phase);
; 179  :         before+=before; after+=after; // Two bytes per sample

	mov	eax, DWORD PTR _before$[ebp]
	mov	edx, ecx
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _after$[ebp]
	add	eax, eax

; 180  :         if (!use_shorts)

	cmp	BYTE PTR _use_shorts$[ebp], 0
	jne	SHORT $LN2@pre_alloc

; 181  :           { before+=before; after+=after; } // Four bytes per sample

	add	ecx, ecx
	add	eax, eax
$LN2@pre_alloc:

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	ecx, 15					; 0000000fH
	add	eax, 15					; 0000000fH
	and	ecx, -16				; fffffff0H
	and	eax, -16				; fffffff0H
	add	ecx, eax
	imul	ecx, DWORD PTR _num_requests$[ebp]
	add	DWORD PTR [edx+4], ecx

; 183  :       }

	pop	ebp
	ret	16					; 00000010H
?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z ENDP	; kdu_sample_allocator::pre_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_subband@@QAE@XZ
_TEXT	SEGMENT
??0kdu_subband@@QAE@XZ PROC				; kdu_subband::kdu_subband, COMDAT
; _this$ = ecx

; 5274 :     kdu_subband() { state = NULL; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0kdu_subband@@QAE@XZ ENDP				; kdu_subband::kdu_subband
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??7kdu_dims@@QAE_NXZ
_TEXT	SEGMENT
??7kdu_dims@@QAE_NXZ PROC				; kdu_dims::operator!, COMDAT
; _this$ = ecx

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR [ecx+12], 0
	jle	SHORT $LN3@operator
	cmp	DWORD PTR [ecx+8], 0
	jle	SHORT $LN3@operator
	xor	al, al
	ret	0
$LN3@operator:
	mov	al, 1
	ret	0
??7kdu_dims@@QAE_NXZ ENDP				; kdu_dims::operator!
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_dims@@QAE@XZ
_TEXT	SEGMENT
??0kdu_dims@@QAE@XZ PROC				; kdu_dims::kdu_dims, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0

; 304  :     kdu_dims() {};

	mov	eax, ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0

; 304  :     kdu_dims() {};

	ret	0
??0kdu_dims@@QAE@XZ ENDP				; kdu_dims::kdu_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?transpose@kdu_coords@@QAEXXZ
_TEXT	SEGMENT
?transpose@kdu_coords@@QAEXXZ PROC			; kdu_coords::transpose, COMDAT
; _this$ = ecx

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
	ret	0
?transpose@kdu_coords@@QAEXXZ ENDP			; kdu_coords::transpose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_coords@@QAE@XZ
_TEXT	SEGMENT
??0kdu_coords@@QAE@XZ PROC				; kdu_coords::kdu_coords, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kdu_coords@@QAE@XZ ENDP				; kdu_coords::kdu_coords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?release_lock@kdu_thread_entity@@QAEXH@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
?release_lock@kdu_thread_entity@@QAEXH@Z PROC		; kdu_thread_entity::release_lock, COMDAT
; _this$ = ecx

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _lock_id$[ebp]

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [ecx+eax*8+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN5@release_lo
	mov	DWORD PTR _lock_id$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	jmp	DWORD PTR __imp__ReleaseMutex@4
$LN5@release_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
	ret	4
?release_lock@kdu_thread_entity@@QAEXH@Z ENDP		; kdu_thread_entity::release_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?acquire_lock@kdu_thread_entity@@QAEXH_N@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
$T1 = 12						; size = 4
_allow_exceptions$ = 12					; size = 1
?acquire_lock@kdu_thread_entity@@QAEXH_N@Z PROC		; kdu_thread_entity::acquire_lock, COMDAT
; _this$ = ecx

; 1024 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp

; 1025 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	cmp	BYTE PTR _allow_exceptions$[ebp], 0
	mov	eax, DWORD PTR _lock_id$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edx, DWORD PTR [esi+28]
	lea	edi, DWORD PTR [edx+eax*8]
	je	SHORT $LN2@acquire_lo
	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN9@acquire_lo
$LN2@acquire_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@acquire_lo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN6@acquire_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+4], esi
	pop	edi
	pop	esi
	pop	ebp
	ret	8
$LN9@acquire_lo:

; 1025 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN11@acquire_lo:
$LN8@acquire_lo:
	int	3
?acquire_lock@kdu_thread_entity@@QAEXH_N@Z ENDP		; kdu_thread_entity::acquire_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ??_Gkdu_worker@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkdu_worker@@UAEPAXI@Z PROC				; kdu_worker::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 106  :     virtual ~kdu_worker() { return; } // Prevent compiler warnings

	mov	DWORD PTR [esi], OFFSET ??_7kdu_worker@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkdu_worker@@UAEPAXI@Z ENDP				; kdu_worker::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0kdu_worker@@QAE@XZ
_TEXT	SEGMENT
??0kdu_worker@@QAE@XZ PROC				; kdu_worker::kdu_worker, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kdu_worker@@6B@
	mov	eax, ecx
	ret	0
??0kdu_worker@@QAE@XZ ENDP				; kdu_worker::kdu_worker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ??1kdu_worker@@UAE@XZ
_TEXT	SEGMENT
??1kdu_worker@@UAE@XZ PROC				; kdu_worker::~kdu_worker, COMDAT
; _this$ = ecx

; 106  :     virtual ~kdu_worker() { return; } // Prevent compiler warnings

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_worker@@6B@
	ret	0
??1kdu_worker@@UAE@XZ ENDP				; kdu_worker::~kdu_worker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
??6kdu_message@@QAEAAV0@PBD@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 257  :       { put_text(string); return *this; }

	push	ebp
	mov	ebp, esp
	push	esi
	push	DWORD PTR _string$[ebp]
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@PBD@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?unlock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?unlock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::unlock, COMDAT
; _this$ = ecx

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@unlock
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	cmp	eax, 1
	jne	SHORT $LN3@unlock
	mov	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
$LN3@unlock:

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	xor	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
?unlock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?lock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?lock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::lock, COMDAT
; _this$ = ecx

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@lock
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	SHORT $LN3@lock
	mov	al, 1

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
$LN3@lock:

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	xor	al, al

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
?lock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\decoder.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
