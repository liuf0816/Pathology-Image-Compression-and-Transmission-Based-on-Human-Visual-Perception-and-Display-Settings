; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\compressed\blocks.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	??0kdu_block@@AAE@XZ				; kdu_block::kdu_block
PUBLIC	??1kdu_block@@AAE@XZ				; kdu_block::~kdu_block
PUBLIC	?set_max_passes@kdu_block@@QAEXH_N@Z		; kdu_block::set_max_passes
PUBLIC	?set_max_bytes@kdu_block@@QAEXH_N@Z		; kdu_block::set_max_bytes
PUBLIC	?set_max_samples@kdu_block@@QAEXH@Z		; kdu_block::set_max_samples
PUBLIC	?set_max_contexts@kdu_block@@QAEXH@Z		; kdu_block::set_max_contexts
PUBLIC	?get@kd_input@@QAE_NAAE@Z			; kd_input::get
PUBLIC	?get_bit@kd_header_in@@QAEHXZ			; kd_header_in::get_bit
PUBLIC	?get_bits@kd_header_in@@QAEIH@Z			; kd_header_in::get_bits
PUBLIC	?put_bit@kd_header_out@@QAEXH@Z			; kd_header_out::put_bit
PUBLIC	?put_bits@kd_header_out@@QAEXHH@Z		; kd_header_out::put_bits
PUBLIC	?parse_packet_header@kd_block@@QAEHAAVkd_header_in@@PAVkd_buf_server@@H@Z ; kd_block::parse_packet_header
PUBLIC	?retrieve_data@kd_block@@QAEXPAUkdu_block@@HH_N@Z ; kd_block::retrieve_data
PUBLIC	?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_buf_server@@@Z ; kd_block::store_data
PUBLIC	?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_thread_buf_server@@@Z ; kd_block::store_data
PUBLIC	?trim_data@kd_block@@QAE_NGPAVkd_buf_server@@@Z	; kd_block::trim_data
PUBLIC	?start_packet@kd_block@@QAEHHG@Z		; kd_block::start_packet
PUBLIC	?write_packet_header@kd_block@@QAEXAAVkd_header_out@@H_N@Z ; kd_block::write_packet_header
PUBLIC	?write_body_bytes@kd_block@@QAEXPAVkdu_output@@@Z ; kd_block::write_body_bytes
PUBLIC	?build_tree@kd_block@@SAPAV1@Ukdu_coords@@AAPAE@Z ; kd_block::build_tree
PUBLIC	?reset_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z ; kd_block::reset_output_tree
PUBLIC	?save_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z ; kd_block::save_output_tree
PUBLIC	?restore_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z ; kd_block::restore_output_tree
PUBLIC	?put_word@kd_block@@AAEXHPAVkd_buf_server@@@Z	; kd_block::put_word
PUBLIC	?get_bytes@kd_block_reader@@QAEPAEPAEH@Z	; kd_block_reader::get_bytes
PUBLIC	__TI2PAVkd_header_in@@
PUBLIC	__CTA2PAVkd_header_in@@
PUBLIC	??_R0PAVkd_header_in@@@8			; kd_header_in * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAVkd_header_in@@@84
PUBLIC	??_R0PAX@8					; void * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAX@84
PUBLIC	__TI1G
PUBLIC	__CTA1G
PUBLIC	??_R0G@8					; unsigned short `RTTI Type Descriptor'
PUBLIC	__CT??_R0G@82
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ:PROC ; kd_buf_server::get
EXTRN	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z:PROC ; kd_buf_server::release
EXTRN	?augment_local_store@kd_thread_buf_server@@QAEX_N@Z:PROC ; kd_thread_buf_server::augment_local_store
EXTRN	?process_unexpected_marker@kd_input@@AAEXE@Z:PROC ; kd_input::process_unexpected_marker
EXTRN	__CxxThrowException@8:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT __CT??_R0G@82
xdata$x	SEGMENT
__CT??_R0G@82 DD 01H
	DD	FLAT:??_R0G@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	02H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0G@8
data$r	SEGMENT
??_R0G@8 DD	FLAT:??_7type_info@@6B@			; unsigned short `RTTI Type Descriptor'
	DD	00H
	DB	'.G', 00H
data$r	ENDS
;	COMDAT __CTA1G
xdata$x	SEGMENT
__CTA1G	DD	01H
	DD	FLAT:__CT??_R0G@82
xdata$x	ENDS
;	COMDAT __TI1G
xdata$x	SEGMENT
__TI1G	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1G
xdata$x	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT
__CT??_R0PAX@84 DD 01H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAX@8
data$r	SEGMENT
??_R0PAX@8 DD	FLAT:??_7type_info@@6B@			; void * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAX', 00H
data$r	ENDS
;	COMDAT __CT??_R0PAVkd_header_in@@@84
xdata$x	SEGMENT
__CT??_R0PAVkd_header_in@@@84 DD 01H
	DD	FLAT:??_R0PAVkd_header_in@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAVkd_header_in@@@8
data$r	SEGMENT
??_R0PAVkd_header_in@@@8 DD FLAT:??_7type_info@@6B@	; kd_header_in * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVkd_header_in@@', 00H
data$r	ENDS
;	COMDAT __CTA2PAVkd_header_in@@
xdata$x	SEGMENT
__CTA2PAVkd_header_in@@ DD 02H
	DD	FLAT:__CT??_R0PAVkd_header_in@@@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT __TI2PAVkd_header_in@@
xdata$x	SEGMENT
__TI2PAVkd_header_in@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2PAVkd_header_in@@
xdata$x	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?get_bytes@kd_block_reader@@QAEPAEPAEH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_bp$ = 8						; size = 4
_num_needed$ = 12					; size = 4
?get_bytes@kd_block_reader@@QAEPAEPAEH@Z PROC		; kd_block_reader::get_bytes, COMDAT
; _this$ = ecx

; 108  :       { /* Copies `num_needed' bytes into `bp', advancing `current_buf' as

	push	ebp
	mov	ebp, esp
	push	ecx

; 109  :            required and returning `bp'+`num_needed'.  Don't call this
; 110  :            function if `num_needed' <= 0. */
; 111  :         int bytes_available = KD_CODE_BUFFER_LEN - buf_pos;
; 112  :         kdu_byte *sp = current_buf->buf + buf_pos;
; 113  :         while (1)
; 114  :           {
; 115  :             if (num_needed <= bytes_available)

	mov	eax, DWORD PTR _bp$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _num_needed$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, 58					; 0000003aH
	mov	DWORD PTR _this$1$[ebp], edi
	mov	edx, DWORD PTR [edi+4]
	sub	esi, edx
	add	edx, 6
	add	edx, DWORD PTR [edi]
	cmp	ebx, esi
	jle	SHORT $LN19@get_bytes
$LL2@get_bytes:

; 120  :                 return bp;
; 121  :               }
; 122  :             num_needed -= bytes_available;

	sub	ebx, esi

; 123  :             for (; bytes_available > 4; bytes_available-=4, sp+=4, bp+=4)

	cmp	esi, 4
	jle	SHORT $LN7@get_bytes

; 120  :                 return bp;
; 121  :               }
; 122  :             num_needed -= bytes_available;

	lea	edi, DWORD PTR [esi-5]
	shr	edi, 2
	inc	edi

; 123  :             for (; bytes_available > 4; bytes_available-=4, sp+=4, bp+=4)

	mov	ecx, edi
	neg	ecx
	lea	esi, DWORD PTR [esi+ecx*4]
	npad	6
$LL8@get_bytes:

; 124  :               { bp[0] = sp[0]; bp[1] = sp[1]; bp[2] = sp[2]; bp[3] = sp[3]; }

	movzx	ecx, BYTE PTR [edx]
	mov	BYTE PTR [eax], cl
	movzx	ecx, BYTE PTR [edx+1]
	mov	BYTE PTR [eax+1], cl
	movzx	ecx, BYTE PTR [edx+2]
	mov	BYTE PTR [eax+2], cl
	movzx	ecx, BYTE PTR [edx+3]
	add	edx, 4
	mov	BYTE PTR [eax+3], cl
	add	eax, 4
	sub	edi, 1
	jne	SHORT $LL8@get_bytes
	mov	edi, DWORD PTR _this$1$[ebp]
$LN7@get_bytes:

; 125  :             for(; bytes_available > 0; bytes_available--)

	test	esi, esi
	jle	SHORT $LN10@get_bytes
	sub	edx, eax
	npad	2
$LL11@get_bytes:

; 126  :               *(bp++) = *(sp++);

	mov	cl, BYTE PTR [edx+eax]
	dec	esi
	mov	BYTE PTR [eax], cl
	inc	eax
	test	esi, esi
	jg	SHORT $LL11@get_bytes
$LN10@get_bytes:

; 127  :             current_buf = current_buf->next;   assert(current_buf != NULL);

	mov	ecx, DWORD PTR [edi]

; 128  :             buf_pos = 0;  sp=current_buf->buf;
; 129  :             bytes_available = KD_CODE_BUFFER_LEN;

	mov	esi, 58					; 0000003aH
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edi], ecx
	mov	DWORD PTR [edi+4], 0
	lea	edx, DWORD PTR [ecx+6]
	cmp	ebx, esi
	jg	SHORT $LL2@get_bytes
$LN19@get_bytes:

; 116  :               {
; 117  :                 buf_pos += num_needed;

	add	DWORD PTR [edi+4], ebx

; 118  :                 while (num_needed--)

	test	ebx, ebx
	je	SHORT $LN23@get_bytes
	npad	5
$LL4@get_bytes:

; 119  :                   *(bp++) = *(sp++);

	mov	cl, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx+1]
	mov	BYTE PTR [eax], cl
	inc	eax
	sub	ebx, 1
	jne	SHORT $LL4@get_bytes
$LN23@get_bytes:
	pop	edi
	pop	esi
	pop	ebx

; 130  :           }
; 131  :       }

	mov	esp, ebp
	pop	ebp
	ret	8
?get_bytes@kd_block_reader@@QAEPAEPAEH@Z ENDP		; kd_block_reader::get_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?get_address@kd_block_reader@@QAEPAEXZ
_TEXT	SEGMENT
?get_address@kd_block_reader@@QAEPAEXZ PROC		; kd_block_reader::get_address, COMDAT
; _this$ = ecx

; 99   :       {

	push	esi
	mov	esi, ecx

; 100  :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer

	mov	eax, DWORD PTR [esi+4]
	neg	eax
	and	eax, 3

; 101  :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer

	add	eax, 4
	add	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+4], eax

; 102  :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	eax, 58					; 0000003aH
	jle	SHORT $LN2@get_addres

; 103  :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
$LN2@get_addres:

; 104  :             assert(current_buf != NULL); }
; 105  :         return ((kdu_byte **)(current_buf->buf+buf_pos))[-1];

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	pop	esi
	mov	eax, DWORD PTR [ecx+eax+2]

; 106  :       }

	ret	0
?get_address@kd_block_reader@@QAEPAEXZ ENDP		; kd_block_reader::get_address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?get_word@kd_block_reader@@QAEHXZ
_TEXT	SEGMENT
?get_word@kd_block_reader@@QAEHXZ PROC			; kd_block_reader::get_word, COMDAT
; _this$ = ecx

; 90   :       {

	push	esi
	mov	esi, ecx

; 91   :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	mov	eax, DWORD PTR [esi+4]
	and	eax, 1

; 92   :         buf_pos += 2; // Advance the buffer pointer

	add	eax, 2
	add	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+4], eax

; 93   :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	eax, 58					; 0000003aH
	jle	SHORT $LN2@get_word

; 94   :           { buf_pos=2; current_buf=current_buf->next;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], 2
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
$LN2@get_word:

; 95   :             assert(current_buf != NULL); }
; 96   :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	pop	esi
	movzx	eax, WORD PTR [ecx+eax+4]

; 97   :       }

	ret	0
?get_word@kd_block_reader@@QAEHXZ ENDP			; kd_block_reader::get_word
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?get_byte@kd_block_reader@@QAEEXZ
_TEXT	SEGMENT
?get_byte@kd_block_reader@@QAEEXZ PROC			; kd_block_reader::get_byte, COMDAT
; _this$ = ecx

; 83   :       {

	mov	edx, ecx

; 84   :         if (buf_pos==KD_CODE_BUFFER_LEN)

	cmp	DWORD PTR [edx+4], 58			; 0000003aH
	jne	SHORT $LN2@get_byte

; 85   :           { buf_pos=0; current_buf=current_buf->next;

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN2@get_byte:

; 86   :             assert(current_buf != NULL); }
; 87   :         return current_buf->buf[buf_pos++];

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx]
	mov	al, BYTE PTR [ecx+eax+6]
	inc	ecx
	mov	DWORD PTR [edx+4], ecx

; 88   :       }

	ret	0
?get_byte@kd_block_reader@@QAEEXZ ENDP			; kd_block_reader::get_byte
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ??0kd_block_reader@@QAE@PAUkd_code_buffer@@@Z
_TEXT	SEGMENT
_start$ = 8						; size = 4
??0kd_block_reader@@QAE@PAUkd_code_buffer@@@Z PROC	; kd_block_reader::kd_block_reader, COMDAT
; _this$ = ecx

; 80   :     kd_block_reader(kd_code_buffer *start)

	push	ebp
	mov	ebp, esp

; 81   :       { current_buf = start; buf_pos = 0; }

	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	pop	ebp
	ret	4
??0kd_block_reader@@QAE@PAUkd_code_buffer@@@Z ENDP	; kd_block_reader::kd_block_reader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?skip_word@kd_block@@AAEXXZ
_TEXT	SEGMENT
?skip_word@kd_block@@AAEXXZ PROC			; kd_block::skip_word, COMDAT
; _this$ = ecx

; 3891 :         buf_pos += 2 + (buf_pos & 1); // Align and advance the buffer pointer

	mov	dl, BYTE PTR [ecx+8]
	and	dl, 1
	add	dl, 2
	add	dl, BYTE PTR [ecx+8]
	mov	BYTE PTR [ecx+8], dl

; 3892 :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	dl, 58					; 0000003aH
	jbe	SHORT $LN2@skip_word

; 3893 :           { buf_pos=2; current_buf=current_buf->next;

	mov	eax, DWORD PTR [ecx+4]
	mov	BYTE PTR [ecx+8], 2
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
$LN2@skip_word:

; 3894 :             assert(current_buf != NULL); }
; 3895 :       }

	ret	0
?skip_word@kd_block@@AAEXXZ ENDP			; kd_block::skip_word
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_word@kd_block@@AAEHXZ
_TEXT	SEGMENT
?get_word@kd_block@@AAEHXZ PROC				; kd_block::get_word, COMDAT
; _this$ = ecx

; 3872 :       {

	push	esi
	mov	esi, ecx

; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	mov	dl, BYTE PTR [esi+8]
	and	dl, 1

; 3874 :         buf_pos += 2; // Advance the buffer pointer

	add	dl, 2
	add	dl, BYTE PTR [esi+8]
	mov	BYTE PTR [esi+8], dl

; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	dl, 58					; 0000003aH
	jbe	SHORT $LN2@get_word

; 3876 :           { buf_pos=2; current_buf=current_buf->next;

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [esi+8], 2
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+4], eax
$LN2@get_word:

; 3877 :             assert(current_buf != NULL); }
; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	movzx	ecx, BYTE PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	pop	esi
	movzx	eax, WORD PTR [eax+ecx+4]

; 3879 :       }

	ret	0
?get_word@kd_block@@AAEHXZ ENDP				; kd_block::get_word
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?put_word@kd_block@@AAEXHPAVkd_thread_buf_server@@@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
_buf_server$ = 12					; size = 4
?put_word@kd_block@@AAEXHPAVkd_thread_buf_server@@@Z PROC ; kd_block::put_word, COMDAT
; _this$ = ecx

; 3848 :       {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 3849 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	mov	dl, BYTE PTR [esi+8]
	and	dl, 1
	add	dl, BYTE PTR [esi+8]
	mov	BYTE PTR [esi+8], dl

; 3850 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))

	cmp	dl, 56					; 00000038H
	jbe	SHORT $LN2@put_word
	push	edi

; 370  :         if (head == NULL) augment_local_store(false);

	mov	edi, DWORD PTR _buf_server$[ebp]

; 3851 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	BYTE PTR [esi+8], 0

; 370  :         if (head == NULL) augment_local_store(false);

	cmp	DWORD PTR [edi+16], 0
	jne	SHORT $LN5@put_word
	push	0
	mov	ecx, edi
	call	?augment_local_store@kd_thread_buf_server@@QAEX_N@Z ; kd_thread_buf_server::augment_local_store
$LN5@put_word:

; 371  :         kd_code_buffer *result = head;

	mov	ecx, DWORD PTR [edi+16]

; 372  :         if ((head = result->next) == NULL)

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+16], eax
	test	eax, eax
	jne	SHORT $LN6@put_word

; 373  :           tail = NULL;

	mov	DWORD PTR [edi+20], eax
$LN6@put_word:

; 374  :         result->next = NULL;

	mov	DWORD PTR [ecx], 0

; 375  :         num_available_buffers--;

	dec	DWORD PTR [edi+8]

; 3851 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [esi+4], ecx
$LN2@put_word:

; 3852 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;

	movzx	edx, BYTE PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	mov	ax, WORD PTR _val$[ebp]
	mov	WORD PTR [ecx+edx+6], ax

; 3853 :         buf_pos += 2;

	add	BYTE PTR [esi+8], 2
	pop	esi

; 3854 :       }

	pop	ebp
	ret	8
?put_word@kd_block@@AAEXHPAVkd_thread_buf_server@@@Z ENDP ; kd_block::put_word
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?put_word@kd_block@@AAEXHPAVkd_buf_server@@@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
_buf_server$ = 12					; size = 4
?put_word@kd_block@@AAEXHPAVkd_buf_server@@@Z PROC	; kd_block::put_word, COMDAT
; _this$ = ecx

; 3824 :       {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	mov	dl, BYTE PTR [esi+8]
	and	dl, 1
	add	dl, BYTE PTR [esi+8]
	mov	BYTE PTR [esi+8], dl

; 3826 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))

	cmp	dl, 56					; 00000038H
	jbe	SHORT $LN2@put_word

; 3827 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	ecx, DWORD PTR _buf_server$[ebp]
	mov	BYTE PTR [esi+8], 0
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [esi+4], eax
$LN2@put_word:

; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;

	movzx	edx, BYTE PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	mov	ax, WORD PTR _val$[ebp]
	mov	WORD PTR [ecx+edx+6], ax

; 3829 :         buf_pos += 2;

	add	BYTE PTR [esi+8], 2
	pop	esi

; 3830 :       }

	pop	ebp
	ret	8
?put_word@kd_block@@AAEXHPAVkd_buf_server@@@Z ENDP	; kd_block::put_word
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?put_byte@kd_block@@AAEXEPAVkd_buf_server@@@Z
_TEXT	SEGMENT
_val$ = 8						; size = 1
_buf_server$ = 12					; size = 4
?put_byte@kd_block@@AAEXEPAVkd_buf_server@@@Z PROC	; kd_block::put_byte, COMDAT
; _this$ = ecx

; 3817 :       {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 3818 :         assert(current_buf != NULL);
; 3819 :         if (buf_pos==KD_CODE_BUFFER_LEN)

	cmp	BYTE PTR [esi+8], 58			; 0000003aH
	jne	SHORT $LN2@put_byte

; 3820 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	ecx, DWORD PTR _buf_server$[ebp]
	mov	BYTE PTR [esi+8], 0
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [esi+4], eax
$LN2@put_byte:

; 3821 :         current_buf->buf[buf_pos++] = val;

	movzx	edx, BYTE PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	mov	al, BYTE PTR _val$[ebp]
	mov	BYTE PTR [ecx+edx+6], al
	inc	BYTE PTR [esi+8]
	pop	esi

; 3822 :       }

	pop	ebp
	ret	8
?put_byte@kd_block@@AAEXEPAVkd_buf_server@@@Z ENDP	; kd_block::put_byte
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?start_buffering@kd_block@@AAEXPAVkd_thread_buf_server@@@Z
_TEXT	SEGMENT
_buf_server$ = 8					; size = 4
?start_buffering@kd_block@@AAEXPAVkd_thread_buf_server@@@Z PROC ; kd_block::start_buffering, COMDAT
; _this$ = ecx

; 3814 :       { assert(first_buf == NULL);

	push	ebp
	mov	ebp, esp
	push	esi

; 370  :         if (head == NULL) augment_local_store(false);

	mov	esi, DWORD PTR _buf_server$[ebp]
	push	edi

; 3814 :       { assert(first_buf == NULL);

	mov	edi, ecx

; 370  :         if (head == NULL) augment_local_store(false);

	cmp	DWORD PTR [esi+16], 0
	jne	SHORT $LN4@start_buff
	push	0
	mov	ecx, esi
	call	?augment_local_store@kd_thread_buf_server@@QAEX_N@Z ; kd_thread_buf_server::augment_local_store
$LN4@start_buff:

; 371  :         kd_code_buffer *result = head;

	mov	ecx, DWORD PTR [esi+16]

; 372  :         if ((head = result->next) == NULL)

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+16], eax
	test	eax, eax
	jne	SHORT $LN5@start_buff

; 373  :           tail = NULL;

	mov	DWORD PTR [esi+20], eax
$LN5@start_buff:

; 374  :         result->next = NULL;

	mov	DWORD PTR [ecx], 0

; 375  :         num_available_buffers--;

	dec	DWORD PTR [esi+8]

; 3815 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }

	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [edi], ecx
	mov	BYTE PTR [edi+8], 0
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?start_buffering@kd_block@@AAEXPAVkd_thread_buf_server@@@Z ENDP ; kd_block::start_buffering
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?start_buffering@kd_block@@AAEXPAVkd_buf_server@@@Z
_TEXT	SEGMENT
_buf_server$ = 8					; size = 4
?start_buffering@kd_block@@AAEXPAVkd_buf_server@@@Z PROC ; kd_block::start_buffering, COMDAT
; _this$ = ecx

; 3811 :       { assert(first_buf == NULL);

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }

	mov	ecx, DWORD PTR _buf_server$[ebp]
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], eax
	mov	BYTE PTR [esi+8], 0
	pop	esi
	pop	ebp
	ret	4
?start_buffering@kd_block@@AAEXPAVkd_buf_server@@@Z ENDP ; kd_block::start_buffering
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?restore_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z
_TEXT	SEGMENT
_size$2$ = -4						; size = 4
_node$ = 8						; size = 4
_size$ = 12						; size = 8
_y$1$ = 16						; size = 4
_x$ = 16						; size = 4
?restore_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z PROC ; kd_block::restore_output_tree, COMDAT

; 1200 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 1201 :   bool leaf_node = true;
; 1202 :   int x, y;
; 1203 : 
; 1204 :   if ((size.x == 0) || (size.y == 0))

	mov	esi, DWORD PTR _size$[ebp+4]
	mov	cl, 1
	test	esi, esi
	je	$LN3@restore_ou
	mov	edx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$2$[ebp], edx
	test	edx, edx
	je	$LN3@restore_ou
	mov	eax, DWORD PTR _node$[ebp]
	push	ebx
	push	edi
	mov	edi, DWORD PTR _x$[ebp]
$LL4@restore_ou:

; 1205 :     return;
; 1206 :   do {
; 1207 :       if (leaf_node)
; 1208 :         {
; 1209 :           for (y=0; y < size.y; y++)

	xor	ebx, ebx
	test	cl, cl
	je	SHORT $LN19@restore_ou
	test	edx, edx
	jle	SHORT $LN12@restore_ou
	mov	ebx, edx
	mov	DWORD PTR _y$1$[ebp], edx
$LL7@restore_ou:

; 1210 :             for (x=0; x < size.x; x++, node++)

	xor	edi, edi
	test	esi, esi
	jle	SHORT $LN5@restore_ou
	mov	edx, esi
	mov	edi, esi
$LL10@restore_ou:

; 1211 :               node->beta = node->save_beta;

	mov	cl, BYTE PTR [eax+12]
	mov	BYTE PTR [eax+16], cl
	add	eax, 24					; 00000018H
	sub	edx, 1
	jne	SHORT $LL10@restore_ou
$LN5@restore_ou:

; 1205 :     return;
; 1206 :   do {
; 1207 :       if (leaf_node)
; 1208 :         {
; 1209 :           for (y=0; y < size.y; y++)

	sub	ebx, 1
	jne	SHORT $LL7@restore_ou

; 1212 :         }
; 1213 :       else

	jmp	SHORT $LN42@restore_ou
$LN19@restore_ou:

; 1214 :         { // Only restore non-leaf node state.
; 1215 :           for (y=0; y < size.y; y++)

	test	edx, edx
	jle	SHORT $LN12@restore_ou
	mov	ebx, edx
	mov	DWORD PTR _y$1$[ebp], edx
	npad	1
$LL13@restore_ou:

; 1216 :             for (x=0; x < size.x; x++, node++)

	xor	edi, edi
	test	esi, esi
	jle	SHORT $LN11@restore_ou
	mov	edx, esi
	mov	edi, esi
	npad	6
$LL16@restore_ou:

; 1217 :               {
; 1218 :                 node->layer_w = node->save_layer_w;

	movzx	ecx, WORD PTR [eax]
	mov	WORD PTR [eax+12], cx

; 1219 :                 node->layer_wbar = node->save_layer_wbar;

	movzx	ecx, WORD PTR [eax+4]
	mov	WORD PTR [eax+14], cx

; 1220 :                 node->msbs_wbar = node->save_msbs_wbar;

	mov	cl, BYTE PTR [eax+8]
	mov	BYTE PTR [eax+16], cl
	add	eax, 24					; 00000018H
	sub	edx, 1
	jne	SHORT $LL16@restore_ou
$LN11@restore_ou:

; 1214 :         { // Only restore non-leaf node state.
; 1215 :           for (y=0; y < size.y; y++)

	sub	ebx, 1
	jne	SHORT $LL13@restore_ou
$LN42@restore_ou:
	mov	ebx, DWORD PTR _y$1$[ebp]
	mov	edx, DWORD PTR _size$2$[ebp]
$LN12@restore_ou:

; 1221 :               }
; 1222 :         }
; 1223 :       size.y = (size.y+1)>>1;

	inc	edx

; 1224 :       size.x = (size.x+1)>>1;

	inc	esi
	sar	edx, 1

; 1225 :       leaf_node = false;

	xor	cl, cl
	sar	esi, 1
	mov	DWORD PTR _size$2$[ebp], edx

; 1226 :     } while ((x > 1) || (y > 1));

	cmp	edi, 1
	jg	SHORT $LL4@restore_ou
	cmp	ebx, 1
	jg	$LL4@restore_ou
	pop	edi
	pop	ebx
$LN3@restore_ou:
	pop	esi

; 1227 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?restore_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z ENDP ; kd_block::restore_output_tree
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?save_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z
_TEXT	SEGMENT
_y$1$ = -24						; size = 4
_size$1$ = -20						; size = 4
_size$2$ = -16						; size = 4
tv509 = -12						; size = 4
_x$ = -8						; size = 4
tv513 = -2						; size = 1
_leaf_node$1$ = -1					; size = 1
_node$ = 8						; size = 4
_size$ = 12						; size = 8
?save_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z PROC ; kd_block::save_output_tree, COMDAT

; 1156 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1157 :   bool leaf_node = true;
; 1158 :   int x, y;
; 1159 : 
; 1160 :   if ((size.x == 0) || (size.y == 0))

	mov	edx, DWORD PTR _size$[ebp+4]
	mov	al, 1
	mov	BYTE PTR _leaf_node$1$[ebp], al
	mov	DWORD PTR _size$1$[ebp], edx
	test	edx, edx
	je	$LN3@save_outpu
	push	edi
	mov	edi, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$2$[ebp], edi
	test	edi, edi
	je	$LN34@save_outpu
	mov	ecx, DWORD PTR _node$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _x$[ebp]
$LL4@save_outpu:

; 1161 :     return;
; 1162 :   do {
; 1163 :       for (y=0; y < size.y; y++)

	xor	ebx, ebx
	test	edi, edi
	jle	$LN6@save_outpu
	mov	ebx, edi
	mov	DWORD PTR _y$1$[ebp], edi
	mov	DWORD PTR tv509[ebp], ebx
$LL7@save_outpu:

; 1164 :         for (x=0; x < size.x; x++, node++)

	xor	esi, esi
	test	edx, edx
	jle	$LN5@save_outpu
	mov	edi, edx
	mov	DWORD PTR _x$[ebp], edx
$LL10@save_outpu:

; 1165 :           {
; 1166 :             if (leaf_node)

	test	al, al
	je	SHORT $LN15@save_outpu

; 1167 :               { // Commit the pending new coding passes.
; 1168 :                 int buf_pos = node->buf_pos;
; 1169 :                 buf_pos += ((int) node->pending_new_passes)<<2;

	movzx	edx, BYTE PTR [ecx+14]
	movzx	eax, BYTE PTR [ecx+8]
	lea	ebx, DWORD PTR [eax+edx*4]

; 1170 :                 while (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	ebx, 58					; 0000003aH
	jle	SHORT $LN12@save_outpu
	mov	esi, DWORD PTR [ecx+4]
	lea	edx, DWORD PTR [ebx-59]
	mov	eax, -1925330167			; 8d3dcb09H
	mul	edx
	shr	edx, 5
	inc	edx
	imul	eax, edx, -58
	add	ebx, eax
	npad	5
$LL11@save_outpu:

; 1171 :                   {
; 1172 :                     node->current_buf = node->current_buf->next;

	mov	esi, DWORD PTR [esi]
	mov	DWORD PTR [ecx+4], esi
	sub	edx, 1
	jne	SHORT $LL11@save_outpu
$LN12@save_outpu:

; 1173 :                     assert(node->current_buf != NULL);
; 1174 :                     buf_pos -= KD_CODE_BUFFER_LEN;
; 1175 :                   }
; 1176 :                 node->buf_pos = (kdu_byte) buf_pos;
; 1177 :                 node->pass_idx += node->pending_new_passes;

	mov	al, BYTE PTR [ecx+14]
	add	BYTE PTR [ecx+11], al

; 1178 :                 node->pending_new_passes = 0;
; 1179 :                 node->save_beta = node->beta;

	movzx	eax, BYTE PTR [ecx+16]
	mov	BYTE PTR [ecx+8], bl
	mov	BYTE PTR [ecx+14], 0
	mov	BYTE PTR [ecx+12], al

; 1180 :               }
; 1181 :             else

	jmp	SHORT $LN8@save_outpu
$LN15@save_outpu:

; 1182 :               {
; 1183 :                 node->save_layer_w = node->layer_w;

	movzx	eax, WORD PTR [ecx+12]
	mov	WORD PTR [ecx], ax

; 1184 :                 node->save_layer_wbar = node->layer_wbar;

	movzx	eax, WORD PTR [ecx+14]
	mov	WORD PTR [ecx+4], ax

; 1185 :                 node->save_msbs_wbar = node->msbs_wbar;

	mov	al, BYTE PTR [ecx+16]
	mov	BYTE PTR [ecx+8], al
$LN8@save_outpu:

; 1164 :         for (x=0; x < size.x; x++, node++)

	mov	al, BYTE PTR _leaf_node$1$[ebp]
	add	ecx, 24					; 00000018H
	sub	edi, 1
	jne	SHORT $LL10@save_outpu
	mov	edx, DWORD PTR _size$1$[ebp]
	mov	ebx, DWORD PTR tv509[ebp]
	mov	esi, DWORD PTR _x$[ebp]
$LN5@save_outpu:

; 1161 :     return;
; 1162 :   do {
; 1163 :       for (y=0; y < size.y; y++)

	sub	ebx, 1
	mov	DWORD PTR tv509[ebp], ebx
	jne	$LL7@save_outpu
	mov	edi, DWORD PTR _size$2$[ebp]
	mov	ebx, DWORD PTR _y$1$[ebp]
$LN6@save_outpu:

; 1186 :               }
; 1187 :           }
; 1188 :       size.y = (size.y+1)>>1;

	inc	edi

; 1189 :       size.x = (size.x+1)>>1;

	inc	edx
	sar	edi, 1

; 1190 :       leaf_node = false;

	xor	al, al
	sar	edx, 1
	mov	DWORD PTR _size$2$[ebp], edi
	mov	DWORD PTR _size$[ebp], edi
	mov	DWORD PTR _size$1$[ebp], edx
	mov	DWORD PTR _size$[ebp+4], edx
	mov	BYTE PTR _leaf_node$1$[ebp], al

; 1191 :     } while ((x > 1) || (y > 1));

	cmp	esi, 1
	jg	$LL4@save_outpu
	cmp	ebx, 1
	jg	$LL4@save_outpu
	pop	esi
	pop	ebx
$LN34@save_outpu:
	pop	edi
$LN3@save_outpu:

; 1192 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?save_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z ENDP ; kd_block::save_output_tree
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?reset_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z
_TEXT	SEGMENT
_y$1$ = -4						; size = 4
_node$ = 8						; size = 4
_size$ = 12						; size = 8
_x$ = 16						; size = 4
?reset_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z PROC ; kd_block::reset_output_tree, COMDAT

; 1121 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 1122 :   bool leaf_node = true;
; 1123 :   int x, y;
; 1124 : 
; 1125 :   if ((size.x == 0) || (size.y == 0))

	mov	esi, DWORD PTR _size$[ebp+4]
	mov	cl, 1
	test	esi, esi
	je	$LN3@reset_outp
	push	edi
	mov	edi, DWORD PTR _size$[ebp]
	test	edi, edi
	je	SHORT $LN28@reset_outp
	mov	eax, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	push	ebx
$LL4@reset_outp:

; 1126 :     return;
; 1127 :   do {
; 1128 :       if (leaf_node)

	test	cl, cl
	je	SHORT $LN13@reset_outp

; 1129 :         {
; 1130 :           x = size.x; y = size.y;
; 1131 :           node += x*y;

	mov	ecx, edi
	mov	edx, esi
	imul	ecx, esi
	mov	ebx, edi
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [eax+ecx*8]

; 1132 :         }
; 1133 :       else

	jmp	SHORT $LN6@reset_outp
$LN13@reset_outp:

; 1134 :         {
; 1135 :           for (y=0; y < size.y; y++)

	xor	ebx, ebx
	mov	DWORD PTR _y$1$[ebp], ebx
	test	edi, edi
	jle	SHORT $LN6@reset_outp
	npad	1
$LL7@reset_outp:

; 1136 :             for (x=0; x < size.x; x++, node++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN5@reset_outp
	npad	10
$LL10@reset_outp:

; 1137 :               {
; 1138 :                 node->msbs_wbar = 0;

	mov	BYTE PTR [eax+16], 0
	inc	edx

; 1139 :                 node->layer_wbar = 0;
; 1140 :                 node->msbs_w = 0xFF;
; 1141 :                 node->layer_w = 0xFFFF;

	mov	DWORD PTR [eax+12], 65535		; 0000ffffH
	xor	ecx, ecx
	mov	BYTE PTR [eax+9], 255			; 000000ffH
	add	eax, 24					; 00000018H
	mov	esi, DWORD PTR _size$[ebp+4]
	cmp	edx, esi
	jl	SHORT $LL10@reset_outp

; 1136 :             for (x=0; x < size.x; x++, node++)

	mov	edi, DWORD PTR _size$[ebp]
	mov	ebx, DWORD PTR _y$1$[ebp]
$LN5@reset_outp:

; 1134 :         {
; 1135 :           for (y=0; y < size.y; y++)

	inc	ebx
	mov	DWORD PTR _y$1$[ebp], ebx
	cmp	ebx, edi
	jl	SHORT $LL7@reset_outp
$LN6@reset_outp:

; 1142 :               }
; 1143 :         }
; 1144 :       size.y = (size.y+1)>>1;

	inc	edi

; 1145 :       size.x = (size.x+1)>>1;

	inc	esi
	sar	edi, 1

; 1146 :       leaf_node = false;

	xor	cl, cl
	sar	esi, 1
	mov	DWORD PTR _size$[ebp], edi
	mov	DWORD PTR _size$[ebp+4], esi

; 1147 :     } while ((x > 1) || (y > 1));

	cmp	edx, 1
	jg	SHORT $LL4@reset_outp
	cmp	ebx, 1
	jg	SHORT $LL4@reset_outp
	pop	ebx
$LN28@reset_outp:
	pop	edi
$LN3@reset_outp:
	pop	esi

; 1148 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?reset_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z ENDP ; kd_block::reset_output_tree
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?build_tree@kd_block@@SAPAV1@Ukdu_coords@@AAPAE@Z
_TEXT	SEGMENT
_blocks$1$ = -40					; size = 4
_next_size$2$ = -36					; size = 4
tv225 = -32						; size = 4
tv232 = -28						; size = 4
_next$1$ = -24						; size = 4
_next_size$1$ = -20					; size = 4
_level_size$4$ = -16					; size = 4
_y$1$ = -12						; size = 4
_level_idx$1$ = -8					; size = 4
_num_levels$1$ = -4					; size = 4
_size$ = 8						; size = 8
_mem_block$ = 16					; size = 4
?build_tree@kd_block@@SAPAV1@Ukdu_coords@@AAPAE@Z PROC	; kd_block::build_tree, COMDAT

; 1067 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1068 :   int level_nodes, total_nodes, level_idx, num_levels;
; 1069 :   kdu_coords level_size;
; 1070 : 
; 1071 :   total_nodes = level_nodes = size.x*size.y;

	mov	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _size$[ebp+4]
	push	ebx
	push	esi
	mov	esi, ecx

; 1072 :   assert(total_nodes >= 0);
; 1073 :   level_size = size;
; 1074 :   num_levels = 1;

	mov	ebx, 1
	imul	esi, edx
	mov	DWORD PTR _num_levels$1$[ebp], ebx

; 1075 :   while (level_nodes > 1)

	cmp	esi, ebx
	jle	SHORT $LN3@build_tree
	npad	1
$LL2@build_tree:

; 1076 :     {
; 1077 :       level_size.x = (level_size.x+1)>>1;
; 1078 :       level_size.y = (level_size.y+1)>>1;

	inc	ecx
	inc	edx
	sar	ecx, 1

; 1079 :       level_nodes = level_size.x*level_size.y;
; 1080 :       total_nodes += level_nodes;
; 1081 :       num_levels++;

	inc	ebx
	sar	edx, 1
	mov	eax, ecx
	imul	eax, edx
	add	esi, eax
	cmp	eax, 1
	jg	SHORT $LL2@build_tree
	mov	DWORD PTR _num_levels$1$[ebp], ebx
$LN3@build_tree:

; 1082 :     }
; 1083 :   if (total_nodes == 0)

	test	esi, esi
	jne	SHORT $LN13@build_tree

; 1084 :     return NULL;

	pop	esi
	xor	eax, eax
	pop	ebx

; 1113 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@build_tree:

; 1085 : 
; 1086 :   kd_block *blocks = (kd_block *) mem_block;

	mov	edx, DWORD PTR _mem_block$[ebp]

; 1087 :   mem_block += total_nodes * sizeof(kd_block);

	lea	ecx, DWORD PTR [esi+esi*2]
	push	edi
	shl	ecx, 3

; 1088 :   memset(blocks,0,(size_t)(sizeof(kd_block)*total_nodes));

	push	ecx
	mov	ebx, DWORD PTR [edx]
	push	0
	push	ebx
	mov	DWORD PTR _blocks$1$[ebp], ebx
	lea	eax, DWORD PTR [ecx+ebx]
	mov	DWORD PTR [edx], eax
	call	_memset

; 1089 :   kd_block *node, *next;
; 1090 :   kdu_coords next_size;
; 1091 :   for (node=blocks, level_size=size, level_idx=0;

	mov	edx, DWORD PTR _size$[ebp]

; 1092 :        level_idx < num_levels;

	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _level_size$4$[ebp], edx
	mov	edi, ebx
	mov	ebx, DWORD PTR _size$[ebp+4]
	mov	DWORD PTR _level_idx$1$[ebp], ecx
	cmp	DWORD PTR _num_levels$1$[ebp], ecx
	jle	$LN5@build_tree
	npad	5
$LL6@build_tree:

; 1094 :     {
; 1095 :       next_size.x = (level_size.x+1)>>1;

	lea	eax, DWORD PTR [ebx+1]

; 1096 :       next_size.y = (level_size.y+1)>>1;
; 1097 :       level_nodes = level_size.x*level_size.y;
; 1098 :       next = node+level_nodes;
; 1099 : 
; 1100 :       for (int y=0; y < level_size.y; y++)

	xor	esi, esi
	sar	eax, 1
	mov	DWORD PTR _next_size$1$[ebp], eax
	lea	eax, DWORD PTR [edx+1]
	sar	eax, 1
	mov	DWORD PTR _next_size$2$[ebp], eax
	mov	eax, edx
	imul	eax, ebx
	mov	DWORD PTR _y$1$[ebp], esi
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [edi+eax*8]
	mov	DWORD PTR _next$1$[ebp], eax
	test	edx, edx
	jle	SHORT $LN4@build_tree
$LL9@build_tree:

; 1101 :         for (int x=0; x < level_size.x; x++, node++)

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN7@build_tree
	mov	ecx, DWORD PTR _num_levels$1$[ebp]
	mov	edx, esi
	sar	edx, 1
	imul	edx, DWORD PTR _next_size$1$[ebp]
	dec	ecx
	mov	DWORD PTR tv232[ebp], ecx
	npad	4
$LL12@build_tree:

; 1102 :           {
; 1103 :             node->up_down = next + (y>>1)*next_size.x + (x>>1);

	mov	esi, DWORD PTR _next$1$[ebp]
	mov	ecx, eax
	sar	ecx, 1
	add	ecx, edx

; 1104 :             if (level_idx == (num_levels-1))

	mov	DWORD PTR tv225[ebp], 0
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR _level_idx$1$[ebp]
	cmp	esi, DWORD PTR tv232[ebp]
	cmove	ecx, DWORD PTR tv225[ebp]
	inc	eax
	mov	DWORD PTR [edi+20], ecx
	add	edi, 24					; 00000018H
	cmp	eax, ebx
	jl	SHORT $LL12@build_tree
	mov	esi, DWORD PTR _y$1$[ebp]
	mov	edx, DWORD PTR _level_size$4$[ebp]
$LN7@build_tree:

; 1096 :       next_size.y = (level_size.y+1)>>1;
; 1097 :       level_nodes = level_size.x*level_size.y;
; 1098 :       next = node+level_nodes;
; 1099 : 
; 1100 :       for (int y=0; y < level_size.y; y++)

	inc	esi
	mov	DWORD PTR _y$1$[ebp], esi
	cmp	esi, edx
	jl	SHORT $LL9@build_tree
	mov	ecx, DWORD PTR _level_idx$1$[ebp]
$LN4@build_tree:
	mov	edx, DWORD PTR _next_size$2$[ebp]

; 1093 :        level_idx++, level_size=next_size)

	inc	ecx
	mov	ebx, DWORD PTR _next_size$1$[ebp]
	mov	DWORD PTR _level_idx$1$[ebp], ecx
	mov	DWORD PTR _level_size$4$[ebp], edx
	cmp	ecx, DWORD PTR _num_levels$1$[ebp]
	jl	$LL6@build_tree
$LN5@build_tree:

; 1105 :               {
; 1106 :                 assert((x==0) && (y==0));
; 1107 :                 node->up_down = NULL;
; 1108 :               }
; 1109 :           }
; 1110 :     }
; 1111 :   assert(node == (blocks+total_nodes));
; 1112 :   return blocks;

	mov	eax, DWORD PTR _blocks$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 1113 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?build_tree@kd_block@@SAPAV1@Ukdu_coords@@AAPAE@Z ENDP	; kd_block::build_tree
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?write_body_bytes@kd_block@@QAEXPAVkdu_output@@@Z
_TEXT	SEGMENT
_this$1$ = -12						; size = 4
_new_bytes$1$ = -8					; size = 4
_scan$1$ = -4						; size = 4
_dest$ = 8						; size = 4
?write_body_bytes@kd_block@@QAEXPAVkdu_output@@@Z PROC	; kd_block::write_body_bytes, COMDAT
; _this$ = ecx

; 1031 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	DWORD PTR _this$1$[ebp], ebx

; 1032 :   if (temp_length == 0)

	movzx	esi, WORD PTR [ebx+18]
	test	si, si
	je	$LN1@write_body

; 1033 :     return;
; 1034 : 
; 1035 :   int pos = body_bytes_offset;

	movzx	ecx, WORD PTR [ebx+12]

; 1036 :   kd_code_buffer *scan = first_buf;

	mov	edx, DWORD PTR [ebx]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _scan$1$[ebp], edx

; 1037 :   while (pos >= KD_CODE_BUFFER_LEN)

	cmp	edi, 58					; 0000003aH
	jl	SHORT $LN3@write_body

; 1033 :     return;
; 1034 : 
; 1035 :   int pos = body_bytes_offset;

	mov	eax, -1925330167			; 8d3dcb09H
	mul	edi
	shr	edx, 5

; 1037 :   while (pos >= KD_CODE_BUFFER_LEN)

	imul	eax, edx, -58
	add	edi, eax
	mov	eax, DWORD PTR _scan$1$[ebp]
	npad	3
$LL2@write_body:

; 1038 :     {
; 1039 :       pos -= KD_CODE_BUFFER_LEN;
; 1040 :       scan = scan->next;

	mov	eax, DWORD PTR [eax]
	sub	edx, 1
	jne	SHORT $LL2@write_body
	mov	DWORD PTR _scan$1$[ebp], eax
	mov	edx, eax
$LN3@write_body:

; 1041 :       assert(scan != NULL);
; 1042 :     }
; 1043 :   int new_bytes = temp_length;
; 1044 :   assert((new_bytes+(int) body_bytes_offset) < (2<<16));
; 1045 :   body_bytes_offset += temp_length;

	lea	eax, DWORD PTR [ecx+esi]
	mov	WORD PTR [ebx+12], ax

; 1046 :   temp_length = 0;

	xor	eax, eax
	mov	WORD PTR [ebx+18], ax

; 1047 :   while (new_bytes > 0)

	mov	eax, esi
	test	eax, eax
	jle	$LN5@write_body
	mov	esi, DWORD PTR _dest$[ebp]
$LL4@write_body:

; 1048 :     {
; 1049 :       int xfer_bytes = KD_CODE_BUFFER_LEN-pos;

	mov	ebx, 58					; 0000003aH
	sub	ebx, edi

; 1050 :       assert((xfer_bytes > 0) && (scan != NULL));
; 1051 :       if (xfer_bytes > new_bytes)

	cmp	ebx, eax
	cmovg	ebx, eax

; 1052 :         xfer_bytes = new_bytes;
; 1053 :       new_bytes -= xfer_bytes;
; 1054 :       dest->write(scan->buf+pos,xfer_bytes);

	add	edi, 6
	sub	eax, ebx
	add	edi, edx
	mov	DWORD PTR _new_bytes$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 179  :         while (count > 0)

	test	ebx, ebx
	jle	SHORT $LN11@write_body
$LL10@write_body:

; 180  :           {
; 181  :             int xfer_bytes = (int)(end_buf - next_buf);

	mov	eax, DWORD PTR [esi+520]
	sub	eax, DWORD PTR [esi+516]

; 182  :             if (xfer_bytes == 0)

	jne	SHORT $LN14@write_body

; 183  :               { flush_buf(); xfer_bytes = (int)(end_buf - next_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi+520]
	sub	eax, DWORD PTR [esi+516]
$LN14@write_body:

; 184  :             xfer_bytes = (count < xfer_bytes)?count:xfer_bytes;

	cmp	ebx, eax
	cmovl	eax, ebx

; 185  :             count -= xfer_bytes;

	sub	ebx, eax

; 186  :             while (xfer_bytes--)

	test	eax, eax
	je	SHORT $LN21@write_body
	npad	4
$LL12@write_body:

; 187  :               *(next_buf++) = *(buf++);

	mov	edx, DWORD PTR [esi+516]
	mov	cl, BYTE PTR [edi]
	inc	edi
	mov	BYTE PTR [edx], cl
	inc	DWORD PTR [esi+516]
	sub	eax, 1
	jne	SHORT $LL12@write_body
$LN21@write_body:

; 179  :         while (count > 0)

	test	ebx, ebx
	jg	SHORT $LL10@write_body
	mov	edx, DWORD PTR _scan$1$[ebp]
	mov	eax, DWORD PTR _new_bytes$1$[ebp]
$LN11@write_body:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 1055 :       scan = scan->next;

	mov	edx, DWORD PTR [edx]

; 1056 :       pos = 0;

	xor	edi, edi
	mov	DWORD PTR _scan$1$[ebp], edx
	test	eax, eax
	jg	SHORT $LL4@write_body
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN5@write_body:

; 1057 :     }
; 1058 :   pending_new_passes = 0;

	mov	BYTE PTR [ebx+14], 0
	pop	edi
$LN1@write_body:
	pop	esi
	pop	ebx

; 1059 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?write_body_bytes@kd_block@@QAEXPAVkdu_output@@@Z ENDP	; kd_block::write_body_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?write_packet_header@kd_block@@QAEXAAVkd_header_out@@H_N@Z
_TEXT	SEGMENT
_val$3$ = -36						; size = 4
_val$2$ = -36						; size = 4
_bit$1$ = -32						; size = 4
_bit$1$ = -32						; size = 4
_save_current_buf$1$ = -32				; size = 4
_delta$1$ = -32						; size = 4
tv1164 = -32						; size = 4
_threshold$1$ = -28					; size = 4
tv1189 = -28						; size = 4
_new_passes$2$ = -24					; size = 4
_idx$1$ = -24						; size = 4
_new_passes$1$ = -20					; size = 4
_idx$2$ = -20						; size = 4
_length_bits$2$ = -16					; size = 4
_segment_bytes$2$ = -16					; size = 4
_prev$2$ = -16						; size = 4
_prev$2$ = -16						; size = 4
_length_bits$4$ = -12					; size = 4
_segment_bytes$1$ = -12					; size = 4
_segment_passes$1$ = -8					; size = 4
_this$1$ = -8						; size = 4
_byte$1$ = -2						; size = 1
_byte$1$ = -2						; size = 1
_byte$1$ = -2						; size = 1
_included$1$ = -2					; size = 1
_save_buf_pos$1$ = -1					; size = 1
_save_new_passes$1$ = -1				; size = 1
_head$ = 8						; size = 4
_layer_idx$ = 12					; size = 4
_byte$1$ = 15						; size = 1
_byte$1$ = 15						; size = 1
_all_term$1$ = 15					; size = 1
_threshold$1$ = 15					; size = 1
_simulate$ = 16						; size = 1
?write_packet_header@kd_block@@QAEXAAVkd_header_out@@H_N@Z PROC ; kd_block::write_packet_header, COMDAT
; _this$ = ecx

; 810  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 811  :   // Process inclusion information first
; 812  : 
; 813  :   bool included = (pending_new_passes > 0);

	mov	al, BYTE PTR [edi+14]
	test	al, al
	mov	BYTE PTR _save_new_passes$1$[ebp], al
	setne	cl

; 814  :   if (pass_idx == 0)

	cmp	BYTE PTR [edi+11], 0
	mov	BYTE PTR _included$1$[ebp], cl
	jne	$LN37@write_pack

; 815  :     { // First time inclusion.
; 816  :       assert((included && (layer_w < 0xFFFF)) ||
; 817  :              ((!included) && (layer_w == 0xFFFF)));
; 818  :       kdu_byte save_new_passes=pending_new_passes; // Shares layer_wbar storage
; 819  :       layer_wbar = (kdu_uint16) layer_idx;

	mov	ax, WORD PTR _layer_idx$[ebp]

; 820  :       kd_block *scan, *prev, *next;
; 821  : 
; 822  :       // Walk up to the root node in the tree.
; 823  :       scan=this; prev=NULL;

	xor	edx, edx
	mov	WORD PTR [edi+14], ax

; 824  :       while ((next=scan->up_down) != NULL)

	mov	eax, edi
	mov	ecx, DWORD PTR [eax+20]
	test	ecx, ecx
	je	SHORT $LN3@write_pack
	npad	7
$LL2@write_pack:

; 825  :         { scan->up_down=prev; prev=scan; scan=next; }

	mov	DWORD PTR [edi+20], edx
	mov	edx, edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [ecx+20]
	test	ecx, ecx
	jne	SHORT $LL2@write_pack
$LN3@write_pack:

; 826  :       scan->up_down = prev;
; 827  : 
; 828  :       // Walk back down the tree, performing the encoding steps.
; 829  : 
; 830  :       kdu_uint16 wbar_min = 0;
; 831  :       kdu_uint16 threshold = layer_wbar+1;
; 832  :       prev = NULL;

	mov	esi, DWORD PTR _head$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR [edi+20], edx
	mov	ax, WORD PTR [eax+14]
	inc	ax
	xor	ebx, ebx
	movzx	edx, ax
	mov	DWORD PTR _threshold$1$[ebp], edx
	mov	DWORD PTR _prev$2$[ebp], ebx
$LL4@write_pack:

; 833  :       while (scan != NULL)
; 834  :         {
; 835  :           if (scan->layer_wbar < wbar_min)

	cmp	WORD PTR [edi+14], cx
	jae	SHORT $LN123@write_pack

; 836  :             scan->layer_wbar = wbar_min;

	mov	WORD PTR [edi+14], cx
$LN123@write_pack:

; 837  :           while ((scan->layer_w >= scan->layer_wbar) &&

	mov	ax, WORD PTR [edi+12]
	cmp	ax, WORD PTR [edi+14]
	jb	$LN7@write_pack
	npad	1
$LL6@write_pack:
	movzx	eax, WORD PTR [edi+14]
	cmp	ax, dx
	jae	SHORT $LN178@write_pack

; 838  :                  (scan->layer_wbar < threshold))
; 839  :             {
; 840  :               scan->layer_wbar++;

	inc	eax

; 841  :               head.put_bit((scan->layer_w >= scan->layer_wbar)?0:1);

	cmp	WORD PTR [edi+12], ax
	mov	WORD PTR [edi+14], ax
	sbb	ecx, ecx
	neg	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3561 :         if (bits_left == 0)

	cmp	DWORD PTR [esi+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 841  :               head.put_bit((scan->layer_w >= scan->layer_wbar)?0:1);

	mov	DWORD PTR _bit$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3561 :         if (bits_left == 0)

	jne	SHORT $LN75@write_pack

; 3562 :           { if (out != NULL) out->put(byte);

	mov	ebx, DWORD PTR [esi+12]
	test	ebx, ebx
	je	SHORT $LN76@write_pack
	mov	al, BYTE PTR [esi]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [ebx+516]
	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN79@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _bit$1$[ebp]
$LN79@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
	mov	dl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], dl
	inc	DWORD PTR [ebx+516]
	mov	edx, DWORD PTR _threshold$1$[ebp]
$LN76@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3563 :             completed_bytes++;

	inc	DWORD PTR [esi+8]

; 3564 :             bits_left = (byte==0xFF)?7:8;

	xor	eax, eax
	cmp	BYTE PTR [esi], 255			; 000000ffH

; 3565 :             byte = 0; }

	mov	BYTE PTR [esi], 0
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+4], eax
$LN75@write_pack:

; 3566 :         byte += byte + bit;

	mov	al, BYTE PTR [esi]

; 3567 :         bits_left--;

	dec	DWORD PTR [esi+4]
	add	al, al
	add	al, cl
	mov	BYTE PTR [esi], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 837  :           while ((scan->layer_w >= scan->layer_wbar) &&

	mov	ax, WORD PTR [edi+12]
	cmp	ax, WORD PTR [edi+14]
	jae	SHORT $LL6@write_pack
$LN178@write_pack:
	mov	ebx, DWORD PTR _prev$2$[ebp]
$LN7@write_pack:

; 842  :             }
; 843  :           wbar_min =

	movzx	eax, WORD PTR [edi+14]
	movzx	ecx, WORD PTR [edi+12]
	cmp	cx, ax
	jb	SHORT $LN71@write_pack
	mov	ecx, eax
$LN71@write_pack:

; 844  :             (scan->layer_w<scan->layer_wbar)?scan->layer_w:scan->layer_wbar;
; 845  :           next=scan->up_down; scan->up_down=prev; prev=scan; scan=next;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [edi+20], ebx
	mov	ebx, edi
	mov	DWORD PTR _prev$2$[ebp], edi
	mov	edi, eax
	test	eax, eax
	jne	$LL4@write_pack

; 846  :         }
; 847  :       pending_new_passes = save_new_passes; // Finished using layer_wbar now

	mov	edi, DWORD PTR _this$1$[ebp]
	mov	al, BYTE PTR _save_new_passes$1$[ebp]
	mov	BYTE PTR [edi+14], al

; 848  :     }
; 849  :   else

	jmp	SHORT $LN38@write_pack
$LN37@write_pack:

; 850  :     { // Has been included at least once before
; 851  :       head.put_bit((included)?1:0);

	mov	esi, DWORD PTR _head$[ebp]
	xor	eax, eax
	test	cl, cl
	mov	ecx, esi
	setne	al
	push	eax
	call	?put_bit@kd_header_out@@QAEXH@Z		; kd_header_out::put_bit
$LN38@write_pack:

; 852  :     }
; 853  :   if (!included)

	cmp	BYTE PTR _included$1$[ebp], 0
	je	$LN67@write_pack

; 854  :     return;
; 855  : 
; 856  :   // If we get here, the code-block does contribute to the current layer.
; 857  : 
; 858  :   if (pass_idx == 0)

	cmp	BYTE PTR [edi+11], 0
	jne	$LN41@write_pack

; 859  :     { // First time contribution.  Need to get MSB's.
; 860  :       for (msbs_wbar=0; msbs_wbar <= msbs_w; )

	mov	BYTE PTR [edi+16], 0
	npad	4
$LL8@write_pack:

; 861  :         { // Run tag tree decoder.
; 862  :           kd_block *scan, *prev, *next;
; 863  : 
; 864  :           // Walk up to the root note in the tree.
; 865  :           scan=this; prev=NULL;
; 866  :           while ((next=scan->up_down) != NULL)

	mov	eax, DWORD PTR [edi+20]
	xor	ecx, ecx
	mov	ebx, edi
	test	eax, eax
	je	SHORT $LN12@write_pack
	npad	5
$LL11@write_pack:

; 867  :             { scan->up_down=prev; prev=scan; scan=next; }

	mov	DWORD PTR [ebx+20], ecx
	mov	ecx, ebx
	mov	ebx, eax
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL11@write_pack
$LN12@write_pack:

; 868  :           scan->up_down = prev;

	mov	DWORD PTR [ebx+20], ecx

; 869  : 
; 870  :           // Walk back down the tree, performing the encoding steps.
; 871  :           kdu_byte wbar_min = 0;

	xor	cl, cl

; 872  :           kdu_byte threshold = msbs_wbar+1;

	mov	dl, BYTE PTR [edi+16]
	inc	dl

; 873  :           prev = NULL;

	xor	edi, edi
	mov	BYTE PTR _threshold$1$[ebp], dl
	mov	DWORD PTR _prev$2$[ebp], edi
$LL13@write_pack:

; 874  :           while (scan != NULL)
; 875  :             {
; 876  :               if (scan->msbs_wbar < wbar_min)

	cmp	BYTE PTR [ebx+16], cl
	jae	SHORT $LN127@write_pack

; 877  :                 scan->msbs_wbar = wbar_min;

	mov	BYTE PTR [ebx+16], cl
$LN127@write_pack:

; 878  :               while ((scan->msbs_w >= scan->msbs_wbar) &&

	mov	al, BYTE PTR [ebx+9]
	cmp	al, BYTE PTR [ebx+16]
	jb	$LN16@write_pack
$LL15@write_pack:
	mov	al, BYTE PTR [ebx+16]
	cmp	al, dl
	jae	SHORT $LN179@write_pack

; 879  :                      (scan->msbs_wbar < threshold))
; 880  :                 {
; 881  :                   scan->msbs_wbar++;

	inc	al

; 882  :                   head.put_bit((scan->msbs_w >= scan->msbs_wbar)?0:1);

	cmp	BYTE PTR [ebx+9], al
	mov	BYTE PTR [ebx+16], al
	sbb	ecx, ecx
	neg	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3561 :         if (bits_left == 0)

	cmp	DWORD PTR [esi+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 882  :                   head.put_bit((scan->msbs_w >= scan->msbs_wbar)?0:1);

	mov	DWORD PTR _bit$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3561 :         if (bits_left == 0)

	jne	SHORT $LN82@write_pack

; 3562 :           { if (out != NULL) out->put(byte);

	mov	edi, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN83@write_pack
	mov	al, BYTE PTR [esi]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN86@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _bit$1$[ebp]
$LN86@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	dl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], dl
	inc	DWORD PTR [edi+516]
	mov	dl, BYTE PTR _threshold$1$[ebp]
$LN83@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3563 :             completed_bytes++;

	inc	DWORD PTR [esi+8]

; 3564 :             bits_left = (byte==0xFF)?7:8;

	xor	eax, eax
	cmp	BYTE PTR [esi], 255			; 000000ffH

; 3565 :             byte = 0; }

	mov	BYTE PTR [esi], 0
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+4], eax
$LN82@write_pack:

; 3566 :         byte += byte + bit;

	movzx	eax, BYTE PTR [esi]

; 3567 :         bits_left--;

	dec	DWORD PTR [esi+4]
	add	al, al
	add	al, cl
	mov	BYTE PTR [esi], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 878  :               while ((scan->msbs_w >= scan->msbs_wbar) &&

	movzx	eax, BYTE PTR [ebx+9]
	cmp	al, BYTE PTR [ebx+16]
	jae	SHORT $LL15@write_pack
$LN179@write_pack:
	mov	edi, DWORD PTR _prev$2$[ebp]
$LN16@write_pack:

; 883  :                 }
; 884  :               wbar_min =

	mov	dl, BYTE PTR [ebx+16]
	cmp	BYTE PTR [ebx+9], dl
	movzx	eax, dl
	mov	dl, BYTE PTR _threshold$1$[ebp]
	mov	DWORD PTR tv1164[ebp], eax
	movzx	eax, BYTE PTR [ebx+9]
	mov	ecx, DWORD PTR tv1164[ebp]
	cmovb	ecx, eax

; 885  :                 (scan->msbs_w<scan->msbs_wbar)?scan->msbs_w:scan->msbs_wbar;
; 886  :               next=scan->up_down; scan->up_down=prev; prev=scan; scan=next;

	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [ebx+20], edi
	mov	edi, ebx
	mov	DWORD PTR _prev$2$[ebp], edi
	mov	ebx, eax
	test	eax, eax
	jne	$LL13@write_pack

; 859  :     { // First time contribution.  Need to get MSB's.
; 860  :       for (msbs_wbar=0; msbs_wbar <= msbs_w; )

	mov	edi, DWORD PTR _this$1$[ebp]
	mov	al, BYTE PTR [edi+16]
	cmp	al, BYTE PTR [edi+9]
	jbe	$LL8@write_pack

; 887  :             }
; 888  :         }
; 889  :       beta = 3;

	mov	BYTE PTR [edi+16], 3
$LN41@write_pack:

; 890  :     }
; 891  : 
; 892  :   // Encode number of passes.
; 893  : 
; 894  :   int val = pending_new_passes - 1;

	movzx	ebx, BYTE PTR [edi+14]

; 895  :   int delta = (val > 1)?1:val;

	mov	edx, 1
	dec	ebx
	cmp	ebx, edx
	mov	ecx, ebx
	cmovg	ecx, edx

; 896  :   val -= delta;

	sub	ebx, ecx
	mov	DWORD PTR _delta$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3561 :         if (bits_left == 0)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN89@write_pack

; 3562 :           { if (out != NULL) out->put(byte);

	mov	edi, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN90@write_pack
	mov	al, BYTE PTR [esi]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN93@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _delta$1$[ebp]
$LN93@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	dl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], dl
	mov	edx, 1
	inc	DWORD PTR [edi+516]
$LN90@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3563 :             completed_bytes++;

	inc	DWORD PTR [esi+8]

; 3564 :             bits_left = (byte==0xFF)?7:8;

	xor	eax, eax
	cmp	BYTE PTR [esi], 255			; 000000ffH

; 3565 :             byte = 0; }

	mov	BYTE PTR [esi], 0
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+4], eax
$LN89@write_pack:

; 3566 :         byte += byte + bit;

	mov	al, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 898  :   if (delta)

	mov	edi, 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3567 :         bits_left--;

	dec	DWORD PTR [esi+4]
	add	al, al
	add	al, cl
	mov	BYTE PTR [esi], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 898  :   if (delta)

	test	ecx, ecx
	je	SHORT $LN46@write_pack

; 899  :     { // new_passes > 1
; 900  :       delta = (val > 1)?1:val;

	cmp	ebx, 1
	mov	edi, ebx

; 901  :       val -= delta;
; 902  :       head.put_bit(delta);

	mov	ecx, esi
	cmovg	edi, edx
	push	edi
	sub	ebx, edi
	call	?put_bit@kd_header_out@@QAEXH@Z		; kd_header_out::put_bit

; 903  :       if (delta)

	test	edi, edi
	je	SHORT $LN182@write_pack

; 904  :         { // new_passes > 2
; 905  :           delta = (val > 3)?3:val;

	cmp	ebx, 3
	mov	edi, ebx
	mov	eax, 3

; 906  :           val -= delta;
; 907  :           head.put_bits(delta,2);

	mov	ecx, esi
	cmovg	edi, eax
	push	2
	push	edi
	sub	ebx, edi
	call	?put_bits@kd_header_out@@QAEXHH@Z	; kd_header_out::put_bits

; 908  :           if (delta == 3)

	cmp	edi, 3
	jne	SHORT $LN182@write_pack

; 909  :             {
; 910  :               delta = (val > 31)?31:val;

	mov	eax, 31					; 0000001fH
	mov	edi, ebx
	cmp	ebx, eax

; 911  :               val -= delta;
; 912  :               head.put_bits(delta,5);

	mov	ecx, esi
	push	5
	cmovg	edi, eax
	push	edi
	sub	ebx, edi
	call	?put_bits@kd_header_out@@QAEXHH@Z	; kd_header_out::put_bits

; 913  :               if (delta == 31)

	cmp	edi, 31					; 0000001fH
	jne	SHORT $LN182@write_pack

; 914  :                 {
; 915  :                   delta = (val > 127)?127:val;

	mov	eax, 127				; 0000007fH

; 916  :                   val -= delta;
; 917  :                   head.put_bits(delta,7);

	mov	ecx, esi
	cmp	ebx, eax
	push	7
	cmovg	ebx, eax
	push	ebx
	call	?put_bits@kd_header_out@@QAEXHH@Z	; kd_header_out::put_bits
$LN182@write_pack:
	mov	edi, 3
$LN46@write_pack:

; 918  :                 }
; 919  :             }
; 920  :         }
; 921  :     }
; 922  :   assert(val == 0);
; 923  : 
; 924  :   // Finally, encode the length information.
; 925  : 
; 926  :   int segment_passes, segment_bytes, total_bytes, length_bits, new_passes, idx;
; 927  :   bool bypass_term = ((((int) modes) & Cmodes_BYPASS) != 0);

	mov	ebx, DWORD PTR _this$1$[ebp]

; 928  :   bool all_term = ((((int) modes) & Cmodes_RESTART) != 0);
; 929  :   if (all_term)

	mov	ecx, 0
	mov	dl, BYTE PTR [ebx+17]
	mov	al, dl
	shr	dl, 2
	and	al, 1
	and	dl, 1
	movzx	eax, al
	cmovne	eax, ecx
	mov	BYTE PTR _all_term$1$[ebp], dl

; 930  :     bypass_term = false;
; 931  : 
; 932  :   // Save buffer status
; 933  :   kd_code_buffer *save_current_buf = current_buf;
; 934  :   kdu_byte save_buf_pos = buf_pos;
; 935  : 
; 936  :   // Walk through the coding passes a first time to determine beta.
; 937  :   for (total_bytes=0, idx=pass_idx, new_passes=pending_new_passes;

	movzx	ecx, BYTE PTR [ebx+14]
	mov	DWORD PTR tv1189[ebp], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _save_current_buf$1$[ebp], eax
	mov	al, BYTE PTR [ebx+8]
	mov	BYTE PTR _save_buf_pos$1$[ebp], al
	movzx	eax, BYTE PTR [ebx+11]
	mov	DWORD PTR _idx$1$[ebp], eax
	mov	DWORD PTR _new_passes$1$[ebp], ecx

; 938  :        new_passes > 0; new_passes-=segment_passes,

	test	ecx, ecx
	jle	$LN18@write_pack
$LL19@write_pack:

; 940  :     {
; 941  :       if (all_term)

	test	dl, dl
	je	SHORT $LN48@write_pack

; 942  :         segment_passes = 1;

	mov	edi, 1

; 956  :       for (length_bits=0; (1<<length_bits) <= segment_passes; length_bits++);

	xor	ecx, ecx
	mov	DWORD PTR _segment_passes$1$[ebp], edi
	jmp	SHORT $LN176@write_pack
$LN48@write_pack:

; 943  :       else if (bypass_term)

	cmp	BYTE PTR tv1189[ebp], 0
	je	SHORT $LN50@write_pack

; 944  :         {
; 945  :           if (idx < 10)

	cmp	eax, 10					; 0000000aH
	jge	SHORT $LN52@write_pack

; 946  :             segment_passes = 10-idx;

	mov	edi, 10					; 0000000aH
	sub	edi, eax
	jmp	SHORT $LN183@write_pack
$LN52@write_pack:

; 947  :           else if (((idx-10) % 3) == 0)

	add	eax, -10				; fffffff6H
	cdq
	idiv	edi
	mov	edi, edx
	neg	edi
	sbb	edi, edi
	add	edi, 2
$LN183@write_pack:
	mov	DWORD PTR _segment_passes$1$[ebp], edi

; 948  :             segment_passes = 2;
; 949  :           else
; 950  :             segment_passes = 1;
; 951  :           if (segment_passes > new_passes)

	cmp	edi, ecx
	jle	SHORT $LN51@write_pack
$LN50@write_pack:

; 952  :             segment_passes = new_passes;
; 953  :         }
; 954  :       else
; 955  :         segment_passes = new_passes;

	mov	edi, ecx
	mov	DWORD PTR _segment_passes$1$[ebp], edi
$LN51@write_pack:

; 956  :       for (length_bits=0; (1<<length_bits) <= segment_passes; length_bits++);

	xor	ecx, ecx
	cmp	edi, 1
	jl	SHORT $LN21@write_pack
$LN176@write_pack:
	mov	eax, 1
	npad	5
$LL22@write_pack:
	rol	eax, 1
	inc	ecx
	cmp	eax, edi
	jle	SHORT $LL22@write_pack
$LN21@write_pack:

; 957  :       length_bits--;
; 958  :       length_bits += beta;

	movzx	eax, BYTE PTR [ebx+16]

; 959  :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	xor	edx, edx
	dec	eax
	mov	DWORD PTR _segment_bytes$1$[ebp], edx
	add	ecx, eax
	mov	DWORD PTR _val$2$[ebp], edi
	mov	DWORD PTR _length_bits$2$[ebp], ecx
	test	edi, edi
	jle	SHORT $LN131@write_pack
	mov	edx, DWORD PTR [ebx+4]
	mov	esi, edi
	mov	cl, BYTE PTR [ebx+8]
$LL25@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3891 :         buf_pos += 2 + (buf_pos & 1); // Align and advance the buffer pointer

	mov	al, cl
	and	al, 1
	add	al, 2
	add	cl, al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 959  :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	mov	BYTE PTR [ebx+8], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3892 :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	cl, 58					; 0000003aH
	jbe	SHORT $LN96@write_pack

; 3893 :           { buf_pos=2; current_buf=current_buf->next;

	mov	cl, 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 959  :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	mov	BYTE PTR [ebx+8], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3893 :           { buf_pos=2; current_buf=current_buf->next;

	mov	edx, DWORD PTR [edx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 959  :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	mov	DWORD PTR [ebx+4], edx
$LN96@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	mov	al, cl
	and	al, 1

; 3874 :         buf_pos += 2; // Advance the buffer pointer

	add	al, 2
	add	cl, al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 959  :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	mov	BYTE PTR [ebx+8], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	cl, 58					; 0000003aH
	jbe	SHORT $LN99@write_pack

; 3876 :           { buf_pos=2; current_buf=current_buf->next;

	mov	cl, 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 959  :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	mov	BYTE PTR [ebx+8], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3876 :           { buf_pos=2; current_buf=current_buf->next;

	mov	edx, DWORD PTR [edx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 959  :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	mov	DWORD PTR [ebx+4], edx
$LN99@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	movzx	eax, cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 959  :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	dec	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	movzx	eax, WORD PTR [eax+edx+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 962  :           segment_bytes += get_word();

	add	DWORD PTR _segment_bytes$1$[ebp], eax
	test	esi, esi
	jg	SHORT $LL25@write_pack
	mov	esi, DWORD PTR _head$[ebp]
	mov	edx, DWORD PTR _segment_bytes$1$[ebp]
	mov	ecx, DWORD PTR _length_bits$2$[ebp]
$LN131@write_pack:

; 964  :       while (segment_bytes >= (1<<length_bits))

	mov	eax, 1
	shl	eax, cl
	cmp	edx, eax
	jl	SHORT $LN17@write_pack
	npad	3
$LL26@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3561 :         if (bits_left == 0)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN102@write_pack

; 3562 :           { if (out != NULL) out->put(byte);

	mov	edi, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN103@write_pack
	mov	al, BYTE PTR [esi]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN106@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR _segment_bytes$1$[ebp]
$LN106@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [edi+516]
	mov	ecx, DWORD PTR _length_bits$2$[ebp]
$LN103@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3563 :             completed_bytes++;

	inc	DWORD PTR [esi+8]

; 3564 :             bits_left = (byte==0xFF)?7:8;

	xor	eax, eax
	cmp	BYTE PTR [esi], 255			; 000000ffH

; 3565 :             byte = 0; }

	mov	BYTE PTR [esi], 0
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+4], eax
$LN102@write_pack:

; 3566 :         byte += byte + bit;

	mov	al, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 967  :           length_bits++;

	inc	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3567 :         bits_left--;

	dec	DWORD PTR [esi+4]
	add	al, al
	inc	al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 967  :           length_bits++;

	mov	DWORD PTR _length_bits$2$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3566 :         byte += byte + bit;

	mov	BYTE PTR [esi], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 964  :       while (segment_bytes >= (1<<length_bits))

	mov	eax, 1

; 968  :           beta++;

	inc	BYTE PTR [ebx+16]
	shl	eax, cl
	cmp	edx, eax
	jge	SHORT $LL26@write_pack
	mov	edi, DWORD PTR _segment_passes$1$[ebp]
$LN17@write_pack:

; 939  :        total_bytes+=segment_bytes, idx+=segment_passes)

	mov	ecx, DWORD PTR _new_passes$1$[ebp]
	mov	eax, DWORD PTR _idx$1$[ebp]
	sub	ecx, edi
	mov	dl, BYTE PTR _all_term$1$[ebp]
	add	eax, edi
	mov	DWORD PTR _new_passes$1$[ebp], ecx
	mov	edi, 3
	mov	DWORD PTR _idx$1$[ebp], eax
	test	ecx, ecx
	jg	$LL19@write_pack
$LN18@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3561 :         if (bits_left == 0)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN109@write_pack

; 3562 :           { if (out != NULL) out->put(byte);

	mov	edi, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN110@write_pack
	mov	al, BYTE PTR [esi]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN113@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN113@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [edi+516]
$LN110@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3563 :             completed_bytes++;

	inc	DWORD PTR [esi+8]

; 3564 :             bits_left = (byte==0xFF)?7:8;

	xor	eax, eax
	cmp	BYTE PTR [esi], 255			; 000000ffH

; 3565 :             byte = 0; }

	mov	BYTE PTR [esi], 0
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+4], eax
$LN109@write_pack:

; 3566 :         byte += byte + bit;

	movzx	eax, BYTE PTR [esi]

; 3567 :         bits_left--;

	dec	DWORD PTR [esi+4]
	add	al, al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 975  :   current_buf = save_current_buf;

	mov	edx, DWORD PTR _save_current_buf$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3566 :         byte += byte + bit;

	mov	BYTE PTR [esi], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 976  :   buf_pos = save_buf_pos;

	mov	al, BYTE PTR _save_buf_pos$1$[ebp]

; 977  : 
; 978  :   // Walk through the coding passes a second time to encode the segment lengths
; 979  :   for (total_bytes=0, idx=pass_idx, new_passes=pending_new_passes;

	movzx	ecx, BYTE PTR [ebx+14]
	mov	BYTE PTR [ebx+8], al
	movzx	eax, BYTE PTR [ebx+11]
	mov	DWORD PTR [ebx+4], edx
	mov	DWORD PTR _idx$2$[ebp], eax
	mov	DWORD PTR _new_passes$2$[ebp], ecx

; 980  :        new_passes > 0; new_passes-=segment_passes,

	test	ecx, ecx
	jle	$LN29@write_pack
	npad	6
$LL30@write_pack:

; 981  :        total_bytes+=segment_bytes, idx+=segment_passes)
; 982  :     {
; 983  :       if (all_term)

	cmp	BYTE PTR _all_term$1$[ebp], 0
	je	SHORT $LN57@write_pack

; 984  :         segment_passes = 1;

	mov	edi, 1

; 998  :       for (length_bits=0; (1<<length_bits) <= segment_passes; length_bits++);

	xor	ecx, ecx
	jmp	SHORT $LN177@write_pack
$LN57@write_pack:

; 985  :       else if (bypass_term)

	cmp	BYTE PTR tv1189[ebp], 0
	je	SHORT $LN59@write_pack

; 986  :         {
; 987  :           if (idx < 10)

	cmp	eax, 10					; 0000000aH
	jge	SHORT $LN61@write_pack

; 988  :             segment_passes = 10-idx;

	mov	edi, 10					; 0000000aH
	sub	edi, eax
	jmp	SHORT $LN63@write_pack
$LN61@write_pack:

; 989  :           else if (((idx-10) % 3) == 0)

	add	eax, -10				; fffffff6H
	mov	edi, 3
	cdq
	idiv	edi
	mov	edi, edx
	neg	edi
	sbb	edi, edi
	add	edi, 2
$LN63@write_pack:

; 990  :             segment_passes = 2;
; 991  :           else
; 992  :             segment_passes = 1;
; 993  :           if (segment_passes > new_passes)

	cmp	edi, ecx
	jle	SHORT $LN60@write_pack
$LN59@write_pack:

; 994  :             segment_passes = new_passes;
; 995  :         }
; 996  :       else
; 997  :         segment_passes = new_passes;

	mov	edi, ecx
$LN60@write_pack:

; 998  :       for (length_bits=0; (1<<length_bits) <= segment_passes; length_bits++);

	xor	ecx, ecx
	cmp	edi, 1
	jl	SHORT $LN32@write_pack
$LN177@write_pack:
	mov	eax, 1
	npad	7
$LL33@write_pack:
	rol	eax, 1
	inc	ecx
	cmp	eax, edi
	jle	SHORT $LL33@write_pack
$LN32@write_pack:

; 999  :       length_bits--;
; 1000 :       length_bits += beta;

	movzx	eax, BYTE PTR [ebx+16]
	dec	eax

; 1001 :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	mov	DWORD PTR _val$3$[ebp], edi
	add	eax, ecx
	mov	DWORD PTR _length_bits$4$[ebp], eax
	xor	eax, eax
	mov	DWORD PTR _segment_bytes$2$[ebp], eax
	test	edi, edi
	jle	SHORT $LN35@write_pack
	mov	edx, DWORD PTR [ebx+4]
	mov	esi, edi
	mov	cl, BYTE PTR [ebx+8]
$LL36@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3891 :         buf_pos += 2 + (buf_pos & 1); // Align and advance the buffer pointer

	mov	al, cl
	and	al, 1
	add	al, 2
	add	cl, al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 1001 :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	mov	BYTE PTR [ebx+8], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3892 :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	cl, 58					; 0000003aH
	jbe	SHORT $LN116@write_pack

; 3893 :           { buf_pos=2; current_buf=current_buf->next;

	mov	cl, 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 1001 :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	mov	BYTE PTR [ebx+8], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3893 :           { buf_pos=2; current_buf=current_buf->next;

	mov	edx, DWORD PTR [edx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 1001 :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	mov	DWORD PTR [ebx+4], edx
$LN116@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	mov	al, cl
	and	al, 1

; 3874 :         buf_pos += 2; // Advance the buffer pointer

	add	al, 2
	add	cl, al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 1001 :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	mov	BYTE PTR [ebx+8], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	cl, 58					; 0000003aH
	jbe	SHORT $LN119@write_pack

; 3876 :           { buf_pos=2; current_buf=current_buf->next;

	mov	cl, 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 1001 :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	mov	BYTE PTR [ebx+8], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3876 :           { buf_pos=2; current_buf=current_buf->next;

	mov	edx, DWORD PTR [edx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 1001 :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	mov	DWORD PTR [ebx+4], edx
$LN119@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	movzx	eax, cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 1001 :       for (segment_bytes=0, val=segment_passes; val > 0; val--)

	dec	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	movzx	eax, WORD PTR [eax+edx+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 1004 :           segment_bytes += get_word();

	add	DWORD PTR _segment_bytes$2$[ebp], eax
	test	esi, esi
	jg	SHORT $LL36@write_pack
	mov	esi, DWORD PTR _head$[ebp]
	mov	eax, DWORD PTR _segment_bytes$2$[ebp]
$LN35@write_pack:

; 1005 :         }
; 1006 :       assert(segment_bytes < (1<<length_bits));
; 1007 :       head.put_bits(segment_bytes,length_bits);

	push	DWORD PTR _length_bits$4$[ebp]
	mov	ecx, esi
	push	eax
	call	?put_bits@kd_header_out@@QAEXHH@Z	; kd_header_out::put_bits
	mov	ecx, DWORD PTR _new_passes$2$[ebp]
	mov	eax, DWORD PTR _idx$2$[ebp]
	sub	ecx, edi
	add	eax, edi
	mov	DWORD PTR _new_passes$2$[ebp], ecx
	mov	DWORD PTR _idx$2$[ebp], eax
	test	ecx, ecx
	jg	$LL30@write_pack
	mov	edx, DWORD PTR _save_current_buf$1$[ebp]
$LN29@write_pack:

; 1008 :     }
; 1009 :   assert(total_bytes == (int) temp_length);
; 1010 : 
; 1011 :   if (simulate)

	cmp	BYTE PTR _simulate$[ebp], 0
	je	SHORT $LN66@write_pack

; 1012 :     { // Restore buffer status so we can try other thresholds for this layer
; 1013 :       current_buf = save_current_buf;
; 1014 :       buf_pos = save_buf_pos;

	mov	al, BYTE PTR _save_buf_pos$1$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+4], edx
	mov	BYTE PTR [ebx+8], al
	pop	ebx

; 1022 :     }
; 1023 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN66@write_pack:

; 1015 :     }
; 1016 :   else
; 1017 :     { // Commit state changes for this layer
; 1018 :       if (pass_idx == 0)

	mov	cl, BYTE PTR [ebx+11]
	test	cl, cl
	jne	SHORT $LN68@write_pack

; 1019 :         body_bytes_offset = ((kdu_uint16) num_passes) << 2;

	movzx	eax, BYTE PTR [ebx+10]
	shl	ax, 2
	mov	WORD PTR [ebx+12], ax
$LN68@write_pack:

; 1020 :       pass_idx += pending_new_passes;

	mov	al, BYTE PTR [ebx+14]
	add	al, cl

; 1021 :       pending_new_passes = 0;

	mov	BYTE PTR [ebx+14], 0
	mov	BYTE PTR [ebx+11], al
$LN67@write_pack:
	pop	edi
	pop	esi
	pop	ebx

; 1022 :     }
; 1023 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?write_packet_header@kd_block@@QAEXAAVkd_header_out@@H_N@Z ENDP ; kd_block::write_packet_header
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?start_packet@kd_block@@QAEHHG@Z
_TEXT	SEGMENT
_save_current_buf$1$ = -16				; size = 4
_test_length$1$ = -12					; size = 4
_test_passes$1$ = -8					; size = 4
_save_buf_pos$1$ = -1					; size = 1
_layer_idx$ = 8						; size = 4
_slope_threshold$ = 12					; size = 2
?start_packet@kd_block@@QAEHHG@Z PROC			; kd_block::start_packet, COMDAT
; _this$ = ecx

; 732  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 733  :   if (layer_idx == 0)

	mov	esi, DWORD PTR _layer_idx$[ebp]
	push	edi
	mov	edi, 65535				; 0000ffffH
	test	esi, esi
	jne	SHORT $LN43@start_pack

; 734  :     {
; 735  :       pass_idx = 0;
; 736  :       current_buf = first_buf;
; 737  :       buf_pos = 0;
; 738  :       layer_w = 0xFFFF;
; 739  :       if (num_passes == 0)

	cmp	BYTE PTR [ecx+10], 0
	mov	eax, DWORD PTR [ecx]
	mov	BYTE PTR [ecx+11], 0
	mov	DWORD PTR [ecx+4], eax
	mov	BYTE PTR [ecx+8], 0
	mov	WORD PTR [ecx+12], di
	jne	SHORT $LN12@start_pack

; 740  :         msbs_w = 0xFF; /* We will never include this block.  Make sure its

	mov	BYTE PTR [ecx+9], 255			; 000000ffH
$LN12@start_pack:

; 741  :                           `msbs_w' value does not damage the efficiency with
; 742  :                           which the neighbouring blocks are represented. */
; 743  : 
; 744  :       // Reflect `msbs_w' value into higher nodes in the tag tree.
; 745  :       for (kd_block *scan=this->up_down; scan != NULL; scan=scan->up_down)

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN43@start_pack
$LL4@start_pack:

; 746  :         if (scan->msbs_w > msbs_w)

	mov	dl, BYTE PTR [ecx+9]
	cmp	BYTE PTR [eax+9], dl
	jbe	SHORT $LN43@start_pack

; 747  :           scan->msbs_w = msbs_w;

	mov	BYTE PTR [eax+9], dl
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL4@start_pack
$LN43@start_pack:

; 748  :         else
; 749  :           break; // No point in going further up the tree.
; 750  :     }
; 751  : 
; 752  :   // Find number of new passes.
; 753  : 
; 754  :   pending_new_passes = 0;
; 755  :   temp_length = 0;
; 756  :   if (pass_idx == num_passes)

	mov	dh, BYTE PTR [ecx+11]
	xor	eax, eax
	mov	bl, BYTE PTR [ecx+10]
	mov	BYTE PTR [ecx+14], 0
	mov	WORD PTR [ecx+18], ax
	cmp	dh, bl
	jne	SHORT $LN15@start_pack

; 757  :     {
; 758  :       layer_w=0xFFFF; // `save_beta' may have been reset by `save_output_tree'

	mov	WORD PTR [ecx+12], di
	pop	edi
	pop	esi
	pop	ebx

; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN15@start_pack:

; 759  :       return 0;
; 760  :     }
; 761  : 
; 762  :   kd_code_buffer *save_current_buf = current_buf;
; 763  :   kdu_byte save_buf_pos = buf_pos;

	mov	dl, BYTE PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+4]

; 764  :   int test_length = 0;

	mov	DWORD PTR _test_length$1$[ebp], eax

; 765  :   int test_passes = 0;

	xor	eax, eax
	mov	DWORD PTR _test_passes$1$[ebp], eax

; 766  :   for (int n=(num_passes-pass_idx); n > 0; n--)

	movzx	eax, dh
	movzx	ebx, bl
	sub	ebx, eax
	mov	DWORD PTR _save_current_buf$1$[ebp], edi
	mov	BYTE PTR _save_buf_pos$1$[ebp], dl
	test	ebx, ebx
	jle	SHORT $LN33@start_pack
	npad	6
$LL7@start_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	and	dl, 1

; 3874 :         buf_pos += 2; // Advance the buffer pointer

	add	dl, 2
	add	BYTE PTR [ecx+8], dl

; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	BYTE PTR [ecx+8], 58			; 0000003aH
	jbe	SHORT $LN25@start_pack

; 3876 :           { buf_pos=2; current_buf=current_buf->next;

	mov	BYTE PTR [ecx+8], 2
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx+4], eax
$LN25@start_pack:

; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	mov	dl, BYTE PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+4]
	movzx	eax, dl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 768  :       kdu_uint16 slope = get_word();

	movzx	esi, WORD PTR [eax+edi+4]

; 769  :       if ((slope != 0) && (slope <= slope_threshold))

	test	si, si
	je	SHORT $LN16@start_pack
	cmp	si, WORD PTR _slope_threshold$[ebp]
	jbe	SHORT $LN44@start_pack
$LN16@start_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	and	dl, 1

; 3874 :         buf_pos += 2; // Advance the buffer pointer

	add	dl, 2
	add	BYTE PTR [ecx+8], dl

; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	BYTE PTR [ecx+8], 58			; 0000003aH
	jbe	SHORT $LN28@start_pack

; 3876 :           { buf_pos=2; current_buf=current_buf->next;

	mov	BYTE PTR [ecx+8], 2
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx+4], eax
$LN28@start_pack:

; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	mov	dl, BYTE PTR [ecx+8]
	mov	edi, DWORD PTR [ecx+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 772  :       test_passes++;

	inc	DWORD PTR _test_passes$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	movzx	eax, dl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 773  :       test_length += length;

	movzx	eax, WORD PTR [eax+edi+4]
	add	DWORD PTR _test_length$1$[ebp], eax

; 774  :       if (slope != 0)

	test	si, si
	je	SHORT $LN5@start_pack

; 775  :         {
; 776  :           pending_new_passes = test_passes;

	mov	eax, DWORD PTR _test_passes$1$[ebp]
	mov	BYTE PTR [ecx+14], al

; 777  :           assert(test_length < (1<<16));
; 778  :           temp_length = (kdu_uint16) test_length;

	mov	eax, DWORD PTR _test_length$1$[ebp]
	mov	WORD PTR [ecx+18], ax
$LN5@start_pack:

; 766  :   for (int n=(num_passes-pass_idx); n > 0; n--)

	dec	ebx
	test	ebx, ebx
	jg	SHORT $LL7@start_pack
$LN44@start_pack:
	mov	esi, DWORD PTR _layer_idx$[ebp]
$LN33@start_pack:

; 779  :         }
; 780  :     }
; 781  :   current_buf = save_current_buf;

	mov	eax, DWORD PTR _save_current_buf$1$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 782  :   buf_pos = save_buf_pos;

	mov	al, BYTE PTR _save_buf_pos$1$[ebp]
	mov	BYTE PTR [ecx+8], al

; 783  : 
; 784  :   // See if we need to update tag tree nodes.
; 785  : 
; 786  :   if (pass_idx == 0)

	test	dh, dh
	jne	SHORT $LN20@start_pack

; 787  :     {
; 788  :       if (pending_new_passes)

	cmp	BYTE PTR [ecx+14], dh
	je	SHORT $LN19@start_pack

; 789  :         {
; 790  :           layer_w  = (kdu_uint16) layer_idx;
; 791  :           for (kd_block *scan=up_down; scan != NULL; scan=scan->up_down)

	mov	eax, DWORD PTR [ecx+20]
	mov	WORD PTR [ecx+12], si
	test	eax, eax
	je	SHORT $LN20@start_pack
	npad	9
$LL10@start_pack:

; 792  :             if (scan->layer_w > layer_w)

	movzx	edx, WORD PTR [ecx+12]
	cmp	WORD PTR [eax+12], dx
	jbe	SHORT $LN20@start_pack

; 793  :               scan->layer_w = layer_w;

	mov	WORD PTR [eax+12], dx
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL10@start_pack

; 799  :     }
; 800  :   return temp_length;

	movzx	eax, WORD PTR [ecx+18]
	pop	edi
	pop	esi
	pop	ebx

; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN19@start_pack:

; 794  :             else
; 795  :               break; // No point in going further up the tree.
; 796  :         }
; 797  :       else
; 798  :         layer_w = 0xFFFF;

	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR [ecx+12], ax
$LN20@start_pack:

; 799  :     }
; 800  :   return temp_length;

	movzx	eax, WORD PTR [ecx+18]
	pop	edi
	pop	esi
	pop	ebx

; 801  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?start_packet@kd_block@@QAEHHG@Z ENDP			; kd_block::start_packet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?trim_data@kd_block@@QAE_NGPAVkd_buf_server@@@Z
_TEXT	SEGMENT
_save_current_buf$1$ = -28				; size = 4
_buf_ptr$1$ = -24					; size = 4
_slope$1$ = -20						; size = 4
_max_body_bytes$1$ = -16				; size = 4
_potential_body_bytes$1$ = -12				; size = 4
_max_passes$1$ = -8					; size = 4
_save_buf_pos$1$ = -1					; size = 1
_slope_threshold$ = 8					; size = 2
_buf_server$ = 12					; size = 4
?trim_data@kd_block@@QAE_NGPAVkd_buf_server@@@Z PROC	; kd_block::trim_data, COMDAT
; _this$ = ecx

; 660  : {

	push	ebp
	mov	ebp, esp

; 661  :   if (num_passes == 0)

	mov	al, BYTE PTR [ecx+10]
	sub	esp, 28					; 0000001cH
	test	al, al
	jne	SHORT $LN13@trim_data

; 724  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN13@trim_data:
	push	ebx

; 662  :     return false;
; 663  : 
; 664  :   // Find the number of passes we can keep.
; 665  :   int n;
; 666  :   int potential_body_bytes = 0;
; 667  :   int max_body_bytes = 0;
; 668  :   int max_passes = 0;
; 669  :   kd_code_buffer *save_current_buf = current_buf;

	mov	ebx, DWORD PTR [ecx+4]
	xor	edx, edx
	push	esi
	mov	DWORD PTR _save_current_buf$1$[ebp], ebx

; 670  :   kdu_byte save_buf_pos = buf_pos;
; 671  : 
; 672  :   current_buf = first_buf;
; 673  :   buf_pos = 0;
; 674  :   for (n=0; n < num_passes; n++)

	xor	esi, esi
	mov	bl, BYTE PTR [ecx+8]
	push	edi
	movzx	edi, al
	mov	BYTE PTR _save_buf_pos$1$[ebp], bl
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR _potential_body_bytes$1$[ebp], 0
	mov	DWORD PTR _max_body_bytes$1$[ebp], 0
	mov	DWORD PTR _max_passes$1$[ebp], edx
	mov	DWORD PTR _buf_ptr$1$[ebp], ebx
	mov	DWORD PTR [ecx+4], ebx
	mov	BYTE PTR [ecx+8], dl
	test	edi, edi
	jle	$LN30@trim_data
	npad	3
$LL4@trim_data:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	movzx	eax, BYTE PTR [ecx+8]
	and	al, 1

; 3874 :         buf_pos += 2; // Advance the buffer pointer

	add	al, 2
	add	BYTE PTR [ecx+8], al

; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	BYTE PTR [ecx+8], 58			; 0000003aH
	jbe	SHORT $LN20@trim_data

; 3876 :           { buf_pos=2; current_buf=current_buf->next;

	mov	eax, DWORD PTR [ecx+4]
	mov	BYTE PTR [ecx+8], 2
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
$LN20@trim_data:

; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	mov	dl, BYTE PTR [ecx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 676  :       kdu_uint16 slope = get_word();

	mov	ebx, DWORD PTR [ecx+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	movzx	eax, dl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 676  :       kdu_uint16 slope = get_word();

	movzx	eax, WORD PTR [eax+ebx+4]
	mov	DWORD PTR _slope$1$[ebp], eax

; 677  :       if ((slope != 0) && (slope <= slope_threshold))

	test	ax, ax
	je	SHORT $LN14@trim_data
	cmp	ax, WORD PTR _slope_threshold$[ebp]
	jbe	SHORT $LN47@trim_data
$LN14@trim_data:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	and	dl, 1

; 3874 :         buf_pos += 2; // Advance the buffer pointer

	add	dl, 2
	add	BYTE PTR [ecx+8], dl

; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	BYTE PTR [ecx+8], 58			; 0000003aH
	jbe	SHORT $LN23@trim_data

; 3876 :           { buf_pos=2; current_buf=current_buf->next;

	mov	BYTE PTR [ecx+8], 2
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ecx+4], eax
$LN23@trim_data:

; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	movzx	edx, BYTE PTR [ecx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 680  :       potential_body_bytes += length;

	mov	eax, DWORD PTR [ecx+4]
	movzx	eax, WORD PTR [edx+eax+4]
	mov	edx, DWORD PTR _potential_body_bytes$1$[ebp]
	add	edx, eax

; 681  :       if (slope != 0)

	cmp	WORD PTR _slope$1$[ebp], 0
	mov	DWORD PTR _potential_body_bytes$1$[ebp], edx
	je	SHORT $LN2@trim_data

; 682  :         {
; 683  :           max_body_bytes = potential_body_bytes;

	mov	DWORD PTR _max_body_bytes$1$[ebp], edx

; 684  :           max_passes = n+1;

	lea	edx, DWORD PTR [esi+1]
	mov	DWORD PTR _max_passes$1$[ebp], edx
$LN2@trim_data:

; 670  :   kdu_byte save_buf_pos = buf_pos;
; 671  : 
; 672  :   current_buf = first_buf;
; 673  :   buf_pos = 0;
; 674  :   for (n=0; n < num_passes; n++)

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@trim_data
$LN47@trim_data:
	mov	ebx, DWORD PTR _buf_ptr$1$[ebp]
	mov	edx, DWORD PTR _max_passes$1$[ebp]
$LN30@trim_data:

; 685  :         }
; 686  :     }
; 687  : 
; 688  :   // Restore the counters.
; 689  :   current_buf = save_current_buf;

	mov	eax, DWORD PTR _save_current_buf$1$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 690  :   buf_pos = save_buf_pos;

	mov	al, BYTE PTR _save_buf_pos$1$[ebp]
	mov	BYTE PTR [ecx+8], al

; 691  : 
; 692  :   // Now go back through the data setting additional pass slopes to 0.
; 693  : 
; 694  :      /* Notice that we do not change `num_passes' for that would prevent
; 695  :         us from later locating the body bytes. */
; 696  : 
; 697  :   if (n == num_passes)

	cmp	esi, edi
	jne	SHORT $LN16@trim_data

; 698  :     return false;

	pop	edi
	pop	esi
	xor	al, al
	pop	ebx

; 724  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN16@trim_data:

; 700  :   int pos = max_passes << 2;

	lea	esi, DWORD PTR [edx*4]

; 701  :   while (pos > KD_CODE_BUFFER_LEN)

	cmp	esi, 58					; 0000003aH
	jle	SHORT $LN6@trim_data

; 699  :   kd_code_buffer *buf_ptr = first_buf;

	lea	edx, DWORD PTR [esi-59]
	mov	eax, -1925330167			; 8d3dcb09H
	mul	edx
	shr	edx, 5
	inc	edx

; 701  :   while (pos > KD_CODE_BUFFER_LEN)

	imul	eax, edx, -58
	add	esi, eax
	npad	6
$LL5@trim_data:

; 702  :     { buf_ptr = buf_ptr->next; pos -= KD_CODE_BUFFER_LEN; }

	mov	ebx, DWORD PTR [ebx]
	sub	edx, 1
	jne	SHORT $LL5@trim_data
	mov	edx, DWORD PTR _max_passes$1$[ebp]
$LN6@trim_data:

; 703  :   n = (num_passes-max_passes)<<2; // Number of bytes to set to 0

	sub	edi, edx
	shl	edi, 2

; 704  :   while (n--)

	test	edi, edi
	je	SHORT $LN33@trim_data
$LL7@trim_data:
	dec	edi

; 705  :     {
; 706  :       if (pos == KD_CODE_BUFFER_LEN)

	cmp	esi, 58					; 0000003aH
	jne	SHORT $LN17@trim_data

; 707  :         { buf_ptr = buf_ptr->next; pos = 0; }

	mov	ebx, DWORD PTR [ebx]
	xor	esi, esi
$LN17@trim_data:

; 708  :       buf_ptr->buf[pos++] = 0;

	mov	BYTE PTR [esi+ebx+6], 0
	inc	esi
	test	edi, edi
	jne	SHORT $LL7@trim_data
$LN33@trim_data:

; 709  :     }
; 710  : 
; 711  :   // Now remove the unwanted body bytes.
; 712  : 
; 713  :   buf_ptr = first_buf;

	mov	esi, DWORD PTR [ecx]

; 714  :   pos = (num_passes<<2) + max_body_bytes;

	movzx	ecx, BYTE PTR [ecx+10]
	mov	edx, DWORD PTR _max_body_bytes$1$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*4]

; 715  :   while (pos > KD_CODE_BUFFER_LEN)

	cmp	ecx, 58					; 0000003aH
	jle	SHORT $LN29@trim_data

; 709  :     }
; 710  : 
; 711  :   // Now remove the unwanted body bytes.
; 712  : 
; 713  :   buf_ptr = first_buf;

	add	ecx, -59				; ffffffc5H
	mov	eax, -1925330167			; 8d3dcb09H
	mul	ecx
	shr	edx, 5
	inc	edx
$LL9@trim_data:

; 716  :     { buf_ptr = buf_ptr->next; pos -= KD_CODE_BUFFER_LEN; }

	mov	esi, DWORD PTR [esi]
	sub	edx, 1
	jne	SHORT $LL9@trim_data
$LN29@trim_data:

; 717  :   kd_code_buffer *tmp;
; 718  :   while ((tmp=buf_ptr->next) != NULL)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN12@trim_data
	mov	edi, DWORD PTR _buf_server$[ebp]
$LL11@trim_data:

; 719  :     {
; 720  :       buf_ptr->next = tmp->next;

	mov	eax, DWORD PTR [ecx]

; 721  :       buf_server->release(tmp);

	push	ecx
	mov	ecx, edi
	mov	DWORD PTR [esi], eax
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	jne	SHORT $LL11@trim_data
$LN12@trim_data:
	pop	edi
	pop	esi

; 722  :     }
; 723  :   return true;

	mov	al, 1
	pop	ebx

; 724  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?trim_data@kd_block@@QAE_NGPAVkd_buf_server@@@Z ENDP	; kd_block::trim_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_thread_buf_server@@@Z
_TEXT	SEGMENT
_val$2$ = -8						; size = 4
_val$1$ = -8						; size = 4
_total_bytes$1$ = -4					; size = 4
_bp$1$ = 8						; size = 4
_block$ = 8						; size = 4
_buf_server$ = 12					; size = 4
?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_thread_buf_server@@@Z PROC ; kd_block::store_data, COMDAT
; _this$ = ecx

; 610  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 618  :   msbs_w = (kdu_byte) block->missing_msbs;

	mov	ecx, DWORD PTR _block$[ebp]
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 370  :         if (head == NULL) augment_local_store(false);

	mov	edi, DWORD PTR _buf_server$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 618  :   msbs_w = (kdu_byte) block->missing_msbs;

	mov	al, BYTE PTR [ecx+44]
	mov	BYTE PTR [esi+9], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 370  :         if (head == NULL) augment_local_store(false);

	cmp	DWORD PTR [edi+16], 0
	jne	SHORT $LN14@store_data
	push	0
	mov	ecx, edi
	call	?augment_local_store@kd_thread_buf_server@@QAEX_N@Z ; kd_thread_buf_server::augment_local_store
	mov	ecx, DWORD PTR _block$[ebp]
$LN14@store_data:

; 371  :         kd_code_buffer *result = head;

	mov	edx, DWORD PTR [edi+16]

; 372  :         if ((head = result->next) == NULL)

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edi+16], eax
	test	eax, eax
	jne	SHORT $LN15@store_data

; 373  :           tail = NULL;

	mov	DWORD PTR [edi+20], eax
$LN15@store_data:

; 374  :         result->next = NULL;

	mov	DWORD PTR [edx], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 622  :   for (n=0; n < block->num_passes; n++)

	xor	ebx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 375  :         num_available_buffers--;

	dec	DWORD PTR [edi+8]

; 3815 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }

	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 621  :   total_bytes = 0;

	xor	edx, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3815 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }

	mov	BYTE PTR [esi+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 620  :   num_passes = (kdu_byte) block->num_passes;

	mov	al, BYTE PTR [ecx+48]
	mov	BYTE PTR [esi+10], al

; 621  :   total_bytes = 0;

	mov	DWORD PTR _total_bytes$1$[ebp], edx

; 622  :   for (n=0; n < block->num_passes; n++)

	cmp	DWORD PTR [ecx+48], edx
	jle	$LN3@store_data
$LL4@store_data:

; 623  :     {
; 624  :       val = block->pass_slopes[n];

	mov	eax, DWORD PTR [ecx+56]
	movzx	eax, WORD PTR [eax+ebx*2]
	mov	DWORD PTR _val$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3849 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	movzx	eax, BYTE PTR [esi+8]
	and	al, 1
	add	BYTE PTR [esi+8], al

; 3850 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))

	cmp	BYTE PTR [esi+8], 56			; 00000038H
	jbe	SHORT $LN18@store_data

; 3851 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	BYTE PTR [esi+8], 0

; 370  :         if (head == NULL) augment_local_store(false);

	cmp	DWORD PTR [edi+16], 0
	jne	SHORT $LN21@store_data
	push	0
	mov	ecx, edi
	call	?augment_local_store@kd_thread_buf_server@@QAEX_N@Z ; kd_thread_buf_server::augment_local_store
$LN21@store_data:

; 371  :         kd_code_buffer *result = head;

	mov	ecx, DWORD PTR [edi+16]

; 372  :         if ((head = result->next) == NULL)

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+16], eax
	test	eax, eax
	jne	SHORT $LN22@store_data

; 373  :           tail = NULL;

	mov	DWORD PTR [edi+20], eax
$LN22@store_data:

; 374  :         result->next = NULL;

	mov	DWORD PTR [ecx], 0

; 375  :         num_available_buffers--;

	dec	DWORD PTR [edi+8]

; 3851 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [esi+4], ecx
$LN18@store_data:

; 3852 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;

	movzx	ecx, BYTE PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _val$1$[ebp]
	mov	WORD PTR [ecx+eax+6], dx

; 3853 :         buf_pos += 2;

	add	BYTE PTR [esi+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 627  :       val = block->pass_lengths[n];

	mov	eax, DWORD PTR _block$[ebp]

; 629  :       total_bytes += val;

	mov	edx, DWORD PTR _total_bytes$1$[ebp]
	mov	eax, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [eax+ebx*4]
	add	edx, eax
	mov	DWORD PTR _val$2$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3849 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	mov	al, BYTE PTR [esi+8]
	and	al, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 629  :       total_bytes += val;

	mov	DWORD PTR _total_bytes$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3849 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	add	al, BYTE PTR [esi+8]
	mov	BYTE PTR [esi+8], al

; 3850 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))

	cmp	al, 56					; 00000038H
	jbe	SHORT $LN25@store_data

; 3851 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	BYTE PTR [esi+8], 0

; 370  :         if (head == NULL) augment_local_store(false);

	cmp	DWORD PTR [edi+16], 0
	jne	SHORT $LN28@store_data
	push	0
	mov	ecx, edi
	call	?augment_local_store@kd_thread_buf_server@@QAEX_N@Z ; kd_thread_buf_server::augment_local_store
	mov	edx, DWORD PTR _total_bytes$1$[ebp]
$LN28@store_data:

; 371  :         kd_code_buffer *result = head;

	mov	ecx, DWORD PTR [edi+16]

; 372  :         if ((head = result->next) == NULL)

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+16], eax
	test	eax, eax
	jne	SHORT $LN29@store_data

; 373  :           tail = NULL;

	mov	DWORD PTR [edi+20], eax
$LN29@store_data:

; 374  :         result->next = NULL;

	mov	DWORD PTR [ecx], 0

; 375  :         num_available_buffers--;

	dec	DWORD PTR [edi+8]

; 3851 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [esi+4], ecx
$LN25@store_data:

; 3852 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;

	movzx	ecx, BYTE PTR [esi+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 622  :   for (n=0; n < block->num_passes; n++)

	inc	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3852 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _val$2$[ebp]
	mov	WORD PTR [ecx+eax+6], di
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 622  :   for (n=0; n < block->num_passes; n++)

	mov	ecx, DWORD PTR _block$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3853 :         buf_pos += 2;

	add	BYTE PTR [esi+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 622  :   for (n=0; n < block->num_passes; n++)

	mov	edi, DWORD PTR _buf_server$[ebp]
	cmp	ebx, DWORD PTR [ecx+48]
	jl	$LL4@store_data
$LN3@store_data:

; 630  :       put_word(val,buf_server);
; 631  :     }
; 632  :   assert(total_bytes <= block->max_bytes);
; 633  : 
; 634  :   // Finally, copy the code-bytes.
; 635  :   kdu_byte *bp = block->byte_buffer;

	mov	eax, DWORD PTR [ecx+60]
	mov	DWORD PTR _bp$1$[ebp], eax

; 636  :   while (total_bytes > 0)

	test	edx, edx
	jle	$LN6@store_data
	npad	7
$LL5@store_data:

; 637  :     {
; 638  :       int xfer_bytes = KD_CODE_BUFFER_LEN - buf_pos;

	movzx	eax, BYTE PTR [esi+8]
	mov	ecx, 58					; 0000003aH
	sub	ecx, eax

; 639  :       if (xfer_bytes == 0)

	jne	SHORT $LN9@store_data
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 370  :         if (head == NULL) augment_local_store(false);

	cmp	DWORD PTR [edi+16], ecx
	jne	SHORT $LN32@store_data
	push	ecx
	mov	ecx, edi
	call	?augment_local_store@kd_thread_buf_server@@QAEX_N@Z ; kd_thread_buf_server::augment_local_store
	mov	edx, DWORD PTR _total_bytes$1$[ebp]
$LN32@store_data:

; 371  :         kd_code_buffer *result = head;

	mov	ecx, DWORD PTR [edi+16]

; 372  :         if ((head = result->next) == NULL)

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+16], eax
	test	eax, eax
	jne	SHORT $LN33@store_data

; 373  :           tail = NULL;

	mov	DWORD PTR [edi+20], eax
$LN33@store_data:

; 374  :         result->next = NULL;

	mov	DWORD PTR [ecx], 0

; 375  :         num_available_buffers--;

	dec	DWORD PTR [edi+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 641  :           current_buf = current_buf->next = buf_server->get();

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [esi+4], ecx

; 642  :           buf_pos = 0;
; 643  :           xfer_bytes = KD_CODE_BUFFER_LEN;

	mov	ecx, 58					; 0000003aH
	mov	BYTE PTR [esi+8], 0
$LN9@store_data:

; 644  :         }
; 645  :       xfer_bytes = (xfer_bytes < total_bytes)?xfer_bytes:total_bytes;

	cmp	ecx, edx
	mov	ebx, edx
	cmovl	ebx, ecx

; 646  :       total_bytes -= xfer_bytes;

	sub	edx, ebx
	mov	DWORD PTR _total_bytes$1$[ebp], edx

; 647  :       while (xfer_bytes--)

	test	ebx, ebx
	je	SHORT $LN39@store_data
	mov	edi, DWORD PTR _bp$1$[ebp]
	npad	7
$LL7@store_data:

; 648  :         current_buf->buf[buf_pos++] = *(bp++);

	movzx	edx, BYTE PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [edi]
	inc	edi
	mov	BYTE PTR [edx+ecx+6], al
	inc	BYTE PTR [esi+8]
	sub	ebx, 1
	jne	SHORT $LL7@store_data
	mov	edx, DWORD PTR _total_bytes$1$[ebp]
	mov	DWORD PTR _bp$1$[ebp], edi
	mov	edi, DWORD PTR _buf_server$[ebp]
$LN39@store_data:

; 636  :   while (total_bytes > 0)

	test	edx, edx
	jg	$LL5@store_data
$LN6@store_data:

; 649  :     }
; 650  :   current_buf = first_buf;

	mov	eax, DWORD PTR [esi]
	pop	edi
	mov	DWORD PTR [esi+4], eax

; 651  :   buf_pos = 0;

	mov	BYTE PTR [esi+8], 0
	pop	esi
	pop	ebx

; 652  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_thread_buf_server@@@Z ENDP ; kd_block::store_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_buf_server@@@Z
_TEXT	SEGMENT
_val$2$ = -8						; size = 4
_val$1$ = -8						; size = 4
_total_bytes$1$ = -4					; size = 4
_block$ = 8						; size = 4
_buf_server$ = 12					; size = 4
?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_buf_server@@@Z PROC ; kd_block::store_data, COMDAT
; _this$ = ecx

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 568  :   msbs_w = (kdu_byte) block->missing_msbs;

	mov	ebx, DWORD PTR _block$[ebp]
	push	esi
	mov	esi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }

	mov	ecx, DWORD PTR _buf_server$[ebp]
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 568  :   msbs_w = (kdu_byte) block->missing_msbs;

	movzx	eax, BYTE PTR [ebx+44]
	mov	BYTE PTR [esi+9], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }

	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	DWORD PTR [esi+4], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 571  :   total_bytes = 0;

	xor	edx, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }

	mov	DWORD PTR [esi], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 572  :   for (n=0; n < block->num_passes; n++)

	xor	edi, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }

	mov	BYTE PTR [esi+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 570  :   num_passes = (kdu_byte) block->num_passes;

	movzx	eax, BYTE PTR [ebx+48]
	mov	BYTE PTR [esi+10], al

; 571  :   total_bytes = 0;

	mov	DWORD PTR _total_bytes$1$[ebp], edx

; 572  :   for (n=0; n < block->num_passes; n++)

	cmp	DWORD PTR [ebx+48], edx
	jle	$LN3@store_data
	npad	3
$LL4@store_data:

; 573  :     {
; 574  :       val = block->pass_slopes[n];

	mov	eax, DWORD PTR [ebx+56]
	movzx	eax, WORD PTR [eax+edi*2]
	mov	DWORD PTR _val$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	movzx	eax, BYTE PTR [esi+8]
	and	al, 1
	add	BYTE PTR [esi+8], al

; 3826 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))

	cmp	BYTE PTR [esi+8], 56			; 00000038H
	jbe	SHORT $LN14@store_data

; 3827 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	ecx, DWORD PTR _buf_server$[ebp]
	mov	BYTE PTR [esi+8], 0
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _total_bytes$1$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [esi+4], eax
$LN14@store_data:

; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;

	movzx	ecx, BYTE PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR _val$1$[ebp]
	mov	WORD PTR [ecx+eax+6], bx

; 3829 :         buf_pos += 2;

	add	BYTE PTR [esi+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 577  :       val = block->pass_lengths[n];

	mov	ebx, DWORD PTR _block$[ebp]
	mov	eax, DWORD PTR [ebx+52]
	mov	eax, DWORD PTR [eax+edi*4]

; 579  :       total_bytes += val;

	add	edx, eax
	mov	DWORD PTR _val$2$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	mov	al, BYTE PTR [esi+8]
	and	al, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 579  :       total_bytes += val;

	mov	DWORD PTR _total_bytes$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	add	al, BYTE PTR [esi+8]
	mov	BYTE PTR [esi+8], al

; 3826 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))

	cmp	al, 56					; 00000038H
	jbe	SHORT $LN17@store_data

; 3827 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	ecx, DWORD PTR _buf_server$[ebp]
	mov	BYTE PTR [esi+8], 0
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _total_bytes$1$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [esi+4], eax
$LN17@store_data:

; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;

	movzx	ecx, BYTE PTR [esi+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 572  :   for (n=0; n < block->num_passes; n++)

	inc	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;

	mov	eax, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR _val$2$[ebp]
	mov	WORD PTR [ecx+eax+6], bx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 572  :   for (n=0; n < block->num_passes; n++)

	mov	ebx, DWORD PTR _block$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3829 :         buf_pos += 2;

	add	BYTE PTR [esi+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 572  :   for (n=0; n < block->num_passes; n++)

	cmp	edi, DWORD PTR [ebx+48]
	jl	$LL4@store_data
$LN3@store_data:

; 580  :       put_word(val,buf_server);
; 581  :     }
; 582  :   assert(total_bytes <= block->max_bytes);
; 583  : 
; 584  :   // Finally, copy the code-bytes.
; 585  :   kdu_byte *bp = block->byte_buffer;

	mov	ebx, DWORD PTR [ebx+60]

; 586  :   while (total_bytes > 0)

	test	edx, edx
	jle	SHORT $LN6@store_data
$LL5@store_data:

; 587  :     {
; 588  :       int xfer_bytes = KD_CODE_BUFFER_LEN - buf_pos;

	movzx	eax, BYTE PTR [esi+8]
	mov	ecx, 58					; 0000003aH
	sub	ecx, eax

; 589  :       if (xfer_bytes == 0)

	jne	SHORT $LN9@store_data

; 590  :         {
; 591  :           current_buf = current_buf->next = buf_server->get();

	mov	ecx, DWORD PTR _buf_server$[ebp]
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _total_bytes$1$[ebp]
	mov	DWORD PTR [ecx], eax

; 592  :           buf_pos = 0;
; 593  :           xfer_bytes = KD_CODE_BUFFER_LEN;

	mov	ecx, 58					; 0000003aH
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [esi+8], 0
$LN9@store_data:

; 594  :         }
; 595  :       xfer_bytes = (xfer_bytes < total_bytes)?xfer_bytes:total_bytes;

	cmp	ecx, edx
	mov	edi, edx
	cmovl	edi, ecx

; 596  :       total_bytes -= xfer_bytes;

	sub	edx, edi
	mov	DWORD PTR _total_bytes$1$[ebp], edx

; 597  :       while (xfer_bytes--)

	test	edi, edi
	je	SHORT $LN23@store_data
	npad	6
$LL7@store_data:

; 598  :         current_buf->buf[buf_pos++] = *(bp++);

	movzx	edx, BYTE PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [edx+ecx+6], al
	inc	BYTE PTR [esi+8]
	sub	edi, 1
	jne	SHORT $LL7@store_data
	mov	edx, DWORD PTR _total_bytes$1$[ebp]
$LN23@store_data:

; 586  :   while (total_bytes > 0)

	test	edx, edx
	jg	SHORT $LL5@store_data
$LN6@store_data:

; 599  :     }
; 600  :   current_buf = first_buf;

	mov	eax, DWORD PTR [esi]
	pop	edi
	mov	DWORD PTR [esi+4], eax

; 601  :   buf_pos = 0;

	mov	BYTE PTR [esi+8], 0
	pop	esi
	pop	ebx

; 602  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_buf_server@@@Z ENDP ; kd_block::store_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?retrieve_data@kd_block@@QAEXPAUkdu_block@@HH_N@Z
_TEXT	SEGMENT
_reader$ = -36						; size = 8
_layer_idx$1$ = -28					; size = 4
_reader$2$ = -24					; size = 4
_remaining_bytes$1$ = -20				; size = 4
_local_num_passes$1$ = -16				; size = 4
_p_idx$1$ = -12						; size = 4
_bp$1$ = -8						; size = 4
_reader$1$ = -4						; size = 4
_block$ = 8						; size = 4
_max_layers$ = 12					; size = 4
_discard_passes$ = 16					; size = 4
_more_headers$1$ = 19					; size = 1
_in_memory_source$ = 20					; size = 1
?retrieve_data@kd_block@@QAEXPAUkdu_block@@HH_N@Z PROC	; kd_block::retrieve_data, COMDAT
; _this$ = ecx

; 476  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx

; 477  :   assert(num_passes < 255); // 255 has the special meaning: "discard block"
; 478  :   block->num_passes = 0; // We will increment this as we read them in.

	mov	ebx, DWORD PTR _block$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebx+48], 0

; 479  :   block->missing_msbs = msbs_w;

	movzx	eax, BYTE PTR [edi+9]
	mov	DWORD PTR [ebx+44], eax

; 480  :   int local_num_passes = this->num_passes - discard_passes;

	movzx	esi, BYTE PTR [edi+10]
	sub	esi, DWORD PTR _discard_passes$[ebp]

; 481  :   if ((beta == 0) || (local_num_passes <= 0))

	cmp	BYTE PTR [edi+16], 0
	mov	DWORD PTR _local_num_passes$1$[ebp], esi
	je	$LN54@retrieve_d
	test	esi, esi
	jle	$LN54@retrieve_d

; 482  :     return;
; 483  : 
; 484  :   if ((num_bytes+2) > block->max_bytes)

	movzx	ecx, WORD PTR [edi+14]
	lea	eax, DWORD PTR [ecx+2]
	cmp	eax, DWORD PTR [ebx+68]
	jle	SHORT $LN14@retrieve_d

; 485  :     block->set_max_bytes(((int) num_bytes)+4096,

	lea	eax, DWORD PTR [ecx+4096]
	mov	ecx, ebx
	push	0
	push	eax
	call	?set_max_bytes@kdu_block@@QAEXH_N@Z	; kdu_block::set_max_bytes
$LN14@retrieve_d:

; 486  :                          false); // A generous allocation
; 487  :   if (local_num_passes > block->max_passes)

	cmp	esi, DWORD PTR [ebx+64]
	jle	SHORT $LN15@retrieve_d

; 488  :     block->set_max_passes(((int) local_num_passes)+32,

	push	0
	lea	eax, DWORD PTR [esi+32]
	mov	ecx, ebx
	push	eax
	call	?set_max_passes@kdu_block@@QAEXH_N@Z	; kdu_block::set_max_passes
$LN15@retrieve_d:

; 492  :   kdu_byte *bp = block->byte_buffer;

	mov	ecx, DWORD PTR [ebx+60]

; 81   :       { current_buf = start; buf_pos = 0; }

	xor	esi, esi

; 489  :                           false); // A generous allocation
; 490  : 
; 491  :   int remaining_bytes = num_bytes;

	movzx	eax, WORD PTR [edi+14]

; 493  : 
; 494  :   kd_block_reader reader(first_buf);
; 495  :   int p_idx=0;

	xor	ebx, ebx

; 81   :       { current_buf = start; buf_pos = 0; }

	mov	edi, DWORD PTR [edi]

; 489  :                           false); // A generous allocation
; 490  : 
; 491  :   int remaining_bytes = num_bytes;

	mov	DWORD PTR _remaining_bytes$1$[ebp], eax

; 492  :   kdu_byte *bp = block->byte_buffer;

	mov	DWORD PTR _bp$1$[ebp], ecx

; 81   :       { current_buf = start; buf_pos = 0; }

	mov	DWORD PTR _reader$1$[ebp], edi
	mov	DWORD PTR _reader$[ebp], edi

; 493  : 
; 494  :   kd_block_reader reader(first_buf);
; 495  :   int p_idx=0;

	mov	DWORD PTR _p_idx$1$[ebp], ebx

; 496  :   while ((p_idx < local_num_passes) && (remaining_bytes >= 0))

	cmp	DWORD PTR _local_num_passes$1$[ebp], ebx
	jle	$LN54@retrieve_d
	npad	5
$LL2@retrieve_d:
	test	eax, eax
	js	$LN54@retrieve_d

; 88   :       }
; 89   :     int get_word()
; 90   :       {
; 91   :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	mov	eax, esi

; 92   :         buf_pos += 2; // Advance the buffer pointer

	add	esi, 2
	and	eax, 1
	add	esi, eax

; 93   :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	esi, 58					; 0000003aH
	jle	SHORT $LN26@retrieve_d

; 94   :           { buf_pos=2; current_buf=current_buf->next;

	mov	edi, DWORD PTR [edi]
	mov	esi, 2
	mov	DWORD PTR _reader$1$[ebp], edi
	mov	DWORD PTR _reader$[ebp], edi
$LN26@retrieve_d:

; 95   :             assert(current_buf != NULL); }
; 96   :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	movzx	eax, WORD PTR [esi+edi+4]
	mov	DWORD PTR _layer_idx$1$[ebp], eax

; 497  :     {
; 498  :       // Get the layer index for the next contribution.
; 499  :       int layer_idx = reader.get_word();
; 500  :       if (layer_idx >= max_layers)

	cmp	eax, DWORD PTR _max_layers$[ebp]
	jge	$LN54@retrieve_d

; 501  :         break;
; 502  : 
; 503  :       int new_passes, new_bytes;
; 504  :       int idx = p_idx;

	mov	eax, ebx
$LL4@retrieve_d:

; 88   :       }
; 89   :     int get_word()
; 90   :       {
; 91   :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	mov	ecx, esi

; 92   :         buf_pos += 2; // Advance the buffer pointer

	add	esi, 2
	and	ecx, 1
	add	esi, ecx

; 93   :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	esi, 58					; 0000003aH
	jle	SHORT $LN29@retrieve_d

; 94   :           { buf_pos=2; current_buf=current_buf->next;

	mov	edi, DWORD PTR [edi]
	mov	esi, 2
	mov	DWORD PTR _reader$1$[ebp], edi
	mov	DWORD PTR _reader$[ebp], edi
$LN29@retrieve_d:

; 95   :             assert(current_buf != NULL); }
; 96   :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];

	movzx	ebx, WORD PTR [esi+edi+4]

; 82   :     kdu_byte get_byte()
; 83   :       {
; 84   :         if (buf_pos==KD_CODE_BUFFER_LEN)

	cmp	esi, 58					; 0000003aH
	jne	SHORT $LN32@retrieve_d

; 85   :           { buf_pos=0; current_buf=current_buf->next;

	mov	edi, DWORD PTR [edi]
	xor	esi, esi
	mov	DWORD PTR _reader$1$[ebp], edi
	mov	DWORD PTR _reader$[ebp], edi
$LN32@retrieve_d:

; 86   :             assert(current_buf != NULL); }
; 87   :         return current_buf->buf[buf_pos++];

	mov	cl, BYTE PTR [esi+edi+6]
	inc	esi
	mov	DWORD PTR _reader$2$[ebp], esi
	mov	DWORD PTR _reader$[ebp+4], esi

; 509  :         {
; 510  :           new_bytes = reader.get_word();
; 511  :           new_passes = reader.get_byte();

	movzx	edx, cl

; 512  :           more_headers = false;

	mov	BYTE PTR _more_headers$1$[ebp], 0

; 513  :           if (new_bytes & (1<<15))

	test	ebx, 32768				; 00008000H
	je	SHORT $LN17@retrieve_d

; 514  :             {
; 515  :               more_headers = true;

	mov	BYTE PTR _more_headers$1$[ebp], 1

; 516  :               new_bytes &= ~(1<<15);

	and	ebx, -32769				; ffff7fffH
$LN17@retrieve_d:

; 517  :             }
; 518  :           for (; (new_passes > 0) && (idx < local_num_passes);

	test	edx, edx
	jle	SHORT $LN7@retrieve_d
	mov	edi, DWORD PTR _block$[ebp]
	mov	esi, DWORD PTR _local_num_passes$1$[ebp]
$LL8@retrieve_d:
	cmp	eax, esi
	jge	SHORT $LN53@retrieve_d

; 519  :                new_passes--, new_bytes=0, idx++)
; 520  :             {
; 521  :               assert(idx < num_passes);
; 522  :               block->pass_lengths[idx] = new_bytes;

	mov	ecx, DWORD PTR [edi+52]
	dec	edx
	mov	DWORD PTR [ecx+eax*4], ebx

; 523  :               block->pass_slopes[idx] = 0;

	xor	ebx, ebx
	mov	ecx, DWORD PTR [edi+56]
	mov	WORD PTR [ecx+eax*2], bx
	inc	eax
	test	edx, edx
	jg	SHORT $LL8@retrieve_d
$LN53@retrieve_d:
	mov	esi, DWORD PTR _reader$2$[ebp]
	mov	edi, DWORD PTR _reader$1$[ebp]
$LN7@retrieve_d:

; 505  :       bool more_headers=true;
; 506  : 
; 507  :       assert(block->num_passes == (kdu_byte) p_idx);
; 508  :       while (more_headers)

	cmp	BYTE PTR _more_headers$1$[ebp], 0
	jne	$LL4@retrieve_d

; 524  :             }
; 525  :         }
; 526  :       assert(idx > 0);
; 527  :       block->pass_slopes[idx-1] = ((1<<16)-1) - layer_idx;

	mov	ecx, DWORD PTR _block$[ebp]
	mov	edx, 65535				; 0000ffffH
	sub	edx, DWORD PTR _layer_idx$1$[ebp]

; 528  : 
; 529  :       int xfer_bytes = 0;

	xor	ebx, ebx
	mov	ecx, DWORD PTR [ecx+56]
	mov	WORD PTR [ecx+eax*2-2], dx

; 530  :       for (; p_idx < idx; p_idx++)

	cmp	DWORD PTR _p_idx$1$[ebp], eax
	jge	$LN21@retrieve_d

; 531  :         {
; 532  :           new_bytes = block->pass_lengths[p_idx];

	mov	edi, DWORD PTR _block$[ebp]
	mov	esi, DWORD PTR _p_idx$1$[ebp]
	mov	ecx, DWORD PTR [edi+52]
	lea	edx, DWORD PTR [ecx+esi*4]
$LL11@retrieve_d:
	mov	ecx, DWORD PTR [edx]

; 533  :           remaining_bytes -= new_bytes;

	sub	DWORD PTR _remaining_bytes$1$[ebp], ecx

; 534  :           if (remaining_bytes < 0)

	js	SHORT $LN41@retrieve_d

; 535  :             break;
; 536  :           xfer_bytes += new_bytes;
; 537  :           block->num_passes = p_idx+1;

	inc	esi
	add	ebx, ecx
	add	edx, 4
	mov	DWORD PTR [edi+48], esi
	cmp	esi, eax
	jl	SHORT $LL11@retrieve_d
$LN41@retrieve_d:

; 538  :         }
; 539  :       if (xfer_bytes > 0)

	mov	edi, DWORD PTR _reader$1$[ebp]
	mov	DWORD PTR _p_idx$1$[ebp], esi
	mov	esi, DWORD PTR _reader$2$[ebp]
	test	ebx, ebx
	jle	SHORT $LN21@retrieve_d

; 540  :         {
; 541  :           if (in_memory_source)

	cmp	BYTE PTR _in_memory_source$[ebp], 0
	je	SHORT $LN20@retrieve_d

; 97   :       }
; 98   :     kdu_byte *get_address()
; 99   :       {
; 100  :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 101  :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer

	mov	eax, esi
	add	esi, 4
	neg	eax
	and	eax, 3
	add	esi, eax

; 102  :         if (buf_pos > KD_CODE_BUFFER_LEN)

	cmp	esi, 58					; 0000003aH
	jle	SHORT $LN35@retrieve_d

; 103  :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;

	mov	edi, DWORD PTR [edi]
	mov	esi, 4
	mov	DWORD PTR _reader$1$[ebp], edi
	mov	DWORD PTR _reader$[ebp], edi
$LN35@retrieve_d:

; 542  :             { // Read the data directly from the original in-memory source
; 543  :               kdu_byte *addr = reader.get_address();
; 544  :               memcpy(bp,addr,(size_t) xfer_bytes);

	push	ebx
	push	DWORD PTR [esi+edi+2]
	push	DWORD PTR _bp$1$[ebp]
	call	_memcpy
	add	esp, 12					; 0000000cH

; 545  :               bp += xfer_bytes;

	add	DWORD PTR _bp$1$[ebp], ebx

; 546  :             }
; 547  :           else

	jmp	SHORT $LN21@retrieve_d
$LN20@retrieve_d:

; 548  :             bp = reader.get_bytes(bp,xfer_bytes);

	push	ebx
	push	DWORD PTR _bp$1$[ebp]
	lea	ecx, DWORD PTR _reader$[ebp]
	call	?get_bytes@kd_block_reader@@QAEPAEPAEH@Z ; kd_block_reader::get_bytes
	mov	edi, DWORD PTR _reader$[ebp]
	mov	esi, DWORD PTR _reader$[ebp+4]
	mov	DWORD PTR _bp$1$[ebp], eax
	mov	DWORD PTR _reader$1$[ebp], edi
$LN21@retrieve_d:

; 496  :   while ((p_idx < local_num_passes) && (remaining_bytes >= 0))

	mov	ebx, DWORD PTR _p_idx$1$[ebp]
	mov	eax, DWORD PTR _remaining_bytes$1$[ebp]
	cmp	ebx, DWORD PTR _local_num_passes$1$[ebp]
	jl	$LL2@retrieve_d
$LN54@retrieve_d:
	pop	edi
	pop	esi
	pop	ebx

; 549  :         }
; 550  :     }
; 551  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?retrieve_data@kd_block@@QAEXPAUkdu_block@@HH_N@Z ENDP	; kd_block::retrieve_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?parse_packet_header@kd_block@@QAEHAAVkd_header_in@@PAVkd_buf_server@@H@Z
_TEXT	SEGMENT
tv1027 = -20						; size = 4
_threshold$1$ = -16					; size = 4
_idx$1$ = -16						; size = 4
_segment_bytes$1$ = -12					; size = 4
_prev$2$ = -12						; size = 4
_prev$2$ = -12						; size = 4
_this$1$ = -8						; size = 4
_threshold$1$ = -1					; size = 1
_head$ = 8						; size = 4
_discard_block$1$ = 11					; size = 1
$T1 = 12						; size = 2
$T2 = 12						; size = 2
$T3 = 12						; size = 2
$T4 = 12						; size = 4
_buf_server$ = 12					; size = 4
_layer_idx$ = 16					; size = 4
_all_term$1$ = 19					; size = 1
?parse_packet_header@kd_block@@QAEHAAVkd_header_in@@PAVkd_buf_server@@H@Z PROC ; kd_block::parse_packet_header, COMDAT
; _this$ = ecx

; 292  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, ecx

; 293  :   // Parse inclusion information first.
; 294  : 
; 295  :   temp_length = 0;

	xor	eax, eax
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[ebp], ebx
	mov	WORD PTR [ebx+18], ax

; 296  :   if (beta == 0)

	cmp	BYTE PTR [ebx+16], al
	jne	$LN23@parse_pack

; 297  :     { // Not yet included. Tag tree decoding for `layer_w'.
; 298  :       assert(layer_wbar == layer_w);
; 299  :       kd_block *scan, *prev, *next;
; 300  : 
; 301  :       // Walk up to the root node in the tree.
; 302  :       scan=this; prev=NULL;
; 303  :       while ((next=scan->up_down) != NULL)

	mov	edx, ebx
	xor	ecx, ecx
	mov	eax, DWORD PTR [edx+20]
	test	eax, eax
	je	SHORT $LN3@parse_pack
$LL2@parse_pack:

; 304  :         { scan->up_down=prev; prev=scan; scan=next; }

	mov	DWORD PTR [ebx+20], ecx
	mov	ecx, ebx
	mov	ebx, eax
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL2@parse_pack
$LN3@parse_pack:

; 305  :       scan->up_down = prev;
; 306  : 
; 307  :       // Walk back down the tree, performing the decoding steps.
; 308  :       kdu_uint16 wbar_min = 0;
; 309  :       kdu_uint16 threshold = (kdu_uint16)(layer_idx+1);

	mov	eax, DWORD PTR _layer_idx$[ebp]

; 310  :       prev = NULL;

	mov	esi, DWORD PTR _head$[ebp]
	inc	eax
	mov	DWORD PTR [ebx+20], ecx
	xor	ecx, ecx
	movzx	edx, ax
	xor	edi, edi
	mov	DWORD PTR _threshold$1$[ebp], edx
	mov	DWORD PTR _prev$2$[ebp], edi
	npad	3
$LL4@parse_pack:

; 311  :       while (scan != NULL)
; 312  :         {
; 313  :           if (scan->layer_wbar < wbar_min)

	cmp	WORD PTR [ebx+14], cx
	jae	SHORT $LN92@parse_pack

; 314  :             { scan->layer_wbar = wbar_min; scan->layer_w = wbar_min; }

	mov	WORD PTR [ebx+14], cx
	mov	WORD PTR [ebx+12], cx
$LN92@parse_pack:

; 315  :           while ((scan->layer_w == scan->layer_wbar) &&

	mov	ax, WORD PTR [ebx+12]
	cmp	ax, WORD PTR [ebx+14]
	jne	$LN7@parse_pack
	npad	4
$LL6@parse_pack:
	movzx	eax, WORD PTR [ebx+14]
	cmp	ax, dx
	jae	$LN157@parse_pack

; 316  :                  (scan->layer_wbar < threshold))
; 317  :             {
; 318  :               scan->layer_wbar++;

	inc	eax
	mov	WORD PTR [ebx+14], ax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3501 :         if (bits_left==0)

	cmp	DWORD PTR [esi+8], 0
	jne	$LN58@parse_pack

; 3504 :             if (!source->get(byte))

	mov	edi, DWORD PTR [esi]
	xor	eax, eax
	cmp	BYTE PTR [esi+4], 255			; 000000ffH
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+8], eax

; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))

	cmp	BYTE PTR [edi+533], 0
	jne	$LN167@parse_pack
	mov	eax, DWORD PTR [edi+524]
	cmp	eax, DWORD PTR [edi+528]
	jne	SHORT $LN62@parse_pack
	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	$LN167@parse_pack
$LN62@parse_pack:

; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.
; 535  :         byte = *(first_unread++);

	mov	eax, DWORD PTR [edi+524]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [esi+4], al
	inc	DWORD PTR [edi+524]

; 536  :         if (throw_markers)

	cmp	BYTE PTR [edi+534], 0
	je	SHORT $LN64@parse_pack

; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [edi+535], 0
	je	SHORT $LN65@parse_pack
	mov	al, BYTE PTR [esi+4]
	cmp	al, 143					; 0000008fH
	jbe	SHORT $LN65@parse_pack

; 539  :               process_unexpected_marker(byte);

	push	eax
	mov	ecx, edi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
$LN65@parse_pack:

; 540  :             have_FF = (byte==0xFF);

	cmp	BYTE PTR [esi+4], 255			; 000000ffH
	sete	al
	mov	BYTE PTR [edi+535], al
$LN64@parse_pack:

; 3506 :             header_bytes++;

	inc	DWORD PTR [esi+12]
	mov	edx, DWORD PTR _threshold$1$[ebp]
$LN58@parse_pack:

; 3507 :           }
; 3508 :         bits_left--;

	dec	DWORD PTR [esi+8]

; 3509 :         return (byte >> bits_left) & 1;

	mov	al, BYTE PTR [esi+4]
	mov	cl, BYTE PTR [esi+8]
	shr	al, cl
	test	al, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 319  :               if (head.get_bit() == 0)

	jne	SHORT $LN26@parse_pack

; 320  :                 scan->layer_w++;

	inc	WORD PTR [ebx+12]
$LN26@parse_pack:

; 315  :           while ((scan->layer_w == scan->layer_wbar) &&

	mov	ax, WORD PTR [ebx+12]
	cmp	ax, WORD PTR [ebx+14]
	je	$LL6@parse_pack
$LN157@parse_pack:
	mov	edi, DWORD PTR _prev$2$[ebp]
$LN7@parse_pack:

; 321  :             }
; 322  :           wbar_min = scan->layer_w;
; 323  :           next=scan->up_down; scan->up_down=prev; prev=scan; scan=next;

	mov	eax, DWORD PTR [ebx+20]
	movzx	ecx, WORD PTR [ebx+12]
	mov	DWORD PTR [ebx+20], edi
	mov	edi, ebx
	mov	DWORD PTR _prev$2$[ebp], ebx
	mov	ebx, eax
	test	eax, eax
	jne	$LL4@parse_pack

; 324  :         }
; 325  :       if (layer_wbar == layer_w)

	mov	ebx, DWORD PTR _this$1$[ebp]
	movzx	eax, WORD PTR [ebx+12]
	cmp	WORD PTR [ebx+14], ax
	jne	SHORT $LN27@parse_pack
$LN166@parse_pack:
	pop	edi
	pop	esi

; 326  :         return 0; // Nothing included yet.

	xor	eax, eax
	pop	ebx

; 467  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN27@parse_pack:

; 327  :       if (layer_w != (kdu_uint16) layer_idx)

	cmp	ax, WORD PTR _layer_idx$[ebp]
	je	SHORT $LN29@parse_pack
	jmp	$LN168@parse_pack
$LN23@parse_pack:

; 329  :     }
; 330  :   else
; 331  :     { // Already included.
; 332  :       if (head.get_bit() == 0)

	mov	esi, DWORD PTR _head$[ebp]
	mov	ecx, esi
	call	?get_bit@kd_header_in@@QAEHXZ		; kd_header_in::get_bit
	test	eax, eax
	je	SHORT $LN166@parse_pack
$LN29@parse_pack:

; 333  :         return 0;
; 334  :     }
; 335  : 
; 336  :   // If we get here, the code-block does contribute to the current layer.
; 337  : 
; 338  :   bool discard_block = (num_passes == 255);

	cmp	BYTE PTR [ebx+10], 255			; 000000ffH

; 339  : 
; 340  :   if (beta == 0)

	mov	edi, DWORD PTR _buf_server$[ebp]
	sete	al
	cmp	BYTE PTR [ebx+16], 0
	mov	BYTE PTR _discard_block$1$[ebp], al
	jne	$LN34@parse_pack

; 341  :     { // First time contribution.  Need to get MSB's and set up buffering.
; 342  :       while (msbs_w == msbs_wbar)

	cmp	BYTE PTR [ebx+9], 0
	jne	$LN9@parse_pack
	npad	3
$LL8@parse_pack:

; 343  :         { // Run tag tree decoder.
; 344  :           kd_block *scan, *prev, *next;
; 345  : 
; 346  :           // Walk up to the root note in the tree.
; 347  :           scan=this; prev=NULL;
; 348  :           while ((next=scan->up_down) != NULL)

	mov	eax, DWORD PTR [ebx+20]
	xor	ecx, ecx
	mov	edi, ebx
	test	eax, eax
	je	SHORT $LN11@parse_pack
	npad	5
$LL10@parse_pack:

; 349  :             { scan->up_down=prev; prev=scan; scan=next; }

	mov	DWORD PTR [edi+20], ecx
	mov	ecx, edi
	mov	edi, eax
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	jne	SHORT $LL10@parse_pack
$LN11@parse_pack:

; 350  :           scan->up_down = prev;

	mov	DWORD PTR [edi+20], ecx

; 351  : 
; 352  :           // Walk back down the tree, performing the decoding steps.
; 353  :           kdu_byte wbar_min = 0;

	xor	cl, cl

; 354  :           kdu_byte threshold = msbs_wbar+1;

	mov	dl, BYTE PTR [ebx+16]
	inc	dl

; 355  :           prev = NULL;

	xor	ebx, ebx
	mov	BYTE PTR _threshold$1$[ebp], dl
	mov	DWORD PTR _prev$2$[ebp], ebx
$LL12@parse_pack:

; 356  :           while (scan != NULL)
; 357  :             {
; 358  :               if (scan->msbs_wbar < wbar_min)

	cmp	BYTE PTR [edi+16], cl
	jae	SHORT $LN96@parse_pack

; 359  :                 { scan->msbs_wbar = wbar_min; scan->msbs_w = wbar_min; }

	mov	BYTE PTR [edi+16], cl
	mov	BYTE PTR [edi+9], cl
$LN96@parse_pack:

; 360  :               while ((scan->msbs_w == scan->msbs_wbar) &&

	mov	al, BYTE PTR [edi+9]
	cmp	al, BYTE PTR [edi+16]
	jne	$LN15@parse_pack
	npad	9
$LL14@parse_pack:
	mov	al, BYTE PTR [edi+16]
	cmp	al, dl
	jae	$LN160@parse_pack

; 361  :                      (scan->msbs_wbar < threshold))
; 362  :                 {
; 363  :                   scan->msbs_wbar++;

	add	al, 1
	mov	BYTE PTR [edi+16], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3501 :         if (bits_left==0)

	cmp	DWORD PTR [esi+8], 0
	jne	$LN69@parse_pack

; 3504 :             if (!source->get(byte))

	mov	ebx, DWORD PTR [esi]
	xor	eax, eax
	cmp	BYTE PTR [esi+4], 255			; 000000ffH
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+8], eax

; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))

	cmp	BYTE PTR [ebx+533], 0
	jne	$LN167@parse_pack
	mov	eax, DWORD PTR [ebx+524]
	cmp	eax, DWORD PTR [ebx+528]
	jne	SHORT $LN73@parse_pack
	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	$LN167@parse_pack
$LN73@parse_pack:

; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.
; 535  :         byte = *(first_unread++);

	mov	eax, DWORD PTR [ebx+524]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [esi+4], al
	inc	DWORD PTR [ebx+524]

; 536  :         if (throw_markers)

	cmp	BYTE PTR [ebx+534], 0
	je	SHORT $LN75@parse_pack

; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [ebx+535], 0
	je	SHORT $LN76@parse_pack
	mov	al, BYTE PTR [esi+4]
	cmp	al, 143					; 0000008fH
	jbe	SHORT $LN76@parse_pack

; 539  :               process_unexpected_marker(byte);

	push	eax
	mov	ecx, ebx
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
$LN76@parse_pack:

; 540  :             have_FF = (byte==0xFF);

	cmp	BYTE PTR [esi+4], 255			; 000000ffH
	sete	al
	mov	BYTE PTR [ebx+535], al
$LN75@parse_pack:

; 3506 :             header_bytes++;

	inc	DWORD PTR [esi+12]
	mov	dl, BYTE PTR _threshold$1$[ebp]
$LN69@parse_pack:

; 3507 :           }
; 3508 :         bits_left--;

	dec	DWORD PTR [esi+8]

; 3509 :         return (byte >> bits_left) & 1;

	mov	al, BYTE PTR [esi+4]
	mov	cl, BYTE PTR [esi+8]
	shr	al, cl
	test	al, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 364  :                   if (head.get_bit() == 0)

	jne	SHORT $LN33@parse_pack

; 365  :                     {
; 366  :                       scan->msbs_w++;

	inc	BYTE PTR [edi+9]
	mov	al, BYTE PTR [edi+9]

; 367  :                       if (scan->msbs_w > 74)

	cmp	al, 74					; 0000004aH
	ja	$LN102@parse_pack
$LN33@parse_pack:

; 360  :               while ((scan->msbs_w == scan->msbs_wbar) &&

	mov	al, BYTE PTR [edi+9]
	cmp	al, BYTE PTR [edi+16]
	je	$LL14@parse_pack
$LN160@parse_pack:
	mov	ebx, DWORD PTR _prev$2$[ebp]
$LN15@parse_pack:

; 372  :                         }
; 373  :                     }
; 374  :                 }
; 375  :               wbar_min = scan->msbs_w;
; 376  :               next=scan->up_down; scan->up_down=prev; prev=scan; scan=next;

	mov	eax, DWORD PTR [edi+20]
	mov	cl, BYTE PTR [edi+9]
	mov	DWORD PTR [edi+20], ebx
	mov	ebx, edi
	mov	DWORD PTR _prev$2$[ebp], ebx
	mov	edi, eax
	test	eax, eax
	jne	$LL12@parse_pack

; 341  :     { // First time contribution.  Need to get MSB's and set up buffering.
; 342  :       while (msbs_w == msbs_wbar)

	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	al, BYTE PTR [ebx+9]
	cmp	al, BYTE PTR [ebx+16]
	je	$LL8@parse_pack
	mov	al, BYTE PTR _discard_block$1$[ebp]
	mov	edi, DWORD PTR _buf_server$[ebp]
$LN9@parse_pack:

; 377  :             }
; 378  :         }
; 379  : 
; 380  :       num_bytes = 0;

	xor	ecx, ecx

; 381  :       beta = 3;

	mov	BYTE PTR [ebx+16], 3
	mov	WORD PTR [ebx+14], cx

; 382  :       assert(pass_idx == 0);
; 383  :       if (!discard_block)

	test	al, al
	jne	SHORT $LN35@parse_pack
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }

	mov	ecx, edi
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	DWORD PTR [ebx+4], eax
	mov	DWORD PTR [ebx], eax
	mov	BYTE PTR [ebx+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 387  :   if (!discard_block)

	jmp	SHORT $LN145@parse_pack
$LN34@parse_pack:
	test	al, al
	jne	SHORT $LN35@parse_pack
$LN145@parse_pack:

; 388  :     put_word(layer_idx,buf_server);

	push	edi
	push	DWORD PTR _layer_idx$[ebp]
	mov	ecx, ebx
	call	?put_word@kd_block@@AAEXHPAVkd_buf_server@@@Z ; kd_block::put_word
$LN35@parse_pack:

; 389  :          // Record the layer index for this new contribution.
; 390  : 
; 391  :   // Decode number of passes.
; 392  : 
; 393  :   int new_passes = 1;
; 394  :   new_passes += head.get_bit();

	mov	ecx, esi
	call	?get_bit@kd_header_in@@QAEHXZ		; kd_header_in::get_bit
	lea	edi, DWORD PTR [eax+1]

; 395  :   if (new_passes >= 2)

	cmp	edi, 2
	jl	SHORT $LL16@parse_pack

; 396  :     {
; 397  :       new_passes += head.get_bit();

	mov	ecx, esi
	call	?get_bit@kd_header_in@@QAEHXZ		; kd_header_in::get_bit
	add	edi, eax

; 398  :       if (new_passes >= 3)

	cmp	edi, 3
	jl	SHORT $LL16@parse_pack

; 399  :         {
; 400  :           new_passes += head.get_bits(2);

	push	2
	mov	ecx, esi
	call	?get_bits@kd_header_in@@QAEIH@Z		; kd_header_in::get_bits
	add	edi, eax

; 401  :           if (new_passes >= 6)

	cmp	edi, 6
	jl	SHORT $LL16@parse_pack

; 402  :             {
; 403  :               new_passes += head.get_bits(5);

	push	5
	mov	ecx, esi
	call	?get_bits@kd_header_in@@QAEIH@Z		; kd_header_in::get_bits
	add	edi, eax

; 404  :               if (new_passes >= 37)

	cmp	edi, 37					; 00000025H
	jl	SHORT $LL16@parse_pack

; 405  :                 new_passes += head.get_bits(7);

	push	7
	mov	ecx, esi
	call	?get_bits@kd_header_in@@QAEIH@Z		; kd_header_in::get_bits
	add	edi, eax
	npad	4
$LL16@parse_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3501 :         if (bits_left==0)

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN81@parse_pack

; 3502 :           {
; 3503 :             bits_left = (byte==0xFF)?7:8;

	lea	ecx, DWORD PTR [esi+4]
	xor	eax, eax
	cmp	BYTE PTR [ecx], 255			; 000000ffH

; 3504 :             if (!source->get(byte))

	push	ecx
	mov	ecx, DWORD PTR [esi]
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+8], eax
	call	?get@kd_input@@QAE_NAAE@Z		; kd_input::get
	test	al, al
	je	$LN167@parse_pack

; 3506 :             header_bytes++;

	inc	DWORD PTR [esi+12]
$LN81@parse_pack:

; 3507 :           }
; 3508 :         bits_left--;

	dec	DWORD PTR [esi+8]

; 3509 :         return (byte >> bits_left) & 1;

	mov	al, BYTE PTR [esi+4]
	mov	cl, BYTE PTR [esi+8]
	shr	al, cl
	test	al, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 412  :   while (head.get_bit())

	je	SHORT $LN17@parse_pack

; 413  :     {
; 414  :       if (beta == 255)

	mov	al, BYTE PTR [ebx+16]
	cmp	al, 255					; 000000ffH
	je	$LN104@parse_pack

; 416  :       beta++;

	inc	al
	mov	BYTE PTR [ebx+16], al

; 417  :     }

	jmp	SHORT $LL16@parse_pack
$LN17@parse_pack:

; 418  : 
; 419  :   bool bypass_term = ((((int) modes) & Cmodes_BYPASS) != 0);

	mov	cl, BYTE PTR [ebx+17]
	mov	al, cl

; 420  :   bool all_term = ((((int) modes) & Cmodes_RESTART) != 0);

	shr	cl, 2
	and	al, 1
	and	cl, 1

; 421  :   if (all_term)

	movzx	edx, al
	mov	eax, 0
	cmovne	edx, eax
	mov	BYTE PTR _all_term$1$[ebp], cl

; 422  :     bypass_term = false;
; 423  : 
; 424  :   int segment_passes, segment_bytes;
; 425  :   int length_bits;
; 426  :   int idx = pass_idx;

	movzx	eax, BYTE PTR [ebx+11]
	mov	DWORD PTR tv1027[ebp], edx
	mov	DWORD PTR _idx$1$[ebp], eax

; 427  :   while (new_passes > 0)

	test	edi, edi
	jle	$LN19@parse_pack
	npad	8
$LL162@parse_pack:
	mov	ebx, 3

; 428  :     {
; 429  :       if (all_term)

	test	cl, cl
	je	SHORT $LN42@parse_pack

; 430  :         segment_passes = 1;

	mov	ebx, 1

; 444  :       for (length_bits=0; (1<<length_bits) <= segment_passes; length_bits++);

	xor	ecx, ecx
	jmp	SHORT $LN152@parse_pack
$LN42@parse_pack:

; 431  :       else if (bypass_term)

	test	dl, dl
	je	SHORT $LN44@parse_pack

; 432  :         {
; 433  :           if (idx < 10)

	cmp	eax, 10					; 0000000aH
	jge	SHORT $LN46@parse_pack

; 434  :             segment_passes = 10-idx;

	mov	ebx, 10					; 0000000aH
	sub	ebx, eax
	jmp	SHORT $LN48@parse_pack
$LN46@parse_pack:

; 435  :           else if (((idx-10) % 3) == 0)

	add	eax, -10				; fffffff6H
	cdq
	idiv	ebx
	mov	ebx, edx
	neg	ebx
	sbb	ebx, ebx
	add	ebx, 2
$LN48@parse_pack:

; 436  :             segment_passes = 2;
; 437  :           else
; 438  :             segment_passes = 1;
; 439  :           if (segment_passes > new_passes)

	cmp	ebx, edi
	jle	SHORT $LN45@parse_pack
$LN44@parse_pack:

; 440  :             segment_passes = new_passes;
; 441  :         }
; 442  :       else
; 443  :         segment_passes = new_passes;

	mov	ebx, edi
$LN45@parse_pack:

; 444  :       for (length_bits=0; (1<<length_bits) <= segment_passes; length_bits++);

	xor	ecx, ecx
	cmp	ebx, 1
	jl	SHORT $LN21@parse_pack
$LN152@parse_pack:
	mov	eax, 1
$LL22@parse_pack:
	rol	eax, 1
	inc	ecx
	cmp	eax, ebx
	jle	SHORT $LL22@parse_pack
$LN21@parse_pack:

; 445  :       length_bits--;
; 446  :       length_bits += beta;

	mov	eax, DWORD PTR _this$1$[ebp]
	movzx	eax, BYTE PTR [eax+16]
	dec	eax
	add	eax, ecx

; 447  :       segment_bytes = head.get_bits(length_bits);

	mov	ecx, esi
	push	eax
	call	?get_bits@kd_header_in@@QAEIH@Z		; kd_header_in::get_bits
	mov	DWORD PTR _segment_bytes$1$[ebp], eax

; 448  :       if ((segment_bytes >= (1<<15)) ||

	cmp	eax, 32768				; 00008000H
	jge	$LN104@parse_pack
	mov	edx, DWORD PTR _this$1$[ebp]
	movzx	ecx, WORD PTR [edx+18]
	mov	edx, 65536				; 00010000H
	sub	edx, ecx
	cmp	eax, edx
	jge	$LN104@parse_pack

; 449  :           (segment_bytes >= ((1<<16) - (int) temp_length)))
; 450  :         throw KDU_EXCEPTION_PRECISION;
; 451  :       temp_length += segment_bytes;

	mov	edx, DWORD PTR _this$1$[ebp]

; 452  :       idx += segment_passes;
; 453  :       new_passes -= segment_passes;

	sub	edi, ebx
	movzx	ecx, WORD PTR [edx+18]
	add	eax, ecx
	mov	WORD PTR [edx+18], ax
	mov	eax, DWORD PTR _idx$1$[ebp]
	add	eax, ebx
	mov	DWORD PTR _idx$1$[ebp], eax

; 454  :       if (new_passes > 0)

	test	edi, edi
	jle	SHORT $LN53@parse_pack

; 455  :         segment_bytes |= (1<<15); // Continuation flag.

	or	DWORD PTR _segment_bytes$1$[ebp], 32768	; 00008000H
$LN53@parse_pack:

; 456  :       if (!discard_block)

	cmp	BYTE PTR _discard_block$1$[ebp], 0
	jne	SHORT $LN158@parse_pack
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer

	mov	al, BYTE PTR [edx+8]
	and	al, 1
	add	BYTE PTR [edx+8], al

; 3826 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))

	cmp	BYTE PTR [edx+8], 56			; 00000038H
	jbe	SHORT $LN85@parse_pack

; 3827 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	ecx, DWORD PTR _buf_server$[ebp]
	mov	BYTE PTR [edx+8], 0
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	edx, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [edx+4], eax
$LN85@parse_pack:

; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;

	movzx	ecx, BYTE PTR [edx+8]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _segment_bytes$1$[ebp]
	mov	WORD PTR [ecx+eax+6], dx

; 3829 :         buf_pos += 2;

	mov	edx, DWORD PTR _this$1$[ebp]
	add	BYTE PTR [edx+8], 2

; 3813 :     void start_buffering(kd_thread_buf_server *buf_server)
; 3814 :       { assert(first_buf == NULL);
; 3815 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3816 :     void put_byte(kdu_byte val, kd_buf_server *buf_server)
; 3817 :       {
; 3818 :         assert(current_buf != NULL);
; 3819 :         if (buf_pos==KD_CODE_BUFFER_LEN)

	cmp	BYTE PTR [edx+8], 58			; 0000003aH
	jne	SHORT $LN88@parse_pack

; 3820 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	ecx, DWORD PTR _buf_server$[ebp]
	mov	BYTE PTR [edx+8], 0
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	edx, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [edx+4], eax
$LN88@parse_pack:

; 3821 :         current_buf->buf[buf_pos++] = val;

	movzx	ecx, BYTE PTR [edx+8]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+eax+6], bl
	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR _idx$1$[ebp]
	inc	BYTE PTR [ebx+8]
	jmp	SHORT $LN54@parse_pack
$LN158@parse_pack:
	mov	ebx, edx
$LN54@parse_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 427  :   while (new_passes > 0)

	mov	cl, BYTE PTR _all_term$1$[ebp]
	mov	edx, DWORD PTR tv1027[ebp]
	test	edi, edi
	jg	$LL162@parse_pack
$LN19@parse_pack:

; 457  :         { // Record the number of bytes and the number of passes in the segment
; 458  :           put_word(segment_bytes,buf_server);
; 459  :           put_byte((kdu_byte) segment_passes,buf_server);
; 460  :         }
; 461  :     }
; 462  : 
; 463  :   pass_idx = (kdu_byte) idx;
; 464  :   if (!discard_block)

	cmp	BYTE PTR _discard_block$1$[ebp], 0
	mov	BYTE PTR [ebx+11], al
	jne	SHORT $LN55@parse_pack

; 465  :     num_passes = pass_idx;

	mov	BYTE PTR [ebx+10], al
$LN55@parse_pack:

; 466  :   return temp_length;

	movzx	eax, WORD PTR [ebx+18]
	pop	edi
	pop	esi
	pop	ebx

; 467  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN167@parse_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3505 :               { bits_left = 0; throw this; }

	push	OFFSET __TI2PAVkd_header_in@@
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR [esi+8], 0
	push	eax
	mov	DWORD PTR $T4[ebp], esi
	call	__CxxThrowException@8
$LN169@parse_pack:
$LN168@parse_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 328  :         throw KDU_EXCEPTION_ILLEGAL_LAYER;

	push	OFFSET __TI1G
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T2[ebp], 21			; 00000015H
	push	eax
	call	__CxxThrowException@8
$LN170@parse_pack:
$LN102@parse_pack:

; 368  :                         {
; 369  :                           beta = 0;

	mov	eax, DWORD PTR _this$1$[ebp]

; 370  :                           num_passes = 0;
; 371  :                           throw KDU_EXCEPTION_ILLEGAL_MISSING_MSBS;

	push	OFFSET __TI1G
	mov	DWORD PTR $T3[ebp], 74			; 0000004aH
	mov	BYTE PTR [eax+16], 0
	mov	BYTE PTR [eax+10], 0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN171@parse_pack:
$LN104@parse_pack:

; 415  :         throw KDU_EXCEPTION_PRECISION;

	push	OFFSET __TI1G
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T1[ebp], 13			; 0000000dH
	push	eax
	call	__CxxThrowException@8
$LN172@parse_pack:
$LN165@parse_pack:
	int	3
?parse_packet_header@kd_block@@QAEHAAVkd_header_in@@PAVkd_buf_server@@H@Z ENDP ; kd_block::parse_packet_header
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?put_bits@kd_header_out@@QAEXHH@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
_num_bits$ = 12						; size = 4
_byte$1$ = 15						; size = 1
?put_bits@kd_header_out@@QAEXHH@Z PROC			; kd_header_out::put_bits, COMDAT
; _this$ = ecx

; 3570 :       { // Output the least significant `num_bits' of `val'

	push	ebp
	mov	ebp, esp
	push	ebx

; 3571 :         while (num_bits > 0)

	mov	ebx, DWORD PTR _num_bits$[ebp]
	push	esi
	mov	esi, ecx
	test	ebx, ebx
	jle	SHORT $LN3@put_bits
	push	edi
	npad	1
$LL2@put_bits:

; 3572 :           put_bit((val >> (--num_bits)) & 1);

	dec	ebx

; 3561 :         if (bits_left == 0)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN6@put_bits

; 3562 :           { if (out != NULL) out->put(byte);

	mov	edi, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN7@put_bits
	mov	al, BYTE PTR [esi]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN10@put_bits

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN10@put_bits:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [edi+516]
$LN7@put_bits:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3563 :             completed_bytes++;

	inc	DWORD PTR [esi+8]

; 3564 :             bits_left = (byte==0xFF)?7:8;

	xor	eax, eax
	cmp	BYTE PTR [esi], 255			; 000000ffH

; 3565 :             byte = 0; }

	mov	BYTE PTR [esi], 0
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+4], eax
$LN6@put_bits:

; 3572 :           put_bit((val >> (--num_bits)) & 1);

	mov	edx, DWORD PTR _val$[ebp]
	mov	ecx, ebx

; 3566 :         byte += byte + bit;

	mov	al, BYTE PTR [esi]

; 3567 :         bits_left--;

	dec	DWORD PTR [esi+4]
	add	al, al

; 3572 :           put_bit((val >> (--num_bits)) & 1);

	sar	edx, cl
	and	dl, 1

; 3566 :         byte += byte + bit;

	add	dl, al
	mov	BYTE PTR [esi], dl

; 3571 :         while (num_bits > 0)

	test	ebx, ebx
	jg	SHORT $LL2@put_bits
	pop	edi
$LN3@put_bits:
	pop	esi
	pop	ebx

; 3573 :       }

	pop	ebp
	ret	8
?put_bits@kd_header_out@@QAEXHH@Z ENDP			; kd_header_out::put_bits
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?put_bit@kd_header_out@@QAEXH@Z
_TEXT	SEGMENT
_bit$ = 8						; size = 4
?put_bit@kd_header_out@@QAEXH@Z PROC			; kd_header_out::put_bit, COMDAT
; _this$ = ecx

; 3559 :       { // Output a header bit

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN2@put_bit

; 3562 :           { if (out != NULL) out->put(byte);

	push	edi
	mov	edi, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN3@put_bit
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	push	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3562 :           { if (out != NULL) out->put(byte);

	mov	bl, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN6@put_bit

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN6@put_bit:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [edi+516]
	pop	ebx
$LN3@put_bit:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3563 :             completed_bytes++;

	inc	DWORD PTR [esi+8]

; 3564 :             bits_left = (byte==0xFF)?7:8;

	xor	eax, eax
	cmp	BYTE PTR [esi], 255			; 000000ffH

; 3565 :             byte = 0; }

	mov	BYTE PTR [esi], 0
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+4], eax
	pop	edi
$LN2@put_bit:

; 3566 :         byte += byte + bit;

	mov	al, BYTE PTR [esi]
	add	al, al
	add	al, BYTE PTR _bit$[ebp]

; 3567 :         bits_left--;

	dec	DWORD PTR [esi+4]
	mov	BYTE PTR [esi], al
	pop	esi

; 3568 :       }

	pop	ebp
	ret	4
?put_bit@kd_header_out@@QAEXH@Z ENDP			; kd_header_out::put_bit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_bits@kd_header_in@@QAEIH@Z
_TEXT	SEGMENT
_result$1$ = -4						; size = 4
$T1 = 8							; size = 4
_num_bits$ = 8						; size = 4
?get_bits@kd_header_in@@QAEIH@Z PROC			; kd_header_in::get_bits, COMDAT
; _this$ = ecx

; 3512 :       { kdu_uint32 result = 0;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 3513 :         while (num_bits > 0)

	mov	ebx, DWORD PTR _num_bits$[ebp]
	xor	eax, eax
	mov	DWORD PTR _result$1$[ebp], eax
	push	edi
	mov	edi, ecx
	test	ebx, ebx
	jle	$LN3@get_bits
	push	esi
	npad	7
$LL2@get_bits:

; 3514 :           {
; 3515 :             if (bits_left==0)

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN4@get_bits

; 3516 :               {
; 3517 :                 bits_left = (byte==0xFF)?7:8;
; 3518 :                 if (!source->get(byte))

	mov	esi, DWORD PTR [edi]
	xor	eax, eax
	cmp	BYTE PTR [edi+4], 255			; 000000ffH
	setne	al
	add	eax, 7
	mov	DWORD PTR [edi+8], eax

; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))

	cmp	BYTE PTR [esi+533], 0
	jne	$LN24@get_bits
	mov	eax, DWORD PTR [esi+524]
	cmp	eax, DWORD PTR [esi+528]
	jne	SHORT $LN10@get_bits
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	$LN24@get_bits
$LN10@get_bits:

; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.
; 535  :         byte = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edi+4], al
	inc	DWORD PTR [esi+524]

; 536  :         if (throw_markers)

	cmp	BYTE PTR [esi+534], 0
	je	SHORT $LN12@get_bits

; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [esi+535], 0
	je	SHORT $LN13@get_bits
	mov	al, BYTE PTR [edi+4]
	cmp	al, 143					; 0000008fH
	jbe	SHORT $LN13@get_bits

; 539  :               process_unexpected_marker(byte);

	push	eax
	mov	ecx, esi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
$LN13@get_bits:

; 540  :             have_FF = (byte==0xFF);

	cmp	BYTE PTR [edi+4], 255			; 000000ffH
	sete	al
	mov	BYTE PTR [esi+535], al
$LN12@get_bits:

; 3520 :                 header_bytes++;

	inc	DWORD PTR [edi+12]
$LN4@get_bits:

; 3521 :               }
; 3522 :             int xfer_bits = (num_bits<bits_left)?num_bits:bits_left;

	mov	eax, DWORD PTR [edi+8]
	mov	esi, eax

; 3523 :             bits_left -= xfer_bits;
; 3524 :             num_bits -= xfer_bits;
; 3525 :             result <<= xfer_bits;
; 3526 :             result |= ((byte >> bits_left) & ~(0xFF << xfer_bits));

	movzx	edx, BYTE PTR [edi+4]
	cmp	ebx, eax
	cmovl	esi, ebx
	sub	eax, esi
	sub	ebx, esi
	mov	cl, al
	mov	DWORD PTR [edi+8], eax
	shr	edx, cl
	mov	eax, 255				; 000000ffH
	mov	ecx, esi
	shl	eax, cl
	not	eax
	and	edx, eax
	mov	eax, DWORD PTR _result$1$[ebp]
	shl	eax, cl
	or	eax, edx
	mov	DWORD PTR _result$1$[ebp], eax
	test	ebx, ebx
	jg	$LL2@get_bits
	pop	esi
$LN3@get_bits:
	pop	edi
	pop	ebx

; 3527 :           }
; 3528 :         return result;
; 3529 :       }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN24@get_bits:

; 3519 :                   { bits_left = 0; throw this; }

	push	OFFSET __TI2PAVkd_header_in@@
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edi+8], 0
	push	eax
	mov	DWORD PTR $T1[ebp], edi
	call	__CxxThrowException@8
$LN25@get_bits:
$LN23@get_bits:
	int	3
?get_bits@kd_header_in@@QAEIH@Z ENDP			; kd_header_in::get_bits
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_bit@kd_header_in@@QAEHXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?get_bit@kd_header_in@@QAEHXZ PROC			; kd_header_in::get_bit, COMDAT
; _this$ = ecx

; 3500 :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 3501 :         if (bits_left==0)

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN2@get_bit

; 3502 :           {
; 3503 :             bits_left = (byte==0xFF)?7:8;
; 3504 :             if (!source->get(byte))

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [esi+4]
	xor	eax, eax
	cmp	BYTE PTR [edx], 255			; 000000ffH
	push	edx
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+8], eax
	call	?get@kd_input@@QAE_NAAE@Z		; kd_input::get
	test	al, al
	je	SHORT $LN6@get_bit

; 3506 :             header_bytes++;

	inc	DWORD PTR [esi+12]
$LN2@get_bit:

; 3507 :           }
; 3508 :         bits_left--;

	dec	DWORD PTR [esi+8]

; 3509 :         return (byte >> bits_left) & 1;

	movzx	eax, BYTE PTR [esi+4]
	mov	cl, BYTE PTR [esi+8]
	shr	eax, cl
	and	eax, 1
	pop	esi

; 3510 :       }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@get_bit:

; 3505 :               { bits_left = 0; throw this; }

	push	OFFSET __TI2PAVkd_header_in@@
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [esi+8], 0
	push	eax
	mov	DWORD PTR $T1[ebp], esi
	call	__CxxThrowException@8
$LN8@get_bit:
$LN5@get_bit:
	int	3
?get_bit@kd_header_in@@QAEHXZ ENDP			; kd_header_in::get_bit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get@kd_input@@QAE_NAAE@Z
_TEXT	SEGMENT
_byte$ = 8						; size = 4
?get@kd_input@@QAE_NAAE@Z PROC				; kd_input::get, COMDAT
; _this$ = ecx

; 531  :       { /* Access a single byte, returning false if and only if the source is

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 532  :            exhausted, in which case future calls to `failed' return true. */
; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))

	cmp	BYTE PTR [esi+533], 0
	jne	SHORT $LN3@get
	mov	eax, DWORD PTR [esi+524]
	cmp	eax, DWORD PTR [esi+528]
	jne	SHORT $LN2@get
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	SHORT $LN3@get
$LN2@get:

; 535  :         byte = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	push	edi
	mov	edi, DWORD PTR _byte$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edi], al
	inc	DWORD PTR [esi+524]

; 536  :         if (throw_markers)

	cmp	BYTE PTR [esi+534], 0
	je	SHORT $LN4@get

; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [esi+535], 0
	je	SHORT $LN5@get
	mov	al, BYTE PTR [edi]
	cmp	al, 143					; 0000008fH
	jbe	SHORT $LN5@get

; 539  :               process_unexpected_marker(byte);

	push	eax
	mov	ecx, esi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
$LN5@get:

; 540  :             have_FF = (byte==0xFF);

	cmp	BYTE PTR [edi], 255			; 000000ffH
	sete	al
	mov	BYTE PTR [esi+535], al
$LN4@get:

; 541  :           }
; 542  :         return true;

	pop	edi
	mov	al, 1
	pop	esi

; 543  :       }

	pop	ebp
	ret	4
$LN3@get:

; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.

	xor	al, al
	pop	esi

; 543  :       }

	pop	ebp
	ret	4
?get@kd_input@@QAE_NAAE@Z ENDP				; kd_input::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get@kd_thread_buf_server@@QAEPAUkd_code_buffer@@XZ
_TEXT	SEGMENT
?get@kd_thread_buf_server@@QAEPAUkd_code_buffer@@XZ PROC ; kd_thread_buf_server::get, COMDAT
; _this$ = ecx

; 363  :       { /* Behaves like `kd_buf_server::get', but allocates initially

	push	esi
	mov	esi, ecx

; 364  :            from the thread's local buffer store, getting extra data from the
; 365  :            codestream specified in the most recent call to
; 366  :            `set_codestream_buf_server' where required.  This function must
; 367  :            not be called while holding any lock, since it may need to
; 368  :            temporarily instantiate a lock to get extra storage from the
; 369  :            underlying codestream. */
; 370  :         if (head == NULL) augment_local_store(false);

	cmp	DWORD PTR [esi+16], 0
	jne	SHORT $LN2@get
	push	0
	call	?augment_local_store@kd_thread_buf_server@@QAEX_N@Z ; kd_thread_buf_server::augment_local_store
$LN2@get:

; 371  :         kd_code_buffer *result = head;

	mov	eax, DWORD PTR [esi+16]

; 372  :         if ((head = result->next) == NULL)

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+16], ecx
	test	ecx, ecx
	jne	SHORT $LN3@get

; 373  :           tail = NULL;

	mov	DWORD PTR [esi+20], ecx
$LN3@get:

; 374  :         result->next = NULL;

	mov	DWORD PTR [eax], 0

; 375  :         num_available_buffers--;

	dec	DWORD PTR [esi+8]
	pop	esi

; 376  :         return result;
; 377  :       }

	ret	0
?get@kd_thread_buf_server@@QAEPAUkd_code_buffer@@XZ ENDP ; kd_thread_buf_server::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?set_max_contexts@kdu_block@@QAEXH@Z
_TEXT	SEGMENT
_new_contexts$ = 8					; size = 4
?set_max_contexts@kdu_block@@QAEXH@Z PROC		; kdu_block::set_max_contexts, COMDAT
; _this$ = ecx

; 270  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 271  :   if (max_contexts >= new_contexts)

	mov	edi, DWORD PTR _new_contexts$[ebp]
	cmp	DWORD PTR [esi+120], edi
	jge	SHORT $LN1@set_max_co

; 272  :     return;
; 273  :   if (context_buffer != NULL)

	mov	eax, DWORD PTR [esi+112]
	test	eax, eax
	je	SHORT $LN3@set_max_co

; 274  :     { delete[] context_buffer;  context_buffer = NULL; }

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+112], 0
$LN3@set_max_co:

; 275  :   context_buffer = new kdu_int32[new_contexts];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+112], eax

; 276  :   max_contexts = new_contexts;

	mov	DWORD PTR [esi+120], edi
$LN1@set_max_co:
	pop	edi
	pop	esi

; 277  : }

	pop	ebp
	ret	4
?set_max_contexts@kdu_block@@QAEXH@Z ENDP		; kdu_block::set_max_contexts
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?set_max_samples@kdu_block@@QAEXH@Z
_TEXT	SEGMENT
_new_samples$ = 8					; size = 4
?set_max_samples@kdu_block@@QAEXH@Z PROC		; kdu_block::set_max_samples, COMDAT
; _this$ = ecx

; 251  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 252  :   if (max_samples >= new_samples)

	mov	edi, DWORD PTR _new_samples$[ebp]
	cmp	DWORD PTR [esi+116], edi
	jge	SHORT $LN1@set_max_sa

; 253  :     return;
; 254  :   if (sample_handle != NULL)

	mov	eax, DWORD PTR [esi+128]
	test	eax, eax
	je	SHORT $LN3@set_max_sa

; 255  :     delete[] sample_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@set_max_sa:

; 256  :   sample_buffer = sample_handle = new kdu_int32[new_samples+3];

	xor	ecx, ecx
	lea	eax, DWORD PTR [edi+3]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 257  :   max_samples = new_samples;
; 258  :   int alignment = (int)(_addr_to_kdu_int32(sample_buffer) & 0x0F);
; 259  :   assert(!(alignment & 3));
; 260  :   alignment >>= 2; // Measure in 32-bit integers
; 261  :   sample_buffer += (4-alignment) & 3;

	mov	ecx, eax
	mov	DWORD PTR [esi+128], eax
	sar	ecx, 2
	add	esp, 4
	neg	ecx
	mov	DWORD PTR [esi+116], edi
	and	ecx, 3
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+108], eax
$LN1@set_max_sa:
	pop	edi
	pop	esi

; 262  : }

	pop	ebp
	ret	4
?set_max_samples@kdu_block@@QAEXH@Z ENDP		; kdu_block::set_max_samples
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?set_max_bytes@kdu_block@@QAEXH_N@Z
_TEXT	SEGMENT
_new_bytes$ = 8						; size = 4
_copy_existing$ = 12					; size = 1
?set_max_bytes@kdu_block@@QAEXH_N@Z PROC		; kdu_block::set_max_bytes, COMDAT
; _this$ = ecx

; 224  : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 225  :   if (max_bytes >= new_bytes)

	mov	ebx, DWORD PTR _new_bytes$[ebp]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+68]
	cmp	eax, ebx
	jge	SHORT $LN1@set_max_by

; 226  :     return;
; 227  :   if (max_bytes == 0)

	test	eax, eax
	je	SHORT $LN4@set_max_by

; 228  :     copy_existing = false;
; 229  :   if (copy_existing)

	cmp	BYTE PTR _copy_existing$[ebp], 0
	je	SHORT $LN4@set_max_by

; 230  :     {
; 231  :       kdu_byte *new_buf = (new kdu_byte[new_bytes+1])+1;

	lea	eax, DWORD PTR [ebx+1]
	push	esi
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 232  :       memcpy(new_buf,byte_buffer,max_bytes);

	push	DWORD PTR [edi+68]
	push	DWORD PTR [edi+60]
	lea	esi, DWORD PTR [eax+1]
	push	esi
	call	_memcpy

; 233  :       delete[] (byte_buffer-1);

	mov	eax, DWORD PTR [edi+60]
	dec	eax
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 20					; 00000014H

; 234  :       byte_buffer = new_buf;

	mov	DWORD PTR [edi+60], esi

; 241  :     }
; 242  :   max_bytes = new_bytes;

	mov	DWORD PTR [edi+68], ebx
	pop	esi
	pop	edi
	pop	ebx

; 243  : }

	pop	ebp
	ret	8
$LN4@set_max_by:

; 235  :     }
; 236  :   else
; 237  :     {
; 238  :       if (byte_buffer != NULL)

	mov	eax, DWORD PTR [edi+60]
	test	eax, eax
	je	SHORT $LN6@set_max_by

; 239  :         { delete[] (byte_buffer-1);  byte_buffer = NULL; }

	dec	eax
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [edi+60], 0
$LN6@set_max_by:

; 240  :       byte_buffer = (new kdu_byte[new_bytes+1])+1;

	lea	eax, DWORD PTR [ebx+1]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 241  :     }
; 242  :   max_bytes = new_bytes;

	mov	DWORD PTR [edi+68], ebx
	inc	eax
	mov	DWORD PTR [edi+60], eax
$LN1@set_max_by:
	pop	edi
	pop	ebx

; 243  : }

	pop	ebp
	ret	8
?set_max_bytes@kdu_block@@QAEXH_N@Z ENDP		; kdu_block::set_max_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?set_max_passes@kdu_block@@QAEXH_N@Z
_TEXT	SEGMENT
_new_passes$ = 8					; size = 4
_new_pass_slopes$1$ = 12				; size = 4
_copy_existing$ = 12					; size = 1
?set_max_passes@kdu_block@@QAEXH_N@Z PROC		; kdu_block::set_max_passes, COMDAT
; _this$ = ecx

; 187  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 188  :   if (max_passes >= new_passes)

	mov	edi, DWORD PTR _new_passes$[ebp]
	mov	eax, DWORD PTR [esi+64]
	cmp	eax, edi
	jge	$LN1@set_max_pa

; 189  :     return;
; 190  :   if (max_passes == 0)

	test	eax, eax
	je	$LN7@set_max_pa

; 191  :     copy_existing = false;
; 192  :   if (copy_existing)

	cmp	BYTE PTR _copy_existing$[ebp], 0
	je	$LN7@set_max_pa

; 193  :     {
; 194  :       int *new_pass_lengths = new int[new_passes];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	push	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ebx, eax

; 195  :       kdu_uint16 *new_pass_slopes = new kdu_uint16[new_passes];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 196  :       for (int n=0; n < max_passes; n++)

	xor	ecx, ecx
	add	esp, 8
	mov	edx, eax
	mov	DWORD PTR _new_pass_slopes$1$[ebp], edx
	cmp	DWORD PTR [esi+64], ecx
	jle	SHORT $LN3@set_max_pa
	npad	7
$LL4@set_max_pa:

; 197  :         {
; 198  :           new_pass_lengths[n] = pass_lengths[n];

	mov	eax, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ebx+ecx*4], eax

; 199  :           new_pass_slopes[n] = pass_slopes[n];

	mov	eax, DWORD PTR [esi+56]
	mov	ax, WORD PTR [eax+ecx*2]
	mov	WORD PTR [edx+ecx*2], ax
	inc	ecx
	cmp	ecx, DWORD PTR [esi+64]
	jl	SHORT $LL4@set_max_pa
$LN3@set_max_pa:

; 200  :         }
; 201  :       delete[] pass_lengths;

	push	DWORD PTR [esi+52]
	call	??_V@YAXPAX@Z				; operator delete[]

; 202  :       delete[] pass_slopes;

	push	DWORD PTR [esi+56]
	call	??_V@YAXPAX@Z				; operator delete[]

; 203  :       pass_lengths = new_pass_lengths;
; 204  :       pass_slopes = new_pass_slopes;

	mov	eax, DWORD PTR _new_pass_slopes$1$[ebp]
	add	esp, 8
	mov	DWORD PTR [esi+52], ebx

; 214  :     }
; 215  :   max_passes = new_passes;

	mov	DWORD PTR [esi+64], edi
	mov	DWORD PTR [esi+56], eax
	pop	ebx
	pop	edi
	pop	esi

; 216  : }

	pop	ebp
	ret	8
$LN7@set_max_pa:

; 205  :     }
; 206  :   else
; 207  :     {
; 208  :       if (pass_lengths != NULL)

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN9@set_max_pa

; 209  :         { delete[] pass_lengths; pass_lengths = NULL; }

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+52], 0
$LN9@set_max_pa:

; 210  :       if (pass_slopes != NULL)

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN10@set_max_pa

; 211  :         { delete[] pass_slopes; pass_slopes = NULL; }

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+56], 0
$LN10@set_max_pa:

; 212  :       pass_lengths = new int[new_passes];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+52], eax

; 213  :       pass_slopes = new kdu_uint16[new_passes];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 8
	mov	DWORD PTR [esi+56], eax

; 214  :     }
; 215  :   max_passes = new_passes;

	mov	DWORD PTR [esi+64], edi
$LN1@set_max_pa:
	pop	edi
	pop	esi

; 216  : }

	pop	ebp
	ret	8
?set_max_passes@kdu_block@@QAEXH_N@Z ENDP		; kdu_block::set_max_passes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ??1kdu_block@@AAE@XZ
_TEXT	SEGMENT
??1kdu_block@@AAE@XZ PROC				; kdu_block::~kdu_block, COMDAT
; _this$ = ecx

; 168  : {

	push	esi
	mov	esi, ecx

; 169  :   if (pass_lengths != NULL)

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN2@kdu_block

; 170  :     delete[] pass_lengths;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kdu_block:

; 171  :   if (pass_slopes != NULL)

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN3@kdu_block

; 172  :     delete[] pass_slopes;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@kdu_block:

; 173  :   if (byte_buffer != NULL)

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN4@kdu_block

; 174  :     delete[] (byte_buffer-1);

	dec	eax
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN4@kdu_block:

; 175  :   if (sample_handle != NULL)

	mov	eax, DWORD PTR [esi+128]
	test	eax, eax
	je	SHORT $LN5@kdu_block

; 176  :     delete[] sample_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@kdu_block:

; 177  :   if (context_buffer != NULL)

	mov	eax, DWORD PTR [esi+112]
	pop	esi
	test	eax, eax
	je	SHORT $LN6@kdu_block

; 178  :     delete[] context_buffer;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN6@kdu_block:

; 179  : }

	ret	0
??1kdu_block@@AAE@XZ ENDP				; kdu_block::~kdu_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ??0kdu_block@@AAE@XZ
_TEXT	SEGMENT
??0kdu_block@@AAE@XZ PROC				; kdu_block::kdu_block, COMDAT
; _this$ = ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 161  : }

	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp

; 148  :   transpose = vflip = hflip = false;

	mov	WORD PTR [ecx+25], 0
	mov	BYTE PTR [ecx+24], 0

; 149  :   pass_lengths = NULL; pass_slopes = NULL; max_passes = 0;

	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+64], 0

; 150  :   byte_buffer = NULL;  max_bytes = 0;

	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+68], 0

; 151  :   sample_buffer = sample_handle = NULL; max_samples = 0;

	mov	DWORD PTR [ecx+128], 0
	mov	DWORD PTR [ecx+108], 0
	mov	DWORD PTR [ecx+116], 0

; 152  :   context_buffer = NULL; max_contexts = 0;

	mov	DWORD PTR [ecx+112], 0
	mov	DWORD PTR [ecx+120], 0

; 153  :   cpu_iterations = 0;

	mov	DWORD PTR [ecx+132], 0

; 154  :   cpu_time = 0;

	mov	DWORD PTR [ecx+148], 0

; 155  :   cpu_unique_samples = 0;

	mov	DWORD PTR [ecx+136], 0
	mov	DWORD PTR [ecx+140], 0

; 156  :   resilient = fussy = false;

	mov	WORD PTR [ecx+36], 0

; 157  :   errors_detected = false;

	mov	WORD PTR [ecx+124], 0

; 158  :   insufficient_precision_detected = false;
; 159  :   precinct = NULL;

	mov	DWORD PTR [ecx+152], 0

; 160  :   block = NULL;

	mov	DWORD PTR [ecx+156], 0

; 161  : }

	ret	0
??0kdu_block@@AAE@XZ ENDP				; kdu_block::kdu_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_dims@@QAE@XZ
_TEXT	SEGMENT
??0kdu_dims@@QAE@XZ PROC				; kdu_dims::kdu_dims, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0

; 304  :     kdu_dims() {};

	mov	eax, ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0

; 304  :     kdu_dims() {};

	ret	0
??0kdu_dims@@QAE@XZ ENDP				; kdu_dims::kdu_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_coords@@QAE@XZ
_TEXT	SEGMENT
??0kdu_coords@@QAE@XZ PROC				; kdu_coords::kdu_coords, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kdu_coords@@QAE@XZ ENDP				; kdu_coords::kdu_coords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?write@kdu_output@@QAEXPAEH@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_count$ = 12						; size = 4
?write@kdu_output@@QAEXPAEH@Z PROC			; kdu_output::write, COMDAT
; _this$ = ecx

; 175  :       {

	push	ebp
	mov	ebp, esp
	push	ebx

; 176  :       /* [SYNOPSIS] Writes zero or more bytes from the supplied buffer.
; 177  :          [ARG: buf] Points to the source byte buffer.
; 178  :          [ARG: count] The number of bytes to write from the buffer. */
; 179  :         while (count > 0)

	mov	ebx, DWORD PTR _count$[ebp]
	push	esi
	mov	esi, ecx
	test	ebx, ebx
	jle	SHORT $LN3@write
	push	edi
	mov	edi, DWORD PTR _buf$[ebp]
$LL2@write:

; 180  :           {
; 181  :             int xfer_bytes = (int)(end_buf - next_buf);

	mov	eax, DWORD PTR [esi+520]
	sub	eax, DWORD PTR [esi+516]

; 182  :             if (xfer_bytes == 0)

	jne	SHORT $LN6@write

; 183  :               { flush_buf(); xfer_bytes = (int)(end_buf - next_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi+520]
	sub	eax, DWORD PTR [esi+516]
$LN6@write:

; 184  :             xfer_bytes = (count < xfer_bytes)?count:xfer_bytes;

	cmp	ebx, eax
	cmovl	eax, ebx

; 185  :             count -= xfer_bytes;

	sub	ebx, eax

; 186  :             while (xfer_bytes--)

	test	eax, eax
	je	SHORT $LN10@write
	npad	2
$LL4@write:

; 187  :               *(next_buf++) = *(buf++);

	mov	edx, DWORD PTR [esi+516]
	mov	cl, BYTE PTR [edi]
	inc	edi
	mov	BYTE PTR [edx], cl
	inc	DWORD PTR [esi+516]
	sub	eax, 1
	jne	SHORT $LL4@write
$LN10@write:

; 176  :       /* [SYNOPSIS] Writes zero or more bytes from the supplied buffer.
; 177  :          [ARG: buf] Points to the source byte buffer.
; 178  :          [ARG: count] The number of bytes to write from the buffer. */
; 179  :         while (count > 0)

	test	ebx, ebx
	jg	SHORT $LL2@write
	pop	edi
$LN3@write:
	pop	esi
	pop	ebx

; 188  :           }
; 189  :       }

	pop	ebp
	ret	8
?write@kdu_output@@QAEXPAEH@Z ENDP			; kdu_output::write
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?put@kdu_output@@QAEHE@Z
_TEXT	SEGMENT
_byte$ = 8						; size = 1
?put@kdu_output@@QAEHE@Z PROC				; kdu_output::put, COMDAT
; _this$ = ecx

; 138  :       {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 139  :       /* [SYNOPSIS] Writes a single byte.
; 140  :          [RETURNS] Always returns 1. */
; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN2@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
$LN2@put:

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
	mov	al, BYTE PTR _byte$[ebp]
	mov	BYTE PTR [ecx], al

; 144  :         return 1;

	mov	eax, 1
	inc	DWORD PTR [esi+516]
	pop	esi

; 145  :       }

	pop	ebp
	ret	4
?put@kdu_output@@QAEHE@Z ENDP				; kdu_output::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\blocks.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
