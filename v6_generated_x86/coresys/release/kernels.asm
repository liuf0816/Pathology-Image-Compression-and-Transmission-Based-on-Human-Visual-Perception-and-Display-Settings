; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\kernels\kernels.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	??0kdu_kernel_step_info@@QAE@XZ			; kdu_kernel_step_info::kdu_kernel_step_info
PUBLIC	?init@kdu_kernels@@QAEXH_N@Z			; kdu_kernels::init
PUBLIC	?init@kdu_kernels@@QAEXHPBUkdu_kernel_step_info@@PBM_N22@Z ; kdu_kernels::init
PUBLIC	?get_impulse_response@kdu_kernels@@QAEPAMW4kdu_kernel_type@@AAHPAH2@Z ; kdu_kernels::get_impulse_response
PUBLIC	?get_energy_gain@kdu_kernels@@QAENHHQA_N@Z	; kdu_kernels::get_energy_gain
PUBLIC	?get_bibo_gain@kdu_kernels@@QAENHHQA_N@Z	; kdu_kernels::get_bibo_gain
PUBLIC	?get_bibo_gains@kdu_kernels@@QAEPANHHQA_NAAN1@Z	; kdu_kernels::get_bibo_gains
PUBLIC	?clear@kdu_kernels@@AAEXXZ			; kdu_kernels::clear
PUBLIC	?reset@kdu_kernels@@AAEXXZ			; kdu_kernels::reset
PUBLIC	?derive_taps_and_gains@kdu_kernels@@AAEXXZ	; kdu_kernels::derive_taps_and_gains
PUBLIC	?enlarge_work_buffers@kdu_kernels@@AAEXH@Z	; kdu_kernels::enlarge_work_buffers
PUBLIC	?expand_and_convolve@kdu_kernels@@AAEHPAPAMHPAMH0@Z ; kdu_kernels::expand_and_convolve
PUBLIC	??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@	; `string'
PUBLIC	??_C@_0DM@IMEJCDIE@The?5W9X7?5kernel?5may?5not?5be?5used?5@ ; `string'
PUBLIC	??_C@_0EA@EBONPOMG@Illegal?5DWT?5kernel?5ID?5used?5to?5co@ ; `string'
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__xmm@00000001000000010000000100000001
PUBLIC	__xmm@00000003000000020000000100000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??0kdu_error@@QAE@PBD@Z:PROC			; kdu_error::kdu_error
EXTRN	??1kdu_error@@UAE@XZ:PROC			; kdu_error::~kdu_error
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@00000003000000020000000100000000
CONST	SEGMENT
__xmm@00000003000000020000000100000000 DB 00H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 02H, 00H, 00H, 00H, 03H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000001000000010000000100000001
CONST	SEGMENT
__xmm@00000001000000010000000100000001 DB 01H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 01H, 00H, 00H, 00H, 01H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_C@_0EA@EBONPOMG@Illegal?5DWT?5kernel?5ID?5used?5to?5co@
CONST	SEGMENT
??_C@_0EA@EBONPOMG@Illegal?5DWT?5kernel?5ID?5used?5to?5co@ DB 'Illegal DW'
	DB	'T kernel ID used to construct a `kdu_kernels'' object.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@IMEJCDIE@The?5W9X7?5kernel?5may?5not?5be?5used?5@
CONST	SEGMENT
??_C@_0DM@IMEJCDIE@The?5W9X7?5kernel?5may?5not?5be?5used?5@ DB 'The W9X7 '
	DB	'kernel may not be used for reversible compression!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
CONST	SEGMENT
??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@ DB 'Kakadu Core Error:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?init@kdu_kernels@@QAEXH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?init@kdu_kernels@@QAEXH_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?init@kdu_kernels@@QAEXH_N@Z$3
__ehfuncinfo$?init@kdu_kernels@@QAEXH_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?init@kdu_kernels@@QAEXH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
;	COMDAT ?expand_and_convolve@kdu_kernels@@AAEHPAPAMHPAMH0@Z
_TEXT	SEGMENT
tv1367 = -20						; size = 4
_sp$1$ = -16						; size = 4
_dst_L$1$ = -12						; size = 4
tv1390 = -8						; size = 4
tv1391 = -4						; size = 4
tv1365 = 8						; size = 4
_dp$1$ = 8						; size = 4
_src$ = 8						; size = 4
_src_L$ = 12						; size = 4
_taps$ = 16						; size = 4
_taps_L$ = 20						; size = 4
_k$1$ = 24						; size = 4
_dst$ = 24						; size = 4
?expand_and_convolve@kdu_kernels@@AAEHPAPAMHPAMH0@Z PROC ; kdu_kernels::expand_and_convolve, COMDAT
; _this$ = ecx

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 193  :   int dst_L = 2*src_L + taps_L;

	mov	eax, DWORD PTR _src_L$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _taps_L$[ebp]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebx+eax*2]

; 194  :   enlarge_work_buffers(dst_L);

	push	edi
	mov	DWORD PTR _dst_L$1$[ebp], edi
	call	?enlarge_work_buffers@kdu_kernels@@AAEXH@Z ; kdu_kernels::enlarge_work_buffers

; 195  :   float val, *dpp, *sp = *src, *dp = *dst;

	mov	eax, DWORD PTR _src$[ebp]

; 196  :   assert((sp == work1) || (sp == work2));
; 197  :   assert((dp == work1) || (dp == work2));
; 198  :   assert(dst_L <= work_L);
; 199  : 
; 200  :   int n, k;
; 201  :   for (n=-dst_L; n <= dst_L; n++)

	mov	edx, edi
	neg	edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _sp$1$[ebp], eax
	mov	eax, DWORD PTR _dst$[ebp]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _dp$1$[ebp], esi
	cmp	edx, edi
	jg	SHORT $LN3@expand_and

; 202  :     dp[n] = 0.0F;

	mov	eax, edi
	lea	edi, DWORD PTR [esi+edx*4]
	sub	eax, edx
	lea	ecx, DWORD PTR [eax*4+4]
	shr	ecx, 2
	xor	eax, eax
	rep stosd
	mov	edi, DWORD PTR _dst_L$1$[ebp]
$LN3@expand_and:

; 203  :   for (k=-src_L; k <= src_L; k++)

	mov	ecx, DWORD PTR _src_L$[ebp]
	neg	ecx
	mov	DWORD PTR _k$1$[ebp], ecx
	cmp	ecx, DWORD PTR _src_L$[ebp]
	jg	$LN34@expand_and

; 206  :       for (dpp=dp+(2*k), n=-taps_L; n <= taps_L; n++)

	mov	eax, ebx
	mov	edx, ebx
	neg	eax
	sub	edx, eax
	mov	DWORD PTR tv1391[ebp], eax
	lea	eax, DWORD PTR [ecx*8]
	inc	edx
	lea	edi, DWORD PTR [eax+esi]
	mov	DWORD PTR tv1390[ebp], edx
	mov	esi, DWORD PTR _taps$[ebp]
	sub	esi, eax
	sub	esi, DWORD PTR _dp$1$[ebp]
	mov	DWORD PTR tv1365[ebp], esi
$LL7@expand_and:

; 204  :     {
; 205  :       val = sp[k];

	mov	eax, DWORD PTR _sp$1$[ebp]
	movss	xmm2, DWORD PTR [eax+ecx*4]

; 206  :       for (dpp=dp+(2*k), n=-taps_L; n <= taps_L; n++)

	mov	eax, DWORD PTR tv1391[ebp]
	movaps	xmm3, xmm2
	shufps	xmm3, xmm3, 0
	mov	edx, eax
	cmp	eax, ebx
	jg	$LN19@expand_and
	cmp	DWORD PTR tv1390[ebp], 8
	jb	$LN19@expand_and

; 207  :         dpp[n] += val * taps[n];

	mov	eax, DWORD PTR _taps$[ebp]
	lea	ecx, DWORD PTR [eax+ebx*4]
	mov	eax, edx
	lea	eax, DWORD PTR [edi+eax*4]
	cmp	eax, ecx
	ja	SHORT $LN20@expand_and
	mov	esi, edx
	lea	eax, DWORD PTR [edi+ebx*4]
	mov	edx, DWORD PTR _taps$[ebp]
	lea	ecx, DWORD PTR [edx+esi*4]
	mov	edx, esi
	mov	esi, DWORD PTR tv1365[ebp]
	cmp	eax, ecx
	jae	SHORT $LN36@expand_and
$LN20@expand_and:
	mov	eax, DWORD PTR tv1390[ebp]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN37@expand_and
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN37@expand_and:
	mov	ecx, DWORD PTR _taps$[ebp]
	mov	esi, ebx
	mov	ebx, DWORD PTR tv1365[ebp]
	sub	esi, eax
	mov	eax, DWORD PTR tv1391[ebp]
	lea	ecx, DWORD PTR [ecx+eax*4]
	lea	eax, DWORD PTR [edx+4]
	lea	eax, DWORD PTR [edi+eax*4]
	npad	2
$LL10@expand_and:
	movups	xmm1, XMMWORD PTR [ecx]
	add	edx, 8
	add	ecx, 32					; 00000020H
	movups	xmm0, XMMWORD PTR [eax-16]
	mulps	xmm1, xmm3
	addps	xmm1, xmm0
	movups	XMMWORD PTR [eax-16], xmm1
	movups	xmm1, XMMWORD PTR [eax+ebx]
	movups	xmm0, XMMWORD PTR [eax]
	mulps	xmm1, xmm3
	addps	xmm1, xmm0
	movups	XMMWORD PTR [eax], xmm1
	add	eax, 32					; 00000020H
	cmp	edx, esi
	jle	SHORT $LL10@expand_and
	mov	ebx, DWORD PTR _taps_L$[ebp]
	mov	esi, DWORD PTR tv1365[ebp]
$LN36@expand_and:
	mov	ecx, DWORD PTR _k$1$[ebp]
$LN19@expand_and:
	cmp	edx, ebx
	jg	$LN5@expand_and

; 206  :       for (dpp=dp+(2*k), n=-taps_L; n <= taps_L; n++)

	mov	eax, ebx
	sub	eax, edx
	inc	eax
	cmp	eax, 4
	jl	SHORT $LC27@expand_and
	mov	ecx, DWORD PTR _taps$[ebp]
	lea	eax, DWORD PTR [edx+1]
	lea	eax, DWORD PTR [edi+eax*4]
	lea	esi, DWORD PTR [ecx+12]
	sub	ecx, edi
	mov	DWORD PTR tv1367[ebp], ecx
	lea	esi, DWORD PTR [esi+edx*4]
	mov	ecx, ebx
	mov	ebx, DWORD PTR tv1367[ebp]
	sub	ecx, edx
	sub	ecx, 3
	shr	ecx, 2
	inc	ecx
	lea	edx, DWORD PTR [edx+ecx*4]
	npad	2
$LL28@expand_and:

; 207  :         dpp[n] += val * taps[n];

	movss	xmm0, DWORD PTR [esi-12]
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax-4]
	movss	DWORD PTR [eax-4], xmm0
	movss	xmm0, DWORD PTR [eax+ebx]
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [esi-4]
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [eax+4], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [esi]
	add	esi, 16					; 00000010H
	addss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [eax+8], xmm0
	add	eax, 16					; 00000010H
	sub	ecx, 1
	jne	SHORT $LL28@expand_and
	mov	ebx, DWORD PTR _taps_L$[ebp]
$LC27@expand_and:

; 206  :       for (dpp=dp+(2*k), n=-taps_L; n <= taps_L; n++)

	cmp	edx, ebx
	jg	SHORT $LN35@expand_and
	mov	esi, DWORD PTR _taps$[ebp]
	lea	eax, DWORD PTR [edi+edx*4]
	mov	ecx, ebx
	sub	esi, edi
	sub	ecx, edx
	inc	ecx
	npad	9
$LC18@expand_and:

; 207  :         dpp[n] += val * taps[n];

	movss	xmm0, DWORD PTR [esi+eax]
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LC18@expand_and
$LN35@expand_and:
	mov	esi, DWORD PTR tv1365[ebp]
	mov	ecx, DWORD PTR _k$1$[ebp]
$LN5@expand_and:

; 203  :   for (k=-src_L; k <= src_L; k++)

	inc	ecx
	sub	esi, 8
	add	edi, 8
	mov	DWORD PTR _k$1$[ebp], ecx
	mov	DWORD PTR tv1365[ebp], esi
	cmp	ecx, DWORD PTR _src_L$[ebp]
	jle	$LL7@expand_and

; 208  :     }
; 209  : 
; 210  :   return dst_L;

	mov	eax, DWORD PTR _dst_L$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 211  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN34@expand_and:

; 208  :     }
; 209  : 
; 210  :   return dst_L;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 211  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?expand_and_convolve@kdu_kernels@@AAEHPAPAMHPAMH0@Z ENDP ; kdu_kernels::expand_and_convolve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
;	COMDAT ?enlarge_work_buffers@kdu_kernels@@AAEXH@Z
_TEXT	SEGMENT
_w2$1$ = -8						; size = 4
_w1$1$ = -4						; size = 4
_min_work_L$ = 8					; size = 4
?enlarge_work_buffers@kdu_kernels@@AAEXH@Z PROC		; kdu_kernels::enlarge_work_buffers, COMDAT
; _this$ = ecx

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  :   if (work_L >= min_work_L)

	mov	eax, DWORD PTR _min_work_L$[ebp]
	sub	esp, 8
	push	ebx
	mov	ebx, ecx
	cmp	DWORD PTR [ebx+104], eax
	jge	$LN1@enlarge_wo

; 165  :     return;
; 166  :   float *w1 = (new float[2*min_work_L+1]) + min_work_L;

	push	esi
	lea	esi, DWORD PTR [eax*2+1]
	xor	ecx, ecx
	push	edi
	lea	edi, DWORD PTR [eax*4]
	mov	edx, 4
	mov	eax, esi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	eax, edi

; 167  :   float *w2 = (new float[2*min_work_L+1]) + min_work_L;

	xor	ecx, ecx
	mov	DWORD PTR _w1$1$[ebp], eax
	mov	edx, 4
	mov	eax, esi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 168  :   if (work1 != NULL)

	mov	edx, DWORD PTR [ebx+108]
	add	eax, edi

; 169  :     {
; 170  :       memcpy(w1-work_L,work1-work_L,sizeof(float)*(size_t)(2*work_L+1));

	mov	esi, DWORD PTR _w1$1$[ebp]
	add	esp, 8
	mov	DWORD PTR _w2$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN3@enlarge_wo
	mov	eax, DWORD PTR [ebx+104]
	lea	ecx, DWORD PTR [eax*4]
	lea	eax, DWORD PTR [eax*8+4]
	sub	edx, ecx
	push	eax
	mov	eax, esi
	push	edx
	sub	eax, ecx
	push	eax
	call	_memcpy

; 171  :       delete[] (work1 - work_L);

	mov	ecx, DWORD PTR [ebx+104]
	mov	eax, DWORD PTR [ebx+108]
	shl	ecx, 2
	sub	eax, ecx
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 172  :       work1 = NULL;

	mov	DWORD PTR [ebx+108], 0
$LN3@enlarge_wo:

; 173  :     }
; 174  :   if (work2 != NULL)

	mov	edx, DWORD PTR [ebx+112]

; 175  :     {
; 176  :       memcpy(w2-work_L,work2-work_L,sizeof(float)*(size_t)(2*work_L+1));

	mov	edi, DWORD PTR _w2$1$[ebp]
	test	edx, edx
	je	SHORT $LN4@enlarge_wo
	mov	eax, DWORD PTR [ebx+104]
	lea	ecx, DWORD PTR [eax*4]
	lea	eax, DWORD PTR [eax*8+4]
	sub	edx, ecx
	push	eax
	mov	eax, edi
	push	edx
	sub	eax, ecx
	push	eax
	call	_memcpy

; 177  :       delete[] (work2 - work_L);

	mov	ecx, DWORD PTR [ebx+104]
	mov	eax, DWORD PTR [ebx+112]
	shl	ecx, 2
	sub	eax, ecx
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H

; 178  :       work2 = NULL;

	mov	DWORD PTR [ebx+112], 0
$LN4@enlarge_wo:

; 179  :     }
; 180  :   work1 = w1;
; 181  :   work2 = w2;
; 182  :   work_L = min_work_L;

	mov	eax, DWORD PTR _min_work_L$[ebp]
	mov	DWORD PTR [ebx+112], edi
	pop	edi
	mov	DWORD PTR [ebx+108], esi
	mov	DWORD PTR [ebx+104], eax
	pop	esi
$LN1@enlarge_wo:
	pop	ebx

; 183  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?enlarge_work_buffers@kdu_kernels@@AAEXH@Z ENDP		; kdu_kernels::enlarge_work_buffers
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
;	COMDAT ?derive_taps_and_gains@kdu_kernels@@AAEXXZ
_TEXT	SEGMENT
_branch_buf$ = -76					; size = 8
_branch_max$ = -68					; size = 8
_branch_min$ = -60					; size = 8
tv2891 = -52						; size = 4
tv2886 = -52						; size = 4
tv2880 = -52						; size = 4
tv2855 = -52						; size = 4
tv2828 = -52						; size = 4
_n$1$ = -48						; size = 4
tv2885 = -48						; size = 4
tv2881 = -48						; size = 4
tv2847 = -48						; size = 4
tv2829 = -48						; size = 4
tv2839 = -44						; size = 4
tv2772 = -44						; size = 4
_n$8$ = -40						; size = 4
_s$1$ = -40						; size = 4
_impulse_L$1$ = -36					; size = 4
tv2846 = -36						; size = 4
_step_parity$1$ = -32					; size = 4
tv2852 = -32						; size = 4
_n$3$ = -28						; size = 4
tv2845 = -28						; size = 4
_impulse_min$1$ = -24					; size = 4
tv2842 = -24						; size = 4
_impulse_max$1$ = -20					; size = 4
_Ns$1$ = -20						; size = 4
_this$1$ = -16						; size = 4
_which$1$ = -12						; size = 4
_analysis$1$ = -8					; size = 4
_Ps$1$ = -8						; size = 4
_synthesis$1$ = -4					; size = 4
_i$1$ = -4						; size = 4
_n$2$ = -4						; size = 4
?derive_taps_and_gains@kdu_kernels@@AAEXXZ PROC		; kdu_kernels::derive_taps_and_gains, COMDAT
; _this$ = ecx

; 317  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	esi
	push	edi
	mov	edi, ecx

; 318  :   bibo_step_gains = new double[num_steps];

	mov	edx, 8
	xor	ecx, ecx
	mov	DWORD PTR _this$1$[ebp], edi
	mov	eax, DWORD PTR [edi+8]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+96], eax
	add	esp, 4

; 319  : 
; 320  :   // Allocate initial work buffers of sufficient size
; 321  :   enlarge_work_buffers(max_step_length * num_steps);

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, edi
	imul	eax, DWORD PTR [edi+8]
	push	eax
	call	?enlarge_work_buffers@kdu_kernels@@AAEXH@Z ; kdu_kernels::enlarge_work_buffers

; 322  : 
; 323  :   // Fill in the impulse responses, without normalization
; 324  :   int n, s, which;
; 325  :   int branch_min[2], branch_max[2]; // Min/max indices for even/odd branches
; 326  :   float val, *fp, *branch_buf[2] = {work1,work2};

	mov	eax, DWORD PTR [edi+108]

; 327  :   for (which=0; which < 2; which++)

	xor	edx, edx
	mov	DWORD PTR _branch_buf$[ebp], eax
	mov	eax, DWORD PTR [edi+112]
	mov	DWORD PTR _branch_buf$[ebp+4], eax
	mov	DWORD PTR _which$1$[ebp], edx
	npad	4
$LL4@derive_tap:

; 328  :     { // Scan through the two different subbands
; 329  : 
; 330  :       // First, evaluate the synthesis impulse response for band `which'
; 331  :       (branch_buf[which])[0] = 1.0F;

	lea	ecx, DWORD PTR [edx*4]
	mov	eax, DWORD PTR _branch_buf$[ebp+ecx]

; 332  :       branch_min[which] = branch_max[which] = 0; // Impulse on this branch

	mov	DWORD PTR _branch_max$[ebp+ecx], 0
	mov	DWORD PTR _branch_min$[ebp+ecx], 0

; 333  :       branch_min[1-which] = 1;  branch_max[1-which] = -1; // Empty branch

	neg	ecx
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 334  :       for (s=num_steps-1; s >= 0; s--)

	mov	eax, DWORD PTR [edi+8]
	sub	eax, 1
	mov	DWORD PTR _branch_min$[ebp+ecx+4], 1
	mov	DWORD PTR _branch_max$[ebp+ecx+4], -1
	mov	DWORD PTR _s$1$[ebp], eax
	js	$LN6@derive_tap

; 328  :     { // Scan through the two different subbands
; 329  : 
; 330  :       // First, evaluate the synthesis impulse response for band `which'
; 331  :       (branch_buf[which])[0] = 1.0F;

	mov	esi, eax
	shl	esi, 4
	mov	DWORD PTR tv2842[ebp], esi
	npad	6
$LL7@derive_tap:

; 335  :         {
; 336  :           int i, step_parity = s & 1; // Identifies the source branch

	and	eax, 1
	mov	DWORD PTR _step_parity$1$[ebp], eax

; 337  :           if (branch_max[step_parity] < branch_min[step_parity])

	lea	edx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR _branch_min$[ebp+edx]
	mov	ecx, DWORD PTR _branch_max$[ebp+edx]
	mov	DWORD PTR _n$2$[ebp], eax
	cmp	ecx, eax
	jl	$LN5@derive_tap

; 338  :             continue;
; 339  :           int Ns = step_info[s].support_min;

	mov	eax, DWORD PTR [edi+16]

; 340  :           int Ps =  step_info[s].support_length - 1 + Ns;
; 341  :               // Cs[n] has coefficients in the range Ns <= n <= Ps
; 342  :               // Impulse response of lifting filter is Cs[-n]
; 343  :           if ((n=branch_max[step_parity]-Ns) > branch_max[1-step_parity])

	neg	edx
	mov	edi, DWORD PTR tv2842[ebp]
	mov	DWORD PTR tv2845[ebp], edx
	mov	esi, DWORD PTR [eax+esi+4]
	sub	ecx, esi
	mov	eax, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR _branch_max$[ebp+edx+4]
	dec	eax
	mov	edi, DWORD PTR _this$1$[ebp]
	add	eax, esi
	mov	DWORD PTR _Ns$1$[ebp], esi
	mov	DWORD PTR _Ps$1$[ebp], eax
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	ecx, edx
	jle	SHORT $LN9@derive_tap

; 344  :             while (branch_max[1-step_parity] < n)

	cmp	edx, ecx
	jge	SHORT $LN9@derive_tap

; 345  :               (branch_buf[1-step_parity])[++branch_max[1-step_parity]] = 0.0F;

	mov	eax, DWORD PTR _step_parity$1$[ebp]
	lea	ecx, DWORD PTR _branch_buf$[ebp+4]
	shl	eax, 2
	sub	ecx, eax
	mov	eax, DWORD PTR _n$1$[ebp]
	mov	ecx, DWORD PTR [ecx]
	npad	1
$LL8@derive_tap:
	inc	edx
	mov	DWORD PTR [ecx+edx*4], 0
	cmp	edx, eax
	jl	SHORT $LL8@derive_tap
	mov	eax, DWORD PTR tv2845[ebp]
	mov	DWORD PTR _branch_max$[ebp+eax+4], edx
	mov	eax, DWORD PTR _Ps$1$[ebp]
$LN9@derive_tap:

; 346  :           if ((n=branch_min[step_parity]-Ps) < branch_min[1-step_parity])

	mov	ecx, DWORD PTR _n$2$[ebp]
	sub	ecx, eax
	mov	eax, DWORD PTR tv2845[ebp]
	mov	DWORD PTR _n$2$[ebp], ecx
	mov	edx, DWORD PTR _branch_min$[ebp+eax+4]
	cmp	ecx, edx
	jge	SHORT $LN11@derive_tap

; 347  :             while (branch_min[1-step_parity] > n)

	cmp	edx, ecx
	jle	SHORT $LN11@derive_tap

; 348  :               (branch_buf[1-step_parity])[--branch_min[1-step_parity]] = 0.0F;

	mov	eax, DWORD PTR _step_parity$1$[ebp]
	lea	ecx, DWORD PTR _branch_buf$[ebp+4]
	shl	eax, 2
	sub	ecx, eax
	mov	eax, DWORD PTR _n$2$[ebp]
	mov	ecx, DWORD PTR [ecx]
	npad	3
$LL10@derive_tap:
	dec	edx
	mov	DWORD PTR [ecx+edx*4], 0
	cmp	edx, eax
	jg	SHORT $LL10@derive_tap
	mov	eax, DWORD PTR tv2845[ebp]
	mov	DWORD PTR _branch_min$[ebp+eax+4], edx
$LN11@derive_tap:

; 349  :           assert((branch_min[1-step_parity] >= -work_L) &&
; 350  :                  (branch_max[1-step_parity] <= work_L));
; 351  :           for (i=branch_min[step_parity]; i <= branch_max[step_parity]; i++)

	mov	edx, DWORD PTR _step_parity$1$[ebp]
	mov	ecx, DWORD PTR _branch_min$[ebp+edx*4]
	mov	eax, DWORD PTR _branch_max$[ebp+edx*4]
	mov	DWORD PTR _i$1$[ebp], ecx
	mov	DWORD PTR tv2891[ebp], eax
	cmp	ecx, eax
	jg	$LN160@derive_tap

; 356  :                 (branch_buf[1-step_parity])[i-n] -= val * *fp;

	lea	eax, DWORD PTR [edx*4]
	lea	edi, DWORD PTR _branch_buf$[ebp+4]
	sub	edi, eax
	mov	eax, DWORD PTR _branch_buf$[ebp+edx*4]
	mov	DWORD PTR tv2839[ebp], edi
	mov	edi, DWORD PTR _this$1$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, ecx
	sub	eax, esi
	mov	DWORD PTR tv2847[ebp], edx
	lea	eax, DWORD PTR [eax*4-8]
	mov	DWORD PTR tv2846[ebp], eax
$LL14@derive_tap:

; 334  :       for (s=num_steps-1; s >= 0; s--)

	movss	xmm2, DWORD PTR [edx]
	mov	eax, DWORD PTR [edi+20]
	mov	edx, DWORD PTR _s$1$[ebp]

; 352  :             {
; 353  :               val = (branch_buf[step_parity])[i];
; 354  :               fp = lifting_factors + s;
; 355  :               for (n=Ns; n <= Ps; n++, fp+=num_steps)

	mov	DWORD PTR _n$3$[ebp], esi
	lea	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _Ps$1$[ebp]
	cmp	DWORD PTR _Ns$1$[ebp], eax
	jg	$LN12@derive_tap
	sub	eax, DWORD PTR _Ns$1$[ebp]
	inc	eax
	cmp	eax, 4
	jl	$LC130@derive_tap

; 356  :                 (branch_buf[1-step_parity])[i-n] -= val * *fp;

	mov	eax, DWORD PTR tv2839[ebp]
	mov	esi, DWORD PTR _Ps$1$[ebp]
	mov	ecx, DWORD PTR _Ns$1$[ebp]
	sub	esi, ecx
	sub	esi, 3
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR tv2846[ebp]
	shr	esi, 2
	inc	esi
	mov	DWORD PTR tv2852[ebp], eax
	lea	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR _n$3$[ebp], ecx
	npad	1
$LL131@derive_tap:
	movss	xmm1, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [eax+8], xmm0
	mov	eax, DWORD PTR [edi+8]
	movss	xmm1, DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR tv2852[ebp]
	mulss	xmm1, xmm2
	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, xmm1
	movss	DWORD PTR [edx+4], xmm0
	mov	eax, DWORD PTR [edi+8]
	movss	xmm1, DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [edx], xmm0
	mov	eax, DWORD PTR [edi+8]
	movss	xmm1, DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	movss	xmm0, DWORD PTR [edx-4]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [edx-4], xmm0
	mov	eax, DWORD PTR [edi+8]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR tv2852[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR tv2852[ebp], eax
	sub	esi, 1
	jne	$LL131@derive_tap
	mov	esi, DWORD PTR _n$3$[ebp]
	mov	ecx, DWORD PTR _i$1$[ebp]
$LC130@derive_tap:

; 352  :             {
; 353  :               val = (branch_buf[step_parity])[i];
; 354  :               fp = lifting_factors + s;
; 355  :               for (n=Ns; n <= Ps; n++, fp+=num_steps)

	cmp	esi, DWORD PTR _Ps$1$[ebp]
	jg	SHORT $LN12@derive_tap

; 356  :                 (branch_buf[1-step_parity])[i-n] -= val * *fp;

	mov	eax, DWORD PTR tv2839[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _i$1$[ebp]
	sub	eax, esi
	mov	esi, DWORD PTR _Ps$1$[ebp]
	sub	esi, DWORD PTR _n$3$[ebp]
	inc	esi
	lea	ecx, DWORD PTR [ecx+eax*4]
	npad	11
$LC17@derive_tap:
	movss	xmm1, DWORD PTR [edx]
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [ecx], xmm0
	sub	ecx, 4
	mov	eax, DWORD PTR [edi+8]
	lea	edx, DWORD PTR [edx+eax*4]
	sub	esi, 1
	jne	SHORT $LC17@derive_tap
	mov	ecx, DWORD PTR _i$1$[ebp]
$LN12@derive_tap:

; 349  :           assert((branch_min[1-step_parity] >= -work_L) &&
; 350  :                  (branch_max[1-step_parity] <= work_L));
; 351  :           for (i=branch_min[step_parity]; i <= branch_max[step_parity]; i++)

	mov	edx, DWORD PTR tv2847[ebp]
	inc	ecx
	add	DWORD PTR tv2846[ebp], 4
	add	edx, 4
	mov	esi, DWORD PTR _Ns$1$[ebp]
	mov	DWORD PTR _i$1$[ebp], ecx
	mov	DWORD PTR tv2847[ebp], edx
	cmp	ecx, DWORD PTR tv2891[ebp]
	jle	$LL14@derive_tap
$LN160@derive_tap:
	mov	esi, DWORD PTR tv2842[ebp]
$LN5@derive_tap:

; 334  :       for (s=num_steps-1; s >= 0; s--)

	mov	eax, DWORD PTR _s$1$[ebp]
	sub	esi, 16					; 00000010H
	dec	eax
	mov	DWORD PTR tv2842[ebp], esi
	mov	DWORD PTR _s$1$[ebp], eax
	test	eax, eax
	jns	$LL7@derive_tap
$LN6@derive_tap:

; 357  :             }
; 358  :         }
; 359  : 
; 360  :       // Now the odd and even coefficients of the impulse response are in
; 361  :       // the two branches -- don't forget that the impulse was at location
; 362  :       // `which' -- we want the impulse response expressed relative to that
; 363  :       // location
; 364  : 
; 365  :       // Find the length of the impulse response
; 366  :       int impulse_min=100, impulse_max=-100; // Ridiculous values to start
; 367  :       for (s=0; s < 2; s++)
; 368  :         {
; 369  :           if (branch_max[s] < branch_min[s])

	mov	eax, DWORD PTR _branch_max$[ebp]
	mov	edx, 100				; 00000064H
	mov	esi, DWORD PTR _branch_min$[ebp]
	mov	ecx, -100				; ffffff9cH
	mov	DWORD PTR _impulse_min$1$[ebp], edx
	mov	DWORD PTR _impulse_max$1$[ebp], ecx
	cmp	eax, esi
	jl	SHORT $LN18@derive_tap

; 370  :             continue;
; 371  :           if ((n = 2*branch_max[s]+s-which) > impulse_max)

	add	eax, eax
	sub	eax, DWORD PTR _which$1$[ebp]
	cmp	eax, ecx
	cmovg	ecx, eax

; 372  :             impulse_max = n;
; 373  :           if ((n = 2*branch_min[s]+s-which) < impulse_min)

	lea	eax, DWORD PTR [esi+esi]
	sub	eax, DWORD PTR _which$1$[ebp]
	cmp	eax, edx
	mov	DWORD PTR _impulse_max$1$[ebp], ecx
	cmovl	edx, eax
	mov	DWORD PTR _impulse_min$1$[ebp], edx
$LN18@derive_tap:

; 357  :             }
; 358  :         }
; 359  : 
; 360  :       // Now the odd and even coefficients of the impulse response are in
; 361  :       // the two branches -- don't forget that the impulse was at location
; 362  :       // `which' -- we want the impulse response expressed relative to that
; 363  :       // location
; 364  : 
; 365  :       // Find the length of the impulse response
; 366  :       int impulse_min=100, impulse_max=-100; // Ridiculous values to start
; 367  :       for (s=0; s < 2; s++)
; 368  :         {
; 369  :           if (branch_max[s] < branch_min[s])

	mov	eax, DWORD PTR _branch_max$[ebp+4]
	mov	esi, DWORD PTR _branch_min$[ebp+4]
	cmp	eax, esi
	jl	SHORT $LN138@derive_tap

; 370  :             continue;
; 371  :           if ((n = 2*branch_max[s]+s-which) > impulse_max)

	add	eax, eax
	sub	eax, DWORD PTR _which$1$[ebp]
	inc	eax
	cmp	eax, ecx
	cmovg	ecx, eax

; 372  :             impulse_max = n;
; 373  :           if ((n = 2*branch_min[s]+s-which) < impulse_min)

	lea	eax, DWORD PTR [esi+esi]
	sub	eax, DWORD PTR _which$1$[ebp]
	inc	eax
	mov	DWORD PTR _impulse_max$1$[ebp], ecx
	cmp	eax, edx
	cmovl	edx, eax
	mov	DWORD PTR _impulse_min$1$[ebp], edx
$LN138@derive_tap:

; 374  :             impulse_min = n;
; 375  :         }
; 376  :       int impulse_L = // Find H, such that support contained in [-H,H]
; 377  :         ((impulse_min+impulse_max) < 0)?(-impulse_min):(impulse_max);

	lea	eax, DWORD PTR [ecx+edx]
	test	eax, eax
	jns	SHORT $LN61@derive_tap
	mov	esi, edx
	neg	esi
	mov	DWORD PTR _impulse_L$1$[ebp], esi
	jmp	SHORT $LN62@derive_tap
$LN61@derive_tap:
	mov	esi, ecx
	mov	DWORD PTR _impulse_L$1$[ebp], ecx
$LN62@derive_tap:

; 378  : 
; 379  :       // De-interleave the branch buffers into the synthesis impulse response
; 380  :       // buffer
; 381  :       float *synthesis = (new float[2*impulse_L+1]) + impulse_L;

	lea	edx, DWORD PTR [esi*2+1]
	xor	ecx, ecx
	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR tv2886[ebp], edx
	mov	DWORD PTR tv2885[ebp], eax
	mov	eax, edx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, eax

; 382  :       for (n=-impulse_L; n <= impulse_L; n++)

	mov	ecx, esi
	lea	eax, DWORD PTR [esi*4]
	neg	ecx
	add	edx, eax
	mov	DWORD PTR _n$8$[ebp], ecx
	add	esp, 4
	mov	DWORD PTR _synthesis$1$[ebp], edx
	cmp	ecx, esi
	jg	SHORT $LN22@derive_tap

; 383  :         synthesis[n] = 0.0F;

	mov	eax, esi
	mov	esi, DWORD PTR _n$8$[ebp]
	sub	eax, ecx
	lea	edi, DWORD PTR [edx+esi*4]
	lea	ecx, DWORD PTR [eax*4+4]
	shr	ecx, 2
	xor	eax, eax
	rep stosd
$LN22@derive_tap:

; 384  : 
; 385  :       for (s=0; s < 2; s++)

	xor	edi, edi
	npad	3
$LL26@derive_tap:

; 386  :         for (n=branch_min[s]; n <= branch_max[s]; n++)

	mov	esi, DWORD PTR _branch_min$[ebp+edi*4]
	mov	ecx, DWORD PTR _branch_max$[ebp+edi*4]
	cmp	esi, ecx
	jg	SHORT $LN24@derive_tap

; 387  :           synthesis[2*n+s-which] = (branch_buf[s])[n];

	mov	eax, DWORD PTR _branch_buf$[ebp+edi*4]
	sub	ecx, DWORD PTR _branch_min$[ebp+edi*4]
	lea	edx, DWORD PTR [eax+esi*4]
	lea	eax, DWORD PTR [esi+esi]
	mov	esi, DWORD PTR _synthesis$1$[ebp]
	sub	eax, DWORD PTR _which$1$[ebp]
	add	eax, edi
	inc	ecx
	lea	esi, DWORD PTR [esi+eax*4]
$LL29@derive_tap:
	mov	eax, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi], eax
	lea	esi, DWORD PTR [esi+8]
	sub	ecx, 1
	jne	SHORT $LL29@derive_tap
$LN24@derive_tap:

; 384  : 
; 385  :       for (s=0; s < 2; s++)

	inc	edi
	cmp	edi, 2
	jl	SHORT $LL26@derive_tap

; 388  : 
; 389  :       // Deduce analysis impulse response from the synthesis impulse response
; 390  :       float *analysis = (new float[2*impulse_L+1]) + impulse_L;

	mov	eax, DWORD PTR tv2886[ebp]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	eax, DWORD PTR tv2885[ebp]
	add	esp, 4

; 391  :       for (n=-impulse_L; n <= impulse_L; n++)

	mov	esi, DWORD PTR _impulse_L$1$[ebp]
	mov	ecx, DWORD PTR _n$8$[ebp]
	mov	edx, ecx
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _analysis$1$[ebp], eax
	mov	eax, esi
	sub	eax, ecx
	inc	eax
	mov	DWORD PTR tv2772[ebp], eax
	cmp	ecx, esi
	jg	$LN159@derive_tap
	cmp	eax, 8
	jb	$LN159@derive_tap

; 392  :         analysis[n] = (n&1)?(-synthesis[n]):(synthesis[n]);

	mov	eax, DWORD PTR _analysis$1$[ebp]
	movaps	xmm6, XMMWORD PTR __xmm@00000003000000020000000100000000
	lea	edi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _synthesis$1$[ebp]
	mov	DWORD PTR tv2881[ebp], edi
	lea	edi, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv2880[ebp], edi
	lea	eax, DWORD PTR [eax+esi*4]
	mov	edi, DWORD PTR _analysis$1$[ebp]
	lea	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _this$1$[ebp]
	cmp	ecx, eax
	ja	SHORT $LN106@derive_tap
	mov	eax, DWORD PTR tv2880[ebp]
	cmp	DWORD PTR tv2881[ebp], eax
	jae	$LN159@derive_tap
$LN106@derive_tap:
	mov	eax, DWORD PTR tv2772[ebp]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN161@derive_tap
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN161@derive_tap:
	movaps	xmm4, XMMWORD PTR __xmm@00000001000000010000000100000001
	mov	ecx, esi
	movaps	xmm7, XMMWORD PTR __xmm@80000000800000008000000080000000
	sub	ecx, eax
	mov	eax, DWORD PTR _n$8$[ebp]
	xorps	xmm5, xmm5
	mov	DWORD PTR tv2855[ebp], ecx
	mov	ecx, DWORD PTR _analysis$1$[ebp]
	lea	esi, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _synthesis$1$[ebp]

; 391  :       for (n=-impulse_L; n <= impulse_L; n++)

	mov	eax, DWORD PTR _analysis$1$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv2829[ebp], eax
	lea	edi, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR tv2855[ebp]
	lea	edi, DWORD PTR [edi+edx*4]
	npad	6
$LL32@derive_tap:

; 392  :         analysis[n] = (n&1)?(-synthesis[n]):(synthesis[n]);

	movups	xmm2, XMMWORD PTR [edi-16]
	lea	eax, DWORD PTR [edx+4]
	movd	xmm0, edx
	lea	esi, DWORD PTR [esi+32]
	pshufd	xmm3, xmm0, 0
	lea	edi, DWORD PTR [edi+32]
	paddd	xmm3, xmm6
	movaps	xmm0, xmm2
	pand	xmm3, xmm4
	xorps	xmm0, xmm7
	pcmpeqd	xmm3, xmm5
	add	edx, 8
	movaps	xmm1, xmm3
	andps	xmm2, xmm3
	andnps	xmm1, xmm0
	movd	xmm0, eax
	mov	eax, DWORD PTR tv2829[ebp]
	orps	xmm1, xmm2
	pshufd	xmm3, xmm0, 0
	paddd	xmm3, xmm6
	pand	xmm3, xmm4
	pcmpeqd	xmm3, xmm5
	movups	XMMWORD PTR [esi-32], xmm1
	movaps	xmm1, xmm3
	movups	xmm2, XMMWORD PTR [edi-32]
	movaps	xmm0, xmm2
	andps	xmm2, xmm3
	xorps	xmm0, xmm7
	andnps	xmm1, xmm0
	orps	xmm1, xmm2
	movups	XMMWORD PTR [eax+edi-32], xmm1
	cmp	edx, ecx
	jle	SHORT $LL32@derive_tap
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	esi, DWORD PTR _impulse_L$1$[ebp]
	jmp	SHORT $LN162@derive_tap
$LN159@derive_tap:
	movaps	xmm7, XMMWORD PTR __xmm@80000000800000008000000080000000
$LN162@derive_tap:
	mov	ecx, DWORD PTR _synthesis$1$[ebp]

; 391  :       for (n=-impulse_L; n <= impulse_L; n++)

	cmp	edx, esi
	jg	SHORT $LN31@derive_tap
	mov	edi, DWORD PTR _analysis$1$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	sub	edi, ecx
	mov	DWORD PTR tv2828[ebp], edi
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR tv2828[ebp]
	npad	7
$LL101@derive_tap:

; 392  :         analysis[n] = (n&1)?(-synthesis[n]):(synthesis[n]);

	movss	xmm0, DWORD PTR [eax]
	test	dl, 1
	je	SHORT $LN103@derive_tap
	xorps	xmm0, xmm7
$LN103@derive_tap:
	movss	DWORD PTR [eax+ecx], xmm0
	inc	edx
	add	eax, 4
	cmp	edx, esi
	jle	SHORT $LL101@derive_tap
	mov	ecx, DWORD PTR _synthesis$1$[ebp]
$LN31@derive_tap:

; 393  : 
; 394  :       if (which == 0)

	mov	edx, DWORD PTR _which$1$[ebp]

; 395  :         { // Low-pass synthesis response was found
; 396  :           low_synthesis_min = high_analysis_min = impulse_min;

	mov	eax, DWORD PTR _impulse_min$1$[ebp]
	test	edx, edx
	jne	SHORT $LN57@derive_tap
	mov	DWORD PTR [edi+52], eax
	mov	DWORD PTR [edi+68], eax

; 397  :           low_synthesis_max = high_analysis_max = impulse_max;

	mov	eax, DWORD PTR _impulse_max$1$[ebp]
	mov	DWORD PTR [edi+56], eax
	mov	DWORD PTR [edi+72], eax

; 398  :           low_synthesis_L = high_analysis_L = impulse_L;
; 399  :           low_synthesis_taps = synthesis;
; 400  :           high_analysis_taps = analysis;

	mov	eax, DWORD PTR _analysis$1$[ebp]
	mov	DWORD PTR [edi+48], esi
	mov	DWORD PTR [edi+64], esi
	mov	DWORD PTR [edi+76], ecx
	mov	DWORD PTR [edi+60], eax

; 401  :         }
; 402  :       else

	jmp	SHORT $LN2@derive_tap
$LN57@derive_tap:

; 403  :         { // High-pass synthesis response was found
; 404  :           high_synthesis_min = low_analysis_min = impulse_min;

	mov	DWORD PTR [edi+36], eax
	mov	DWORD PTR [edi+84], eax

; 405  :           high_synthesis_max = low_analysis_max = impulse_max;

	mov	eax, DWORD PTR _impulse_max$1$[ebp]
	mov	DWORD PTR [edi+40], eax
	mov	DWORD PTR [edi+88], eax

; 406  :           high_synthesis_L = low_analysis_L = impulse_L;
; 407  :           high_synthesis_taps = synthesis;
; 408  :           low_analysis_taps = analysis;

	mov	eax, DWORD PTR _analysis$1$[ebp]
	mov	DWORD PTR [edi+32], esi
	mov	DWORD PTR [edi+80], esi
	mov	DWORD PTR [edi+92], ecx
	mov	DWORD PTR [edi+44], eax
$LN2@derive_tap:

; 327  :   for (which=0; which < 2; which++)

	inc	edx
	mov	DWORD PTR _which$1$[ebp], edx
	cmp	edx, 2
	jl	$LL4@derive_tap

; 409  :         }
; 410  :     }
; 411  : 
; 412  :   // Deduce scaling factors and normalize filter taps.
; 413  :   if (reversible)

	cmp	BYTE PTR [edi+4], 0
	je	SHORT $LN59@derive_tap

; 414  :     { low_scale = high_scale = 1.0F; return; }

	mov	DWORD PTR [edi+28], 1065353216		; 3f800000H
	mov	DWORD PTR [edi+24], 1065353216		; 3f800000H
	pop	edi
	pop	esi

; 433  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@derive_tap:

; 415  : 
; 416  :   float gain;
; 417  : 
; 418  :   for (gain=0.0F, n=-low_analysis_L; n <= low_analysis_L; n++)

	mov	esi, DWORD PTR [edi+32]
	xorps	xmm2, xmm2
	mov	ecx, esi
	movaps	xmm1, xmm2
	neg	ecx
	cmp	ecx, esi
	jg	SHORT $LN34@derive_tap

; 419  :     gain += low_analysis_taps[n];

	mov	eax, DWORD PTR [edi+44]
	mov	edx, esi
	sub	edx, ecx
	inc	edx
	lea	eax, DWORD PTR [eax+ecx*4]
	npad	9
$LL35@derive_tap:
	addss	xmm1, DWORD PTR [eax]
	add	eax, 4
	sub	edx, 1
	jne	SHORT $LL35@derive_tap
$LN34@derive_tap:

; 420  :   low_scale = 1.0F / gain;

	movss	xmm3, DWORD PTR __real@3f800000
	movaps	xmm0, xmm3
	divss	xmm0, xmm1
	movss	DWORD PTR [edi+24], xmm0

; 421  :   for (n=-low_analysis_L; n <= low_analysis_L; n++)

	cmp	ecx, esi
	jg	SHORT $LN37@derive_tap
	npad	12
$LL38@derive_tap:
	mov	eax, DWORD PTR [edi+44]

; 422  :     low_analysis_taps[n] *= low_scale;

	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, DWORD PTR [edi+24]
	movss	DWORD PTR [eax+ecx*4], xmm0
	inc	ecx
	cmp	ecx, DWORD PTR [edi+32]
	jle	SHORT $LL38@derive_tap
$LN37@derive_tap:

; 423  :   for (n=-low_synthesis_L; n <= low_synthesis_L; n++)

	mov	ecx, DWORD PTR [edi+64]
	neg	ecx
	cmp	ecx, DWORD PTR [edi+64]
	jg	SHORT $LN40@derive_tap
$LL41@derive_tap:
	mov	eax, DWORD PTR [edi+76]

; 424  :     low_synthesis_taps[n] *= gain;

	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax+ecx*4], xmm0
	inc	ecx
	cmp	ecx, DWORD PTR [edi+64]
	jle	SHORT $LL41@derive_tap
$LN40@derive_tap:

; 425  : 
; 426  :   for (gain=0.0F, n=-high_analysis_L; n <= high_analysis_L; n++)

	mov	esi, DWORD PTR [edi+48]
	mov	ecx, esi
	neg	ecx
	mov	edx, ecx
	cmp	edx, esi
	jg	SHORT $LN43@derive_tap

; 427  :     gain += (n & 1)?(-high_analysis_taps[n]):(high_analysis_taps[n]);

	mov	eax, DWORD PTR [edi+60]
	lea	eax, DWORD PTR [eax+edx*4]
	npad	4
$LL44@derive_tap:
	movss	xmm0, DWORD PTR [eax]
	test	dl, 1
	je	SHORT $LN66@derive_tap
	xorps	xmm0, xmm7
$LN66@derive_tap:

; 425  : 
; 426  :   for (gain=0.0F, n=-high_analysis_L; n <= high_analysis_L; n++)

	inc	edx

; 427  :     gain += (n & 1)?(-high_analysis_taps[n]):(high_analysis_taps[n]);

	addss	xmm2, xmm0
	add	eax, 4
	cmp	edx, esi
	jle	SHORT $LL44@derive_tap
$LN43@derive_tap:

; 428  :   high_scale = 1.0F / gain;

	divss	xmm3, xmm2
	movss	DWORD PTR [edi+28], xmm3

; 429  :   for (n=-high_analysis_L; n <= high_analysis_L; n++)

	cmp	ecx, esi
	jg	SHORT $LN46@derive_tap
	npad	11
$LL47@derive_tap:
	mov	eax, DWORD PTR [edi+60]

; 430  :     high_analysis_taps[n] *= high_scale;

	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, DWORD PTR [edi+28]
	movss	DWORD PTR [eax+ecx*4], xmm0
	inc	ecx
	cmp	ecx, DWORD PTR [edi+48]
	jle	SHORT $LL47@derive_tap
$LN46@derive_tap:

; 431  :   for (n=-high_synthesis_L; n <= high_synthesis_L; n++)

	mov	ecx, DWORD PTR [edi+80]
	neg	ecx
	cmp	ecx, DWORD PTR [edi+80]
	jg	SHORT $LN49@derive_tap
$LL50@derive_tap:
	mov	eax, DWORD PTR [edi+92]

; 432  :     high_synthesis_taps[n] *= gain;

	movss	xmm0, DWORD PTR [eax+ecx*4]
	mulss	xmm0, xmm2
	movss	DWORD PTR [eax+ecx*4], xmm0
	inc	ecx
	cmp	ecx, DWORD PTR [edi+80]
	jle	SHORT $LL50@derive_tap
$LN49@derive_tap:
	pop	edi
	pop	esi

; 433  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?derive_taps_and_gains@kdu_kernels@@AAEXXZ ENDP		; kdu_kernels::derive_taps_and_gains
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
;	COMDAT ?reset@kdu_kernels@@AAEXXZ
_TEXT	SEGMENT
?reset@kdu_kernels@@AAEXXZ PROC				; kdu_kernels::reset, COMDAT
; _this$ = ecx

; 135  : {

	push	esi
	mov	esi, ecx

; 136  :   if (step_info != NULL)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN2@reset

; 137  :     delete[] step_info;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@reset:

; 138  :   if (lifting_factors != NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN3@reset

; 139  :     delete[] lifting_factors;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@reset:

; 140  :   if (low_analysis_taps != NULL)

	mov	ecx, DWORD PTR [esi+44]
	test	ecx, ecx
	je	SHORT $LN4@reset

; 141  :     delete[] (low_analysis_taps-low_analysis_L);

	mov	eax, DWORD PTR [esi+32]
	shl	eax, 2
	sub	ecx, eax
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN4@reset:

; 142  :   if (high_analysis_taps != NULL)

	mov	ecx, DWORD PTR [esi+60]
	test	ecx, ecx
	je	SHORT $LN5@reset

; 143  :     delete[] (high_analysis_taps-high_analysis_L);

	mov	eax, DWORD PTR [esi+48]
	shl	eax, 2
	sub	ecx, eax
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@reset:

; 144  :   if (low_synthesis_taps != NULL)

	mov	ecx, DWORD PTR [esi+76]
	test	ecx, ecx
	je	SHORT $LN6@reset

; 145  :     delete[] (low_synthesis_taps-low_synthesis_L);

	mov	eax, DWORD PTR [esi+64]
	shl	eax, 2
	sub	ecx, eax
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@reset:

; 146  :   if (high_synthesis_taps != NULL)

	mov	ecx, DWORD PTR [esi+92]
	test	ecx, ecx
	je	SHORT $LN7@reset

; 147  :     delete[] (high_synthesis_taps-high_synthesis_L);

	mov	eax, DWORD PTR [esi+80]
	shl	eax, 2
	sub	ecx, eax
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@reset:

; 148  :   if (work1 != NULL)

	mov	ecx, DWORD PTR [esi+108]
	test	ecx, ecx
	je	SHORT $LN8@reset

; 149  :     delete[] (work1-work_L);

	mov	eax, DWORD PTR [esi+104]
	shl	eax, 2
	sub	ecx, eax
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@reset:

; 150  :   if (work2 != NULL)

	mov	ecx, DWORD PTR [esi+112]
	test	ecx, ecx
	je	SHORT $LN9@reset

; 151  :     delete[] (work2-work_L);

	mov	eax, DWORD PTR [esi+104]
	shl	eax, 2
	sub	ecx, eax
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN9@reset:

; 152  :   if (bibo_step_gains != NULL)

	mov	eax, DWORD PTR [esi+96]
	test	eax, eax
	je	SHORT $LN10@reset

; 153  :     delete[] bibo_step_gains;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN10@reset:

; 154  :   clear();

	mov	ecx, esi
	pop	esi
	jmp	?clear@kdu_kernels@@AAEXXZ		; kdu_kernels::clear
?reset@kdu_kernels@@AAEXXZ ENDP				; kdu_kernels::reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
;	COMDAT ?clear@kdu_kernels@@AAEXXZ
_TEXT	SEGMENT
?clear@kdu_kernels@@AAEXXZ PROC				; kdu_kernels::clear, COMDAT
; _this$ = ecx

; 102  :   kernel_id = -1;

	mov	DWORD PTR [ecx], -1
	mov	eax, 15					; 0000000fH

; 103  :   reversible = false;

	mov	WORD PTR [ecx+4], 0
	xorps	xmm0, xmm0

; 104  :   symmetric = false;
; 105  :   symmetric_extension = false;

	mov	BYTE PTR [ecx+6], 0

; 106  :   num_steps = max_step_length = 0;

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0

; 107  :   step_info = NULL;

	mov	DWORD PTR [ecx+16], 0

; 108  :   lifting_factors = NULL;

	mov	DWORD PTR [ecx+20], 0

; 109  :   low_scale = high_scale = 1.0F;

	mov	DWORD PTR [ecx+28], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+24], 1065353216		; 3f800000H

; 110  :   low_analysis_L = low_analysis_min = low_analysis_max = 0;

	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+32], 0

; 111  :   high_analysis_L = high_analysis_min = high_analysis_max = 0;

	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+48], 0

; 112  :   low_synthesis_L = low_synthesis_min = low_synthesis_max = 0;

	mov	DWORD PTR [ecx+72], 0
	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+64], 0

; 113  :   high_synthesis_L = high_synthesis_min = high_synthesis_max = 0;

	mov	DWORD PTR [ecx+88], 0
	mov	DWORD PTR [ecx+84], 0
	mov	DWORD PTR [ecx+80], 0

; 114  :   low_synthesis_taps = high_synthesis_taps = NULL;

	mov	DWORD PTR [ecx+92], 0
	mov	DWORD PTR [ecx+76], 0

; 115  :   low_analysis_taps = high_analysis_taps = NULL;

	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+44], 0

; 116  :   bibo_step_gains = NULL;

	mov	DWORD PTR [ecx+96], 0

; 117  :   max_initial_lowpass_stages = 4;

	mov	DWORD PTR [ecx+100], 4

; 118  :   work_L = -1;

	mov	DWORD PTR [ecx+104], -1

; 119  :   work1 = work2 = NULL;

	mov	DWORD PTR [ecx+112], 0
	mov	DWORD PTR [ecx+108], 0
	sub	ecx, -128				; ffffff80H
	npad	8
$LL4@clear:

; 120  :   for (int n=0; n < 15; n++)
; 121  :     {
; 122  :       energy_gain_records[n].initial_stages = -1;

	mov	DWORD PTR [ecx-8], -1
	lea	ecx, DWORD PTR [ecx+16]

; 123  :       energy_gain_records[n].energy_gain = 0.0;

	movsd	QWORD PTR [ecx-16], xmm0

; 124  :       bibo_gain_records[n].initial_stages = -1;

	mov	DWORD PTR [ecx+216], -1

; 125  :       bibo_gain_records[n].bibo_gain = 0.0;

	movsd	QWORD PTR [ecx+224], xmm0
	sub	eax, 1
	jne	SHORT $LL4@clear

; 126  :     }
; 127  : }

	ret	0
?clear@kdu_kernels@@AAEXXZ ENDP				; kdu_kernels::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
;	COMDAT ?get_bibo_gains@kdu_kernels@@QAEPANHHQA_NAAN1@Z
_TEXT	SEGMENT
_total_levels$1$ = -64					; size = 4
_lev$1$ = -60						; size = 4
_Ns$1$ = -56						; size = 4
tv4467 = -56						; size = 4
tv4465 = -56						; size = 4
tv4458 = -56						; size = 4
tv4453 = -56						; size = 4
tv4447 = -56						; size = 4
_Ns$1$ = -52						; size = 4
tv4439 = -52						; size = 4
tv4395 = -52						; size = 4
tv4377 = -52						; size = 4
_k$2$ = -48						; size = 4
tv4462 = -48						; size = 4
tv4461 = -48						; size = 4
tv4436 = -48						; size = 4
tv4463 = -44						; size = 4
tv4464 = -40						; size = 4
_step$1$ = -36						; size = 4
_Ps$1$ = -32						; size = 4
_Ps$1$ = -32						; size = 4
_high_max$1$ = -28					; size = 4
_gap$1$ = -24						; size = 4
_low_max$1$ = -20					; size = 4
_this$1$ = -16						; size = 4
_high_min$1$ = -12					; size = 4
_work_high$1$ = -8					; size = 4
_work_low$1$ = -4					; size = 4
_initial_lowpass_stages$ = 8				; size = 4
_k$1$ = 12						; size = 4
_low_min$1$ = 12					; size = 4
_extra_stages$ = 12					; size = 4
_extra_stage_high$ = 16					; size = 4
_low_gain$ = 20						; size = 4
_high_gain$ = 24					; size = 4
?get_bibo_gains@kdu_kernels@@QAEPANHHQA_NAAN1@Z PROC	; kdu_kernels::get_bibo_gains, COMDAT
; _this$ = ecx

; 632  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	mov	esi, ecx
	push	edi

; 633  :   if (initial_lowpass_stages > max_initial_lowpass_stages)

	mov	edi, DWORD PTR _initial_lowpass_stages$[ebp]

; 634  :     initial_lowpass_stages = max_initial_lowpass_stages;
; 635  : 
; 636  :   enlarge_work_buffers(1); // Make sure we have at least something

	push	1
	cmp	edi, DWORD PTR [esi+100]
	mov	DWORD PTR _this$1$[ebp], esi
	cmovg	edi, DWORD PTR [esi+100]
	mov	DWORD PTR _initial_lowpass_stages$[ebp], edi
	call	?enlarge_work_buffers@kdu_kernels@@AAEXH@Z ; kdu_kernels::enlarge_work_buffers

; 637  :   float *work_low=work1, *work_high=work2;
; 638  : 
; 639  :   // In the seqel, `work_low' will hold the analysis kernel used to compute
; 640  :   // the even sub-sequence entry at location 0, while `work_high' will hold the
; 641  :   // analysis kernels used to compute the odd sub-sequence entry at location
; 642  :   // 1.  The lifting procedure is followed to alternately update these
; 643  :   // analysis kernels.
; 644  : 
; 645  :   int k, lev, low_min, low_max, high_min, high_max, gap;
; 646  :   int total_levels = initial_lowpass_stages + extra_stages + 1;

	mov	eax, DWORD PTR _extra_stages$[ebp]
	mov	edx, DWORD PTR [esi+108]
	inc	eax
	mov	ecx, DWORD PTR [esi+112]
	add	eax, edi

; 647  : 
; 648  :   // Initialize analysis vectors and gains for a 1 level lazy wavelet
; 649  :   work_low[0] = 1.0F;
; 650  :   low_min = low_max = 0;
; 651  :   high_min = 0; high_max = 0;
; 652  :   low_gain = high_gain = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	xor	esi, esi
	mov	DWORD PTR _total_levels$1$[ebp], eax
	xor	edi, edi
	mov	eax, DWORD PTR _high_gain$[ebp]
	mov	DWORD PTR [edx], 1065353216		; 3f800000H
	mov	DWORD PTR _work_low$1$[ebp], edx
	mov	DWORD PTR _work_high$1$[ebp], ecx
	movsd	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _low_gain$[ebp]
	mov	DWORD PTR _low_max$1$[ebp], esi
	mov	DWORD PTR _low_min$1$[ebp], esi
	mov	DWORD PTR _high_min$1$[ebp], esi
	movsd	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _high_max$1$[ebp], edi

; 653  : 
; 654  :   for (gap=1, lev=0; lev < total_levels; lev++, gap<<=1)

	mov	DWORD PTR _gap$1$[ebp], 1
	mov	DWORD PTR _lev$1$[ebp], esi
	cmp	DWORD PTR _total_levels$1$[ebp], esi
	jle	$LN166@get_bibo_g
	movsd	xmm3, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	lea	ecx, DWORD PTR [eax+28]
	add	eax, 24					; 00000018H
	mov	DWORD PTR tv4464[ebp], ecx
	mov	ecx, DWORD PTR _work_high$1$[ebp]
	mov	DWORD PTR tv4463[ebp], eax
	xor	eax, eax
$LL4@get_bibo_g:

; 655  :     { // Work through the levels
; 656  :       bool keep_low = (lev <= initial_lowpass_stages) ||

	cmp	eax, DWORD PTR _initial_lowpass_stages$[ebp]
	jle	$LN57@get_bibo_g
	mov	edx, DWORD PTR _extra_stage_high$[ebp]
	sub	eax, DWORD PTR _initial_lowpass_stages$[ebp]
	cmp	BYTE PTR [eax+edx-1], 0
	mov	edx, DWORD PTR _work_low$1$[ebp]
	je	$LN57@get_bibo_g

; 666  :         }
; 667  :       else
; 668  :         { /* Copy the high analysis vector from the last level to the low
; 669  :              analysis vector for the current level. */
; 670  :           for (k=high_min; k <= high_max; k++)

	mov	esi, DWORD PTR _high_min$1$[ebp]
	mov	DWORD PTR _k$1$[ebp], esi
	cmp	esi, edi
	jg	$LN126@get_bibo_g
	mov	eax, edi
	sub	eax, esi
	inc	eax
	cmp	eax, 4
	jl	SHORT $LC127@get_bibo_g
	mov	eax, DWORD PTR _work_low$1$[ebp]
	lea	edx, DWORD PTR [esi+3]
	inc	esi
	lea	edx, DWORD PTR [ecx+edx*4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR _work_high$1$[ebp]
	sub	esi, eax
	mov	eax, DWORD PTR _high_min$1$[ebp]
	mov	DWORD PTR tv4453[ebp], esi
	mov	esi, edi
	mov	edi, DWORD PTR tv4453[ebp]
	sub	esi, eax
	sub	esi, 3
	shr	esi, 2
	inc	esi
	lea	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR _k$1$[ebp], eax
$LL128@get_bibo_g:

; 671  :             work_low[k] = work_high[k];

	mov	eax, DWORD PTR [edx-12]
	lea	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx-20], eax
	lea	edx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [edi+ecx-16]
	mov	DWORD PTR [ecx-16], eax
	mov	eax, DWORD PTR [edx-20]
	mov	DWORD PTR [ecx-12], eax
	mov	eax, DWORD PTR [edx-16]
	mov	DWORD PTR [ecx-8], eax
	sub	esi, 1
	jne	SHORT $LL128@get_bibo_g
	mov	edi, DWORD PTR _high_max$1$[ebp]
	mov	edx, DWORD PTR _work_low$1$[ebp]
$LC127@get_bibo_g:

; 666  :         }
; 667  :       else
; 668  :         { /* Copy the high analysis vector from the last level to the low
; 669  :              analysis vector for the current level. */
; 670  :           for (k=high_min; k <= high_max; k++)

	mov	eax, DWORD PTR _k$1$[ebp]
	cmp	eax, edi
	jg	SHORT $LN126@get_bibo_g
	mov	esi, DWORD PTR _work_high$1$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	sub	esi, edx
	mov	edx, edi
	sub	edx, eax
	inc	edx
$LC95@get_bibo_g:

; 671  :             work_low[k] = work_high[k];

	mov	eax, DWORD PTR [ecx+esi]
	lea	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx-4], eax
	sub	edx, 1
	jne	SHORT $LC95@get_bibo_g
$LN126@get_bibo_g:

; 672  :           low_min = high_min;  low_max = high_max;
; 673  :           low_gain = high_gain;

	mov	eax, DWORD PTR _high_gain$[ebp]
	mov	esi, edi
	mov	edx, DWORD PTR _high_min$1$[ebp]
	mov	DWORD PTR _low_min$1$[ebp], edx
	mov	DWORD PTR _low_max$1$[ebp], esi
	movsd	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR _low_gain$[ebp]
	jmp	$LN178@get_bibo_g
$LN57@get_bibo_g:

; 657  :                       !extra_stage_high[lev-1-initial_lowpass_stages];
; 658  : 
; 659  :       if (keep_low)
; 660  :         { /* Copy the low analysis vector from the last level to the high
; 661  :              analysis vector for the current level. */
; 662  :           for (k=low_min; k <= low_max; k++)

	mov	edi, DWORD PTR _low_min$1$[ebp]
	mov	DWORD PTR _k$2$[ebp], edi
	cmp	edi, esi
	jg	$LN123@get_bibo_g
	mov	eax, esi
	sub	eax, edi
	inc	eax
	cmp	eax, 4
	jl	SHORT $LC124@get_bibo_g
	mov	eax, DWORD PTR _work_low$1$[ebp]
	lea	edx, DWORD PTR [edx+edi*4]
	sub	eax, DWORD PTR _work_high$1$[ebp]
	lea	ecx, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR tv4458[ebp], eax
	mov	edi, esi
	mov	eax, DWORD PTR _low_min$1$[ebp]
	add	edx, 12					; 0000000cH
	mov	esi, DWORD PTR tv4458[ebp]
	sub	edi, eax
	sub	edi, 3
	add	ecx, 4
	shr	edi, 2
	inc	edi
	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _k$2$[ebp], eax
	npad	4
$LL125@get_bibo_g:

; 663  :             work_high[k] = work_low[k];

	mov	eax, DWORD PTR [edx-12]
	lea	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx-20], eax
	lea	edx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [esi+ecx-16]
	mov	DWORD PTR [ecx-16], eax
	mov	eax, DWORD PTR [edx-20]
	mov	DWORD PTR [ecx-12], eax
	mov	eax, DWORD PTR [edx-16]
	mov	DWORD PTR [ecx-8], eax
	sub	edi, 1
	jne	SHORT $LL125@get_bibo_g
	mov	esi, DWORD PTR _low_max$1$[ebp]
	mov	edx, DWORD PTR _work_low$1$[ebp]
	mov	ecx, DWORD PTR _work_high$1$[ebp]
$LC124@get_bibo_g:

; 657  :                       !extra_stage_high[lev-1-initial_lowpass_stages];
; 658  : 
; 659  :       if (keep_low)
; 660  :         { /* Copy the low analysis vector from the last level to the high
; 661  :              analysis vector for the current level. */
; 662  :           for (k=low_min; k <= low_max; k++)

	mov	eax, DWORD PTR _k$2$[ebp]
	cmp	eax, esi
	jg	SHORT $LN123@get_bibo_g
	mov	edi, edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	sub	edi, DWORD PTR _work_high$1$[ebp]
	mov	edx, esi
	sub	edx, eax
	inc	edx
$LC93@get_bibo_g:

; 663  :             work_high[k] = work_low[k];

	mov	eax, DWORD PTR [ecx+edi]
	lea	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx-4], eax
	sub	edx, 1
	jne	SHORT $LC93@get_bibo_g
$LN123@get_bibo_g:

; 664  :           high_min = low_min;  high_max = low_max;
; 665  :           high_gain = low_gain;

	mov	eax, DWORD PTR _low_gain$[ebp]
	mov	edx, DWORD PTR _low_min$1$[ebp]
	mov	DWORD PTR _high_min$1$[ebp], edx
	mov	DWORD PTR _high_max$1$[ebp], esi
	movsd	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR _high_gain$[ebp]
$LN178@get_bibo_g:
	movsd	QWORD PTR [eax], xmm0

; 674  :         }
; 675  : 
; 676  :       // See if we need to resize the work buffers
; 677  :       int safe_L = ((low_max+low_min) > 0)?low_max:(-low_min);

	lea	eax, DWORD PTR [esi+edx]
	test	eax, eax
	jle	SHORT $LN59@get_bibo_g
	mov	ecx, esi
	jmp	SHORT $LN60@get_bibo_g
$LN59@get_bibo_g:
	mov	ecx, edx
	neg	ecx
$LN60@get_bibo_g:

; 678  :       safe_L += gap*max_step_length*num_steps;

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+8]
	imul	eax, DWORD PTR _gap$1$[ebp]
	imul	eax, DWORD PTR [edi+12]
	add	ecx, eax

; 679  :       if (safe_L > work_L)

	mov	eax, edi
	mov	edi, DWORD PTR _high_max$1$[ebp]
	cmp	ecx, DWORD PTR [eax+104]
	jle	SHORT $LN53@get_bibo_g

; 680  :         {
; 681  :           enlarge_work_buffers(safe_L);

	push	ecx
	mov	ecx, eax
	call	?enlarge_work_buffers@kdu_kernels@@AAEXH@Z ; kdu_kernels::enlarge_work_buffers

; 682  :           work_low = work1;   work_high = work2;

	mov	ecx, DWORD PTR _this$1$[ebp]
	movsd	xmm3, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	mov	edx, DWORD PTR _low_min$1$[ebp]
	mov	eax, DWORD PTR [ecx+108]
	mov	DWORD PTR _work_low$1$[ebp], eax
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+112]
	mov	DWORD PTR _work_high$1$[ebp], ecx
$LN53@get_bibo_g:

; 683  :         }
; 684  : 
; 685  :       for (int step=0; step < num_steps; step+=2)

	cmp	DWORD PTR [eax+8], 0
	mov	DWORD PTR _step$1$[ebp], 0
	jle	$LN12@get_bibo_g
	mov	DWORD PTR tv4436[ebp], 0
	jmp	SHORT $LN179@get_bibo_g
$LL174@get_bibo_g:
	mov	edx, DWORD PTR _low_min$1$[ebp]
$LN179@get_bibo_g:
	mov	ecx, DWORD PTR _work_high$1$[ebp]

; 686  :         { // Work through the lifting steps in this level
; 687  :           if (low_min <= low_max)

	cmp	edx, esi
	jg	$LN167@get_bibo_g

; 688  :             { // Updating the odd sub-sequence analysis kernel
; 689  :               int n;
; 690  :               int Ns = step_info[step].support_min;

	mov	eax, DWORD PTR [eax+16]
	mov	edx, DWORD PTR tv4436[ebp]
	mov	edi, DWORD PTR [eax+edx+4]

; 691  :               int Ps =  step_info[step].support_length - 1 + Ns;

	mov	eax, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _step$1$[ebp]
	dec	eax
	add	eax, edi
	mov	DWORD PTR _Ns$1$[ebp], edi
	mov	DWORD PTR _Ps$1$[ebp], eax
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+20]
	lea	edx, DWORD PTR [eax+edx*4]

; 692  :                 // Cs[n] has coefficients in the range Ns <= n <= Ps
; 693  :               float *fp = lifting_factors + step;
; 694  :               for (n=low_min+(2*Ns-1)*gap; n < high_min; )

	lea	eax, DWORD PTR [edi*2-1]
	mov	edi, DWORD PTR _high_max$1$[ebp]
	imul	eax, DWORD PTR _gap$1$[ebp]
	add	eax, DWORD PTR _low_min$1$[ebp]
	cmp	eax, DWORD PTR _high_min$1$[ebp]
	jge	SHORT $LN15@get_bibo_g
	mov	esi, DWORD PTR _high_min$1$[ebp]
	npad	7
$LL14@get_bibo_g:

; 695  :                 work_high[--high_min] = 0.0F;

	dec	esi
	mov	DWORD PTR [ecx+esi*4], 0
	cmp	esi, eax
	jg	SHORT $LL14@get_bibo_g
	mov	DWORD PTR _high_min$1$[ebp], esi
	mov	esi, DWORD PTR _low_max$1$[ebp]
$LN15@get_bibo_g:

; 696  :               for (n=low_max+(2*Ps-1)*gap; n > high_max; )

	mov	eax, DWORD PTR _Ps$1$[ebp]
	lea	eax, DWORD PTR [eax*2-1]
	imul	eax, DWORD PTR _gap$1$[ebp]
	add	eax, esi
	cmp	eax, edi
	jle	SHORT $LN18@get_bibo_g
$LL17@get_bibo_g:

; 697  :                 work_high[++high_max] = 0.0F;

	inc	edi
	mov	DWORD PTR [ecx+edi*4], 0
	cmp	edi, eax
	jl	SHORT $LL17@get_bibo_g
	mov	DWORD PTR _high_max$1$[ebp], edi
$LN18@get_bibo_g:

; 698  :               for (n=Ns; n <= Ps; n++, fp+=num_steps)

	mov	eax, DWORD PTR _Ns$1$[ebp]
	cmp	eax, DWORD PTR _Ps$1$[ebp]
	jg	SHORT $LN21@get_bibo_g
	lea	eax, DWORD PTR [eax*8-4]
	imul	eax, DWORD PTR _gap$1$[ebp]
	add	eax, ecx
	mov	ecx, DWORD PTR _low_min$1$[ebp]
	lea	edi, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _Ps$1$[ebp]
	sub	eax, DWORD PTR _Ns$1$[ebp]
	inc	eax
	mov	DWORD PTR tv4447[ebp], edi
	mov	DWORD PTR _Ps$1$[ebp], eax
	npad	3
$LL22@get_bibo_g:

; 699  :                 for (k=low_min; k <= low_max; k++)

	mov	eax, ecx
	mov	ecx, edi
	mov	edi, DWORD PTR _work_low$1$[ebp]
	npad	9
$LL25@get_bibo_g:

; 700  :                   work_high[k+(2*n-1)*gap] += work_low[k] * fp[0];

	movss	xmm0, DWORD PTR [edi+eax*4]
	inc	eax
	mulss	xmm0, DWORD PTR [edx]
	addss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0
	add	ecx, 4
	cmp	eax, esi
	jle	SHORT $LL25@get_bibo_g

; 698  :               for (n=Ns; n <= Ps; n++, fp+=num_steps)

	mov	ecx, DWORD PTR _gap$1$[ebp]
	mov	edi, DWORD PTR tv4447[ebp]
	lea	eax, DWORD PTR [ecx*8]
	mov	ecx, DWORD PTR _low_min$1$[ebp]
	add	edi, eax
	sub	DWORD PTR _Ps$1$[ebp], 1
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR tv4447[ebp], edi
	mov	eax, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [edx+eax*4]
	jne	SHORT $LL22@get_bibo_g
	mov	edi, DWORD PTR _high_max$1$[ebp]
$LN21@get_bibo_g:

; 701  : 
; 702  :               for (high_gain=0.0, k=high_min; k <= high_max; k++)

	mov	eax, DWORD PTR _high_gain$[ebp]
	xorps	xmm4, xmm4
	mov	edx, DWORD PTR _high_min$1$[ebp]
	mov	ecx, edx
	movsd	QWORD PTR [eax], xmm4
	cmp	edx, edi
	jg	$LN129@get_bibo_g
	mov	eax, edi
	sub	eax, edx
	inc	eax
	cmp	eax, 4
	jl	SHORT $LC130@get_bibo_g
	mov	eax, DWORD PTR _work_high$1$[ebp]
	mov	esi, DWORD PTR _high_gain$[ebp]
	add	eax, 8
	lea	edx, DWORD PTR [eax+edx*4]
	mov	eax, edi
	sub	eax, ecx
	sub	eax, 3
	shr	eax, 2
	inc	eax
	lea	ecx, DWORD PTR [ecx+eax*4]
	npad	5
$LL131@get_bibo_g:

; 703  :                 high_gain += fabs(work_high[k]);

	movss	xmm0, DWORD PTR [edx-8]
	cvtps2pd xmm0, xmm0
	andps	xmm0, xmm3
	addsd	xmm0, QWORD PTR [esi]
	movsd	QWORD PTR [esi], xmm0
	movss	xmm1, DWORD PTR [edx-4]
	cvtps2pd xmm1, xmm1
	andps	xmm1, xmm3
	addsd	xmm1, xmm0
	movsd	QWORD PTR [esi], xmm1
	movss	xmm2, DWORD PTR [edx]
	cvtps2pd xmm2, xmm2
	andps	xmm2, xmm3
	addsd	xmm2, xmm1
	movsd	QWORD PTR [esi], xmm2
	movss	xmm0, DWORD PTR [edx+4]
	add	edx, 16					; 00000010H
	cvtps2pd xmm0, xmm0
	andps	xmm0, xmm3
	addsd	xmm0, xmm2
	movsd	QWORD PTR [esi], xmm0
	sub	eax, 1
	jne	SHORT $LL131@get_bibo_g
	mov	esi, DWORD PTR _low_max$1$[ebp]
$LC130@get_bibo_g:

; 701  : 
; 702  :               for (high_gain=0.0, k=high_min; k <= high_max; k++)

	cmp	ecx, edi
	jg	SHORT $LN129@get_bibo_g
	mov	eax, DWORD PTR _work_high$1$[ebp]
	mov	edx, DWORD PTR _high_gain$[ebp]
$LC28@get_bibo_g:
	movss	xmm0, DWORD PTR [eax+ecx*4]
	inc	ecx

; 703  :                 high_gain += fabs(work_high[k]);

	cvtps2pd xmm0, xmm0
	andps	xmm0, xmm3
	addsd	xmm0, QWORD PTR [edx]
	movsd	QWORD PTR [edx], xmm0
	cmp	ecx, edi
	jle	SHORT $LC28@get_bibo_g
$LN129@get_bibo_g:

; 704  :               bibo_step_gains[step] = high_gain;

	mov	ecx, DWORD PTR _high_gain$[ebp]
	mov	edx, DWORD PTR _this$1$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+96]
	mov	ecx, DWORD PTR _step$1$[ebp]
	movsd	QWORD PTR [eax+ecx*8], xmm0
	jmp	SHORT $LN54@get_bibo_g
$LN167@get_bibo_g:
	mov	edx, DWORD PTR _this$1$[ebp]
	xorps	xmm4, xmm4
	mov	ecx, DWORD PTR _step$1$[ebp]
$LN54@get_bibo_g:

; 705  :             }
; 706  : 
; 707  :           if ((high_min <= high_max) && ((step+1) < num_steps))

	cmp	DWORD PTR _high_min$1$[ebp], edi
	jg	$LN11@get_bibo_g
	lea	eax, DWORD PTR [ecx+1]
	cmp	eax, DWORD PTR [edx+8]
	jge	$LN11@get_bibo_g

; 708  :             { // Now update the even sub-sequence analysis kernel
; 709  :               int n;
; 710  :               int Ns = step_info[step+1].support_min;

	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR tv4436[ebp]

; 711  :               int Ps = step_info[step+1].support_length - 1 + Ns;

	mov	esi, DWORD PTR tv4436[ebp]
	mov	ecx, DWORD PTR [eax+ecx+20]
	mov	eax, DWORD PTR [eax+esi+16]

; 712  :                 // Cs[n] has coefficients in the range Ns <= n <= Ps
; 713  :               float *fp = lifting_factors + (step+1);
; 714  :               for (n=high_min+(2*Ns+1)*gap; n < low_min; )

	mov	esi, DWORD PTR _low_max$1$[ebp]
	dec	eax
	add	eax, ecx
	mov	DWORD PTR _Ns$1$[ebp], ecx
	mov	DWORD PTR _Ps$1$[ebp], eax
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _step$1$[ebp]
	inc	edx
	lea	edx, DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [ecx*2+1]
	mov	ecx, DWORD PTR _work_low$1$[ebp]
	imul	eax, DWORD PTR _gap$1$[ebp]
	add	eax, DWORD PTR _high_min$1$[ebp]
	cmp	eax, DWORD PTR _low_min$1$[ebp]
	jge	SHORT $LN30@get_bibo_g
	mov	esi, DWORD PTR _low_min$1$[ebp]
	npad	3
$LL29@get_bibo_g:

; 715  :                 work_low[--low_min] = 0.0F;

	dec	esi
	mov	DWORD PTR [ecx+esi*4], 0
	cmp	esi, eax
	jg	SHORT $LL29@get_bibo_g
	mov	DWORD PTR _low_min$1$[ebp], esi
	mov	esi, DWORD PTR _low_max$1$[ebp]
$LN30@get_bibo_g:

; 716  :               for (n=high_max+(2*Ps+1)*gap; n > low_max; )

	mov	eax, DWORD PTR _Ps$1$[ebp]
	lea	eax, DWORD PTR [eax*2+1]
	imul	eax, DWORD PTR _gap$1$[ebp]
	add	eax, edi
	cmp	eax, esi
	jle	SHORT $LN33@get_bibo_g
$LL32@get_bibo_g:

; 717  :                 work_low[++low_max] = 0.0F;

	inc	esi
	mov	DWORD PTR [ecx+esi*4], 0
	cmp	esi, eax
	jl	SHORT $LL32@get_bibo_g
	mov	DWORD PTR _low_max$1$[ebp], esi
$LN33@get_bibo_g:

; 718  :               for (n=Ns; n <= Ps; n++, fp+=num_steps)

	mov	eax, DWORD PTR _Ns$1$[ebp]
	cmp	eax, DWORD PTR _Ps$1$[ebp]
	jg	SHORT $LN36@get_bibo_g
	lea	eax, DWORD PTR [eax*8+4]
	imul	eax, DWORD PTR _gap$1$[ebp]
	add	eax, ecx
	mov	ecx, DWORD PTR _high_min$1$[ebp]
	lea	esi, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _Ps$1$[ebp]
	sub	eax, DWORD PTR _Ns$1$[ebp]
	inc	eax
	mov	DWORD PTR tv4439[ebp], esi
	mov	DWORD PTR _Ps$1$[ebp], eax
	npad	3
$LL37@get_bibo_g:

; 719  :                 for (k=high_min; k <= high_max; k++)

	mov	eax, ecx
	mov	ecx, esi
	mov	esi, DWORD PTR _work_high$1$[ebp]
	npad	9
$LL40@get_bibo_g:

; 720  :                   work_low[k+(2*n+1)*gap] += work_high[k] * fp[0];

	movss	xmm0, DWORD PTR [esi+eax*4]
	inc	eax
	mulss	xmm0, DWORD PTR [edx]
	addss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0
	add	ecx, 4
	cmp	eax, edi
	jle	SHORT $LL40@get_bibo_g

; 718  :               for (n=Ns; n <= Ps; n++, fp+=num_steps)

	mov	ecx, DWORD PTR _gap$1$[ebp]
	mov	esi, DWORD PTR tv4439[ebp]
	lea	eax, DWORD PTR [ecx*8]
	mov	ecx, DWORD PTR _high_min$1$[ebp]
	add	esi, eax
	sub	DWORD PTR _Ps$1$[ebp], 1
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR tv4439[ebp], esi
	mov	eax, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [edx+eax*4]
	jne	SHORT $LL37@get_bibo_g
	mov	esi, DWORD PTR _low_max$1$[ebp]
$LN36@get_bibo_g:

; 721  : 
; 722  :               for (low_gain=0.0, k=low_min; k <= low_max; k++)

	mov	eax, DWORD PTR _low_gain$[ebp]
	mov	edx, DWORD PTR _low_min$1$[ebp]
	mov	ecx, edx
	movsd	QWORD PTR [eax], xmm4
	cmp	edx, esi
	jg	$LN132@get_bibo_g
	mov	eax, esi
	sub	eax, edx
	inc	eax
	cmp	eax, 4
	jl	SHORT $LC133@get_bibo_g
	mov	eax, DWORD PTR _work_low$1$[ebp]
	mov	edi, DWORD PTR _low_gain$[ebp]
	add	eax, 8
	lea	edx, DWORD PTR [eax+edx*4]
	mov	eax, esi
	sub	eax, ecx
	sub	eax, 3
	shr	eax, 2
	inc	eax
	lea	ecx, DWORD PTR [ecx+eax*4]
	npad	8
$LL134@get_bibo_g:

; 723  :                 low_gain += fabs(work_low[k]);

	movss	xmm0, DWORD PTR [edx-8]
	cvtps2pd xmm0, xmm0
	andps	xmm0, xmm3
	addsd	xmm0, QWORD PTR [edi]
	movsd	QWORD PTR [edi], xmm0
	movss	xmm1, DWORD PTR [edx-4]
	cvtps2pd xmm1, xmm1
	andps	xmm1, xmm3
	addsd	xmm1, xmm0
	movsd	QWORD PTR [edi], xmm1
	movss	xmm2, DWORD PTR [edx]
	cvtps2pd xmm2, xmm2
	andps	xmm2, xmm3
	addsd	xmm2, xmm1
	movsd	QWORD PTR [edi], xmm2
	movss	xmm0, DWORD PTR [edx+4]
	add	edx, 16					; 00000010H
	cvtps2pd xmm0, xmm0
	andps	xmm0, xmm3
	addsd	xmm0, xmm2
	movsd	QWORD PTR [edi], xmm0
	sub	eax, 1
	jne	SHORT $LL134@get_bibo_g
	mov	edi, DWORD PTR _high_max$1$[ebp]
$LC133@get_bibo_g:

; 721  : 
; 722  :               for (low_gain=0.0, k=low_min; k <= low_max; k++)

	cmp	ecx, esi
	jg	SHORT $LN132@get_bibo_g
	mov	eax, DWORD PTR _work_low$1$[ebp]
	mov	edx, DWORD PTR _low_gain$[ebp]
$LC43@get_bibo_g:
	movss	xmm0, DWORD PTR [eax+ecx*4]
	inc	ecx

; 723  :                 low_gain += fabs(work_low[k]);

	cvtps2pd xmm0, xmm0
	andps	xmm0, xmm3
	addsd	xmm0, QWORD PTR [edx]
	movsd	QWORD PTR [edx], xmm0
	cmp	ecx, esi
	jle	SHORT $LC43@get_bibo_g
$LN132@get_bibo_g:

; 724  :               bibo_step_gains[step+1] = low_gain;

	mov	ecx, DWORD PTR _low_gain$[ebp]
	mov	edx, DWORD PTR _this$1$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+96]
	mov	ecx, DWORD PTR _step$1$[ebp]
	movsd	QWORD PTR [eax+ecx*8+8], xmm0
$LN11@get_bibo_g:

; 683  :         }
; 684  : 
; 685  :       for (int step=0; step < num_steps; step+=2)

	add	DWORD PTR tv4436[ebp], 32		; 00000020H
	add	ecx, 2
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _step$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edx+8]
	jl	$LL174@get_bibo_g
$LN12@get_bibo_g:

; 725  :             }
; 726  :         }
; 727  : 
; 728  :       // Now incorporate the subband scaling factors
; 729  :       for (k=high_min; k <= high_max; k++)

	mov	edx, DWORD PTR _high_min$1$[ebp]
	mov	eax, edi
	sub	eax, edx
	mov	ecx, edx
	inc	eax
	mov	DWORD PTR tv4377[ebp], eax
	cmp	edx, edi
	jg	$LN135@get_bibo_g

; 730  :         work_high[k] *= high_scale;

	mov	edx, DWORD PTR _work_high$1$[ebp]
	cmp	eax, 8
	jb	SHORT $LN98@get_bibo_g
	mov	eax, DWORD PTR tv4464[ebp]
	lea	esi, DWORD PTR [edx+edi*4]
	mov	DWORD PTR tv4467[ebp], esi
	mov	esi, DWORD PTR _low_max$1$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mov	eax, ecx
	shufps	xmm1, xmm1, 0
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	eax, DWORD PTR tv4464[ebp]
	ja	SHORT $LN99@get_bibo_g
	mov	edx, DWORD PTR tv4464[ebp]
	cmp	DWORD PTR tv4467[ebp], edx
	mov	edx, DWORD PTR _work_high$1$[ebp]
	jae	SHORT $LN98@get_bibo_g
$LN99@get_bibo_g:
	mov	esi, DWORD PTR tv4377[ebp]
	and	esi, -2147483641			; 80000007H
	jns	SHORT $LN176@get_bibo_g
	dec	esi
	or	esi, -8					; fffffff8H
	inc	esi
$LN176@get_bibo_g:
	mov	DWORD PTR tv4462[ebp], edi
	sub	DWORD PTR tv4462[ebp], esi
	mov	esi, DWORD PTR _low_max$1$[ebp]
$LL46@get_bibo_g:
	movups	xmm0, XMMWORD PTR [eax]
	add	ecx, 8
	lea	eax, DWORD PTR [eax+32]
	mulps	xmm0, xmm1
	movups	XMMWORD PTR [eax-32], xmm0
	movups	xmm0, XMMWORD PTR [eax-16]
	mulps	xmm0, xmm1
	movups	XMMWORD PTR [eax-16], xmm0
	cmp	ecx, DWORD PTR tv4462[ebp]
	jle	SHORT $LL46@get_bibo_g
$LN98@get_bibo_g:
	cmp	ecx, edi
	jg	$LN135@get_bibo_g

; 725  :             }
; 726  :         }
; 727  : 
; 728  :       // Now incorporate the subband scaling factors
; 729  :       for (k=high_min; k <= high_max; k++)

	mov	eax, edi
	sub	eax, ecx
	inc	eax
	cmp	eax, 4
	jl	SHORT $LC136@get_bibo_g
	mov	esi, DWORD PTR tv4464[ebp]
	lea	eax, DWORD PTR [edx+8]
	mov	edx, edi
	lea	eax, DWORD PTR [eax+ecx*4]
	sub	edx, ecx
	sub	edx, 3
	shr	edx, 2
	inc	edx
	lea	ecx, DWORD PTR [ecx+edx*4]
	npad	4
$LL137@get_bibo_g:

; 730  :         work_high[k] *= high_scale;

	movss	xmm0, DWORD PTR [eax-8]
	lea	eax, DWORD PTR [eax+16]
	mulss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR [eax-24], xmm0
	movss	xmm0, DWORD PTR [esi]
	mulss	xmm0, DWORD PTR [eax-20]
	movss	DWORD PTR [eax-20], xmm0
	movss	xmm0, DWORD PTR [eax-16]
	mulss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR [eax-16], xmm0
	movss	xmm0, DWORD PTR [eax-12]
	mulss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR [eax-12], xmm0
	sub	edx, 1
	jne	SHORT $LL137@get_bibo_g
	mov	esi, DWORD PTR _low_max$1$[ebp]
$LC136@get_bibo_g:

; 725  :             }
; 726  :         }
; 727  : 
; 728  :       // Now incorporate the subband scaling factors
; 729  :       for (k=high_min; k <= high_max; k++)

	cmp	ecx, edi
	jg	SHORT $LN135@get_bibo_g
	mov	eax, DWORD PTR _work_high$1$[ebp]
	mov	edx, DWORD PTR tv4464[ebp]
	npad	3
$LC97@get_bibo_g:

; 730  :         work_high[k] *= high_scale;

	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [eax+ecx*4]
	movss	DWORD PTR [eax+ecx*4], xmm0
	inc	ecx
	cmp	ecx, edi
	jle	SHORT $LC97@get_bibo_g
$LN135@get_bibo_g:

; 731  :       high_gain *= high_scale;

	mov	eax, DWORD PTR tv4464[ebp]

; 732  :       for (k=low_min; k <= low_max; k++)

	mov	edx, DWORD PTR _low_min$1$[ebp]
	mov	ecx, edx
	movss	xmm0, DWORD PTR [eax]
	mov	eax, DWORD PTR _high_gain$[ebp]
	cvtps2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR [eax]
	movsd	QWORD PTR [eax], xmm0
	mov	eax, esi
	sub	eax, edx
	inc	eax
	mov	DWORD PTR tv4395[ebp], eax
	cmp	edx, esi
	jg	$LN171@get_bibo_g

; 733  :         work_low[k] *= low_scale;

	mov	edx, DWORD PTR _work_low$1$[ebp]
	cmp	eax, 8
	jb	SHORT $LN101@get_bibo_g
	mov	eax, DWORD PTR tv4463[ebp]
	lea	edi, DWORD PTR [edx+esi*4]
	mov	DWORD PTR tv4465[ebp], edi
	mov	edi, DWORD PTR _high_max$1$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mov	eax, ecx
	shufps	xmm1, xmm1, 0
	lea	eax, DWORD PTR [edx+eax*4]
	cmp	eax, DWORD PTR tv4463[ebp]
	ja	SHORT $LN102@get_bibo_g
	mov	edx, DWORD PTR tv4463[ebp]
	cmp	DWORD PTR tv4465[ebp], edx
	mov	edx, DWORD PTR _work_low$1$[ebp]
	jae	SHORT $LN101@get_bibo_g
$LN102@get_bibo_g:
	mov	edi, DWORD PTR tv4395[ebp]
	and	edi, -2147483641			; 80000007H
	jns	SHORT $LN177@get_bibo_g
	dec	edi
	or	edi, -8					; fffffff8H
	inc	edi
$LN177@get_bibo_g:
	mov	DWORD PTR tv4461[ebp], esi
	sub	DWORD PTR tv4461[ebp], edi
	mov	edi, DWORD PTR _high_max$1$[ebp]
$LL49@get_bibo_g:
	movups	xmm0, XMMWORD PTR [eax]
	add	ecx, 8
	lea	eax, DWORD PTR [eax+32]
	mulps	xmm0, xmm1
	movups	XMMWORD PTR [eax-32], xmm0
	movups	xmm0, XMMWORD PTR [eax-16]
	mulps	xmm0, xmm1
	movups	XMMWORD PTR [eax-16], xmm0
	cmp	ecx, DWORD PTR tv4461[ebp]
	jle	SHORT $LL49@get_bibo_g
$LN101@get_bibo_g:
	cmp	ecx, esi
	jg	$LN171@get_bibo_g

; 732  :       for (k=low_min; k <= low_max; k++)

	mov	eax, esi
	sub	eax, ecx
	inc	eax
	cmp	eax, 4
	jl	SHORT $LC139@get_bibo_g
	mov	edi, DWORD PTR tv4463[ebp]
	lea	eax, DWORD PTR [edx+8]
	mov	edx, esi
	lea	eax, DWORD PTR [eax+ecx*4]
	sub	edx, ecx
	sub	edx, 3
	shr	edx, 2
	inc	edx
	lea	ecx, DWORD PTR [ecx+edx*4]
$LL140@get_bibo_g:

; 733  :         work_low[k] *= low_scale;

	movss	xmm0, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+16]
	mulss	xmm0, DWORD PTR [eax-24]
	movss	DWORD PTR [eax-24], xmm0
	movss	xmm0, DWORD PTR [eax-20]
	mulss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR [eax-20], xmm0
	movss	xmm0, DWORD PTR [edi]
	mulss	xmm0, DWORD PTR [eax-16]
	movss	DWORD PTR [eax-16], xmm0
	movss	xmm0, DWORD PTR [edi]
	mulss	xmm0, DWORD PTR [eax-12]
	movss	DWORD PTR [eax-12], xmm0
	sub	edx, 1
	jne	SHORT $LL140@get_bibo_g
	mov	edi, DWORD PTR _high_max$1$[ebp]
$LC139@get_bibo_g:
	mov	edx, DWORD PTR _work_low$1$[ebp]

; 732  :       for (k=low_min; k <= low_max; k++)

	cmp	ecx, esi
	jg	SHORT $LN138@get_bibo_g
	mov	eax, DWORD PTR tv4463[ebp]
	npad	3
$LC100@get_bibo_g:

; 733  :         work_low[k] *= low_scale;

	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR [edx+ecx*4], xmm0
	inc	ecx
	cmp	ecx, esi
	jle	SHORT $LC100@get_bibo_g
	jmp	SHORT $LN138@get_bibo_g
$LN171@get_bibo_g:
	mov	edx, DWORD PTR _work_low$1$[ebp]
$LN138@get_bibo_g:

; 734  :       low_gain *= low_scale;

	mov	ecx, DWORD PTR tv4463[ebp]
	mov	eax, DWORD PTR _low_gain$[ebp]
	shl	DWORD PTR _gap$1$[ebp], 1
	movss	xmm0, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _work_high$1$[ebp]
	cvtps2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR [eax]
	movsd	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _lev$1$[ebp]
	inc	eax
	mov	DWORD PTR _lev$1$[ebp], eax
	cmp	eax, DWORD PTR _total_levels$1$[ebp]
	jl	$LL4@get_bibo_g

; 735  :     }
; 736  : 
; 737  :   return bibo_step_gains;

	mov	eax, DWORD PTR _this$1$[ebp]
$LN166@get_bibo_g:
	mov	eax, DWORD PTR [eax+96]
	pop	edi
	pop	esi

; 738  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?get_bibo_gains@kdu_kernels@@QAEPANHHQA_NAAN1@Z ENDP	; kdu_kernels::get_bibo_gains
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
;	COMDAT ?get_bibo_gain@kdu_kernels@@QAENHHQA_N@Z
_TEXT	SEGMENT
_high_gain$ = -24					; size = 8
_low_gain$ = -16					; size = 8
_bibo_gain$ = -8					; size = 8
_this$1$ = -4						; size = 4
_initial_lowpass_stages$ = 8				; size = 4
_num_extra_stages$ = 12					; size = 4
_extra_stage_high$ = 16					; size = 4
?get_bibo_gain@kdu_kernels@@QAENHHQA_N@Z PROC		; kdu_kernels::get_bibo_gain, COMDAT
; _this$ = ecx

; 542  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx

; 543  :   assert((num_extra_stages >= 0) && (num_extra_stages <= 3));
; 544  :   int n, record_idx = (1 << num_extra_stages) - 1;

	mov	ebx, DWORD PTR _num_extra_stages$[ebp]
	mov	eax, ecx
	mov	edx, 1
	mov	DWORD PTR _this$1$[ebp], eax
	mov	ecx, ebx
	shl	edx, cl
	push	esi
	dec	edx

; 545  :   for (n=0; n < num_extra_stages; n++)

	xor	esi, esi
	push	edi
	test	ebx, ebx
	jle	SHORT $LN3@get_bibo_g
	mov	edi, DWORD PTR _extra_stage_high$[ebp]
	mov	ecx, 1
	npad	7
$LL30@get_bibo_g:

; 546  :     record_idx += (extra_stage_high[n])?(1<<n):0;

	xor	eax, eax
	cmp	BYTE PTR [esi+edi], al
	cmovne	eax, ecx
	inc	esi
	add	edx, eax
	rol	ecx, 1
	cmp	esi, ebx
	jl	SHORT $LL30@get_bibo_g
	mov	eax, DWORD PTR _this$1$[ebp]
$LN3@get_bibo_g:

; 547  :   kd_bibo_gain_record *rec = NULL;

	xor	esi, esi

; 548  :   if (record_idx < 15)

	cmp	edx, 15					; 0000000fH
	jge	SHORT $LN5@get_bibo_g

; 549  :     rec = bibo_gain_records + record_idx;

	shl	edx, 4
	lea	esi, DWORD PTR [eax+360]
	add	esi, edx
$LN5@get_bibo_g:

; 550  : 
; 551  :   if (initial_lowpass_stages > max_initial_lowpass_stages)

	mov	eax, DWORD PTR [eax+100]
	mov	edi, DWORD PTR _initial_lowpass_stages$[ebp]
	cmp	edi, eax
	cmovg	edi, eax

; 552  :     initial_lowpass_stages = max_initial_lowpass_stages;
; 553  :   if ((rec != NULL) && (rec->initial_stages == initial_lowpass_stages))

	test	esi, esi
	je	SHORT $LN7@get_bibo_g
	cmp	DWORD PTR [esi], edi
	jne	SHORT $LN7@get_bibo_g

; 554  :     return rec->bibo_gain;

	fld	QWORD PTR [esi+8]
	pop	edi
	pop	esi
	pop	ebx

; 622  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN7@get_bibo_g:

; 555  : 
; 556  :   // If we get here, we need to calculate the BIBO gain.  We will use the
; 557  :   // `get_bibo_gains' function to calculate both low and high-pass gains
; 558  :   // at once, storing both of them in the records if allowed.
; 559  :   double low_gain, high_gain, bibo_gain;
; 560  :   if (num_extra_stages > 0)

	test	ebx, ebx
	jle	$LN8@get_bibo_g

; 561  :     {
; 562  :       get_bibo_gains(initial_lowpass_stages,num_extra_stages-1,

	lea	ecx, DWORD PTR _high_gain$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _low_gain$[ebp]
	push	ecx
	push	DWORD PTR _extra_stage_high$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR [ebx-1]
	push	eax
	push	edi
	call	?get_bibo_gains@kdu_kernels@@QAEPANHHQA_NAAN1@Z ; kdu_kernels::get_bibo_gains

; 563  :                      extra_stage_high,low_gain,high_gain);
; 564  :       if (extra_stage_high[num_extra_stages-1])

	mov	eax, DWORD PTR _extra_stage_high$[ebp]
	cmp	BYTE PTR [ebx+eax-1], 0
	je	SHORT $LN10@get_bibo_g

; 565  :         {
; 566  :           bibo_gain = high_gain;

	movsd	xmm0, QWORD PTR _high_gain$[ebp]
	movsd	QWORD PTR _bibo_gain$[ebp], xmm0

; 567  :           if (rec != NULL)

	test	esi, esi
	je	$LN23@get_bibo_g

; 568  :             {
; 569  :               if (rec->initial_stages < initial_lowpass_stages)

	cmp	DWORD PTR [esi], edi
	jge	SHORT $LN13@get_bibo_g

; 570  :                 {
; 571  :                   rec->initial_stages = initial_lowpass_stages;

	mov	DWORD PTR [esi], edi

; 572  :                   rec->bibo_gain = high_gain;

	movsd	QWORD PTR [esi+8], xmm0
$LN13@get_bibo_g:

; 573  :                 }
; 574  :               rec -= (int)(1<<(num_extra_stages-1));

	or	eax, -1
	lea	ecx, DWORD PTR [ebx-1]
	shl	eax, cl
	add	eax, eax

; 575  :                       // Rec with low-pass final branch
; 576  :               if (rec->initial_stages < initial_lowpass_stages)

	cmp	DWORD PTR [esi+eax*8], edi
	jge	$LN23@get_bibo_g

; 577  :                 {
; 578  :                   rec->initial_stages = initial_lowpass_stages;
; 579  :                   rec->bibo_gain = low_gain;

	movsd	xmm0, QWORD PTR _low_gain$[ebp]

; 620  : 
; 621  :   return bibo_gain;

	fld	QWORD PTR _bibo_gain$[ebp]
	mov	DWORD PTR [esi+eax*8], edi
	pop	edi
	movsd	QWORD PTR [esi+eax*8+8], xmm0
	pop	esi
	pop	ebx

; 622  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN10@get_bibo_g:

; 580  :                 }
; 581  :               else if (rec->initial_stages == initial_lowpass_stages)
; 582  :                 assert(rec->bibo_gain == low_gain);
; 583  :             }
; 584  :         }
; 585  :       else
; 586  :         {
; 587  :           bibo_gain = low_gain;

	movsd	xmm0, QWORD PTR _low_gain$[ebp]
	movsd	QWORD PTR _bibo_gain$[ebp], xmm0

; 588  :           if (rec != NULL)

	test	esi, esi
	je	$LN23@get_bibo_g

; 589  :             {
; 590  :               if (rec->initial_stages < initial_lowpass_stages)

	cmp	DWORD PTR [esi], edi
	jge	SHORT $LN18@get_bibo_g

; 591  :                 {
; 592  :                   rec->initial_stages = initial_lowpass_stages;

	mov	DWORD PTR [esi], edi

; 593  :                   rec->bibo_gain = low_gain;

	movsd	QWORD PTR [esi+8], xmm0
$LN18@get_bibo_g:

; 594  :                 }
; 595  :               rec += (int)(1<<(num_extra_stages-1));

	lea	ecx, DWORD PTR [ebx-1]
	mov	eax, 1
	shl	eax, cl
	add	eax, eax

; 596  :                       // Rec with hi-pass final branch
; 597  :               if (rec->initial_stages < initial_lowpass_stages)

	cmp	DWORD PTR [esi+eax*8], edi
	jge	SHORT $LN23@get_bibo_g

; 598  :                 {
; 599  :                   rec->initial_stages = initial_lowpass_stages;
; 600  :                   rec->bibo_gain = high_gain;

	movsd	xmm0, QWORD PTR _high_gain$[ebp]

; 620  : 
; 621  :   return bibo_gain;

	fld	QWORD PTR _bibo_gain$[ebp]
	mov	DWORD PTR [esi+eax*8], edi
	pop	edi
	movsd	QWORD PTR [esi+eax*8+8], xmm0
	pop	esi
	pop	ebx

; 622  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN8@get_bibo_g:

; 601  :                 }
; 602  :               else if (rec->initial_stages == initial_lowpass_stages)
; 603  :                 assert(rec->bibo_gain == high_gain);
; 604  :             }
; 605  :         }
; 606  :     }
; 607  :   else if (initial_lowpass_stages > 0)

	test	edi, edi
	jle	SHORT $LN22@get_bibo_g

; 608  :     {
; 609  :       get_bibo_gains(initial_lowpass_stages-1,0,NULL,low_gain,high_gain);

	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR _high_gain$[ebp]
	push	eax
	lea	eax, DWORD PTR _low_gain$[ebp]
	push	eax
	push	0
	push	0
	lea	eax, DWORD PTR [edi-1]
	push	eax
	call	?get_bibo_gains@kdu_kernels@@QAEPANHHQA_NAAN1@Z ; kdu_kernels::get_bibo_gains

; 610  :       assert((record_idx == 0) && (rec != NULL));
; 611  :       bibo_gain = low_gain;

	movsd	xmm0, QWORD PTR _low_gain$[ebp]
	movsd	QWORD PTR _bibo_gain$[ebp], xmm0

; 612  :       if (rec->initial_stages < initial_lowpass_stages)

	cmp	DWORD PTR [esi], edi
	jge	SHORT $LN23@get_bibo_g

; 620  : 
; 621  :   return bibo_gain;

	fld	QWORD PTR _bibo_gain$[ebp]
	mov	DWORD PTR [esi], edi
	pop	edi
	movsd	QWORD PTR [esi+8], xmm0
	pop	esi
	pop	ebx

; 622  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN22@get_bibo_g:

; 613  :         {
; 614  :           rec->initial_stages = initial_lowpass_stages;
; 615  :           rec->bibo_gain = bibo_gain;
; 616  :         }
; 617  :     }
; 618  :   else
; 619  :     bibo_gain = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _bibo_gain$[ebp], xmm0
$LN23@get_bibo_g:

; 620  : 
; 621  :   return bibo_gain;

	fld	QWORD PTR _bibo_gain$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 622  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get_bibo_gain@kdu_kernels@@QAENHHQA_N@Z ENDP		; kdu_kernels::get_bibo_gain
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
;	COMDAT ?get_energy_gain@kdu_kernels@@QAENHHQA_N@Z
_TEXT	SEGMENT
_energy$ = -20						; size = 8
_interp_factor$ = -12					; size = 8
_rec$1$ = -4						; size = 4
_this$1$ = -4						; size = 4
_initial_lowpass_stages$ = 8				; size = 4
_n$3$ = 12						; size = 4
_n$2$ = 12						; size = 4
_num_extra_stages$ = 12					; size = 4
_extra_stage_high$ = 16					; size = 4
?get_energy_gain@kdu_kernels@@QAENHHQA_N@Z PROC		; kdu_kernels::get_energy_gain, COMDAT
; _this$ = ecx

; 477  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 478  :   assert((num_extra_stages >= 0) && (num_extra_stages <= 3));
; 479  :   int n, record_idx = (1 << num_extra_stages) - 1;

	mov	eax, DWORD PTR _num_extra_stages$[ebp]
	mov	edx, 1
	push	ebx
	push	esi
	mov	esi, ecx
	mov	ecx, eax
	shl	edx, cl
	push	edi
	dec	edx
	mov	DWORD PTR _this$1$[ebp], esi

; 480  :   for (n=0; n < num_extra_stages; n++)

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN3@get_energy
	mov	ebx, DWORD PTR _extra_stage_high$[ebp]
	lea	ecx, DWORD PTR [edi+1]
	mov	esi, eax
	npad	7
$LL34@get_energy:

; 481  :     record_idx += (extra_stage_high[n])?(1<<n):0;

	xor	eax, eax
	cmp	BYTE PTR [edi+ebx], al
	cmovne	eax, ecx
	inc	edi
	add	edx, eax
	rol	ecx, 1
	cmp	edi, esi
	jl	SHORT $LL34@get_energy
	mov	esi, DWORD PTR _this$1$[ebp]
$LN3@get_energy:

; 482  :   kd_energy_gain_record *rec = NULL;

	xor	ebx, ebx
	mov	DWORD PTR _rec$1$[ebp], ebx

; 483  :   if (record_idx < 15)

	cmp	edx, 15					; 0000000fH
	jge	SHORT $LN16@get_energy

; 484  :     rec = energy_gain_records + record_idx;

	shl	edx, 4
	lea	ebx, DWORD PTR [esi+120]
	add	ebx, edx
	mov	DWORD PTR _rec$1$[ebp], ebx
$LN16@get_energy:

; 485  : 
; 486  :   int calculated_initial_lowpass_stages = initial_lowpass_stages;
; 487  :   double interp_factor = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	mov	edi, DWORD PTR [esi+100]
	mov	edx, DWORD PTR _initial_lowpass_stages$[ebp]
	movsd	QWORD PTR _interp_factor$[ebp], xmm0
	cmp	edx, edi
	jle	SHORT $LN45@get_energy

; 488  :   while (calculated_initial_lowpass_stages > max_initial_lowpass_stages)

	movsd	xmm1, QWORD PTR __real@4000000000000000
	mov	eax, edx
	sub	eax, edi
	cmp	eax, 8
	jl	SHORT $LC46@get_energy

; 480  :   for (n=0; n < num_extra_stages; n++)

	mov	ecx, edx
	sub	ecx, edi
	sub	ecx, 8
	shr	ecx, 3
	inc	ecx
	lea	eax, DWORD PTR [ecx*8]
	sub	edx, eax
	mov	DWORD PTR _initial_lowpass_stages$[ebp], edx
	npad	8

; 488  :   while (calculated_initial_lowpass_stages > max_initial_lowpass_stages)

$LL47@get_energy:

; 489  :     {
; 490  :       calculated_initial_lowpass_stages--;
; 491  :       interp_factor *= 2.0;

	mulsd	xmm0, xmm1
	mulsd	xmm0, xmm1
	mulsd	xmm0, xmm1
	mulsd	xmm0, xmm1
	mulsd	xmm0, xmm1
	mulsd	xmm0, xmm1
	mulsd	xmm0, xmm1
	mulsd	xmm0, xmm1
	sub	ecx, 1
	jne	SHORT $LL47@get_energy
	movsd	QWORD PTR _interp_factor$[ebp], xmm0
$LC46@get_energy:

; 488  :   while (calculated_initial_lowpass_stages > max_initial_lowpass_stages)

	cmp	edx, edi
	jle	SHORT $LN45@get_energy
	mov	eax, edx
	sub	eax, edi
	sub	edx, eax
	mov	DWORD PTR _initial_lowpass_stages$[ebp], edx
$LC5@get_energy:

; 489  :     {
; 490  :       calculated_initial_lowpass_stages--;
; 491  :       interp_factor *= 2.0;

	mulsd	xmm0, xmm1
	sub	eax, 1
	jne	SHORT $LC5@get_energy
	movsd	QWORD PTR _interp_factor$[ebp], xmm0
$LN45@get_energy:

; 492  :     }
; 493  :   if ((rec != NULL) &&

	test	ebx, ebx
	je	SHORT $LN17@get_energy
	cmp	DWORD PTR [ebx], edx
	jne	SHORT $LN17@get_energy

; 494  :       (rec->initial_stages == calculated_initial_lowpass_stages))
; 495  :     return (rec->energy_gain * interp_factor);

	fld	QWORD PTR [ebx+8]

; 531  :     }
; 532  :   return energy * interp_factor;

	fmul	QWORD PTR _interp_factor$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 533  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN17@get_energy:

; 496  : 
; 497  :   int half_len;
; 498  :   float **wtmp, **wp[2] = {&work1,&work2};
; 499  :   work1[0] = 1.0F;  half_len = 0;

	mov	eax, DWORD PTR [esi+108]
	lea	edi, DWORD PTR [esi+108]
	xor	ecx, ecx
	lea	ebx, DWORD PTR [esi+112]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 500  :   for (n=num_extra_stages-1; n >= 0; n--)

	mov	eax, DWORD PTR _num_extra_stages$[ebp]
	add	eax, -1
	mov	DWORD PTR _n$2$[ebp], eax
	js	SHORT $LN8@get_energy
$LL9@get_energy:

; 501  :     {
; 502  :       if (extra_stage_high[n])

	mov	edx, DWORD PTR _extra_stage_high$[ebp]

; 503  :         half_len = expand_and_convolve(wp[0],half_len,high_synthesis_taps,

	push	ebx
	cmp	BYTE PTR [eax+edx], 0
	je	SHORT $LN18@get_energy
	push	DWORD PTR [esi+80]
	push	DWORD PTR [esi+92]

; 504  :                                        high_synthesis_L,wp[1]);
; 505  :       else

	jmp	SHORT $LN59@get_energy
$LN18@get_energy:

; 506  :         half_len = expand_and_convolve(wp[0],half_len,low_synthesis_taps,

	push	DWORD PTR [esi+64]
	push	DWORD PTR [esi+76]
$LN59@get_energy:
	push	ecx
	push	edi
	mov	ecx, esi
	call	?expand_and_convolve@kdu_kernels@@AAEHPAPAMHPAMH0@Z ; kdu_kernels::expand_and_convolve
	mov	ecx, eax

; 507  :                                        low_synthesis_L,wp[1]);
; 508  :       wtmp = wp[0]; wp[0] = wp[1];  wp[1] = wtmp;

	mov	eax, edi
	mov	edi, ebx
	mov	ebx, eax
	mov	eax, DWORD PTR _n$2$[ebp]
	sub	eax, 1
	mov	DWORD PTR _n$2$[ebp], eax
	jns	SHORT $LL9@get_energy
	mov	edx, DWORD PTR _initial_lowpass_stages$[ebp]
$LN8@get_energy:

; 509  :     }
; 510  :   for (n=calculated_initial_lowpass_stages; n > 0; n--)

	mov	DWORD PTR _n$3$[ebp], edx
	test	edx, edx
	jle	SHORT $LN11@get_energy
$LL12@get_energy:

; 511  :     {
; 512  :       half_len = expand_and_convolve(wp[0],half_len,low_synthesis_taps,

	push	ebx
	push	DWORD PTR [esi+64]
	push	DWORD PTR [esi+76]
	push	ecx
	push	edi
	mov	ecx, esi
	call	?expand_and_convolve@kdu_kernels@@AAEHPAPAMHPAMH0@Z ; kdu_kernels::expand_and_convolve
	mov	ecx, eax

; 513  :                                      low_synthesis_L,wp[1]);
; 514  :       wtmp = wp[0]; wp[0] = wp[1];  wp[1] = wtmp;

	mov	eax, edi
	mov	edi, ebx
	mov	ebx, eax
	mov	eax, DWORD PTR _n$3$[ebp]
	dec	eax
	mov	DWORD PTR _n$3$[ebp], eax
	test	eax, eax
	jg	SHORT $LL12@get_energy
$LN11@get_energy:

; 515  :     }
; 516  :   assert(half_len <= work_L);
; 517  : 
; 518  :   float *src = *(wp[0]);

	mov	edi, DWORD PTR [edi]

; 519  :   double val, energy = 0.0;
; 520  :   for (n=-half_len; n <= half_len; n++)

	mov	edx, ecx
	neg	edx
	xorps	xmm1, xmm1
	movsd	QWORD PTR _energy$[ebp], xmm1
	cmp	edx, ecx
	jg	$LN48@get_energy
	mov	eax, ecx
	sub	eax, edx
	inc	eax
	cmp	eax, 4
	jl	SHORT $LC49@get_energy
	mov	eax, ecx
	lea	esi, DWORD PTR [edx+2]
	sub	eax, edx
	lea	esi, DWORD PTR [edi+esi*4]
	sub	eax, 3
	shr	eax, 2
	inc	eax
	lea	edx, DWORD PTR [edx+eax*4]
	npad	3
$LL50@get_energy:

; 521  :     {
; 522  :       val = src[n];

	movss	xmm0, DWORD PTR [esi-8]
	cvtps2pd xmm0, xmm0

; 523  :       energy += val*val;

	mulsd	xmm0, xmm0
	addsd	xmm0, xmm1
	movss	xmm1, DWORD PTR [esi-4]
	cvtps2pd xmm1, xmm1
	mulsd	xmm1, xmm1
	addsd	xmm1, xmm0
	movss	xmm0, DWORD PTR [esi]
	cvtps2pd xmm0, xmm0
	mulsd	xmm0, xmm0
	addsd	xmm0, xmm1
	movss	xmm1, DWORD PTR [esi+4]
	cvtps2pd xmm1, xmm1
	add	esi, 16					; 00000010H
	mulsd	xmm1, xmm1
	addsd	xmm1, xmm0
	sub	eax, 1
	jne	SHORT $LL50@get_energy
	movsd	QWORD PTR _energy$[ebp], xmm1
$LC49@get_energy:

; 519  :   double val, energy = 0.0;
; 520  :   for (n=-half_len; n <= half_len; n++)

	cmp	edx, ecx
	jg	SHORT $LN48@get_energy
$LC38@get_energy:
	movss	xmm0, DWORD PTR [edi+edx*4]

; 480  :   for (n=0; n < num_extra_stages; n++)

	inc	edx

; 521  :     {
; 522  :       val = src[n];

	cvtps2pd xmm0, xmm0

; 523  :       energy += val*val;

	mulsd	xmm0, xmm0
	addsd	xmm1, xmm0
	cmp	edx, ecx
	jle	SHORT $LC38@get_energy
	movsd	QWORD PTR _energy$[ebp], xmm1
$LN48@get_energy:

; 524  :     }
; 525  : 
; 526  :   if ((rec != NULL) &&

	mov	ecx, DWORD PTR _rec$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN20@get_energy
	mov	eax, DWORD PTR _initial_lowpass_stages$[ebp]
	cmp	DWORD PTR [ecx], eax
	jge	SHORT $LN20@get_energy

; 527  :       (rec->initial_stages < calculated_initial_lowpass_stages))
; 528  :     {
; 529  :       rec->initial_stages = calculated_initial_lowpass_stages;

	mov	DWORD PTR [ecx], eax

; 530  :       rec->energy_gain = energy;

	movsd	QWORD PTR [ecx+8], xmm1
$LN20@get_energy:

; 531  :     }
; 532  :   return energy * interp_factor;

	fld	QWORD PTR _energy$[ebp]
	fmul	QWORD PTR _interp_factor$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 533  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get_energy_gain@kdu_kernels@@QAENHHQA_N@Z ENDP		; kdu_kernels::get_energy_gain
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
;	COMDAT ?get_impulse_response@kdu_kernels@@QAEPAMW4kdu_kernel_type@@AAHPAH2@Z
_TEXT	SEGMENT
_which$ = 8						; size = 4
_half_length$ = 12					; size = 4
_support_min$ = 16					; size = 4
_support_max$ = 20					; size = 4
?get_impulse_response@kdu_kernels@@QAEPAMW4kdu_kernel_type@@AAHPAH2@Z PROC ; kdu_kernels::get_impulse_response, COMDAT
; _this$ = ecx

; 442  : {

	push	ebp
	mov	ebp, esp

; 443  :   switch (which) {

	mov	eax, DWORD PTR _which$[ebp]
	mov	edx, ecx
	cmp	eax, 3
	ja	$LN16@get_impuls
	jmp	DWORD PTR $LN19@get_impuls[eax*4]
$LN4@get_impuls:

; 444  :     case KDU_ANALYSIS_LOW:
; 445  :       if (support_min != NULL) *support_min = low_analysis_min;

	mov	ecx, DWORD PTR _support_min$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@get_impuls
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx], eax
$LN5@get_impuls:

; 446  :       if (support_max != NULL) *support_max = low_analysis_max;

	mov	ecx, DWORD PTR _support_max$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@get_impuls
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx], eax
$LN6@get_impuls:

; 447  :       half_length = low_analysis_L;

	mov	eax, DWORD PTR _half_length$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	mov	DWORD PTR [eax], ecx

; 448  :       return low_analysis_taps;

	mov	eax, DWORD PTR [edx+44]

; 468  : }

	pop	ebp
	ret	16					; 00000010H
$LN7@get_impuls:

; 449  :     case KDU_ANALYSIS_HIGH:
; 450  :       if (support_min != NULL) *support_min = high_analysis_min;

	mov	ecx, DWORD PTR _support_min$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@get_impuls
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx], eax
$LN8@get_impuls:

; 451  :       if (support_max != NULL) *support_max = high_analysis_max;

	mov	ecx, DWORD PTR _support_max$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@get_impuls
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR [ecx], eax
$LN9@get_impuls:

; 452  :       half_length = high_analysis_L;

	mov	eax, DWORD PTR _half_length$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	mov	DWORD PTR [eax], ecx

; 453  :       return high_analysis_taps;

	mov	eax, DWORD PTR [edx+60]

; 468  : }

	pop	ebp
	ret	16					; 00000010H
$LN10@get_impuls:

; 454  :     case KDU_SYNTHESIS_LOW:
; 455  :       if (support_min != NULL) *support_min = low_synthesis_min;

	mov	ecx, DWORD PTR _support_min$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@get_impuls
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR [ecx], eax
$LN11@get_impuls:

; 456  :       if (support_max != NULL) *support_max = low_synthesis_max;

	mov	ecx, DWORD PTR _support_max$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@get_impuls
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR [ecx], eax
$LN12@get_impuls:

; 457  :       half_length = low_synthesis_L;

	mov	eax, DWORD PTR _half_length$[ebp]
	mov	ecx, DWORD PTR [edx+64]
	mov	DWORD PTR [eax], ecx

; 458  :       return low_synthesis_taps;

	mov	eax, DWORD PTR [edx+76]

; 468  : }

	pop	ebp
	ret	16					; 00000010H
$LN13@get_impuls:

; 459  :     case KDU_SYNTHESIS_HIGH:
; 460  :       if (support_min != NULL) *support_min = high_synthesis_min;

	mov	ecx, DWORD PTR _support_min$[ebp]
	test	ecx, ecx
	je	SHORT $LN14@get_impuls
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR [ecx], eax
$LN14@get_impuls:

; 461  :       if (support_max != NULL) *support_max = high_synthesis_max;

	mov	ecx, DWORD PTR _support_max$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@get_impuls
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR [ecx], eax
$LN15@get_impuls:

; 462  :       half_length = high_synthesis_L;

	mov	eax, DWORD PTR _half_length$[ebp]
	mov	ecx, DWORD PTR [edx+80]
	mov	DWORD PTR [eax], ecx

; 463  :       return high_synthesis_taps;

	mov	eax, DWORD PTR [edx+92]

; 468  : }

	pop	ebp
	ret	16					; 00000010H
$LN16@get_impuls:

; 464  :     default:
; 465  :       assert(0);
; 466  :     }
; 467  :   return NULL;

	xor	eax, eax

; 468  : }

	pop	ebp
	ret	16					; 00000010H
	npad	2
$LN19@get_impuls:
	DD	$LN4@get_impuls
	DD	$LN7@get_impuls
	DD	$LN10@get_impuls
	DD	$LN13@get_impuls
?get_impulse_response@kdu_kernels@@QAEPAMW4kdu_kernel_type@@AAHPAH2@Z ENDP ; kdu_kernels::get_impulse_response
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
;	COMDAT ?init@kdu_kernels@@QAEXHPBUkdu_kernel_step_info@@PBM_N22@Z
_TEXT	SEGMENT
tv1045 = -32						; size = 4
tv1035 = -28						; size = 4
tv1047 = -24						; size = 4
tv1033 = -20						; size = 4
tv1036 = -16						; size = 4
tv1038 = -12						; size = 4
_n$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
_num_steps$ = 8						; size = 4
tv1044 = 12						; size = 4
_info$ = 12						; size = 4
_Ls$1$ = 16						; size = 4
_coefficients$ = 16					; size = 4
tv1046 = 20						; size = 4
_symmetric$ = 20					; size = 1
tv1043 = 24						; size = 4
_symmetric_extension$ = 24				; size = 1
_s$1$ = 28						; size = 4
$T1 = 28						; size = 4
_reversible$ = 28					; size = 1
?init@kdu_kernels@@QAEXHPBUkdu_kernel_step_info@@PBM_N22@Z PROC ; kdu_kernels::init, COMDAT
; _this$ = ecx

; 281  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$1$[ebp], esi

; 282  :   int s, n;
; 283  : 
; 284  :   reset();

	call	?reset@kdu_kernels@@AAEXXZ		; kdu_kernels::reset

; 285  :   this->kernel_id = Ckernels_ATK;
; 286  :   this->reversible = reversible;

	mov	al, BYTE PTR _reversible$[ebp]

; 291  :   step_info = new kdu_kernel_step_info[num_steps];

	xor	ecx, ecx
	mov	ebx, DWORD PTR _num_steps$[ebp]
	mov	edx, 16					; 00000010H
	mov	BYTE PTR [esi+4], al
	mov	al, BYTE PTR _symmetric$[ebp]
	mov	BYTE PTR [esi+5], al
	mov	al, BYTE PTR _symmetric_extension$[ebp]
	mov	BYTE PTR [esi+6], al
	mov	eax, ebx
	mul	edx
	mov	DWORD PTR [esi], -1
	mov	DWORD PTR [esi+8], ebx
	seto	cl
	mov	DWORD PTR [esi+12], 0
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN16@init
	mov	edx, ebx
	test	ebx, ebx
	je	SHORT $LN17@init
	lea	ecx, DWORD PTR [eax+12]
$LL20@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 101  :       { support_length = support_min = 0;  downshift = rounding_offset = 0; }

	mov	DWORD PTR [ecx-8], 0
	lea	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx-28], 0
	mov	DWORD PTR [ecx-16], 0
	mov	DWORD PTR [ecx-20], 0
	sub	edx, 1
	jne	SHORT $LL20@init
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp

; 291  :   step_info = new kdu_kernel_step_info[num_steps];

	jmp	SHORT $LN17@init
$LN16@init:
	xor	eax, eax
$LN17@init:
	mov	DWORD PTR [esi+16], eax

; 292  :   for (s=0; s < num_steps; s++)

	test	ebx, ebx
	jle	SHORT $LN3@init

; 291  :   step_info = new kdu_kernel_step_info[num_steps];

	mov	ecx, DWORD PTR _info$[ebp]
	xor	edx, edx
	mov	edi, ebx
	npad	7
$LL4@init:

; 292  :   for (s=0; s < num_steps; s++)

	mov	eax, DWORD PTR [esi+16]

; 293  :     {
; 294  :       step_info[s] = info[s];

	movups	xmm0, XMMWORD PTR [ecx]
	movups	XMMWORD PTR [eax+edx], xmm0

; 295  :       if (info[s].support_length > max_step_length)

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi+12]
	jle	SHORT $LN2@init

; 296  :         max_step_length = info[s].support_length;

	mov	DWORD PTR [esi+12], eax
$LN2@init:

; 292  :   for (s=0; s < num_steps; s++)

	add	edx, 16					; 00000010H
	add	ecx, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL4@init
$LN3@init:

; 297  :     }
; 298  :   lifting_factors = new float[max_step_length*num_steps];

	mov	eax, DWORD PTR [esi+12]
	xor	ecx, ecx
	imul	eax, ebx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 299  :   for (s=0; s < num_steps; s++)

	mov	ecx, ebx
	mov	DWORD PTR [esi+20], eax
	add	esp, 4
	mov	DWORD PTR _s$1$[ebp], 0
	test	ecx, ecx
	jle	$LN6@init

; 297  :     }
; 298  :   lifting_factors = new float[max_step_length*num_steps];

	mov	ebx, DWORD PTR _coefficients$[ebp]
	lea	edi, DWORD PTR [ecx*4]
	xor	edx, edx
	mov	DWORD PTR tv1036[ebp], 0
	mov	DWORD PTR tv1035[ebp], edx
	mov	DWORD PTR tv1038[ebp], edi
	mov	DWORD PTR tv1033[ebp], edi
	npad	2
$LL7@init:

; 300  :     {
; 301  :       int Ls = step_info[s].support_length;

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [edx+eax]

; 302  :       for (n=0; n < Ls; n++)

	xor	edx, edx
	mov	DWORD PTR _Ls$1$[ebp], eax
	cmp	eax, 4
	jl	$LC42@init

; 300  :     {
; 301  :       int Ls = step_info[s].support_length;

	mov	edx, DWORD PTR tv1036[ebp]
	mov	edi, ecx
	mov	DWORD PTR tv1046[ebp], edx
	add	eax, -4					; fffffffcH
	mov	edx, DWORD PTR _s$1$[ebp]
	shr	eax, 2
	shl	edi, 4
	lea	edx, DWORD PTR [edx+ecx*2]
	add	edx, ecx
	shl	edx, 2
	mov	DWORD PTR tv1045[ebp], edx
	mov	edx, DWORD PTR _s$1$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*2]
	shl	ecx, 2
	inc	eax
	mov	DWORD PTR tv1044[ebp], ecx
	mov	ecx, DWORD PTR tv1033[ebp]
	mov	DWORD PTR tv1043[ebp], ecx
	lea	edx, DWORD PTR [eax*4]
	mov	DWORD PTR tv1047[ebp], eax
	mov	DWORD PTR _n$1$[ebp], edx
	mov	edx, DWORD PTR tv1045[ebp]

; 302  :       for (n=0; n < Ls; n++)

$LL43@init:

; 303  :         lifting_factors[s + n*num_steps] = *(coefficients++);

	mov	ecx, DWORD PTR [esi+20]
	mov	esi, DWORD PTR tv1046[ebp]
	mov	eax, DWORD PTR [ebx]
	add	DWORD PTR tv1046[ebp], edi
	mov	DWORD PTR [esi+ecx], eax
	mov	esi, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [esi+20]
	mov	esi, DWORD PTR tv1043[ebp]
	add	DWORD PTR tv1043[ebp], edi
	mov	DWORD PTR [esi+ecx], eax
	mov	esi, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [esi+20]
	mov	esi, DWORD PTR tv1044[ebp]
	add	DWORD PTR tv1044[ebp], edi
	mov	DWORD PTR [esi+ecx], eax
	mov	esi, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ebx+12]
	add	ebx, 16					; 00000010H
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [edx+ecx], eax
	add	edx, edi
	sub	DWORD PTR tv1047[ebp], 1
	jne	SHORT $LL43@init
	mov	edx, DWORD PTR _n$1$[ebp]
	mov	eax, DWORD PTR _Ls$1$[ebp]
	mov	edi, DWORD PTR tv1038[ebp]
	mov	ecx, DWORD PTR _num_steps$[ebp]
$LC42@init:

; 302  :       for (n=0; n < Ls; n++)

	cmp	edx, eax
	jge	SHORT $LN41@init
	mov	edi, edx
	sub	eax, edx
	imul	edi, ecx
	mov	DWORD PTR _Ls$1$[ebp], eax
	add	edi, DWORD PTR _s$1$[ebp]
	shl	edi, 2
	add	edx, eax
	mov	DWORD PTR _n$1$[ebp], edx
	mov	edx, eax
$LC10@init:

; 303  :         lifting_factors[s + n*num_steps] = *(coefficients++);

	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [ebx]
	add	ebx, 4
	mov	DWORD PTR [edi+ecx], eax
	add	edi, DWORD PTR tv1038[ebp]
	sub	edx, 1
	jne	SHORT $LC10@init
	mov	edx, DWORD PTR _n$1$[ebp]
	mov	edi, DWORD PTR tv1038[ebp]
$LN41@init:

; 304  :       for (; n < max_step_length; n++)

	cmp	edx, DWORD PTR [esi+12]
	jge	SHORT $LN5@init
	mov	ecx, edx
	imul	ecx, DWORD PTR _num_steps$[ebp]
	add	ecx, DWORD PTR _s$1$[ebp]
	shl	ecx, 2
$LL13@init:

; 305  :         lifting_factors[s + n*num_steps] = 0.0F;

	mov	eax, DWORD PTR [esi+20]
	inc	edx
	mov	DWORD PTR [ecx+eax], 0
	add	ecx, edi
	cmp	edx, DWORD PTR [esi+12]
	jl	SHORT $LL13@init
$LN5@init:

; 299  :   for (s=0; s < num_steps; s++)

	mov	eax, DWORD PTR _s$1$[ebp]
	mov	edx, DWORD PTR tv1035[ebp]
	inc	eax
	add	DWORD PTR tv1036[ebp], 4
	add	edx, 16					; 00000010H
	add	DWORD PTR tv1033[ebp], 4
	mov	ecx, DWORD PTR _num_steps$[ebp]
	mov	DWORD PTR _s$1$[ebp], eax
	mov	DWORD PTR tv1035[ebp], edx
	cmp	eax, ecx
	jl	$LL7@init
$LN6@init:

; 306  :     }
; 307  : 
; 308  :   derive_taps_and_gains();

	mov	ecx, esi
	call	?derive_taps_and_gains@kdu_kernels@@AAEXXZ ; kdu_kernels::derive_taps_and_gains
	pop	edi
	pop	esi
	pop	ebx

; 309  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?init@kdu_kernels@@QAEXHPBUkdu_kernel_step_info@@PBM_N22@Z ENDP ; kdu_kernels::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp
;	COMDAT ?init@kdu_kernels@@QAEXH_N@Z
_TEXT	SEGMENT
_e$2 = -52						; size = 20
_e$3 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_kernel_id$ = 8						; size = 4
$T4 = 12						; size = 4
$T5 = 12						; size = 4
_reversible$ = 12					; size = 1
?init@kdu_kernels@@QAEXH_N@Z PROC			; kdu_kernels::init, COMDAT
; _this$ = ecx

; 219  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?init@kdu_kernels@@QAEXH_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 220  :   reset();

	call	?reset@kdu_kernels@@AAEXXZ		; kdu_kernels::reset

; 221  :   this->kernel_id = kernel_id;

	mov	eax, DWORD PTR _kernel_id$[ebp]

; 222  :   this->reversible = reversible;

	mov	bl, BYTE PTR _reversible$[ebp]
	mov	DWORD PTR [esi], eax
	mov	BYTE PTR [esi+4], bl

; 223  :   this->symmetric = true;

	mov	WORD PTR [esi+5], 257			; 00000101H

; 224  :   this->symmetric_extension = true;
; 225  :   if (kernel_id == Ckernels_W5X3)

	cmp	eax, 1
	jne	$LN5@init

; 229  :       step_info = new kdu_kernel_step_info[num_steps];

	xor	ecx, ecx
	mov	DWORD PTR [esi+8], 2
	mov	eax, 2
	mov	DWORD PTR [esi+12], 2
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	test	eax, eax
	je	SHORT $LN12@init
	mov	edx, 2
	lea	ecx, DWORD PTR [eax+12]
$LL21@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 101  :       { support_length = support_min = 0;  downshift = rounding_offset = 0; }

	mov	DWORD PTR [ecx-8], 0
	lea	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx-28], 0
	mov	DWORD PTR [ecx-16], 0
	mov	DWORD PTR [ecx-20], 0
	sub	edx, 1
	jne	SHORT $LL21@init
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp

; 229  :       step_info = new kdu_kernel_step_info[num_steps];

	jmp	SHORT $LN13@init
$LN12@init:
	xor	eax, eax
$LN13@init:
	mov	DWORD PTR [esi+16], eax

; 230  :       step_info[0].support_length = step_info[1].support_length = 2;
; 231  :       lifting_factors = new float[2*num_steps];

	xor	ecx, ecx
	mov	DWORD PTR [eax+16], 2
	mov	edx, 4
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax], 2
	mov	eax, DWORD PTR [esi+8]
	add	eax, eax
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+20], eax
	add	esp, 4

; 232  :       lifting_factors[0] = lifting_factors[2] = -0.5F;

	mov	DWORD PTR [eax+8], -1090519040		; bf000000H
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax], -1090519040		; bf000000H

; 233  :       lifting_factors[1] = lifting_factors[3] = 0.25F;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+12], 1048576000		; 3e800000H
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+4], 1048576000		; 3e800000H

; 234  :       if (reversible)

	test	bl, bl
	je	$LN9@init

; 235  :         {
; 236  :           step_info[0].downshift = 1;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+8], 1

; 237  :           step_info[1].downshift = 2;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+24], 2

; 238  :           step_info[0].rounding_offset = 1;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+12], 1

; 239  :           step_info[1].rounding_offset = 2;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+28], 2

; 240  :         }
; 241  :     }

	jmp	$LN9@init
$LN5@init:

; 242  :   else if (kernel_id == Ckernels_W9X7)

	test	eax, eax
	jne	$LN8@init

; 246  :       step_info = new kdu_kernel_step_info[num_steps];

	xor	ecx, ecx
	mov	DWORD PTR [esi+8], 4
	mov	edi, 4
	mov	DWORD PTR [esi+12], 2
	mov	eax, edi
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	test	eax, eax
	je	SHORT $LN14@init
	mov	edx, edi
	lea	ecx, DWORD PTR [eax+12]
	npad	5
$LL27@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 101  :       { support_length = support_min = 0;  downshift = rounding_offset = 0; }

	mov	DWORD PTR [ecx-8], 0
	lea	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx-28], 0
	mov	DWORD PTR [ecx-16], 0
	mov	DWORD PTR [ecx-20], 0
	sub	edx, 1
	jne	SHORT $LL27@init
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp

; 246  :       step_info = new kdu_kernel_step_info[num_steps];

	jmp	SHORT $LN15@init
$LN14@init:
	xor	eax, eax
$LN15@init:
	mov	DWORD PTR [esi+16], eax

; 247  :       step_info[0].support_length = step_info[1].support_length =
; 248  :         step_info[2].support_length = step_info[3].support_length = 2;
; 249  :       lifting_factors = new float[2*num_steps];

	xor	ecx, ecx
	mov	DWORD PTR [eax+48], 2
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+32], 2
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+16], 2
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax], 2
	mov	eax, DWORD PTR [esi+8]
	add	eax, eax
	mul	edi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+20], eax

; 250  :       if (reversible)

	test	bl, bl
	je	SHORT $LN10@init

; 251  :         { KDU_ERROR(e,0); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0DM@IMEJCDIE@The?5W9X7?5kernel?5may?5not?5be?5used?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp

; 251  :         { KDU_ERROR(e,0); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp

; 254  :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN10@init:

; 255  :       lifting_factors[0] = lifting_factors[4] = (float) -1.586134342;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+16], -1077213581		; bfcb0673H
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax], -1077213581		; bfcb0673H

; 256  :       lifting_factors[1] = lifting_factors[5] = (float) -0.052980118;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+20], -1118240338		; bd5901aeH
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+4], -1118240338		; bd5901aeH

; 257  :       lifting_factors[2] = lifting_factors[6] = (float) 0.882911075;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+24], 1063388790		; 3f620676H
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+8], 1063388790		; 3f620676H

; 258  :       lifting_factors[3] = lifting_factors[7] = (float)  0.443506852;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+28], 1055069013		; 3ee31355H
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+12], 1055069013		; 3ee31355H

; 259  :     }
; 260  :   else

	jmp	SHORT $LN9@init
$LN8@init:

; 261  :     { KDU_ERROR_DEV(e,1); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EA@EBONPOMG@Illegal?5DWT?5kernel?5ID?5used?5to?5co@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp

; 261  :     { KDU_ERROR_DEV(e,1); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\kernels\kernels.cpp

; 264  :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN9@init:

; 265  : 
; 266  :   for (int n=0; n < num_steps; n++)

	xor	edi, edi
	cmp	DWORD PTR [esi+8], edi
	jle	SHORT $LN3@init
	xor	ebx, ebx
	npad	5
$LL4@init:

; 267  :     step_info[n].support_min =

	mov	edx, DWORD PTR [esi+16]
	lea	ebx, DWORD PTR [ebx+16]
	mov	ecx, edi
	inc	edi
	and	ecx, 1
	mov	eax, DWORD PTR [ebx+edx-16]
	dec	eax
	add	eax, ecx
	sar	eax, 1
	neg	eax
	mov	DWORD PTR [ebx+edx-12], eax
	cmp	edi, DWORD PTR [esi+8]
	jl	SHORT $LL4@init
$LN3@init:

; 268  :       -((step_info[n].support_length + (n & 1) - 1) >> 1);
; 269  : 
; 270  :   derive_taps_and_gains();

	mov	ecx, esi
	call	?derive_taps_and_gains@kdu_kernels@@AAEXXZ ; kdu_kernels::derive_taps_and_gains

; 271  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?init@kdu_kernels@@QAEXH_N@Z$2:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?init@kdu_kernels@@QAEXH_N@Z$3:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?init@kdu_kernels@@QAEXH_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?init@kdu_kernels@@QAEXH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?init@kdu_kernels@@QAEXH_N@Z ENDP			; kdu_kernels::init
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ??0kdu_kernel_step_info@@QAE@XZ
_TEXT	SEGMENT
??0kdu_kernel_step_info@@QAE@XZ PROC			; kdu_kernel_step_info::kdu_kernel_step_info, COMDAT
; _this$ = ecx

; 101  :       { support_length = support_min = 0;  downshift = rounding_offset = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0kdu_kernel_step_info@@QAE@XZ ENDP			; kdu_kernel_step_info::kdu_kernel_step_info
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
??6kdu_message@@QAEAAV0@PBD@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 257  :       { put_text(string); return *this; }

	push	ebp
	mov	ebp, esp
	push	esi
	push	DWORD PTR _string$[ebp]
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@PBD@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
