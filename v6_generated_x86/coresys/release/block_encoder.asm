; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\coding\block_encoder.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_printf
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	??1kdu_block_encoder_base@@MAE@XZ		; kdu_block_encoder_base::~kdu_block_encoder_base
PUBLIC	??_Gkdu_block_encoder_base@@MAEPAXI@Z		; kdu_block_encoder_base::`scalar deleting destructor'
PUBLIC	??0kdu_block_encoder@@QAE@XZ			; kdu_block_encoder::kdu_block_encoder
PUBLIC	??0mq_encoder@@QAE@XZ				; mq_encoder::mq_encoder
PUBLIC	?get_incremental_length@mq_encoder@@QAEHAA_N@Z	; mq_encoder::get_incremental_length
PUBLIC	?encode@kd_block_encoder@@MAEXPAUkdu_block@@_NNG@Z ; kd_block_encoder::encode
PUBLIC	??_Gkd_block_encoder@@UAEPAXI@Z			; kd_block_encoder::`scalar deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7kdu_block_encoder_base@@6B@			; kdu_block_encoder_base::`vftable'
PUBLIC	??_7kd_block_encoder@@6B@			; kd_block_encoder::`vftable'
PUBLIC	??_C@_08DIMCPJMD@XXXXXXX?6?$AA@			; `string'
PUBLIC	??_R4kdu_block_encoder_base@@6B@		; kdu_block_encoder_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_block_encoder_base@@@8		; kdu_block_encoder_base `RTTI Type Descriptor'
PUBLIC	??_R3kdu_block_encoder_base@@8			; kdu_block_encoder_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_block_encoder_base@@8			; kdu_block_encoder_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_block_encoder_base@@8		; kdu_block_encoder_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_block_encoder@@6B@			; kd_block_encoder::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_block_encoder@@@8			; kd_block_encoder `RTTI Type Descriptor'
PUBLIC	??_R3kd_block_encoder@@8			; kd_block_encoder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_block_encoder@@8			; kd_block_encoder::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_block_encoder@@8		; kd_block_encoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3ef0000000000000
PUBLIC	__real@3f70000000000000
PUBLIC	__real@3fa0000000000000
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fd1e4d5d80e496f
PUBLIC	__real@3fd3dc93ea2d2fe4
PUBLIC	__real@3fd9ae642bf9830e
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4040000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@4070000000000000
PUBLIC	__real@40efffe000000000
PUBLIC	__real@40f0000000000000
PUBLIC	__real@bff0000000000000
PUBLIC	__real@c08f400000000000
PUBLIC	__xmm@00000003000000020000000100000000
PUBLIC	__xmm@00000020000000200000002000000020
PUBLIC	__xmm@3fa00000000000003fa0000000000000
PUBLIC	__xmm@3fe00000000000003fe0000000000000
PUBLIC	__xmm@3ff80000000000003ff8000000000000
PUBLIC	__xmm@40f000000000000040f0000000000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__clock:PROC
EXTRN	?set_max_passes@kdu_block@@QAEXH_N@Z:PROC	; kdu_block::set_max_passes
EXTRN	?set_max_bytes@kdu_block@@QAEXH_N@Z:PROC	; kdu_block::set_max_bytes
EXTRN	?set_max_contexts@kdu_block@@QAEXH@Z:PROC	; kdu_block::set_max_contexts
EXTRN	??_Ekdu_block_encoder_base@@MAEPAXI@Z:PROC	; kdu_block_encoder_base::`vector deleting destructor'
EXTRN	?start@mq_encoder@@QAEXPAE_N@Z:PROC		; mq_encoder::start
EXTRN	?terminate@mq_encoder@@QAEPAE_N@Z:PROC		; mq_encoder::terminate
EXTRN	?mq_encode_run@mq_encoder@@QAEXH@Z:PROC		; mq_encoder::mq_encode_run
EXTRN	?find_truncation_point@mq_encoder@@AAEXPAE@Z:PROC ; mq_encoder::find_truncation_point
EXTRN	??_Ekd_block_encoder@@UAEPAXI@Z:PROC		; kd_block_encoder::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___vdecl_floor2:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__libm_sse2_exp_precise:PROC
EXTRN	__libm_sse2_log_precise:PROC
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	_floor:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?hl_sig_lut@@3PAEA:BYTE				; hl_sig_lut
EXTRN	?lh_sig_lut@@3PAEA:BYTE				; lh_sig_lut
EXTRN	?hh_sig_lut@@3PAEA:BYTE				; hh_sig_lut
EXTRN	?sign_lut@@3PAEA:BYTE				; sign_lut
EXTRN	?p_bar_table@mq_encoder@@2PAHA:BYTE		; mq_encoder::p_bar_table
EXTRN	?transition_table@mq_encoder@@2PAUmqe_transition@@A:BYTE ; mq_encoder::transition_table
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?significance_distortion_lut@@3PAHA DD 020H DUP (?)	; significance_distortion_lut
?significance_distortion_lut_lossless@@3PAHA DD 020H DUP (?) ; significance_distortion_lut_lossless
?refinement_distortion_lut@@3PAHA DD 040H DUP (?)	; refinement_distortion_lut
?refinement_distortion_lut_lossless@@3PAHA DD 040H DUP (?) ; refinement_distortion_lut_lossless
?_do_it@@3Vencoder_local_init@@A DB 01H DUP (?)		; _do_it
_BSS	ENDS
CRT$XCU	SEGMENT
?_do_it$initializer$@@3P6AXXZA DD FLAT:??__E_do_it@@YAXXZ ; _do_it$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@40f000000000000040f0000000000000
CONST	SEGMENT
__xmm@40f000000000000040f0000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 0f0H
	DB	'@', 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, '@'
CONST	ENDS
;	COMDAT __xmm@3ff80000000000003ff8000000000000
CONST	SEGMENT
__xmm@3ff80000000000003ff8000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 0f8H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 0f8H, '?'
CONST	ENDS
;	COMDAT __xmm@3fe00000000000003fe0000000000000
CONST	SEGMENT
__xmm@3fe00000000000003fe0000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 0e0H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 0e0H, '?'
CONST	ENDS
;	COMDAT __xmm@3fa00000000000003fa0000000000000
CONST	SEGMENT
__xmm@3fa00000000000003fa0000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 0a0H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 0a0H, '?'
CONST	ENDS
;	COMDAT __xmm@00000020000000200000002000000020
CONST	SEGMENT
__xmm@00000020000000200000002000000020 DB ' ', 00H, 00H, 00H, ' ', 00H, 00H
	DB	00H, ' ', 00H, 00H, 00H, ' ', 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000003000000020000000100000000
CONST	SEGMENT
__xmm@00000003000000020000000100000000 DB 00H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 02H, 00H, 00H, 00H, 03H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@c08f400000000000
CONST	SEGMENT
__real@c08f400000000000 DQ 0c08f400000000000r	; -1000
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@40f0000000000000
CONST	SEGMENT
__real@40f0000000000000 DQ 040f0000000000000r	; 65536
CONST	ENDS
;	COMDAT __real@40efffe000000000
CONST	SEGMENT
__real@40efffe000000000 DQ 040efffe000000000r	; 65535
CONST	ENDS
;	COMDAT __real@4070000000000000
CONST	SEGMENT
__real@4070000000000000 DQ 04070000000000000r	; 256
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4040000000000000
CONST	SEGMENT
__real@4040000000000000 DQ 04040000000000000r	; 32
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fd9ae642bf9830e
CONST	SEGMENT
__real@3fd9ae642bf9830e DQ 03fd9ae642bf9830er	; 0.401269
CONST	ENDS
;	COMDAT __real@3fd3dc93ea2d2fe4
CONST	SEGMENT
__real@3fd3dc93ea2d2fe4 DQ 03fd3dc93ea2d2fe4r	; 0.310338
CONST	ENDS
;	COMDAT __real@3fd1e4d5d80e496f
CONST	SEGMENT
__real@3fd1e4d5d80e496f DQ 03fd1e4d5d80e496fr	; 0.279592
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3fa0000000000000
CONST	SEGMENT
__real@3fa0000000000000 DQ 03fa0000000000000r	; 0.03125
CONST	ENDS
;	COMDAT __real@3f70000000000000
CONST	SEGMENT
__real@3f70000000000000 DQ 03f70000000000000r	; 0.00390625
CONST	ENDS
;	COMDAT __real@3ef0000000000000
CONST	SEGMENT
__real@3ef0000000000000 DQ 03ef0000000000000r	; 1.52588e-05
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_block_encoder@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_block_encoder@@8 DD FLAT:??_R0?AVkd_block_encoder@@@8 ; kd_block_encoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_block_encoder@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_block_encoder@@8
rdata$r	SEGMENT
??_R2kd_block_encoder@@8 DD FLAT:??_R1A@?0A@EA@kd_block_encoder@@8 ; kd_block_encoder::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_block_encoder_base@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_block_encoder@@8
rdata$r	SEGMENT
??_R3kd_block_encoder@@8 DD 00H				; kd_block_encoder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_block_encoder@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_block_encoder@@@8
data$r	SEGMENT
??_R0?AVkd_block_encoder@@@8 DD FLAT:??_7type_info@@6B@	; kd_block_encoder `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_block_encoder@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_block_encoder@@6B@
rdata$r	SEGMENT
??_R4kd_block_encoder@@6B@ DD 00H			; kd_block_encoder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_block_encoder@@@8
	DD	FLAT:??_R3kd_block_encoder@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_block_encoder_base@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_block_encoder_base@@8 DD FLAT:??_R0?AVkdu_block_encoder_base@@@8 ; kdu_block_encoder_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_block_encoder_base@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_block_encoder_base@@8
rdata$r	SEGMENT
??_R2kdu_block_encoder_base@@8 DD FLAT:??_R1A@?0A@EA@kdu_block_encoder_base@@8 ; kdu_block_encoder_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_block_encoder_base@@8
rdata$r	SEGMENT
??_R3kdu_block_encoder_base@@8 DD 00H			; kdu_block_encoder_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_block_encoder_base@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_block_encoder_base@@@8
data$r	SEGMENT
??_R0?AVkdu_block_encoder_base@@@8 DD FLAT:??_7type_info@@6B@ ; kdu_block_encoder_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_block_encoder_base@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_block_encoder_base@@6B@
rdata$r	SEGMENT
??_R4kdu_block_encoder_base@@6B@ DD 00H			; kdu_block_encoder_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_block_encoder_base@@@8
	DD	FLAT:??_R3kdu_block_encoder_base@@8
rdata$r	ENDS
;	COMDAT ??_C@_08DIMCPJMD@XXXXXXX?6?$AA@
CONST	SEGMENT
??_C@_08DIMCPJMD@XXXXXXX?6?$AA@ DB 'XXXXXXX', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_7kd_block_encoder@@6B@
CONST	SEGMENT
??_7kd_block_encoder@@6B@ DD FLAT:??_R4kd_block_encoder@@6B@ ; kd_block_encoder::`vftable'
	DD	FLAT:??_Ekd_block_encoder@@UAEPAXI@Z
	DD	FLAT:?encode@kd_block_encoder@@MAEXPAUkdu_block@@_NNG@Z
CONST	ENDS
_DATA	SEGMENT
?significance_luts@@3PAPAEA DD FLAT:?lh_sig_lut@@3PAEA	; significance_luts
	DD	FLAT:?hl_sig_lut@@3PAEA
	DD	FLAT:?lh_sig_lut@@3PAEA
	DD	FLAT:?hh_sig_lut@@3PAEA
_DATA	ENDS
;	COMDAT ??_7kdu_block_encoder_base@@6B@
CONST	SEGMENT
??_7kdu_block_encoder_base@@6B@ DD FLAT:??_R4kdu_block_encoder_base@@6B@ ; kdu_block_encoder_base::`vftable'
	DD	FLAT:??_Ekdu_block_encoder_base@@MAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?find_convex_hull@@YAXQAHQANQAGH@Z
_TEXT	SEGMENT
_log_scale$1$ = -16					; size = 8
_log_slope$1$ = -8					; size = 8
_pass_lengths$ = 8					; size = 4
_pass_wmse_changes$ = 12				; size = 4
_pass_slopes$ = 16					; size = 4
_num_passes$ = 20					; size = 4
?find_convex_hull@@YAXQAHQANQAGH@Z PROC			; find_convex_hull, COMDAT

; 1207 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi

; 1208 :   int z;
; 1209 : 
; 1210 :   for (z=0; z < num_passes; z++)

	mov	edi, DWORD PTR _num_passes$[ebp]
	xor	esi, esi
	test	edi, edi
	jle	$LN9@find_conve
	mov	ebx, DWORD PTR _pass_wmse_changes$[ebp]
	xorps	xmm4, xmm4
	movsd	xmm5, QWORD PTR __real@4000000000000000
	npad	12
$LL4@find_conve:

; 1211 :     { /* Find the value, lambda(z), defined in equation (8.4) of the book by
; 1212 :          Taubman and Marcellin.  Every coding pass which contributes to the
; 1213 :          convex hull set has this value for its distortion-length slope;
; 1214 :          however, not all coding passes which have a positive lambda(z) value
; 1215 :          actually contribute to the convex hull.  The points which do not
; 1216 :          contribute are weeded out next. */
; 1217 :       double lambda_z = -1.0; // Marks initial condition.

	movsd	xmm1, QWORD PTR __real@bff0000000000000

; 1218 :       double delta_L = 0.0, delta_D = 0.0;

	movaps	xmm2, xmm4
	movsd	QWORD PTR _log_slope$1$[ebp], xmm1
	movaps	xmm3, xmm4

; 1219 :       int t, min_t=(z>9)?(z-9):0;

	cmp	esi, 9
	jle	SHORT $LN22@find_conve
	lea	ecx, DWORD PTR [esi-9]
	jmp	SHORT $LN23@find_conve
$LN22@find_conve:
	xor	ecx, ecx
$LN23@find_conve:

; 1220 :       for (t=z; t >= min_t; t--)

	mov	eax, esi
	cmp	esi, ecx
	jl	$LN50@find_conve
	mov	edx, DWORD PTR _pass_lengths$[ebp]
	npad	4
$LL7@find_conve:
	movd	xmm0, DWORD PTR [edx+eax*4]

; 1221 :         {
; 1222 :           delta_L += (double) pass_lengths[t];
; 1223 :           delta_D += pass_wmse_changes[t];

	addsd	xmm3, QWORD PTR [ebx+eax*8]
	cvtdq2pd xmm0, xmm0

; 1224 :           if (delta_D <= 0.0)

	comisd	xmm4, xmm3
	addsd	xmm2, xmm0
	jae	$LN50@find_conve

; 1225 :             { // This pass cannot contribute to convex hull
; 1226 :               lambda_z = -1.0; break;
; 1227 :             }
; 1228 :           else if ((delta_L > 0.0) &&

	comisd	xmm2, xmm4
	jbe	SHORT $LN5@find_conve
	comisd	xmm4, xmm1
	ja	SHORT $LN17@find_conve
	movaps	xmm0, xmm2
	mulsd	xmm0, xmm1
	comisd	xmm0, xmm3
	jbe	SHORT $LN5@find_conve
$LN17@find_conve:

; 1229 :                    ((lambda_z < 0.0) || ((delta_L*lambda_z) > delta_D)))
; 1230 :             lambda_z = delta_D / delta_L;

	movaps	xmm1, xmm3
	divsd	xmm1, xmm2
	movsd	QWORD PTR _log_slope$1$[ebp], xmm1
$LN5@find_conve:

; 1220 :       for (t=z; t >= min_t; t--)

	dec	eax
	cmp	eax, ecx
	jge	SHORT $LL7@find_conve

; 1231 :         }
; 1232 :       if (lambda_z <= 0.0)

	comisd	xmm4, xmm1
	jae	$LN50@find_conve

; 1174 :   double log_scale = 256.0 / log(2.0); // Convert log values to 8.8 fixed point

	movaps	xmm0, xmm5
	call	__libm_sse2_log_precise
	movsd	xmm1, QWORD PTR __real@4070000000000000
	divsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	QWORD PTR _log_scale$1$[ebp], xmm1
	movsd	xmm1, QWORD PTR __real@4040000000000000
	call	__libm_sse2_pow_precise

; 1175 :   double log_slope = lambda / max_slope;

	movsd	xmm1, QWORD PTR _log_slope$1$[ebp]
	divsd	xmm1, xmm0

; 1176 :   log_slope = (log_slope > 1.0)?1.0:log_slope;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN30@find_conve
	movaps	xmm1, xmm0
$LN30@find_conve:

; 1177 :   log_slope = (log(log_slope) * log_scale) + (double)(1<<16);

	movaps	xmm0, xmm1
	call	__libm_sse2_log_precise
	mulsd	xmm0, QWORD PTR _log_scale$1$[ebp]

; 1178 :   if (log_slope > (double) 0xFFFF)
; 1179 :     return 0xFFFF;

	movsd	xmm5, QWORD PTR __real@4000000000000000
	addsd	xmm0, QWORD PTR __real@40f0000000000000
	comisd	xmm0, QWORD PTR __real@40efffe000000000
	jbe	SHORT $LN25@find_conve

; 1234 :       else
; 1235 :         pass_slopes[z] = slope_to_log(lambda_z);

	mov	ecx, DWORD PTR _pass_slopes$[ebp]

; 1178 :   if (log_slope > (double) 0xFFFF)
; 1179 :     return 0xFFFF;

	mov	eax, 65535				; 0000ffffH
	xorps	xmm4, xmm4

; 1234 :       else
; 1235 :         pass_slopes[z] = slope_to_log(lambda_z);

	mov	WORD PTR [ecx+esi*2], ax
	jmp	SHORT $LN2@find_conve
$LN25@find_conve:

; 1180 :   else if (log_slope < 2.0)

	comisd	xmm5, xmm0
	jbe	SHORT $LN27@find_conve

; 1234 :       else
; 1235 :         pass_slopes[z] = slope_to_log(lambda_z);

	mov	ecx, DWORD PTR _pass_slopes$[ebp]

; 1181 :     return 2;

	mov	eax, 2
	xorps	xmm4, xmm4

; 1234 :       else
; 1235 :         pass_slopes[z] = slope_to_log(lambda_z);

	mov	WORD PTR [ecx+esi*2], ax
	jmp	SHORT $LN2@find_conve
$LN27@find_conve:
	mov	ecx, DWORD PTR _pass_slopes$[ebp]
	xorps	xmm4, xmm4

; 1182 :   else
; 1183 :     return (kdu_uint16) log_slope;

	cvttsd2si eax, xmm0
	movzx	eax, ax

; 1234 :       else
; 1235 :         pass_slopes[z] = slope_to_log(lambda_z);

	mov	WORD PTR [ecx+esi*2], ax
	jmp	SHORT $LN2@find_conve
$LN50@find_conve:

; 1233 :         pass_slopes[z] = 0;

	mov	eax, DWORD PTR _pass_slopes$[ebp]
	xor	ecx, ecx
	mov	WORD PTR [eax+esi*2], cx
$LN2@find_conve:

; 1208 :   int z;
; 1209 : 
; 1210 :   for (z=0; z < num_passes; z++)

	inc	esi
	cmp	esi, edi
	jl	$LL4@find_conve

; 1236 :     }
; 1237 : 
; 1238 :   /* Now weed out the non-contributing passes. */
; 1239 :   for (z=0; z < num_passes; z++)

	test	edi, edi
	jle	SHORT $LN9@find_conve
	mov	esi, DWORD PTR _pass_slopes$[ebp]
	mov	edx, 1
	mov	ebx, edi
	npad	6
$LL10@find_conve:

; 1240 :     {
; 1241 :       for (int t=z+1; t < num_passes; t++)

	mov	eax, edx
	cmp	edx, edi
	jge	SHORT $LN8@find_conve

; 1242 :         if (pass_slopes[t] >= pass_slopes[z])

	movzx	ecx, WORD PTR [esi]
	npad	7
$LL13@find_conve:
	mov	edi, DWORD PTR _pass_slopes$[ebp]
	cmp	WORD PTR [edi+eax*2], cx
	mov	edi, DWORD PTR _num_passes$[ebp]
	jae	SHORT $LN37@find_conve

; 1240 :     {
; 1241 :       for (int t=z+1; t < num_passes; t++)

	inc	eax
	cmp	eax, edi
	jl	SHORT $LL13@find_conve

; 1242 :         if (pass_slopes[t] >= pass_slopes[z])

	jmp	SHORT $LN8@find_conve
$LN37@find_conve:

; 1243 :           { pass_slopes[z] = 0; break; }

	xor	eax, eax
	mov	WORD PTR [esi], ax
$LN8@find_conve:

; 1236 :     }
; 1237 : 
; 1238 :   /* Now weed out the non-contributing passes. */
; 1239 :   for (z=0; z < num_passes; z++)

	inc	edx
	add	esi, 2
	sub	ebx, 1
	jne	SHORT $LL10@find_conve
$LN9@find_conve:
	pop	edi
	pop	esi
	pop	ebx

; 1244 :     }
; 1245 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?find_convex_hull@@YAXQAHQANQAGH@Z ENDP			; find_convex_hull
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?slope_from_log@@YANG@Z
_TEXT	SEGMENT
tv136 = -8						; size = 8
tv130 = -8						; size = 8
_slope$ = 8						; size = 2
?slope_from_log@@YANG@Z PROC				; slope_from_log, COMDAT

; 1192 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1193 :   double max_slope = pow(2.0,32.0);
; 1194 :   double log_scale = log(2.0) / 256.0;

	movsd	xmm0, QWORD PTR __real@4000000000000000
	call	__libm_sse2_log_precise

; 1195 :   double log_slope = ((double) slope) - ((double)(1<<16));
; 1196 :   log_slope *= log_scale;
; 1197 :   return exp(log_slope) * max_slope;

	movzx	eax, WORD PTR _slope$[ebp]
	mulsd	xmm0, QWORD PTR __real@3f70000000000000
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	subsd	xmm1, QWORD PTR __real@40f0000000000000
	mulsd	xmm0, xmm1
	call	__libm_sse2_exp_precise
	movsd	xmm1, QWORD PTR __real@4040000000000000
	movsd	QWORD PTR tv130[ebp], xmm0
	movsd	xmm0, QWORD PTR __real@4000000000000000
	call	__libm_sse2_pow_precise
	movsd	xmm1, QWORD PTR tv130[ebp]
	mulsd	xmm1, xmm0
	movsd	QWORD PTR tv136[ebp], xmm1
	fld	QWORD PTR tv136[ebp]

; 1198 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?slope_from_log@@YANG@Z ENDP				; slope_from_log
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?slope_to_log@@YAGN@Z
_TEXT	SEGMENT
_log_scale$1$ = -8					; size = 8
_lambda$ = 8						; size = 8
?slope_to_log@@YAGN@Z PROC				; slope_to_log, COMDAT

; 1172 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1173 :   double max_slope = pow(2.0,32.0); // Maximum slope we can reprsent
; 1174 :   double log_scale = 256.0 / log(2.0); // Convert log values to 8.8 fixed point

	movsd	xmm0, QWORD PTR __real@4000000000000000
	call	__libm_sse2_log_precise
	movsd	xmm1, QWORD PTR __real@4070000000000000
	divsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	QWORD PTR _log_scale$1$[ebp], xmm1
	movsd	xmm1, QWORD PTR __real@4040000000000000
	call	__libm_sse2_pow_precise

; 1175 :   double log_slope = lambda / max_slope;

	movsd	xmm1, QWORD PTR _lambda$[ebp]
	divsd	xmm1, xmm0

; 1176 :   log_slope = (log_slope > 1.0)?1.0:log_slope;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN7@slope_to_l
	movaps	xmm1, xmm0
$LN7@slope_to_l:

; 1177 :   log_slope = (log(log_slope) * log_scale) + (double)(1<<16);

	movaps	xmm0, xmm1
	call	__libm_sse2_log_precise
	mulsd	xmm0, QWORD PTR _log_scale$1$[ebp]
	addsd	xmm0, QWORD PTR __real@40f0000000000000

; 1178 :   if (log_slope > (double) 0xFFFF)

	comisd	xmm0, QWORD PTR __real@40efffe000000000
	jbe	SHORT $LN2@slope_to_l

; 1179 :     return 0xFFFF;

	mov	eax, 65535				; 0000ffffH

; 1184 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@slope_to_l:

; 1180 :   else if (log_slope < 2.0)

	movsd	xmm1, QWORD PTR __real@4000000000000000

; 1181 :     return 2;

	mov	eax, 2
	comisd	xmm1, xmm0
	ja	SHORT $LN5@slope_to_l

; 1182 :   else
; 1183 :     return (kdu_uint16) log_slope;

	cvttsd2si eax, xmm0
$LN5@slope_to_l:

; 1184 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?slope_to_log@@YAGN@Z ENDP				; slope_to_log
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?encode_cleanup_pass@@YAHAAVmq_encoder@@QAUmqe_state@@H_NHPAH33HHH2@Z
_TEXT	SEGMENT
_c$1$ = -44						; size = 4
_distortion_lut$1$ = -44				; size = 4
_distortion_lut$2$ = -40				; size = 4
_val$11$ = -36						; size = 4
_sym$13$ = -36						; size = 4
_sym$12$ = -36						; size = 4
_sym$10$ = -36						; size = 4
_sym$7$ = -36						; size = 4
_sym$4$ = -36						; size = 4
_sym$1$ = -36						; size = 4
tv1451 = -36						; size = 4
tv1450 = -36						; size = 4
tv1446 = -36						; size = 4
tv1445 = -36						; size = 4
tv1444 = -36						; size = 4
tv1441 = -36						; size = 4
tv1439 = -36						; size = 4
tv1438 = -36						; size = 4
tv1437 = -36						; size = 4
tv1436 = -36						; size = 4
tv1435 = -36						; size = 4
tv1434 = -36						; size = 4
tv1433 = -36						; size = 4
tv1432 = -36						; size = 4
tv1431 = -36						; size = 4
tv1430 = -36						; size = 4
_sig_lut$1$ = -32					; size = 4
_state_ref$6$ = -28					; size = 4
_state_ref$4$ = -28					; size = 4
_state_ref$2$ = -28					; size = 4
_val$13$ = -28						; size = 4
_val$10$ = -28						; size = 4
_val$7$ = -28						; size = 4
_val$4$ = -28						; size = 4
tv1449 = -28						; size = 4
tv1447 = -28						; size = 4
_A$1$ = -28						; size = 4
_state_ref$9$ = -24					; size = 4
_state_ref$8$ = -24					; size = 4
_state_ref$7$ = -24					; size = 4
_state_ref$5$ = -24					; size = 4
_state_ref$3$ = -24					; size = 4
_val$8$ = -24						; size = 4
_val$5$ = -24						; size = 4
_val$2$ = -24						; size = 4
_width_by2$1$ = -20					; size = 4
tv1473 = -16						; size = 4
_shift$1$ = -12						; size = 4
_store$1$ = -8						; size = 4
_t$1$ = -4						; size = 4
_coder$ = 8						; size = 4
_states$ = 12						; size = 4
_p$ = 16						; size = 4
_causal$ = 20						; size = 1
_distortion_change$1$ = 24				; size = 4
_orientation$ = 24					; size = 4
_samples$ = 28						; size = 4
_dec_samples$ = 32					; size = 4
_contexts$ = 36						; size = 4
_width$ = 40						; size = 4
_num_stripes$ = 44					; size = 4
_context_row_gap$ = 48					; size = 4
_cword$1$ = 52						; size = 4
_val$1$ = 52						; size = 4
_lossless_pass$ = 52					; size = 1
?encode_cleanup_pass@@YAHAAVmq_encoder@@QAUmqe_state@@H_NHPAH33HHH2@Z PROC ; encode_cleanup_pass, COMDAT

; 894  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 895  : 	/* Ideally, register storage is available for 12 32-bit integers. Three
; 896  : 	are declared inside the "_mq_check_out_" macro.  The order of priority
; 897  : 	for these registers corresponds roughly to the order in which their
; 898  : 	declarations appear below.  Unfortunately, none of these register
; 899  : 	requests are likely to be honored by the register-starved X86 family
; 900  : 	of processors, but the register declarations may prove useful to
; 901  : 	compilers for other architectures or for hand optimizations of
; 902  : 	assembly code. */
; 903  : 	register kdu_int32 *cp = contexts;
; 904  : 	register int c;
; 905  : 	register kdu_int32 cword;
; 906  : 	_mq_check_out_(coder); // Declares A, C, and t as registers.
; 907  : 	register kdu_int32 sym;
; 908  : 	register kdu_int32 val;
; 909  : 	register kdu_int32 *sp = samples;
; 910  : 	register kdu_int32 sign_sample = 0;
; 911  : 	//ohhan
; 912  : 	register kdu_int32 *dec_sp = dec_samples;
; 913  : 	register kdu_int32 kx, ky;
; 914  : 	register kdu_int32 shift = 31-p; assert(shift > 0);

	mov	ecx, 31					; 0000001fH

; 919  : 	kdu_int32 *distortion_lut = significance_distortion_lut;

	mov	DWORD PTR _distortion_lut$1$[ebp], OFFSET ?significance_distortion_lut@@3PAHA
	sub	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _shift$1$[ebp], ecx
	mov	ecx, DWORD PTR _orientation$[ebp]
	push	ebx
	push	esi
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 267  :         assert(active && (!checked_out) && MQ_segment); checked_out = true;

	mov	edi, DWORD PTR _coder$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 915  : 	register  kdu_byte *sig_lut = significance_luts[orientation];

	mov	ecx, DWORD PTR ?significance_luts@@3PAPAEA[ecx*4]
	mov	DWORD PTR _sig_lut$1$[ebp], ecx

; 917  : 	int r, width_by2=width+width, width_by3=width_by2+width;

	mov	ecx, DWORD PTR _width$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 269  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	edx, DWORD PTR [edi+8]
	mov	ebx, DWORD PTR [edi]
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR _t$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 917  : 	int r, width_by2=width+width, width_by3=width_by2+width;

	lea	edx, DWORD PTR [ecx+ecx]
	add	ecx, edx
	mov	DWORD PTR _width_by2$1$[ebp], edx

; 920  : 	if (lossless_pass)

	cmp	BYTE PTR _lossless_pass$[ebp], 0
	mov	edx, OFFSET ?significance_distortion_lut_lossless@@3PAHA
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 267  :         assert(active && (!checked_out) && MQ_segment); checked_out = true;

	mov	BYTE PTR [edi+25], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 920  : 	if (lossless_pass)

	cmove	edx, DWORD PTR _distortion_lut$1$[ebp]

; 921  : 		distortion_lut = significance_distortion_lut_lossless;
; 922  : 
; 923  : 	kx = 0;
; 924  : 	ky = 0;
; 925  : 
; 926  : 	assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 927  : 	for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3, dec_sp += width_by3, kx += 4, ky = 0)

	cmp	DWORD PTR _num_stripes$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 269  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	edi, DWORD PTR [edi+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 920  : 	if (lossless_pass)

	mov	DWORD PTR _distortion_lut$2$[ebp], edx

; 921  : 		distortion_lut = significance_distortion_lut_lossless;
; 922  : 
; 923  : 	kx = 0;
; 924  : 	ky = 0;
; 925  : 
; 926  : 	assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 927  : 	for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3, dec_sp += width_by3, kx += 4, ky = 0)

	mov	edx, DWORD PTR _t$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 269  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	DWORD PTR _store$1$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 918  : 	kdu_int32 distortion_change = 0;

	mov	DWORD PTR _distortion_change$1$[ebp], 0

; 921  : 		distortion_lut = significance_distortion_lut_lossless;
; 922  : 
; 923  : 	kx = 0;
; 924  : 	ky = 0;
; 925  : 
; 926  : 	assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 927  : 	for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3, dec_sp += width_by3, kx += 4, ky = 0)

	jle	$LN3@encode_cle
	mov	edx, DWORD PTR _samples$[ebp]
	shl	ecx, 2
	mov	DWORD PTR tv1473[ebp], ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	npad	2
$LL4@encode_cle:

; 928  : 		for (c=width; c > 0; c--, sp++, dec_sp++, cp++, ky++)

	mov	edi, DWORD PTR _width$[ebp]
	test	edi, edi
	mov	DWORD PTR _c$1$[ebp], edi
	mov	edi, DWORD PTR _store$1$[ebp]
	jle	$LN2@encode_cle
$LL7@encode_cle:

; 929  : 		{
; 930  : 			if (*cp == 0)

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	jne	$LN17@encode_cle

; 931  : 			{ // Enter the run mode
; 932  : 				sym = 0; val = -1;

	mov	DWORD PTR _sym$1$[ebp], edx
	or	ecx, -1

; 933  : 				if ((sp[0] << shift) < 0)

	mov	edx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _val$1$[ebp], ecx
	mov	ecx, DWORD PTR _shift$1$[ebp]
	mov	edx, DWORD PTR [edx]
	shl	edx, cl
	test	edx, edx
	jns	SHORT $LN45@encode_cle

; 934  : 				{ val = 0; sym = KDU_INT32_MIN; }

	xor	ecx, ecx
	mov	DWORD PTR _val$1$[ebp], ecx
	mov	ecx, -2147483648			; 80000000H
	jmp	SHORT $LN51@encode_cle
$LN45@encode_cle:

; 935  : 				else if ((sp[width] << shift) < 0)

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	edx, DWORD PTR _width$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	edx, cl
	test	edx, edx
	jns	SHORT $LN47@encode_cle

; 936  : 				{ val = 1; sym = KDU_INT32_MIN; }

	mov	DWORD PTR _val$1$[ebp], 1
	mov	ecx, -2147483648			; 80000000H
	jmp	SHORT $LN51@encode_cle
$LN47@encode_cle:

; 937  : 				else if ((sp[width_by2] << shift) < 0)

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	edx, DWORD PTR _width_by2$1$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	edx, cl
	test	edx, edx
	jns	SHORT $LN49@encode_cle

; 938  : 				{ val = 2; sym = KDU_INT32_MIN; }

	mov	DWORD PTR _val$1$[ebp], 2
	mov	ecx, -2147483648			; 80000000H
	jmp	SHORT $LN51@encode_cle
$LN49@encode_cle:

; 939  : 				else if ((sp[width_by3] << shift) < 0)

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	edx, DWORD PTR tv1473[ebp]
	mov	edx, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	edx, cl
	test	edx, edx
	jns	SHORT $LN330@encode_cle

; 940  : 				{ val = 3; sym = KDU_INT32_MIN; }

	mov	DWORD PTR _val$1$[ebp], 3
	mov	ecx, -2147483648			; 80000000H
	jmp	SHORT $LN51@encode_cle
$LN330@encode_cle:
	mov	ecx, DWORD PTR _sym$1$[ebp]
$LN51@encode_cle:

; 941  : 				state_ref = states + KAPPA_RUN_BASE;
; 942  : 				_mq_enc_(coder,sym,*state_ref);

	mov	edx, DWORD PTR _states$[ebp]
	xor	ecx, DWORD PTR [edx+72]
	sub	ebx, ecx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN52@encode_cle
	add	esi, ecx
	jmp	$LN9@encode_cle
$LN52@encode_cle:
	test	ecx, ecx
	js	SHORT $LN54@encode_cle
	cmp	ebx, ecx
	jge	SHORT $LN56@encode_cle
	mov	ebx, ecx
	jmp	SHORT $LN57@encode_cle
$LN56@encode_cle:
	add	esi, ecx
$LN57@encode_cle:
	mov	edx, DWORD PTR [edx+76]
	mov	DWORD PTR tv1430[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _states$[ebp]
	mov	DWORD PTR [edx+72], ecx
	mov	edx, DWORD PTR tv1430[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN337@encode_cle
$LN54@encode_cle:
	and	ebx, 2147483647				; 7fffffffH
	and	ecx, 2147483647				; 7fffffffH
	cmp	ebx, ecx
	jge	SHORT $LN58@encode_cle
	add	esi, ecx
	jmp	SHORT $LN59@encode_cle
$LN58@encode_cle:
	mov	ebx, ecx
$LN59@encode_cle:
	mov	edx, DWORD PTR [edx+76]
	mov	DWORD PTR tv1431[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _states$[ebp]
	mov	DWORD PTR [edx+72], ecx
	mov	edx, DWORD PTR tv1431[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN337@encode_cle:
	mov	edx, DWORD PTR _states$[ebp]
	mov	DWORD PTR [edx+76], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL10@encode_cle:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN8@encode_cle
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN61@encode_cle
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN8@encode_cle
$LN61@encode_cle:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN8@encode_cle:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL10@encode_cle
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN9@encode_cle:

; 943  : 				if (val < 0)

	mov	edx, DWORD PTR _val$1$[ebp]
	test	edx, edx
	js	$LN5@encode_cle

; 944  : 					continue;
; 945  : 				_mq_enc_run_(coder,val);

	mov	ecx, edx
	sub	ebx, 22017				; 00005601H
	and	ecx, 2
	jne	SHORT $LN64@encode_cle
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN64@encode_cle
	add	esi, 22017				; 00005601H
	jmp	$LN12@encode_cle
$LN64@encode_cle:
	test	ecx, ecx
	jne	SHORT $LN66@encode_cle
	cmp	ebx, 22017				; 00005601H
	jl	SHORT $LN70@encode_cle
	add	esi, 22017				; 00005601H
	jmp	SHORT $LN320@encode_cle
$LN66@encode_cle:
	cmp	ebx, 22017				; 00005601H
	jge	SHORT $LN70@encode_cle
	add	esi, 22017				; 00005601H
	jmp	SHORT $LN320@encode_cle
$LN70@encode_cle:
	mov	ebx, 22017				; 00005601H
$LN320@encode_cle:
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL13@encode_cle:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN11@encode_cle
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN73@encode_cle
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN11@encode_cle
$LN73@encode_cle:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN11@encode_cle:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL13@encode_cle
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN12@encode_cle:
	sub	ebx, 22017				; 00005601H
	mov	ecx, edx
	mov	DWORD PTR _A$1$[ebp], ebx
	and	ecx, 1
	jne	SHORT $LN75@encode_cle
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN75@encode_cle
	add	esi, 22017				; 00005601H
	jmp	$LN15@encode_cle
$LN75@encode_cle:
	test	ecx, ecx
	jne	SHORT $LN77@encode_cle
	cmp	ebx, 22017				; 00005601H
	jl	SHORT $LN81@encode_cle
	add	esi, 22017				; 00005601H
	jmp	SHORT $LN321@encode_cle
$LN77@encode_cle:
	cmp	ebx, 22017				; 00005601H
	jge	SHORT $LN81@encode_cle
	add	esi, 22017				; 00005601H
	jmp	SHORT $LN321@encode_cle
$LN81@encode_cle:
	mov	ebx, 22017				; 00005601H
$LN321@encode_cle:
	mov	ecx, DWORD PTR _t$1$[ebp]
	npad	6
$LL16@encode_cle:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN14@encode_cle
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN84@encode_cle
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN14@encode_cle
$LN84@encode_cle:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN14@encode_cle:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL16@encode_cle
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _A$1$[ebp], ebx
	mov	DWORD PTR _store$1$[ebp], edi
$LN15@encode_cle:

; 946  : 				cword = *cp;

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _cword$1$[ebp], ecx

; 947  : 				switch (val) {

	cmp	edx, 3
	ja	SHORT $LN336@encode_cle
	jmp	DWORD PTR $LN348@encode_cle[edx*4]
$LN86@encode_cle:

; 948  : 			  case 0: val = sp[0]<<shift; goto row_0_significant;

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	edx, cl
	jmp	$row_0_significant$349
$LN88@encode_cle:

; 949  : 			  case 1: val = sp[width]<<shift; goto row_1_significant;

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	edx, DWORD PTR _width$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	edx, cl
	jmp	$row_1_significant$350
$LN90@encode_cle:

; 950  : 			  case 2: val = sp[width_by2]<<shift; goto row_2_significant;

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	edx, DWORD PTR _width_by2$1$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	edx, cl
	jmp	$row_2_significant$351
$LN92@encode_cle:

; 951  : 			  case 3: val = sp[width_by3]<<shift; goto row_3_significant;

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	edx, DWORD PTR tv1473[ebp]
	mov	edx, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	edx, cl
	jmp	$row_3_significant$352
$LN336@encode_cle:
	mov	edx, DWORD PTR _cword$1$[ebp]
$LN17@encode_cle:

; 952  : 				}
; 953  : 			}
; 954  : 
; 955  : 			//ohhan-Debug
; 956  : 			if (kx == 4 && ky == 4)
; 957  : 				kx +=0;
; 958  : 
; 959  : 			if (&(dec_sp[0]) != &(dec_samples[kx*64+ky]))
; 960  : 				kx += 0;
; 961  : 
; 962  : 			cword = *cp;

	mov	DWORD PTR _cword$1$[ebp], edx

; 963  : 			if (!(cword & (CLEANUP_MEMBER_MASK<<0)))

	test	edx, 3145744				; 00300010H
	jne	$row_1$353

; 964  : 			{ // Process first row of stripe column (row 0)
; 965  : 				state_ref = states+KAPPA_SIG_BASE+sig_lut[cword & NBRHD_MASK];

	mov	ecx, edx
	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	edx, DWORD PTR [edx+ecx*8]

; 966  : 				val = sp[0]<<shift;

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _state_ref$2$[ebp], edx
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _val$2$[ebp], ecx
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	DWORD PTR _val$2$[ebp], cl

; 967  : 				sym = val & KDU_INT32_MIN;

	mov	ecx, DWORD PTR _val$2$[ebp]
	and	ecx, -2147483648			; 80000000H

; 968  : 				_mq_enc_(coder,sym,*state_ref);

	xor	ecx, DWORD PTR [edx]
	sub	ebx, ecx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN97@encode_cle
	add	esi, ecx
	jmp	$LN20@encode_cle
$LN97@encode_cle:
	test	ecx, ecx
	js	SHORT $LN99@encode_cle
	cmp	ebx, ecx
	jge	SHORT $LN101@encode_cle
	mov	ebx, ecx
	jmp	SHORT $LN102@encode_cle
$LN101@encode_cle:
	add	esi, ecx
$LN102@encode_cle:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1432[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1432[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN338@encode_cle
$LN99@encode_cle:
	and	ebx, 2147483647				; 7fffffffH
	and	ecx, 2147483647				; 7fffffffH
	cmp	ebx, ecx
	jge	SHORT $LN103@encode_cle
	add	esi, ecx
	jmp	SHORT $LN104@encode_cle
$LN103@encode_cle:
	mov	ebx, ecx
$LN104@encode_cle:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1433[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1433[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN338@encode_cle:
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL21@encode_cle:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN19@encode_cle
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN106@encode_cle
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN19@encode_cle
$LN106@encode_cle:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN19@encode_cle:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL21@encode_cle
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN20@encode_cle:

; 969  : 				if (val >= 0) // New magnitude bit was 0, so still insignificant

	mov	edx, DWORD PTR _val$2$[ebp]
	test	edx, edx
	jns	$LN334@encode_cle
$row_0_significant$349:

; 970  : 					goto row_1;
; 971  : row_0_significant:
; 972  : 				// Compute distortion change
; 973  : 				val =  (val>>(31-DISTORTION_LSBS)) & (SIGNIFICANCE_DISTORTIONS-1);
; 974  : 				distortion_change += distortion_lut[val];

	mov	edi, DWORD PTR _distortion_lut$2$[ebp]
	mov	ecx, DWORD PTR _distortion_change$1$[ebp]
	sar	edx, 26					; 0000001aH
	and	edx, 31					; 0000001fH
	add	ecx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR _distortion_change$1$[ebp], ecx

; 975  : 				//ohhan
; 976  : 				dec_sp[0] |= 1<<p;   //true coefficients

	mov	ecx, DWORD PTR _dec_samples$[ebp]

; 977  : 				dec_sp[0] |= 1<<(p-1); //mid-point reconstruction
; 978  : 				if (sign_sample = (sp[0]&(1<<31))) 

	mov	edi, DWORD PTR _store$1$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _p$[ebp]
	bts	edx, ecx
	dec	ecx
	bts	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [ecx]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN110@encode_cle

; 979  : 					dec_sp[0] |= sign_sample;  //sign bit 

	or	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ecx], edx
$LN110@encode_cle:

; 980  : 
; 981  : 				// Encode sign bit
; 982  : 				sym = cword & ((CHI_BIT>>3) | (SIGMA_CC_BIT>>3) |
; 983  : 					(CHI_BIT<<3) | (SIGMA_CC_BIT<<3));
; 984  : 				sym >>= 1; // Shift down so that top sigma bit has address 0
; 985  : 				sym |= (cp[-1] & ((CHI_BIT<<0) | (SIGMA_CC_BIT<<0))) >> (1+1);
; 986  : 				sym |= (cp[ 1] & ((CHI_BIT<<0) | (SIGMA_CC_BIT<<0))) >> (1-1);

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR _cword$1$[ebp]
	sar	edx, 1
	and	ecx, 17039490				; 01040082H
	and	edx, 1048584				; 00100008H
	or	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	sar	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 2097168				; 00200010H
	or	edx, ecx

; 987  : 				sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma

	mov	ecx, edx
	sar	ecx, 16					; 00000010H

; 988  : 				val = sign_lut[sym & 0x000000FF];

	or	ecx, edx
	movzx	ecx, cl
	movzx	edx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _sym$4$[ebp], edx

; 989  : 				state_ref = states + KAPPA_SIGN_BASE + (val>>1);

	mov	ecx, edx
	mov	edx, DWORD PTR _states$[ebp]
	add	edx, 80					; 00000050H
	sar	ecx, 1
	lea	ecx, DWORD PTR [edx+ecx*8]

; 990  : 				sym = val << 31; // Get sign flipping to `sym'

	mov	edx, DWORD PTR _sym$4$[ebp]
	shl	edx, 31					; 0000001fH
	mov	DWORD PTR _sym$4$[ebp], edx

; 991  : 				val = sp[0] & KDU_INT32_MIN; // Get the sign bit

	mov	edx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _state_ref$3$[ebp], ecx

; 992  : 				sym ^= val; // Moves flipped sign bit into `sym'
; 993  : 				_mq_enc_(coder,sym,*state_ref);

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx]
	and	edx, -2147483648			; 80000000H
	xor	ecx, edx
	mov	DWORD PTR _val$4$[ebp], edx
	mov	edx, DWORD PTR _sym$4$[ebp]
	xor	edx, ecx
	sub	ebx, edx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN111@encode_cle
	add	esi, edx
	jmp	$LN23@encode_cle
$LN111@encode_cle:
	test	edx, edx
	js	SHORT $LN113@encode_cle
	cmp	ebx, edx
	jge	SHORT $LN115@encode_cle
	mov	ebx, edx
	jmp	SHORT $LN116@encode_cle
$LN115@encode_cle:
	add	esi, edx
$LN116@encode_cle:
	mov	ecx, DWORD PTR _state_ref$3$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1434[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1434[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN339@encode_cle
$LN113@encode_cle:
	and	ebx, 2147483647				; 7fffffffH
	and	edx, 2147483647				; 7fffffffH
	cmp	ebx, edx
	jge	SHORT $LN117@encode_cle
	add	esi, edx
	jmp	SHORT $LN118@encode_cle
$LN117@encode_cle:
	mov	ebx, edx
$LN118@encode_cle:
	mov	ecx, DWORD PTR _state_ref$3$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1435[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1435[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN339@encode_cle:
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
	npad	1
$LL24@encode_cle:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN22@encode_cle
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN120@encode_cle
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN22@encode_cle
$LN120@encode_cle:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN22@encode_cle:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL24@encode_cle
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN23@encode_cle:

; 994  : 				// Broadcast neighbourhood context changes; sign bit is in `val'
; 995  : 				cp[-1] |= (SIGMA_CR_BIT<<0);

	mov	ecx, DWORD PTR _contexts$[ebp]

; 996  : 				cp[1]  |= (SIGMA_CL_BIT<<0);
; 997  : 				if (val < 0)
; 998  : 				{
; 999  : 					cword |= (SIGMA_CC_BIT<<0) | (CHI_BIT<<0);

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	DWORD PTR [ecx-4], 32			; 00000020H
	or	DWORD PTR [ecx+4], 8
	cmp	DWORD PTR _val$4$[ebp], 0
	jge	SHORT $LN122@encode_cle
	or	edx, 2097168				; 00200010H

; 1000 : 					if (!causal)

	cmp	BYTE PTR _causal$[ebp], 0
	mov	DWORD PTR _cword$1$[ebp], edx
	jne	SHORT $row_1$353

; 1001 : 					{
; 1002 : 						cp[-context_row_gap-1] |= (SIGMA_BR_BIT<<9);

	mov	ecx, DWORD PTR _context_row_gap$[ebp]
	mov	edx, DWORD PTR _contexts$[ebp]
	shl	ecx, 2
	sub	edx, ecx
	or	DWORD PTR [edx-4], 131072		; 00020000H

; 1003 : 						cp[-context_row_gap  ] |= (SIGMA_BC_BIT<<9) | NEXT_CHI_BIT;

	or	DWORD PTR [edx], -2147418112		; 80010000H

; 1004 : 						cp[-context_row_gap+1] |= (SIGMA_BL_BIT<<9);
; 1005 : 					}
; 1006 : 				}
; 1007 : 				else

	jmp	SHORT $LN346@encode_cle
$LN122@encode_cle:

; 1008 : 				{
; 1009 : 					cword |= (SIGMA_CC_BIT<<0);

	or	edx, 16					; 00000010H

; 1010 : 					if (!causal)

	cmp	BYTE PTR _causal$[ebp], 0
	mov	DWORD PTR _cword$1$[ebp], edx
	jne	SHORT $row_1$353

; 1011 : 					{
; 1012 : 						cp[-context_row_gap-1] |= (SIGMA_BR_BIT<<9);

	mov	ecx, DWORD PTR _context_row_gap$[ebp]
	mov	edx, DWORD PTR _contexts$[ebp]
	shl	ecx, 2
	sub	edx, ecx
	or	DWORD PTR [edx-4], 131072		; 00020000H

; 1013 : 						cp[-context_row_gap  ] |= (SIGMA_BC_BIT<<9);

	or	DWORD PTR [edx], 65536			; 00010000H
$LN346@encode_cle:

; 1014 : 						cp[-context_row_gap+1] |= (SIGMA_BL_BIT<<9);

	or	DWORD PTR [edx+4], 32768		; 00008000H
$LN334@encode_cle:
	mov	edx, DWORD PTR _cword$1$[ebp]
$row_1$353:

; 1015 : 					}
; 1016 : 				}
; 1017 : 			}
; 1018 : row_1:
; 1019 : 			if (!(cword & (CLEANUP_MEMBER_MASK<<3)))

	test	edx, 25165952				; 01800080H
	jne	$row_2$354

; 1020 : 			{ // Process second row of stripe column (row 1)
; 1021 : 				state_ref = states+KAPPA_SIG_BASE+sig_lut[(cword>>3) & NBRHD_MASK];
; 1022 : 				val = sp[width]<<shift;

	mov	edi, DWORD PTR _width$[ebp]
	mov	ecx, edx
	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	sar	ecx, 3
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _state_ref$4$[ebp], edx
	mov	ecx, DWORD PTR [ecx+edi*4]

; 1023 : 				sym = val & KDU_INT32_MIN;
; 1024 : 				_mq_enc_(coder,sym,*state_ref);

	mov	edi, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _val$5$[ebp], ecx
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	DWORD PTR _val$5$[ebp], cl
	mov	ecx, DWORD PTR _val$5$[ebp]
	and	ecx, -2147483648			; 80000000H
	xor	ecx, DWORD PTR [edx]
	sub	ebx, ecx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN127@encode_cle
	add	esi, ecx
	jmp	$LN26@encode_cle
$LN127@encode_cle:
	test	ecx, ecx
	js	SHORT $LN129@encode_cle
	cmp	ebx, ecx
	jge	SHORT $LN131@encode_cle
	mov	ebx, ecx
	jmp	SHORT $LN132@encode_cle
$LN131@encode_cle:
	add	esi, ecx
$LN132@encode_cle:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1436[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1436[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN340@encode_cle
$LN129@encode_cle:
	and	ebx, 2147483647				; 7fffffffH
	and	ecx, 2147483647				; 7fffffffH
	cmp	ebx, ecx
	jge	SHORT $LN133@encode_cle
	add	esi, ecx
	jmp	SHORT $LN134@encode_cle
$LN133@encode_cle:
	mov	ebx, ecx
$LN134@encode_cle:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1437[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1437[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN340@encode_cle:
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL27@encode_cle:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN25@encode_cle
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN136@encode_cle
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN25@encode_cle
$LN136@encode_cle:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN25@encode_cle:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL27@encode_cle
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN26@encode_cle:

; 1025 : 				if (val >= 0) // New magnitude bit was 0, so still insignificant

	mov	edx, DWORD PTR _val$5$[ebp]
	test	edx, edx
	jns	$LN333@encode_cle
$row_1_significant$350:

; 1026 : 					goto row_2;
; 1027 : row_1_significant:
; 1028 : 				// Compute distortion change
; 1029 : 				val =  (val>>(31-DISTORTION_LSBS)) & (SIGNIFICANCE_DISTORTIONS-1);
; 1030 : 				distortion_change += distortion_lut[val];

	mov	edi, DWORD PTR _distortion_lut$2$[ebp]
	mov	ecx, DWORD PTR _distortion_change$1$[ebp]
	sar	edx, 26					; 0000001aH
	and	edx, 31					; 0000001fH
	add	ecx, DWORD PTR [edi+edx*4]

; 1031 : 
; 1032 : 				//ohhan
; 1033 : 				dec_sp[width] |= 1<<p;   //true coefficients

	mov	edi, DWORD PTR _width$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR _p$[ebp]
	bts	edx, ecx

; 1034 : 				dec_sp[width] |= 1<<(p-1); //mid-point reconstruction

	dec	ecx
	bts	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ecx+edi*4], edx

; 1035 : 				if (sign_sample = (sp[width]&(1<<31))) 

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN140@encode_cle

; 1036 : 					dec_sp[width] |= sign_sample;  //sign bit 

	or	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ecx+edi*4], edx
$LN140@encode_cle:

; 1037 : 
; 1038 : 
; 1039 : 				// Encode sign bit
; 1040 : 				sym = cword & ((CHI_BIT<<0) | (SIGMA_CC_BIT<<0) |
; 1041 : 					(CHI_BIT<<6) | (SIGMA_CC_BIT<<6));
; 1042 : 				sym >>= 4; // Shift down so that top sigma bit has address 0
; 1043 : 				sym |= (cp[-1] & ((CHI_BIT<<3) | (SIGMA_CC_BIT<<3))) >> (4+1);
; 1044 : 				sym |= (cp[ 1] & ((CHI_BIT<<3) | (SIGMA_CC_BIT<<3))) >> (4-1);

	mov	ecx, DWORD PTR _contexts$[ebp]

; 1045 : 				sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma
; 1046 : 				val = sign_lut[sym & 0x000000FF];
; 1047 : 				state_ref = states + KAPPA_SIGN_BASE + (val>>1);
; 1048 : 				sym = val << 31; // Get sign flipping to `sym'
; 1049 : 				val = sp[width] & KDU_INT32_MIN; // Get the sign bit

	mov	edi, DWORD PTR _width$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR _cword$1$[ebp]
	sar	edx, 1
	and	ecx, 136315920				; 08200410H
	and	edx, 8388672				; 00800040H
	or	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	sar	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 16777344				; 01000080H
	or	edx, ecx
	sar	edx, 3
	mov	ecx, edx
	sar	ecx, 16					; 00000010H
	or	ecx, edx
	movzx	ecx, cl
	movzx	edx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _sym$7$[ebp], edx
	mov	ecx, edx
	mov	edx, DWORD PTR _states$[ebp]
	add	edx, 80					; 00000050H
	sar	ecx, 1
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _sym$7$[ebp]
	shl	edx, 31					; 0000001fH
	mov	DWORD PTR _sym$7$[ebp], edx
	mov	edx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _state_ref$5$[ebp], ecx

; 1050 : 				sym ^= val; // Moves flipped sign bit into `sym'
; 1051 : 				_mq_enc_(coder,sym,*state_ref);

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	edi, DWORD PTR _store$1$[ebp]
	and	edx, -2147483648			; 80000000H
	xor	ecx, edx
	mov	DWORD PTR _val$7$[ebp], edx
	mov	edx, DWORD PTR _sym$7$[ebp]
	xor	edx, ecx
	sub	ebx, edx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN141@encode_cle
	add	esi, edx
	jmp	$LN29@encode_cle
$LN141@encode_cle:
	test	edx, edx
	js	SHORT $LN143@encode_cle
	cmp	ebx, edx
	jge	SHORT $LN145@encode_cle
	mov	ebx, edx
	jmp	SHORT $LN146@encode_cle
$LN145@encode_cle:
	add	esi, edx
$LN146@encode_cle:
	mov	ecx, DWORD PTR _state_ref$5$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1438[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1438[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN341@encode_cle
$LN143@encode_cle:
	and	ebx, 2147483647				; 7fffffffH
	and	edx, 2147483647				; 7fffffffH
	cmp	ebx, edx
	jge	SHORT $LN147@encode_cle
	add	esi, edx
	jmp	SHORT $LN148@encode_cle
$LN147@encode_cle:
	mov	ebx, edx
$LN148@encode_cle:
	mov	ecx, DWORD PTR _state_ref$5$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1439[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1439[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN341@encode_cle:
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
	npad	3
$LL30@encode_cle:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN28@encode_cle
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN150@encode_cle
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN28@encode_cle
$LN150@encode_cle:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN28@encode_cle:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL30@encode_cle
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN29@encode_cle:

; 1052 : 				// Broadcast neighbourhood context changes; sign bit is in `val'
; 1053 : 				cp[-1] |= (SIGMA_CR_BIT<<3);

	mov	ecx, DWORD PTR _contexts$[ebp]

; 1054 : 				cp[1]  |= (SIGMA_CL_BIT<<3);
; 1055 : 				cword |= (SIGMA_CC_BIT<<3);
; 1056 : 				val = (kdu_int32)(((kdu_uint32) val)>>(31-(CHI_POS+3))); // SRL
; 1057 : 				cword |= val;

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	DWORD PTR [ecx-4], 256			; 00000100H
	or	DWORD PTR [ecx+4], 64			; 00000040H
	mov	ecx, DWORD PTR _val$7$[ebp]
	or	ecx, 16384				; 00004000H
	shr	ecx, 7
	or	edx, ecx
	mov	DWORD PTR _cword$1$[ebp], edx
	jmp	SHORT $row_2$354
$LN333@encode_cle:
	mov	edx, DWORD PTR _cword$1$[ebp]
$row_2$354:

; 1058 : 			}
; 1059 : row_2:
; 1060 : 			if (!(cword & (CLEANUP_MEMBER_MASK<<6)))

	test	edx, 201327616				; 0c000400H
	jne	$row_3$355

; 1061 : 			{ // Process third row of stripe column (row 2)
; 1062 : 				state_ref = states+KAPPA_SIG_BASE+sig_lut[(cword>>6) & NBRHD_MASK];
; 1063 : 				val = sp[width_by2]<<shift;

	mov	edi, DWORD PTR _width_by2$1$[ebp]
	mov	ecx, edx
	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	sar	ecx, 6
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _state_ref$6$[ebp], edx
	mov	ecx, DWORD PTR [ecx+edi*4]

; 1064 : 				sym = val & KDU_INT32_MIN;
; 1065 : 				_mq_enc_(coder,sym,*state_ref);

	mov	edi, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _val$8$[ebp], ecx
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	DWORD PTR _val$8$[ebp], cl
	mov	ecx, DWORD PTR _val$8$[ebp]
	and	ecx, -2147483648			; 80000000H
	xor	ecx, DWORD PTR [edx]
	sub	ebx, ecx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN153@encode_cle
	add	esi, ecx
	jmp	$LN32@encode_cle
$LN153@encode_cle:
	test	ecx, ecx
	js	SHORT $LN155@encode_cle
	cmp	ebx, ecx
	jge	SHORT $LN157@encode_cle
	mov	ebx, ecx
	jmp	SHORT $LN158@encode_cle
$LN157@encode_cle:
	add	esi, ecx
$LN158@encode_cle:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1441[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1441[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN342@encode_cle
$LN155@encode_cle:
	and	ebx, 2147483647				; 7fffffffH
	and	ecx, 2147483647				; 7fffffffH
	cmp	ebx, ecx
	jge	SHORT $LN159@encode_cle
	add	esi, ecx
	jmp	SHORT $LN160@encode_cle
$LN159@encode_cle:
	mov	ebx, ecx
$LN160@encode_cle:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1444[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1444[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN342@encode_cle:
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
	npad	1
$LL33@encode_cle:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN31@encode_cle
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN162@encode_cle
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN31@encode_cle
$LN162@encode_cle:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN31@encode_cle:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL33@encode_cle
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN32@encode_cle:

; 1066 : 				if (val >= 0) // New magnitude bit was 0, so still insignificant

	mov	edx, DWORD PTR _val$8$[ebp]
	test	edx, edx
	jns	$LN332@encode_cle
$row_2_significant$351:

; 1067 : 					goto row_3;
; 1068 : row_2_significant:
; 1069 : 				// Compute distortion change
; 1070 : 				val =  (val>>(31-DISTORTION_LSBS)) & (SIGNIFICANCE_DISTORTIONS-1);
; 1071 : 				distortion_change += distortion_lut[val];

	mov	edi, DWORD PTR _distortion_lut$2$[ebp]
	mov	ecx, DWORD PTR _distortion_change$1$[ebp]
	sar	edx, 26					; 0000001aH
	and	edx, 31					; 0000001fH
	add	ecx, DWORD PTR [edi+edx*4]

; 1072 : 
; 1073 : 				//ohhan
; 1074 : 				dec_sp[width_by2] |= 1<<p;   //true coefficients

	mov	edi, DWORD PTR _width_by2$1$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR _p$[ebp]
	bts	edx, ecx

; 1075 : 				dec_sp[width_by2] |= 1<<(p-1); //mid-point reconstruction

	dec	ecx
	bts	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ecx+edi*4], edx

; 1076 : 				if (sign_sample = (sp[width_by2]&(1<<31))) 

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN166@encode_cle

; 1077 : 					dec_sp[width_by2] |= sign_sample;  //sign bit 

	or	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ecx+edi*4], edx
$LN166@encode_cle:

; 1078 : 
; 1079 : 
; 1080 : 				// Encode sign bit
; 1081 : 				sym = cword & ((CHI_BIT<<3) | (SIGMA_CC_BIT<<3) |
; 1082 : 					(CHI_BIT<<9) | (SIGMA_CC_BIT<<9));
; 1083 : 				sym >>= 7; // Shift down so that top sigma bit has address 0
; 1084 : 				sym |= (cp[-1] & ((CHI_BIT<<6) | (SIGMA_CC_BIT<<6))) >> (7+1);
; 1085 : 				sym |= (cp[ 1] & ((CHI_BIT<<6) | (SIGMA_CC_BIT<<6))) >> (7-1);

	mov	ecx, DWORD PTR _contexts$[ebp]

; 1086 : 				sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma
; 1087 : 				val = sign_lut[sym & 0x000000FF];
; 1088 : 				state_ref = states + KAPPA_SIGN_BASE + (val>>1);
; 1089 : 				sym = val << 31; // Get sign flipping to `sym'
; 1090 : 				val = sp[width_by2] & KDU_INT32_MIN; // Get the sign bit

	mov	edi, DWORD PTR _width_by2$1$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR _cword$1$[ebp]
	sar	edx, 1
	and	ecx, 1090527360				; 41002080H
	and	edx, 67109376				; 04000200H
	or	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	sar	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 134218752				; 08000400H
	or	edx, ecx
	sar	edx, 6
	mov	ecx, edx
	sar	ecx, 16					; 00000010H
	or	ecx, edx
	movzx	ecx, cl
	movzx	edx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _sym$10$[ebp], edx
	mov	ecx, edx
	mov	edx, DWORD PTR _states$[ebp]
	add	edx, 80					; 00000050H
	sar	ecx, 1
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _sym$10$[ebp]
	shl	edx, 31					; 0000001fH
	mov	DWORD PTR _sym$10$[ebp], edx
	mov	edx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _state_ref$7$[ebp], ecx

; 1091 : 				sym ^= val; // Moves flipped sign bit into `sym'
; 1092 : 				_mq_enc_(coder,sym,*state_ref);

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	edi, DWORD PTR _store$1$[ebp]
	and	edx, -2147483648			; 80000000H
	xor	ecx, edx
	mov	DWORD PTR _val$10$[ebp], edx
	mov	edx, DWORD PTR _sym$10$[ebp]
	xor	edx, ecx
	sub	ebx, edx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN167@encode_cle
	add	esi, edx
	jmp	$LN35@encode_cle
$LN167@encode_cle:
	test	edx, edx
	js	SHORT $LN169@encode_cle
	cmp	ebx, edx
	jge	SHORT $LN171@encode_cle
	mov	ebx, edx
	jmp	SHORT $LN172@encode_cle
$LN171@encode_cle:
	add	esi, edx
$LN172@encode_cle:
	mov	ecx, DWORD PTR _state_ref$7$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1445[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1445[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN343@encode_cle
$LN169@encode_cle:
	and	ebx, 2147483647				; 7fffffffH
	and	edx, 2147483647				; 7fffffffH
	cmp	ebx, edx
	jge	SHORT $LN173@encode_cle
	add	esi, edx
	jmp	SHORT $LN174@encode_cle
$LN173@encode_cle:
	mov	ebx, edx
$LN174@encode_cle:
	mov	ecx, DWORD PTR _state_ref$7$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1446[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1446[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN343@encode_cle:
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
	npad	6
$LL36@encode_cle:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN34@encode_cle
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN176@encode_cle
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN34@encode_cle
$LN176@encode_cle:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN34@encode_cle:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL36@encode_cle
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN35@encode_cle:

; 1093 : 				// Broadcast neighbourhood context changes; sign bit is in `val'
; 1094 : 				cp[-1] |= (SIGMA_CR_BIT<<6);

	mov	ecx, DWORD PTR _contexts$[ebp]

; 1095 : 				cp[1]  |= (SIGMA_CL_BIT<<6);
; 1096 : 				cword |= (SIGMA_CC_BIT<<6);
; 1097 : 				val = (kdu_int32)(((kdu_uint32) val)>>(31-(CHI_POS+6))); // SRL
; 1098 : 				cword |= val;

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	DWORD PTR [ecx-4], 2048			; 00000800H
	or	DWORD PTR [ecx+4], 512			; 00000200H
	mov	ecx, DWORD PTR _val$10$[ebp]
	or	ecx, 16384				; 00004000H
	shr	ecx, 4
	or	edx, ecx
	mov	DWORD PTR _cword$1$[ebp], edx
	jmp	SHORT $row_3$355
$LN332@encode_cle:
	mov	edx, DWORD PTR _cword$1$[ebp]
$row_3$355:

; 1099 : 			}
; 1100 : row_3:
; 1101 : 			if (!(cword & (CLEANUP_MEMBER_MASK<<9)))

	test	edx, 1610620928				; 60002000H
	jne	$done$356

; 1102 : 			{ // Process fourth row of stripe column (row 3)
; 1103 : 				state_ref = states+KAPPA_SIG_BASE+sig_lut[(cword>>9) & NBRHD_MASK];

	mov	ecx, edx
	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	sar	ecx, 9
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	edx, DWORD PTR [edx+ecx*8]

; 1104 : 				val = sp[width_by3]<<shift;

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _state_ref$8$[ebp], edx
	mov	edx, DWORD PTR tv1473[ebp]
	mov	ecx, DWORD PTR [edx+ecx]

; 1105 : 				sym = val & KDU_INT32_MIN;
; 1106 : 				_mq_enc_(coder,sym,*state_ref);

	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR _val$11$[ebp], ecx
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	DWORD PTR _val$11$[ebp], cl
	mov	ecx, DWORD PTR _val$11$[ebp]
	and	ecx, -2147483648			; 80000000H
	xor	ecx, DWORD PTR [edx]
	sub	ebx, ecx
	mov	DWORD PTR _A$1$[ebp], ebx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN179@encode_cle
	add	esi, ecx
	jmp	$LN38@encode_cle
$LN179@encode_cle:
	test	ecx, ecx
	js	SHORT $LN181@encode_cle
	cmp	ebx, ecx
	jge	SHORT $LN183@encode_cle
	mov	ebx, ecx
	jmp	SHORT $LN184@encode_cle
$LN183@encode_cle:
	add	esi, ecx
$LN184@encode_cle:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1447[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1447[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN344@encode_cle
$LN181@encode_cle:
	and	ebx, 2147483647				; 7fffffffH
	and	ecx, 2147483647				; 7fffffffH
	cmp	ebx, ecx
	jge	SHORT $LN185@encode_cle
	add	esi, ecx
	jmp	SHORT $LN186@encode_cle
$LN185@encode_cle:
	mov	ebx, ecx
$LN186@encode_cle:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1449[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1449[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN344@encode_cle:
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL39@encode_cle:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN37@encode_cle
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN188@encode_cle
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN37@encode_cle
$LN188@encode_cle:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN37@encode_cle:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL39@encode_cle
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _A$1$[ebp], ebx
	mov	DWORD PTR _store$1$[ebp], edi
$LN38@encode_cle:

; 1107 : 				if (val >= 0) // New magnitude bit was 0, so still insignificant

	mov	edx, DWORD PTR _val$11$[ebp]
	test	edx, edx
	jns	$LN331@encode_cle
$row_3_significant$352:

; 1108 : 					goto done;
; 1109 : row_3_significant:
; 1110 : 				// Compute distortion change
; 1111 : 				val =  (val>>(31-DISTORTION_LSBS)) & (SIGNIFICANCE_DISTORTIONS-1);
; 1112 : 				distortion_change += distortion_lut[val];

	mov	ebx, DWORD PTR _distortion_lut$2$[ebp]
	mov	ecx, DWORD PTR _distortion_change$1$[ebp]
	sar	edx, 26					; 0000001aH
	and	edx, 31					; 0000001fH
	add	ecx, DWORD PTR [ebx+edx*4]

; 1113 : 
; 1114 : 				//ohhan
; 1115 : 				dec_sp[width_by3] |= 1<<p;   //true coefficients

	mov	edx, DWORD PTR tv1473[ebp]

; 1116 : 				dec_sp[width_by3] |= 1<<(p-1); //mid-point reconstruction

	mov	ebx, DWORD PTR tv1473[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	edx, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _p$[ebp]
	bts	edx, ecx
	dec	ecx
	bts	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ebx+ecx], edx

; 1117 : 				if (sign_sample = (sp[width_by3]&(1<<31))) 

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [ebx+ecx]
	mov	ebx, DWORD PTR _A$1$[ebp]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN192@encode_cle

; 1118 : 					dec_sp[width_by3] |= sign_sample;  //sign bit 

	mov	ebx, DWORD PTR tv1473[ebp]
	or	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ebx+ecx], edx
	mov	ebx, DWORD PTR _A$1$[ebp]
$LN192@encode_cle:

; 1119 : 
; 1120 : 
; 1121 : 				// Decode sign bit
; 1122 : 				sym = cword & ((CHI_BIT<<6) | (SIGMA_CC_BIT<<6) |
; 1123 : 					0       | (SIGMA_CC_BIT<<12));
; 1124 : 				sym >>= 10; // Shift down so that top sigma bit has address 0

	mov	edx, DWORD PTR _cword$1$[ebp]
	mov	ecx, edx
	sar	ecx, 10					; 0000000aH
	and	ecx, 131137				; 00020041H
	mov	DWORD PTR _sym$12$[ebp], ecx

; 1125 : 				if (cword < 0) // Use the fact that NEXT_CHI_BIT = 31

	test	edx, edx
	jns	SHORT $LN193@encode_cle

; 1126 : 					sym |= CHI_BIT<<(12-10);

	or	ecx, 8388608				; 00800000H
	mov	DWORD PTR _sym$12$[ebp], ecx
$LN193@encode_cle:

; 1127 : 				sym |= (cp[-1] & ((CHI_BIT<<9) | (SIGMA_CC_BIT<<9))) >> (10+1);
; 1128 : 				sym |= (cp[ 1] & ((CHI_BIT<<9) | (SIGMA_CC_BIT<<9))) >> (10-1);

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 1073750016				; 40002000H
	sar	edx, 2
	and	edx, 268437504				; 10000800H
	or	edx, ecx
	mov	ecx, DWORD PTR _sym$12$[ebp]
	sar	edx, 9
	or	ecx, edx
	mov	DWORD PTR _sym$12$[ebp], ecx

; 1129 : 				sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma

	sar	ecx, 16					; 00000010H

; 1130 : 				val = sign_lut[sym & 0x000000FF];

	or	ecx, DWORD PTR _sym$12$[ebp]
	movzx	ecx, cl
	movzx	edx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _sym$13$[ebp], edx

; 1131 : 				state_ref = states + KAPPA_SIGN_BASE + (val>>1);

	mov	ecx, edx
	mov	edx, DWORD PTR _states$[ebp]
	sar	ecx, 1
	add	edx, 80					; 00000050H
	lea	ecx, DWORD PTR [edx+ecx*8]

; 1132 : 				sym = val << 31; // Get sign flipping to `sym'

	mov	edx, DWORD PTR _sym$13$[ebp]
	shl	edx, 31					; 0000001fH
	mov	DWORD PTR _state_ref$9$[ebp], ecx

; 1133 : 				val = sp[width_by3] & KDU_INT32_MIN; // Get the sign bit

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _sym$13$[ebp], edx
	mov	edx, DWORD PTR tv1473[ebp]
	mov	ecx, DWORD PTR [edx+ecx]

; 1134 : 				sym ^= val; // Moves flipped sign bit into `sym'
; 1135 : 				_mq_enc_(coder,sym,*state_ref);

	mov	edx, DWORD PTR _sym$13$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	DWORD PTR _val$13$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$9$[ebp]
	mov	ecx, DWORD PTR [ecx]
	xor	ecx, DWORD PTR _val$13$[ebp]
	xor	edx, ecx
	sub	ebx, edx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN194@encode_cle
	add	esi, edx
	jmp	$LN41@encode_cle
$LN194@encode_cle:
	test	edx, edx
	js	SHORT $LN196@encode_cle
	cmp	ebx, edx
	jge	SHORT $LN198@encode_cle
	mov	ebx, edx
	jmp	SHORT $LN199@encode_cle
$LN198@encode_cle:
	add	esi, edx
$LN199@encode_cle:
	mov	ecx, DWORD PTR _state_ref$9$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1450[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$9$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1450[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN345@encode_cle
$LN196@encode_cle:
	and	ebx, 2147483647				; 7fffffffH
	and	edx, 2147483647				; 7fffffffH
	cmp	ebx, edx
	jge	SHORT $LN200@encode_cle
	add	esi, edx
	jmp	SHORT $LN201@encode_cle
$LN200@encode_cle:
	mov	ebx, edx
$LN201@encode_cle:
	mov	ecx, DWORD PTR _state_ref$9$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1451[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$9$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1451[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN345@encode_cle:
	mov	edx, DWORD PTR _state_ref$9$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL42@encode_cle:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN40@encode_cle
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN203@encode_cle
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN40@encode_cle
$LN203@encode_cle:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN40@encode_cle:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL42@encode_cle
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN41@encode_cle:

; 1136 : 				// Broadcast neighbourhood context changes; sign bit is in `val'
; 1137 : 				cp[context_row_gap-1] |= SIGMA_TR_BIT;

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	edx, DWORD PTR _context_row_gap$[ebp]
	or	DWORD PTR [ecx+edx*4-4], 4

; 1138 : 				cp[context_row_gap+1] |= SIGMA_TL_BIT;

	or	DWORD PTR [ecx+edx*4+4], 1

; 1139 : 				cp[-1] |= (SIGMA_CR_BIT<<9);

	or	DWORD PTR [ecx-4], 16384		; 00004000H

; 1140 : 				cp[1]  |= (SIGMA_CL_BIT<<9);

	or	DWORD PTR [ecx+4], 4096			; 00001000H

; 1141 : 				if (val < 0)

	cmp	DWORD PTR _val$13$[ebp], 0
	jge	SHORT $LN205@encode_cle

; 1142 : 				{
; 1143 : 					cp[context_row_gap  ] |= SIGMA_TC_BIT | PREV_CHI_BIT;

	or	DWORD PTR [ecx+edx*4], 262146		; 00040002H

; 1144 : 					cword |= (SIGMA_CC_BIT<<9) | (CHI_BIT<<9);

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	edx, 1073750016				; 40002000H

; 1145 : 				}
; 1146 : 				else

	jmp	SHORT $done$356
$LN205@encode_cle:

; 1147 : 				{
; 1148 : 					cp[context_row_gap  ] |= SIGMA_TC_BIT;

	or	DWORD PTR [ecx+edx*4], 2

; 1149 : 					cword |= (SIGMA_CC_BIT<<9);

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	edx, 8192				; 00002000H
	jmp	SHORT $done$356
$LN331@encode_cle:
	mov	edx, DWORD PTR _cword$1$[ebp]
$done$356:

; 1150 : 				}
; 1151 : 			}
; 1152 : done:
; 1153 : 			cword |= (cword << (MU_POS - SIGMA_CC_POS)) &
; 1154 : 				((MU_BIT<<0)|(MU_BIT<<3)|(MU_BIT<<6)|(MU_BIT<<9));
; 1155 : 			cword &= ~((PI_BIT<<0)|(PI_BIT<<3)|(PI_BIT<<6)|(PI_BIT<<9));
; 1156 : 			*cp = cword;

	mov	ecx, edx
	and	ecx, 9360				; 00002490H
	shl	ecx, 15					; 0000000fH
	or	ecx, edx
	mov	edx, DWORD PTR _contexts$[ebp]
	and	ecx, -613416961				; db6fffffH
	mov	DWORD PTR [edx], ecx
$LN5@encode_cle:

; 928  : 		for (c=width; c > 0; c--, sp++, dec_sp++, cp++, ky++)

	mov	edx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR _contexts$[ebp]
	add	edx, 4
	dec	DWORD PTR _c$1$[ebp]
	add	ecx, 4
	add	DWORD PTR _dec_samples$[ebp], 4
	cmp	DWORD PTR _c$1$[ebp], 0
	mov	DWORD PTR _samples$[ebp], edx
	mov	DWORD PTR _contexts$[ebp], ecx
	jg	$LL7@encode_cle
$LN2@encode_cle:

; 921  : 		distortion_lut = significance_distortion_lut_lossless;
; 922  : 
; 923  : 	kx = 0;
; 924  : 	ky = 0;
; 925  : 
; 926  : 	assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 927  : 	for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3, dec_sp += width_by3, kx += 4, ky = 0)

	dec	DWORD PTR _num_stripes$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _contexts$[ebp], ecx
	mov	ecx, DWORD PTR tv1473[ebp]
	add	edx, ecx
	add	DWORD PTR _dec_samples$[ebp], ecx
	cmp	DWORD PTR _num_stripes$[ebp], 0
	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	DWORD PTR _samples$[ebp], edx
	jg	$LL4@encode_cle
	mov	edx, DWORD PTR _t$1$[ebp]
$LN3@encode_cle:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 279  :         assert(active && checked_out && MQ_segment); checked_out = false;

	mov	ecx, DWORD PTR _coder$[ebp]

; 281  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+20], edi
	pop	edi

; 280  :         this->A = A; this->C = C;

	mov	DWORD PTR [ecx+4], esi
	pop	esi
	mov	DWORD PTR [ecx], ebx

; 281  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+12], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1159 : 		return distortion_change;

	mov	eax, DWORD PTR _distortion_change$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 279  :         assert(active && checked_out && MQ_segment); checked_out = false;

	mov	BYTE PTR [ecx+25], 0

; 281  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+8], edx
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1160 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN348@encode_cle:
	DD	$LN86@encode_cle
	DD	$LN88@encode_cle
	DD	$LN90@encode_cle
	DD	$LN92@encode_cle
?encode_cleanup_pass@@YAHAAVmq_encoder@@QAUmqe_state@@H_NHPAH33HHH2@Z ENDP ; encode_cleanup_pass
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?encode_mag_ref_pass@@YAHAAVmq_encoder@@QAUmqe_state@@H_NPAH33HHH2@Z
_TEXT	SEGMENT
_sym$1$ = -56						; size = 4
tv711 = -56						; size = 4
tv710 = -56						; size = 4
tv709 = -56						; size = 4
tv708 = -56						; size = 4
tv707 = -56						; size = 4
tv706 = -56						; size = 4
tv705 = -56						; size = 4
tv704 = -56						; size = 4
tv691 = -56						; size = 4
tv669 = -56						; size = 4
tv644 = -56						; size = 4
_distortion_lut$1$ = -56				; size = 4
_sym$4$ = -52						; size = 4
_sym$3$ = -52						; size = 4
_sym$2$ = -52						; size = 4
tv618 = -52						; size = 4
_width_by2$1$ = -48					; size = 4
tv714 = -44						; size = 4
_distortion_lut$2$ = -40				; size = 4
_curr_bit_mask$1$ = -36					; size = 4
_shift$1$ = -32						; size = 4
_refined_mask$1$ = -28					; size = 4
_val$8$ = -24						; size = 4
_val$6$ = -24						; size = 4
_val$4$ = -24						; size = 4
_val$2$ = -24						; size = 4
_c$1$ = -20						; size = 4
_cword$1$ = -16						; size = 4
_distortion_change$1$ = -12				; size = 4
_store$1$ = -8						; size = 4
_t$1$ = -4						; size = 4
_coder$ = 8						; size = 4
_states$ = 12						; size = 4
_p$ = 16						; size = 4
_causal$ = 20						; size = 1
_samples$ = 24						; size = 4
_dec_samples$ = 28					; size = 4
_contexts$ = 32						; size = 4
_width$ = 36						; size = 4
_num_stripes$ = 40					; size = 4
_context_row_gap$ = 44					; size = 4
_state_ref$4$ = 48					; size = 4
_state_ref$3$ = 48					; size = 4
_state_ref$2$ = 48					; size = 4
_state_ref$1$ = 48					; size = 4
_lossless_pass$ = 48					; size = 1
?encode_mag_ref_pass@@YAHAAVmq_encoder@@QAUmqe_state@@H_NPAH33HHH2@Z PROC ; encode_mag_ref_pass, COMDAT

; 712  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 729  : 	register kdu_int32 curr_bit_mask = ~(1<<p);

	mov	ecx, DWORD PTR _p$[ebp]
	push	ebx
	push	esi
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 267  :         assert(active && (!checked_out) && MQ_segment); checked_out = true;

	mov	edi, DWORD PTR _coder$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 737  : 	kdu_int32 *distortion_lut = refinement_distortion_lut;

	mov	DWORD PTR _distortion_lut$1$[ebp], OFFSET ?refinement_distortion_lut@@3PAHA
	mov	DWORD PTR _distortion_change$1$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 269  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	edx, DWORD PTR [edi+8]
	mov	ebx, DWORD PTR [edi]
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+12]
	mov	BYTE PTR [edi+25], 1
	mov	edi, DWORD PTR [edi+20]
	mov	DWORD PTR _store$1$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 729  : 	register kdu_int32 curr_bit_mask = ~(1<<p);

	mov	edi, 1
	shl	edi, cl
	not	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 269  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	DWORD PTR _t$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 729  : 	register kdu_int32 curr_bit_mask = ~(1<<p);

	mov	DWORD PTR _curr_bit_mask$1$[ebp], edi

; 730  : 	register mqe_state *state_ref;
; 731  : 	register kdu_int32 sym;
; 732  : 	register kdu_int32 val;
; 733  : 	register kdu_int32 shift = 31-p; // Shift to get new mag bit to sign position

	mov	edi, 31					; 0000001fH
	sub	edi, ecx

; 734  : 	register kdu_int32 refined_mask = (((kdu_int32)(-1))<<(p+2)) & KDU_INT32_MAX;

	add	ecx, 2
	mov	DWORD PTR _shift$1$[ebp], edi
	or	edi, -1
	shl	edi, cl

; 735  : 	int r, width_by2=width+width, width_by3=width_by2+width;

	mov	ecx, DWORD PTR _width$[ebp]
	and	edi, 2147483647				; 7fffffffH
	mov	DWORD PTR _refined_mask$1$[ebp], edi
	lea	edi, DWORD PTR [ecx+ecx]
	add	ecx, edi
	mov	DWORD PTR _width_by2$1$[ebp], edi

; 738  : 	int kx, ky;
; 739  : 	kx = ky = 0;
; 740  : 	if (lossless_pass)

	cmp	BYTE PTR _lossless_pass$[ebp], 0
	mov	edi, OFFSET ?refinement_distortion_lut_lossless@@3PAHA
	cmove	edi, DWORD PTR _distortion_lut$1$[ebp]

; 741  : 		distortion_lut = refinement_distortion_lut_lossless;
; 742  : 
; 743  : 	states += KAPPA_MAG_BASE;

	add	DWORD PTR _states$[ebp], 120		; 00000078H

; 744  : 	assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 745  : 	for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3, dec_sp += width_by3, kx += 4, ky = 0)

	cmp	DWORD PTR _num_stripes$[ebp], 0
	mov	DWORD PTR _distortion_lut$2$[ebp], edi
	mov	edi, DWORD PTR _store$1$[ebp]
	jle	$LN3@encode_mag
	shl	ecx, 2
	mov	DWORD PTR tv714[ebp], ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
$LL4@encode_mag:

; 746  : 		for (c=width; c > 0; c--, sp++, dec_sp++, cp++, ky++)

	mov	edx, DWORD PTR _width$[ebp]
	test	edx, edx
	mov	DWORD PTR _c$1$[ebp], edx
	mov	edx, DWORD PTR _t$1$[ebp]
	jle	$LN2@encode_mag
$LL7@encode_mag:

; 747  : 		{
; 748  : 			if ((*cp & ((MU_BIT<<0)|(MU_BIT<<3)|(MU_BIT<<6)|(MU_BIT<<9))) == 0)

	mov	edx, DWORD PTR [ecx]
	test	edx, 306708480				; 12480000H
	mov	DWORD PTR _cword$1$[ebp], edx
	mov	edx, DWORD PTR _t$1$[ebp]
	jne	SHORT $LN24@encode_mag

; 749  : 			{ // Invoke speedup trick to skip over runs of all-0 neighbourhoods
; 750  : 				for (cp+=2; *cp == 0; cp+=2, c-=2, sp+=2, dec_sp += 2, ky += 2);

	add	ecx, 8
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN9@encode_mag
	mov	edi, DWORD PTR _dec_samples$[ebp]
	mov	edx, DWORD PTR _c$1$[ebp]
$LL10@encode_mag:
	add	DWORD PTR _samples$[ebp], 8
	add	ecx, 8
	sub	edx, 2
	add	edi, 8
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LL10@encode_mag
	mov	DWORD PTR _c$1$[ebp], edx
	mov	edx, DWORD PTR _t$1$[ebp]
	mov	DWORD PTR _dec_samples$[ebp], edi
$LN9@encode_mag:

; 751  : 				cp-=2;

	sub	ecx, 8

; 752  : 				continue;

	jmp	$LN5@encode_mag
$LN24@encode_mag:

; 753  : 			}
; 754  : 
; 755  : 			//ohhan-Debug
; 756  : 			if (kx == 4 && ky == 4)
; 757  : 				kx +=0;
; 758  : 
; 759  : 			if (&(dec_sp[0]) != &(dec_samples[kx*64+ky]))
; 760  : 				kx += 0;
; 761  : 
; 762  : 
; 763  : 			cword = *cp;
; 764  : 			if (cword & (MU_BIT<<0))

	mov	ecx, DWORD PTR _cword$1$[ebp]
	test	ecx, 524288				; 00080000H
	je	$LN12@encode_mag

; 765  : 			{ // Process first row of stripe column
; 766  : 				val = sp[0];

	mov	edx, DWORD PTR _samples$[ebp]

; 767  : 				// Get coding context
; 768  : 				state_ref = states;

	mov	edi, DWORD PTR _states$[ebp]
	mov	DWORD PTR _state_ref$1$[ebp], edi
	mov	edx, DWORD PTR [edx]

; 769  : 				if (!(val & refined_mask))

	test	edx, DWORD PTR _refined_mask$1$[ebp]
	jne	SHORT $LN28@encode_mag

; 770  : 				{ // This is the first magnitude refinement step
; 771  : 					if (cword & (NBRHD_MASK<<0))

	test	ecx, 495				; 000001efH
	je	SHORT $LN29@encode_mag

; 772  : 						state_ref++;

	mov	ecx, edi
	add	ecx, 8

; 773  : 				}
; 774  : 				else

	jmp	SHORT $LN152@encode_mag
$LN28@encode_mag:

; 775  : 					state_ref += 2;

	mov	ecx, edi
	add	ecx, 16					; 00000010H
$LN152@encode_mag:
	mov	DWORD PTR _state_ref$1$[ebp], ecx
$LN29@encode_mag:

; 776  : 				val <<= shift; // Get new magnitude bit to sign position.

	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	edx, cl
	mov	DWORD PTR _val$2$[ebp], edx

; 777  : 				sym = val & KDU_INT32_MIN;

	and	edx, -2147483648			; 80000000H

; 778  : 
; 779  : 
; 780  : 
; 781  : 
; 782  : 				// Compute distortion change
; 783  : 				val =  (val >> (31-DISTORTION_LSBS)) & (REFINEMENT_DISTORTIONS-1);

	mov	ecx, DWORD PTR _val$2$[ebp]
	sar	ecx, 26					; 0000001aH
	and	ecx, 63					; 0000003fH
	mov	DWORD PTR _sym$1$[ebp], edx

; 784  : 
; 785  : 
; 786  : 				dec_sp[0] |= 1<<(p-1);

	mov	edx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR _val$2$[ebp], ecx
	mov	ecx, DWORD PTR _p$[ebp]
	dec	ecx
	mov	edx, DWORD PTR [edx]
	bts	edx, ecx
	mov	ecx, edx
	mov	DWORD PTR tv618[ebp], edx
	mov	edx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [edx], ecx

; 787  : 				if (val < (1<<5))

	mov	ecx, DWORD PTR _val$2$[ebp]
	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN31@encode_mag

; 788  : 				{
; 789  : 					dec_sp[0] &= curr_bit_mask;

	mov	ecx, DWORD PTR tv618[ebp]
	mov	edi, edx
	and	ecx, DWORD PTR _curr_bit_mask$1$[ebp]
	mov	DWORD PTR [edi], ecx
	mov	ecx, DWORD PTR _val$2$[ebp]
$LN31@encode_mag:

; 790  : 				}
; 791  : 
; 792  : 
; 793  : 
; 794  : 				distortion_change += distortion_lut[val];

	mov	edx, DWORD PTR _distortion_lut$2$[ebp]
	mov	edi, DWORD PTR _distortion_change$1$[ebp]
	add	edi, DWORD PTR [edx+ecx*4]

; 795  : 				// Encode magnitude bit
; 796  : 				_mq_enc_(coder,sym,*state_ref);

	mov	ecx, DWORD PTR _state_ref$1$[ebp]
	mov	edx, DWORD PTR _sym$1$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], edi
	mov	edi, DWORD PTR _store$1$[ebp]
	xor	edx, DWORD PTR [ecx]
	sub	ebx, edx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN32@encode_mag
	add	esi, edx
	jmp	$LN153@encode_mag
$LN32@encode_mag:
	test	edx, edx
	js	SHORT $LN34@encode_mag
	cmp	ebx, edx
	jge	SHORT $LN36@encode_mag
	mov	ebx, edx
	jmp	SHORT $LN37@encode_mag
$LN36@encode_mag:
	add	esi, edx
$LN37@encode_mag:
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv704[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv704[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN154@encode_mag
$LN34@encode_mag:
	and	ebx, 2147483647				; 7fffffffH
	and	edx, 2147483647				; 7fffffffH
	cmp	ebx, edx
	jge	SHORT $LN38@encode_mag
	add	esi, edx
	jmp	SHORT $LN39@encode_mag
$LN38@encode_mag:
	mov	ebx, edx
$LN39@encode_mag:
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv705[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv705[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN154@encode_mag:
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _t$1$[ebp]
	npad	1
$LL13@encode_mag:
	add	ebx, ebx
	add	esi, esi
	sub	edx, 1
	jne	SHORT $LN11@encode_mag
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN41@encode_mag
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	mov	edx, 7
	and	esi, 1048575				; 000fffffH
	jmp	SHORT $LN11@encode_mag
$LN41@encode_mag:
	mov	BYTE PTR [edi], al
	mov	edx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN11@encode_mag:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL13@encode_mag
	mov	DWORD PTR _t$1$[ebp], edx
	mov	DWORD PTR _store$1$[ebp], edi
$LN153@encode_mag:
	mov	ecx, DWORD PTR _cword$1$[ebp]
$LN12@encode_mag:

; 797  : 			}
; 798  : 			if (cword & (MU_BIT<<3))

	test	ecx, 4194304				; 00400000H
	je	$LN15@encode_mag

; 799  : 			{ // Process second row of stripe column
; 800  : 				val = sp[width];

	mov	edi, DWORD PTR _width$[ebp]
	mov	edx, DWORD PTR _samples$[ebp]
	mov	edx, DWORD PTR [edx+edi*4]

; 801  : 				// Get coding context
; 802  : 				state_ref = states;

	mov	edi, DWORD PTR _states$[ebp]
	mov	DWORD PTR _state_ref$2$[ebp], edi

; 803  : 				if (!(val & refined_mask))

	test	edx, DWORD PTR _refined_mask$1$[ebp]
	jne	SHORT $LN44@encode_mag

; 804  : 				{ // This is the first magnitude refinement step
; 805  : 					if (cword & (NBRHD_MASK<<3))

	test	ecx, 3960				; 00000f78H
	je	SHORT $LN45@encode_mag

; 806  : 						state_ref++;

	mov	ecx, edi
	add	ecx, 8

; 807  : 				}
; 808  : 				else

	jmp	SHORT $LN155@encode_mag
$LN44@encode_mag:

; 809  : 					state_ref += 2;

	mov	ecx, edi
	add	ecx, 16					; 00000010H
$LN155@encode_mag:
	mov	DWORD PTR _state_ref$2$[ebp], ecx
$LN45@encode_mag:

; 810  : 				val <<= shift; // Get new magnitude bit to sign position.

	mov	ecx, DWORD PTR _shift$1$[ebp]

; 811  : 				sym = val & KDU_INT32_MIN;
; 812  : 				// Compute distortion change
; 813  : 				val =  (val >> (31-DISTORTION_LSBS)) & (REFINEMENT_DISTORTIONS-1);
; 814  : 
; 815  : 				dec_sp[width] |= 1<<(p-1);

	mov	edi, DWORD PTR _width$[ebp]
	shl	edx, cl
	mov	DWORD PTR _val$4$[ebp], edx
	and	edx, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _val$4$[ebp]
	sar	ecx, 26					; 0000001aH
	and	ecx, 63					; 0000003fH
	mov	DWORD PTR _sym$2$[ebp], edx
	mov	edx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR _val$4$[ebp], ecx
	mov	ecx, DWORD PTR _p$[ebp]
	dec	ecx
	mov	edx, DWORD PTR [edx+edi*4]
	bts	edx, ecx
	mov	ecx, edx
	mov	DWORD PTR tv644[ebp], edx
	mov	edx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [edx+edi*4], ecx

; 816  : 				if (val < (1<<5))

	mov	ecx, DWORD PTR _val$4$[ebp]
	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN47@encode_mag

; 817  : 				{
; 818  : 					dec_sp[width] &= curr_bit_mask;

	mov	ecx, DWORD PTR tv644[ebp]
	mov	edi, edx
	mov	edx, DWORD PTR _width$[ebp]
	and	ecx, DWORD PTR _curr_bit_mask$1$[ebp]
	mov	DWORD PTR [edi+edx*4], ecx
	mov	ecx, DWORD PTR _val$4$[ebp]
$LN47@encode_mag:

; 819  : 				}
; 820  : 
; 821  : 				distortion_change += distortion_lut[val];

	mov	edx, DWORD PTR _distortion_lut$2$[ebp]
	mov	edi, DWORD PTR _distortion_change$1$[ebp]
	add	edi, DWORD PTR [edx+ecx*4]

; 822  : 				// Encode magnitude bit
; 823  : 				_mq_enc_(coder,sym,*state_ref);

	mov	ecx, DWORD PTR _state_ref$2$[ebp]
	mov	edx, DWORD PTR _sym$2$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], edi
	mov	edi, DWORD PTR _store$1$[ebp]
	xor	edx, DWORD PTR [ecx]
	sub	ebx, edx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN48@encode_mag
	add	esi, edx
	jmp	$LN156@encode_mag
$LN48@encode_mag:
	test	edx, edx
	js	SHORT $LN50@encode_mag
	cmp	ebx, edx
	jge	SHORT $LN52@encode_mag
	mov	ebx, edx
	jmp	SHORT $LN53@encode_mag
$LN52@encode_mag:
	add	esi, edx
$LN53@encode_mag:
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv706[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv706[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN157@encode_mag
$LN50@encode_mag:
	and	ebx, 2147483647				; 7fffffffH
	and	edx, 2147483647				; 7fffffffH
	cmp	ebx, edx
	jge	SHORT $LN54@encode_mag
	add	esi, edx
	jmp	SHORT $LN55@encode_mag
$LN54@encode_mag:
	mov	ebx, edx
$LN55@encode_mag:
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv707[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv707[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN157@encode_mag:
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL16@encode_mag:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN14@encode_mag
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN57@encode_mag
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN14@encode_mag
$LN57@encode_mag:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN14@encode_mag:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL16@encode_mag
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN156@encode_mag:
	mov	ecx, DWORD PTR _cword$1$[ebp]
$LN15@encode_mag:

; 824  : 			}
; 825  : 			if (cword & (MU_BIT<<6))

	test	ecx, 33554432				; 02000000H
	je	$LN18@encode_mag

; 826  : 			{ // Process third row of stripe column
; 827  : 				val = sp[width_by2];

	mov	edi, DWORD PTR _width_by2$1$[ebp]
	mov	edx, DWORD PTR _samples$[ebp]
	mov	edx, DWORD PTR [edx+edi*4]

; 828  : 				// Get coding context
; 829  : 				state_ref = states;

	mov	edi, DWORD PTR _states$[ebp]
	mov	DWORD PTR _state_ref$3$[ebp], edi

; 830  : 				if (!(val & refined_mask))

	test	edx, DWORD PTR _refined_mask$1$[ebp]
	jne	SHORT $LN60@encode_mag

; 831  : 				{ // This is the first magnitude refinement step
; 832  : 					if (cword & (NBRHD_MASK<<6))

	test	ecx, 31680				; 00007bc0H
	je	SHORT $LN61@encode_mag

; 833  : 						state_ref++;

	mov	ecx, edi
	add	ecx, 8

; 834  : 				}
; 835  : 				else

	jmp	SHORT $LN158@encode_mag
$LN60@encode_mag:

; 836  : 					state_ref += 2;

	mov	ecx, edi
	add	ecx, 16					; 00000010H
$LN158@encode_mag:
	mov	DWORD PTR _state_ref$3$[ebp], ecx
$LN61@encode_mag:

; 837  : 				val <<= shift; // Get new magnitude bit to sign position.

	mov	ecx, DWORD PTR _shift$1$[ebp]

; 838  : 				sym = val & KDU_INT32_MIN;
; 839  : 				// Compute distortion change
; 840  : 				val =  (val >> (31-DISTORTION_LSBS)) & (REFINEMENT_DISTORTIONS-1);
; 841  : 
; 842  : 				dec_sp[width_by2] |= 1<<(p-1);

	mov	edi, DWORD PTR _width_by2$1$[ebp]
	shl	edx, cl
	mov	DWORD PTR _val$6$[ebp], edx
	and	edx, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _val$6$[ebp]
	sar	ecx, 26					; 0000001aH
	and	ecx, 63					; 0000003fH
	mov	DWORD PTR _sym$3$[ebp], edx
	mov	edx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR _val$6$[ebp], ecx
	mov	ecx, DWORD PTR _p$[ebp]
	dec	ecx
	mov	edx, DWORD PTR [edx+edi*4]
	bts	edx, ecx
	mov	ecx, edx
	mov	DWORD PTR tv669[ebp], edx
	mov	edx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [edx+edi*4], ecx

; 843  : 				if (val < (1<<5))

	mov	ecx, DWORD PTR _val$6$[ebp]
	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN63@encode_mag

; 844  : 				{
; 845  : 					dec_sp[width_by2] &= curr_bit_mask;

	mov	ecx, DWORD PTR tv669[ebp]
	mov	edi, edx
	mov	edx, DWORD PTR _width_by2$1$[ebp]
	and	ecx, DWORD PTR _curr_bit_mask$1$[ebp]
	mov	DWORD PTR [edi+edx*4], ecx
	mov	ecx, DWORD PTR _val$6$[ebp]
$LN63@encode_mag:

; 846  : 				}
; 847  : 
; 848  : 				distortion_change += distortion_lut[val];

	mov	edx, DWORD PTR _distortion_lut$2$[ebp]
	mov	edi, DWORD PTR _distortion_change$1$[ebp]
	add	edi, DWORD PTR [edx+ecx*4]

; 849  : 				// Encode magnitude bit
; 850  : 				_mq_enc_(coder,sym,*state_ref);

	mov	ecx, DWORD PTR _state_ref$3$[ebp]
	mov	edx, DWORD PTR _sym$3$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], edi
	mov	edi, DWORD PTR _store$1$[ebp]
	xor	edx, DWORD PTR [ecx]
	sub	ebx, edx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN64@encode_mag
	add	esi, edx
	jmp	$LN159@encode_mag
$LN64@encode_mag:
	test	edx, edx
	js	SHORT $LN66@encode_mag
	cmp	ebx, edx
	jge	SHORT $LN68@encode_mag
	mov	ebx, edx
	jmp	SHORT $LN69@encode_mag
$LN68@encode_mag:
	add	esi, edx
$LN69@encode_mag:
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv708[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv708[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN160@encode_mag
$LN66@encode_mag:
	and	ebx, 2147483647				; 7fffffffH
	and	edx, 2147483647				; 7fffffffH
	cmp	ebx, edx
	jge	SHORT $LN70@encode_mag
	add	esi, edx
	jmp	SHORT $LN71@encode_mag
$LN70@encode_mag:
	mov	ebx, edx
$LN71@encode_mag:
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv709[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv709[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN160@encode_mag:
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL19@encode_mag:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN17@encode_mag
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN73@encode_mag
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN17@encode_mag
$LN73@encode_mag:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN17@encode_mag:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL19@encode_mag
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN159@encode_mag:
	mov	ecx, DWORD PTR _cword$1$[ebp]
$LN18@encode_mag:

; 851  : 			}
; 852  : 			if (cword & (MU_BIT<<9))

	test	ecx, 268435456				; 10000000H
	je	$LN21@encode_mag

; 853  : 			{ // Process fourth row of stripe column
; 854  : 				val = sp[width_by3];

	mov	edi, DWORD PTR tv714[ebp]
	mov	edx, DWORD PTR _samples$[ebp]
	mov	edx, DWORD PTR [edi+edx]

; 855  : 				// Get coding context
; 856  : 				state_ref = states;

	mov	edi, DWORD PTR _states$[ebp]
	mov	DWORD PTR _state_ref$4$[ebp], edi

; 857  : 				if (!(val & refined_mask))

	test	edx, DWORD PTR _refined_mask$1$[ebp]
	jne	SHORT $LN76@encode_mag

; 858  : 				{ // This is the first magnitude refinement step
; 859  : 					if (cword & (NBRHD_MASK<<9))

	test	ecx, 253440				; 0003de00H
	je	SHORT $LN77@encode_mag

; 860  : 						state_ref++;

	mov	ecx, edi
	add	ecx, 8

; 861  : 				}
; 862  : 				else

	jmp	SHORT $LN161@encode_mag
$LN76@encode_mag:

; 863  : 					state_ref += 2;

	mov	ecx, edi
	add	ecx, 16					; 00000010H
$LN161@encode_mag:
	mov	DWORD PTR _state_ref$4$[ebp], ecx
$LN77@encode_mag:

; 864  : 				val <<= shift; // Get new magnitude bit to sign position.

	mov	ecx, DWORD PTR _shift$1$[ebp]

; 865  : 				sym = val & KDU_INT32_MIN;
; 866  : 				// Compute distortion change
; 867  : 				val =  (val >> (31-DISTORTION_LSBS)) & (REFINEMENT_DISTORTIONS-1);
; 868  : 
; 869  : 				dec_sp[width_by3] |= 1<<(p-1);

	mov	edi, DWORD PTR tv714[ebp]
	shl	edx, cl
	mov	DWORD PTR _val$8$[ebp], edx
	and	edx, -2147483648			; 80000000H
	mov	ecx, DWORD PTR _val$8$[ebp]
	sar	ecx, 26					; 0000001aH
	and	ecx, 63					; 0000003fH
	mov	DWORD PTR _sym$4$[ebp], edx
	mov	edx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR _val$8$[ebp], ecx
	mov	ecx, DWORD PTR _p$[ebp]
	dec	ecx
	mov	edx, DWORD PTR [edi+edx]
	bts	edx, ecx
	mov	ecx, edx
	mov	DWORD PTR tv691[ebp], edx
	mov	edx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [edi+edx], ecx

; 870  : 				if (val < (1<<5))

	mov	ecx, DWORD PTR _val$8$[ebp]
	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN79@encode_mag

; 871  : 				{
; 872  : 					dec_sp[width_by3] &= curr_bit_mask;

	mov	ecx, DWORD PTR tv691[ebp]
	mov	edi, edx
	mov	edx, DWORD PTR tv714[ebp]
	and	ecx, DWORD PTR _curr_bit_mask$1$[ebp]
	mov	DWORD PTR [edx+edi], ecx
	mov	ecx, DWORD PTR _val$8$[ebp]
$LN79@encode_mag:

; 873  : 				}
; 874  : 
; 875  : 				distortion_change += distortion_lut[val];

	mov	edx, DWORD PTR _distortion_lut$2$[ebp]
	mov	edi, DWORD PTR _distortion_change$1$[ebp]
	add	edi, DWORD PTR [edx+ecx*4]

; 876  : 				// Encode magnitude bit
; 877  : 				_mq_enc_(coder,sym,*state_ref);

	mov	ecx, DWORD PTR _state_ref$4$[ebp]
	mov	edx, DWORD PTR _sym$4$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], edi
	mov	edi, DWORD PTR _store$1$[ebp]
	xor	edx, DWORD PTR [ecx]
	sub	ebx, edx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN80@encode_mag
	add	esi, edx
	jmp	$LN21@encode_mag
$LN80@encode_mag:
	test	edx, edx
	js	SHORT $LN82@encode_mag
	cmp	ebx, edx
	jge	SHORT $LN84@encode_mag
	mov	ebx, edx
	jmp	SHORT $LN85@encode_mag
$LN84@encode_mag:
	add	esi, edx
$LN85@encode_mag:
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv710[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv710[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN162@encode_mag
$LN82@encode_mag:
	and	ebx, 2147483647				; 7fffffffH
	and	edx, 2147483647				; 7fffffffH
	cmp	ebx, edx
	jge	SHORT $LN86@encode_mag
	add	esi, edx
	jmp	SHORT $LN87@encode_mag
$LN86@encode_mag:
	mov	ebx, edx
$LN87@encode_mag:
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv711[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv711[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN162@encode_mag:
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
	npad	7
$LL22@encode_mag:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN20@encode_mag
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN89@encode_mag
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN20@encode_mag
$LN89@encode_mag:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN20@encode_mag:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL22@encode_mag
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN21@encode_mag:
	mov	edx, DWORD PTR _t$1$[ebp]
	mov	ecx, DWORD PTR _contexts$[ebp]
$LN5@encode_mag:

; 746  : 		for (c=width; c > 0; c--, sp++, dec_sp++, cp++, ky++)

	dec	DWORD PTR _c$1$[ebp]
	add	ecx, 4
	add	DWORD PTR _samples$[ebp], 4
	add	DWORD PTR _dec_samples$[ebp], 4
	cmp	DWORD PTR _c$1$[ebp], 0
	mov	DWORD PTR _contexts$[ebp], ecx
	jg	$LL7@encode_mag
$LN2@encode_mag:

; 744  : 	assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 745  : 	for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3, dec_sp += width_by3, kx += 4, ky = 0)

	mov	edi, DWORD PTR tv714[ebp]
	add	ecx, 12					; 0000000cH
	dec	DWORD PTR _num_stripes$[ebp]
	add	DWORD PTR _samples$[ebp], edi
	add	DWORD PTR _dec_samples$[ebp], edi
	cmp	DWORD PTR _num_stripes$[ebp], 0
	mov	edi, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _contexts$[ebp], ecx
	jg	$LL4@encode_mag
$LN3@encode_mag:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 279  :         assert(active && checked_out && MQ_segment); checked_out = false;

	mov	ecx, DWORD PTR _coder$[ebp]

; 281  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+20], edi
	pop	edi

; 280  :         this->A = A; this->C = C;

	mov	DWORD PTR [ecx+4], esi
	pop	esi
	mov	DWORD PTR [ecx], ebx

; 281  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+12], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 881  : 		return distortion_change;

	mov	eax, DWORD PTR _distortion_change$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 279  :         assert(active && checked_out && MQ_segment); checked_out = false;

	mov	BYTE PTR [ecx+25], 0

; 281  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+8], edx
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 882  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?encode_mag_ref_pass@@YAHAAVmq_encoder@@QAUmqe_state@@H_NPAH33HHH2@Z ENDP ; encode_mag_ref_pass
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?encode_mag_ref_pass_raw@@YAHAAVmq_encoder@@H_NPAH2HHH1@Z
_TEXT	SEGMENT
_width_by2$1$ = -24					; size = 4
_distortion_lut$1$ = -20				; size = 4
tv365 = -20						; size = 4
_sym$3$ = -16						; size = 4
_sym$2$ = -16						; size = 4
_sym$1$ = -16						; size = 4
_c$1$ = -12						; size = 4
_shift$1$ = -8						; size = 4
_store$1$ = -4						; size = 4
_coder$ = 8						; size = 4
_distortion_change$1$ = 12				; size = 4
_p$ = 12						; size = 4
_causal$ = 16						; size = 1
_sym$4$ = 20						; size = 4
_cword$1$ = 20						; size = 4
_samples$ = 20						; size = 4
_contexts$ = 24						; size = 4
_width$ = 28						; size = 4
_num_stripes$ = 32					; size = 4
_context_row_gap$ = 36					; size = 4
_distortion_lut$2$ = 40					; size = 4
_lossless_pass$ = 40					; size = 1
?encode_mag_ref_pass_raw@@YAHAAVmq_encoder@@H_NPAH2HHH1@Z PROC ; encode_mag_ref_pass_raw, COMDAT

; 620  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 273  :         assert(active && (!checked_out) && !MQ_segment); checked_out = true;

	mov	ecx, DWORD PTR _coder$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 636  :   register kdu_int32 shift = 31-p; // Shift to get new mag bit to sign position

	mov	edx, 31					; 0000001fH
	sub	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _contexts$[ebp]
	push	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 274  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	ebx, DWORD PTR [ecx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 636  :   register kdu_int32 shift = 31-p; // Shift to get new mag bit to sign position

	mov	DWORD PTR _shift$1$[ebp], edx

; 637  :   int r, width_by2=width+width, width_by3=width_by2+width;

	mov	edx, DWORD PTR _width$[ebp]
	push	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 274  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	esi, DWORD PTR [ecx+8]
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 637  :   int r, width_by2=width+width, width_by3=width_by2+width;

	lea	edi, DWORD PTR [edx+edx]

; 639  :   kdu_int32 *distortion_lut = refinement_distortion_lut;

	mov	DWORD PTR _distortion_lut$1$[ebp], OFFSET ?refinement_distortion_lut@@3PAHA
	add	edx, edi
	mov	DWORD PTR _width_by2$1$[ebp], edi

; 640  :   if (lossless_pass)

	cmp	BYTE PTR _lossless_pass$[ebp], 0
	mov	edi, OFFSET ?refinement_distortion_lut_lossless@@3PAHA
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 273  :         assert(active && (!checked_out) && !MQ_segment); checked_out = true;

	mov	BYTE PTR [ecx+25], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 640  :   if (lossless_pass)

	cmove	edi, DWORD PTR _distortion_lut$1$[ebp]

; 641  :     distortion_lut = refinement_distortion_lut_lossless;
; 642  : 
; 643  :   assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 644  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3)

	cmp	DWORD PTR _num_stripes$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 274  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	ecx, DWORD PTR [ecx+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 640  :   if (lossless_pass)

	mov	DWORD PTR _distortion_lut$2$[ebp], edi

; 641  :     distortion_lut = refinement_distortion_lut_lossless;
; 642  : 
; 643  :   assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 644  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3)

	mov	edi, DWORD PTR _samples$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 274  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	DWORD PTR _store$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 638  :   kdu_int32 distortion_change = 0;

	mov	DWORD PTR _distortion_change$1$[ebp], 0

; 641  :     distortion_lut = refinement_distortion_lut_lossless;
; 642  : 
; 643  :   assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 644  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3)

	jle	$LN3@encode_mag
	lea	ecx, DWORD PTR [edx*4]
	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR tv365[ebp], ecx
	npad	3
$LL4@encode_mag:

; 645  :     for (c=width; c > 0; c--, sp++, cp++)

	mov	ecx, edx
	mov	DWORD PTR _c$1$[ebp], ecx
	test	edx, edx
	jle	$LN2@encode_mag
	npad	3
$LL7@encode_mag:

; 646  :       {
; 647  :         if ((*cp & ((MU_BIT<<0)|(MU_BIT<<3)|(MU_BIT<<6)|(MU_BIT<<9))) == 0)

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _cword$1$[ebp], edx
	test	edx, 306708480				; 12480000H
	jne	SHORT $LN12@encode_mag

; 648  :           { // Invoke speedup trick to skip over runs of all-0 neighbourhoods
; 649  :             for (cp+=2; *cp == 0; cp+=2, c-=2, sp+=2);

	add	eax, 8
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN9@encode_mag
$LL10@encode_mag:
	add	eax, 8
	sub	ecx, 2
	add	edi, 8
	cmp	DWORD PTR [eax], 0
	je	SHORT $LL10@encode_mag
$LN9@encode_mag:

; 650  :             cp-=2;

	sub	eax, 8

; 651  :             continue;

	jmp	$LN5@encode_mag
$LN12@encode_mag:

; 652  :           }
; 653  :         cword = *cp;
; 654  :         if (cword & (MU_BIT<<0))

	test	edx, 524288				; 00080000H
	je	SHORT $LN13@encode_mag

; 655  :           { // Process first row of stripe column
; 656  :             val = sp[0];
; 657  :             val <<= shift; // Get new magnitude bit to sign position.

	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR _shift$1$[ebp]

; 658  :             sym = (kdu_int32)(((kdu_uint32) val)>>31);
; 659  :             // Compute distortion change
; 660  :             val =  (val >> (31-DISTORTION_LSBS)) & (REFINEMENT_DISTORTIONS-1);
; 661  :             distortion_change += distortion_lut[val];

	mov	eax, DWORD PTR _distortion_lut$2$[ebp]
	shl	edx, cl
	mov	ecx, edx
	sar	edx, 26					; 0000001aH
	shr	ecx, 31					; 0000001fH
	and	edx, 63					; 0000003fH
	mov	DWORD PTR _sym$1$[ebp], ecx
	mov	ecx, DWORD PTR _distortion_change$1$[ebp]
	add	ecx, DWORD PTR [eax+edx*4]

; 662  :             // Encode magnitude bit
; 663  :             _raw_enc_(coder,sym);

	mov	eax, DWORD PTR _contexts$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], ecx
	mov	ecx, DWORD PTR _sym$1$[ebp]
	test	esi, esi
	jne	SHORT $LN14@encode_mag
	mov	ecx, DWORD PTR _store$1$[ebp]
	mov	esi, 8
	mov	BYTE PTR [ecx], bl
	inc	ecx
	mov	DWORD PTR _store$1$[ebp], ecx
	lea	ecx, DWORD PTR [ebx+1]
	sar	ecx, 8
	sub	esi, ecx
	mov	ecx, DWORD PTR _sym$1$[ebp]
	xor	ebx, ebx
$LN14@encode_mag:
	mov	edx, DWORD PTR _cword$1$[ebp]
	lea	ebx, DWORD PTR [ecx+ebx*2]
	dec	esi
$LN13@encode_mag:

; 664  :           }
; 665  :         if (cword & (MU_BIT<<3))

	test	edx, 4194304				; 00400000H
	je	SHORT $LN15@encode_mag

; 666  :           { // Process second row of stripe column
; 667  :             val = sp[width];
; 668  :             val <<= shift; // Get new magnitude bit to sign position.

	mov	eax, DWORD PTR _width$[ebp]
	mov	ecx, DWORD PTR _shift$1$[ebp]
	mov	edx, DWORD PTR [edi+eax*4]

; 669  :             sym = (kdu_int32)(((kdu_uint32) val)>>31);
; 670  :             // Compute distortion change
; 671  :             val =  (val >> (31-DISTORTION_LSBS)) & (REFINEMENT_DISTORTIONS-1);
; 672  :             distortion_change += distortion_lut[val];

	mov	eax, DWORD PTR _distortion_lut$2$[ebp]
	shl	edx, cl
	mov	ecx, edx
	sar	edx, 26					; 0000001aH
	shr	ecx, 31					; 0000001fH
	and	edx, 63					; 0000003fH
	mov	DWORD PTR _sym$2$[ebp], ecx
	mov	ecx, DWORD PTR _distortion_change$1$[ebp]
	add	ecx, DWORD PTR [eax+edx*4]

; 673  :             // Encode magnitude bit
; 674  :             _raw_enc_(coder,sym);

	mov	eax, DWORD PTR _contexts$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], ecx
	mov	ecx, DWORD PTR _sym$2$[ebp]
	test	esi, esi
	jne	SHORT $LN16@encode_mag
	mov	ecx, DWORD PTR _store$1$[ebp]
	mov	esi, 8
	mov	BYTE PTR [ecx], bl
	inc	ecx
	mov	DWORD PTR _store$1$[ebp], ecx
	lea	ecx, DWORD PTR [ebx+1]
	sar	ecx, 8
	sub	esi, ecx
	mov	ecx, DWORD PTR _sym$2$[ebp]
	xor	ebx, ebx
$LN16@encode_mag:
	mov	edx, DWORD PTR _cword$1$[ebp]
	lea	ebx, DWORD PTR [ecx+ebx*2]
	dec	esi
$LN15@encode_mag:

; 675  :           }
; 676  :         if (cword & (MU_BIT<<6))

	test	edx, 33554432				; 02000000H
	je	SHORT $LN17@encode_mag

; 677  :           { // Process third row of stripe column
; 678  :             val = sp[width_by2];
; 679  :             val <<= shift; // Get new magnitude bit to sign position.

	mov	eax, DWORD PTR _width_by2$1$[ebp]
	mov	ecx, DWORD PTR _shift$1$[ebp]
	mov	edx, DWORD PTR [edi+eax*4]

; 680  :             sym = (kdu_int32)(((kdu_uint32) val)>>31);
; 681  :             // Compute distortion change
; 682  :             val =  (val >> (31-DISTORTION_LSBS)) & (REFINEMENT_DISTORTIONS-1);
; 683  :             distortion_change += distortion_lut[val];

	mov	eax, DWORD PTR _distortion_lut$2$[ebp]
	shl	edx, cl
	mov	ecx, edx
	sar	edx, 26					; 0000001aH
	shr	ecx, 31					; 0000001fH
	and	edx, 63					; 0000003fH
	mov	DWORD PTR _sym$3$[ebp], ecx
	mov	ecx, DWORD PTR _distortion_change$1$[ebp]
	add	ecx, DWORD PTR [eax+edx*4]

; 684  :             // Encode magnitude bit
; 685  :             _raw_enc_(coder,sym);

	mov	eax, DWORD PTR _contexts$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], ecx
	mov	ecx, DWORD PTR _sym$3$[ebp]
	test	esi, esi
	jne	SHORT $LN18@encode_mag
	mov	ecx, DWORD PTR _store$1$[ebp]
	mov	esi, 8
	mov	BYTE PTR [ecx], bl
	inc	ecx
	mov	DWORD PTR _store$1$[ebp], ecx
	lea	ecx, DWORD PTR [ebx+1]
	sar	ecx, 8
	sub	esi, ecx
	mov	ecx, DWORD PTR _sym$3$[ebp]
	xor	ebx, ebx
$LN18@encode_mag:
	mov	edx, DWORD PTR _cword$1$[ebp]
	lea	ebx, DWORD PTR [ecx+ebx*2]
	dec	esi
$LN17@encode_mag:

; 686  :           }
; 687  :         if (cword & (MU_BIT<<9))

	test	edx, 268435456				; 10000000H
	je	SHORT $LN38@encode_mag

; 688  :           { // Process fourth row of stripe column
; 689  :             val = sp[width_by3];
; 690  :             val <<= shift; // Get new magnitude bit to sign position.

	mov	eax, DWORD PTR tv365[ebp]
	mov	ecx, DWORD PTR _shift$1$[ebp]
	mov	edx, DWORD PTR [eax+edi]

; 691  :             sym = (kdu_int32)(((kdu_uint32) val)>>31);
; 692  :             // Compute distortion change
; 693  :             val =  (val >> (31-DISTORTION_LSBS)) & (REFINEMENT_DISTORTIONS-1);
; 694  :             distortion_change += distortion_lut[val];

	mov	eax, DWORD PTR _distortion_lut$2$[ebp]
	shl	edx, cl
	mov	ecx, edx
	sar	edx, 26					; 0000001aH
	shr	ecx, 31					; 0000001fH
	and	edx, 63					; 0000003fH
	mov	DWORD PTR _sym$4$[ebp], ecx
	mov	ecx, DWORD PTR _distortion_change$1$[ebp]
	add	ecx, DWORD PTR [eax+edx*4]

; 695  :             // Encode magnitude bit
; 696  :             _raw_enc_(coder,sym);

	mov	eax, DWORD PTR _contexts$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], ecx
	mov	ecx, DWORD PTR _sym$4$[ebp]
	test	esi, esi
	jne	SHORT $LN20@encode_mag
	mov	ecx, DWORD PTR _store$1$[ebp]
	mov	esi, 8
	mov	BYTE PTR [ecx], bl
	inc	ecx
	mov	DWORD PTR _store$1$[ebp], ecx
	lea	ecx, DWORD PTR [ebx+1]
	sar	ecx, 8
	sub	esi, ecx
	mov	ecx, DWORD PTR _sym$4$[ebp]
	xor	ebx, ebx
$LN20@encode_mag:
	lea	ebx, DWORD PTR [ecx+ebx*2]
	dec	esi
$LN38@encode_mag:
	mov	ecx, DWORD PTR _c$1$[ebp]
$LN5@encode_mag:

; 645  :     for (c=width; c > 0; c--, sp++, cp++)

	dec	ecx
	add	eax, 4
	add	edi, 4
	mov	DWORD PTR _c$1$[ebp], ecx
	mov	DWORD PTR _contexts$[ebp], eax
	test	ecx, ecx
	jg	$LL7@encode_mag
	mov	edx, DWORD PTR _width$[ebp]
$LN2@encode_mag:

; 641  :     distortion_lut = refinement_distortion_lut_lossless;
; 642  : 
; 643  :   assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 644  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3)

	mov	ecx, DWORD PTR _num_stripes$[ebp]
	add	eax, 12					; 0000000cH
	add	edi, DWORD PTR tv365[ebp]
	dec	ecx
	mov	DWORD PTR _num_stripes$[ebp], ecx
	mov	DWORD PTR _contexts$[ebp], eax
	test	ecx, ecx
	jg	$LL4@encode_mag
	mov	ecx, DWORD PTR _store$1$[ebp]
$LN3@encode_mag:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 285  :         assert(active && checked_out && !MQ_segment); checked_out = false;

	mov	eax, DWORD PTR _coder$[ebp]
	pop	edi

; 286  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], ebx
	pop	esi

; 285  :         assert(active && checked_out && !MQ_segment); checked_out = false;

	mov	BYTE PTR [eax+25], 0

; 286  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [eax+20], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 700  :   return distortion_change;

	mov	eax, DWORD PTR _distortion_change$1$[ebp]
	pop	ebx

; 701  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?encode_mag_ref_pass_raw@@YAHAAVmq_encoder@@H_NPAH2HHH1@Z ENDP ; encode_mag_ref_pass_raw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?encode_sig_prop_pass@@YAHAAVmq_encoder@@QAUmqe_state@@H_NHPAH33HHH2@Z
_TEXT	SEGMENT
_distortion_lut$2$ = -40				; size = 4
_distortion_lut$1$ = -40				; size = 4
_shift$1$ = -36						; size = 4
_sig_lut$1$ = -32					; size = 4
_width_by2$1$ = -28					; size = 4
_sym$15$ = -24						; size = 4
_sym$14$ = -24						; size = 4
_sym$11$ = -24						; size = 4
_sym$7$ = -24						; size = 4
_sym$3$ = -24						; size = 4
_val$12$ = -24						; size = 4
_val$9$ = -24						; size = 4
_val$6$ = -24						; size = 4
_val$3$ = -24						; size = 4
_val$1$ = -24						; size = 4
_state_ref$7$ = -24					; size = 4
_state_ref$5$ = -24					; size = 4
_state_ref$3$ = -24					; size = 4
tv1465 = -20						; size = 4
_c$1$ = -16						; size = 4
_val$10$ = -12						; size = 4
_val$7$ = -12						; size = 4
_val$4$ = -12						; size = 4
_state_ref$8$ = -12					; size = 4
_state_ref$6$ = -12					; size = 4
_state_ref$4$ = -12					; size = 4
_state_ref$2$ = -12					; size = 4
_state_ref$1$ = -12					; size = 4
tv1460 = -8						; size = 4
tv1458 = -8						; size = 4
tv1457 = -8						; size = 4
tv1456 = -8						; size = 4
tv1455 = -8						; size = 4
tv1454 = -8						; size = 4
tv1451 = -8						; size = 4
tv1450 = -8						; size = 4
tv1449 = -8						; size = 4
tv1448 = -8						; size = 4
tv1447 = -8						; size = 4
tv1446 = -8						; size = 4
tv1445 = -8						; size = 4
tv1444 = -8						; size = 4
tv1443 = -8						; size = 4
tv1442 = -8						; size = 4
_store$1$ = -8						; size = 4
_t$1$ = -4						; size = 4
_coder$ = 8						; size = 4
_states$ = 12						; size = 4
_p$ = 16						; size = 4
_causal$ = 20						; size = 1
_distortion_change$1$ = 24				; size = 4
_orientation$ = 24					; size = 4
_samples$ = 28						; size = 4
_dec_samples$ = 32					; size = 4
_contexts$ = 36						; size = 4
_width$ = 40						; size = 4
_num_stripes$ = 44					; size = 4
_context_row_gap$ = 48					; size = 4
_cword$1$ = 52						; size = 4
_lossless_pass$ = 52					; size = 1
?encode_sig_prop_pass@@YAHAAVmq_encoder@@QAUmqe_state@@H_NHPAH33HHH2@Z PROC ; encode_sig_prop_pass, COMDAT

; 368  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 369  : 	/* Ideally, register storage is available for 12 32-bit integers. Three
; 370  : 	are declared inside the "_mq_check_out_" macro.  The order of priority
; 371  : 	for these registers corresponds roughly to the order in which their
; 372  : 	declarations appear below.  Unfortunately, none of these register
; 373  : 	requests are likely to be honored by the register-starved X86 family
; 374  : 	of processors, but the register declarations may prove useful to
; 375  : 	compilers for other architectures or for hand optimizations of
; 376  : 	assembly code. */
; 377  : 	register kdu_int32 *cp = contexts;
; 378  : 	register int c;
; 379  : 	register kdu_int32 cword;
; 380  : 	_mq_check_out_(coder); // Declares A, C, and t as registers.
; 381  : 	register kdu_int32 sym;
; 382  : 	register kdu_int32 val;
; 383  : 	register kdu_int32 *sp = samples;
; 384  : 	//ohhan
; 385  : 	register kdu_int32 *dec_sp = dec_samples;
; 386  : 	int kx, ky;
; 387  : 	kx = ky = 0;
; 388  : 	register kdu_int32 sign_sample = 0;
; 389  : 	register kdu_int32 shift = 31-p; assert(shift > 0);

	mov	ecx, 31					; 0000001fH

; 394  : 	kdu_int32 *distortion_lut = significance_distortion_lut;

	mov	DWORD PTR _distortion_lut$1$[ebp], OFFSET ?significance_distortion_lut@@3PAHA
	sub	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _shift$1$[ebp], ecx
	mov	ecx, DWORD PTR _orientation$[ebp]
	push	ebx
	push	esi
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 267  :         assert(active && (!checked_out) && MQ_segment); checked_out = true;

	mov	edi, DWORD PTR _coder$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 390  : 	register  kdu_byte *sig_lut = significance_luts[orientation];

	mov	ecx, DWORD PTR ?significance_luts@@3PAPAEA[ecx*4]
	mov	DWORD PTR _sig_lut$1$[ebp], ecx

; 392  : 	int r, width_by2=width+width, width_by3=width_by2+width;

	mov	ecx, DWORD PTR _width$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 269  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	edx, DWORD PTR [edi+8]
	mov	ebx, DWORD PTR [edi]
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR _t$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 392  : 	int r, width_by2=width+width, width_by3=width_by2+width;

	lea	edx, DWORD PTR [ecx+ecx]
	add	ecx, edx
	mov	DWORD PTR _width_by2$1$[ebp], edx

; 395  : 	if (lossless_pass)

	cmp	BYTE PTR _lossless_pass$[ebp], 0
	mov	edx, OFFSET ?significance_distortion_lut_lossless@@3PAHA
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 267  :         assert(active && (!checked_out) && MQ_segment); checked_out = true;

	mov	BYTE PTR [edi+25], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 395  : 	if (lossless_pass)

	cmove	edx, DWORD PTR _distortion_lut$1$[ebp]

; 396  : 		distortion_lut = significance_distortion_lut_lossless;
; 397  : 
; 398  : 	assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 399  : 	for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3, dec_sp += width_by3, kx += 4, ky = 0)

	cmp	DWORD PTR _num_stripes$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 269  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	edi, DWORD PTR [edi+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 395  : 	if (lossless_pass)

	mov	DWORD PTR _distortion_lut$2$[ebp], edx

; 396  : 		distortion_lut = significance_distortion_lut_lossless;
; 397  : 
; 398  : 	assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 399  : 	for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3, dec_sp += width_by3, kx += 4, ky = 0)

	mov	edx, DWORD PTR _t$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 269  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	DWORD PTR _store$1$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 393  : 	kdu_int32 distortion_change = 0;

	mov	DWORD PTR _distortion_change$1$[ebp], 0

; 396  : 		distortion_lut = significance_distortion_lut_lossless;
; 397  : 
; 398  : 	assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 399  : 	for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3, dec_sp += width_by3, kx += 4, ky = 0)

	jle	$LN3@encode_sig
	shl	ecx, 2
	mov	DWORD PTR tv1465[ebp], ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	npad	5
$LL4@encode_sig:

; 400  : 		for (c=width; c > 0; c--, sp++, dec_sp++, cp++, ky++)

	mov	edi, DWORD PTR _width$[ebp]
	test	edi, edi
	mov	DWORD PTR _c$1$[ebp], edi
	mov	edi, DWORD PTR _store$1$[ebp]
	jle	$LN2@encode_sig
$LL7@encode_sig:

; 401  : 		{
; 402  : 			if (*cp == 0)

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	mov	DWORD PTR _cword$1$[ebp], edx
	mov	edx, DWORD PTR _t$1$[ebp]
	jne	SHORT $LN36@encode_sig

; 403  : 			{ // Invoke speedup trick to skip over runs of all-0 neighbourhoods
; 404  : 				for (cp+=3; *cp == 0; cp+=3, c-=3, sp+=3, dec_sp+=3, ky+=3);

	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN9@encode_sig
$LL10@encode_sig:
	sub	DWORD PTR _c$1$[ebp], 3
	add	ecx, 12					; 0000000cH
	add	DWORD PTR _samples$[ebp], 12		; 0000000cH
	add	DWORD PTR _dec_samples$[ebp], 12	; 0000000cH
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LL10@encode_sig
$LN9@encode_sig:

; 405  : 				cp-=3;

	sub	ecx, 12					; 0000000cH

; 406  : 				continue;

	jmp	$LN5@encode_sig
$LN36@encode_sig:

; 407  : 			}
; 408  : 
; 409  : 			//ohhan-Debug
; 410  : 			if (kx == 56 && ky == 21)
; 411  : 				kx +=0;
; 412  : 
; 413  : 			if (&(dec_sp[0]) != &(dec_samples[kx*64+ky]))
; 414  : 				kx += 0;
; 415  : 
; 416  : 			cword = *cp;
; 417  : 			if ((cword & (NBRHD_MASK<<0)) && !(cword & (SIG_PROP_MEMBER_MASK<<0)))

	mov	edx, DWORD PTR _cword$1$[ebp]
	mov	ecx, edx
	and	ecx, 495				; 000001efH
	je	$row_1$271
	test	edx, 2097168				; 00200010H
	jne	$row_1$271

; 418  : 			{ // Process first row of stripe column (row 0)
; 419  : 				state_ref = states+KAPPA_SIG_BASE+sig_lut[cword & NBRHD_MASK];

	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	edx, DWORD PTR [edx+ecx*8]

; 420  : 				val = sp[0]<<shift; // Move bit p to sign bit.

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _state_ref$1$[ebp], edx
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _val$1$[ebp], ecx
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	DWORD PTR _val$1$[ebp], cl

; 421  : 				sym = val & KDU_INT32_MIN;

	mov	ecx, DWORD PTR _val$1$[ebp]
	and	ecx, -2147483648			; 80000000H

; 422  : 				_mq_enc_(coder,sym,*state_ref);

	xor	ecx, DWORD PTR [edx]
	sub	ebx, ecx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN40@encode_sig
	add	esi, ecx
	jmp	$LN12@encode_sig
$LN40@encode_sig:
	test	ecx, ecx
	js	SHORT $LN42@encode_sig
	cmp	ebx, ecx
	jge	SHORT $LN44@encode_sig
	mov	ebx, ecx
	jmp	SHORT $LN45@encode_sig
$LN44@encode_sig:
	add	esi, ecx
$LN45@encode_sig:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1442[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1442[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN259@encode_sig
$LN42@encode_sig:
	and	ebx, 2147483647				; 7fffffffH
	and	ecx, 2147483647				; 7fffffffH
	cmp	ebx, ecx
	jge	SHORT $LN46@encode_sig
	add	esi, ecx
	jmp	SHORT $LN47@encode_sig
$LN46@encode_sig:
	mov	ebx, ecx
$LN47@encode_sig:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1443[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1443[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN259@encode_sig:
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _t$1$[ebp]
	npad	2
$LL13@encode_sig:
	add	ebx, ebx
	add	esi, esi
	sub	edx, 1
	jne	SHORT $LN11@encode_sig
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN49@encode_sig
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	mov	edx, 7
	and	esi, 1048575				; 000fffffH
	jmp	SHORT $LN11@encode_sig
$LN49@encode_sig:
	mov	BYTE PTR [edi], al
	mov	edx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN11@encode_sig:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL13@encode_sig
	mov	DWORD PTR _t$1$[ebp], edx
	mov	DWORD PTR _store$1$[ebp], edi
$LN12@encode_sig:

; 423  : 				if (val >= 0) // New magnitude bit was 0, so still insignificant

	mov	ecx, DWORD PTR _val$1$[ebp]
	test	ecx, ecx
	js	SHORT $LN51@encode_sig

; 424  : 				{ cword |= (PI_BIT<<0); goto row_1; }

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	edx, 1048576				; 00100000H
	mov	DWORD PTR _cword$1$[ebp], edx
	jmp	$row_1$271
$LN51@encode_sig:

; 425  : 				// Compute distortion change
; 426  : 				val =  (val>>(31-DISTORTION_LSBS)) & (SIGNIFICANCE_DISTORTIONS-1);
; 427  : 				distortion_change += distortion_lut[val];

	mov	edi, DWORD PTR _distortion_lut$2$[ebp]
	mov	edx, DWORD PTR _distortion_change$1$[ebp]
	sar	ecx, 26					; 0000001aH
	and	ecx, 31					; 0000001fH
	add	edx, DWORD PTR [edi+ecx*4]

; 428  : 
; 429  : 				//ohhan
; 430  : 				dec_sp[0] |= 1<<p;   //true coefficients

	mov	ecx, DWORD PTR _dec_samples$[ebp]

; 431  : 				dec_sp[0] |= 1<<(p-1); //mid-point reconstruction
; 432  : 				if (sign_sample = (sp[0]&(1<<31))) 

	mov	edi, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], edx
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _p$[ebp]
	bts	edx, ecx
	dec	ecx
	bts	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [ecx]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN53@encode_sig

; 433  : 					dec_sp[0] |= sign_sample;  //sign bit

	or	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ecx], edx
$LN53@encode_sig:

; 434  : 
; 435  : 
; 436  : 				// Encode sign bit
; 437  : 				sym = cword & ((CHI_BIT>>3) | (SIGMA_CC_BIT>>3) |
; 438  : 					(CHI_BIT<<3) | (SIGMA_CC_BIT<<3));
; 439  : 				sym >>= 1; // Shift down so that top sigma bit has address 0
; 440  : 				sym |= (cp[-1] & ((CHI_BIT<<0) | (SIGMA_CC_BIT<<0))) >> (1+1);
; 441  : 				sym |= (cp[ 1] & ((CHI_BIT<<0) | (SIGMA_CC_BIT<<0))) >> (1-1);

	mov	edx, DWORD PTR _contexts$[ebp]
	mov	ecx, DWORD PTR _cword$1$[ebp]
	and	ecx, 17039490				; 01040082H
	mov	edx, DWORD PTR [edx-4]
	sar	edx, 1
	and	edx, 1048584				; 00100008H
	or	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	sar	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 2097168				; 00200010H
	or	edx, ecx

; 442  : 				sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma

	mov	ecx, edx
	sar	ecx, 16					; 00000010H

; 443  : 				val = sign_lut[sym & 0x000000FF];

	or	ecx, edx
	movzx	ecx, cl
	movzx	edx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _sym$3$[ebp], edx

; 444  : 				state_ref = states + KAPPA_SIGN_BASE + (val>>1);

	mov	ecx, edx
	mov	edx, DWORD PTR _states$[ebp]
	sar	ecx, 1
	add	edx, 80					; 00000050H
	lea	ecx, DWORD PTR [edx+ecx*8]

; 445  : 				sym = val << 31; // Get sign flipping to `sym'

	mov	edx, DWORD PTR _sym$3$[ebp]
	mov	DWORD PTR _state_ref$2$[ebp], ecx

; 446  : 				val = sp[0] & KDU_INT32_MIN; // Get the sign bit

	mov	ecx, DWORD PTR _samples$[ebp]
	shl	edx, 31					; 0000001fH
	mov	ecx, DWORD PTR [ecx]
	and	ecx, -2147483648			; 80000000H
	mov	DWORD PTR _val$3$[ebp], ecx

; 447  : 				sym ^= val; // Moves flipped sign bit into `sym'
; 448  : 				_mq_enc_(coder,sym,*state_ref);

	mov	ecx, DWORD PTR _state_ref$2$[ebp]
	mov	ecx, DWORD PTR [ecx]
	xor	ecx, edx
	xor	ecx, DWORD PTR _val$3$[ebp]
	sub	ebx, ecx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN54@encode_sig
	add	esi, ecx
	jmp	$LN15@encode_sig
$LN54@encode_sig:
	test	ecx, ecx
	js	SHORT $LN56@encode_sig
	cmp	ebx, ecx
	jge	SHORT $LN58@encode_sig
	mov	ebx, ecx
	jmp	SHORT $LN59@encode_sig
$LN58@encode_sig:
	add	esi, ecx
$LN59@encode_sig:
	mov	ecx, DWORD PTR _state_ref$2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1444[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1444[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN260@encode_sig
$LN56@encode_sig:
	and	ebx, 2147483647				; 7fffffffH
	and	ecx, 2147483647				; 7fffffffH
	cmp	ebx, ecx
	jge	SHORT $LN60@encode_sig
	add	esi, ecx
	jmp	SHORT $LN61@encode_sig
$LN60@encode_sig:
	mov	ebx, ecx
$LN61@encode_sig:
	mov	ecx, DWORD PTR _state_ref$2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1445[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1445[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN260@encode_sig:
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL16@encode_sig:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN14@encode_sig
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN63@encode_sig
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN14@encode_sig
$LN63@encode_sig:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN14@encode_sig:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL16@encode_sig
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN15@encode_sig:

; 449  : 				// Broadcast neighbourhood context changes; sign bit is in `val'
; 450  : 				cp[-1] |= (SIGMA_CR_BIT<<0);

	mov	edx, DWORD PTR _contexts$[ebp]
	or	DWORD PTR [edx-4], 32			; 00000020H

; 451  : 				cp[1]  |= (SIGMA_CL_BIT<<0);

	or	DWORD PTR [edx+4], 8

; 452  : 				if (val < 0)

	cmp	DWORD PTR _val$3$[ebp], 0
	jge	SHORT $LN65@encode_sig

; 453  : 				{
; 454  : 					cword |= (SIGMA_CC_BIT<<0) | (PI_BIT<<0) | (CHI_BIT<<0);

	or	DWORD PTR _cword$1$[ebp], 3145744	; 00300010H

; 455  : 					if (!causal)

	cmp	BYTE PTR _causal$[ebp], 0
	jne	SHORT $LN258@encode_sig

; 456  : 					{
; 457  : 						cp[-context_row_gap-1] |= (SIGMA_BR_BIT<<9);

	mov	ecx, DWORD PTR _context_row_gap$[ebp]
	shl	ecx, 2
	sub	edx, ecx
	or	DWORD PTR [edx-4], 131072		; 00020000H

; 458  : 						cp[-context_row_gap  ] |= (SIGMA_BC_BIT<<9) | NEXT_CHI_BIT;

	or	DWORD PTR [edx], -2147418112		; 80010000H

; 459  : 						cp[-context_row_gap+1] |= (SIGMA_BL_BIT<<9);
; 460  : 					}
; 461  : 				}
; 462  : 				else

	jmp	SHORT $LN269@encode_sig
$LN65@encode_sig:

; 463  : 				{
; 464  : 					cword |= (SIGMA_CC_BIT<<0) | (PI_BIT<<0);

	or	DWORD PTR _cword$1$[ebp], 1048592	; 00100010H

; 465  : 					if (!causal)

	cmp	BYTE PTR _causal$[ebp], 0
	jne	SHORT $LN258@encode_sig

; 466  : 					{
; 467  : 						cp[-context_row_gap-1] |= (SIGMA_BR_BIT<<9);

	mov	ecx, DWORD PTR _context_row_gap$[ebp]
	shl	ecx, 2
	sub	edx, ecx
	or	DWORD PTR [edx-4], 131072		; 00020000H

; 468  : 						cp[-context_row_gap  ] |= (SIGMA_BC_BIT<<9);

	or	DWORD PTR [edx], 65536			; 00010000H
$LN269@encode_sig:

; 469  : 						cp[-context_row_gap+1] |= (SIGMA_BL_BIT<<9);

	or	DWORD PTR [edx+4], 32768		; 00008000H
$LN258@encode_sig:
	mov	edx, DWORD PTR _cword$1$[ebp]
$row_1$271:

; 470  : 					}
; 471  : 				}
; 472  : 			}
; 473  : row_1:
; 474  : 			if ((cword & (NBRHD_MASK<<3)) && !(cword & (SIG_PROP_MEMBER_MASK<<3)))

	test	edx, 3960				; 00000f78H
	je	$row_2$272
	test	edx, 16777344				; 01000080H
	jne	$row_2$272

; 475  : 			{ // Process second row of stripe column (row 1)
; 476  : 				state_ref = states+KAPPA_SIG_BASE+sig_lut[(cword>>3) & NBRHD_MASK];
; 477  : 				val = sp[width]<<shift; // Move bit p to sign bit.

	mov	edi, DWORD PTR _width$[ebp]
	mov	ecx, edx
	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	sar	ecx, 3
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _state_ref$3$[ebp], edx
	mov	ecx, DWORD PTR [ecx+edi*4]

; 478  : 				sym = val & KDU_INT32_MIN;
; 479  : 				_mq_enc_(coder,sym,*state_ref);

	mov	edi, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _val$4$[ebp], ecx
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	DWORD PTR _val$4$[ebp], cl
	mov	ecx, DWORD PTR _val$4$[ebp]
	and	ecx, -2147483648			; 80000000H
	xor	ecx, DWORD PTR [edx]
	sub	ebx, ecx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN70@encode_sig
	add	esi, ecx
	jmp	$LN18@encode_sig
$LN70@encode_sig:
	test	ecx, ecx
	js	SHORT $LN72@encode_sig
	cmp	ebx, ecx
	jge	SHORT $LN74@encode_sig
	mov	ebx, ecx
	jmp	SHORT $LN75@encode_sig
$LN74@encode_sig:
	add	esi, ecx
$LN75@encode_sig:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1446[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1446[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN261@encode_sig
$LN72@encode_sig:
	and	ebx, 2147483647				; 7fffffffH
	and	ecx, 2147483647				; 7fffffffH
	cmp	ebx, ecx
	jge	SHORT $LN76@encode_sig
	add	esi, ecx
	jmp	SHORT $LN77@encode_sig
$LN76@encode_sig:
	mov	ebx, ecx
$LN77@encode_sig:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1447[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1447[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN261@encode_sig:
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
	npad	4
$LL19@encode_sig:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN17@encode_sig
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN79@encode_sig
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN17@encode_sig
$LN79@encode_sig:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN17@encode_sig:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL19@encode_sig
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN18@encode_sig:

; 480  : 				if (val >= 0) // New magnitude bit was 0, so still insignificant

	mov	ecx, DWORD PTR _val$4$[ebp]
	test	ecx, ecx
	js	SHORT $LN81@encode_sig

; 481  : 				{ cword |= (PI_BIT<<3); goto row_2; }

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	edx, 8388608				; 00800000H
	jmp	$LN262@encode_sig
$LN81@encode_sig:

; 482  : 				// Compute distortion change
; 483  : 				val =  (val>>(31-DISTORTION_LSBS)) & (SIGNIFICANCE_DISTORTIONS-1);
; 484  : 				distortion_change += distortion_lut[val];

	mov	edi, DWORD PTR _distortion_lut$2$[ebp]
	mov	edx, DWORD PTR _distortion_change$1$[ebp]
	sar	ecx, 26					; 0000001aH
	and	ecx, 31					; 0000001fH
	add	edx, DWORD PTR [edi+ecx*4]

; 485  : 
; 486  : 				//ohhan
; 487  : 				dec_sp[width] |= 1<<p;   //true coefficients

	mov	edi, DWORD PTR _width$[ebp]
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], edx
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR _p$[ebp]
	bts	edx, ecx

; 488  : 				dec_sp[width] |= 1<<(p-1); //mid-point reconstruction

	dec	ecx
	bts	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ecx+edi*4], edx

; 489  : 				if (sign_sample = (sp[width]&(1<<31))) 

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN83@encode_sig

; 490  : 					dec_sp[width] |= sign_sample;  //sign bit

	or	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ecx+edi*4], edx
$LN83@encode_sig:

; 491  : 
; 492  : 
; 493  : 				// Encode sign bit
; 494  : 				sym = cword & ((CHI_BIT<<0) | (SIGMA_CC_BIT<<0) |
; 495  : 					(CHI_BIT<<6) | (SIGMA_CC_BIT<<6));
; 496  : 				sym >>= 4; // Shift down so that top sigma bit has address 0
; 497  : 				sym |= (cp[-1] & ((CHI_BIT<<3) | (SIGMA_CC_BIT<<3))) >> (4+1);
; 498  : 				sym |= (cp[ 1] & ((CHI_BIT<<3) | (SIGMA_CC_BIT<<3))) >> (4-1);

	mov	ecx, DWORD PTR _contexts$[ebp]

; 499  : 				sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma
; 500  : 				val = sign_lut[sym & 0x000000FF];
; 501  : 				state_ref = states + KAPPA_SIGN_BASE + (val>>1);
; 502  : 				sym = val << 31; // Get sign flipping to `sym'
; 503  : 				val = sp[width] & KDU_INT32_MIN; // Get the sign bit

	mov	edi, DWORD PTR _width$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR _cword$1$[ebp]
	and	ecx, 136315920				; 08200410H
	sar	edx, 1
	and	edx, 8388672				; 00800040H
	or	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	sar	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 16777344				; 01000080H
	or	edx, ecx
	sar	edx, 3
	mov	ecx, edx
	sar	ecx, 16					; 00000010H
	or	ecx, edx
	movzx	ecx, cl
	movzx	edx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _sym$7$[ebp], edx
	mov	ecx, edx
	mov	edx, DWORD PTR _states$[ebp]
	sar	ecx, 1
	add	edx, 80					; 00000050H
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _sym$7$[ebp]
	mov	DWORD PTR _state_ref$4$[ebp], ecx
	mov	ecx, DWORD PTR _samples$[ebp]
	shl	edx, 31					; 0000001fH
	mov	ecx, DWORD PTR [ecx+edi*4]

; 504  : 				sym ^= val; // Moves flipped sign bit into `sym'
; 505  : 				_mq_enc_(coder,sym,*state_ref);

	mov	edi, DWORD PTR _store$1$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	DWORD PTR _val$6$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$4$[ebp]
	mov	ecx, DWORD PTR [ecx]
	xor	ecx, edx
	xor	ecx, DWORD PTR _val$6$[ebp]
	sub	ebx, ecx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN84@encode_sig
	add	esi, ecx
	jmp	$LN21@encode_sig
$LN84@encode_sig:
	test	ecx, ecx
	js	SHORT $LN86@encode_sig
	cmp	ebx, ecx
	jge	SHORT $LN88@encode_sig
	mov	ebx, ecx
	jmp	SHORT $LN89@encode_sig
$LN88@encode_sig:
	add	esi, ecx
$LN89@encode_sig:
	mov	ecx, DWORD PTR _state_ref$4$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1448[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1448[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN263@encode_sig
$LN86@encode_sig:
	and	ebx, 2147483647				; 7fffffffH
	and	ecx, 2147483647				; 7fffffffH
	cmp	ebx, ecx
	jge	SHORT $LN90@encode_sig
	add	esi, ecx
	jmp	SHORT $LN91@encode_sig
$LN90@encode_sig:
	mov	ebx, ecx
$LN91@encode_sig:
	mov	ecx, DWORD PTR _state_ref$4$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1449[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1449[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN263@encode_sig:
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL22@encode_sig:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN20@encode_sig
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN93@encode_sig
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN20@encode_sig
$LN93@encode_sig:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN20@encode_sig:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL22@encode_sig
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN21@encode_sig:

; 506  : 				// Broadcast neighbourhood context changes; sign bit is in `val'
; 507  : 				cp[-1] |= (SIGMA_CR_BIT<<3);

	mov	ecx, DWORD PTR _contexts$[ebp]

; 508  : 				cp[1]  |= (SIGMA_CL_BIT<<3);
; 509  : 				cword |= (SIGMA_CC_BIT<<3) | (PI_BIT<<3);
; 510  : 				val = (kdu_int32)(((kdu_uint32) val)>>(31-(CHI_POS+3))); // SRL
; 511  : 				cword |= val;

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	DWORD PTR [ecx-4], 256			; 00000100H
	or	DWORD PTR [ecx+4], 64			; 00000040H
	mov	ecx, DWORD PTR _val$6$[ebp]
	or	ecx, 1073758208				; 40004000H
	shr	ecx, 7
	or	edx, ecx
$LN262@encode_sig:
	mov	DWORD PTR _cword$1$[ebp], edx
$row_2$272:

; 512  : 			}
; 513  : row_2:
; 514  : 			if ((cword & (NBRHD_MASK<<6)) && !(cword & (SIG_PROP_MEMBER_MASK<<6)))

	test	edx, 31680				; 00007bc0H
	je	$row_3$273
	test	edx, 134218752				; 08000400H
	jne	$row_3$273

; 515  : 			{ // Process third row of stripe column (row 2)
; 516  : 				state_ref = states+KAPPA_SIG_BASE+sig_lut[(cword>>6) & NBRHD_MASK];
; 517  : 				val = sp[width_by2]<<shift; // Move bit p to sign bit.

	mov	edi, DWORD PTR _width_by2$1$[ebp]
	mov	ecx, edx
	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	sar	ecx, 6
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _state_ref$5$[ebp], edx
	mov	ecx, DWORD PTR [ecx+edi*4]

; 518  : 				sym = val & KDU_INT32_MIN;
; 519  : 				_mq_enc_(coder,sym,*state_ref);

	mov	edi, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _val$7$[ebp], ecx
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	DWORD PTR _val$7$[ebp], cl
	mov	ecx, DWORD PTR _val$7$[ebp]
	and	ecx, -2147483648			; 80000000H
	xor	ecx, DWORD PTR [edx]
	sub	ebx, ecx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN96@encode_sig
	add	esi, ecx
	jmp	$LN24@encode_sig
$LN96@encode_sig:
	test	ecx, ecx
	js	SHORT $LN98@encode_sig
	cmp	ebx, ecx
	jge	SHORT $LN100@encode_sig
	mov	ebx, ecx
	jmp	SHORT $LN101@encode_sig
$LN100@encode_sig:
	add	esi, ecx
$LN101@encode_sig:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1450[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1450[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN264@encode_sig
$LN98@encode_sig:
	and	ebx, 2147483647				; 7fffffffH
	and	ecx, 2147483647				; 7fffffffH
	cmp	ebx, ecx
	jge	SHORT $LN102@encode_sig
	add	esi, ecx
	jmp	SHORT $LN103@encode_sig
$LN102@encode_sig:
	mov	ebx, ecx
$LN103@encode_sig:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1451[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1451[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN264@encode_sig:
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL25@encode_sig:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN23@encode_sig
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN105@encode_sig
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN23@encode_sig
$LN105@encode_sig:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN23@encode_sig:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL25@encode_sig
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN24@encode_sig:

; 520  : 				if (val >= 0) // New magnitude bit was 0, so still insignificant

	mov	ecx, DWORD PTR _val$7$[ebp]
	test	ecx, ecx
	js	SHORT $LN107@encode_sig

; 521  : 				{ cword |= (PI_BIT<<6); goto row_3; }

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	edx, 67108864				; 04000000H
	jmp	$LN265@encode_sig
$LN107@encode_sig:

; 522  : 				// Compute distortion change
; 523  : 				val =  (val>>(31-DISTORTION_LSBS)) & (SIGNIFICANCE_DISTORTIONS-1);
; 524  : 				distortion_change += distortion_lut[val];

	mov	edi, DWORD PTR _distortion_lut$2$[ebp]
	mov	edx, DWORD PTR _distortion_change$1$[ebp]
	sar	ecx, 26					; 0000001aH
	and	ecx, 31					; 0000001fH
	add	edx, DWORD PTR [edi+ecx*4]

; 525  : 
; 526  : 				//ohhan
; 527  : 				dec_sp[width_by2] |= 1<<p;   //true coefficients

	mov	edi, DWORD PTR _width_by2$1$[ebp]
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], edx
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR _p$[ebp]
	bts	edx, ecx

; 528  : 				dec_sp[width_by2] |= 1<<(p-1); //mid-point reconstruction

	dec	ecx
	bts	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ecx+edi*4], edx

; 529  : 				if (sign_sample = (sp[width_by2]&(1<<31))) 

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN109@encode_sig

; 530  : 					dec_sp[width_by2] |= sign_sample;  //sign bit

	or	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [ecx+edi*4], edx
$LN109@encode_sig:

; 531  : 
; 532  : 
; 533  : 				// Encode sign bit
; 534  : 				sym = cword & ((CHI_BIT<<3) | (SIGMA_CC_BIT<<3) |
; 535  : 					(CHI_BIT<<9) | (SIGMA_CC_BIT<<9));
; 536  : 				sym >>= 7; // Shift down so that top sigma bit has address 0
; 537  : 				sym |= (cp[-1] & ((CHI_BIT<<6) | (SIGMA_CC_BIT<<6))) >> (7+1);
; 538  : 				sym |= (cp[ 1] & ((CHI_BIT<<6) | (SIGMA_CC_BIT<<6))) >> (7-1);

	mov	ecx, DWORD PTR _contexts$[ebp]

; 539  : 				sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma
; 540  : 				val = sign_lut[sym & 0x000000FF];
; 541  : 				state_ref = states + KAPPA_SIGN_BASE + (val>>1);
; 542  : 				sym = val << 31; // Get sign flipping to `sym'
; 543  : 				val = sp[width_by2] & KDU_INT32_MIN; // Get the sign bit

	mov	edi, DWORD PTR _width_by2$1$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR _cword$1$[ebp]
	and	ecx, 1090527360				; 41002080H
	sar	edx, 1
	and	edx, 67109376				; 04000200H
	or	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	sar	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 134218752				; 08000400H
	or	edx, ecx
	sar	edx, 6
	mov	ecx, edx
	sar	ecx, 16					; 00000010H
	or	ecx, edx
	movzx	ecx, cl
	movzx	edx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _sym$11$[ebp], edx
	mov	ecx, edx
	mov	edx, DWORD PTR _states$[ebp]
	sar	ecx, 1
	add	edx, 80					; 00000050H
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _sym$11$[ebp]
	mov	DWORD PTR _state_ref$6$[ebp], ecx
	mov	ecx, DWORD PTR _samples$[ebp]
	shl	edx, 31					; 0000001fH
	mov	ecx, DWORD PTR [ecx+edi*4]

; 544  : 				sym ^= val; // Moves flipped sign bit into `sym'
; 545  : 				_mq_enc_(coder,sym,*state_ref);

	mov	edi, DWORD PTR _store$1$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	DWORD PTR _val$9$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$6$[ebp]
	mov	ecx, DWORD PTR [ecx]
	xor	ecx, edx
	xor	ecx, DWORD PTR _val$9$[ebp]
	sub	ebx, ecx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN110@encode_sig
	add	esi, ecx
	jmp	$LN27@encode_sig
$LN110@encode_sig:
	test	ecx, ecx
	js	SHORT $LN112@encode_sig
	cmp	ebx, ecx
	jge	SHORT $LN114@encode_sig
	mov	ebx, ecx
	jmp	SHORT $LN115@encode_sig
$LN114@encode_sig:
	add	esi, ecx
$LN115@encode_sig:
	mov	ecx, DWORD PTR _state_ref$6$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1454[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1454[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN266@encode_sig
$LN112@encode_sig:
	and	ebx, 2147483647				; 7fffffffH
	and	ecx, 2147483647				; 7fffffffH
	cmp	ebx, ecx
	jge	SHORT $LN116@encode_sig
	add	esi, ecx
	jmp	SHORT $LN117@encode_sig
$LN116@encode_sig:
	mov	ebx, ecx
$LN117@encode_sig:
	mov	ecx, DWORD PTR _state_ref$6$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1455[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1455[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN266@encode_sig:
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
	npad	6
$LL28@encode_sig:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN26@encode_sig
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN119@encode_sig
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN26@encode_sig
$LN119@encode_sig:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN26@encode_sig:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL28@encode_sig
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN27@encode_sig:

; 546  : 				// Broadcast neighbourhood context changes; sign bit is in `val'
; 547  : 				cp[-1] |= (SIGMA_CR_BIT<<6);

	mov	ecx, DWORD PTR _contexts$[ebp]

; 548  : 				cp[1]  |= (SIGMA_CL_BIT<<6);
; 549  : 				cword |= (SIGMA_CC_BIT<<6) | (PI_BIT<<6);
; 550  : 				val = (kdu_int32)(((kdu_uint32) val)>>(31-(CHI_POS+6))); // SRL
; 551  : 				cword |= val;

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	DWORD PTR [ecx-4], 2048			; 00000800H
	or	DWORD PTR [ecx+4], 512			; 00000200H
	mov	ecx, DWORD PTR _val$9$[ebp]
	or	ecx, 1073758208				; 40004000H
	shr	ecx, 4
	or	edx, ecx
$LN265@encode_sig:
	mov	DWORD PTR _cword$1$[ebp], edx
$row_3$273:

; 552  : 			}
; 553  : row_3:
; 554  : 			if ((cword & (NBRHD_MASK<<9)) && !(cword & (SIG_PROP_MEMBER_MASK<<9)))

	test	edx, 253440				; 0003de00H
	je	$LN256@encode_sig
	test	edx, 1073750016				; 40002000H
	jne	$LN256@encode_sig

; 555  : 			{ // Process fourth row of stripe column (row 3)
; 556  : 				state_ref = states+KAPPA_SIG_BASE+sig_lut[(cword>>9) & NBRHD_MASK];
; 557  : 				val = sp[width_by3]<<shift; // Move bit p to sign bit.

	mov	edi, DWORD PTR tv1465[ebp]
	mov	ecx, edx
	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	sar	ecx, 9
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _state_ref$7$[ebp], edx
	mov	ecx, DWORD PTR [edi+ecx]

; 558  : 				sym = val & KDU_INT32_MIN;
; 559  : 				_mq_enc_(coder,sym,*state_ref);

	mov	edi, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _val$10$[ebp], ecx
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	DWORD PTR _val$10$[ebp], cl
	mov	ecx, DWORD PTR _val$10$[ebp]
	and	ecx, -2147483648			; 80000000H
	xor	ecx, DWORD PTR [edx]
	sub	ebx, ecx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN122@encode_sig
	add	esi, ecx
	jmp	$LN30@encode_sig
$LN122@encode_sig:
	test	ecx, ecx
	js	SHORT $LN124@encode_sig
	cmp	ebx, ecx
	jge	SHORT $LN126@encode_sig
	mov	ebx, ecx
	jmp	SHORT $LN127@encode_sig
$LN126@encode_sig:
	add	esi, ecx
$LN127@encode_sig:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1456[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1456[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN267@encode_sig
$LN124@encode_sig:
	and	ebx, 2147483647				; 7fffffffH
	and	ecx, 2147483647				; 7fffffffH
	cmp	ebx, ecx
	jge	SHORT $LN128@encode_sig
	add	esi, ecx
	jmp	SHORT $LN129@encode_sig
$LN128@encode_sig:
	mov	ebx, ecx
$LN129@encode_sig:
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR tv1457[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1457[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN267@encode_sig:
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
	npad	7
$LL31@encode_sig:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN29@encode_sig
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN131@encode_sig
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN29@encode_sig
$LN131@encode_sig:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN29@encode_sig:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL31@encode_sig
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN30@encode_sig:

; 560  : 				if (val >= 0) // New magnitude bit was 0, so still insignificant

	mov	ecx, DWORD PTR _val$10$[ebp]
	test	ecx, ecx
	js	SHORT $LN133@encode_sig

; 561  : 				{ cword |= (PI_BIT<<9); goto done; }

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	edx, 536870912				; 20000000H
$LN256@encode_sig:
	mov	ecx, DWORD PTR _contexts$[ebp]
$done$274:

; 602  : 				}
; 603  : 			}
; 604  : done:
; 605  : 			*cp = cword;

	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR _t$1$[ebp]
$LN5@encode_sig:

; 400  : 		for (c=width; c > 0; c--, sp++, dec_sp++, cp++, ky++)

	dec	DWORD PTR _c$1$[ebp]
	add	ecx, 4
	add	DWORD PTR _samples$[ebp], 4
	add	DWORD PTR _dec_samples$[ebp], 4
	cmp	DWORD PTR _c$1$[ebp], 0
	mov	DWORD PTR _contexts$[ebp], ecx
	jg	$LL7@encode_sig
$LN2@encode_sig:

; 396  : 		distortion_lut = significance_distortion_lut_lossless;
; 397  : 
; 398  : 	assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 399  : 	for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3, dec_sp += width_by3, kx += 4, ky = 0)

	mov	edi, DWORD PTR tv1465[ebp]
	add	ecx, 12					; 0000000cH
	dec	DWORD PTR _num_stripes$[ebp]
	add	DWORD PTR _samples$[ebp], edi
	add	DWORD PTR _dec_samples$[ebp], edi
	cmp	DWORD PTR _num_stripes$[ebp], 0
	mov	edi, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _contexts$[ebp], ecx
	jg	$LL4@encode_sig
$LN3@encode_sig:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 279  :         assert(active && checked_out && MQ_segment); checked_out = false;

	mov	ecx, DWORD PTR _coder$[ebp]

; 281  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+20], edi
	pop	edi

; 280  :         this->A = A; this->C = C;

	mov	DWORD PTR [ecx+4], esi
	pop	esi
	mov	DWORD PTR [ecx], ebx

; 281  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+12], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 608  : 		return distortion_change;

	mov	eax, DWORD PTR _distortion_change$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 279  :         assert(active && checked_out && MQ_segment); checked_out = false;

	mov	BYTE PTR [ecx+25], 0

; 281  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+8], edx
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 609  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN133@encode_sig:

; 562  : 				// Compute distortion change
; 563  : 				val =  (val>>(31-DISTORTION_LSBS)) & (SIGNIFICANCE_DISTORTIONS-1);
; 564  : 				distortion_change += distortion_lut[val];

	mov	edi, DWORD PTR _distortion_lut$2$[ebp]
	mov	edx, DWORD PTR _distortion_change$1$[ebp]
	sar	ecx, 26					; 0000001aH
	and	ecx, 31					; 0000001fH
	add	edx, DWORD PTR [edi+ecx*4]

; 565  : 
; 566  : 				//ohhan
; 567  : 				dec_sp[width_by3] |= 1<<p;   //true coefficients

	mov	edi, DWORD PTR tv1465[ebp]
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], edx
	mov	edx, DWORD PTR [edi+ecx]
	mov	ecx, DWORD PTR _p$[ebp]
	bts	edx, ecx

; 568  : 				dec_sp[width_by3] |= 1<<(p-1); //mid-point reconstruction

	dec	ecx
	bts	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [edi+ecx], edx

; 569  : 				if (sign_sample = (sp[width_by3]&(1<<31))) 

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [edi+ecx]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN135@encode_sig

; 570  : 					dec_sp[width_by3] |= sign_sample;  //sign bit

	or	edx, ecx
	mov	ecx, DWORD PTR _dec_samples$[ebp]
	mov	DWORD PTR [edi+ecx], edx
$LN135@encode_sig:

; 571  : 
; 572  : 
; 573  : 				// Encode sign bit
; 574  : 				sym = cword & ((CHI_BIT<<6) | (SIGMA_CC_BIT<<6) |
; 575  : 					0       | (SIGMA_CC_BIT<<12));
; 576  : 				sym >>= 10; // Shift down so that top sigma bit has address 0

	mov	edx, DWORD PTR _cword$1$[ebp]
	mov	ecx, edx
	sar	ecx, 10					; 0000000aH
	and	ecx, 131137				; 00020041H
	mov	DWORD PTR _sym$14$[ebp], ecx

; 577  : 				if (cword < 0) // Use the fact that NEXT_CHI_BIT = 31

	test	edx, edx
	jns	SHORT $LN136@encode_sig

; 578  : 					sym |= CHI_BIT<<(12-10);

	or	ecx, 8388608				; 00800000H
	mov	DWORD PTR _sym$14$[ebp], ecx
$LN136@encode_sig:

; 579  : 				sym |= (cp[-1] & ((CHI_BIT<<9) | (SIGMA_CC_BIT<<9))) >> (10+1);
; 580  : 				sym |= (cp[ 1] & ((CHI_BIT<<9) | (SIGMA_CC_BIT<<9))) >> (10-1);

	mov	ecx, DWORD PTR _contexts$[ebp]

; 581  : 				sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma
; 582  : 				val = sign_lut[sym & 0x000000FF];
; 583  : 				state_ref = states + KAPPA_SIGN_BASE + (val>>1);
; 584  : 				sym = val << 31; // Get sign flipping to `sym'
; 585  : 				val = sp[width_by3] & KDU_INT32_MIN; // Get the sign bit

	mov	edi, DWORD PTR tv1465[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 1073750016				; 40002000H
	sar	edx, 2
	and	edx, 268437504				; 10000800H
	or	edx, ecx
	mov	ecx, DWORD PTR _sym$14$[ebp]
	sar	edx, 9
	or	ecx, edx
	mov	DWORD PTR _sym$14$[ebp], ecx
	sar	ecx, 16					; 00000010H
	or	ecx, DWORD PTR _sym$14$[ebp]
	movzx	ecx, cl
	movzx	edx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _sym$15$[ebp], edx
	mov	ecx, edx
	mov	edx, DWORD PTR _states$[ebp]
	sar	ecx, 1
	add	edx, 80					; 00000050H
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _sym$15$[ebp]
	mov	DWORD PTR _state_ref$8$[ebp], ecx
	mov	ecx, DWORD PTR _samples$[ebp]
	shl	edx, 31					; 0000001fH
	mov	ecx, DWORD PTR [edi+ecx]

; 586  : 				sym ^= val; // Moves flipped sign bit into `sym'
; 587  : 				_mq_enc_(coder,sym,*state_ref);

	mov	edi, DWORD PTR _store$1$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	DWORD PTR _val$12$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$8$[ebp]
	mov	ecx, DWORD PTR [ecx]
	xor	ecx, edx
	xor	ecx, DWORD PTR _val$12$[ebp]
	sub	ebx, ecx
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LN137@encode_sig
	add	esi, ecx
	jmp	$LN33@encode_sig
$LN137@encode_sig:
	test	ecx, ecx
	js	SHORT $LN139@encode_sig
	cmp	ebx, ecx
	jge	SHORT $LN141@encode_sig
	mov	ebx, ecx
	jmp	SHORT $LN142@encode_sig
$LN141@encode_sig:
	add	esi, ecx
$LN142@encode_sig:
	mov	ecx, DWORD PTR _state_ref$8$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1458[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1458[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN268@encode_sig
$LN139@encode_sig:
	and	ebx, 2147483647				; 7fffffffH
	and	ecx, 2147483647				; 7fffffffH
	cmp	ebx, ecx
	jge	SHORT $LN143@encode_sig
	add	esi, ecx
	jmp	SHORT $LN144@encode_sig
$LN143@encode_sig:
	mov	ebx, ecx
$LN144@encode_sig:
	mov	ecx, DWORD PTR _state_ref$8$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1460[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1460[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN268@encode_sig:
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL34@encode_sig:
	add	ebx, ebx
	add	esi, esi
	sub	ecx, 1
	jne	SHORT $LN32@encode_sig
	mov	ecx, esi
	sar	ecx, 27					; 0000001bH
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN146@encode_sig
	or	eax, 254				; 000000feH
	mov	BYTE PTR [edi], 255			; 000000ffH
	mov	ecx, esi
	sar	eax, 1
	sar	ecx, 20					; 00000014H
	inc	edi
	and	eax, ecx
	and	esi, 1048575				; 000fffffH
	mov	ecx, 7
	jmp	SHORT $LN32@encode_sig
$LN146@encode_sig:
	mov	BYTE PTR [edi], al
	mov	ecx, 8
	mov	eax, esi
	inc	edi
	sar	eax, 19					; 00000013H
	and	esi, 524287				; 0007ffffH
	movzx	eax, al
$LN32@encode_sig:
	cmp	ebx, 32768				; 00008000H
	jl	SHORT $LL34@encode_sig
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	DWORD PTR _store$1$[ebp], edi
$LN33@encode_sig:

; 588  : 				// Broadcast neighbourhood context changes; sign bit is in `val'
; 589  : 				cp[context_row_gap-1] |= SIGMA_TR_BIT;

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	edx, DWORD PTR _context_row_gap$[ebp]
	or	DWORD PTR [ecx+edx*4-4], 4

; 590  : 				cp[context_row_gap+1] |= SIGMA_TL_BIT;

	or	DWORD PTR [ecx+edx*4+4], 1

; 591  : 				cp[-1] |= (SIGMA_CR_BIT<<9);

	or	DWORD PTR [ecx-4], 16384		; 00004000H

; 592  : 				cp[1]  |= (SIGMA_CL_BIT<<9);

	or	DWORD PTR [ecx+4], 4096			; 00001000H

; 593  : 				if (val < 0)

	cmp	DWORD PTR _val$12$[ebp], 0
	jge	SHORT $LN148@encode_sig

; 594  : 				{
; 595  : 					cp[context_row_gap  ] |= SIGMA_TC_BIT | PREV_CHI_BIT;

	or	DWORD PTR [ecx+edx*4], 262146		; 00040002H

; 596  : 					cword |= (SIGMA_CC_BIT<<9) | (PI_BIT<<9) | (CHI_BIT<<9);

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	edx, 1610620928				; 60002000H

; 597  : 				}
; 598  : 				else

	jmp	$done$274
$LN148@encode_sig:

; 599  : 				{
; 600  : 					cp[context_row_gap  ] |= SIGMA_TC_BIT;

	or	DWORD PTR [ecx+edx*4], 2

; 601  : 					cword |= (SIGMA_CC_BIT<<9) | (PI_BIT<<9);

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	edx, 536879104				; 20002000H
	jmp	$done$274
?encode_sig_prop_pass@@YAHAAVmq_encoder@@QAUmqe_state@@H_NHPAH33HHH2@Z ENDP ; encode_sig_prop_pass
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?encode_sig_prop_pass_raw@@YAHAAVmq_encoder@@H_NPAH2HHH1@Z
_TEXT	SEGMENT
_sym$7$ = -28						; size = 4
_sym$5$ = -28						; size = 4
_sym$3$ = -28						; size = 4
_sym$1$ = -28						; size = 4
_c$1$ = -24						; size = 4
_distortion_lut$1$ = -24				; size = 4
_width_by2$1$ = -20					; size = 4
tv704 = -16						; size = 4
_distortion_lut$2$ = -12				; size = 4
_shift$1$ = -8						; size = 4
_store$1$ = -4						; size = 4
_coder$ = 8						; size = 4
_distortion_change$1$ = 12				; size = 4
_p$ = 12						; size = 4
_causal$ = 16						; size = 1
_samples$ = 20						; size = 4
_contexts$ = 24						; size = 4
_width$ = 28						; size = 4
_num_stripes$ = 32					; size = 4
_context_row_gap$ = 36					; size = 4
_sym$8$ = 40						; size = 4
_sym$6$ = 40						; size = 4
_sym$4$ = 40						; size = 4
_sym$2$ = 40						; size = 4
_val$4$ = 40						; size = 4
_val$3$ = 40						; size = 4
_val$2$ = 40						; size = 4
_val$1$ = 40						; size = 4
_lossless_pass$ = 40					; size = 1
?encode_sig_prop_pass_raw@@YAHAAVmq_encoder@@H_NPAH2HHH1@Z PROC ; encode_sig_prop_pass_raw, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 234  :   /* Ideally, register storage is available for 9 32-bit integers. Two
; 235  :      are declared inside the "_raw_check_out_" macro.  The order of priority
; 236  :      for these registers corresponds roughly to the order in which their
; 237  :      declarations appear below.  Unfortunately, none of these register
; 238  :      requests are likely to be honored by the register-starved X86 family
; 239  :      of processors, but the register declarations may prove useful to
; 240  :      compilers for other architectures or for hand optimizations of
; 241  :      assembly code. */
; 242  :   register kdu_int32 *cp = contexts;
; 243  :   register int c;
; 244  :   register kdu_int32 cword;
; 245  :   _raw_check_out_(coder); // Declares t and temp as registers.
; 246  :   register kdu_int32 sym;
; 247  :   register kdu_int32 val;
; 248  :   register kdu_int32 *sp = samples;
; 249  :   register kdu_int32 shift = 31-p; assert(shift > 0);

	mov	ecx, 31					; 0000001fH

; 252  :   kdu_int32 *distortion_lut = significance_distortion_lut;

	mov	DWORD PTR _distortion_lut$1$[ebp], OFFSET ?significance_distortion_lut@@3PAHA
	sub	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _shift$1$[ebp], ecx
	mov	ecx, DWORD PTR _width$[ebp]
	push	ebx
	push	esi
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 273  :         assert(active && (!checked_out) && !MQ_segment); checked_out = true;

	mov	edi, DWORD PTR _coder$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 250  :   int r, width_by2=width+width, width_by3=width_by2+width;

	lea	edx, DWORD PTR [ecx+ecx]
	add	ecx, edx
	mov	DWORD PTR _width_by2$1$[ebp], edx

; 251  :   kdu_int32 distortion_change = 0;

	xor	esi, esi

; 253  :   if (lossless_pass)

	mov	edx, OFFSET ?significance_distortion_lut_lossless@@3PAHA
	cmp	BYTE PTR _lossless_pass$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 274  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	eax, DWORD PTR [edi+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 253  :   if (lossless_pass)

	cmove	edx, DWORD PTR _distortion_lut$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 274  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	ebx, DWORD PTR [edi+12]
	mov	BYTE PTR [edi+25], 1
	mov	edi, DWORD PTR [edi+20]
	mov	DWORD PTR _store$1$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 251  :   kdu_int32 distortion_change = 0;

	mov	DWORD PTR _distortion_change$1$[ebp], esi

; 253  :   if (lossless_pass)

	mov	DWORD PTR _distortion_lut$2$[ebp], edx

; 254  :     distortion_lut = significance_distortion_lut_lossless;
; 255  : 
; 256  :   assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 257  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3)

	cmp	DWORD PTR _num_stripes$[ebp], esi
	jle	$LN3@encode_sig
	mov	edx, DWORD PTR _contexts$[ebp]
	mov	esi, DWORD PTR _width$[ebp]
	shl	ecx, 2
	mov	DWORD PTR tv704[ebp], ecx
	mov	ecx, DWORD PTR _samples$[ebp]
	npad	10
$LL4@encode_sig:

; 258  :     for (c=width; c > 0; c--, sp++, cp++)

	mov	DWORD PTR _c$1$[ebp], esi
	test	esi, esi
	jle	$LN2@encode_sig
	npad	5
$LL7@encode_sig:

; 259  :       {
; 260  :         if (*cp == 0)

	mov	esi, DWORD PTR [edx]
	test	esi, esi
	je	$LN5@encode_sig

; 261  :           continue;
; 262  :         cword = *cp;
; 263  :         if ((cword & (NBRHD_MASK<<0)) && !(cword & (SIG_PROP_MEMBER_MASK<<0)))

	test	esi, 495				; 000001efH
	je	$row_1$45
	test	esi, 2097168				; 00200010H
	jne	$row_1$45

; 264  :           { // Process first row of stripe column (row 0)
; 265  :             val = sp[0]<<shift; // Move bit p to sign bit.

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _val$1$[ebp], ecx
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	DWORD PTR _val$1$[ebp], cl

; 266  :             sym = (kdu_int32)(((kdu_uint32) val)>>31); // Move bit into LSB

	mov	ecx, DWORD PTR _val$1$[ebp]
	mov	edx, ecx
	shr	edx, 31					; 0000001fH
	mov	DWORD PTR _sym$1$[ebp], edx

; 267  :             _raw_enc_(coder,sym);

	test	eax, eax
	jne	SHORT $LN11@encode_sig
	lea	ecx, DWORD PTR [ebx+1]
	mov	BYTE PTR [edi], bl
	sar	ecx, 8
	inc	edi
	mov	eax, 8
	mov	DWORD PTR _store$1$[ebp], edi
	sub	eax, ecx
	mov	ecx, DWORD PTR _val$1$[ebp]
	xor	ebx, ebx
$LN11@encode_sig:
	mov	edx, DWORD PTR _sym$1$[ebp]
	dec	eax
	lea	ebx, DWORD PTR [edx+ebx*2]

; 268  :             if (val >= 0) // New magnitude bit was 0, so still insignificant

	mov	edx, DWORD PTR _contexts$[ebp]
	test	ecx, ecx
	js	SHORT $LN12@encode_sig

; 269  :               { cword |= (PI_BIT<<0); goto row_1; }

	or	esi, 1048576				; 00100000H
	jmp	$row_1$45
$LN12@encode_sig:

; 270  :             // Compute distortion change
; 271  :             val =  (val>>(31-DISTORTION_LSBS)) & (SIGNIFICANCE_DISTORTIONS-1);
; 272  :             distortion_change += distortion_lut[val];

	mov	edi, DWORD PTR _distortion_lut$2$[ebp]
	mov	edx, DWORD PTR _distortion_change$1$[ebp]
	sar	ecx, 26					; 0000001aH
	and	ecx, 31					; 0000001fH
	add	edx, DWORD PTR [edi+ecx*4]

; 273  :             // Encode sign bit
; 274  :             sym = sp[0];
; 275  :             sym = (kdu_int32)(((kdu_uint32) sym)>>31); // Move sign into LSB

	mov	ecx, DWORD PTR _samples$[ebp]

; 276  :             _raw_enc_(coder,sym);

	mov	edi, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], edx
	mov	edx, DWORD PTR _contexts$[ebp]
	mov	ecx, DWORD PTR [ecx]
	shr	ecx, 31					; 0000001fH
	mov	DWORD PTR _sym$2$[ebp], ecx
	test	eax, eax
	jne	SHORT $LN14@encode_sig
	lea	ecx, DWORD PTR [ebx+1]
	mov	BYTE PTR [edi], bl
	sar	ecx, 8
	inc	edi
	mov	eax, 8
	mov	DWORD PTR _store$1$[ebp], edi
	sub	eax, ecx
	mov	ecx, DWORD PTR _sym$2$[ebp]
	xor	ebx, ebx
$LN14@encode_sig:
	dec	eax
	lea	ebx, DWORD PTR [ecx+ebx*2]

; 277  :             // Broadcast neighbourhood context changes
; 278  :             if (!causal)

	cmp	BYTE PTR _causal$[ebp], 0
	jne	SHORT $LN15@encode_sig

; 279  :               {
; 280  :                 cp[-context_row_gap-1] |=(SIGMA_BR_BIT<<9);

	mov	ecx, DWORD PTR _context_row_gap$[ebp]
	shl	ecx, 2
	sub	edx, ecx

; 281  :                 cp[-context_row_gap  ] |=(SIGMA_BC_BIT<<9)|(sym<<NEXT_CHI_POS);

	mov	ecx, DWORD PTR _sym$2$[ebp]
	shl	ecx, 31					; 0000001fH
	or	ecx, 65536				; 00010000H
	or	DWORD PTR [edx-4], 131072		; 00020000H
	or	DWORD PTR [edx], ecx

; 282  :                 cp[-context_row_gap+1] |=(SIGMA_BL_BIT<<9);

	or	DWORD PTR [edx+4], 32768		; 00008000H
	mov	edx, DWORD PTR _contexts$[ebp]
	mov	ecx, DWORD PTR _sym$2$[ebp]
$LN15@encode_sig:

; 283  :               }
; 284  :             cp[-1] |= (SIGMA_CR_BIT<<0);

	or	DWORD PTR [edx-4], 32			; 00000020H

; 285  :             cp[1]  |= (SIGMA_CL_BIT<<0);

	or	DWORD PTR [edx+4], 8

; 286  :             cword |= (SIGMA_CC_BIT<<0) | (PI_BIT<<0) | (sym<<CHI_POS);

	shl	ecx, 21					; 00000015H
	or	ecx, 1048592				; 00100010H
	or	esi, ecx
$row_1$45:

; 287  :           }
; 288  : row_1:
; 289  :         if ((cword & (NBRHD_MASK<<3)) && !(cword & (SIG_PROP_MEMBER_MASK<<3)))

	test	esi, 3960				; 00000f78H
	je	$row_2$46
	test	esi, 16777344				; 01000080H
	jne	$row_2$46

; 290  :           { // Process second row of stripe column (row 1)
; 291  :             val = sp[width]<<shift; // Move bit p to sign bit.

	mov	edx, DWORD PTR _width$[ebp]
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _val$2$[ebp], ecx
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	DWORD PTR _val$2$[ebp], cl

; 292  :             sym = (kdu_int32)(((kdu_uint32) val)>>31); // Move bit into LSB

	mov	ecx, DWORD PTR _val$2$[ebp]
	mov	edx, ecx
	shr	edx, 31					; 0000001fH
	mov	DWORD PTR _sym$3$[ebp], edx

; 293  :             _raw_enc_(coder,sym);

	test	eax, eax
	jne	SHORT $LN17@encode_sig
	lea	ecx, DWORD PTR [ebx+1]
	mov	BYTE PTR [edi], bl
	sar	ecx, 8
	inc	edi
	mov	eax, 8
	mov	DWORD PTR _store$1$[ebp], edi
	sub	eax, ecx
	mov	ecx, DWORD PTR _val$2$[ebp]
	xor	ebx, ebx
$LN17@encode_sig:
	mov	edx, DWORD PTR _sym$3$[ebp]
	dec	eax
	lea	ebx, DWORD PTR [edx+ebx*2]

; 294  :             if (val >= 0) // New magnitude bit was 0, so still insignificant

	mov	edx, DWORD PTR _contexts$[ebp]
	test	ecx, ecx
	js	SHORT $LN18@encode_sig

; 295  :               { cword |= (PI_BIT<<3); goto row_2; }

	or	esi, 8388608				; 00800000H
	jmp	SHORT $row_2$46
$LN18@encode_sig:

; 296  :             // Compute distortion change
; 297  :             val =  (val>>(31-DISTORTION_LSBS)) & (SIGNIFICANCE_DISTORTIONS-1);
; 298  :             distortion_change += distortion_lut[val];

	mov	edi, DWORD PTR _distortion_lut$2$[ebp]
	mov	edx, DWORD PTR _distortion_change$1$[ebp]
	sar	ecx, 26					; 0000001aH
	and	ecx, 31					; 0000001fH
	add	edx, DWORD PTR [edi+ecx*4]

; 299  :             // Encode sign bit
; 300  :             sym = sp[width];
; 301  :             sym = (kdu_int32)(((kdu_uint32) sym)>>31); // Move sign into LSB

	mov	ecx, DWORD PTR _samples$[ebp]

; 302  :             _raw_enc_(coder,sym);

	mov	edi, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], edx
	mov	edx, DWORD PTR _width$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _contexts$[ebp]
	shr	ecx, 31					; 0000001fH
	mov	DWORD PTR _sym$4$[ebp], ecx
	test	eax, eax
	jne	SHORT $LN20@encode_sig
	lea	ecx, DWORD PTR [ebx+1]
	mov	BYTE PTR [edi], bl
	sar	ecx, 8
	inc	edi
	mov	eax, 8
	mov	DWORD PTR _store$1$[ebp], edi
	sub	eax, ecx
	mov	ecx, DWORD PTR _sym$4$[ebp]
	xor	ebx, ebx
$LN20@encode_sig:

; 303  :             // Broadcast neighbourhood context changes
; 304  :             cp[-1] |= (SIGMA_CR_BIT<<3);

	or	DWORD PTR [edx-4], 256			; 00000100H
	lea	ebx, DWORD PTR [ecx+ebx*2]

; 305  :             cp[1]  |= (SIGMA_CL_BIT<<3);

	or	DWORD PTR [edx+4], 64			; 00000040H
	dec	eax

; 306  :             cword |= (SIGMA_CC_BIT<<3) | (PI_BIT<<3) | (sym<<(CHI_POS+3));

	shl	ecx, 24					; 00000018H
	or	ecx, 8388736				; 00800080H
	or	esi, ecx
$row_2$46:

; 307  :           }
; 308  : row_2:
; 309  :         if ((cword & (NBRHD_MASK<<6)) && !(cword & (SIG_PROP_MEMBER_MASK<<6)))

	test	esi, 31680				; 00007bc0H
	je	$row_3$47
	test	esi, 134218752				; 08000400H
	jne	$row_3$47

; 310  :           { // Process third row of stripe column (row 2)
; 311  :             val = sp[width_by2]<<shift; // Move bit p to sign bit.

	mov	edx, DWORD PTR _width_by2$1$[ebp]
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _val$3$[ebp], ecx
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	DWORD PTR _val$3$[ebp], cl

; 312  :             sym = (kdu_int32)(((kdu_uint32) val)>>31); // Move bit into LSB

	mov	ecx, DWORD PTR _val$3$[ebp]
	mov	edx, ecx
	shr	edx, 31					; 0000001fH
	mov	DWORD PTR _sym$5$[ebp], edx

; 313  :             _raw_enc_(coder,sym);

	test	eax, eax
	jne	SHORT $LN22@encode_sig
	lea	ecx, DWORD PTR [ebx+1]
	mov	BYTE PTR [edi], bl
	sar	ecx, 8
	inc	edi
	mov	eax, 8
	mov	DWORD PTR _store$1$[ebp], edi
	sub	eax, ecx
	mov	ecx, DWORD PTR _val$3$[ebp]
	xor	ebx, ebx
$LN22@encode_sig:
	mov	edx, DWORD PTR _sym$5$[ebp]
	dec	eax
	lea	ebx, DWORD PTR [edx+ebx*2]

; 314  :             if (val >= 0) // New magnitude bit was 0, so still insignificant

	mov	edx, DWORD PTR _contexts$[ebp]
	test	ecx, ecx
	js	SHORT $LN23@encode_sig

; 315  :               { cword |= (PI_BIT<<6); goto row_3; }

	or	esi, 67108864				; 04000000H
	jmp	SHORT $row_3$47
$LN23@encode_sig:

; 316  :             // Compute distortion change
; 317  :             val =  (val>>(31-DISTORTION_LSBS)) & (SIGNIFICANCE_DISTORTIONS-1);
; 318  :             distortion_change += distortion_lut[val];

	mov	edi, DWORD PTR _distortion_lut$2$[ebp]
	mov	edx, DWORD PTR _distortion_change$1$[ebp]
	sar	ecx, 26					; 0000001aH
	and	ecx, 31					; 0000001fH
	add	edx, DWORD PTR [edi+ecx*4]

; 319  :             // Encode sign bit
; 320  :             sym = sp[width_by2];
; 321  :             sym = (kdu_int32)(((kdu_uint32) sym)>>31); // Move sign into LSB

	mov	ecx, DWORD PTR _samples$[ebp]

; 322  :             _raw_enc_(coder,sym);

	mov	edi, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], edx
	mov	edx, DWORD PTR _width_by2$1$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _contexts$[ebp]
	shr	ecx, 31					; 0000001fH
	mov	DWORD PTR _sym$6$[ebp], ecx
	test	eax, eax
	jne	SHORT $LN25@encode_sig
	lea	ecx, DWORD PTR [ebx+1]
	mov	BYTE PTR [edi], bl
	sar	ecx, 8
	inc	edi
	mov	eax, 8
	mov	DWORD PTR _store$1$[ebp], edi
	sub	eax, ecx
	mov	ecx, DWORD PTR _sym$6$[ebp]
	xor	ebx, ebx
$LN25@encode_sig:

; 323  :             // Broadcast neighbourhood context changes
; 324  :             cp[-1] |= (SIGMA_CR_BIT<<6);

	or	DWORD PTR [edx-4], 2048			; 00000800H
	lea	ebx, DWORD PTR [ecx+ebx*2]

; 325  :             cp[1]  |= (SIGMA_CL_BIT<<6);

	or	DWORD PTR [edx+4], 512			; 00000200H
	dec	eax

; 326  :             cword |= (SIGMA_CC_BIT<<6) | (PI_BIT<<6) | (sym << (CHI_POS+6));

	shl	ecx, 27					; 0000001bH
	or	ecx, 67109888				; 04000400H
	or	esi, ecx
$row_3$47:

; 327  :           }
; 328  : row_3:
; 329  :         if ((cword & (NBRHD_MASK<<9)) && !(cword & (SIG_PROP_MEMBER_MASK<<9)))

	test	esi, 253440				; 0003de00H
	je	$done$48
	test	esi, 1073750016				; 40002000H
	jne	$done$48

; 330  :           { // Process fourth row of stripe column (row 3)
; 331  :             val = sp[width_by3]<<shift; // Move bit p to sign bit.

	mov	edx, DWORD PTR tv704[ebp]
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _val$4$[ebp], ecx
	mov	ecx, DWORD PTR _shift$1$[ebp]
	shl	DWORD PTR _val$4$[ebp], cl

; 332  :             sym = (kdu_int32)(((kdu_uint32) val)>>31); // Move bit into LSB

	mov	ecx, DWORD PTR _val$4$[ebp]
	mov	edx, ecx
	shr	edx, 31					; 0000001fH
	mov	DWORD PTR _sym$7$[ebp], edx

; 333  :             _raw_enc_(coder,sym);

	test	eax, eax
	jne	SHORT $LN27@encode_sig
	lea	ecx, DWORD PTR [ebx+1]
	mov	BYTE PTR [edi], bl
	sar	ecx, 8
	inc	edi
	mov	eax, 8
	mov	DWORD PTR _store$1$[ebp], edi
	sub	eax, ecx
	mov	ecx, DWORD PTR _val$4$[ebp]
	xor	ebx, ebx
$LN27@encode_sig:
	mov	edx, DWORD PTR _sym$7$[ebp]
	dec	eax
	lea	ebx, DWORD PTR [edx+ebx*2]

; 334  :             if (val >= 0) // New magnitude bit was 0, so still insignificant

	mov	edx, DWORD PTR _contexts$[ebp]
	test	ecx, ecx
	js	SHORT $LN28@encode_sig

; 335  :               { cword |= (PI_BIT<<9); goto done; }

	or	esi, 536870912				; 20000000H
	jmp	$done$48
$LN28@encode_sig:

; 336  :             // Compute distortion change
; 337  :             val =  (val>>(31-DISTORTION_LSBS)) & (SIGNIFICANCE_DISTORTIONS-1);
; 338  :             distortion_change += distortion_lut[val];

	mov	edi, DWORD PTR _distortion_lut$2$[ebp]
	mov	edx, DWORD PTR _distortion_change$1$[ebp]
	sar	ecx, 26					; 0000001aH
	and	ecx, 31					; 0000001fH
	add	edx, DWORD PTR [edi+ecx*4]

; 339  :             // Encode sign bit
; 340  :             sym = sp[width_by3];
; 341  :             sym = (kdu_int32)(((kdu_uint32) sym)>>31); // Move sign into LSB

	mov	ecx, DWORD PTR _samples$[ebp]

; 342  :             _raw_enc_(coder,sym);

	mov	edi, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _distortion_change$1$[ebp], edx
	mov	edx, DWORD PTR tv704[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR _contexts$[ebp]
	shr	ecx, 31					; 0000001fH
	mov	DWORD PTR _sym$8$[ebp], ecx
	test	eax, eax
	jne	SHORT $LN30@encode_sig
	lea	ecx, DWORD PTR [ebx+1]
	mov	BYTE PTR [edi], bl
	sar	ecx, 8
	inc	edi
	mov	eax, 8
	mov	DWORD PTR _store$1$[ebp], edi
	sub	eax, ecx
	mov	ecx, DWORD PTR _sym$8$[ebp]
	xor	ebx, ebx
$LN30@encode_sig:

; 343  :             // Broadcast neighbourhood context changes
; 344  :             cp[context_row_gap-1] |= SIGMA_TR_BIT;

	mov	edi, DWORD PTR _context_row_gap$[ebp]
	lea	ebx, DWORD PTR [ecx+ebx*2]

; 345  :             cp[context_row_gap  ] |= SIGMA_TC_BIT | (sym<<PREV_CHI_POS);

	shl	ecx, 18					; 00000012H
	dec	eax
	or	ecx, 2
	or	DWORD PTR [edx+edi*4], ecx

; 346  :             cp[context_row_gap+1] |= SIGMA_TL_BIT;

	mov	ecx, edi
	or	DWORD PTR [edx+edi*4-4], 4
	mov	edi, DWORD PTR _store$1$[ebp]
	or	DWORD PTR [edx+ecx*4+4], 1

; 347  :             cp[-1] |= (SIGMA_CR_BIT<<9);
; 348  :             cp[1]  |= (SIGMA_CL_BIT<<9);
; 349  :             cword |= (SIGMA_CC_BIT<<9) | (PI_BIT<<9) | (sym<<(CHI_POS+9));

	mov	ecx, DWORD PTR _sym$8$[ebp]
	or	DWORD PTR [edx-4], 16384		; 00004000H
	or	DWORD PTR [edx+4], 4096			; 00001000H
	shl	ecx, 30					; 0000001eH
	or	ecx, 536879104				; 20002000H
	or	esi, ecx
$done$48:

; 350  :           }
; 351  : done:
; 352  :         *cp = cword;

	mov	ecx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR [edx], esi
$LN5@encode_sig:

; 258  :     for (c=width; c > 0; c--, sp++, cp++)

	mov	esi, DWORD PTR _c$1$[ebp]
	add	ecx, 4
	dec	esi
	mov	DWORD PTR _samples$[ebp], ecx
	add	edx, 4
	mov	DWORD PTR _c$1$[ebp], esi
	mov	DWORD PTR _contexts$[ebp], edx
	test	esi, esi
	jg	$LL7@encode_sig
	mov	esi, DWORD PTR _width$[ebp]
$LN2@encode_sig:

; 254  :     distortion_lut = significance_distortion_lut_lossless;
; 255  : 
; 256  :   assert((context_row_gap - width) == EXTRA_ENCODE_CWORDS);
; 257  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_ENCODE_CWORDS, sp += width_by3)

	dec	DWORD PTR _num_stripes$[ebp]
	add	edx, 12					; 0000000cH
	add	ecx, DWORD PTR tv704[ebp]
	cmp	DWORD PTR _num_stripes$[ebp], 0
	mov	DWORD PTR _contexts$[ebp], edx
	mov	DWORD PTR _samples$[ebp], ecx
	jg	$LL4@encode_sig
	mov	esi, DWORD PTR _distortion_change$1$[ebp]
$LN3@encode_sig:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 285  :         assert(active && checked_out && !MQ_segment); checked_out = false;

	mov	ecx, DWORD PTR _coder$[ebp]

; 286  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+20], edi
	pop	edi
	mov	DWORD PTR [ecx+8], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 355  :   return distortion_change;

	mov	eax, esi
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 286  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+12], ebx
	mov	BYTE PTR [ecx+25], 0
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 356  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?encode_sig_prop_pass_raw@@YAHAAVmq_encoder@@H_NPAH2HHH1@Z ENDP ; encode_sig_prop_pass_raw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?reset_states@@YAXQAUmqe_state@@@Z
_TEXT	SEGMENT
_states$ = 8						; size = 4
?reset_states@@YAXQAUmqe_state@@@Z PROC			; reset_states, COMDAT

; 161  : {

	push	ebp
	mov	ebp, esp

; 162  :   for (int n=0; n < 18; n++)

	mov	edx, DWORD PTR _states$[ebp]
	xor	eax, eax
	npad	8
$LL4@reset_stat:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	mov	ecx, DWORD PTR ?p_bar_table@mq_encoder@@2PAHA
	mov	DWORD PTR [edx+eax*8], ecx

; 335  :   transition = mq_encoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR [edx+eax*8+4], OFFSET ?transition_table@mq_encoder@@2PAUmqe_transition@@A ; mq_encoder::transition_table
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 162  :   for (int n=0; n < 18; n++)

	inc	eax
	cmp	eax, 18					; 00000012H
	jl	SHORT $LL4@reset_stat
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	mov	eax, DWORD PTR ?p_bar_table@mq_encoder@@2PAHA+16
	mov	DWORD PTR [edx], eax

; 335  :   transition = mq_encoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR [edx+4], OFFSET ?transition_table@mq_encoder@@2PAUmqe_transition@@A+128

; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	mov	eax, DWORD PTR ?p_bar_table@mq_encoder@@2PAHA+12
	mov	DWORD PTR [edx+72], eax

; 335  :   transition = mq_encoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR [edx+76], OFFSET ?transition_table@mq_encoder@@2PAUmqe_transition@@A+96
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 166  : }

	pop	ebp
	ret	0
?reset_states@@YAXQAUmqe_state@@@Z ENDP			; reset_states
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ??__E_do_it@@YAXXZ
text$di	SEGMENT
??__E_do_it@@YAXXZ PROC					; `dynamic initializer for '_do_it'', COMDAT

; 103  :               { initialize_significance_distortion_luts();

	call	?initialize_significance_distortion_luts@@YAXXZ ; initialize_significance_distortion_luts

; 104  :                 initialize_refinement_distortion_luts(); }

	jmp	?initialize_refinement_distortion_luts@@YAXXZ ; initialize_refinement_distortion_luts
??__E_do_it@@YAXXZ ENDP					; `dynamic initializer for '_do_it''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ??0encoder_local_init@@QAE@XZ
_TEXT	SEGMENT
??0encoder_local_init@@QAE@XZ PROC			; encoder_local_init::encoder_local_init, COMDAT
; _this$ = ecx

; 102  :     public: encoder_local_init()

	push	esi
	mov	esi, ecx

; 103  :               { initialize_significance_distortion_luts();

	call	?initialize_significance_distortion_luts@@YAXXZ ; initialize_significance_distortion_luts

; 104  :                 initialize_refinement_distortion_luts(); }

	call	?initialize_refinement_distortion_luts@@YAXXZ ; initialize_refinement_distortion_luts
	mov	eax, esi
	pop	esi
	ret	0
??0encoder_local_init@@QAE@XZ ENDP			; encoder_local_init::encoder_local_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?initialize_refinement_distortion_luts@@YAXXZ
_TEXT	SEGMENT
tv219 = -16						; size = 8
_sqe_before$1$ = -16					; size = 8
tv229 = -8						; size = 8
?initialize_refinement_distortion_luts@@YAXXZ PROC	; initialize_refinement_distortion_luts, COMDAT

; 136  : {

	push	ebp
	mov	ebp, esp

; 137  :   for (kdu_int32 n=0; n < REFINEMENT_DISTORTIONS; n++)

	movsd	xmm3, QWORD PTR __real@3fe0000000000000
	sub	esp, 16					; 00000010H
	push	esi
	xor	esi, esi
	npad	15
$LL10@initialize:

; 138  :     {
; 139  :       double v_tilde = ((double) n) / ((double)(1<<DISTORTION_LSBS));

	movd	xmm1, esi
	cvtdq2pd xmm1, xmm1
	mulsd	xmm1, QWORD PTR __real@3fa0000000000000

; 140  :       assert(v_tilde < 2.0);
; 141  :       double sqe_before = (v_tilde-1.0)*(v_tilde-1.0);

	movaps	xmm0, xmm1
	subsd	xmm0, QWORD PTR __real@3ff0000000000000
	movaps	xmm2, xmm0
	mulsd	xmm2, xmm0
	movsd	QWORD PTR _sqe_before$1$[ebp], xmm2

; 142  :       v_tilde = (n >> DISTORTION_LSBS)?(v_tilde-1.0):v_tilde;

	test	esi, -32				; ffffffe0H
	je	SHORT $LN11@initialize
	movaps	xmm1, xmm0
$LN11@initialize:

; 143  :       assert((v_tilde >= 0.0) && (v_tilde < 1.0));
; 144  :       double sqe_after = (v_tilde-0.5)*(v_tilde-0.5);

	subsd	xmm1, xmm3

; 145  :       refinement_distortion_lut[n] = (int)

	movaps	xmm0, xmm2
	sub	esp, 8
	mulsd	xmm1, xmm1
	subsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@40f0000000000000
	addsd	xmm0, xmm3
	movsd	QWORD PTR tv229[ebp], xmm0
	fld	QWORD PTR tv229[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	call	__ftol2_sse

; 146  :         floor(0.5 + KD_DISTORTION_LUT_SCALE*(sqe_before-sqe_after));
; 147  :       refinement_distortion_lut_lossless[n] = (int)

	movsd	xmm0, QWORD PTR _sqe_before$1$[ebp]
	mulsd	xmm0, QWORD PTR __real@40f0000000000000
	mov	DWORD PTR ?refinement_distortion_lut@@3PAHA[esi*4], eax
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv219[ebp], xmm0
	fld	QWORD PTR tv219[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	movsd	xmm3, QWORD PTR __real@3fe0000000000000
	mov	DWORD PTR ?refinement_distortion_lut_lossless@@3PAHA[esi*4], eax
	inc	esi
	cmp	esi, 64					; 00000040H
	jl	$LL10@initialize
	pop	esi

; 148  :         floor(0.5 + KD_DISTORTION_LUT_SCALE*sqe_before);
; 149  :     }
; 150  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?initialize_refinement_distortion_luts@@YAXXZ ENDP	; initialize_refinement_distortion_luts
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?initialize_significance_distortion_luts@@YAXXZ
_TEXT	SEGMENT
tv364 = -16						; size = 16
?initialize_significance_distortion_luts@@YAXXZ PROC	; initialize_significance_distortion_luts, COMDAT

; 115  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 116  :   for (kdu_int32 n=0; n < SIGNIFICANCE_DISTORTIONS; n++)

	xor	esi, esi
	npad	4
$LL4@initialize:

; 117  :     {
; 118  :       kdu_int32 idx = n | (1<<DISTORTION_LSBS);

	movd	xmm0, esi
	pshufd	xmm0, xmm0, 0
	paddd	xmm0, XMMWORD PTR __xmm@00000003000000020000000100000000
	por	xmm0, XMMWORD PTR __xmm@00000020000000200000002000000020

; 119  :       double v_tilde = ((double) idx) / ((double)(1<<DISTORTION_LSBS));

	cvtdq2pd xmm1, xmm0
	mulpd	xmm1, XMMWORD PTR __xmm@3fa00000000000003fa0000000000000

; 120  :       assert((v_tilde >= 1.0) && (v_tilde < 2.0));
; 121  :       double sqe_before = v_tilde*v_tilde;

	movaps	xmm0, xmm1
	mulpd	xmm0, xmm1

; 122  :       double sqe_after = (v_tilde-1.5)*(v_tilde-1.5);

	subpd	xmm1, XMMWORD PTR __xmm@3ff80000000000003ff8000000000000
	movaps	XMMWORD PTR tv364[ebp], xmm0
	mulpd	xmm1, xmm1

; 123  :       significance_distortion_lut[n] = (int)

	subpd	xmm0, xmm1
	mulpd	xmm0, XMMWORD PTR __xmm@40f000000000000040f0000000000000
	addpd	xmm0, XMMWORD PTR __xmm@3fe00000000000003fe0000000000000
	call	___vdecl_floor2
	cvttpd2dq xmm1, xmm0

; 124  :         floor(0.5 + KD_DISTORTION_LUT_SCALE*(sqe_before-sqe_after));
; 125  :       significance_distortion_lut_lossless[n] = (int)

	movaps	xmm0, XMMWORD PTR tv364[ebp]
	mulpd	xmm0, XMMWORD PTR __xmm@40f000000000000040f0000000000000
	movq	QWORD PTR ?significance_distortion_lut@@3PAHA[esi*4], xmm1
	addpd	xmm0, XMMWORD PTR __xmm@3fe00000000000003fe0000000000000
	call	___vdecl_floor2
	cvttpd2dq xmm0, xmm0
	movq	QWORD PTR ?significance_distortion_lut_lossless@@3PAHA[esi*4], xmm0
	add	esi, 2
	cmp	esi, 32					; 00000020H
	jl	$LL4@initialize

; 126  :         floor(0.5 + KD_DISTORTION_LUT_SCALE*sqe_before);
; 127  :     }
; 128  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?initialize_significance_distortion_luts@@YAXXZ ENDP	; initialize_significance_distortion_luts
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
;	COMDAT ??_Gkd_block_encoder@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_block_encoder@@UAEPAXI@Z PROC			; kd_block_encoder::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 76   :     virtual ~kdu_block_encoder_base() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_block_encoder_base@@6B@
	je	SHORT $LN10@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_block_encoder@@UAEPAXI@Z ENDP			; kd_block_encoder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
;	COMDAT ??1kd_block_encoder@@UAE@XZ
_TEXT	SEGMENT
??1kd_block_encoder@@UAE@XZ PROC			; kd_block_encoder::~kd_block_encoder, COMDAT
; _this$ = ecx

; 76   :     virtual ~kdu_block_encoder_base() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_block_encoder_base@@6B@
	ret	0
??1kd_block_encoder@@UAE@XZ ENDP			; kd_block_encoder::~kd_block_encoder
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0kd_block_encoder@@QAE@XZ
_TEXT	SEGMENT
??0kd_block_encoder@@QAE@XZ PROC			; kd_block_encoder::kd_block_encoder, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kd_block_encoder@@6B@
	mov	eax, ecx
	ret	0
??0kd_block_encoder@@QAE@XZ ENDP			; kd_block_encoder::kd_block_encoder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\visual studio\vc\include\cmath
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\visual studio\vc\include\cmath
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\visual studio\vc\include\cmath
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\visual studio\vc\include\cmath
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\visual studio\vc\include\cmath
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\visual studio\vc\include\cmath
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?encode@kd_block_encoder@@MAEXPAUkdu_block@@_NNG@Z
_TEXT	SEGMENT
_max_coeff$2$ = -21076					; size = 8
tv3332 = -21068						; size = 8
_minmaxdist$1$ = -21060					; size = 8
_sample_mean2$1$ = -21052				; size = 8
tv3514 = -21048						; size = 4
tv3480 = -21044						; size = 8
_full_reversible_passes$1$ = -21040			; size = 4
_optimize$1 = -21036					; size = 1
tv3530 = -21032						; size = 4
_sample_val$1$ = -21028					; size = 8
tv3513 = -21024						; size = 4
_minmaxdistidx$1$ = -21020				; size = 4
_firstlowidx$1$ = -21016				; size = 4
_num_rows$1$ = -21012					; size = 4
_first_unsized_z$1$ = -21008				; size = 4
_cpu_counter$1$ = -21004				; size = 4
tv3488 = -21000						; size = 4
tv3487 = -20996						; size = 4
_pass_wmse_scale$1$ = -20992				; size = 8
_sample_mean$1$ = -20992				; size = 8
_available_bytes$1$ = -20984				; size = 4
_seg_buf$1$ = -20980					; size = 4
_causal$2 = -20976					; size = 1
_jnd_threshold$1$ = -20972				; size = 8
_sample_var$1$ = -20972					; size = 8
tv3489 = -20964						; size = 4
_segment_passes$2$ = -20960				; size = 4
_num_coeffs$1$ = -20956					; size = 4
_lossless_pass$3 = -20952				; size = 1
_segment_bytes$1$ = -20948				; size = 4
tv3492 = -20948						; size = 4
_num_stripes$1$ = -20944				; size = 4
_k$1$ = -20940						; size = 4
_num_cols$1$ = -20936					; size = 4
_context_row_gap$1$ = -20932				; size = 4
_final$4 = -20925					; size = 1
_samples$1$ = -20924					; size = 4
_p$1$ = -20920						; size = 4
_context_words$1$ = -20916				; size = 4
_z$1$ = -20912						; size = 4
_block$GSCopy$1$ = -20908				; size = 4
_below_threshold$1$ = -20902				; size = 1
_bypass$1$ = -20901					; size = 1
_dec_samples$ = -20900					; size = 16384
_pass_encoders$ = -4516					; size = 3640
_pass_wmse_changes$ = -876				; size = 728
_states$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_block$ = 8						; size = 4
_reversible$ = 12					; size = 1
_msb_wmse$ = 16						; size = 8
_estimated_threshold$ = 24				; size = 2
?encode@kd_block_encoder@@MAEXPAUkdu_block@@_NNG@Z PROC	; kd_block_encoder::encode, COMDAT
; _this$ = ecx

; 1273 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 21076				; 00005254H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	edi
	mov	edi, DWORD PTR _block$[ebp]

; 1274 :   double estimated_slope_threshold = -1.0;
; 1275 :   if ((estimated_threshold > 1) && (msb_wmse > 0.0) &&
; 1276 :       (block->orientation != LL_BAND))
; 1277 :     estimated_slope_threshold = slope_from_log(estimated_threshold);
; 1278 :      /* Note: the exclusion of the LL band above is important, since LL
; 1279 :         subband blocks do not generally have zero mean samples (far from
; 1280 :         it) so that an approximately uniform block can yield distortion
; 1281 :         which varies in an unpredictable manner with the number of coded
; 1282 :         bit-planes.  These unpredictable variations can lead to a large
; 1283 :         number of consecutive coding passes not lying on the convex hull
; 1284 :         of the R-D curve -- a condition which would cause the coder
; 1285 :         to quit prematurely if an estimated slope threshold were given. */
; 1286 : 
; 1287 :   /* Allocate space on the stack for a number of largish quantities.  These
; 1288 :      could be placed elsewhere. */
; 1289 :   double pass_wmse_changes[MAX_POSSIBLE_PASSES];
; 1290 :   mqe_state states[18];
; 1291 :   mq_encoder pass_encoders[MAX_POSSIBLE_PASSES];

	lea	eax, DWORD PTR _pass_encoders$[ebp+20]
	mov	DWORD PTR _block$GSCopy$1$[ebp], edi
	mov	ecx, 91					; 0000005bH
	npad	4
$LL166@encode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 140  :       { active = false; buf_start=buf_next=NULL; prev=next=NULL; }

	mov	BYTE PTR [eax+7], 0
	lea	eax, DWORD PTR [eax+40]
	mov	DWORD PTR [eax-40], 0
	mov	DWORD PTR [eax-44], 0
	mov	DWORD PTR [eax-24], 0
	mov	DWORD PTR [eax-28], 0
	sub	ecx, 1
	jne	SHORT $LL166@encode
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1294 :   int num_rows = block->size.y;

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _num_rows$1$[ebp], ecx

; 1295 :   int num_stripes = (num_rows+3)>>2;

	add	ecx, 3
	sar	ecx, 2
	mov	DWORD PTR _num_stripes$1$[ebp], ecx

; 1296 :   int context_row_gap = num_cols + EXTRA_ENCODE_CWORDS;
; 1297 :   int num_context_words = (num_stripes+2)*context_row_gap+1;

	add	ecx, 2
	push	esi
	lea	esi, DWORD PTR [eax+3]
	mov	DWORD PTR _num_cols$1$[ebp], eax
	imul	ecx, esi
	mov	DWORD PTR _context_row_gap$1$[ebp], esi
	inc	ecx

; 1298 :   
; 1299 :   // Prepare enough storage.
; 1300 :   assert(block->max_samples >= ((num_stripes<<2)*num_cols));
; 1301 :   if (block->max_contexts < num_context_words)

	cmp	DWORD PTR [edi+120], ecx
	jge	SHORT $LN75@encode

; 1302 :     block->set_max_contexts((num_context_words > 1600)?num_context_words:1600);

	mov	eax, 1600				; 00000640H
	cmp	ecx, eax
	cmovg	eax, ecx
	mov	ecx, edi
	push	eax
	call	?set_max_contexts@kdu_block@@QAEXH@Z	; kdu_block::set_max_contexts
$LN75@encode:

; 1303 :   kdu_int32 *samples = block->sample_buffer;

	mov	eax, DWORD PTR [edi+108]

; 1304 :   kdu_int32 *context_words = block->context_buffer + context_row_gap + 1;

	lea	ecx, DWORD PTR [esi*4]
	mov	DWORD PTR _samples$1$[ebp], eax
	mov	eax, DWORD PTR [edi+112]
	add	eax, 4
	mov	DWORD PTR tv3530[ebp], ecx
	add	eax, ecx

; 1305 : 
; 1306 : 	//ohhan
; 1307 :   kdu_int32 dec_samples[4096];
; 1308 :   memset((kdu_int32*)dec_samples,0,sizeof(kdu_int32)*4096);

	push	16384					; 00004000H
	mov	DWORD PTR _context_words$1$[ebp], eax
	lea	eax, DWORD PTR _dec_samples$[ebp]
	push	0
	push	eax
	call	_memset

; 1309 :   bool percep_coding = true;
; 1310 :   double embbed_delta;
; 1311 :   bool below_threshold = 0;
; 1312 : 
; 1313 :   kdu_uint16* pass_dist = new kdu_uint16[block->num_passes];

	mov	eax, DWORD PTR [edi+48]
	xor	ecx, ecx
	mov	edx, 2
	mov	BYTE PTR _below_threshold$1$[ebp], 0
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 1314 :   memset((kdu_uint16*)pass_dist,0,sizeof(kdu_uint16)*block->num_passes);

	mov	ecx, DWORD PTR [edi+48]
	add	ecx, ecx
	push	ecx
	push	0
	push	eax
	call	_memset

; 1315 :   double dist_sum = 0;
; 1316 :   double minko_dist = 0;
; 1317 :   double max_dist = -1000;
; 1318 :   double max_coeff=-1000;
; 1319 :   double minmaxdist=0.0;
; 1320 :   int minmaxdistidx=0;
; 1321 :   double firstlow=0.0;
; 1322 :   int firstlowidx=0;
; 1323 :   double dist = 0;
; 1324 :   double coeffsingle=0;
; 1325 :   double beta = 10;
; 1326 :   
; 1327 :   //Calculate variance
; 1328 :   double sample_val = 0;
; 1329 :   double sample_var = 0;
; 1330 :   double sample_mean = 0;
; 1331 :   double sample_mean2 = 0;
; 1332 :   double jnd_threshold = 0;
; 1333 :   float normalization[6][4] ={{1.0, 1.0, 1.0, 1.0}, {0.756664, 1.0, 1.0, 1.321590}, {1.145082, 1.513328, 1.513328, 2.0}, {0.866442, 1.145082, 1.145082, 1.513329}, {0.655606, 0.866442, 0.866442, 1.145082}, {0.992147, 1.311212, 1.311212, 1.732885}};
; 1334 :   int num_coeffs = block->size.get_y()*block->size.get_x();

	mov	eax, DWORD PTR [edi]
	xorps	xmm0, xmm0
	imul	eax, DWORD PTR [edi+4]

; 1335 : 
; 1336 :   for (int i = 0; i < num_coeffs; i++)

	xor	esi, esi
	movsd	xmm4, QWORD PTR __real@4000000000000000
	movaps	xmm2, xmm0
	add	esp, 28					; 0000001cH
	movsd	QWORD PTR _minmaxdist$1$[ebp], xmm2
	movaps	xmm3, xmm0
	mov	DWORD PTR _minmaxdistidx$1$[ebp], 0
	mov	DWORD PTR _firstlowidx$1$[ebp], 0
	lea	edx, DWORD PTR [esi+1]
	movsd	QWORD PTR _sample_var$1$[ebp], xmm3
	movaps	xmm1, xmm0
	movsd	QWORD PTR _sample_mean$1$[ebp], xmm2
	mov	DWORD PTR _num_coeffs$1$[ebp], eax
	test	eax, eax
	jle	$LN3@encode

; 1337 :   {
; 1338 : 	  sample_val = (double)(block->sample_buffer[i]&0x7fffffff)/(double)(1<<(31-block->k_max));

	mov	eax, DWORD PTR _block$GSCopy$1$[ebp]
	mov	ecx, 31					; 0000001fH
	mov	edi, DWORD PTR [edi+108]
	sub	ecx, DWORD PTR [eax+80]
	mov	eax, edx
	shl	eax, cl
	movd	xmm2, eax
	cvtdq2pd xmm2, xmm2
	movsd	QWORD PTR tv3480[ebp], xmm2
$LL302@encode:
	mov	ecx, DWORD PTR [edi+esi*4]
	mov	eax, ecx
	and	eax, 2147483647				; 7fffffffH
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, xmm2
	movsd	QWORD PTR _sample_val$1$[ebp], xmm0

; 1339 : 	  sample_mean2 += sample_val;

	addsd	xmm1, xmm0
	movsd	QWORD PTR _sample_mean2$1$[ebp], xmm1

; 1340 : 	  if (block->sample_buffer[i] < 0)

	test	ecx, ecx
	jns	SHORT $LN303@encode

; 1341 : 	  sample_val = -sample_val;

	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR _sample_val$1$[ebp], xmm0
$LN303@encode:

; 1342 : 	  sample_var += pow(sample_val,2.0);

	movaps	xmm1, xmm4
	call	__libm_sse2_pow_precise

; 1343 : 	  sample_mean += sample_val;

	movsd	xmm1, QWORD PTR _sample_mean$1$[ebp]
	inc	esi
	addsd	xmm1, QWORD PTR _sample_val$1$[ebp]
	addsd	xmm0, QWORD PTR _sample_var$1$[ebp]
	mov	eax, DWORD PTR _num_coeffs$1$[ebp]
	movsd	xmm2, QWORD PTR tv3480[ebp]
	movsd	xmm4, QWORD PTR __real@4000000000000000
	movsd	QWORD PTR _sample_mean$1$[ebp], xmm1
	movsd	xmm1, QWORD PTR _sample_mean2$1$[ebp]
	movaps	xmm3, xmm0
	movsd	QWORD PTR _sample_var$1$[ebp], xmm0
	cmp	esi, eax
	jl	$LL302@encode
	movsd	xmm2, QWORD PTR _sample_mean$1$[ebp]
	mov	edi, DWORD PTR _block$GSCopy$1$[ebp]
$LN3@encode:

; 1344 :   }
; 1345 :   sample_mean = 1.0/(double)num_coeffs*sample_mean;
; 1346 :   sample_mean2 = 1.0/(double)num_coeffs*sample_mean2*256.0*(double)block->delta; 
; 1347 :   sample_var = 1.0/(double)num_coeffs*sample_var - pow(sample_mean,2.0);

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	divsd	xmm0, xmm1
	movaps	xmm1, xmm0
	mulsd	xmm0, xmm2
	mulsd	xmm1, xmm3
	movsd	QWORD PTR _jnd_threshold$1$[ebp], xmm1
	movaps	xmm1, xmm4
	call	__libm_sse2_pow_precise
	movsd	xmm1, QWORD PTR _jnd_threshold$1$[ebp]
	subsd	xmm1, xmm0
	movss	xmm0, DWORD PTR [edi+104]

; 1348 :   sample_var *= pow((double)256*block->delta,2.0); 

	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR _jnd_threshold$1$[ebp], xmm1
	mulsd	xmm0, QWORD PTR __real@4070000000000000
	movsd	xmm1, QWORD PTR __real@4000000000000000
	call	__libm_sse2_pow_precise
	movsd	xmm1, QWORD PTR _jnd_threshold$1$[ebp]
	mulsd	xmm1, xmm0

; 1349 :   jnd_threshold = block->a_b * sample_var + block->b_b;
; 1350 :   
; 1351 :   //modify jyh
; 1352 :   printf("XXXXXXX\n");

	push	OFFSET ??_C@_08DIMCPJMD@XXXXXXX?6?$AA@
	mulsd	xmm1, QWORD PTR [edi+88]
	addsd	xmm1, QWORD PTR [edi+96]
	movsd	QWORD PTR _jnd_threshold$1$[ebp], xmm1
	call	_printf
	add	esp, 4

; 1353 : 
; 1354 :   // az_liuf 
; 1355 : 
; 1356 :   if (block->orient == 0)

	cmp	DWORD PTR [edi+76], 0
	jne	SHORT $LN82@encode

; 1357 :   {
; 1358 : 	  if(block->comp_idx==0)

	mov	eax, DWORD PTR [edi+84]
	test	eax, eax
	jne	SHORT $LN78@encode

; 1359 : 	  {
; 1360 : 		  jnd_threshold = 0.310338;

	movsd	xmm1, QWORD PTR __real@3fd3dc93ea2d2fe4
	jmp	SHORT $LN458@encode
$LN78@encode:

; 1361 : 	  }
; 1362 : 	  else if(block->comp_idx==1)

	cmp	eax, 1
	jne	SHORT $LN80@encode

; 1363 : 	  {
; 1364 : 		  jnd_threshold = 0.401269;

	movsd	xmm1, QWORD PTR __real@3fd9ae642bf9830e
	jmp	SHORT $LN458@encode
$LN80@encode:

; 1365 : 	  }
; 1366 : 	  else if(block->comp_idx==2)

	cmp	eax, 2
	jne	SHORT $LN82@encode

; 1367 : 	  {
; 1368 : 		  jnd_threshold = 0.279592;

	movsd	xmm1, QWORD PTR __real@3fd1e4d5d80e496f
$LN458@encode:
	movsd	QWORD PTR _jnd_threshold$1$[ebp], xmm1
$LN82@encode:

; 1369 : 	  }
; 1370 :   }
; 1371 :   
; 1372 :   //masking 
; 1373 :   bool masking_mode;
; 1374 :   double nm[4096];  
; 1375 :   double sm[4096];
; 1376 :   memset((double*)nm,1.0,sizeof(double)*4096);
; 1377 :   memset((double*)sm,1.0,sizeof(double)*4096);
; 1378 :   double masking[4096];
; 1379 :   memset((double*)masking,1.0,sizeof(double)*4096);
; 1380 :   double masking_factor = 1.0f;
; 1381 :   double sm_exp, nm_exp, sm_weight, nm_weight, masking_beta;
; 1382 :   int winsize = 32;
; 1383 :   int winsizeb = (int)((double)winsize/pow(2.0,(double)block->dwt_level));
; 1384 :   double nm_val;
; 1385 :   double adjusted_threshold;
; 1386 :   
; 1387 : 
; 1388 :   // Determine the actual number of passes which we can accomodate.
; 1389 : 
; 1390 :   int full_reversible_passes = block->num_passes;
; 1391 :         // For reversibility, need all these passes recorded in code-stream.
; 1392 :   if (block->num_passes > ((31-block->missing_msbs)*3-2))

	mov	eax, DWORD PTR [edi+44]
	mov	ecx, 91					; 0000005bH
	mov	edx, DWORD PTR [edi+48]
	mov	DWORD PTR _full_reversible_passes$1$[ebp], edx
	lea	eax, DWORD PTR [eax+eax*2]
	sub	ecx, eax
	cmp	edx, ecx
	jle	SHORT $LN83@encode

; 1393 :     block->num_passes = (31-block->missing_msbs)*3-2;

	mov	DWORD PTR [edi+48], ecx
$LN83@encode:

; 1394 :   if (block->num_passes < 0)

	cmp	DWORD PTR [edi+48], 0
	jge	SHORT $LN84@encode

; 1395 :     block->num_passes = 0;

	mov	DWORD PTR [edi+48], 0
$LN84@encode:

; 1396 : 
; 1397 :   // Make sure we have sufficient resources to process this number of passes
; 1398 : 
; 1399 :   if (block->max_passes < block->num_passes)

	mov	eax, DWORD PTR [edi+48]
	cmp	DWORD PTR [edi+64], eax
	jge	SHORT $LN85@encode

; 1400 :     block->set_max_passes(block->num_passes+10,false); // Allocate a few extra

	push	0
	add	eax, 10					; 0000000aH
	mov	ecx, edi
	push	eax
	call	?set_max_passes@kdu_block@@QAEXH_N@Z	; kdu_block::set_max_passes
$LN85@encode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 6340 :         if (cpu_iterations == 0) return 1;

	cmp	DWORD PTR [edi+132], 0
	jne	SHORT $LN176@encode
	mov	DWORD PTR _cpu_counter$1$[ebp], 1
	jmp	SHORT $LN275@encode
$LN176@encode:

; 6341 :         cpu_start = clock(); return cpu_iterations;

	call	DWORD PTR __imp__clock
	mov	DWORD PTR [edi+144], eax
	mov	eax, DWORD PTR [edi+132]
	mov	DWORD PTR _cpu_counter$1$[ebp], eax
$LN275@encode:
	mov	eax, DWORD PTR _context_row_gap$1$[ebp]
	mov	esi, DWORD PTR _num_stripes$1$[ebp]
	movsd	xmm1, QWORD PTR _msb_wmse$[ebp]
	mulsd	xmm1, QWORD PTR __real@3ef0000000000000
	imul	eax, esi
	mulsd	xmm1, QWORD PTR __real@3ef0000000000000
	lea	ecx, DWORD PTR [eax*4+4]
	movsd	QWORD PTR tv3332[ebp], xmm1
	mov	eax, DWORD PTR _context_words$1$[ebp]
	add	eax, -4					; fffffffcH
	mov	DWORD PTR tv3514[ebp], ecx
	and	DWORD PTR _num_rows$1$[ebp], 3
	mov	DWORD PTR tv3513[ebp], eax
	npad	7
$LL7@encode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1406 :       memset(context_words-1,0,(size_t)((num_stripes*context_row_gap+1)<<2));

	push	ecx
	push	0
	push	eax
	call	_memset

; 1407 :       if (num_rows & 3)

	mov	ecx, DWORD PTR _num_rows$1$[ebp]
	add	esp, 12					; 0000000cH
	test	ecx, ecx
	je	SHORT $LN457@encode

; 1408 :         {
; 1409 :           kdu_int32 oob_marker;
; 1410 :           if ((num_rows & 3) == 1) // Last 3 rows of last stripe unoccupied

	cmp	ecx, 1
	jne	SHORT $LN87@encode

; 1411 :             oob_marker = (OOB_MARKER<<3) | (OOB_MARKER<<6) | (OOB_MARKER<<9);

	mov	eax, 1224736768				; 49000000H
	jmp	SHORT $LN89@encode
$LN87@encode:

; 1412 :           else if ((num_rows & 3) == 2) // Last 2 rows of last stripe unused

	cmp	ecx, 2
	mov	eax, 1073741824				; 40000000H
	mov	ecx, 1207959552				; 48000000H
	cmove	eax, ecx
$LN89@encode:

; 1413 :             oob_marker = (OOB_MARKER << 6) | (OOB_MARKER << 9);
; 1414 :           else
; 1415 :             oob_marker = (OOB_MARKER << 9);
; 1416 :           kdu_int32 *cp = context_words + (num_stripes-1)*context_row_gap;

	mov	edx, DWORD PTR _context_words$1$[ebp]
	lea	ecx, DWORD PTR [esi-1]
	imul	ecx, DWORD PTR _context_row_gap$1$[ebp]
	lea	edi, DWORD PTR [edx+ecx*4]

; 1417 :           for (int k=num_cols; k > 0; k--)

	mov	edx, DWORD PTR _num_cols$1$[ebp]
	test	edx, edx
	jle	SHORT $LN454@encode

; 1413 :             oob_marker = (OOB_MARKER << 6) | (OOB_MARKER << 9);
; 1414 :           else
; 1415 :             oob_marker = (OOB_MARKER << 9);
; 1416 :           kdu_int32 *cp = context_words + (num_stripes-1)*context_row_gap;

	mov	ecx, edx
	rep stosd
$LN454@encode:
	mov	edi, DWORD PTR _block$GSCopy$1$[ebp]
	jmp	SHORT $LN10@encode
$LN457@encode:
	mov	edx, DWORD PTR _num_cols$1$[ebp]
$LN10@encode:

; 1418 :             *(cp++) = oob_marker;
; 1419 :         }
; 1420 :       if (context_row_gap > num_cols)

	lea	eax, DWORD PTR [edx+3]
	cmp	eax, edx
	jle	SHORT $LN12@encode

; 1421 :         { // Initialize the extra context words between lines to OOB
; 1422 :           kdu_int32 oob_marker =
; 1423 :             OOB_MARKER | (OOB_MARKER<<3) | (OOB_MARKER<<6) | (OOB_MARKER<<9);
; 1424 :           assert(context_row_gap >= (num_cols+3));
; 1425 :           kdu_int32 *cp = context_words + num_cols;

	mov	eax, DWORD PTR _context_words$1$[ebp]

; 1426 :           for (int k=num_stripes; k > 0; k--, cp+=context_row_gap)

	mov	ecx, esi
	lea	eax, DWORD PTR [eax+edx*4]
	test	esi, esi
	jle	SHORT $LN12@encode
	mov	edx, DWORD PTR tv3530[ebp]
	npad	3
$LL13@encode:

; 1427 :             cp[0] = cp[1] = cp[2] = oob_marker; // Need 3 OOB words after line

	mov	DWORD PTR [eax+8], 1226833920		; 49200000H
	dec	ecx
	mov	DWORD PTR [eax+4], 1226833920		; 49200000H
	mov	DWORD PTR [eax], 1226833920		; 49200000H
	add	eax, edx
	test	ecx, ecx
	jg	SHORT $LL13@encode
$LN12@encode:

; 1431 :       pass_wmse_scale = pass_wmse_scale / ((double)(1<<16));
; 1432 :       for (int i=block->missing_msbs; i > 0; i--)

	mov	esi, DWORD PTR [edi+44]
	mov	ecx, esi
	movsd	xmm3, QWORD PTR tv3332[ebp]
	movsd	xmm4, QWORD PTR __real@3fd0000000000000
	movsd	QWORD PTR _pass_wmse_scale$1$[ebp], xmm3
	cmp	ecx, 8
	jl	SHORT $LC368@encode

; 1428 :         }
; 1429 : 
; 1430 :       double pass_wmse_scale = msb_wmse / KD_DISTORTION_LUT_SCALE;

	lea	edx, DWORD PTR [ecx-8]
	shr	edx, 3
	inc	edx
	mov	eax, edx
	neg	eax
	lea	ecx, DWORD PTR [ecx+eax*8]
	npad	5

; 1431 :       pass_wmse_scale = pass_wmse_scale / ((double)(1<<16));
; 1432 :       for (int i=block->missing_msbs; i > 0; i--)

$LL369@encode:

; 1433 :         pass_wmse_scale *= 0.25;

	mulsd	xmm3, xmm4
	mulsd	xmm3, xmm4
	mulsd	xmm3, xmm4
	mulsd	xmm3, xmm4
	mulsd	xmm3, xmm4
	mulsd	xmm3, xmm4
	mulsd	xmm3, xmm4
	mulsd	xmm3, xmm4
	sub	edx, 1
	jne	SHORT $LL369@encode
	movsd	QWORD PTR _pass_wmse_scale$1$[ebp], xmm3
$LC368@encode:

; 1431 :       pass_wmse_scale = pass_wmse_scale / ((double)(1<<16));
; 1432 :       for (int i=block->missing_msbs; i > 0; i--)

	test	ecx, ecx
	jle	SHORT $LN367@encode
$LC16@encode:
	dec	ecx

; 1433 :         pass_wmse_scale *= 0.25;

	mulsd	xmm3, xmm4
	test	ecx, ecx
	jg	SHORT $LC16@encode
	movsd	QWORD PTR _pass_wmse_scale$1$[ebp], xmm3
$LN367@encode:

; 1434 :       int p_max = 30 - block->missing_msbs; // Index of most significant plane
; 1435 :       int p = p_max; // Bit-plane counter
; 1436 :       int z = 0; // Coding pass index
; 1437 :       int k=2; // Coding pass category; start with cleanup pass
; 1438 :       int segment_passes = 0; // Num coding passes in current codeword segment.
; 1439 :       kdu_byte *seg_buf = block->byte_buffer; // Start of current segment
; 1440 :       int segment_bytes = 0; // Bytes consumed so far by this codeword segment
; 1441 :       int first_unsized_z = 0; // First pass whose length is not yet known
; 1442 :       int available_bytes = block->max_bytes; // For current & future segments
; 1443 :       bool bypass = false;
; 1444 :       bool causal = (block->modes & Cmodes_CAUSAL) != 0;

	mov	ecx, DWORD PTR [edi+28]
	mov	eax, 30					; 0000001eH

; 1445 :       bool optimize = !(block->modes & Cmodes_ERTERM);
; 1446 : 
; 1447 : 
; 1448 : 	  //masking
; 1449 : 	  masking_mode = false;
; 1450 : 	  if (block->comp_idx != 0)
; 1451 : 		  masking_mode = false;
; 1452 : 	  sm_weight = 0.8;
; 1453 : 	  sm_exp = 0.35;
; 1454 : 	  nm_weight = 0.35;
; 1455 : 	  nm_exp = 0.4;
; 1456 : 	  masking_beta = 0.8;
; 1457 : 	  
; 1458 : 
; 1459 : 	  for (int i=0; i < num_coeffs; i++)
; 1460 : 	  {
; 1461 : 		  if (masking_mode == true)
; 1462 : 			  sm[i] = max(1.0,sm_weight*pow((double)(samples[i]&0x7fffffff)/(double)(1<<(31-block->k_max))*block->delta*256.0/(sample_mean2+0.00001),sm_exp));
; 1463 : 	  }
; 1464 : 
; 1465 : 	  // liuf, find the maximum abs of the coeffcients in the codeblock
; 1466 : 
; 1467 : 	  max_coeff=-1000;

	movsd	xmm0, QWORD PTR __real@c08f400000000000
	sub	eax, esi
	movsd	xmm5, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	xor	esi, esi
	mov	DWORD PTR _p$1$[ebp], eax

; 1468 : 
; 1469 : 	  for (int mj=0; mj<num_coeffs;mj++)

	xor	edx, edx
	mov	eax, DWORD PTR [edi+60]
	mov	DWORD PTR _seg_buf$1$[ebp], eax
	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR _available_bytes$1$[ebp], eax
	mov	eax, ecx
	shr	eax, 3
	shr	ecx, 4
	and	al, 1
	not	cl
	mov	BYTE PTR _causal$2[ebp], al
	mov	eax, DWORD PTR _num_coeffs$1$[ebp]
	and	cl, 1
	mov	DWORD PTR _z$1$[ebp], 0
	mov	DWORD PTR _k$1$[ebp], 2
	mov	DWORD PTR _segment_passes$2$[ebp], 0
	mov	DWORD PTR _segment_bytes$1$[ebp], esi
	mov	DWORD PTR _first_unsized_z$1$[ebp], esi
	mov	BYTE PTR _bypass$1$[ebp], 0
	mov	BYTE PTR _optimize$1[ebp], cl
	cmp	eax, 4
	jl	$LC371@encode

; 1470 : 	  {
; 1471 : 		  coeffsingle=abs((double)(samples[mj]&0x7fffffff)/(double)(1<<(31-block->k_max)));

	mov	esi, DWORD PTR _num_coeffs$1$[ebp]
	mov	ecx, 31					; 0000001fH
	sub	ecx, DWORD PTR [edi+80]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _samples$1$[ebp]
	lea	esi, DWORD PTR [esi-4]
	add	ecx, 8
	shr	esi, 2
	inc	esi
	movd	xmm2, eax
	cvtdq2pd xmm2, xmm2
	lea	edx, DWORD PTR [esi*4]
	npad	9
$LL376@encode:
	mov	eax, DWORD PTR [ecx-8]
	and	eax, 2147483647				; 7fffffffH
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	divsd	xmm1, xmm2
; File e:\visual studio\vc\include\cmath

; 37   : 	return (_CSTD fabs(_Xx));

	andps	xmm1, xmm5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1474 : 		  if(max_coeff<coeffsingle)

	comisd	xmm1, xmm0
	jbe	SHORT $LN372@encode

; 1475 : 			  max_coeff=coeffsingle;

	movaps	xmm0, xmm1
$LN372@encode:

; 1470 : 	  {
; 1471 : 		  coeffsingle=abs((double)(samples[mj]&0x7fffffff)/(double)(1<<(31-block->k_max)));

	mov	eax, DWORD PTR [ecx-4]
	and	eax, 2147483647				; 7fffffffH
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	divsd	xmm1, xmm2
; File e:\visual studio\vc\include\cmath

; 37   : 	return (_CSTD fabs(_Xx));

	andps	xmm1, xmm5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1474 : 		  if(max_coeff<coeffsingle)

	comisd	xmm1, xmm0
	jbe	SHORT $LN373@encode

; 1475 : 			  max_coeff=coeffsingle;

	movaps	xmm0, xmm1
$LN373@encode:

; 1470 : 	  {
; 1471 : 		  coeffsingle=abs((double)(samples[mj]&0x7fffffff)/(double)(1<<(31-block->k_max)));

	mov	eax, DWORD PTR [ecx]
	and	eax, 2147483647				; 7fffffffH
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	divsd	xmm1, xmm2
; File e:\visual studio\vc\include\cmath

; 37   : 	return (_CSTD fabs(_Xx));

	andps	xmm1, xmm5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1474 : 		  if(max_coeff<coeffsingle)

	comisd	xmm1, xmm0
	jbe	SHORT $LN374@encode

; 1475 : 			  max_coeff=coeffsingle;

	movaps	xmm0, xmm1
$LN374@encode:

; 1470 : 	  {
; 1471 : 		  coeffsingle=abs((double)(samples[mj]&0x7fffffff)/(double)(1<<(31-block->k_max)));

	mov	eax, DWORD PTR [ecx+4]
	and	eax, 2147483647				; 7fffffffH
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	divsd	xmm1, xmm2
; File e:\visual studio\vc\include\cmath

; 37   : 	return (_CSTD fabs(_Xx));

	andps	xmm1, xmm5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1474 : 		  if(max_coeff<coeffsingle)

	comisd	xmm1, xmm0
	jbe	SHORT $LN375@encode

; 1475 : 			  max_coeff=coeffsingle;

	movaps	xmm0, xmm1
$LN375@encode:
	add	ecx, 16					; 00000010H
	sub	esi, 1
	jne	$LL376@encode
	mov	esi, DWORD PTR _segment_bytes$1$[ebp]
	mov	eax, DWORD PTR _num_coeffs$1$[ebp]
$LC371@encode:

; 1468 : 
; 1469 : 	  for (int mj=0; mj<num_coeffs;mj++)

	cmp	edx, eax
	jge	SHORT $LN370@encode

; 1470 : 	  {
; 1471 : 		  coeffsingle=abs((double)(samples[mj]&0x7fffffff)/(double)(1<<(31-block->k_max)));

	mov	esi, DWORD PTR _num_coeffs$1$[ebp]
	mov	ecx, 31					; 0000001fH
	sub	ecx, DWORD PTR [edi+80]
	mov	eax, 1
	mov	edi, DWORD PTR _samples$1$[ebp]
	shl	eax, cl
	movd	xmm2, eax
	cvtdq2pd xmm2, xmm2
	npad	2
$LC305@encode:
	mov	eax, DWORD PTR [edi+edx*4]
	and	eax, 2147483647				; 7fffffffH
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	divsd	xmm1, xmm2
; File e:\visual studio\vc\include\cmath

; 37   : 	return (_CSTD fabs(_Xx));

	andps	xmm1, xmm5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1474 : 		  if(max_coeff<coeffsingle)

	comisd	xmm1, xmm0
	jbe	SHORT $LN306@encode

; 1475 : 			  max_coeff=coeffsingle;

	movaps	xmm0, xmm1
$LN306@encode:
	inc	edx

; 1468 : 
; 1469 : 	  for (int mj=0; mj<num_coeffs;mj++)

	cmp	edx, esi
	jl	SHORT $LC305@encode
	mov	esi, DWORD PTR _segment_bytes$1$[ebp]
	mov	edi, DWORD PTR _block$GSCopy$1$[ebp]
$LN370@encode:

; 1483 :       for (; z < block->num_passes; z++, k++)

	cmp	DWORD PTR [edi+48], 0
	movss	xmm1, DWORD PTR [edi+104]
	cvtps2pd xmm1, xmm1
	mulsd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR __real@4070000000000000
	movsd	QWORD PTR _max_coeff$2$[ebp], xmm1
	jle	$LN24@encode

; 1476 : 	  }
; 1477 : 	  max_coeff = max_coeff*block->delta*256.0;

	mov	ecx, DWORD PTR _k$1$[ebp]
	lea	edx, DWORD PTR _pass_encoders$[ebp]
	mov	DWORD PTR tv3489[ebp], edx
	mov	edx, 31					; 0000001fH
	sub	edx, DWORD PTR _p$1$[ebp]
	mov	DWORD PTR tv3488[ebp], edx
	mov	DWORD PTR tv3487[ebp], 10		; 0000000aH
$LL25@encode:

; 1484 :         {
; 1485 : 
; 1486 :           if (k == 3)

	cmp	ecx, 3
	jne	SHORT $LN95@encode

; 1487 :             { // Move on to next bit-plane.
; 1488 :               k=0; p--;

	dec	DWORD PTR _p$1$[ebp]
	inc	edx

; 1489 :               pass_wmse_scale *= 0.25;

	mulsd	xmm3, xmm4
	mov	DWORD PTR _k$1$[ebp], 0
	mov	DWORD PTR tv3488[ebp], edx
	movsd	QWORD PTR _pass_wmse_scale$1$[ebp], xmm3
$LN95@encode:

; 1490 :             }
; 1491 : 
; 1492 :           // See if we need to augment byte buffer resources to safely continue
; 1493 :           if ((available_bytes-segment_bytes) < 4096)

	mov	eax, DWORD PTR _available_bytes$1$[ebp]
	sub	eax, esi
	cmp	eax, 4096				; 00001000H
	jge	SHORT $LN96@encode

; 1497 :               block->set_max_bytes(block->max_bytes+8192,true);

	mov	esi, DWORD PTR _block$GSCopy$1$[ebp]
	mov	ecx, esi
	mov	edi, DWORD PTR [edi+60]
	push	1
	mov	eax, DWORD PTR [esi+68]
	add	eax, 8192				; 00002000H
	push	eax
	call	?set_max_bytes@kdu_block@@QAEXH_N@Z	; kdu_block::set_max_bytes

; 1498 :               available_bytes += 8192;

	add	DWORD PTR _available_bytes$1$[ebp], 8192 ; 00002000H

; 1500 :               for (int i=0; i < z; i++)

	mov	eax, DWORD PTR _z$1$[ebp]
	mov	esi, DWORD PTR [esi+60]
	test	eax, eax
	jle	SHORT $LN27@encode

; 1494 :             { // We could build a much more thorough test for sufficiency.
; 1495 :               assert(available_bytes >= segment_bytes); // else already overrun
; 1496 :               kdu_byte *old_handle = block->byte_buffer;

	lea	ecx, DWORD PTR _pass_encoders$[ebp+16]
	mov	edx, eax
$LL28@encode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 173  :         if (buf_start == NULL)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN26@encode

; 174  :           return; // Encoder finished working with buffer
; 175  :         assert((!checked_out) && (old_handle != NULL) && (new_handle != NULL));
; 176  :         buf_start += (new_handle-old_handle);

	sub	eax, edi
	add	eax, esi
	mov	DWORD PTR [ecx], eax

; 177  :         buf_next += (new_handle-old_handle);

	mov	eax, esi
	sub	eax, edi
	add	DWORD PTR [ecx+4], eax
$LN26@encode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1500 :               for (int i=0; i < z; i++)

	add	ecx, 40					; 00000028H
	sub	edx, 1
	jne	SHORT $LL28@encode
$LN27@encode:

; 1501 :                 pass_encoders[i].augment_buffer(old_handle,new_handle);
; 1502 :               seg_buf = new_handle + (seg_buf-old_handle);

	sub	esi, edi
	mov	edi, DWORD PTR _block$GSCopy$1$[ebp]
	add	DWORD PTR _seg_buf$1$[ebp], esi
$LN96@encode:

; 1503 :             }
; 1504 : 
; 1505 :           // Either start a new codeword segment, or continue an earlier one.
; 1506 :           if (segment_passes == 0)

	cmp	DWORD PTR _segment_passes$2$[ebp], 0
	jne	$LN97@encode

; 1507 :             { // Need to start a new codeword segment.
; 1508 :               segment_passes = block->num_passes;
; 1509 :               if (block->modes & Cmodes_BYPASS)

	mov	eax, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [edi+48]
	mov	esi, ecx

; 1510 :                 {
; 1511 :                   if (z < 10)

	mov	edx, DWORD PTR _z$1$[ebp]
	test	al, 1
	je	SHORT $LN103@encode
	cmp	edx, 10					; 0000000aH
	jge	SHORT $LN100@encode

; 1512 :                     segment_passes = 10-z;

	mov	esi, DWORD PTR tv3487[ebp]
	jmp	SHORT $LN103@encode
$LN100@encode:

; 1513 :                   else if (k == 2) // Cleanup pass.

	cmp	DWORD PTR _k$1$[ebp], 2
	jne	SHORT $LN102@encode

; 1514 :                     { segment_passes = 1; bypass = false; }

	mov	esi, 1
	mov	BYTE PTR _bypass$1$[ebp], 0

; 1515 :                   else

	jmp	SHORT $LN103@encode
$LN102@encode:

; 1516 :                     {
; 1517 :                       segment_passes = 2;

	mov	esi, 2

; 1518 :                       bypass = true;

	mov	BYTE PTR _bypass$1$[ebp], 1
$LN103@encode:

; 1519 :                     }
; 1520 :                 }
; 1521 :               if (block->modes & Cmodes_RESTART)

	test	al, 4
	mov	eax, 1
	cmovne	esi, eax
	mov	DWORD PTR _segment_passes$2$[ebp], esi

; 1522 :                 segment_passes = 1;
; 1523 :               if ((z+segment_passes) > block->num_passes)

	lea	eax, DWORD PTR [esi+edx]
	cmp	eax, ecx
	jle	SHORT $LN105@encode

; 1524 :                 segment_passes = block->num_passes - z;

	mov	eax, ecx
	sub	eax, edx
	mov	DWORD PTR _segment_passes$2$[ebp], eax
$LN105@encode:

; 1525 :               pass_encoders[z].start(seg_buf,!bypass);

	cmp	BYTE PTR _bypass$1$[ebp], 0
	mov	esi, DWORD PTR tv3489[ebp]
	mov	ecx, esi
	sete	al
	movzx	eax, al
	push	eax
	push	DWORD PTR _seg_buf$1$[ebp]
	call	?start@mq_encoder@@QAEXPAE_N@Z		; mq_encoder::start

; 1526 :             }
; 1527 :           else

	jmp	SHORT $LN98@encode
$LN97@encode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 187  :         *this = *previous;

	mov	esi, DWORD PTR tv3489[ebp]
	movups	xmm0, XMMWORD PTR [esi-40]
	lea	eax, DWORD PTR [esi-40]
	movups	XMMWORD PTR [esi], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [esi+16], xmm0
	movq	xmm0, QWORD PTR [eax+32]
	movq	QWORD PTR [esi+32], xmm0

; 188  :         prev = previous; previous->next = this;

	mov	DWORD PTR [eax+72], eax
	mov	DWORD PTR [eax+36], esi

; 189  :         previous->active = false;

	mov	BYTE PTR [eax+27], 0
$LN98@encode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1532 : 		  bool lossless_pass = reversible && ((31-p) == block->K_max_prime);

	cmp	BYTE PTR _reversible$[ebp], 0
	je	SHORT $LN157@encode
	mov	eax, DWORD PTR tv3488[ebp]
	mov	BYTE PTR _lossless_pass$3[ebp], 1
	cmp	eax, DWORD PTR [edi+40]
	je	SHORT $LN158@encode
$LN157@encode:
	mov	BYTE PTR _lossless_pass$3[ebp], 0
$LN158@encode:

; 1533 : 
; 1534 : 		  if ((z == 0) || (block->modes & Cmodes_RESET))

	cmp	DWORD PTR _z$1$[ebp], 0
	je	SHORT $LN107@encode
	test	BYTE PTR [edi+28], 2
	je	SHORT $LN106@encode
$LN107@encode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	mov	ecx, DWORD PTR ?p_bar_table@mq_encoder@@2PAHA
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 162  :   for (int n=0; n < 18; n++)

	xor	eax, eax
$LL189@encode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	mov	DWORD PTR _states$[ebp+eax*8], ecx

; 335  :   transition = mq_encoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR _states$[ebp+eax*8+4], OFFSET ?transition_table@mq_encoder@@2PAUmqe_transition@@A ; mq_encoder::transition_table
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 162  :   for (int n=0; n < 18; n++)

	inc	eax
	cmp	eax, 18					; 00000012H
	jl	SHORT $LL189@encode
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	mov	eax, DWORD PTR ?p_bar_table@mq_encoder@@2PAHA+16
	mov	DWORD PTR _states$[ebp], eax
	mov	eax, DWORD PTR ?p_bar_table@mq_encoder@@2PAHA+12

; 335  :   transition = mq_encoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR _states$[ebp+4], OFFSET ?transition_table@mq_encoder@@2PAUmqe_transition@@A+128

; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	mov	DWORD PTR _states$[ebp+72], eax

; 335  :   transition = mq_encoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR _states$[ebp+76], OFFSET ?transition_table@mq_encoder@@2PAUmqe_transition@@A+96
$LN106@encode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1537 : 			  distortion_change =

	push	DWORD PTR _lossless_pass$3[ebp]
	mov	eax, DWORD PTR _k$1$[ebp]
	push	DWORD PTR _context_row_gap$1$[ebp]
	push	DWORD PTR _num_stripes$1$[ebp]
	push	DWORD PTR _num_cols$1$[ebp]
	push	DWORD PTR _context_words$1$[ebp]
	test	eax, eax
	jne	SHORT $LN110@encode

; 1535 : 			  reset_states(states);
; 1536 : 		  if ((k == 0) && !bypass)

	cmp	BYTE PTR _bypass$1$[ebp], al
	jne	SHORT $LN450@encode

; 1537 : 			  distortion_change =

	lea	eax, DWORD PTR _dec_samples$[ebp]
	push	eax
	push	DWORD PTR _samples$1$[ebp]
	lea	eax, DWORD PTR _states$[ebp]
	push	DWORD PTR [edi+32]
	push	DWORD PTR _causal$2[ebp]
	push	DWORD PTR _p$1$[ebp]
	push	eax
	push	esi
	call	?encode_sig_prop_pass@@YAHAAVmq_encoder@@QAUmqe_state@@H_NHPAH33HHH2@Z ; encode_sig_prop_pass
	jmp	$LN459@encode
$LN450@encode:

; 1538 : 			  encode_sig_prop_pass(pass_encoders[z],
; 1539 : 			  states,p,causal,block->orientation,
; 1540 : 			  samples, dec_samples, context_words,
; 1541 : 			  num_cols,num_stripes,context_row_gap,
; 1542 : 			  lossless_pass);
; 1543 : 		  else if (k == 0)
; 1544 : 			  distortion_change =

	push	DWORD PTR _samples$1$[ebp]
	push	DWORD PTR _causal$2[ebp]
	push	DWORD PTR _p$1$[ebp]
	push	esi
	call	?encode_sig_prop_pass_raw@@YAHAAVmq_encoder@@H_NPAH2HHH1@Z ; encode_sig_prop_pass_raw
	add	esp, 36					; 00000024H
	jmp	$LN115@encode
$LN110@encode:

; 1545 : 			  encode_sig_prop_pass_raw(pass_encoders[z],
; 1546 : 			  p,causal,samples,context_words,
; 1547 : 			  num_cols,num_stripes,context_row_gap,
; 1548 : 			  lossless_pass);
; 1549 : 		  else if ((k == 1) && !bypass)

	cmp	eax, 1
	jne	SHORT $LN114@encode
	cmp	BYTE PTR _bypass$1$[ebp], 0
	jne	SHORT $LN451@encode

; 1550 : 			  distortion_change =

	lea	eax, DWORD PTR _dec_samples$[ebp]
	push	eax
	push	DWORD PTR _samples$1$[ebp]
	lea	eax, DWORD PTR _states$[ebp]
	push	DWORD PTR _causal$2[ebp]
	push	DWORD PTR _p$1$[ebp]
	push	eax
	push	esi
	call	?encode_mag_ref_pass@@YAHAAVmq_encoder@@QAUmqe_state@@H_NPAH33HHH2@Z ; encode_mag_ref_pass
	add	esp, 44					; 0000002cH
	jmp	SHORT $LN115@encode
$LN451@encode:

; 1551 : 			  encode_mag_ref_pass(pass_encoders[z],
; 1552 : 			  states,p,causal,samples,dec_samples,context_words,
; 1553 : 			  num_cols,num_stripes,context_row_gap,
; 1554 : 			  lossless_pass);
; 1555 : 		  else if (k == 1)
; 1556 : 			  distortion_change =

	push	DWORD PTR _samples$1$[ebp]
	push	DWORD PTR _causal$2[ebp]
	push	DWORD PTR _p$1$[ebp]
	push	esi
	call	?encode_mag_ref_pass_raw@@YAHAAVmq_encoder@@H_NPAH2HHH1@Z ; encode_mag_ref_pass_raw
	add	esp, 36					; 00000024H

; 1557 : 			  encode_mag_ref_pass_raw(pass_encoders[z],
; 1558 : 			  p,causal,samples,context_words,
; 1559 : 			  num_cols,num_stripes,context_row_gap,
; 1560 : 			  lossless_pass);
; 1561 : 		  else

	jmp	SHORT $LN115@encode
$LN114@encode:

; 1562 : 			  distortion_change =

	lea	eax, DWORD PTR _dec_samples$[ebp]
	push	eax
	push	DWORD PTR _samples$1$[ebp]
	lea	eax, DWORD PTR _states$[ebp]
	push	DWORD PTR [edi+32]
	push	DWORD PTR _causal$2[ebp]
	push	DWORD PTR _p$1$[ebp]
	push	eax
	push	esi
	call	?encode_cleanup_pass@@YAHAAVmq_encoder@@QAUmqe_state@@H_NHPAH33HHH2@Z ; encode_cleanup_pass
$LN459@encode:
	add	esp, 48					; 00000030H
$LN115@encode:

; 1563 : 			  encode_cleanup_pass(pass_encoders[z],
; 1564 : 			  states,p,causal,block->orientation,
; 1565 : 			  samples, dec_samples, context_words,
; 1566 : 			  num_cols,num_stripes,context_row_gap,
; 1567 : 			  lossless_pass);
; 1568 : 		  pass_wmse_changes[z] = pass_wmse_scale * distortion_change;
; 1569 : 
; 1570 : 		  
; 1571 : 		  if (percep_coding == true)
; 1572 : 		  {
; 1573 : 			  
; 1574 : 
; 1575 : 			  //texture masking
; 1576 : 			  if (masking_mode == true && block->dwt_level <= 3)
; 1577 : 			  {
; 1578 : 				  for (int i = 0; i < block->size.get_y(); i += winsizeb)
; 1579 : 				  {
; 1580 : 					  for (int j = 0; j < block->size.get_x(); j += winsizeb)
; 1581 : 					  {
; 1582 : 						  sample_var = 0;
; 1583 : 						  sample_mean = 0;
; 1584 : 						  //calculate local variance
; 1585 : 						  for (int m = i; m < i+winsizeb; m++)  //m,y,i - (row)
; 1586 : 						  {
; 1587 : 							  for (int n = j; n < j+winsizeb; n++) //n,x,j - (col)
; 1588 : 							  {
; 1589 : 								  sample_val = (double)(dec_samples[m*block->size.get_x()+n]&0x7fffffff)/(double)(1<<(31-block->k_max));
; 1590 : 								  if (dec_samples[m*block->size.get_x()+n] < 0)
; 1591 : 									  sample_val = -sample_val;
; 1592 : 								  sample_var += pow(sample_val,2.0);
; 1593 : 								  sample_mean += sample_val;
; 1594 : 							  }
; 1595 : 						  }
; 1596 : 						  sample_mean = 1.0/(double)(winsizeb*winsizeb)*sample_mean;
; 1597 : 						  sample_var = 1.0/(double)(winsizeb*winsizeb)*sample_var - pow(sample_mean,2.0);
; 1598 : 						  sample_var *= pow((double)256.0*block->delta,2.0);
; 1599 : 						  nm_val = max(1.0,nm_weight*pow(sample_var,nm_exp));
; 1600 : 
; 1601 : 						  //allocate texture masking
; 1602 : 						  for (int m = i; m < i+winsizeb; m++)
; 1603 : 						  {
; 1604 : 							  for (int n = j; n < j+winsizeb; n++)
; 1605 : 							  {
; 1606 : 								  nm[m*block->size.get_x()+n] = nm_val;
; 1607 : 							  }
; 1608 : 						  }
; 1609 : 
; 1610 : 					  }
; 1611 : 				  }
; 1612 : 
; 1613 : 				  sample_mean = 0;
; 1614 : 				  //minkowski distance
; 1615 : 				  for (int i = 0; i < num_coeffs; i++)
; 1616 : 				  {
; 1617 : 					  masking[i] = sm[i]*nm[i];
; 1618 : 					  sample_mean += pow(masking[i],masking_beta); 
; 1619 : 				  }
; 1620 : 				  masking_factor = pow(1.0/(double)num_coeffs*sample_mean,1.0/masking_beta);
; 1621 : 
; 1622 : 			  }
; 1623 : 
; 1624 : 			  if (masking_mode == true)
; 1625 : 			  {
; 1626 : 				  if (block->orient != 0)
; 1627 : 					  adjusted_threshold = min(masking_factor*jnd_threshold,6.0*block->b_b);
; 1628 : 				  else
; 1629 : 					  adjusted_threshold = masking_factor*jnd_threshold;
; 1630 : 			  }
; 1631 : 			  else
; 1632 : 				  adjusted_threshold = jnd_threshold;
; 1633 : 
; 1634 : 			  double qthresh=adjusted_threshold/(block->delta*256.0);

	movss	xmm5, DWORD PTR [edi+104]
	movsd	xmm6, QWORD PTR __real@4070000000000000
	movsd	xmm1, QWORD PTR _jnd_threshold$1$[ebp]

; 1635 : 
; 1636 : 			  max_dist = -1000;
; 1637 : 			  dist_sum = 0;
; 1638 : 
; 1639 : 			  // liuf, find distortion
; 1640 : 			  for (int i = 0; i < num_coeffs; i++)

	mov	edx, DWORD PTR _num_coeffs$1$[ebp]
	movaps	xmm4, xmm1
	movd	xmm0, eax
	mov	eax, DWORD PTR _z$1$[ebp]
	movsd	xmm2, QWORD PTR __real@c08f400000000000
	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR _pass_wmse_scale$1$[ebp]
	movsd	QWORD PTR _pass_wmse_changes$[ebp+eax*8], xmm0
	cvtps2pd xmm0, xmm5
	mulsd	xmm0, xmm6
	divsd	xmm4, xmm0
	test	edx, edx
	jle	$LN51@encode

; 1641 : 			  {
; 1642 : 				  //Calculate error
; 1643 : 				  /*if((double)(samples[i]&0x7fffffff)/(double)(1<<(31-block->k_max))!=0.0)
; 1644 : 				  {
; 1645 : 					  dist1 = abs((double)(samples[i]&0x7fffffff-dec_samples[i]&0x7fffffff)/(double)(1<<(31-block->k_max)));
; 1646 : 					  dist2 = abs((double)(samples[i]&0x7fffffff-dec_samples[i]&0x7fffffff)/(double)(1<<(31-block->k_max))+1);
; 1647 : 					  dist=max(dist1,dist2); 
; 1648 : 				  }
; 1649 : 				  else
; 1650 : 				  {
; 1651 : 					  dist1 = abs((double)(samples[i]&0x7fffffff-dec_samples[i]&0x7fffffff)/(double)(1<<(31-block->k_max))-1);
; 1652 : 					  dist2 = abs((double)(samples[i]&0x7fffffff-dec_samples[i]&0x7fffffff)/(double)(1<<(31-block->k_max))+1);
; 1653 : 					  dist=max(dist1,dist2);
; 1654 : 				  }*/
; 1655 : 				  dist = abs((double)(samples[i]&0x7fffffff-dec_samples[i]&0x7fffffff)/(double)(1<<(31-block->k_max)));

	mov	esi, DWORD PTR _samples$1$[ebp]
	mov	ecx, 31					; 0000001fH
	sub	ecx, DWORD PTR [edi+80]
	mov	eax, 1
	shl	eax, cl
	mov	edi, edx
	movd	xmm3, eax
	lea	eax, DWORD PTR _dec_samples$[ebp]
	sub	eax, esi
	cvtdq2pd xmm3, xmm3
	mov	DWORD PTR tv3492[ebp], eax
$LL315@encode:
	mov	ecx, DWORD PTR [eax+esi]
	or	eax, -1
	mov	edx, DWORD PTR [esi]
	sub	eax, ecx
	and	eax, edx

; 1664 : 				  if(((double)(dec_samples[i]&0x7fffffff)/(double)(1<<(31-block->k_max))>=qthresh)&&((double)(samples[i]&0x7fffffff)/(double)(1<<(31-block->k_max))>=qthresh))

	and	ecx, 2147483647				; 7fffffffH
	and	eax, 2147483647				; 7fffffffH
	movd	xmm0, ecx
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	cvtdq2pd xmm0, xmm0
	divsd	xmm1, xmm3
	divsd	xmm0, xmm3
; File e:\visual studio\vc\include\cmath

; 37   : 	return (_CSTD fabs(_Xx));

	andps	xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1664 : 				  if(((double)(dec_samples[i]&0x7fffffff)/(double)(1<<(31-block->k_max))>=qthresh)&&((double)(samples[i]&0x7fffffff)/(double)(1<<(31-block->k_max))>=qthresh))

	comisd	xmm0, xmm4
	jb	SHORT $LN316@encode
	and	edx, 2147483647				; 7fffffffH
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, xmm3
	comisd	xmm0, xmm4
	jb	SHORT $LN316@encode

; 1665 : 				  {
; 1666 : 					  dist=dist*2.0;

	mulsd	xmm1, QWORD PTR __real@4000000000000000
$LN316@encode:

; 1667 : 				  }
; 1668 : 				  
; 1669 : 				  //dist_sum += pow(dist*block->delta*256.0/jnd_threshold,beta);
; 1670 : 				  //pass_dist[z] += dist;
; 1671 : 				  if (max_dist < dist)

	comisd	xmm1, xmm2
	jbe	SHORT $LN317@encode

; 1672 : 					  max_dist = dist;

	movaps	xmm2, xmm1
$LN317@encode:

; 1635 : 
; 1636 : 			  max_dist = -1000;
; 1637 : 			  dist_sum = 0;
; 1638 : 
; 1639 : 			  // liuf, find distortion
; 1640 : 			  for (int i = 0; i < num_coeffs; i++)

	mov	eax, DWORD PTR tv3492[ebp]
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL315@encode
	movsd	xmm1, QWORD PTR _jnd_threshold$1$[ebp]
	mov	edi, DWORD PTR _block$GSCopy$1$[ebp]
	mov	esi, DWORD PTR tv3489[ebp]
	mov	eax, DWORD PTR _z$1$[ebp]
$LN51@encode:
	xorps	xmm0, xmm0

; 1673 : 				  //if(block->orient == 0)
; 1674 : 				  //fprintf(pThresh,"\n%f %f",dist,max_dist);
; 1675 : 
; 1676 : 				
; 1677 : 			  }
; 1678 : 
; 1679 : 			  // liuf, find whether to include
; 1680 : 			  //minko_dist = pow(dist_sum,1.0/beta);
; 1681 : 			  max_dist = max_dist*block->delta*256.0;

	cvtss2sd xmm0, xmm5
	mulsd	xmm0, xmm2

; 1682 : 
; 1683 : 			  if((max_dist<minmaxdist)||(z==0))

	movsd	xmm2, QWORD PTR _minmaxdist$1$[ebp]
	mulsd	xmm0, xmm6
	comisd	xmm2, xmm0
	ja	SHORT $LN126@encode
	test	eax, eax
	jne	SHORT $LN125@encode
$LN126@encode:

; 1684 : 			  {
; 1685 : 				  minmaxdist=max_dist;

	movaps	xmm2, xmm0

; 1686 : 				  minmaxdistidx=z;

	mov	DWORD PTR _minmaxdistidx$1$[ebp], eax
	movsd	QWORD PTR _minmaxdist$1$[ebp], xmm2
$LN125@encode:

; 1687 : 			  }
; 1688 : 			  if((below_threshold == false)&&(max_dist<adjusted_threshold))

	cmp	BYTE PTR _below_threshold$1$[ebp], 0
	jne	SHORT $LN127@encode
	comisd	xmm1, xmm0
	jbe	SHORT $LN127@encode

; 1689 : 			  {
; 1690 : 				  firstlow=max_dist;
; 1691 : 				  firstlowidx=z;

	mov	DWORD PTR _firstlowidx$1$[ebp], eax

; 1692 : 				  below_threshold=true;

	mov	BYTE PTR _below_threshold$1$[ebp], 1
$LN127@encode:

; 1693 : 			  }
; 1694 : 
; 1695 : 
; 1696 : 			  /*//embbed_delta = block->delta*256.0*(1<<(int)((block->num_passes-z+1)/3.0));
; 1697 : 			  pass_dist[z] = (kdu_uint16)(max_dist+1000.0);
; 1698 : 
; 1699 : 			  if (below_threshold) 
; 1700 : 				  pass_dist[z] = 1;
; 1701 : 
; 1702 : 
; 1703 : 			  //if (below_threshold == false && embbed_delta <= jnd_threshold)
; 1704 : 			  if (below_threshold == false && max_dist <= adjusted_threshold)
; 1705 : 			  {
; 1706 : 				  //printf("\njnd threshold=%.4f, max distortion=%.4f, \nmasking_factor=%.4f adjusted threshold=%.4f(difference=%.4f)\n",jnd_threshold,max_dist,masking_factor,adjusted_threshold,abs(adjusted_threshold-max_dist));
; 1707 : 				  //fprintf(pThresh,"%.4f %.4f %.4f",adjusted_threshold,max_dist,adjusted_threshold-max_dist);
; 1708 : 				  pass_dist[z] = 2;
; 1709 : 				  below_threshold = true;
; 1710 : 			  }*/
; 1711 : 
; 1712 : 
; 1713 : 		  }
; 1714 : 
; 1715 : 		  if (block->orient == 1 && block->dwt_level == 4)
; 1716 : 			  block->orient += 0;
; 1717 : 
; 1718 : 
; 1719 :           if ((block->modes & Cmodes_SEGMARK) && (k==2))

	test	BYTE PTR [edi+28], 32			; 00000020H
	je	SHORT $LN129@encode
	cmp	DWORD PTR _k$1$[ebp], 2
	jne	SHORT $LN129@encode

; 1720 :             {
; 1721 :               kdu_int32 segmark = 0x0A;
; 1722 :               pass_encoders[z].mq_encode_run(segmark>>2);

	push	2
	mov	ecx, esi
	call	?mq_encode_run@mq_encoder@@QAEXH@Z	; mq_encoder::mq_encode_run

; 1723 :               pass_encoders[z].mq_encode_run(segmark & 3);

	push	2
	mov	ecx, esi
	call	?mq_encode_run@mq_encoder@@QAEXH@Z	; mq_encoder::mq_encode_run
$LN129@encode:

; 1727 :           segment_passes--;

	mov	ecx, DWORD PTR _segment_passes$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 163  :         return (int)(buf_next-buf_start);

	mov	eax, DWORD PTR [esi+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1727 :           segment_passes--;

	dec	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 163  :         return (int)(buf_next-buf_start);

	sub	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1727 :           segment_passes--;

	mov	DWORD PTR _segment_passes$2$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 163  :         return (int)(buf_next-buf_start);

	mov	DWORD PTR _segment_bytes$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1729 :           if (segment_passes == 0)

	test	ecx, ecx
	jne	SHORT $LN130@encode

; 1730 :             {
; 1731 :               kdu_byte *new_buf = pass_encoders[z].terminate(optimize);

	push	DWORD PTR _optimize$1[ebp]
	mov	ecx, esi
	call	?terminate@mq_encoder@@QAEPAE_N@Z	; mq_encoder::terminate

; 1732 :               available_bytes -= (int)(new_buf - seg_buf);

	mov	ecx, DWORD PTR _seg_buf$1$[ebp]
	sub	ecx, eax

; 1733 :               seg_buf = new_buf;

	mov	DWORD PTR _seg_buf$1$[ebp], eax
	add	DWORD PTR _available_bytes$1$[ebp], ecx

; 1734 :               segment_bytes = 0;

	mov	DWORD PTR _segment_bytes$1$[ebp], 0
$LN130@encode:

; 1735 :             }
; 1736 : 
; 1737 :           { // Incrementally determine and process truncation lengths
; 1738 :             int t;
; 1739 :             bool final;
; 1740 :             for  (t=first_unsized_z; t <= z; t++)

	mov	eax, DWORD PTR _first_unsized_z$1$[ebp]
	mov	esi, eax
	cmp	eax, DWORD PTR _z$1$[ebp]
	jg	SHORT $LL58@encode
	lea	eax, DWORD PTR [eax+eax*4]
	lea	edi, DWORD PTR _pass_encoders$[ebp]
	lea	edi, DWORD PTR [edi+eax*8]
$LL55@encode:

; 1741 :               {
; 1742 :                 block->pass_lengths[t] =

	lea	eax, DWORD PTR _final$4[ebp]
	mov	ecx, edi
	push	eax
	call	?get_incremental_length@mq_encoder@@QAEHAA_N@Z ; mq_encoder::get_incremental_length

; 1743 :                   pass_encoders[t].get_incremental_length(final);
; 1744 :                 if (final)

	cmp	BYTE PTR _final$4[ebp], 0
	mov	edx, DWORD PTR _block$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+esi*4], eax
	je	SHORT $LN53@encode

; 1745 :                   { assert(first_unsized_z == t); first_unsized_z++; }

	inc	DWORD PTR _first_unsized_z$1$[ebp]
$LN53@encode:

; 1735 :             }
; 1736 : 
; 1737 :           { // Incrementally determine and process truncation lengths
; 1738 :             int t;
; 1739 :             bool final;
; 1740 :             for  (t=first_unsized_z; t <= z; t++)

	inc	esi
	add	edi, 40					; 00000028H
	cmp	esi, DWORD PTR _z$1$[ebp]
	jle	SHORT $LL55@encode
	mov	edi, edx
	npad	5
$LL58@encode:

; 1831 :           if (segment_passes == 0)

	cmp	DWORD PTR _segment_passes$2$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 254  :         for (scan=this; scan != NULL; scan = next_scan)

	mov	edx, DWORD PTR tv3489[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1831 :           if (segment_passes == 0)

	jne	SHORT $LN23@encode
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 254  :         for (scan=this; scan != NULL; scan = next_scan)

	mov	ecx, edx
	test	edx, edx
	je	SHORT $LN23@encode
$LL215@encode:

; 255  :           {
; 256  :             assert(!scan->active);
; 257  :             next_scan = scan->prev;

	mov	eax, DWORD PTR [ecx+32]

; 258  :             scan->next = scan->prev = NULL;

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0

; 259  :             scan->truncation_point_found = false;

	mov	BYTE PTR [ecx+28], 0

; 260  :             scan->buf_start = scan->buf_next = NULL;

	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+16], 0
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL215@encode
$LN23@encode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1483 :       for (; z < block->num_passes; z++, k++)

	mov	eax, DWORD PTR _z$1$[ebp]
	add	edx, 40					; 00000028H
	mov	ecx, DWORD PTR _k$1$[ebp]
	inc	eax
	dec	DWORD PTR tv3487[ebp]
	inc	ecx
	movsd	xmm3, QWORD PTR _pass_wmse_scale$1$[ebp]
	movsd	xmm4, QWORD PTR __real@3fd0000000000000
	mov	esi, DWORD PTR _segment_bytes$1$[ebp]
	mov	DWORD PTR tv3489[ebp], edx
	mov	edx, DWORD PTR tv3488[ebp]
	mov	DWORD PTR _z$1$[ebp], eax
	mov	DWORD PTR _k$1$[ebp], ecx
	cmp	eax, DWORD PTR [edi+48]
	jl	$LL25@encode
$LN24@encode:

; 1832 :             { // Finish cleaning up the completed codeword segment.
; 1833 :               assert(first_unsized_z == (z+1));
; 1834 :               pass_encoders[z].finish();
; 1835 :             }
; 1836 :         }
; 1837 : 
; 1838 :       assert(segment_passes == 0);
; 1839 :       assert(first_unsized_z == block->num_passes);
; 1840 : 
; 1841 :       if (msb_wmse > 0.0)

	movsd	xmm1, QWORD PTR _msb_wmse$[ebp]
	xorps	xmm0, xmm0
	comisd	xmm1, xmm0
	jbe	$LN5@encode

; 1842 :         { /* Form the convex hull set.  We could have done most of the work
; 1843 :              incrementally as the lengths became available -- see above.
; 1844 :              However, there is little value to this in the present
; 1845 :              implementation.  A hardware implementation may prefer the
; 1846 :              incremental calculation approach for all quantities, so that
; 1847 :              slopes and lengths can be dispatched in a covnenient interleaved
; 1848 :              fashion to memory as they become available. */
; 1849 :           find_convex_hull(block->pass_lengths,pass_wmse_changes,

	push	DWORD PTR [edi+48]
	lea	eax, DWORD PTR _pass_wmse_changes$[ebp]
	push	DWORD PTR [edi+56]
	push	eax
	push	DWORD PTR [edi+52]
	call	?find_convex_hull@@YAXQAHQANQAGH@Z	; find_convex_hull

; 1850 :                            block->pass_slopes,block->num_passes);
; 1851 : 
; 1852 : 
; 1853 : 		  //liuf - pass_slopes[i]
; 1854 : 
; 1855 : 		  if (percep_coding == true)
; 1856 : 		  {
; 1857 : 			  kdu_uint16 min_value = 65535;
; 1858 : 			  if((max_coeff<jnd_threshold)||(jnd_threshold>100))

	movsd	xmm0, QWORD PTR _jnd_threshold$1$[ebp]
	add	esp, 16					; 00000010H
	comisd	xmm0, QWORD PTR _max_coeff$2$[ebp]
	ja	SHORT $LN145@encode
	comisd	xmm0, QWORD PTR __real@4059000000000000
	ja	SHORT $LN145@encode

; 1863 : 				  }
; 1864 : 			  }
; 1865 : 			  else
; 1866 : 			  {
; 1867 : 				for (int i = 0; i < block->num_passes; i++)

	xor	ecx, ecx
	cmp	DWORD PTR [edi+48], ecx
	jle	SHORT $LN69@encode
	npad	7
$LL73@encode:

; 1868 : 				{
; 1869 : 					  /*if (pass_dist[i] < min_value )
; 1870 : 					{
; 1871 : 						  min_value = pass_dist[i];
; 1872 : 						  block->pass_slopes[i] = pass_dist[i];
; 1873 : 					}
; 1874 : 					else 
; 1875 : 						  block->pass_slopes[i] = 0;*/
; 1876 : 					if(below_threshold==true)

	cmp	BYTE PTR _below_threshold$1$[ebp], 1

; 1879 : 							  block->pass_slopes[i]=2;

	mov	eax, DWORD PTR [edi+56]
	jne	SHORT $LN146@encode

; 1877 : 					{
; 1878 : 						  if(i<=firstlowidx)

	cmp	ecx, DWORD PTR _firstlowidx$1$[ebp]
	jg	SHORT $LN148@encode

; 1879 : 							  block->pass_slopes[i]=2;

	mov	edx, 2

; 1880 : 						  else

	jmp	SHORT $LN460@encode
$LN146@encode:

; 1881 : 							  block->pass_slopes[i]=0;
; 1882 : 					}
; 1883 : 					else
; 1884 : 					{
; 1885 : 						  if(i<=minmaxdistidx)

	cmp	ecx, DWORD PTR _minmaxdistidx$1$[ebp]
	jg	SHORT $LN148@encode

; 1886 : 							  block->pass_slopes[i]=2;

	mov	edx, 2

; 1887 : 						  else

	jmp	SHORT $LN460@encode
$LN148@encode:

; 1888 : 							  block->pass_slopes[i]=0;

	xor	edx, edx
$LN460@encode:
	mov	WORD PTR [eax+ecx*2], dx
	inc	ecx
	cmp	ecx, DWORD PTR [edi+48]
	jl	SHORT $LL73@encode

; 1746 :               }
; 1747 :           }
; 1748 : 
; 1749 :           if (percep_coding == false && estimated_slope_threshold > 0.0)
; 1750 :             { // See if we can finish up early to save time and memory.
; 1751 :               /* The heuristic is as follows:
; 1752 :                    1) We examine potential truncation points (coding passes),
; 1753 :                       t <= z, finding the distortion length slopes, S_t,
; 1754 :                       which would arise at those points if they were to lie
; 1755 :                       on the convex hull.  This depends only upon distortion
; 1756 :                       and length information for coding passes <= t.
; 1757 :                    2) Let I=[z0,z] be the smallest interval which contains
; 1758 :                       three potential convex hull points, t1 < t2 < t3.
; 1759 :                       By "potential convex hull points", we simply mean that
; 1760 :                       S_t1 >= S_t2 >= S_t3 > 0.  If no such interval exists,
; 1761 :                       set z0=0 and I=[0,z].
; 1762 :                    3) We terminate coding here if all the following conditions
; 1763 :                       hold:
; 1764 :                       a) Interval I contains at least 3 points.
; 1765 :                       b) Interval I contains at least 2 potential convex hull
; 1766 :                          points.
; 1767 :                       c) For each t in I=[z0,z], S_t < alpha(z-t) * S_min,
; 1768 :                          where S_min is the value of `expected_slope_threshold'
; 1769 :                          and alpha(q) = 3^floor(q/3).  This means that
; 1770 :                          alpha(z-t) = 1 for t in {z,z-1,z-2};
; 1771 :                          alpha(z-t) = 3 for t in {z-3,z-4,z-5}; etc.
; 1772 :                          The basic idea is to raise the slope threshold by
; 1773 :                          3 each time we move to another bit-plane.  The base
; 1774 :                          of 3 represents a degree of conservatism, since at
; 1775 :                          high bit-rates we expect the slope to change by a
; 1776 :                          factor of 4 for each extra bit-plane.
; 1777 :               */
; 1778 :               int num_hull_points=0;
; 1779 :               int u, z0;
; 1780 :               double last_deltaD, last_deltaL;
; 1781 :               double deltaD, deltaL, best_deltaD, best_deltaL;
; 1782 :               for (z0=z; (z0 >= 0) && (num_hull_points < 3); z0--)
; 1783 :                 {
; 1784 :                   for (deltaL=0.0, deltaD=0.0, u=z0;
; 1785 :                        (u >= 0) && (u > (z0-7)); u--)
; 1786 :                     {
; 1787 :                       deltaL += block->pass_lengths[u];
; 1788 :                       deltaD += pass_wmse_changes[u];
; 1789 :                       if ((u==z0) ||
; 1790 :                           ((best_deltaD*deltaL) > (deltaD*best_deltaL)))
; 1791 :                         { best_deltaD=deltaD;  best_deltaL=deltaL; }
; 1792 :                     }
; 1793 :                   double ref = estimated_slope_threshold*best_deltaL;
; 1794 :                   for (u = z-z0; u > 2; u-=3)
; 1795 :                     ref *= 3.0;
; 1796 :                   if (best_deltaD > ref)

	jmp	SHORT $LN69@encode
$LN145@encode:

; 1859 : 			  {
; 1860 : 				  for (int i = 0; i < block->num_passes; i++)

	xor	ecx, ecx
	cmp	DWORD PTR [edi+48], ecx
	jle	SHORT $LN69@encode
	npad	1
$LL70@encode:

; 1861 : 				  {
; 1862 : 					  block->pass_slopes[i]=0;

	mov	eax, DWORD PTR [edi+56]
	xor	edx, edx
	mov	WORD PTR [eax+ecx*2], dx
	inc	ecx
	cmp	ecx, DWORD PTR [edi+48]
	jl	SHORT $LL70@encode
$LN69@encode:

; 1889 : 					}
; 1890 : 				}
; 1891 : 			  }
; 1892 : 
; 1893 : 		  }
; 1894 : 
; 1895 : 
; 1896 : 
; 1897 :           if (reversible && (block->num_passes > 0) &&

	cmp	BYTE PTR _reversible$[ebp], 0
	je	SHORT $LN5@encode
	mov	eax, DWORD PTR [edi+48]
	test	eax, eax
	jle	SHORT $LN5@encode
	mov	ecx, DWORD PTR _full_reversible_passes$1$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN5@encode

; 1898 :               (block->num_passes == full_reversible_passes))
; 1899 :             { /* Must force last coding pass onto convex hull.  Otherwise, a
; 1900 :                  decompressor using something other than the mid-point rounding
; 1901 :                  rule can fail to achieve lossless decompression. */
; 1902 :               z = full_reversible_passes-1;
; 1903 :               if (block->pass_slopes[z] == 0)

	mov	eax, DWORD PTR [edi+56]
	cmp	WORD PTR [eax+ecx*2-2], 0
	jne	SHORT $LN5@encode

; 1904 :                 block->pass_slopes[z] = 1; /* Works because

	mov	edx, 1
	mov	WORD PTR [eax+ecx*2-2], dx
$LN5@encode:

; 1905 :                       `find_convex_hull_slopes' never generates slopes of 1. */
; 1906 :             }
; 1907 :         }
; 1908 :     } while ((--cpu_counter) > 0);

	mov	eax, DWORD PTR _cpu_counter$1$[ebp]
	mov	esi, DWORD PTR _num_stripes$1$[ebp]
	dec	eax
	mov	ecx, DWORD PTR tv3514[ebp]
	test	eax, eax
	mov	DWORD PTR _cpu_counter$1$[ebp], eax
	mov	eax, DWORD PTR tv3513[ebp]
	jg	$LL7@encode
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 6345 :         if (cpu_iterations == 0) return;

	cmp	DWORD PTR [edi+132], 0
	pop	esi
	je	SHORT $LN217@encode

; 6346 :         cpu_time += clock() - cpu_start;

	call	DWORD PTR __imp__clock
	sub	eax, DWORD PTR [edi+144]
	add	DWORD PTR [edi+148], eax

; 6347 :         cpu_unique_samples += size.x*size.y;

	mov	eax, DWORD PTR [edi]
	imul	eax, DWORD PTR [edi+4]
	cdq
	add	DWORD PTR [edi+136], eax
	adc	DWORD PTR [edi+140], edx
$LN217@encode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp

; 1910 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?encode@kd_block_encoder@@MAEXPAUkdu_block@@_NNG@Z ENDP	; kd_block_encoder::encode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
;	COMDAT ?check_in@mq_encoder@@QAEXHHPAE@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
_temp$ = 12						; size = 4
_store$ = 16						; size = 4
?check_in@mq_encoder@@QAEXHHPAE@Z PROC			; mq_encoder::check_in, COMDAT
; _this$ = ecx

; 284  :       { // Use this form for raw codeword segments.

	push	ebp
	mov	ebp, esp

; 285  :         assert(active && checked_out && !MQ_segment); checked_out = false;
; 286  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _store$[ebp]
	mov	BYTE PTR [ecx+25], 0
	mov	DWORD PTR [ecx+20], eax

; 287  :       }

	pop	ebp
	ret	12					; 0000000cH
?check_in@mq_encoder@@QAEXHHPAE@Z ENDP			; mq_encoder::check_in
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
;	COMDAT ?check_in@mq_encoder@@QAEXHHHHPAE@Z
_TEXT	SEGMENT
_A$ = 8							; size = 4
_C$ = 12						; size = 4
_t$ = 16						; size = 4
_temp$ = 20						; size = 4
_store$ = 24						; size = 4
?check_in@mq_encoder@@QAEXHHHHPAE@Z PROC		; mq_encoder::check_in, COMDAT
; _this$ = ecx

; 278  :       { // Use this form for MQ codeword segments.

	push	ebp
	mov	ebp, esp

; 279  :         assert(active && checked_out && MQ_segment); checked_out = false;
; 280  :         this->A = A; this->C = C;

	mov	eax, DWORD PTR _A$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _C$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 281  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _store$[ebp]
	mov	BYTE PTR [ecx+25], 0
	mov	DWORD PTR [ecx+20], eax

; 282  :       }

	pop	ebp
	ret	20					; 00000014H
?check_in@mq_encoder@@QAEXHHHHPAE@Z ENDP		; mq_encoder::check_in
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
;	COMDAT ?check_out@mq_encoder@@QAEXAAH0AAPAE@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
_temp$ = 12						; size = 4
_store$ = 16						; size = 4
?check_out@mq_encoder@@QAEXAAH0AAPAE@Z PROC		; mq_encoder::check_out, COMDAT
; _this$ = ecx

; 272  :       { // Use this form for raw codeword segments.

	push	ebp
	mov	ebp, esp

; 273  :         assert(active && (!checked_out) && !MQ_segment); checked_out = true;
; 274  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	eax, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+25], 1
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _temp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _store$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax], ecx

; 275  :       }

	pop	ebp
	ret	12					; 0000000cH
?check_out@mq_encoder@@QAEXAAH0AAPAE@Z ENDP		; mq_encoder::check_out
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
;	COMDAT ?check_out@mq_encoder@@QAEXAAH000AAPAE@Z
_TEXT	SEGMENT
_A$ = 8							; size = 4
_C$ = 12						; size = 4
_t$ = 16						; size = 4
_temp$ = 20						; size = 4
_store$ = 24						; size = 4
?check_out@mq_encoder@@QAEXAAH000AAPAE@Z PROC		; mq_encoder::check_out, COMDAT
; _this$ = ecx

; 266  :       { // Use this form for MQ codeword segments.

	push	ebp
	mov	ebp, esp

; 267  :         assert(active && (!checked_out) && MQ_segment); checked_out = true;
; 268  :         A = this->A; C = this->C;

	mov	eax, DWORD PTR _A$[ebp]
	push	esi
	mov	esi, ecx
	mov	edx, DWORD PTR [esi]
	mov	BYTE PTR [esi+25], 1
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _C$[ebp]
	mov	DWORD PTR [eax], edx

; 269  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	eax, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _temp$[ebp]
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _store$[ebp]
	mov	ecx, DWORD PTR [esi+20]
	pop	esi
	mov	DWORD PTR [eax], ecx

; 270  :       }

	pop	ebp
	ret	20					; 00000014H
?check_out@mq_encoder@@QAEXAAH000AAPAE@Z ENDP		; mq_encoder::check_out
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
;	COMDAT ?finish@mq_encoder@@QAEXXZ
_TEXT	SEGMENT
?finish@mq_encoder@@QAEXXZ PROC				; mq_encoder::finish, COMDAT
; _this$ = ecx

; 249  :            (the same one which you invoked `terminate' on) to reset all
; 250  :            objects in the segment in preparation for later calls to the
; 251  :            `start' member function. */
; 252  :         assert((!active) && (next == NULL));
; 253  :         mq_encoder *scan, *next_scan;
; 254  :         for (scan=this; scan != NULL; scan = next_scan)

	test	ecx, ecx
	je	SHORT $LN3@finish
$LL4@finish:

; 255  :           {
; 256  :             assert(!scan->active);
; 257  :             next_scan = scan->prev;

	mov	eax, DWORD PTR [ecx+32]

; 258  :             scan->next = scan->prev = NULL;

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0

; 259  :             scan->truncation_point_found = false;

	mov	BYTE PTR [ecx+28], 0

; 260  :             scan->buf_start = scan->buf_next = NULL;

	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+16], 0
	mov	ecx, eax
	test	eax, eax
	jne	SHORT $LL4@finish
$LN3@finish:

; 261  :           }
; 262  :       }

	ret	0
?finish@mq_encoder@@QAEXXZ ENDP				; mq_encoder::finish
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
;	COMDAT ?get_incremental_length@mq_encoder@@QAEHAA_N@Z
_TEXT	SEGMENT
_final$ = 8						; size = 4
?get_incremental_length@mq_encoder@@QAEHAA_N@Z PROC	; mq_encoder::get_incremental_length, COMDAT
; _this$ = ecx

; 192  :       { /* This function returns the number of additional code bytes generated

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, ecx

; 193  :            by this object, beyond the point of continuation from any
; 194  :            previous object in a continuation list.  If possible, the function
; 195  :            invokes the truncation point optimization algorithm for this
; 196  :            object and all objects which it continues and have not already
; 197  :            had their truncation points determined.  This will not be possible
; 198  :            if the object is still active or it has been continued by another
; 199  :            object which has generated less than 5 additional bytes so far.
; 200  :            If truncation point optimization is not possible, the `final'
; 201  :            argument is set to false and the function returns a reasonable
; 202  :            lower bound (not quite a guaranteed bound) for the length, which
; 203  :            is the number of bytes which have actually been put onto the
; 204  :            byte buffer beyond the point of continuation (or the start of the
; 205  :            buffer).  The return value is guaranteed to be non-negative. */
; 206  :         if (!truncation_point_found)

	cmp	BYTE PTR [ebx+28], 0
	jne	SHORT $LN22@get_increm

; 207  :           {
; 208  :             mq_encoder *scan_ahead = this;
; 209  :             while (scan_ahead->next != NULL) scan_ahead = scan_ahead->next;

	mov	eax, DWORD PTR [ebx+36]
	push	edi
	mov	edi, ebx
	test	eax, eax
	je	SHORT $LN3@get_increm
$LL2@get_increm:
	mov	edi, eax
	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	jne	SHORT $LL2@get_increm
$LN3@get_increm:
	push	esi

; 210  :             mq_encoder *scan_back = scan_ahead;

	mov	esi, edi
$LL6@get_increm:

; 212  :               {
; 213  :                 if (scan_back->truncation_point_found)

	cmp	BYTE PTR [esi+28], 0
	jne	SHORT $LN24@get_increm

; 214  :                   break;
; 215  :                 if ((!scan_back->active) &&

	cmp	BYTE PTR [esi+27], 0
	jne	SHORT $LN4@get_increm
	mov	ecx, DWORD PTR [edi+20]
	mov	eax, ecx
	sub	eax, DWORD PTR [esi+20]
	cmp	eax, 5
	jl	SHORT $LN4@get_increm

; 216  :                     ((scan_ahead->buf_next - scan_back->buf_next) >= 5))
; 217  :                   scan_back->find_truncation_point(scan_ahead->buf_next);

	push	ecx
	mov	ecx, esi
	call	?find_truncation_point@mq_encoder@@AAEXPAE@Z ; mq_encoder::find_truncation_point
$LN4@get_increm:

; 211  :             for (; scan_back != NULL; scan_back=scan_back->prev)

	mov	esi, DWORD PTR [esi+32]
	test	esi, esi
	jne	SHORT $LL6@get_increm
$LN24@get_increm:
	pop	esi
	pop	edi
$LN22@get_increm:

; 218  :               }
; 219  :           }
; 220  :         final = truncation_point_found;

	mov	eax, DWORD PTR _final$[ebp]
	mov	cl, BYTE PTR [ebx+28]
	mov	BYTE PTR [eax], cl

; 221  :         if (prev == NULL)

	mov	ecx, DWORD PTR [ebx+32]

; 222  :           return (int)(buf_next - buf_start);

	mov	eax, DWORD PTR [ebx+20]
	test	ecx, ecx
	jne	SHORT $LN10@get_increm
	sub	eax, DWORD PTR [ebx+16]
	pop	ebx

; 225  :       }

	pop	ebp
	ret	4
$LN10@get_increm:

; 223  :         else
; 224  :           return (int)(buf_next - prev->buf_next);

	sub	eax, DWORD PTR [ecx+20]
	pop	ebx

; 225  :       }

	pop	ebp
	ret	4
?get_incremental_length@mq_encoder@@QAEHAA_N@Z ENDP	; mq_encoder::get_incremental_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
;	COMDAT ?continues@mq_encoder@@QAEXPAV1@@Z
_TEXT	SEGMENT
_previous$ = 8						; size = 4
?continues@mq_encoder@@QAEXPAV1@@Z PROC			; mq_encoder::continues, COMDAT
; _this$ = ecx

; 180  :       { /* Use this function to continue a coding segment beyond the current

	push	ebp
	mov	ebp, esp

; 181  :            coding pass.  This sets up internal references between the
; 182  :            coding objects which manage the same codeword segment, so that
; 183  :            truncation point computation may be performed later. */
; 184  :         assert((!active) && (buf_start == NULL));
; 185  :         assert(previous->active); // Can't continue an inactive segment.
; 186  :         assert(!previous->checked_out);
; 187  :         *this = *previous;

	mov	eax, DWORD PTR _previous$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [ecx+16], xmm0
	movq	xmm0, QWORD PTR [eax+32]
	movq	QWORD PTR [ecx+32], xmm0

; 188  :         prev = previous; previous->next = this;

	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [eax+36], ecx

; 189  :         previous->active = false;

	mov	BYTE PTR [eax+27], 0

; 190  :       }

	pop	ebp
	ret	4
?continues@mq_encoder@@QAEXPAV1@@Z ENDP			; mq_encoder::continues
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
;	COMDAT ?augment_buffer@mq_encoder@@QAEXPAE0@Z
_TEXT	SEGMENT
_old_handle$ = 8					; size = 4
_new_handle$ = 12					; size = 4
?augment_buffer@mq_encoder@@QAEXPAE0@Z PROC		; mq_encoder::augment_buffer, COMDAT
; _this$ = ecx

; 166  :       { /* Use this if you need to increase the size of the buffer.  You must

	push	ebp
	mov	ebp, esp
	push	esi

; 167  :            first create the new buffer and copy the old buffer's contents into
; 168  :            the new buffer.  Then call this function for every `mqe_coder'
; 169  :            object which is using the buffer. The object will alter its internal
; 170  :            pointers accordingly.   The `old_handle' and `new_handle' pointers
; 171  :            should generally point to the first allocated location in each of
; 172  :            the original and new buffers. */
; 173  :         if (buf_start == NULL)

	mov	esi, DWORD PTR [ecx+16]
	test	esi, esi
	je	SHORT $LN1@augment_bu

; 174  :           return; // Encoder finished working with buffer
; 175  :         assert((!checked_out) && (old_handle != NULL) && (new_handle != NULL));
; 176  :         buf_start += (new_handle-old_handle);

	sub	esi, DWORD PTR _old_handle$[ebp]
	mov	eax, DWORD PTR _new_handle$[ebp]
	add	esi, eax

; 177  :         buf_next += (new_handle-old_handle);

	sub	eax, DWORD PTR _old_handle$[ebp]
	add	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+16], esi
$LN1@augment_bu:
	pop	esi

; 178  :       }

	pop	ebp
	ret	8
?augment_buffer@mq_encoder@@QAEXPAE0@Z ENDP		; mq_encoder::augment_buffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
;	COMDAT ?get_bytes_used@mq_encoder@@QAEHXZ
_TEXT	SEGMENT
?get_bytes_used@mq_encoder@@QAEHXZ PROC			; mq_encoder::get_bytes_used, COMDAT
; _this$ = ecx

; 157  :            supplied in the `start' call which have been used by this object
; 158  :            and any previous objects which it continues.  The function is
; 159  :            provided only to facilitate determination by the user as to whether
; 160  :            or not buffer space will need to be augmented.  There is no
; 161  :            attempt to determine truncation lengths. */
; 162  :         assert((!checked_out) && (buf_start != NULL));
; 163  :         return (int)(buf_next-buf_start);

	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]

; 164  :       }

	ret	0
?get_bytes_used@mq_encoder@@QAEHXZ ENDP			; mq_encoder::get_bytes_used
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
;	COMDAT ??0mq_encoder@@QAE@XZ
_TEXT	SEGMENT
??0mq_encoder@@QAE@XZ PROC				; mq_encoder::mq_encoder, COMDAT
; _this$ = ecx

; 140  :       { active = false; buf_start=buf_next=NULL; prev=next=NULL; }

	mov	BYTE PTR [ecx+27], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+32], 0
	ret	0
??0mq_encoder@@QAE@XZ ENDP				; mq_encoder::mq_encoder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
;	COMDAT ?init@mqe_state@@QAEXHH@Z
_TEXT	SEGMENT
_Sigma$ = 8						; size = 4
_s$ = 12						; size = 4
?init@mqe_state@@QAEXHH@Z PROC				; mqe_state::init, COMDAT
; _this$ = ecx

; 332  : {

	push	ebp
	mov	ebp, esp

; 333  :   assert((Sigma >= 0) && (Sigma <= 46) && (s == (s&1)));
; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	mov	edx, DWORD PTR _Sigma$[ebp]
	push	esi
	mov	esi, DWORD PTR _s$[ebp]
	imul	eax, esi, -2147483648
	add	eax, DWORD PTR ?p_bar_table@mq_encoder@@2PAHA[edx*4]
	mov	DWORD PTR [ecx], eax

; 335  :   transition = mq_encoder::transition_table + ((Sigma<<1) + s);

	lea	eax, DWORD PTR [esi+edx*2]
	shl	eax, 4
	add	eax, OFFSET ?transition_table@mq_encoder@@2PAUmqe_transition@@A ; mq_encoder::transition_table
	mov	DWORD PTR [ecx+4], eax
	pop	esi

; 336  : }

	pop	ebp
	ret	8
?init@mqe_state@@QAEXHH@Z ENDP				; mqe_state::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ??0kdu_block_encoder@@QAE@XZ
_TEXT	SEGMENT
??0kdu_block_encoder@@QAE@XZ PROC			; kdu_block_encoder::kdu_block_encoder, COMDAT
; _this$ = ecx

; 1257 : {

	push	esi

; 1258 :   state = new kd_block_encoder;

	push	4
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@kdu_block_
	mov	DWORD PTR [eax], OFFSET ??_7kd_block_encoder@@6B@
	mov	DWORD PTR [esi], eax

; 1259 : }

	mov	eax, esi
	pop	esi
	ret	0
$LN3@kdu_block_:

; 1258 :   state = new kd_block_encoder;

	mov	DWORD PTR [esi], 0

; 1259 : }

	mov	eax, esi
	pop	esi
	ret	0
??0kdu_block_encoder@@QAE@XZ ENDP			; kdu_block_encoder::kdu_block_encoder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
;	COMDAT ??_Gkdu_block_encoder_base@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkdu_block_encoder_base@@MAEPAXI@Z PROC		; kdu_block_encoder_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 76   :     virtual ~kdu_block_encoder_base() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_block_encoder_base@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkdu_block_encoder_base@@MAEPAXI@Z ENDP		; kdu_block_encoder_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0kdu_block_encoder_base@@QAE@XZ
_TEXT	SEGMENT
??0kdu_block_encoder_base@@QAE@XZ PROC			; kdu_block_encoder_base::kdu_block_encoder_base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kdu_block_encoder_base@@6B@
	mov	eax, ecx
	ret	0
??0kdu_block_encoder_base@@QAE@XZ ENDP			; kdu_block_encoder_base::kdu_block_encoder_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
;	COMDAT ??1kdu_block_encoder_base@@MAE@XZ
_TEXT	SEGMENT
??1kdu_block_encoder_base@@MAE@XZ PROC			; kdu_block_encoder_base::~kdu_block_encoder_base, COMDAT
; _this$ = ecx

; 76   :     virtual ~kdu_block_encoder_base() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_block_encoder_base@@6B@
	ret	0
??1kdu_block_encoder_base@@MAE@XZ ENDP			; kdu_block_encoder_base::~kdu_block_encoder_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?finish_timing@kdu_block@@QAEXXZ
_TEXT	SEGMENT
?finish_timing@kdu_block@@QAEXXZ PROC			; kdu_block::finish_timing, COMDAT
; _this$ = ecx

; 6344 :       { /* [SYNOPSIS] See `start_timing'. */

	push	esi
	mov	esi, ecx

; 6345 :         if (cpu_iterations == 0) return;

	cmp	DWORD PTR [esi+132], 0
	je	SHORT $LN1@finish_tim

; 6346 :         cpu_time += clock() - cpu_start;

	call	DWORD PTR __imp__clock
	sub	eax, DWORD PTR [esi+144]
	add	DWORD PTR [esi+148], eax

; 6347 :         cpu_unique_samples += size.x*size.y;

	mov	eax, DWORD PTR [esi+4]
	imul	eax, DWORD PTR [esi]
	cdq
	add	DWORD PTR [esi+136], eax
	adc	DWORD PTR [esi+140], edx
$LN1@finish_tim:
	pop	esi

; 6348 :       }

	ret	0
?finish_timing@kdu_block@@QAEXXZ ENDP			; kdu_block::finish_timing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?start_timing@kdu_block@@QAEHXZ
_TEXT	SEGMENT
?start_timing@kdu_block@@QAEHXZ PROC			; kdu_block::start_timing, COMDAT
; _this$ = ecx

; 6332 :       {

	push	esi
	mov	esi, ecx

; 6333 :       /* [SYNOPSIS]
; 6334 :            If the block encoder or decoder supports the gathering of timing
; 6335 :            statistics, it should do so by calling this function at the start
; 6336 :            of a timing loop and `finish_timing' at the end of the loop; the
; 6337 :            number of times to execute the loop is the return value from the
; 6338 :            function.
; 6339 :       */
; 6340 :         if (cpu_iterations == 0) return 1;

	cmp	DWORD PTR [esi+132], 0
	jne	SHORT $LN2@start_timi
	mov	eax, 1
	pop	esi

; 6342 :       }

	ret	0
$LN2@start_timi:

; 6341 :         cpu_start = clock(); return cpu_iterations;

	call	DWORD PTR __imp__clock
	mov	DWORD PTR [esi+144], eax
	mov	eax, DWORD PTR [esi+132]
	pop	esi

; 6342 :       }

	ret	0
?start_timing@kdu_block@@QAEHXZ ENDP			; kdu_block::start_timing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?get_y@kdu_coords@@QAEHXZ
_TEXT	SEGMENT
?get_y@kdu_coords@@QAEHXZ PROC				; kdu_coords::get_y, COMDAT
; _this$ = ecx

; 217  :     int get_y() { return y; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?get_y@kdu_coords@@QAEHXZ ENDP				; kdu_coords::get_y
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?get_x@kdu_coords@@QAEHXZ
_TEXT	SEGMENT
?get_x@kdu_coords@@QAEHXZ PROC				; kdu_coords::get_x, COMDAT
; _this$ = ecx

; 216  :     int get_x() { return x; }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?get_x@kdu_coords@@QAEHXZ ENDP				; kdu_coords::get_x
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\visual studio\vc\include\cmath
;	COMDAT ?abs@@YANN@Z
_TEXT	SEGMENT
tv68 = -8						; size = 8
__Xx$ = 8						; size = 8
?abs@@YANN@Z PROC					; abs, COMDAT

; 36   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 37   : 	return (_CSTD fabs(_Xx));

	movsd	xmm0, QWORD PTR __Xx$[ebp]
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movsd	QWORD PTR tv68[ebp], xmm0
	fld	QWORD PTR tv68[ebp]

; 38   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?abs@@YANN@Z ENDP					; abs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 950  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);
; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	esi, DWORD PTR __Format$[ebp]
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	eax
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	pop	esi

; 955  :     __crt_va_end(_ArgList);
; 956  :     return _Result;
; 957  : }

	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\visual studio\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 638  : {

	push	ebp
	mov	ebp, esp

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 640  : }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_encoder.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
