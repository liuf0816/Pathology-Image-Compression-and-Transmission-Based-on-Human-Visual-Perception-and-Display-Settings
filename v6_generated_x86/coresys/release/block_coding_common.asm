; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\coding\block_coding_common.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?hl_sig_lut@@3PAEA				; hl_sig_lut
PUBLIC	?lh_sig_lut@@3PAEA				; lh_sig_lut
PUBLIC	?hh_sig_lut@@3PAEA				; hh_sig_lut
PUBLIC	?sign_lut@@3PAEA				; sign_lut
_BSS	SEGMENT
?hl_sig_lut@@3PAEA DB 0200H DUP (?)			; hl_sig_lut
?lh_sig_lut@@3PAEA DB 0200H DUP (?)			; lh_sig_lut
?hh_sig_lut@@3PAEA DB 0200H DUP (?)			; hh_sig_lut
?sign_lut@@3PAEA DB 0100H DUP (?)			; sign_lut
_BSS	ENDS
_BSS	SEGMENT
?_do_it@@3Vcoding_common_local_init@@A DB 01H DUP (?)	; _do_it
_BSS	ENDS
CRT$XCU	SEGMENT
?_do_it$initializer$@@3P6AXXZA DD FLAT:??__E_do_it@@YAXXZ ; _do_it$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_coding_common.cpp
;	COMDAT ??__E_do_it@@YAXXZ
text$di	SEGMENT
??__E_do_it@@YAXXZ PROC					; `dynamic initializer for '_do_it'', COMDAT

; 65   :               { initialize_significance_luts();

	call	?initialize_significance_luts@@YAXXZ	; initialize_significance_luts

; 66   :                 initialize_sign_lut(); }

	jmp	?initialize_sign_lut@@YAXXZ		; initialize_sign_lut
??__E_do_it@@YAXXZ ENDP					; `dynamic initializer for '_do_it''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_coding_common.cpp
;	COMDAT ??0coding_common_local_init@@QAE@XZ
_TEXT	SEGMENT
??0coding_common_local_init@@QAE@XZ PROC		; coding_common_local_init::coding_common_local_init, COMDAT
; _this$ = ecx

; 64   :     public: coding_common_local_init()

	push	esi
	mov	esi, ecx

; 65   :               { initialize_significance_luts();

	call	?initialize_significance_luts@@YAXXZ	; initialize_significance_luts

; 66   :                 initialize_sign_lut(); }

	call	?initialize_sign_lut@@YAXXZ		; initialize_sign_lut
	mov	eax, esi
	pop	esi
	ret	0
??0coding_common_local_init@@QAE@XZ ENDP		; coding_common_local_init::coding_common_local_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_coding_common.cpp
;	COMDAT ?initialize_sign_lut@@YAXXZ
_TEXT	SEGMENT
_vneg$1$ = -4						; size = 4
?initialize_sign_lut@@YAXXZ PROC			; initialize_sign_lut, COMDAT

; 162  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi

; 163  :   kdu_int32 idx, vpos, vneg, hpos, hneg, kappa, predict, v1, v2;
; 164  : 
; 165  :   for (idx=0; idx < 256; idx++)

	xor	ebx, ebx
	npad	7
$LL16@initialize:

; 166  :     {
; 167  :       vpos = vneg = hpos = hneg = 0;

	xor	ecx, ecx
	xor	edi, edi
	xor	esi, esi
	mov	DWORD PTR _vneg$1$[ebp], ecx
	xor	eax, eax

; 168  :       if ((idx >> UP_NBR_SIGMA_POS) & 1)

	test	bl, 1
	je	SHORT $LN17@initialize

; 169  :         {
; 170  :           kappa = (idx >> UP_NBR_CHI_POS) & 1;

	mov	ecx, ebx

; 171  :           vneg |= kappa;
; 172  :           vpos |= 1-kappa;

	mov	eax, 1
	sar	ecx, 1
	and	ecx, 1
	mov	DWORD PTR _vneg$1$[ebp], ecx
	sub	eax, ecx
$LN17@initialize:

; 173  :         }
; 174  :       if ((idx >> DOWN_NBR_SIGMA_POS) & 1)

	test	bl, 64					; 00000040H
	je	SHORT $LN18@initialize

; 175  :         {
; 176  :           kappa = (idx >> DOWN_NBR_CHI_POS) & 1;

	mov	edx, ebx
	sar	edx, 7
	and	edx, 1

; 177  :           vneg |= kappa;

	or	ecx, edx
	mov	DWORD PTR _vneg$1$[ebp], ecx

; 178  :           vpos |= 1-kappa;

	mov	ecx, 1
	sub	ecx, edx
	or	eax, ecx
$LN18@initialize:

; 179  :         }
; 180  :       if ((idx >> LEFT_NBR_SIGMA_POS) & 1)

	test	bl, 4
	je	SHORT $LN19@initialize

; 181  :         {
; 182  :           kappa = (idx >> LEFT_NBR_CHI_POS) & 1;

	mov	edi, ebx

; 183  :           hneg |= kappa;
; 184  :           hpos |= 1-kappa;

	mov	esi, 1
	sar	edi, 3
	and	edi, 1
	sub	esi, edi
$LN19@initialize:

; 185  :         }
; 186  :       if ((idx >> RIGHT_NBR_SIGMA_POS) & 1)

	test	bl, 16					; 00000010H
	je	SHORT $LN20@initialize

; 187  :         {
; 188  :           kappa = (idx >> RIGHT_NBR_CHI_POS) & 1;

	mov	edx, ebx

; 189  :           hneg |= kappa;
; 190  :           hpos |= 1-kappa;

	mov	ecx, 1
	sar	edx, 5
	and	edx, 1
	sub	ecx, edx
	or	edi, edx
	or	esi, ecx
$LN20@initialize:

; 191  :         }
; 192  :       v1 = hpos-hneg;
; 193  :       v2 = vpos-vneg;

	sub	eax, DWORD PTR _vneg$1$[ebp]

; 194  :       predict = 0;

	xor	ecx, ecx
	sub	esi, edi

; 195  :       if (v1 < 0)

	jns	SHORT $LN21@initialize

; 196  :         {
; 197  :           predict = 1;
; 198  :           v1 = -v1;

	neg	esi
	mov	ecx, 1

; 199  :           v2 = -v2;

	neg	eax
$LN21@initialize:

; 200  :         }
; 201  :       if (v1 == 0)

	test	esi, esi
	jne	SHORT $LN23@initialize

; 202  :         {
; 203  :           if (v2 < 0)

	test	eax, eax
	jns	SHORT $LN24@initialize

; 204  :             {
; 205  :               predict = 1;

	lea	ecx, DWORD PTR [esi+1]

; 206  :               v2 = -v2;

	neg	eax

; 207  :             }
; 208  :           kappa = v2;
; 209  :         }
; 210  :       else

	jmp	SHORT $LN24@initialize
$LN23@initialize:

; 211  :         kappa = 3 + v2;

	add	eax, 3
$LN24@initialize:

; 212  : 
; 213  :       sign_lut[idx] = (kdu_byte)((kappa<<1) | predict);

	add	al, al
	or	al, cl
	mov	BYTE PTR ?sign_lut@@3PAEA[ebx], al
	inc	ebx
	cmp	ebx, 256				; 00000100H
	jl	$LL16@initialize
	pop	edi
	pop	esi
	pop	ebx

; 214  :     }
; 215  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?initialize_sign_lut@@YAXXZ ENDP			; initialize_sign_lut
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_coding_common.cpp
;	COMDAT ?initialize_significance_luts@@YAXXZ
_TEXT	SEGMENT
tv364 = -16						; size = 4
tv363 = -12						; size = 4
tv360 = -8						; size = 4
tv361 = -4						; size = 4
?initialize_significance_luts@@YAXXZ PROC		; initialize_significance_luts, COMDAT

; 75   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 76   :   kdu_int32 idx, kappa, v1, v2, v3;
; 77   : 
; 78   :   for (idx=0; idx < 512; idx++)

	xor	edx, edx
	push	ebx
	push	esi
	push	edi
	npad	5
$LL36@initialize:

; 79   :     {
; 80   :       // Start with the context map for the HL (horizontally high-pass) band
; 81   : 
; 82   :       v1 = ((idx>>SIGMA_TC_POS)&1) + ((idx>>SIGMA_BC_POS)&1);

	mov	eax, edx
	mov	ecx, edx
	sar	eax, 7

; 83   :       v2 = ((idx>>SIGMA_CL_POS)&1) + ((idx>>SIGMA_CR_POS)&1);
; 84   :       v3 = ((idx>>SIGMA_TL_POS)&1) + ((idx>>SIGMA_TR_POS)&1) +

	mov	esi, edx
	and	eax, 1
	sar	ecx, 1
	mov	DWORD PTR tv364[ebp], eax
	and	ecx, 1
	mov	DWORD PTR tv363[ebp], ecx
	sar	esi, 8
	and	esi, 1
	lea	ebx, DWORD PTR [ecx+eax]
	mov	eax, edx
	sar	eax, 5
	mov	ecx, edx
	and	eax, 1
	sar	ecx, 3
	mov	DWORD PTR tv361[ebp], eax
	and	ecx, 1
	mov	DWORD PTR tv360[ebp], ecx
	lea	edi, DWORD PTR [ecx+eax]
	mov	eax, edx
	sar	eax, 6
	and	eax, 1
	add	esi, eax
	mov	eax, edx
	sar	eax, 2
	and	eax, 1
	add	esi, eax
	mov	eax, edx
	and	eax, 1
	add	esi, eax

; 85   :            ((idx>>SIGMA_BL_POS)&1) + ((idx>>SIGMA_BR_POS)&1);
; 86   :       if (v1 == 2)

	cmp	ebx, 2
	jne	SHORT $LN37@initialize

; 87   :         kappa = 8;

	lea	eax, DWORD PTR [ebx+6]
	jmp	SHORT $LN43@initialize
$LN37@initialize:

; 88   :       else if (v1 == 1)

	cmp	ebx, 1
	jne	SHORT $LN41@initialize

; 89   :         {
; 90   :           if (v2)

	test	edi, edi
	je	SHORT $LN38@initialize

; 91   :             kappa = 7;

	lea	eax, DWORD PTR [ebx+6]
	jmp	SHORT $LN43@initialize
$LN38@initialize:

; 92   :           else if (v3)

	xor	eax, eax
	test	esi, esi
	setne	al
	add	eax, 5

; 93   :             kappa = 6;
; 94   :           else
; 95   :             kappa = 5;
; 96   :         }
; 97   :       else

	jmp	SHORT $LN43@initialize
$LN41@initialize:

; 98   :         {
; 99   :           if (v2)

	test	edi, edi
	je	SHORT $LN42@initialize

; 100  :             kappa = 2+v2;

	lea	eax, DWORD PTR [edi+2]

; 101  :           else

	jmp	SHORT $LN43@initialize
$LN42@initialize:

; 102  :             kappa = 0 + ((v3>2)?2:v3);

	cmp	esi, 2
	mov	eax, esi
	mov	ecx, 2
	cmovg	eax, ecx
$LN43@initialize:

; 103  :         }
; 104  :       hl_sig_lut[idx] = (kdu_byte) kappa;

	mov	BYTE PTR ?hl_sig_lut@@3PAEA[edx], al

; 105  :     
; 106  :     //  Now build the context map for the LH (vertically high-pass) band
; 107  : 
; 108  :       v1 = ((idx>>SIGMA_CL_POS)&1) + ((idx>>SIGMA_CR_POS)&1);
; 109  :       v2 = ((idx>>SIGMA_TC_POS)&1) + ((idx>>SIGMA_BC_POS)&1);
; 110  :       v3 = ((idx>>SIGMA_TL_POS)&1) + ((idx>>SIGMA_TR_POS)&1) +
; 111  :            ((idx>>SIGMA_BL_POS)&1) + ((idx>>SIGMA_BR_POS)&1);
; 112  :       if (v1 == 2)

	cmp	edi, 2
	jne	SHORT $LN44@initialize

; 113  :         kappa = 8;

	lea	eax, DWORD PTR [edi+6]
	mov	ebx, edi
	jmp	SHORT $LN50@initialize
$LN44@initialize:

; 114  :       else if (v1 == 1)

	cmp	edi, 1
	jne	SHORT $LN48@initialize

; 115  :         {
; 116  :           if (v2)

	test	ebx, ebx

; 117  :             kappa = 7;

	lea	ebx, DWORD PTR [edi+1]
	je	SHORT $LN45@initialize
	lea	eax, DWORD PTR [edi+6]
	jmp	SHORT $LN50@initialize
$LN45@initialize:

; 118  :           else if (v3)

	xor	eax, eax
	test	esi, esi
	setne	al
	add	eax, 5

; 119  :             kappa = 6;
; 120  :           else
; 121  :             kappa = 5;
; 122  :         }
; 123  :       else

	jmp	SHORT $LN50@initialize
$LN48@initialize:

; 124  :         {
; 125  :           if (v2)

	test	ebx, ebx
	je	SHORT $LN49@initialize

; 126  :             kappa = 2+v2;

	lea	eax, DWORD PTR [ebx+2]

; 127  :           else

	mov	ebx, 2
	jmp	SHORT $LN50@initialize
$LN49@initialize:

; 128  :             kappa = 0 + ((v3>2)?2:v3);

	cmp	esi, 2
	mov	eax, esi
	mov	ebx, 2
	cmovg	eax, ebx
$LN50@initialize:

; 129  :         }
; 130  :       lh_sig_lut[idx] = (kdu_byte) kappa;
; 131  :       
; 132  :       // Finally, build the context map for the HH band
; 133  : 
; 134  :       v1 = ((idx>>SIGMA_TL_POS)&1) + ((idx>>SIGMA_TR_POS)&1) +
; 135  :            ((idx>>SIGMA_BL_POS)&1) + ((idx>>SIGMA_BR_POS)&1);
; 136  :       v2 = ((idx>>SIGMA_CL_POS)&1) + ((idx>>SIGMA_CR_POS)&1) +

	mov	ecx, DWORD PTR tv360[ebp]
	add	ecx, DWORD PTR tv361[ebp]
	add	ecx, DWORD PTR tv363[ebp]
	add	ecx, DWORD PTR tv364[ebp]
	mov	BYTE PTR ?lh_sig_lut@@3PAEA[edx], al

; 137  :            ((idx>>SIGMA_TC_POS)&1) + ((idx>>SIGMA_BC_POS)&1);
; 138  : 
; 139  :       if (v1 >= 3)

	cmp	esi, 3
	jl	SHORT $LN51@initialize

; 140  :         kappa = 8;

	mov	eax, 8
	jmp	SHORT $LN56@initialize
$LN51@initialize:

; 141  :       else if (v1 == 2)

	cmp	esi, 2
	jne	SHORT $LN54@initialize

; 142  :         {
; 143  :           if (v2 >= 1)

	xor	eax, eax
	cmp	ecx, 1
	setge	al
	add	eax, 6

; 144  :             kappa = 7;
; 145  :           else
; 146  :             kappa = 6;

	jmp	SHORT $LN56@initialize
$LN54@initialize:

; 147  :         }
; 148  :       else if (v1 == 1)
; 149  :         kappa = 3 + ((v2>2)?2:v2);

	mov	eax, ecx
	cmp	esi, 1
	jne	SHORT $LN55@initialize
	cmp	ecx, 2
	cmovg	eax, ebx
	add	eax, 3

; 150  :       else

	jmp	SHORT $LN56@initialize
$LN55@initialize:

; 151  :         kappa = 0 + ((v2>2)?2:v2);

	cmp	ecx, 2
	cmovg	eax, ebx
$LN56@initialize:

; 152  :       hh_sig_lut[idx] = (kdu_byte) kappa;

	mov	BYTE PTR ?hh_sig_lut@@3PAEA[edx], al
	inc	edx
	cmp	edx, 512				; 00000200H
	jl	$LL36@initialize
	pop	edi
	pop	esi
	pop	ebx

; 153  :     }
; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?initialize_significance_luts@@YAXXZ ENDP		; initialize_significance_luts
_TEXT	ENDS
END
