; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\coding\mq_encoder.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?p_bar_table@mq_encoder@@2PAHA			; mq_encoder::p_bar_table
PUBLIC	?transition_table@mq_encoder@@2PAUmqe_transition@@A ; mq_encoder::transition_table
_BSS	SEGMENT
?transition_table@mq_encoder@@2PAUmqe_transition@@A DB 05e0H DUP (?) ; mq_encoder::transition_table
_BSS	ENDS
_DATA	SEGMENT
?p_bar_table@mq_encoder@@2PAHA DD 05601H		; mq_encoder::p_bar_table
	DD	03401H
	DD	01801H
	DD	0ac1H
	DD	0521H
	DD	0221H
	DD	05601H
	DD	05401H
	DD	04801H
	DD	03801H
	DD	03001H
	DD	02401H
	DD	01c01H
	DD	01601H
	DD	05601H
	DD	05401H
	DD	05101H
	DD	04801H
	DD	03801H
	DD	03401H
	DD	03001H
	DD	02801H
	DD	02401H
	DD	02201H
	DD	01c01H
	DD	01801H
	DD	01601H
	DD	01401H
	DD	01201H
	DD	01101H
	DD	0ac1H
	DD	09c1H
	DD	08a1H
	DD	0521H
	DD	0441H
	DD	02a1H
	DD	0221H
	DD	0141H
	DD	0111H
	DD	085H
	DD	049H
	DD	025H
	DD	015H
	DD	09H
	DD	05H
	DD	01H
	DD	05601H
_DATA	ENDS
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	?start@mq_encoder@@QAEXPAE_N@Z			; mq_encoder::start
PUBLIC	?terminate@mq_encoder@@QAEPAE_N@Z		; mq_encoder::terminate
PUBLIC	?mq_encode@mq_encoder@@QAEXHAAUmqe_state@@@Z	; mq_encoder::mq_encode
PUBLIC	?mq_encode_run@mq_encoder@@QAEXH@Z		; mq_encoder::mq_encode_run
PUBLIC	?raw_encode@mq_encoder@@QAEXH@Z			; mq_encoder::raw_encode
PUBLIC	?transfer_byte@mq_encoder@@AAEXXZ		; mq_encoder::transfer_byte
PUBLIC	?find_truncation_point@mq_encoder@@AAEXPAE@Z	; mq_encoder::find_truncation_point
PUBLIC	__xmm@00000003000000020000000100000000
PUBLIC	__xmm@00000004000000030000000200000001
PUBLIC	__xmm@00000008000000070000002600000005
PUBLIC	__xmm@0000000c000000090000000600000001
PUBLIC	__xmm@0000000c0000000b0000000a00000009
PUBLIC	__xmm@0000000e00000006000000210000001d
PUBLIC	__xmm@0000000e0000000e0000001500000014
PUBLIC	__xmm@0000000f0000000f0000000f0000000f
PUBLIC	__xmm@00000012000000110000000e0000000e
PUBLIC	__xmm@0000001200000011000000100000000f
PUBLIC	__xmm@00000013000000130000001300000013
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?_do_it@@3Vmq_encoder_local_init@@A DB 01H DUP (?)	; _do_it
_BSS	ENDS
CRT$XCU	SEGMENT
?_do_it$initializer$@@3P6AXXZA DD FLAT:??__E_do_it@@YAXXZ ; _do_it$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@00000013000000130000001300000013
CONST	SEGMENT
__xmm@00000013000000130000001300000013 DB 013H, 00H, 00H, 00H, 013H, 00H, 00H
	DB	00H, 013H, 00H, 00H, 00H, 013H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000001200000011000000100000000f
CONST	SEGMENT
__xmm@0000001200000011000000100000000f DB 0fH, 00H, 00H, 00H, 010H, 00H, 00H
	DB	00H, 011H, 00H, 00H, 00H, 012H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000012000000110000000e0000000e
CONST	SEGMENT
__xmm@00000012000000110000000e0000000e DB 0eH, 00H, 00H, 00H, 0eH, 00H, 00H
	DB	00H, 011H, 00H, 00H, 00H, 012H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000f0000000f0000000f0000000f
CONST	SEGMENT
__xmm@0000000f0000000f0000000f0000000f DB 0fH, 00H, 00H, 00H, 0fH, 00H, 00H
	DB	00H, 0fH, 00H, 00H, 00H, 0fH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000e0000000e0000001500000014
CONST	SEGMENT
__xmm@0000000e0000000e0000001500000014 DB 014H, 00H, 00H, 00H, 015H, 00H, 00H
	DB	00H, 0eH, 00H, 00H, 00H, 0eH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000e00000006000000210000001d
CONST	SEGMENT
__xmm@0000000e00000006000000210000001d DB 01dH, 00H, 00H, 00H, '!', 00H, 00H
	DB	00H, 06H, 00H, 00H, 00H, 0eH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000c0000000b0000000a00000009
CONST	SEGMENT
__xmm@0000000c0000000b0000000a00000009 DB 09H, 00H, 00H, 00H, 0aH, 00H, 00H
	DB	00H, 0bH, 00H, 00H, 00H, 0cH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000c000000090000000600000001
CONST	SEGMENT
__xmm@0000000c000000090000000600000001 DB 01H, 00H, 00H, 00H, 06H, 00H, 00H
	DB	00H, 09H, 00H, 00H, 00H, 0cH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000008000000070000002600000005
CONST	SEGMENT
__xmm@00000008000000070000002600000005 DB 05H, 00H, 00H, 00H, '&', 00H, 00H
	DB	00H, 07H, 00H, 00H, 00H, 08H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000004000000030000000200000001
CONST	SEGMENT
__xmm@00000004000000030000000200000001 DB 01H, 00H, 00H, 00H, 02H, 00H, 00H
	DB	00H, 03H, 00H, 00H, 00H, 04H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000003000000020000000100000000
CONST	SEGMENT
__xmm@00000003000000020000000100000000 DB 00H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 02H, 00H, 00H, 00H, 03H, 00H, 00H, 00H
CONST	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
;	COMDAT ??__E_do_it@@YAXXZ
text$di	SEGMENT
??__E_do_it@@YAXXZ PROC					; `dynamic initializer for '_do_it'', COMDAT

; 68   :               { initialize_transition_table(); }

	jmp	?initialize_transition_table@@YAXXZ	; initialize_transition_table
??__E_do_it@@YAXXZ ENDP					; `dynamic initializer for '_do_it''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
;	COMDAT ??0mq_encoder_local_init@@QAE@XZ
_TEXT	SEGMENT
??0mq_encoder_local_init@@QAE@XZ PROC			; mq_encoder_local_init::mq_encoder_local_init, COMDAT
; _this$ = ecx

; 67   :     public: mq_encoder_local_init()

	push	esi
	mov	esi, ecx

; 68   :               { initialize_transition_table(); }

	call	?initialize_transition_table@@YAXXZ	; initialize_transition_table
	mov	eax, esi
	pop	esi
	ret	0
??0mq_encoder_local_init@@QAE@XZ ENDP			; mq_encoder_local_init::mq_encoder_local_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
;	COMDAT ?initialize_transition_table@@YAXXZ
_TEXT	SEGMENT
_Sigma_lps$ = -380					; size = 188
_Sigma_mps$ = -192					; size = 188
__$ArrayPad$ = -4					; size = 4
?initialize_transition_table@@YAXXZ PROC		; initialize_transition_table, COMDAT

; 77   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 380				; 0000017cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	movaps	xmm0, XMMWORD PTR __xmm@00000004000000030000000200000001

; 78   :   int Sigma_mps[47] =
; 79   :     { 1, 2, 3, 4, 5,38, 7, 8, 9,10,11,12,13,29,15,16,17,18,19,20,21,22,23,24,

	lea	edx, DWORD PTR _Sigma_mps$[ebp+72]
	movaps	xmm1, XMMWORD PTR __xmm@00000003000000020000000100000000
	xor	ecx, ecx
	movaps	xmm2, XMMWORD PTR __xmm@0000000f0000000f0000000f0000000f
	movups	XMMWORD PTR _Sigma_mps$[ebp], xmm0
	mov	DWORD PTR _Sigma_mps$[ebp+48], 13	; 0000000dH
	movaps	xmm0, XMMWORD PTR __xmm@00000008000000070000002600000005
	movups	XMMWORD PTR _Sigma_mps$[ebp+16], xmm0
	mov	DWORD PTR _Sigma_mps$[ebp+52], 29	; 0000001dH
	movaps	xmm0, XMMWORD PTR __xmm@0000000c0000000b0000000a00000009
	movups	XMMWORD PTR _Sigma_mps$[ebp+32], xmm0
$LL13@initialize:
	movd	xmm0, ecx
	lea	eax, DWORD PTR [ecx+4]
	pshufd	xmm0, xmm0, 0
	lea	edx, DWORD PTR [edx+32]
	paddd	xmm0, xmm1
	add	ecx, 8
	paddd	xmm0, xmm2
	movups	XMMWORD PTR [edx-48], xmm0
	movd	xmm0, eax
	pshufd	xmm0, xmm0, 0
	paddd	xmm0, xmm1
	paddd	xmm0, xmm2
	movups	XMMWORD PTR [edx-32], xmm0
	cmp	ecx, 24					; 00000018H
	jl	SHORT $LL13@initialize
	cmp	ecx, 31					; 0000001fH
	jge	SHORT $LN14@initialize
	lea	eax, DWORD PTR [ecx+15]
	lea	ecx, DWORD PTR _Sigma_mps$[ebp+ecx*4+56]
	npad	5
$LL20@initialize:
	mov	DWORD PTR [ecx], eax
	lea	ecx, DWORD PTR [ecx+4]
	inc	eax
	cmp	eax, 46					; 0000002eH
	jl	SHORT $LL20@initialize
$LN14@initialize:
	movaps	xmm0, XMMWORD PTR __xmm@0000000c000000090000000600000001

; 80   :      25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,45,46};

	lea	edx, DWORD PTR _Sigma_lps$[ebp+100]
	movaps	xmm2, XMMWORD PTR __xmm@00000013000000130000001300000013

; 81   :   int Sigma_lps[47] =
; 82   :     { 1, 6, 9,12,29,33, 6,14,14,14,17,18,20,21,14,14,15,16,17,18,19,19,20,21,

	xor	ecx, ecx
	movups	XMMWORD PTR _Sigma_lps$[ebp], xmm0
	mov	DWORD PTR _Sigma_mps$[ebp+180], 45	; 0000002dH
	movaps	xmm0, XMMWORD PTR __xmm@0000000e00000006000000210000001d
	movups	XMMWORD PTR _Sigma_lps$[ebp+16], xmm0
	mov	DWORD PTR _Sigma_mps$[ebp+184], 46	; 0000002eH
	movaps	xmm0, XMMWORD PTR __xmm@00000012000000110000000e0000000e
	movups	XMMWORD PTR _Sigma_lps$[ebp+32], xmm0
	mov	DWORD PTR _Sigma_lps$[ebp+80], 19	; 00000013H
	movaps	xmm0, XMMWORD PTR __xmm@0000000e0000000e0000001500000014
	movups	XMMWORD PTR _Sigma_lps$[ebp+48], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@0000001200000011000000100000000f
	movups	XMMWORD PTR _Sigma_lps$[ebp+64], xmm0
	npad	8
$LL15@initialize:
	movd	xmm0, ecx
	lea	eax, DWORD PTR [ecx+4]
	pshufd	xmm0, xmm0, 0
	lea	edx, DWORD PTR [edx+32]
	paddd	xmm0, xmm1
	add	ecx, 8
	paddd	xmm0, xmm2
	movups	XMMWORD PTR [edx-48], xmm0
	movd	xmm0, eax
	pshufd	xmm0, xmm0, 0
	paddd	xmm0, xmm1
	paddd	xmm0, xmm2
	movups	XMMWORD PTR [edx-32], xmm0
	cmp	ecx, 24					; 00000018H
	jl	SHORT $LL15@initialize
	cmp	ecx, 25					; 00000019H
	jge	SHORT $LN16@initialize
	lea	eax, DWORD PTR [ecx+19]
	lea	ecx, DWORD PTR _Sigma_lps$[ebp+ecx*4+84]
$LL22@initialize:
	mov	DWORD PTR [ecx], eax
	lea	ecx, DWORD PTR [ecx+4]
	inc	eax
	cmp	eax, 44					; 0000002cH
	jl	SHORT $LL22@initialize
$LN16@initialize:
	push	ebx
	push	esi
	push	edi

; 83   :      22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,46};

	mov	DWORD PTR _Sigma_lps$[ebp+184], 46	; 0000002eH

; 85   :   for (kdu_int32 n=0; n < 94; n++)

	xor	edi, edi
	mov	edx, OFFSET ?transition_table@mq_encoder@@2PAUmqe_transition@@A+12
$LL4@initialize:

; 86   :     {
; 87   :       kdu_int32 s, new_s;
; 88   :       int Sigma, new_Sigma;
; 89   : 
; 90   :       s = n & 1;
; 91   :       Sigma = n >> 1;

	mov	ebx, edi
	mov	esi, edi
	sar	ebx, 1
	and	esi, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	imul	eax, esi, -2147483648
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp

; 94   :       new_Sigma = Sigma_mps[Sigma];

	mov	ecx, DWORD PTR _Sigma_mps$[ebp+ebx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	add	eax, DWORD PTR ?p_bar_table@mq_encoder@@2PAHA[ecx*4]
	mov	DWORD PTR [edx-12], eax

; 335  :   transition = mq_encoder::transition_table + ((Sigma<<1) + s);

	lea	eax, DWORD PTR [esi+ecx*2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp

; 98   :       new_Sigma = Sigma_lps[Sigma];

	mov	ecx, DWORD PTR _Sigma_lps$[ebp+ebx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 335  :   transition = mq_encoder::transition_table + ((Sigma<<1) + s);

	shl	eax, 4
	add	eax, OFFSET ?transition_table@mq_encoder@@2PAUmqe_transition@@A
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp

; 100  :       if ((mq_encoder::p_bar_table[Sigma] == 0x5601) && (Sigma != 46))

	cmp	DWORD PTR ?p_bar_table@mq_encoder@@2PAHA[ebx*4], 22017 ; 00005601H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 335  :   transition = mq_encoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR [edx-8], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp

; 100  :       if ((mq_encoder::p_bar_table[Sigma] == 0x5601) && (Sigma != 46))

	jne	SHORT $LN5@initialize
	cmp	ebx, 46					; 0000002eH
	je	SHORT $LN5@initialize

; 101  :         new_s = 1-s;

	mov	eax, 1
	sub	eax, esi
	mov	esi, eax
$LN5@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	imul	eax, esi, -2147483648
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp

; 85   :   for (kdu_int32 n=0; n < 94; n++)

	inc	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	add	eax, DWORD PTR ?p_bar_table@mq_encoder@@2PAHA[ecx*4]
	mov	DWORD PTR [edx-4], eax

; 335  :   transition = mq_encoder::transition_table + ((Sigma<<1) + s);

	lea	eax, DWORD PTR [esi+ecx*2]
	shl	eax, 4
	add	eax, OFFSET ?transition_table@mq_encoder@@2PAUmqe_transition@@A
	mov	DWORD PTR [edx], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp

; 85   :   for (kdu_int32 n=0; n < 94; n++)

	add	edx, 16					; 00000010H
	cmp	edx, OFFSET ?transition_table@mq_encoder@@2PAUmqe_transition@@A+1516
	jl	SHORT $LL4@initialize

; 102  :       mq_encoder::transition_table[n].lps.init(new_Sigma,new_s);
; 103  :     }
; 104  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?initialize_transition_table@@YAXXZ ENDP		; initialize_transition_table
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
;	COMDAT ?find_truncation_point@mq_encoder@@AAEXPAE@Z
_TEXT	SEGMENT
_CplusA_low$1$ = -24					; size = 4
_C_low$1$ = -20						; size = 4
_s$1$ = -16						; size = 4
_CplusA_high$1$ = -12					; size = 4
_C_high$1$ = -8						; size = 4
_save_byte$1$ = -1					; size = 1
_limit$ = 8						; size = 4
?find_truncation_point@mq_encoder@@AAEXPAE@Z PROC	; mq_encoder::find_truncation_point, COMDAT
; _this$ = ecx

; 238  : {

	push	ebp
	mov	ebp, esp
	mov	eax, ecx
	sub	esp, 24					; 00000018H

; 239  :   assert(!active);
; 240  :   assert(!truncation_point_found);
; 241  : 
; 242  :   if (MQ_segment)

	cmp	BYTE PTR [eax+26], 0
	je	$LN6@find_trunc

; 243  :     { /* Find F_min using the algorithm developed in Section 12.3.2 of the
; 244  :          book by Taubman and Marcellin.  You will have a lot of trouble
; 245  :          understanding how this algorithm works without reading the book.  To
; 246  :          deal with the limitations of a 32-bit word length, we represent the
; 247  :          quantities Cr-R_F and Ar+Cr-R_F as follows:
; 248  :             Cr-R_F = C_low + C_high*2^{27}
; 249  :             Cr+Ar-R_F = CplusA_low + CplusA_high*2^{27}
; 250  :          During the iterative loop to find F_min, each iteration shifts
; 251  :          the quantities, Cr-R_F and Cr+Ar-R_F up by s bit positions before
; 252  :          performing the relevant termination tests.  These modifications have
; 253  :          no impact on the outcome of the algorithm described in the book, but
; 254  :          are simpler to implement in the context of our split numeric
; 255  :          representation. */
; 256  :       kdu_byte save_byte = buf_start[-1];

	mov	ecx, DWORD PTR [eax+16]
	push	ebx
	push	esi
	push	edi
	mov	dl, BYTE PTR [ecx-1]

; 257  :       buf_start[-1] = 0; // Need this for algorithm to work in all cases

	mov	BYTE PTR [ecx-1], 0

; 258  : 
; 259  :       kdu_int32 C_low = C<<t;
; 260  :       kdu_int32 CplusA_low = (C+A)<<t;

	mov	edi, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+8]
	add	edi, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR [eax+4]
	shl	ebx, cl
	shl	edi, cl

; 261  :       kdu_int32 C_high = temp;

	mov	ecx, DWORD PTR [eax+12]

; 262  :       kdu_int32 CplusA_high = temp;

	mov	esi, ecx
	mov	BYTE PTR _save_byte$1$[ebp], dl
	mov	DWORD PTR _C_low$1$[ebp], ebx
	mov	DWORD PTR _CplusA_low$1$[ebp], edi
	mov	DWORD PTR _C_high$1$[ebp], ecx
	mov	DWORD PTR _CplusA_high$1$[ebp], esi

; 263  :       if (C_low & MQE_CARRY_BIT)

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN8@find_trunc

; 264  :         { C_high++; C_low -= MQE_CARRY_BIT; }

	inc	ecx
	sub	ebx, 134217728				; 08000000H
	mov	DWORD PTR _C_high$1$[ebp], ecx
	mov	DWORD PTR _C_low$1$[ebp], ebx
$LN8@find_trunc:

; 265  :       if (CplusA_low & MQE_CARRY_BIT)

	test	edi, 134217728				; 08000000H
	je	SHORT $LN9@find_trunc

; 266  :         { CplusA_high++; CplusA_low -= MQE_CARRY_BIT; }

	inc	esi
	sub	edi, 134217728				; 08000000H
	mov	DWORD PTR _CplusA_high$1$[ebp], esi
	mov	DWORD PTR _CplusA_low$1$[ebp], edi
$LN9@find_trunc:

; 267  : 
; 268  :       int s = 8;

	mov	ebx, 8
	mov	DWORD PTR _s$1$[ebp], ebx
$LL2@find_trunc:

; 269  :       int F_min = 0;
; 270  : 
; 271  :       while ((C_high > 0xFF) || (CplusA_high <= 0xFF))

	cmp	ecx, 255				; 000000ffH
	jg	SHORT $LN10@find_trunc
	cmp	esi, 255				; 000000ffH
	jg	$LN3@find_trunc
$LN10@find_trunc:

; 272  :         {
; 273  :           assert(buf_next < limit);
; 274  :           F_min++;
; 275  : 
; 276  :           /* Augment R_F (Bear in mind that the high quantities always
; 277  :              hold the most significant 8 bits of the S_F-bit nominal
; 278  :              word sizes.  Instead of successively decreasing S_F by s,
; 279  :              we are leaving S_F the same and successively up-shifting
; 280  :              the words by s -- same thing. */
; 281  : 
; 282  :           temp = *(buf_next++);

	mov	edx, DWORD PTR [eax+20]
	movzx	ecx, BYTE PTR [edx]
	mov	DWORD PTR [eax+12], ecx
	lea	ecx, DWORD PTR [edx+1]

; 283  :           C_high -= temp << (8-s);

	mov	esi, DWORD PTR [eax+12]
	mov	edx, ebx
	neg	edx
	mov	DWORD PTR [eax+20], ecx
	lea	ecx, DWORD PTR [edx+8]

; 284  :           CplusA_high -= temp << (8-s);
; 285  : 
; 286  :           // Shift Cr-R_F up by s bit positions
; 287  :           C_high <<= s;
; 288  :           C_high += C_low >> (MQE_CARRY_POS-s);

	lea	edi, DWORD PTR [edx+27]
	shl	esi, cl
	mov	edx, DWORD PTR _C_high$1$[ebp]
	mov	ecx, DWORD PTR _s$1$[ebp]
	sub	edx, esi
	shl	edx, cl
	mov	ecx, edi
	mov	DWORD PTR _C_high$1$[ebp], edx
	mov	edx, DWORD PTR _C_low$1$[ebp]
	sar	edx, cl
	add	DWORD PTR _C_high$1$[ebp], edx

; 289  :           C_low <<= s;

	mov	ecx, DWORD PTR _s$1$[ebp]
	mov	edx, DWORD PTR _C_low$1$[ebp]
	shl	edx, cl

; 290  :           C_low &= ~(((kdu_int32)(-1))<<MQE_CARRY_POS);

	and	edx, 134217727				; 07ffffffH
	mov	DWORD PTR _C_low$1$[ebp], edx
	mov	edx, DWORD PTR _CplusA_high$1$[ebp]
	sub	edx, esi

; 291  : 
; 292  :           // Shift Cr+Ar-R_F up by s bit positions
; 293  :           CplusA_high <<= s;

	shl	edx, cl

; 294  :           CplusA_high += CplusA_low >> (MQE_CARRY_POS-s);

	mov	ecx, edi

; 295  :           CplusA_low <<= s;

	mov	edi, DWORD PTR _CplusA_low$1$[ebp]
	mov	DWORD PTR _CplusA_high$1$[ebp], edx
	mov	edx, DWORD PTR _CplusA_low$1$[ebp]
	mov	esi, DWORD PTR _CplusA_high$1$[ebp]
	sar	edx, cl
	mov	ecx, DWORD PTR _s$1$[ebp]
	add	esi, edx
	shl	edi, cl

; 296  :           CplusA_low &= ~(((kdu_int32)(-1))<<MQE_CARRY_POS);
; 297  : 
; 298  :           // Find new value of s
; 299  :           if (temp == 0xFF)

	xor	edx, edx

; 300  :             s = 7;
; 301  :           else
; 302  :             s = 8;
; 303  :         }

	mov	ecx, DWORD PTR _C_high$1$[ebp]
	and	edi, 134217727				; 07ffffffH
	cmp	DWORD PTR [eax+12], 255			; 000000ffH
	mov	DWORD PTR _CplusA_high$1$[ebp], esi
	setne	dl
	mov	DWORD PTR _CplusA_low$1$[ebp], edi
	add	edx, 7
	mov	DWORD PTR _s$1$[ebp], edx
	mov	ebx, edx
	jmp	$LL2@find_trunc
$LN3@find_trunc:

; 304  :       assert(F_min <= 5);
; 305  :       buf_start[-1] = save_byte;

	mov	ecx, DWORD PTR [eax+16]
	mov	dl, BYTE PTR _save_byte$1$[ebp]
	pop	edi
	pop	esi
	mov	BYTE PTR [ecx-1], dl
	pop	ebx

; 306  :     }
; 307  :   else

	jmp	SHORT $LN13@find_trunc
$LN6@find_trunc:

; 308  :     { /* Raw segment.  Nothing to do other than marking the existence of any
; 309  :          partially completed byte and then executing the common code below to
; 310  :          discard trailing strings of 1's, which will be synthesized by the
; 311  :          decoder. */
; 312  :       if (t != 8)

	cmp	DWORD PTR [eax+8], 8
	je	SHORT $LN13@find_trunc

; 313  :         buf_next++;

	inc	DWORD PTR [eax+20]
$LN13@find_trunc:

; 314  :     }
; 315  : 
; 316  :   // Discard trailing FF's or FF7F pairs.
; 317  : 
; 318  :   if ((buf_next > buf_start) && (buf_next[-1] == 0xFF))

	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+16]
	cmp	ecx, edx
	jbe	SHORT $LN17@find_trunc
	dec	ecx
	cmp	BYTE PTR [ecx], 255			; 000000ffH
	jne	SHORT $LN17@find_trunc

; 319  :     buf_next--;

	mov	DWORD PTR [eax+20], ecx
$LN17@find_trunc:

; 320  :   while (((buf_next-buf_start) >= 2)  &&
; 321  :          (buf_next[-1] == 0x7F) && (buf_next[-2] == 0xFF))

	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, edx
	cmp	ecx, 2
	jl	SHORT $LN23@find_trunc
	npad	8
$LL4@find_trunc:
	mov	ecx, DWORD PTR [eax+20]
	cmp	BYTE PTR [ecx-1], 127			; 0000007fH
	jne	SHORT $LN23@find_trunc
	cmp	BYTE PTR [ecx-2], 255			; 000000ffH
	jne	SHORT $LN23@find_trunc

; 322  :     buf_next -= 2;

	add	DWORD PTR [eax+20], -2			; fffffffeH
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, edx
	cmp	ecx, 2
	jge	SHORT $LL4@find_trunc
$LN23@find_trunc:

; 323  : 
; 324  :   truncation_point_found = true;

	mov	BYTE PTR [eax+28], 1

; 325  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?find_truncation_point@mq_encoder@@AAEXPAE@Z ENDP	; mq_encoder::find_truncation_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
;	COMDAT ?transfer_byte@mq_encoder@@AAEXXZ
_TEXT	SEGMENT
?transfer_byte@mq_encoder@@AAEXXZ PROC			; mq_encoder::transfer_byte, COMDAT
; _this$ = ecx

; 335  : {

	push	esi
	mov	esi, ecx

; 336  :   assert(!checked_out);
; 337  :   if (temp == 0xFF)

	mov	edx, DWORD PTR [esi+12]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $LN2@transfer_b

; 338  :     { // Can't propagate carry past this byte; need a bit stuff
; 339  :       *(buf_next++) = (kdu_byte) temp;

	mov	edx, DWORD PTR [esi+20]
	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [edx], al

; 340  :       temp = C >> MQE_MSBS_POS; // Transfer 7 bits plus any carry bit

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, ecx
	inc	DWORD PTR [esi+20]
$LN8@transfer_b:
	sar	eax, 20					; 00000014H

; 341  :       C &= MQE_MSBS_CLEAR;

	and	ecx, 1048575				; 000fffffH

; 342  :       t = 7;

	mov	DWORD PTR [esi+8], 7

; 352  :           C &= MQE_MSBS_CLEAR;
; 353  :           t = 7;
; 354  :         }
; 355  :       else
; 356  :         {
; 357  :           temp = (C>>MQE_PARTIAL_POS);

	mov	DWORD PTR [esi+12], eax

; 358  :           C &= MQE_PARTIAL_CLEAR;

	mov	DWORD PTR [esi+4], ecx
	pop	esi

; 360  :         }
; 361  :     }
; 362  : }

	ret	0
$LN2@transfer_b:

; 343  :     }
; 344  :   else
; 345  :     {
; 346  :       temp += (C>>MQE_CARRY_POS) & 1; // Propagate any carry bit from C to temp

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, ecx

; 347  :       C &= ~MQE_CARRY_BIT; // Reset the carry bit

	and	ecx, -134217729				; f7ffffffH
	sar	eax, 27					; 0000001bH
	mov	DWORD PTR [esi+4], ecx
	and	eax, 1

; 348  :       *(buf_next++) = (kdu_byte) temp;

	mov	ecx, DWORD PTR [esi+20]
	add	eax, edx
	mov	DWORD PTR [esi+12], eax
	mov	BYTE PTR [ecx], al
	inc	DWORD PTR [esi+20]

; 349  :       if (temp == 0xFF) // Decoder will see this as a bit stuff

	cmp	DWORD PTR [esi+12], 255			; 000000ffH

; 350  :         {
; 351  :           temp = (C>>MQE_MSBS_POS);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, ecx
	je	SHORT $LN8@transfer_b

; 352  :           C &= MQE_MSBS_CLEAR;
; 353  :           t = 7;
; 354  :         }
; 355  :       else
; 356  :         {
; 357  :           temp = (C>>MQE_PARTIAL_POS);

	sar	eax, 19					; 00000013H

; 358  :           C &= MQE_PARTIAL_CLEAR;

	and	ecx, 524287				; 0007ffffH

; 359  :           t = 8;

	mov	DWORD PTR [esi+8], 8
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+4], ecx
	pop	esi

; 360  :         }
; 361  :     }
; 362  : }

	ret	0
?transfer_byte@mq_encoder@@AAEXXZ ENDP			; mq_encoder::transfer_byte
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
;	COMDAT ?raw_encode@mq_encoder@@QAEXH@Z
_TEXT	SEGMENT
_symbol$ = 8						; size = 4
?raw_encode@mq_encoder@@QAEXH@Z PROC			; mq_encoder::raw_encode, COMDAT
; _this$ = ecx

; 432  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 433  :   assert((!MQ_segment) && active && (!checked_out) &&
; 434  :          ((symbol == 0) || (symbol == 1)));
; 435  :   if (t == 0)

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN2@raw_encode

; 436  :     {
; 437  :       *(buf_next++) = (kdu_byte) temp;

	mov	edx, DWORD PTR [esi+20]
	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [edx], al

; 438  :       t = (temp == 0xFF)?7:8;

	xor	eax, eax
	inc	DWORD PTR [esi+20]
	cmp	DWORD PTR [esi+12], 255			; 000000ffH

; 439  :       temp = 0;

	mov	DWORD PTR [esi+12], 0
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+8], eax
$LN2@raw_encode:

; 440  :     }
; 441  :   temp = (temp<<1) + symbol;

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR _symbol$[ebp]

; 442  :   t--;

	dec	DWORD PTR [esi+8]
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 443  : }

	pop	ebp
	ret	4
?raw_encode@mq_encoder@@QAEXH@Z ENDP			; mq_encoder::raw_encode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
;	COMDAT ?mq_encode_run@mq_encoder@@QAEXH@Z
_TEXT	SEGMENT
_state$ = -8						; size = 8
_run$ = 8						; size = 4
?mq_encode_run@mq_encoder@@QAEXH@Z PROC			; mq_encoder::mq_encode_run, COMDAT
; _this$ = ecx

; 419  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	mov	eax, DWORD PTR ?p_bar_table@mq_encoder@@2PAHA+184
	push	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp

; 422  :   mq_encode((run&2)<<30,state);

	mov	esi, DWORD PTR _run$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	mov	DWORD PTR _state$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp

; 422  :   mq_encode((run&2)<<30,state);

	lea	eax, DWORD PTR _state$[ebp]
	push	edi
	push	eax
	mov	eax, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h

; 335  :   transition = mq_encoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR _state$[ebp+4], OFFSET ?transition_table@mq_encoder@@2PAUmqe_transition@@A+1472
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp

; 422  :   mq_encode((run&2)<<30,state);

	and	eax, -2					; fffffffeH
	mov	edi, ecx
	shl	eax, 30					; 0000001eH
	push	eax
	call	?mq_encode@mq_encoder@@QAEXHAAUmqe_state@@@Z ; mq_encoder::mq_encode

; 423  :   mq_encode(run<<31,state);

	lea	eax, DWORD PTR _state$[ebp]
	shl	esi, 31					; 0000001fH
	push	eax
	push	esi
	mov	ecx, edi
	call	?mq_encode@mq_encoder@@QAEXHAAUmqe_state@@@Z ; mq_encoder::mq_encode
	pop	edi
	pop	esi

; 424  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?mq_encode_run@mq_encoder@@QAEXH@Z ENDP			; mq_encoder::mq_encode_run
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
;	COMDAT ?mq_encode@mq_encoder@@QAEXHAAUmqe_state@@@Z
_TEXT	SEGMENT
_symbol$ = 8						; size = 4
_state$ = 12						; size = 4
?mq_encode@mq_encoder@@QAEXHAAUmqe_state@@@Z PROC	; mq_encoder::mq_encode, COMDAT
; _this$ = ecx

; 372  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 373  :   assert(MQ_segment && active && (!checked_out) &&
; 374  :          ((symbol==0) || (symbol==KDU_INT32_MIN)));
; 375  : 
; 376  :   kdu_int32 p_bar = state.mps_p_bar & 0x7FFF;

	mov	edi, DWORD PTR _state$[ebp]
	mov	esi, ecx
	mov	ecx, DWORD PTR [edi]

; 377  :   A -= p_bar;

	mov	edx, DWORD PTR [esi]
	and	ecx, 32767				; 00007fffH
	sub	edx, ecx
	mov	DWORD PTR [esi], edx

; 378  :   if (((symbol ^ state.mps_p_bar) & KDU_INT32_MIN) == 0)

	mov	eax, DWORD PTR [edi]
	xor	eax, DWORD PTR _symbol$[ebp]
	js	SHORT $LN8@mq_encode

; 379  :     { // Coding an MPS
; 380  :       if (A >= MQE_A_MIN)

	cmp	edx, 32768				; 00008000H
	jl	SHORT $LN10@mq_encode

; 381  :         { // No renormalization and hence no conditional exchange
; 382  :           C += p_bar;

	add	DWORD PTR [esi+4], ecx
	pop	edi
	pop	esi

; 410  :     }
; 411  : }

	pop	ebp
	ret	8
$LN10@mq_encode:

; 383  :         }
; 384  :       else
; 385  :         { // Renormalization is required.
; 386  :           if (A < p_bar)

	cmp	edx, ecx
	jge	SHORT $LN12@mq_encode

; 387  :             A = p_bar; // Conditional exchange

	mov	DWORD PTR [esi], ecx

; 388  :           else

	jmp	SHORT $LN13@mq_encode
$LN12@mq_encode:

; 389  :             C += p_bar;

	add	DWORD PTR [esi+4], ecx
$LN13@mq_encode:

; 390  :           state = state.transition->mps;

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+4], eax
$LL4@mq_encode:

; 391  :           do {
; 392  :               A += A; C += C; t--;

	mov	eax, DWORD PTR [esi]
	add	eax, eax
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [esi+4]
	add	eax, eax
	add	DWORD PTR [esi+8], -1
	mov	DWORD PTR [esi+4], eax

; 393  :               if (t == 0)

	jne	SHORT $LN2@mq_encode

; 394  :                 transfer_byte();

	mov	ecx, esi
	call	?transfer_byte@mq_encoder@@AAEXXZ	; mq_encoder::transfer_byte
$LN2@mq_encode:

; 395  :             } while (A < MQE_A_MIN);

	cmp	DWORD PTR [esi], 32768			; 00008000H
	jl	SHORT $LL4@mq_encode
	pop	edi
	pop	esi

; 410  :     }
; 411  : }

	pop	ebp
	ret	8
$LN8@mq_encode:

; 396  :         }
; 397  :     }
; 398  :   else
; 399  :     { // Coding an LPS; renormalization is inevitable
; 400  :       if (A < p_bar)

	cmp	edx, ecx
	jge	SHORT $LN15@mq_encode

; 401  :         C += p_bar; // Conditional exchange

	add	DWORD PTR [esi+4], ecx

; 402  :       else

	jmp	SHORT $LN16@mq_encode
$LN15@mq_encode:

; 403  :         A = p_bar;

	mov	DWORD PTR [esi], ecx
$LN16@mq_encode:

; 404  :       state = state.transition->lps;

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edi+4], eax
	npad	6
$LL7@mq_encode:

; 405  :       do {
; 406  :           A += A; C += C; t--;

	mov	eax, DWORD PTR [esi]
	add	eax, eax
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [esi+4]
	add	eax, eax
	add	DWORD PTR [esi+8], -1
	mov	DWORD PTR [esi+4], eax

; 407  :           if (t == 0)

	jne	SHORT $LN5@mq_encode

; 408  :             transfer_byte();

	mov	ecx, esi
	call	?transfer_byte@mq_encoder@@AAEXXZ	; mq_encoder::transfer_byte
$LN5@mq_encode:

; 409  :         } while (A < MQE_A_MIN);

	cmp	DWORD PTR [esi], 32768			; 00008000H
	jl	SHORT $LL7@mq_encode
	pop	edi
	pop	esi

; 410  :     }
; 411  : }

	pop	ebp
	ret	8
?mq_encode@mq_encoder@@QAEXHAAUmqe_state@@@Z ENDP	; mq_encoder::mq_encode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
;	COMDAT ?terminate@mq_encoder@@QAEPAE_N@Z
_TEXT	SEGMENT
_save_buf_next$1$ = -20					; size = 4
_save_buf_next$1$ = -20					; size = 4
_save_t$1$ = -16					; size = 4
_save_temp$1$ = -16					; size = 4
_save_temp$1$ = -12					; size = 4
_save_t$1$ = -12					; size = 4
_save_C$1$ = -8						; size = 4
_save_A$1$ = -4						; size = 4
_optimal$ = 8						; size = 1
?terminate@mq_encoder@@QAEPAE_N@Z PROC			; mq_encoder::terminate, COMDAT
; _this$ = ecx

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 142  :   kdu_byte *buf_limit;
; 143  : 
; 144  :   assert(active);
; 145  :   assert(!checked_out);
; 146  :   if (MQ_segment)

	cmp	BYTE PTR [esi+26], 0
	je	SHORT $LN15@terminate

; 147  :     { /* Perform easy MQ terminating flush (see Section 12.3.1 of the book
; 148  :          by Taubman and Marcellin). */
; 149  :       kdu_int32 save_A = A; // Need these quantities for later calculating

	mov	eax, DWORD PTR [esi]

; 150  :       kdu_int32 save_C = C; // optimal truncation lengths.
; 151  :       kdu_int32 save_t = t;
; 152  :       kdu_int32 save_temp = temp;
; 153  :       kdu_byte *save_buf_next = buf_next;
; 154  : 
; 155  :       int n_bits = MQE_CARRY_POS-15-t; // Number of bits we need to flush.

	mov	edi, 12					; 0000000cH
	mov	ecx, DWORD PTR [esi+8]
	sub	edi, ecx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR _save_A$1$[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _save_C$1$[ebp], eax

; 156  :       C <<= t; // Move the next 8 available bits into the partial byte.

	shl	eax, cl
	mov	DWORD PTR _save_temp$1$[ebp], edx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR _save_t$1$[ebp], ecx
	mov	DWORD PTR _save_buf_next$1$[ebp], edx
	mov	DWORD PTR [esi+4], eax

; 157  :       while (n_bits > 0)

	test	edi, edi
	jle	SHORT $LN3@terminate
	npad	2
$LL2@terminate:

; 158  :         {
; 159  :           transfer_byte();

	mov	ecx, esi
	call	?transfer_byte@mq_encoder@@AAEXXZ	; mq_encoder::transfer_byte

; 160  :           n_bits -= t; // New value of t is the number of bits just transferred

	mov	ecx, DWORD PTR [esi+8]
	sub	edi, ecx

; 161  :           C <<= t;

	shl	DWORD PTR [esi+4], cl
	test	edi, edi
	jg	SHORT $LL2@terminate
$LN3@terminate:

; 162  :         }
; 163  :       transfer_byte(); // Flush the temp byte buffer.

	mov	ecx, esi
	call	?transfer_byte@mq_encoder@@AAEXXZ	; mq_encoder::transfer_byte

; 164  :       buf_limit = buf_next;
; 165  :       if (optimal)

	cmp	BYTE PTR _optimal$[ebp], 0
	mov	ebx, DWORD PTR [esi+20]
	je	SHORT $LN17@terminate

; 166  :         { // Restore previous state so that `find_truncation_point' works.
; 167  :           A = save_A; C = save_C; t = save_t; temp = save_temp;

	mov	eax, DWORD PTR _save_A$1$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _save_C$1$[ebp]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR _save_t$1$[ebp]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR _save_temp$1$[ebp]
	mov	DWORD PTR [esi+12], eax

; 168  :           buf_next = save_buf_next;

	mov	eax, DWORD PTR _save_buf_next$1$[ebp]
	mov	DWORD PTR [esi+20], eax
$LN17@terminate:

; 169  :         }
; 170  :       // Prepare to restore the overwritten byte.
; 171  :       buf_start[-1] = overwritten_byte;

	mov	ecx, DWORD PTR [esi+16]
	mov	al, BYTE PTR [esi+24]
	mov	BYTE PTR [ecx-1], al

; 172  :     }
; 173  :   else

	jmp	$LN23@terminate
$LN15@terminate:

; 174  :     { // Perform raw terminating flush.
; 175  :       kdu_int32 save_t = t;
; 176  :       kdu_int32 save_temp = temp;
; 177  :       kdu_byte *save_buf_next = buf_next;
; 178  :       if (optimal)

	mov	ah, BYTE PTR _optimal$[ebp]
	mov	edx, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+20]
	mov	DWORD PTR _save_t$1$[ebp], edx
	mov	DWORD PTR _save_temp$1$[ebp], ecx
	mov	DWORD PTR _save_buf_next$1$[ebp], edi
	test	ah, ah
	je	SHORT $LN18@terminate

; 179  :         { // For optimal truncation later on, pad with 1's.
; 180  :           if (t != 8)

	cmp	edx, 8
	je	$LN22@terminate

; 181  :             {
; 182  :               for (; t > 0; t--)

	test	edx, edx
	jle	SHORT $LN5@terminate
	mov	eax, edx
$LL6@terminate:
	dec	eax

; 183  :                 temp = (temp<<1) + 1;

	lea	ecx, DWORD PTR [ecx*2+1]
	test	eax, eax
	jg	SHORT $LL6@terminate
	mov	DWORD PTR [esi+8], eax
	mov	ah, BYTE PTR _optimal$[ebp]
	mov	DWORD PTR [esi+12], ecx
$LN5@terminate:

; 184  :               *(buf_next++) = (kdu_byte) temp;

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [edi], al

; 185  :             }
; 186  :         }
; 187  :       else

	jmp	SHORT $LN49@terminate
$LN18@terminate:

; 188  :         { // For error resilient termination, pad with alternating 0/1 sequence
; 189  :           if (temp == 0xFF)

	cmp	ecx, 255				; 000000ffH
	jne	SHORT $LN21@terminate

; 190  :             { // Safest to include stuff bit for resilient raw termination
; 191  :               assert(t==0);
; 192  :               *(buf_next++) = (kdu_byte) temp;

	mov	al, cl
	mov	BYTE PTR [edi], al
	inc	DWORD PTR [esi+20]

; 193  :               temp = 0;

	mov	DWORD PTR [esi+12], 0

; 194  :               t = 7;

	mov	DWORD PTR [esi+8], 7
$LN21@terminate:

; 195  :             }
; 196  :           if (t != 8)

	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, 8
	je	SHORT $LN22@terminate

; 197  :             {
; 198  :               for (int pad=0; t > 0; t--, pad=1-pad)

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN8@terminate
	mov	edi, DWORD PTR [esi+12]
$LL9@terminate:
	mov	eax, 1

; 199  :                 temp = (temp<<1) + pad;

	lea	edi, DWORD PTR [edx+edi*2]
	dec	ecx
	sub	eax, edx
	mov	edx, eax
	test	ecx, ecx
	jg	SHORT $LL9@terminate
	mov	ah, BYTE PTR _optimal$[ebp]
	mov	DWORD PTR [esi+12], edi
	mov	edi, DWORD PTR _save_buf_next$1$[ebp]
	mov	DWORD PTR [esi+8], ecx
$LN8@terminate:

; 200  :               *(buf_next++) = (kdu_byte) temp;

	mov	ecx, DWORD PTR [esi+20]
	mov	al, BYTE PTR [esi+12]
	mov	edx, DWORD PTR _save_t$1$[ebp]
	mov	BYTE PTR [ecx], al
$LN49@terminate:
	inc	DWORD PTR [esi+20]
$LN22@terminate:

; 201  :             }
; 202  :         }
; 203  :       buf_limit = buf_next;

	mov	ebx, DWORD PTR [esi+20]

; 204  :       if (optimal)

	test	ah, ah
	je	SHORT $LN23@terminate

; 205  :         { // Restore previous state so that `find_truncation_point' works.
; 206  :           t = save_t; temp = save_temp; buf_next = save_buf_next;

	mov	eax, DWORD PTR _save_temp$1$[ebp]
	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+20], edi
$LN23@terminate:

; 207  :         }
; 208  :     }
; 209  : 
; 210  :   mq_encoder *scan = this;
; 211  :   while (scan->prev != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN13@terminate
$LL10@terminate:

; 212  :     scan = scan->prev;

	mov	edi, eax
	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	jne	SHORT $LL10@terminate

; 213  :   for (; scan != this; scan=scan->next)

	cmp	edi, esi
	je	SHORT $LN13@terminate
$LL14@terminate:

; 214  :     if (!scan->truncation_point_found)

	cmp	BYTE PTR [edi+28], 0
	jne	SHORT $LN12@terminate

; 215  :       scan->find_truncation_point(buf_limit);

	push	ebx
	mov	ecx, edi
	call	?find_truncation_point@mq_encoder@@AAEXPAE@Z ; mq_encoder::find_truncation_point
$LN12@terminate:

; 213  :   for (; scan != this; scan=scan->next)

	mov	edi, DWORD PTR [edi+36]
	cmp	edi, esi
	jne	SHORT $LL14@terminate
$LN13@terminate:

; 216  : 
; 217  :   active = false;
; 218  : 
; 219  :   if (optimal)

	cmp	BYTE PTR _optimal$[ebp], 0
	mov	BYTE PTR [esi+27], 0
	je	SHORT $LN25@terminate

; 220  :     this->find_truncation_point(buf_limit);

	push	ebx
	mov	ecx, esi
	call	?find_truncation_point@mq_encoder@@AAEXPAE@Z ; mq_encoder::find_truncation_point

; 226  :       truncation_point_found = true;
; 227  :     }
; 228  : 
; 229  :   return buf_next;

	mov	eax, DWORD PTR [esi+20]
	pop	edi
	pop	esi
	pop	ebx

; 230  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN25@terminate:

; 221  :   else
; 222  :     { // Discard any trailing FF, but that is all.
; 223  :       assert(buf_next == buf_limit);
; 224  :       if ((buf_next > buf_start) && (buf_next[-1] == 0xFF))

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN27@terminate
	dec	eax
	cmp	BYTE PTR [eax], 255			; 000000ffH
	jne	SHORT $LN27@terminate

; 225  :         buf_next--;

	mov	DWORD PTR [esi+20], eax
$LN27@terminate:

; 226  :       truncation_point_found = true;
; 227  :     }
; 228  : 
; 229  :   return buf_next;

	mov	eax, DWORD PTR [esi+20]
	pop	edi
	mov	BYTE PTR [esi+28], 1
	pop	esi
	pop	ebx

; 230  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?terminate@mq_encoder@@QAEPAE_N@Z ENDP			; mq_encoder::terminate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.cpp
;	COMDAT ?start@mq_encoder@@QAEXPAE_N@Z
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_MQ_segment$ = 12					; size = 1
?start@mq_encoder@@QAEXPAE_N@Z PROC			; mq_encoder::start, COMDAT
; _this$ = ecx

; 112  : {

	push	ebp
	mov	ebp, esp

; 113  :   assert(!active);
; 114  :   assert(buf_start == NULL);
; 115  :   assert((prev == NULL) && (next == NULL));
; 116  :   assert(buffer != NULL);
; 117  :   active = true;
; 118  :   truncation_point_found = false;
; 119  :   this->MQ_segment = MQ_segment;

	mov	al, BYTE PTR _MQ_segment$[ebp]

; 120  :   buf_start = buffer; // First byte will always be discarded

	mov	edx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [ecx+27], 1
	mov	BYTE PTR [ecx+26], al
	mov	DWORD PTR [ecx+16], edx

; 121  :   checked_out = false;

	mov	BYTE PTR [ecx+25], 0

; 122  :   if (MQ_segment)
; 123  :     {
; 124  :       A = MQE_A_MIN;  C = 0; t=12; temp=0;

	mov	DWORD PTR [ecx+12], 0
	test	al, al
	je	SHORT $LN2@start

; 125  :       buf_next = buf_start - 1;

	lea	eax, DWORD PTR [edx-1]
	mov	DWORD PTR [ecx], 32768			; 00008000H
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 12			; 0000000cH
	mov	DWORD PTR [ecx+20], eax

; 126  :       overwritten_byte = *buf_next;

	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+24], al

; 132  :     }
; 133  : }

	pop	ebp
	ret	8
$LN2@start:

; 127  :     }
; 128  :   else
; 129  :     {
; 130  :       buf_next = buf_start;

	mov	DWORD PTR [ecx+20], edx

; 131  :       t=8; temp = 0;

	mov	DWORD PTR [ecx+8], 8

; 132  :     }
; 133  : }

	pop	ebp
	ret	8
?start@mq_encoder@@QAEXPAE_N@Z ENDP			; mq_encoder::start
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_encoder.h
;	COMDAT ?init@mqe_state@@QAEXHH@Z
_TEXT	SEGMENT
_Sigma$ = 8						; size = 4
_s$ = 12						; size = 4
?init@mqe_state@@QAEXHH@Z PROC				; mqe_state::init, COMDAT
; _this$ = ecx

; 332  : {

	push	ebp
	mov	ebp, esp

; 333  :   assert((Sigma >= 0) && (Sigma <= 46) && (s == (s&1)));
; 334  :   mps_p_bar = mq_encoder::p_bar_table[Sigma] + (s<<31);

	mov	edx, DWORD PTR _Sigma$[ebp]
	push	esi
	mov	esi, DWORD PTR _s$[ebp]
	imul	eax, esi, -2147483648
	add	eax, DWORD PTR ?p_bar_table@mq_encoder@@2PAHA[edx*4]
	mov	DWORD PTR [ecx], eax

; 335  :   transition = mq_encoder::transition_table + ((Sigma<<1) + s);

	lea	eax, DWORD PTR [esi+edx*2]
	shl	eax, 4
	add	eax, OFFSET ?transition_table@mq_encoder@@2PAUmqe_transition@@A ; mq_encoder::transition_table
	mov	DWORD PTR [ecx+4], eax
	pop	esi

; 336  : }

	pop	ebp
	ret	8
?init@mqe_state@@QAEXHH@Z ENDP				; mqe_state::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
END
