; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\coding\encoder.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??1kdu_worker@@UAE@XZ				; kdu_worker::~kdu_worker
PUBLIC	??_Gkdu_worker@@UAEPAXI@Z			; kdu_worker::`scalar deleting destructor'
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	??1kdu_push_ifc_base@@MAE@XZ			; kdu_push_ifc_base::~kdu_push_ifc_base
PUBLIC	??_Gkdu_push_ifc_base@@MAEPAXI@Z		; kdu_push_ifc_base::`scalar deleting destructor'
PUBLIC	??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_encoder::kdu_encoder
PUBLIC	??0kd_encoder@@QAE@XZ				; kd_encoder::kd_encoder
PUBLIC	?init@kd_encoder@@QAEXVkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kd_encoder::init
PUBLIC	??1kd_encoder@@MAE@XZ				; kd_encoder::~kd_encoder
PUBLIC	?push@kd_encoder@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z ; kd_encoder::push
PUBLIC	?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z ; kd_encoder::do_job
PUBLIC	??_Gkd_encoder@@MAEPAXI@Z			; kd_encoder::`scalar deleting destructor'
PUBLIC	??_Ekd_encoder@@O3AEPAXI@Z			; [thunk]:kd_encoder::`vector deleting destructor'
PUBLIC	??_7kdu_worker@@6B@				; kdu_worker::`vftable'
PUBLIC	__TI1H
PUBLIC	__CTA1H
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
PUBLIC	__CT??_R0H@84
PUBLIC	??_7kdu_push_ifc_base@@6B@			; kdu_push_ifc_base::`vftable'
PUBLIC	??_7kd_encoder@@6Bkdu_push_ifc_base@@@		; kd_encoder::`vftable'
PUBLIC	??_7kd_encoder@@6Bkdu_worker@@@			; kd_encoder::`vftable'
PUBLIC	??_C@_0O@NOGJKGJJ@block?5encoder?$AA@		; `string'
PUBLIC	??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@	; `string'
PUBLIC	??_C@_0FB@NPBPJCHA@Insufficient?5implementation?5prec@ ; `string'
PUBLIC	??_C@_0BBG@CKMLINCB@You?5have?5selected?5too?5small?5a?5va@ ; `string'
PUBLIC	??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@ ; `string'
PUBLIC	??_C@_0BOA@JLICEEPH@The?5ROI?5shift?5?$CI?$GARshift?8?5attribut@ ; `string'
PUBLIC	??_R4kdu_worker@@6B@				; kdu_worker::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_worker@@@8				; kdu_worker `RTTI Type Descriptor'
PUBLIC	??_R3kdu_worker@@8				; kdu_worker::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_worker@@8				; kdu_worker::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_worker@@8			; kdu_worker::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kdu_push_ifc_base@@6B@			; kdu_push_ifc_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_push_ifc_base@@@8			; kdu_push_ifc_base `RTTI Type Descriptor'
PUBLIC	??_R3kdu_push_ifc_base@@8			; kdu_push_ifc_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_push_ifc_base@@8			; kdu_push_ifc_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_push_ifc_base@@8		; kdu_push_ifc_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_encoder@@6Bkdu_push_ifc_base@@@		; kd_encoder::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_encoder@@@8				; kd_encoder `RTTI Type Descriptor'
PUBLIC	??_R3kd_encoder@@8				; kd_encoder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_encoder@@8				; kd_encoder::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_encoder@@8			; kd_encoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@kdu_worker@@8			; kdu_worker::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R4kd_encoder@@6Bkdu_worker@@@		; kd_encoder::`RTTI Complete Object Locator'
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@46000000
PUBLIC	__xmm@3fd3a786c226809d3fd6d5cfaacd9e84
PUBLIC	__xmm@3fd56d5cfaacd9e83fe2fcb2d905c033
PUBLIC	__xmm@3fd7f62b6ae7d5673fec6a5d6bebe165
PUBLIC	__xmm@3fde92a3055326183fe57af42784a948
PUBLIC	__xmm@3fe064c2f837b4a23fd8226809d49518
PUBLIC	__xmm@3fe1e90ff972474540af901b0fcf80dc
PUBLIC	__xmm@3fe44679cc74b83940c0ad326e43aa7a
PUBLIC	__xmm@3fe53eab367a0f913fdba5e353f7ced9
PUBLIC	__xmm@3fe7b8bac710cb293fe999999999999a
PUBLIC	__xmm@3fedf8a0902de00d3fe1c36113404ea5
PUBLIC	__xmm@3ff00000000000003ff0000000000000
PUBLIC	__xmm@3ff0bb2fec56d5d03fe9916872b020c5
PUBLIC	__xmm@3ff3f27bb2fec56d3fe6226809d49518
PUBLIC	__xmm@40032ee631f8a0903ff42a305532617c
PUBLIC	__xmm@401199b3d07c84b6400283126e978d50
PUBLIC	__xmm@40c3c42c27418d6940b2b7221db877ab
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	??_Ekdu_worker@@UAEPAXI@Z:PROC			; kdu_worker::`vector deleting destructor'
EXTRN	?get_num_threads@kdu_thread_entity@@QAEHXZ:PROC	; kdu_thread_entity::get_num_threads
EXTRN	?add_queue@kdu_thread_entity@@QAEPAUkdu_thread_queue@@PAVkdu_worker@@PAU2@PBD_J@Z:PROC ; kdu_thread_entity::add_queue
EXTRN	?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z:PROC ; kdu_thread_entity::add_jobs
EXTRN	?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z:PROC ; kdu_thread_entity::process_jobs
EXTRN	??0kdu_error@@QAE@PBD@Z:PROC			; kdu_error::kdu_error
EXTRN	??1kdu_error@@UAE@XZ:PROC			; kdu_error::~kdu_error
EXTRN	??0kdu_warning@@QAE@PBD@Z:PROC			; kdu_warning::kdu_warning
EXTRN	??1kdu_warning@@UAE@XZ:PROC			; kdu_warning::~kdu_warning
EXTRN	?get_dwt_level@kdu_resolution@@QAEHXZ:PROC	; kdu_resolution::get_dwt_level
EXTRN	?get_comp_idx@kdu_resolution@@QAEHXZ:PROC	; kdu_resolution::get_comp_idx
EXTRN	?get_band_idx@kdu_subband@@QAEHXZ:PROC		; kdu_subband::get_band_idx
EXTRN	?access_resolution@kdu_subband@@QAE?AVkdu_resolution@@XZ:PROC ; kdu_subband::access_resolution
EXTRN	?get_K_max@kdu_subband@@QAEHXZ:PROC		; kdu_subband::get_K_max
EXTRN	?get_K_max_prime@kdu_subband@@QAEHXZ:PROC	; kdu_subband::get_K_max_prime
EXTRN	?get_reversible@kdu_subband@@QAE_NXZ:PROC	; kdu_subband::get_reversible
EXTRN	?get_delta@kdu_subband@@QAEMXZ:PROC		; kdu_subband::get_delta
EXTRN	?get_msb_wmse@kdu_subband@@QAEMXZ:PROC		; kdu_subband::get_msb_wmse
EXTRN	?get_roi_weight@kdu_subband@@QAE_NAAM@Z:PROC	; kdu_subband::get_roi_weight
EXTRN	?get_dims@kdu_subband@@QAEXAAUkdu_dims@@@Z:PROC	; kdu_subband::get_dims
EXTRN	?get_valid_blocks@kdu_subband@@QAEXAAUkdu_dims@@@Z:PROC ; kdu_subband::get_valid_blocks
EXTRN	?get_block_size@kdu_subband@@QAEXAAUkdu_coords@@0@Z:PROC ; kdu_subband::get_block_size
EXTRN	?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z:PROC ; kdu_subband::open_block
EXTRN	?close_block@kdu_subband@@QAEXPAUkdu_block@@PAVkdu_thread_env@@@Z:PROC ; kdu_subband::close_block
EXTRN	?get_conservative_slope_threshold@kdu_subband@@QAEGXZ:PROC ; kdu_subband::get_conservative_slope_threshold
EXTRN	?set_max_samples@kdu_block@@QAEXH@Z:PROC	; kdu_block::set_max_samples
EXTRN	??_Ekdu_push_ifc_base@@MAEPAXI@Z:PROC		; kdu_push_ifc_base::`vector deleting destructor'
EXTRN	??0kdu_block_encoder@@QAE@XZ:PROC		; kdu_block_encoder::kdu_block_encoder
EXTRN	??_Ekd_encoder@@MAEPAXI@Z:PROC			; kd_encoder::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	_memcpy:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@40c3c42c27418d6940b2b7221db877ab
CONST	SEGMENT
__xmm@40c3c42c27418d6940b2b7221db877ab DB 0abH, 'w', 0b8H, 01dH, '"', 0b7H
	DB	0b2H, '@i', 08dH, 'A'',', 0c4H, 0c3H, '@'
CONST	ENDS
;	COMDAT __xmm@401199b3d07c84b6400283126e978d50
CONST	SEGMENT
__xmm@401199b3d07c84b6400283126e978d50 DB 'P', 08dH, 097H, 'n', 012H, 083H
	DB	02H, '@', 0b6H, 084H, '|', 0d0H, 0b3H, 099H, 011H, '@'
CONST	ENDS
;	COMDAT __xmm@40032ee631f8a0903ff42a305532617c
CONST	SEGMENT
__xmm@40032ee631f8a0903ff42a305532617c DB '|a2U0*', 0f4H, '?', 090H, 0a0H
	DB	0f8H, '1', 0e6H, '.', 03H, '@'
CONST	ENDS
;	COMDAT __xmm@3ff3f27bb2fec56d3fe6226809d49518
CONST	SEGMENT
__xmm@3ff3f27bb2fec56d3fe6226809d49518 DB 018H, 095H, 0d4H, 09H, 'h"', 0e6H
	DB	'?m', 0c5H, 0feH, 0b2H, '{', 0f2H, 0f3H, '?'
CONST	ENDS
;	COMDAT __xmm@3ff0bb2fec56d5d03fe9916872b020c5
CONST	SEGMENT
__xmm@3ff0bb2fec56d5d03fe9916872b020c5 DB 0c5H, ' ', 0b0H, 'rh', 091H, 0e9H
	DB	'?', 0d0H, 0d5H, 'V', 0ecH, '/', 0bbH, 0f0H, '?'
CONST	ENDS
;	COMDAT __xmm@3ff00000000000003ff0000000000000
CONST	SEGMENT
__xmm@3ff00000000000003ff0000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 0f0H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, '?'
CONST	ENDS
;	COMDAT __xmm@3fedf8a0902de00d3fe1c36113404ea5
CONST	SEGMENT
__xmm@3fedf8a0902de00d3fe1c36113404ea5 DB 0a5H, 'N@', 013H, 'a', 0c3H, 0e1H
	DB	'?', 0dH, 0e0H, '-', 090H, 0a0H, 0f8H, 0edH, '?'
CONST	ENDS
;	COMDAT __xmm@3fe7b8bac710cb293fe999999999999a
CONST	SEGMENT
__xmm@3fe7b8bac710cb293fe999999999999a DB 09aH, 099H, 099H, 099H, 099H, 099H
	DB	0e9H, '?)', 0cbH, 010H, 0c7H, 0baH, 0b8H, 0e7H, '?'
CONST	ENDS
;	COMDAT __xmm@3fe53eab367a0f913fdba5e353f7ced9
CONST	SEGMENT
__xmm@3fe53eab367a0f913fdba5e353f7ced9 DB 0d9H, 0ceH, 0f7H, 'S', 0e3H, 0a5H
	DB	0dbH, '?', 091H, 0fH, 'z6', 0abH, '>', 0e5H, '?'
CONST	ENDS
;	COMDAT __xmm@3fe44679cc74b83940c0ad326e43aa7a
CONST	SEGMENT
__xmm@3fe44679cc74b83940c0ad326e43aa7a DB 'z', 0aaH, 'Cn2', 0adH, 0c0H, '@'
	DB	'9', 0b8H, 't', 0ccH, 'yF', 0e4H, '?'
CONST	ENDS
;	COMDAT __xmm@3fe1e90ff972474540af901b0fcf80dc
CONST	SEGMENT
__xmm@3fe1e90ff972474540af901b0fcf80dc DB 0dcH, 080H, 0cfH, 0fH, 01bH, 090H
	DB	0afH, '@EGr', 0f9H, 0fH, 0e9H, 0e1H, '?'
CONST	ENDS
;	COMDAT __xmm@3fe064c2f837b4a23fd8226809d49518
CONST	SEGMENT
__xmm@3fe064c2f837b4a23fd8226809d49518 DB 018H, 095H, 0d4H, 09H, 'h"', 0d8H
	DB	'?', 0a2H, 0b4H, '7', 0f8H, 0c2H, 'd', 0e0H, '?'
CONST	ENDS
;	COMDAT __xmm@3fde92a3055326183fe57af42784a948
CONST	SEGMENT
__xmm@3fde92a3055326183fe57af42784a948 DB 'H', 0a9H, 084H, '''', 0f4H, 'z'
	DB	0e5H, '?', 018H, '&S', 05H, 0a3H, 092H, 0deH, '?'
CONST	ENDS
;	COMDAT __xmm@3fd7f62b6ae7d5673fec6a5d6bebe165
CONST	SEGMENT
__xmm@3fd7f62b6ae7d5673fec6a5d6bebe165 DB 'e', 0e1H, 0ebH, 'k]j', 0ecH, '?'
	DB	'g', 0d5H, 0e7H, 'j+', 0f6H, 0d7H, '?'
CONST	ENDS
;	COMDAT __xmm@3fd56d5cfaacd9e83fe2fcb2d905c033
CONST	SEGMENT
__xmm@3fd56d5cfaacd9e83fe2fcb2d905c033 DB '3', 0c0H, 05H, 0d9H, 0b2H, 0fcH
	DB	0e2H, '?', 0e8H, 0d9H, 0acH, 0faH, '\m', 0d5H, '?'
CONST	ENDS
;	COMDAT __xmm@3fd3a786c226809d3fd6d5cfaacd9e84
CONST	SEGMENT
__xmm@3fd3a786c226809d3fd6d5cfaacd9e84 DB 084H, 09eH, 0cdH, 0aaH, 0cfH, 0d5H
	DB	0d6H, '?', 09dH, 080H, '&', 0c2H, 086H, 0a7H, 0d3H, '?'
CONST	ENDS
;	COMDAT __real@46000000
CONST	SEGMENT
__real@46000000 DD 046000000r			; 8192
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_R4kd_encoder@@6Bkdu_worker@@@
rdata$r	SEGMENT
??_R4kd_encoder@@6Bkdu_worker@@@ DD 00H			; kd_encoder::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVkd_encoder@@@8
	DD	FLAT:??_R3kd_encoder@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@kdu_worker@@8
rdata$r	SEGMENT
??_R13?0A@EA@kdu_worker@@8 DD FLAT:??_R0?AVkdu_worker@@@8 ; kdu_worker::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_encoder@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_encoder@@8 DD FLAT:??_R0?AVkd_encoder@@@8 ; kd_encoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_encoder@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_encoder@@8
rdata$r	SEGMENT
??_R2kd_encoder@@8 DD FLAT:??_R1A@?0A@EA@kd_encoder@@8	; kd_encoder::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_push_ifc_base@@8
	DD	FLAT:??_R13?0A@EA@kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_encoder@@8
rdata$r	SEGMENT
??_R3kd_encoder@@8 DD 00H				; kd_encoder::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2kd_encoder@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_encoder@@@8
data$r	SEGMENT
??_R0?AVkd_encoder@@@8 DD FLAT:??_7type_info@@6B@	; kd_encoder `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_encoder@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_encoder@@6Bkdu_push_ifc_base@@@
rdata$r	SEGMENT
??_R4kd_encoder@@6Bkdu_push_ifc_base@@@ DD 00H		; kd_encoder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_encoder@@@8
	DD	FLAT:??_R3kd_encoder@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_push_ifc_base@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_push_ifc_base@@8 DD FLAT:??_R0?AVkdu_push_ifc_base@@@8 ; kdu_push_ifc_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_push_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_push_ifc_base@@8
rdata$r	SEGMENT
??_R2kdu_push_ifc_base@@8 DD FLAT:??_R1A@?0A@EA@kdu_push_ifc_base@@8 ; kdu_push_ifc_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_push_ifc_base@@8
rdata$r	SEGMENT
??_R3kdu_push_ifc_base@@8 DD 00H			; kdu_push_ifc_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_push_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_push_ifc_base@@@8
data$r	SEGMENT
??_R0?AVkdu_push_ifc_base@@@8 DD FLAT:??_7type_info@@6B@ ; kdu_push_ifc_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_push_ifc_base@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_push_ifc_base@@6B@
rdata$r	SEGMENT
??_R4kdu_push_ifc_base@@6B@ DD 00H			; kdu_push_ifc_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_push_ifc_base@@@8
	DD	FLAT:??_R3kdu_push_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_worker@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_worker@@8 DD FLAT:??_R0?AVkdu_worker@@@8 ; kdu_worker::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_worker@@8
rdata$r	SEGMENT
??_R2kdu_worker@@8 DD FLAT:??_R1A@?0A@EA@kdu_worker@@8	; kdu_worker::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_worker@@8
rdata$r	SEGMENT
??_R3kdu_worker@@8 DD 00H				; kdu_worker::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_worker@@@8
data$r	SEGMENT
??_R0?AVkdu_worker@@@8 DD FLAT:??_7type_info@@6B@	; kdu_worker `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_worker@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_worker@@6B@
rdata$r	SEGMENT
??_R4kdu_worker@@6B@ DD 00H				; kdu_worker::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_worker@@@8
	DD	FLAT:??_R3kdu_worker@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BOA@JLICEEPH@The?5ROI?5shift?5?$CI?$GARshift?8?5attribut@
CONST	SEGMENT
??_C@_0BOA@JLICEEPH@The?5ROI?5shift?5?$CI?$GARshift?8?5attribut@ DB 'The '
	DB	'ROI shift (`Rshift'' attribute) which you are using is too la'
	DB	'rge to ensure truly lossless recovery of both the foreground '
	DB	'and the background regions, at least by Kakadu -- other compl'
	DB	'iant implementations may give up much earlier.  You might lik'
	DB	'e to consider using the `Rweight'' attribute instead of `Rshi'
	DB	'ft'' -- a 32x32 code-block size (not the default) is recommen'
	DB	'ded in this case and `Rweight'' should be set to around 2 to '
	DB	'the power of the `Rshift'' value you would have used.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
CONST	SEGMENT
??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@ DB 'Kakadu Core Warning'
	DB	':', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBG@CKMLINCB@You?5have?5selected?5too?5small?5a?5va@
CONST	SEGMENT
??_C@_0BBG@CKMLINCB@You?5have?5selected?5too?5small?5a?5va@ DB 'You have '
	DB	'selected too small a value for the ROI up-shift parameter.  T'
	DB	'he up-shift should be at least as large as the largest number'
	DB	' of magnitude bit-planes in any subband; otherwise, the foreg'
	DB	'round and background regions might not be properly distinguis'
	DB	'hed by the decompressor.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@NPBPJCHA@Insufficient?5implementation?5prec@
CONST	SEGMENT
??_C@_0FB@NPBPJCHA@Insufficient?5implementation?5prec@ DB 'Insufficient i'
	DB	'mplementation precision available for true reversible compres'
	DB	'sion!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
CONST	SEGMENT
??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@ DB 'Kakadu Core Error:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NOGJKGJJ@block?5encoder?$AA@
CONST	SEGMENT
??_C@_0O@NOGJKGJJ@block?5encoder?$AA@ DB 'block encoder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7kd_encoder@@6Bkdu_worker@@@
CONST	SEGMENT
??_7kd_encoder@@6Bkdu_worker@@@ DD FLAT:??_R4kd_encoder@@6Bkdu_worker@@@ ; kd_encoder::`vftable'
	DD	FLAT:??_Ekd_encoder@@O3AEPAXI@Z
	DD	FLAT:?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z
CONST	ENDS
;	COMDAT ??_7kd_encoder@@6Bkdu_push_ifc_base@@@
CONST	SEGMENT
??_7kd_encoder@@6Bkdu_push_ifc_base@@@ DD FLAT:??_R4kd_encoder@@6Bkdu_push_ifc_base@@@ ; kd_encoder::`vftable'
	DD	FLAT:??_Ekd_encoder@@MAEPAXI@Z
	DD	FLAT:?push@kd_encoder@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z
CONST	ENDS
;	COMDAT ??_7kdu_push_ifc_base@@6B@
CONST	SEGMENT
??_7kdu_push_ifc_base@@6B@ DD FLAT:??_R4kdu_push_ifc_base@@6B@ ; kdu_push_ifc_base::`vftable'
	DD	FLAT:??_Ekdu_push_ifc_base@@MAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0H@8
data$r	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
data$r	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
;	COMDAT ??_7kdu_worker@@6B@
CONST	SEGMENT
??_7kdu_worker@@6B@ DD FLAT:??_R4kdu_worker@@6B@	; kdu_worker::`vftable'
	DD	FLAT:??_Ekdu_worker@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z$2
__ehfuncinfo$?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kd_encoder@@MAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0kd_encoder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0kd_encoder@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0kd_encoder@@QAE@XZ$1
__ehfuncinfo$??0kd_encoder@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0kd_encoder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z$0
__ehfuncinfo$??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_Ekd_encoder@@O3AEPAXI@Z
_TEXT	SEGMENT
??_Ekd_encoder@@O3AEPAXI@Z PROC				; [thunk]:kd_encoder::`vector deleting destructor', COMDAT
	sub	ecx, 4
	jmp	??_Ekd_encoder@@MAEPAXI@Z
??_Ekd_encoder@@O3AEPAXI@Z ENDP				; [thunk]:kd_encoder::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_encoder@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_encoder@@MAEPAXI@Z PROC				; kd_encoder::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_encoder@@MAE@XZ			; kd_encoder::~kd_encoder
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	104					; 00000068H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_encoder@@MAEPAXI@Z ENDP				; kd_encoder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
;	COMDAT ?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z
_TEXT	SEGMENT
_w$2 = -976						; size = 20
$T3 = -956						; size = 4
$T4 = -952						; size = 4
_e$5 = -948						; size = 20
_e$6 = -948						; size = 20
_estimated_slope_threshold$1$ = -928			; size = 4
_ent$GSCopy$1$ = -924					; size = 4
_idx$1$ = -920						; size = 4
_m_start$1$ = -916					; size = 4
_buf32$1$ = -912					; size = 4
_buf16$1$ = -908					; size = 4
tv2734 = -904						; size = 4
_idx$2$ = -900						; size = 4
_offset$1$ = -896					; size = 4
_n$12$ = -892						; size = 4
_n$11$ = -892						; size = 4
tv2691 = -892						; size = 4
_roi$1$ = -888						; size = 4
_blocks_remaining$1$ = -884				; size = 4
_n_start$1$ = -880					; size = 4
_n_inc$1$ = -876					; size = 4
_m_inc$1$ = -872					; size = 4
_row_gap$1$ = -868					; size = 4
_this$GSCopy$1$ = -864					; size = 4
_m$8$ = -860						; size = 4
_m$4$ = -860						; size = 4
_m$1$ = -860						; size = 4
tv2724 = -860						; size = 4
tv2723 = -860						; size = 4
tv2694 = -860						; size = 4
tv2693 = -860						; size = 4
tv2692 = -860						; size = 4
_downshift$1$ = -856					; size = 4
_scale$1$ = -856					; size = 4
_upshift$1$ = -856					; size = 4
_upshift$1$ = -856					; size = 4
tv2722 = -856						; size = 4
_m$7$ = -852						; size = 4
_m$6$ = -852						; size = 4
_m$5$ = -852						; size = 4
_m$3$ = -852						; size = 4
_m$2$ = -852						; size = 4
tv2725 = -852						; size = 4
tv2703 = -852						; size = 4
tv2699 = -852						; size = 4
tv2695 = -852						; size = 4
_have_foreground$1$ = -845				; size = 1
_or_val$1$ = -844					; size = 4
_scale_wmse$1$ = -838					; size = 1
_have_background$1$ = -837				; size = 1
_m$13$ = -836						; size = 4
_block$1$ = -832					; size = 4
_spp$1$ = -828						; size = 4
_spp$1$ = -828						; size = 4
_dpp$3$ = -828						; size = 4
_spp$1$ = -824						; size = 4
_dpp$1$ = -824						; size = 4
_xfer_size$1$ = -820					; size = 4
_a_b_c1$ = -816						; size = 80
_b_b_c1$ = -736						; size = 80
_a_b_c2$ = -656						; size = 80
_a_b_lum$ = -576					; size = 80
_b_b_c2$ = -496						; size = 80
_b_b_lum$ = -416					; size = 80
_a_b1$ = -336						; size = 80
_b_b1$ = -256						; size = 80
_b1_c1$ = -176						; size = 80
_b1_c2$ = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_ent$ = 8						; size = 4
_job_idx$ = 12						; size = 4
?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z PROC	; kd_encoder::do_job, COMDAT
; _this$ = ecx

; 487  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 964				; 000003c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	eax, DWORD PTR _ent$[ebp]

; 488  :   kdu_thread_env *env = (kdu_thread_env *) ent;
; 489  :   int jobs_per_row = num_jobs_per_row;
; 490  :   int blocks_remaining = block_indices.size.x;
; 491  :   int offset = 0; // Horizontal offset into line buffers
; 492  :   kdu_coords idx = block_indices.pos; // Index of first block to process
; 493  :   kdu_sample32 **buf32 = lines32; // First buffer line to process (32-bit)
; 494  :   kdu_sample16 **buf16 = lines16; // First buffer line to process (16-bit)
; 495  :   kdu_byte **roi = roi_lines; // First ROI line to process
; 496  : 
; 497  :   
; 498  : 
; 499  :   // Start by using `job_idx' to find where we are
; 500  :   int encoder_block_row = job_idx / jobs_per_row;

	mov	edi, DWORD PTR _job_idx$[ebp]
	movzx	esi, BYTE PTR [ecx+19]
	mov	DWORD PTR _ent$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR _blocks_remaining$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR _idx$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _idx$2$[ebp], eax
	mov	eax, DWORD PTR [ecx+88]
	mov	DWORD PTR _buf32$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+84]
	mov	DWORD PTR _buf16$1$[ebp], eax
	mov	eax, DWORD PTR [ecx+92]
	mov	DWORD PTR _roi$1$[ebp], eax
	mov	eax, edi
	cdq
	idiv	esi
	mov	DWORD PTR _offset$1$[ebp], 0
	mov	edx, eax

; 501  :   if ((encoder_block_row & 1) && (buffer_height > nominal_block_height))

	test	dl, 1
	je	SHORT $LN95@do_job
	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	movzx	ecx, WORD PTR [ecx+62]
	cmp	WORD PTR [eax+64], cx
	jle	SHORT $LN95@do_job

; 502  :     { // Select memory bank 1
; 503  :       if (buf32 != NULL) buf32 += nominal_block_height;

	cmp	DWORD PTR _buf32$1$[ebp], 0
	je	SHORT $LN93@do_job
	mov	edi, DWORD PTR _buf32$1$[ebp]
	movsx	eax, cx
	lea	edi, DWORD PTR [edi+eax*4]
	mov	DWORD PTR _buf32$1$[ebp], edi
	mov	edi, DWORD PTR _job_idx$[ebp]
$LN93@do_job:

; 504  :       if (buf16 != NULL) buf16 += nominal_block_height;

	cmp	DWORD PTR _buf16$1$[ebp], 0
	je	SHORT $LN94@do_job
	mov	edi, DWORD PTR _buf16$1$[ebp]
	movsx	eax, cx
	lea	edi, DWORD PTR [edi+eax*4]
	mov	DWORD PTR _buf16$1$[ebp], edi
	mov	edi, DWORD PTR _job_idx$[ebp]
$LN94@do_job:

; 505  :       if (roi != NULL) roi += nominal_block_height;

	cmp	DWORD PTR _roi$1$[ebp], 0
	je	SHORT $LN95@do_job
	movsx	eax, cx
	mov	ecx, DWORD PTR _roi$1$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _roi$1$[ebp], ecx
$LN95@do_job:

; 506  :     }
; 507  :   idx.y += encoder_block_row;

	add	DWORD PTR _idx$1$[ebp], edx

; 508  :   assert(idx.y < (block_indices.pos.y + block_indices.size.y));
; 509  :   if (jobs_per_row > 1)

	cmp	esi, 1
	jle	SHORT $LN355@do_job

; 510  :     {
; 511  :       int job_idx_in_row = job_idx - (encoder_block_row*jobs_per_row);

	imul	edx, esi
	sub	edi, edx

; 512  :       int skip_blocks = (blocks_remaining*job_idx_in_row) / jobs_per_row;

	mov	eax, edi
	imul	eax, DWORD PTR _blocks_remaining$1$[ebp]
	cdq
	idiv	esi
	mov	ecx, eax

; 513  :       blocks_remaining =

	lea	eax, DWORD PTR [edi+1]
	imul	eax, DWORD PTR _blocks_remaining$1$[ebp]
	cdq
	idiv	esi
	mov	esi, eax
	sub	esi, ecx
	mov	DWORD PTR _blocks_remaining$1$[ebp], esi

; 514  :         ((blocks_remaining*(job_idx_in_row+1))/jobs_per_row)-skip_blocks;
; 515  :       assert(blocks_remaining > 0);
; 516  :       if (skip_blocks > 0)

	test	ecx, ecx
	jle	SHORT $LN97@do_job

; 517  :         {
; 518  :           idx.x += skip_blocks;
; 519  :           offset += first_block_width +

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	add	DWORD PTR _idx$2$[ebp], ecx
	dec	ecx
	movsx	edx, WORD PTR [eax+60]
	movsx	eax, WORD PTR [eax+58]
	imul	edx, ecx
	add	edx, eax
	mov	DWORD PTR _offset$1$[ebp], edx
	jmp	SHORT $LN97@do_job
$LN355@do_job:
	mov	esi, DWORD PTR _blocks_remaining$1$[ebp]
$LN97@do_job:

; 520  :             (skip_blocks-1) * (int) nominal_block_width;
; 521  :         }
; 522  :     }
; 523  : 
; 524  :   // Now scan through the blocks to process
; 525  :   kdu_coords xfer_size;
; 526  :   kdu_block *block;
; 527  :   kdu_uint16 estimated_slope_threshold =
; 528  :     band.get_conservative_slope_threshold();

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	add	edi, 8
	mov	ecx, edi
	mov	DWORD PTR tv2734[ebp], edi
	call	?get_conservative_slope_threshold@kdu_subband@@QAEGXZ ; kdu_subband::get_conservative_slope_threshold
	xorps	xmm0, xmm0
	movzx	eax, ax
	movups	XMMWORD PTR _a_b1$[ebp], xmm0
	mov	DWORD PTR _estimated_slope_threshold$1$[ebp], eax

; 529  : 
; 530  : 
; 531  :   // change az_liuf
; 532  : 
; 533  :   double a_b1[5][2]={{0.0,0.0},{0.0,0.0},{0.0,0.0},{0.0,0.0},{0.0,0.0}};
; 534  :   double b_b1[5][2]={{0.887984,0.3744},{0.4320,0.6639},{0.6917,1.2467},{1.2603,2.3979},{2.314,4.4001}};
; 535  : 
; 536  :   double b1_c1[5][2]={{4791.133266,10120.344948},{8538.393990,0.633603},{0.671259,0.4777},{0.80,0.7413},{0.7990,1.0457}};
; 537  :   double b1_c2[5][2]={{4040.052855,0.559700},{0.593347,0.3348},{0.356800,0.3071},{0.3771,0.5123},{0.5551,0.9366}};
; 538  : 
; 539  :   double a_b_lum[5][2];
; 540  :   double b_b_lum[5][2];
; 541  :   double a_b_c1[5][2];
; 542  :   double b_b_c1[5][2];
; 543  :   double a_b_c2[5][2];
; 544  :   double b_b_c2[5][2];
; 545  :   int xi,xj;
; 546  : 
; 547  :   for(xi=0;xi<5;xi++)
; 548  :   {
; 549  : 	  for(xj=0;xj<2;xj++)
; 550  : 	  {
; 551  : 		  a_b_lum[xi][xj]=a_b1[xi][xj];

	xor	eax, eax
	movups	XMMWORD PTR _a_b1$[ebp+16], xmm0
	movups	XMMWORD PTR _a_b1$[ebp+32], xmm0
	movups	XMMWORD PTR _a_b1$[ebp+48], xmm0
	movups	XMMWORD PTR _a_b1$[ebp+64], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3fd7f62b6ae7d5673fec6a5d6bebe165
	xorps	xmm1, xmm1
	movups	XMMWORD PTR _b_b1$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3fe53eab367a0f913fdba5e353f7ced9
	movups	XMMWORD PTR _b_b1$[ebp+16], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3ff3f27bb2fec56d3fe6226809d49518
	movups	XMMWORD PTR _b_b1$[ebp+32], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@40032ee631f8a0903ff42a305532617c
	movups	XMMWORD PTR _b_b1$[ebp+48], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@401199b3d07c84b6400283126e978d50
	movups	XMMWORD PTR _b_b1$[ebp+64], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@40c3c42c27418d6940b2b7221db877ab
	movups	XMMWORD PTR _b1_c1$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3fe44679cc74b83940c0ad326e43aa7a
	movups	XMMWORD PTR _b1_c1$[ebp+16], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3fde92a3055326183fe57af42784a948
	movups	XMMWORD PTR _b1_c1$[ebp+32], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3fe7b8bac710cb293fe999999999999a
	movups	XMMWORD PTR _b1_c1$[ebp+48], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3ff0bb2fec56d5d03fe9916872b020c5
	movups	XMMWORD PTR _b1_c1$[ebp+64], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3fe1e90ff972474540af901b0fcf80dc
	movups	XMMWORD PTR _b1_c2$[ebp], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3fd56d5cfaacd9e83fe2fcb2d905c033
	movups	XMMWORD PTR _b1_c2$[ebp+16], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3fd3a786c226809d3fd6d5cfaacd9e84
	movups	XMMWORD PTR _b1_c2$[ebp+32], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3fe064c2f837b4a23fd8226809d49518
	movups	XMMWORD PTR _b1_c2$[ebp+48], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3fedf8a0902de00d3fe1c36113404ea5
	movups	XMMWORD PTR _b1_c2$[ebp+64], xmm0
	npad	2
$LL4@do_job:
	movsd	xmm0, QWORD PTR _a_b1$[ebp+eax]
	movsd	QWORD PTR _a_b_lum$[ebp+eax], xmm0

; 552  : 		  b_b_lum[xi][xj]=b_b1[xi][xj];

	movsd	xmm0, QWORD PTR _b_b1$[ebp+eax]
	movsd	QWORD PTR _b_b_lum$[ebp+eax], xmm0

; 553  : 		  a_b_c1[xi][xj]=0.0;
; 554  : 		  b_b_c1[xi][xj]=b1_c1[xi][xj];

	movsd	xmm0, QWORD PTR _b1_c1$[ebp+eax]
	movsd	QWORD PTR _b_b_c1$[ebp+eax], xmm0

; 555  : 		  a_b_c2[xi][xj]=0.0;
; 556  : 		  b_b_c2[xi][xj]=b1_c2[xi][xj];

	movsd	xmm0, QWORD PTR _b1_c2$[ebp+eax]
	movsd	QWORD PTR _b_b_c2$[ebp+eax], xmm0
	movsd	xmm0, QWORD PTR _a_b1$[ebp+eax+8]
	movsd	QWORD PTR _a_b_lum$[ebp+eax+8], xmm0
	movsd	xmm0, QWORD PTR _b_b1$[ebp+eax+8]
	movsd	QWORD PTR _b_b_lum$[ebp+eax+8], xmm0
	movsd	xmm0, QWORD PTR _b1_c1$[ebp+eax+8]
	movsd	QWORD PTR _b_b_c1$[ebp+eax+8], xmm0
	movsd	xmm0, QWORD PTR _b1_c2$[ebp+eax+8]
	movsd	QWORD PTR _a_b_c1$[ebp+eax], xmm1
	movsd	QWORD PTR _a_b_c2$[ebp+eax], xmm1
	movsd	QWORD PTR _a_b_c1$[ebp+eax+8], xmm1
	movsd	QWORD PTR _a_b_c2$[ebp+eax+8], xmm1
	movsd	QWORD PTR _b_b_c2$[ebp+eax+8], xmm0
	add	eax, 16					; 00000010H
	cmp	eax, 80					; 00000050H
	jl	$LL4@do_job

; 557  : 	  }
; 558  :   }
; 559  : 
; 560  : 
; 561  :   for (; blocks_remaining > 0; blocks_remaining--,

	test	esi, esi
	jle	$LN9@do_job
$LL10@do_job:

; 562  :        idx.x++, offset+=xfer_size.x)
; 563  :     {
; 564  :       // Open the block and make sure we have enough sample buffer storage.
; 565  :       block = band.open_block(idx,NULL,env);

	push	DWORD PTR _ent$GSCopy$1$[ebp]
	mov	ecx, edi
	push	0
	push	DWORD PTR _idx$2$[ebp]
	push	DWORD PTR _idx$1$[ebp]
	call	?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z ; kdu_subband::open_block

; 566  : 
; 567  : 	  //ohhan
; 568  : 	  //print block information
; 569  : 	  int oh_dwt_level = band.access_resolution().get_dwt_level();

	mov	ecx, DWORD PTR tv2734[ebp]
	mov	edi, eax
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _block$1$[ebp], edi
	push	eax
	call	?access_resolution@kdu_subband@@QAE?AVkdu_resolution@@XZ ; kdu_subband::access_resolution
	mov	ecx, eax
	call	?get_dwt_level@kdu_resolution@@QAEHXZ	; kdu_resolution::get_dwt_level

; 570  : 	  int oh_comp_idx = band.access_resolution().get_comp_idx();

	mov	ecx, DWORD PTR tv2734[ebp]
	mov	esi, eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?access_resolution@kdu_subband@@QAE?AVkdu_resolution@@XZ ; kdu_subband::access_resolution
	mov	ecx, eax
	call	?get_comp_idx@kdu_resolution@@QAEHXZ	; kdu_resolution::get_comp_idx

; 571  : 	  int oh_orient = block->orientation; 

	mov	edx, DWORD PTR [edi+32]

; 572  : 	  int oh_k_max = block->K_max_prime;

	mov	ecx, DWORD PTR [edi+40]

; 573  : 	  kdu_coords oh_coords = idx;
; 574  : 	  oh_coords.y = oh_coords.y*block->size.y*(1<<oh_dwt_level);
; 575  : 	  oh_coords.x = oh_coords.x*block->size.x*(1<<oh_dwt_level);
; 576  : 	  
; 577  : 	  //printf("\n(%d) DWT level=%d, orient=%d, K_max=%d, coords(y,x)=(%d,%d), delta=%.8f",oh_comp_idx,oh_dwt_level,oh_orient,oh_k_max,oh_coords.y,oh_coords.x,band.get_delta());
; 578  : 
; 579  :       block->dwt_level = oh_dwt_level;

	mov	DWORD PTR [edi+72], esi

; 580  : 	  block->orient = oh_orient;

	mov	DWORD PTR [edi+76], edx

; 581  : 	  block->k_max = oh_k_max;

	mov	DWORD PTR [edi+80], ecx

; 582  : 	  block->comp_idx = oh_comp_idx;

	mov	DWORD PTR [edi+84], eax

; 583  : 
; 584  : 	  //ohhan - calculating threshold
; 585  : 
; 586  : 	  if (block->orient == 1 || block->orient == 2)   //HL and LH

	cmp	edx, 1
	je	SHORT $LN100@do_job
	cmp	edx, 2
	je	SHORT $LN100@do_job

; 602  : 		  }
; 603  : 	  }
; 604  : 	  else if (block->orient == 0)    //LL

	test	edx, edx
	jne	SHORT $LN105@do_job

; 605  : 	  {
; 606  : 		  block->a_b = 1.0;

	movaps	xmm0, XMMWORD PTR __xmm@3ff00000000000003ff0000000000000
	movups	XMMWORD PTR [edi+88], xmm0

; 607  : 		  block->b_b = 1.0;
; 608  : 	  }
; 609  : 	  else	//HH

	jmp	$LN104@do_job
$LN105@do_job:

; 610  : 	  {
; 611  : 		  if(block->comp_idx==0)
; 612  : 		  {
; 613  : 			  block->a_b = a_b_lum[block->dwt_level-1][0];

	add	esi, esi
	test	eax, eax
	jne	SHORT $LN107@do_job
	movsd	xmm0, QWORD PTR _a_b_lum$[ebp+esi*8-16]
	movsd	QWORD PTR [edi+88], xmm0

; 614  : 			  block->b_b = b_b_lum[block->dwt_level-1][0];

	movsd	xmm0, QWORD PTR _b_b_lum$[ebp+esi*8-16]
	jmp	$LN357@do_job
$LN107@do_job:

; 615  : 		  }
; 616  : 		  else if(block->comp_idx==1)

	cmp	eax, 1
	jne	SHORT $LN109@do_job

; 617  : 		  {
; 618  : 			  block->a_b = a_b_c1[block->dwt_level-1][0];

	movsd	xmm0, QWORD PTR _a_b_c1$[ebp+esi*8-16]
	movsd	QWORD PTR [edi+88], xmm0

; 619  : 			  block->b_b = b_b_c1[block->dwt_level-1][0];

	movsd	xmm0, QWORD PTR _b_b_c1$[ebp+esi*8-16]

; 620  : 		  }
; 621  : 		  else

	jmp	SHORT $LN357@do_job
$LN109@do_job:

; 622  : 		  {
; 623  : 			  block->a_b = a_b_c2[block->dwt_level-1][0];

	movsd	xmm0, QWORD PTR _a_b_c2$[ebp+esi*8-16]
	movsd	QWORD PTR [edi+88], xmm0

; 624  : 			  block->b_b = b_b_c2[block->dwt_level-1][0];

	movsd	xmm0, QWORD PTR _b_b_c2$[ebp+esi*8-16]
	jmp	SHORT $LN357@do_job
$LN100@do_job:

; 587  : 	  {
; 588  : 		  if(block->comp_idx==0)
; 589  : 		  {
; 590  : 			  block->a_b = a_b_lum[block->dwt_level-1][1];

	add	esi, esi
	test	eax, eax
	jne	SHORT $LN101@do_job
	movsd	xmm0, QWORD PTR _a_b_lum$[ebp+esi*8-8]
	movsd	QWORD PTR [edi+88], xmm0

; 591  : 			  block->b_b = b_b_lum[block->dwt_level-1][1];

	movsd	xmm0, QWORD PTR _b_b_lum$[ebp+esi*8-8]
	jmp	SHORT $LN357@do_job
$LN101@do_job:

; 592  : 		  }
; 593  : 		  else if(block->comp_idx==1)

	cmp	eax, 1
	jne	SHORT $LN103@do_job

; 594  : 		  {
; 595  : 			  block->a_b = a_b_c1[block->dwt_level-1][1];

	movsd	xmm0, QWORD PTR _a_b_c1$[ebp+esi*8-8]
	movsd	QWORD PTR [edi+88], xmm0

; 596  : 			  block->b_b = b_b_c1[block->dwt_level-1][1];

	movsd	xmm0, QWORD PTR _b_b_c1$[ebp+esi*8-8]

; 597  : 		  }
; 598  : 		  else

	jmp	SHORT $LN357@do_job
$LN103@do_job:

; 599  : 		  {
; 600  : 			  block->a_b = a_b_c2[block->dwt_level-1][1];

	movsd	xmm0, QWORD PTR _a_b_c2$[ebp+esi*8-8]
	movsd	QWORD PTR [edi+88], xmm0

; 601  : 			  block->b_b = b_b_c2[block->dwt_level-1][1];

	movsd	xmm0, QWORD PTR _b_b_c2$[ebp+esi*8-8]
$LN357@do_job:
	movsd	QWORD PTR [edi+96], xmm0
$LN104@do_job:

; 625  : 		  }
; 626  : 	  }
; 627  : 	  block->delta = band.get_delta();

	mov	ecx, DWORD PTR tv2734[ebp]
	call	?get_delta@kdu_subband@@QAEMXZ		; kdu_subband::get_delta

; 628  : 
; 629  : 
; 630  : 
; 631  :       int num_stripes = (block->size.y+3) >> 2;

	mov	eax, DWORD PTR [edi]
	add	eax, 3
	sar	eax, 2
	fstp	DWORD PTR [edi+104]

; 632  :       int num_samples = (num_stripes<<2) * block->size.x;

	lea	ecx, DWORD PTR [eax*4]
	imul	ecx, DWORD PTR [edi+4]

; 633  :       assert(num_samples > 0);
; 634  :       if (block->max_samples < num_samples)

	cmp	DWORD PTR [edi+116], ecx
	jge	SHORT $LN111@do_job

; 635  :         block->set_max_samples((num_samples>4096)?num_samples:4096);

	mov	eax, 4096				; 00001000H
	cmp	ecx, eax
	cmovg	eax, ecx
	mov	ecx, edi
	push	eax
	call	?set_max_samples@kdu_block@@QAEXH@Z	; kdu_block::set_max_samples
$LN111@do_job:

; 636  :       
; 637  :       /* Now quantize and transfer samples to the block, observing any
; 638  :          required geometric transformations. */
; 639  :       xfer_size = block->size;
; 640  :       assert((xfer_size.x == block->region.size.x) &&
; 641  :              (xfer_size.y == block->region.size.y) &&
; 642  :              (0 == block->region.pos.x) && (0 == block->region.pos.y));
; 643  :       if (block->transpose)

	mov	dl, BYTE PTR [edi+24]
	mov	ecx, DWORD PTR [edi]
	mov	esi, DWORD PTR [edi+4]
	mov	DWORD PTR _m$13$[ebp], ecx
	mov	DWORD PTR _xfer_size$1$[ebp], esi
	test	dl, dl
	je	SHORT $LN112@do_job
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, ecx
	mov	DWORD PTR _m$13$[ebp], esi
	mov	ecx, esi
	mov	esi, eax
	mov	DWORD PTR _xfer_size$1$[ebp], esi
$LN112@do_job:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 648  :       kdu_int32 *dp, *dpp = block->sample_buffer;

	mov	edi, DWORD PTR [edi+108]

; 649  :       kdu_int32 or_val = 0; // Logical OR of the sample values in this block
; 650  :       int row_gap = block->size.x;

	mov	eax, DWORD PTR _block$1$[ebp]
	mov	DWORD PTR _dpp$1$[ebp], edi

; 651  :       int m_start = 0, m_inc = 1, n_start=offset, n_inc = 1;

	mov	edi, DWORD PTR _offset$1$[ebp]
	mov	DWORD PTR _n_start$1$[ebp], edi

; 652  :       if (block->vflip)

	mov	edi, DWORD PTR _block$1$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _row_gap$1$[ebp], eax
	xor	eax, eax
	mov	DWORD PTR _or_val$1$[ebp], 0
	cmp	BYTE PTR [edi+25], al
	mov	edi, DWORD PTR _dpp$1$[ebp]
	mov	DWORD PTR _m_start$1$[ebp], eax
	mov	DWORD PTR _m_inc$1$[ebp], 1
	mov	DWORD PTR _n_inc$1$[ebp], 1
	je	SHORT $LN113@do_job

; 653  :         { m_start += xfer_size.y-1; m_inc = -1; }

	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR _m_inc$1$[ebp], -1
	mov	DWORD PTR _m_start$1$[ebp], eax
$LN113@do_job:

; 654  :       if (block->hflip)

	mov	ecx, DWORD PTR _block$1$[ebp]
	cmp	BYTE PTR [ecx+26], 0
	je	SHORT $LN114@do_job

; 655  :         { n_start += xfer_size.x-1; n_inc = -1; }

	mov	ecx, DWORD PTR _offset$1$[ebp]
	dec	ecx
	mov	DWORD PTR _n_inc$1$[ebp], -1
	add	ecx, esi
	mov	DWORD PTR _n_start$1$[ebp], ecx
$LN114@do_job:

; 656  : 
; 657  :       // First transfer the sample data
; 658  :       if (buf32 != NULL)

	mov	ecx, DWORD PTR _buf32$1$[ebp]
	test	ecx, ecx
	je	$LN115@do_job

; 659  :         { // Working with 32-bit data types.
; 660  :           kdu_sample32 *sp, **spp = buf32+m_start;

	lea	esi, DWORD PTR [ecx+eax*4]

; 661  :           if (reversible)

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR _spp$1$[ebp], esi
	cmp	BYTE PTR [eax+16], 0
	je	$LN117@do_job

; 662  :             { // Source data is 32-bit absolute integers.
; 663  :               kdu_int32 val;
; 664  :               kdu_int32 upshift = 31-K_max;

	movsx	eax, WORD PTR [eax+12]
	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	mov	DWORD PTR _upshift$1$[ebp], ecx

; 665  :               if (upshift < 0)

	jns	SHORT $LN119@do_job

; 666  :                 { KDU_ERROR(e,1); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$6[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	OFFSET ??_C@_0FB@NPBPJCHA@Insufficient?5implementation?5prec@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 666  :                 { KDU_ERROR(e,1); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 669  :                 }

	lea	ecx, DWORD PTR _e$6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _upshift$1$[ebp]
$LN119@do_job:

; 670  :               if (!block->transpose)

	mov	edi, DWORD PTR _block$1$[ebp]

; 671  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp+=row_gap)

	mov	edx, DWORD PTR _m$13$[ebp]
	mov	eax, edx
	cmp	BYTE PTR [edi+24], 0
	jne	$LN120@do_job
	test	edx, edx
	je	$LN253@do_job
	mov	edx, DWORD PTR _n_start$1$[ebp]
	lea	edi, DWORD PTR [edx*4]
	mov	DWORD PTR tv2725[ebp], edi
$LL13@do_job:

; 672  :                   for (sp=(*spp)+n_start, dp=dpp,

	mov	esi, DWORD PTR [esi]
	dec	eax
	mov	edx, DWORD PTR _dpp$1$[ebp]
	add	esi, edi
	mov	edi, DWORD PTR _xfer_size$1$[ebp]
	mov	DWORD PTR _m$1$[ebp], eax

; 673  :                        n=xfer_size.x; n--; dp++, sp+=n_inc)

	test	edi, edi
	je	SHORT $LN223@do_job
	npad	5
$LL16@do_job:

; 674  :                     {
; 675  :                       val = sp->ival;

	mov	eax, DWORD PTR [esi]
	dec	edi

; 676  :                       if (val < 0)

	test	eax, eax
	jns	SHORT $LN122@do_job

; 677  :                         *dp = ((-val)<<upshift) | KDU_INT32_MIN;

	neg	eax
	shl	eax, cl
	or	eax, -2147483648			; 80000000H

; 678  :                       else

	jmp	SHORT $LN358@do_job
$LN122@do_job:

; 679  :                         *dp = val<<upshift;

	shl	eax, cl
$LN358@do_job:

; 673  :                        n=xfer_size.x; n--; dp++, sp+=n_inc)

	mov	ecx, DWORD PTR _n_inc$1$[ebp]

; 679  :                         *dp = val<<upshift;

	mov	DWORD PTR [edx], eax

; 680  :                       or_val |= *dp;

	mov	eax, DWORD PTR _or_val$1$[ebp]
	or	eax, DWORD PTR [edx]
	add	edx, 4
	mov	DWORD PTR _or_val$1$[ebp], eax
	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR _upshift$1$[ebp]
	add	esi, eax
	test	edi, edi
	jne	SHORT $LL16@do_job
	mov	eax, DWORD PTR _m$1$[ebp]
$LN223@do_job:

; 671  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp+=row_gap)

	mov	edi, DWORD PTR _m_inc$1$[ebp]
	mov	esi, DWORD PTR _spp$1$[ebp]
	lea	edx, DWORD PTR [edi*4]
	mov	edi, DWORD PTR _row_gap$1$[ebp]
	add	esi, edx
	mov	DWORD PTR _spp$1$[ebp], esi
	lea	edx, DWORD PTR [edi*4]
	mov	edi, DWORD PTR tv2725[ebp]
	add	DWORD PTR _dpp$1$[ebp], edx
	test	eax, eax
	jne	$LL13@do_job

; 681  :                     }
; 682  :               else

	jmp	$LN349@do_job
$LN120@do_job:

; 683  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp++)

	test	edx, edx
	je	$LN253@do_job
	mov	edx, DWORD PTR _n_start$1$[ebp]
	lea	edi, DWORD PTR [edx*4]
	mov	edx, DWORD PTR _dpp$1$[ebp]
	mov	DWORD PTR tv2724[ebp], edi
$LL19@do_job:

; 684  :                   for (sp=(*spp)+n_start, dp=dpp,

	mov	esi, DWORD PTR [esi]
	dec	eax
	add	esi, edi
	mov	DWORD PTR _m$2$[ebp], eax
	mov	edi, DWORD PTR _xfer_size$1$[ebp]

; 685  :                        n=xfer_size.x; n--; dp+=row_gap, sp+=n_inc)

	test	edi, edi
	je	SHORT $LN227@do_job
	npad	3
$LL22@do_job:

; 686  :                     {
; 687  :                       val = sp->ival;

	mov	eax, DWORD PTR [esi]
	dec	edi

; 688  :                       if (val < 0)

	test	eax, eax
	jns	SHORT $LN124@do_job

; 689  :                         *dp = ((-val)<<upshift) | KDU_INT32_MIN;

	neg	eax
	shl	eax, cl
	or	eax, -2147483648			; 80000000H

; 690  :                       else

	jmp	SHORT $LN359@do_job
$LN124@do_job:

; 691  :                         *dp = val<<upshift;

	shl	eax, cl
$LN359@do_job:

; 685  :                        n=xfer_size.x; n--; dp+=row_gap, sp+=n_inc)

	mov	ecx, DWORD PTR _row_gap$1$[ebp]

; 691  :                         *dp = val<<upshift;

	mov	DWORD PTR [edx], eax

; 692  :                       or_val |= *dp;

	mov	eax, DWORD PTR _or_val$1$[ebp]
	or	eax, DWORD PTR [edx]
	mov	DWORD PTR _or_val$1$[ebp], eax
	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR _n_inc$1$[ebp]
	add	edx, eax
	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR _upshift$1$[ebp]
	add	esi, eax
	test	edi, edi
	jne	SHORT $LL22@do_job
	mov	eax, DWORD PTR _m$2$[ebp]
$LN227@do_job:

; 683  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp++)

	mov	edi, DWORD PTR _m_inc$1$[ebp]
	mov	esi, DWORD PTR _spp$1$[ebp]
	lea	edx, DWORD PTR [edi*4]
	mov	edi, DWORD PTR tv2724[ebp]
	add	esi, edx
	mov	edx, DWORD PTR _dpp$1$[ebp]
	add	edx, 4
	mov	DWORD PTR _spp$1$[ebp], esi
	mov	DWORD PTR _dpp$1$[ebp], edx
	test	eax, eax
	jne	$LL19@do_job

; 693  :                     }
; 694  :             }
; 695  :           else

	jmp	$LN349@do_job
$LN117@do_job:

; 696  :             { // Source data is true floating point values.
; 697  :               float val;
; 698  :               float scale = (1.0F / delta);

	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, DWORD PTR [eax+20]

; 699  :               if (K_max <= 31)

	movzx	eax, WORD PTR [eax+12]
	cmp	ax, 31					; 0000001fH
	jg	SHORT $LN126@do_job

; 700  :                 scale *= (float)(1<<(31-K_max));

	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
	mulss	xmm2, xmm1

; 701  :               else

	jmp	SHORT $LN127@do_job
$LN126@do_job:

; 702  :                 scale /= (float)(1<<(K_max-31)); // Can't decode all planes

	lea	ecx, DWORD PTR [eax-31]
	movaps	xmm2, xmm1
	mov	eax, 1
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm2, xmm0
$LN127@do_job:

; 703  :               if (!block->transpose)

	test	dl, dl

; 704  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp+=row_gap)

	mov	edx, DWORD PTR _m$13$[ebp]
	mov	eax, edx
	jne	$LN128@do_job
	test	edx, edx
	je	$LN349@do_job
	mov	ecx, DWORD PTR _n_start$1$[ebp]
	mov	edx, DWORD PTR _spp$1$[ebp]
	lea	esi, DWORD PTR [ecx*4]
	mov	DWORD PTR tv2723[ebp], esi
	npad	6
$LL25@do_job:

; 705  :                   for (sp=(*spp)+n_start, dp=dpp,

	mov	edx, DWORD PTR [edx]
	dec	eax
	add	edx, esi
	mov	DWORD PTR _m$3$[ebp], eax
	mov	esi, DWORD PTR _xfer_size$1$[ebp]
	mov	ecx, edi

; 706  :                        n=xfer_size.x; n--; dp++, sp+=n_inc)

	test	esi, esi
	je	SHORT $LN231@do_job
	mov	eax, DWORD PTR _n_inc$1$[ebp]
	xorps	xmm1, xmm1
	lea	edi, DWORD PTR [eax*4]
$LL28@do_job:

; 707  :                     {
; 708  :                       val = scale * sp->fval;

	movaps	xmm0, xmm2
	dec	esi
	mulss	xmm0, DWORD PTR [edx]

; 709  :                       if (val < 0.0F)

	comiss	xmm1, xmm0
	jbe	SHORT $LN130@do_job

; 710  :                         *dp = ((kdu_int32)(-val)) | KDU_INT32_MIN;

	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvttss2si eax, xmm0
	or	eax, -2147483648			; 80000000H

; 711  :                       else

	jmp	SHORT $LN360@do_job
$LN130@do_job:

; 712  :                         *dp = (kdu_int32) val;

	cvttss2si eax, xmm0
$LN360@do_job:
	mov	DWORD PTR [ecx], eax
	add	edx, edi

; 713  :                       or_val |= *dp;

	mov	eax, DWORD PTR _or_val$1$[ebp]
	or	eax, DWORD PTR [ecx]
	add	ecx, 4
	mov	DWORD PTR _or_val$1$[ebp], eax
	test	esi, esi
	jne	SHORT $LL28@do_job
	mov	eax, DWORD PTR _m$3$[ebp]
	mov	edi, DWORD PTR _dpp$1$[ebp]
$LN231@do_job:

; 704  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp+=row_gap)

	mov	esi, DWORD PTR _m_inc$1$[ebp]
	mov	edx, DWORD PTR _spp$1$[ebp]
	lea	ecx, DWORD PTR [esi*4]
	mov	esi, DWORD PTR _row_gap$1$[ebp]
	add	edx, ecx
	mov	DWORD PTR _spp$1$[ebp], edx
	lea	ecx, DWORD PTR [esi*4]
	mov	esi, DWORD PTR tv2723[ebp]
	add	edi, ecx
	mov	DWORD PTR _dpp$1$[ebp], edi
	test	eax, eax
	jne	$LL25@do_job

; 714  :                     }
; 715  :               else

	jmp	$LN349@do_job
$LN128@do_job:

; 716  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp++)

	test	edx, edx
	je	$LN349@do_job
	mov	ecx, DWORD PTR _n_start$1$[ebp]
	mov	edx, DWORD PTR _spp$1$[ebp]
	lea	esi, DWORD PTR [ecx*4]
	mov	DWORD PTR tv2722[ebp], esi
$LL31@do_job:

; 717  :                   for (sp=(*spp)+n_start, dp=dpp,

	mov	edx, DWORD PTR [edx]
	dec	eax
	add	edx, esi
	mov	DWORD PTR _m$4$[ebp], eax
	mov	esi, DWORD PTR _xfer_size$1$[ebp]
	mov	ecx, edi

; 718  :                        n=xfer_size.x; n--; dp+=row_gap, sp+=n_inc)

	test	esi, esi
	je	SHORT $LN235@do_job
	mov	eax, DWORD PTR _row_gap$1$[ebp]
	xorps	xmm1, xmm1
	lea	edi, DWORD PTR [eax*4]
	mov	DWORD PTR tv2703[ebp], edi
$LL34@do_job:

; 719  :                     {
; 720  :                       val = scale * sp->fval;

	movaps	xmm0, xmm2
	dec	esi
	mulss	xmm0, DWORD PTR [edx]

; 721  :                       if (val < 0.0F)

	comiss	xmm1, xmm0
	jbe	SHORT $LN132@do_job

; 722  :                         *dp = ((kdu_int32)(-val)) | KDU_INT32_MIN;

	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	cvttss2si eax, xmm0
	or	eax, -2147483648			; 80000000H

; 723  :                       else

	jmp	SHORT $LN361@do_job
$LN132@do_job:

; 724  :                         *dp = (kdu_int32) val;

	cvttss2si eax, xmm0
$LN361@do_job:
	mov	DWORD PTR [ecx], eax

; 725  :                       or_val |= *dp;

	mov	eax, DWORD PTR _or_val$1$[ebp]
	or	eax, DWORD PTR [ecx]
	add	ecx, edi
	mov	edi, DWORD PTR _n_inc$1$[ebp]
	mov	DWORD PTR _or_val$1$[ebp], eax
	lea	eax, DWORD PTR [edi*4]
	mov	edi, DWORD PTR tv2703[ebp]
	add	edx, eax
	test	esi, esi
	jne	SHORT $LL34@do_job
	mov	eax, DWORD PTR _m$4$[ebp]
	mov	edi, DWORD PTR _dpp$1$[ebp]
$LN235@do_job:

; 716  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp++)

	mov	esi, DWORD PTR _m_inc$1$[ebp]
	add	edi, 4
	mov	edx, DWORD PTR _spp$1$[ebp]
	mov	DWORD PTR _dpp$1$[ebp], edi
	lea	ecx, DWORD PTR [esi*4]
	mov	esi, DWORD PTR tv2722[ebp]
	add	edx, ecx
	mov	DWORD PTR _spp$1$[ebp], edx
	test	eax, eax
	jne	$LL31@do_job

; 726  :                     }
; 727  :             }
; 728  :         }
; 729  :       else

	jmp	$LN349@do_job
$LN115@do_job:

; 730  :         { // Working with 16-bit source data.
; 731  :           kdu_sample16 *sp, **spp=buf16+m_start;

	mov	ecx, DWORD PTR _buf16$1$[ebp]
	lea	esi, DWORD PTR [ecx+eax*4]

; 732  :           if (reversible)

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR _spp$1$[ebp], esi
	cmp	BYTE PTR [eax+16], 0
	je	$LN134@do_job

; 733  :             { // Source data is 16-bit absolute integers.
; 734  :               kdu_int32 val;
; 735  :               kdu_int32 upshift = 31-K_max;

	movsx	eax, WORD PTR [eax+12]
	mov	ecx, 31					; 0000001fH
	sub	ecx, eax

; 736  :               assert(upshift >= 0); // Otherwise should not have chosen 16 bits
; 737  :               if (!block->transpose)

	test	dl, dl

; 738  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp+=row_gap)

	mov	edx, DWORD PTR _m$13$[ebp]
	mov	eax, edx
	mov	DWORD PTR _upshift$1$[ebp], ecx
	jne	$LN136@do_job
	test	edx, edx
	je	$LN349@do_job
	mov	edx, DWORD PTR _n_start$1$[ebp]
	lea	edi, DWORD PTR [edx+edx]
	mov	DWORD PTR tv2694[ebp], edi
	npad	8
$LL37@do_job:

; 739  :                   for (sp=(*spp)+n_start, dp=dpp,

	mov	esi, DWORD PTR [esi]
	dec	eax
	mov	edx, DWORD PTR _dpp$1$[ebp]
	add	esi, edi
	mov	edi, DWORD PTR _xfer_size$1$[ebp]
	mov	DWORD PTR _m$5$[ebp], eax

; 740  :                        n=xfer_size.x; n--; dp++, sp+=n_inc)

	test	edi, edi
	je	SHORT $LN239@do_job
	npad	5
$LL40@do_job:

; 741  :                     {
; 742  :                       val = sp->ival;

	movsx	eax, WORD PTR [esi]
	dec	edi

; 743  :                       if (val < 0)

	test	eax, eax
	jns	SHORT $LN138@do_job

; 744  :                         *dp = ((-val)<<upshift) | KDU_INT32_MIN;

	neg	eax
	shl	eax, cl
	or	eax, -2147483648			; 80000000H

; 745  :                       else

	jmp	SHORT $LN362@do_job
$LN138@do_job:

; 746  :                         *dp = val<<upshift;

	shl	eax, cl
$LN362@do_job:

; 740  :                        n=xfer_size.x; n--; dp++, sp+=n_inc)

	mov	ecx, DWORD PTR _n_inc$1$[ebp]

; 746  :                         *dp = val<<upshift;

	mov	DWORD PTR [edx], eax

; 747  :                       or_val |= *dp;

	mov	eax, DWORD PTR _or_val$1$[ebp]
	or	eax, DWORD PTR [edx]
	add	edx, 4
	mov	DWORD PTR _or_val$1$[ebp], eax
	lea	esi, DWORD PTR [esi+ecx*2]
	mov	ecx, DWORD PTR _upshift$1$[ebp]
	test	edi, edi
	jne	SHORT $LL40@do_job
	mov	eax, DWORD PTR _m$5$[ebp]
$LN239@do_job:

; 738  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp+=row_gap)

	mov	edi, DWORD PTR _m_inc$1$[ebp]
	mov	esi, DWORD PTR _spp$1$[ebp]
	lea	edx, DWORD PTR [edi*4]
	mov	edi, DWORD PTR _row_gap$1$[ebp]
	add	esi, edx
	mov	DWORD PTR _spp$1$[ebp], esi
	lea	edx, DWORD PTR [edi*4]
	mov	edi, DWORD PTR tv2694[ebp]
	add	DWORD PTR _dpp$1$[ebp], edx
	test	eax, eax
	jne	$LL37@do_job

; 748  :                     }
; 749  :               else

	jmp	$LN349@do_job
$LN136@do_job:

; 750  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp++)

	test	edx, edx
	je	$LN349@do_job
	mov	edx, DWORD PTR _n_start$1$[ebp]
	lea	edi, DWORD PTR [edx+edx]
	mov	edx, DWORD PTR _dpp$1$[ebp]
	mov	DWORD PTR tv2693[ebp], edi
	npad	1
$LL43@do_job:

; 751  :                   for (sp=(*spp)+n_start, dp=dpp,

	mov	esi, DWORD PTR [esi]
	dec	eax
	add	esi, edi
	mov	DWORD PTR _m$6$[ebp], eax
	mov	edi, DWORD PTR _xfer_size$1$[ebp]

; 752  :                        n=xfer_size.x; n--; dp+=row_gap, sp+=n_inc)

	test	edi, edi
	je	SHORT $LN243@do_job
$LL46@do_job:

; 753  :                     {
; 754  :                       val = sp->ival;

	movsx	eax, WORD PTR [esi]
	dec	edi

; 755  :                       if (val < 0)

	test	eax, eax
	jns	SHORT $LN140@do_job

; 756  :                         *dp = ((-val)<<upshift) | KDU_INT32_MIN;

	neg	eax
	shl	eax, cl
	or	eax, -2147483648			; 80000000H

; 757  :                       else

	jmp	SHORT $LN363@do_job
$LN140@do_job:

; 758  :                         *dp = val<<upshift;

	shl	eax, cl
$LN363@do_job:

; 752  :                        n=xfer_size.x; n--; dp+=row_gap, sp+=n_inc)

	mov	ecx, DWORD PTR _row_gap$1$[ebp]

; 758  :                         *dp = val<<upshift;

	mov	DWORD PTR [edx], eax

; 759  :                       or_val |= *dp;

	mov	eax, DWORD PTR _or_val$1$[ebp]
	or	eax, DWORD PTR [edx]
	mov	DWORD PTR _or_val$1$[ebp], eax
	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR _n_inc$1$[ebp]
	add	edx, eax
	lea	esi, DWORD PTR [esi+ecx*2]
	mov	ecx, DWORD PTR _upshift$1$[ebp]
	test	edi, edi
	jne	SHORT $LL46@do_job
	mov	eax, DWORD PTR _m$6$[ebp]
$LN243@do_job:

; 750  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp++)

	mov	edi, DWORD PTR _m_inc$1$[ebp]
	mov	esi, DWORD PTR _spp$1$[ebp]
	lea	edx, DWORD PTR [edi*4]
	mov	edi, DWORD PTR tv2693[ebp]
	add	esi, edx
	mov	edx, DWORD PTR _dpp$1$[ebp]
	add	edx, 4
	mov	DWORD PTR _spp$1$[ebp], esi
	mov	DWORD PTR _dpp$1$[ebp], edx
	test	eax, eax
	jne	$LL43@do_job

; 760  :                     }
; 761  :             }
; 762  :           else

	jmp	$LN349@do_job
$LN134@do_job:

; 763  :             { // Source data is 16-bit fixed point integers.
; 764  :               float fscale = 1.0F / (delta * (float)(1<<KDU_FIX_POINT));

	movss	xmm0, DWORD PTR [eax+20]
	mulss	xmm0, DWORD PTR __real@46000000

; 765  :               if (K_max <= 31)

	movzx	eax, WORD PTR [eax+12]
	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm0
	cmp	ax, 31					; 0000001fH
	jg	SHORT $LN142@do_job

; 766  :                 fscale *= (float)(1<<(31-K_max));

	mov	ecx, 31					; 0000001fH
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm2

; 767  :               else

	jmp	SHORT $LN143@do_job
$LN142@do_job:

; 768  :                 fscale /= (float)(1<<(K_max-31));

	lea	ecx, DWORD PTR [eax-31]
	movaps	xmm1, xmm2
	mov	eax, 1
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
$LN143@do_job:

; 769  :               kdu_int32 val, scale = (kdu_int32)(fscale+0.5F);

	addss	xmm1, DWORD PTR __real@3f000000
	cvttss2si eax, xmm1
	mov	DWORD PTR _scale$1$[ebp], eax

; 770  :               if (!block->transpose)

	test	dl, dl
	jne	$LN144@do_job

; 771  : 			  {
; 772  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp+=row_gap)

	mov	edx, DWORD PTR _m$13$[ebp]
	mov	eax, edx
	test	edx, edx
	je	$LN349@do_job
	mov	ecx, DWORD PTR _n_start$1$[ebp]
	lea	edx, DWORD PTR [ecx+ecx]
	mov	DWORD PTR tv2692[ebp], edx
	npad	2
$LL49@do_job:

; 773  :                   for (sp=(*spp)+n_start, dp=dpp,

	mov	ecx, DWORD PTR [esi]
	dec	eax
	add	ecx, edx
	mov	DWORD PTR _m$7$[ebp], eax
	mov	edx, DWORD PTR _xfer_size$1$[ebp]
	mov	esi, edi

; 774  :                        n=xfer_size.x; n--; dp++, sp+=n_inc)

	test	edx, edx
	je	SHORT $LN247@do_job
	mov	eax, DWORD PTR _n_inc$1$[ebp]
	xorps	xmm1, xmm1
	lea	edi, DWORD PTR [eax+eax]
$LL52@do_job:

; 775  :                     {
; 776  :                       val = sp->ival; val *= scale;

	movsx	eax, WORD PTR [ecx]
	dec	edx
	imul	eax, DWORD PTR _scale$1$[ebp]
	movd	xmm0, eax

; 777  :                       if (val < 0.0F)

	cvtdq2ps xmm0, xmm0
	comiss	xmm1, xmm0
	jbe	SHORT $LN146@do_job

; 778  :                         val = (-val) | KDU_INT32_MIN;

	neg	eax
	or	eax, -2147483648			; 80000000H
$LN146@do_job:

; 779  :                       *dp = val;
; 780  : 
; 781  :                       or_val |= val;

	or	DWORD PTR _or_val$1$[ebp], eax
	add	ecx, edi
	mov	DWORD PTR [esi], eax
	add	esi, 4
	test	edx, edx
	jne	SHORT $LL52@do_job
	mov	eax, DWORD PTR _m$7$[ebp]
	mov	edi, DWORD PTR _dpp$1$[ebp]
$LN247@do_job:

; 771  : 			  {
; 772  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp+=row_gap)

	mov	edx, DWORD PTR _m_inc$1$[ebp]
	mov	esi, DWORD PTR _spp$1$[ebp]
	lea	ecx, DWORD PTR [edx*4]
	mov	edx, DWORD PTR _row_gap$1$[ebp]
	add	esi, ecx
	mov	DWORD PTR _spp$1$[ebp], esi
	lea	ecx, DWORD PTR [edx*4]
	mov	edx, DWORD PTR tv2692[ebp]
	add	edi, ecx
	mov	DWORD PTR _dpp$1$[ebp], edi
	test	eax, eax
	jne	$LL49@do_job

; 782  :                     }
; 783  : 
; 784  : 
; 785  : 			  }
; 786  :               else

	jmp	$LN349@do_job
$LN144@do_job:

; 787  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp++)

	mov	ecx, DWORD PTR _m$13$[ebp]
	mov	eax, ecx
	test	ecx, ecx
	je	$LN349@do_job
	mov	ecx, DWORD PTR _n_start$1$[ebp]
	lea	edx, DWORD PTR [ecx+ecx]
	mov	DWORD PTR tv2691[ebp], edx
$LL55@do_job:

; 788  :                   for (sp=(*spp)+n_start, dp=dpp,

	mov	ecx, DWORD PTR [esi]
	dec	eax
	add	ecx, edx
	mov	DWORD PTR _m$8$[ebp], eax
	mov	edx, DWORD PTR _xfer_size$1$[ebp]
	mov	esi, edi

; 789  :                        n=xfer_size.x; n--; dp+=row_gap, sp+=n_inc)

	test	edx, edx
	je	SHORT $LN251@do_job
	mov	eax, DWORD PTR _row_gap$1$[ebp]
	xorps	xmm1, xmm1
	lea	edi, DWORD PTR [eax*4]
	mov	DWORD PTR tv2699[ebp], edi
	npad	3
$LL58@do_job:

; 790  :                     {
; 791  :                       val = sp->ival; val *= scale;

	movsx	eax, WORD PTR [ecx]
	dec	edx
	imul	eax, DWORD PTR _scale$1$[ebp]
	movd	xmm0, eax

; 792  :                       if (val < 0.0F)

	cvtdq2ps xmm0, xmm0
	comiss	xmm1, xmm0
	jbe	SHORT $LN147@do_job

; 793  :                         val = (-val) | KDU_INT32_MIN;

	neg	eax
	or	eax, -2147483648			; 80000000H
$LN147@do_job:

; 794  :                       *dp = val;
; 795  :                       or_val |= val;

	or	DWORD PTR _or_val$1$[ebp], eax
	mov	DWORD PTR [esi], eax
	add	esi, edi
	mov	edi, DWORD PTR _n_inc$1$[ebp]
	lea	ecx, DWORD PTR [ecx+edi*2]
	mov	edi, DWORD PTR tv2699[ebp]
	test	edx, edx
	jne	SHORT $LL58@do_job
	mov	eax, DWORD PTR _m$8$[ebp]
	mov	edi, DWORD PTR _dpp$1$[ebp]
$LN251@do_job:

; 787  :                 for (m=xfer_size.y; m--; spp+=m_inc, dpp++)

	mov	edx, DWORD PTR _m_inc$1$[ebp]
	add	edi, 4
	mov	esi, DWORD PTR _spp$1$[ebp]
	mov	DWORD PTR _dpp$1$[ebp], edi
	lea	ecx, DWORD PTR [edx*4]
	mov	edx, DWORD PTR tv2691[ebp]
	add	esi, ecx
	mov	DWORD PTR _spp$1$[ebp], esi
	test	eax, eax
	jne	$LL55@do_job
$LN349@do_job:
	mov	edi, DWORD PTR _block$1$[ebp]
$LN253@do_job:

; 796  :                     }
; 797  :             }
; 798  :         }
; 799  : 
; 800  : 	//ohhan - coefficiets to file
; 801  : 	/*if (oh_dwt_level == 1 && oh_orient == 3)// && oh_coords.y == 128 && oh_coords.x == 128)
; 802  : 	  {
; 803  : 		for (int i = 0; i < block->size.y*block->size.x; i++)
; 804  : 		{
; 805  : 			int oh_val = (block->sample_buffer[i] & 0x7fffffff) >> (31-oh_k_max);
; 806  : 			if (block->sample_buffer[i] < 0)
; 807  : 				oh_val = -oh_val;
; 808  : 			
; 809  : 			fwrite((int*)&oh_val,sizeof(kdu_int32),1,pCoeffs);
; 810  : 
; 811  : 		}
; 812  : 		
; 813  : 	}*/
; 814  : 
; 815  :       // Now check to see if any ROI up-shift has been specified.  If so,
; 816  :       // we need to zero out sufficient LSB's to ensure that the foreground
; 817  :       // and background regions do not get confused.
; 818  :       if (K_max_prime > K_max)

	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	movzx	eax, WORD PTR [esi+14]
	movzx	ecx, WORD PTR [esi+12]
	cmp	ax, cx
	jle	$LN261@do_job

; 819  :         {
; 820  :           dpp = block->sample_buffer;

	mov	edi, DWORD PTR [edi+108]

; 821  :           kdu_int32 mask = ((kdu_int32)(-1)) << (31-K_max);

	or	esi, -1
	movsx	edx, cx
	mov	ecx, 31					; 0000001fH
	sub	ecx, edx

; 822  :           if ((K_max_prime - K_max) < K_max)

	cwde
	sub	eax, edx
	shl	esi, cl
	cmp	eax, edx
	jge	SHORT $LN149@do_job

; 823  :             { KDU_ERROR(e,2); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0BBG@CKMLINCB@You?5have?5selected?5too?5small?5a?5va@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 823  :             { KDU_ERROR(e,2); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 830  :             }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN149@do_job:

; 831  :           if (!block->transpose)

	mov	eax, DWORD PTR _block$1$[ebp]
	cmp	BYTE PTR [eax+24], 0
	jne	SHORT $LN150@do_job

; 832  :             for (m=xfer_size.y; m--; dpp+=row_gap)

	mov	eax, DWORD PTR _m$13$[ebp]
	mov	edx, eax
	test	eax, eax
	je	SHORT $LN354@do_job
$LL61@do_job:

; 833  :               for (dp=dpp, n=xfer_size.x; n--; dp++)

	mov	ecx, DWORD PTR _xfer_size$1$[ebp]
	dec	edx
	mov	eax, edi
	test	ecx, ecx
	je	SHORT $LN255@do_job
$LL64@do_job:

; 834  :                 *dp &= mask;

	and	DWORD PTR [eax], esi
	lea	eax, DWORD PTR [eax+4]
	sub	ecx, 1
	jne	SHORT $LL64@do_job
$LN255@do_job:

; 832  :             for (m=xfer_size.y; m--; dpp+=row_gap)

	mov	ecx, DWORD PTR _row_gap$1$[ebp]
	lea	eax, DWORD PTR [ecx*4]
	add	edi, eax
	test	edx, edx
	jne	SHORT $LL61@do_job

; 835  :           else

	jmp	SHORT $LN354@do_job
$LN150@do_job:

; 836  :             for (m=xfer_size.x; m--; dpp+=row_gap)

	mov	eax, DWORD PTR _xfer_size$1$[ebp]
	mov	edx, eax
	test	eax, eax
	je	SHORT $LN354@do_job
	npad	4
$LL67@do_job:

; 837  :               for (dp=dpp, n=xfer_size.y; n--; dp++)

	mov	ecx, DWORD PTR _m$13$[ebp]
	dec	edx
	mov	eax, edi
	test	ecx, ecx
	je	SHORT $LN259@do_job
	npad	3
$LL70@do_job:

; 838  :                 *dp &= mask;

	and	DWORD PTR [eax], esi
	lea	eax, DWORD PTR [eax+4]
	sub	ecx, 1
	jne	SHORT $LL70@do_job
$LN259@do_job:

; 836  :             for (m=xfer_size.x; m--; dpp+=row_gap)

	mov	ecx, DWORD PTR _row_gap$1$[ebp]
	lea	eax, DWORD PTR [ecx*4]
	add	edi, eax
	test	edx, edx
	jne	SHORT $LL67@do_job
$LN354@do_job:
	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
$LN261@do_job:

; 839  :         }
; 840  : 
; 841  :       // Now transfer any ROI information which may be available.
; 842  :       bool have_background = false; // If no background, code less bit-planes.

	xor	dh, dh

; 843  :       bool scale_wmse = false; // If true, scale WMSE to account for shifting.
; 844  :       if ((roi != NULL) && (K_max_prime != K_max))

	cmp	DWORD PTR _roi$1$[ebp], 0
	mov	BYTE PTR _have_background$1$[ebp], dh
	mov	BYTE PTR _scale_wmse$1$[ebp], dh
	je	$LN161@do_job
	movzx	ecx, WORD PTR [esi+14]
	movzx	eax, WORD PTR [esi+12]

; 845  :         {
; 846  :           scale_wmse = true; // Background will be shifted down at least
; 847  :           dpp = block->sample_buffer;
; 848  :           kdu_byte *sp, **spp=roi+m_start;

	mov	edi, DWORD PTR _m_start$1$[ebp]
	cmp	cx, ax
	je	$LN152@do_job

; 849  :           kdu_int32 val;
; 850  :           kdu_int32 downshift = K_max_prime - K_max;
; 851  :           assert(downshift >= K_max);
; 852  :           bool have_foreground = false; // If no foreground, downshift `or_val'

	mov	esi, DWORD PTR _block$1$[ebp]
	xor	dl, dl
	cwde
	movsx	ecx, cx
	sub	ecx, eax
	mov	BYTE PTR _scale_wmse$1$[ebp], 1
	mov	esi, DWORD PTR [esi+108]

; 853  :           if (!block->transpose)

	mov	eax, DWORD PTR _block$1$[ebp]
	mov	DWORD PTR _dpp$3$[ebp], esi
	mov	esi, DWORD PTR _roi$1$[ebp]
	mov	DWORD PTR _downshift$1$[ebp], ecx
	mov	BYTE PTR _have_foreground$1$[ebp], dl
	lea	edi, DWORD PTR [esi+edi*4]
	mov	esi, DWORD PTR _dpp$3$[ebp]
	mov	DWORD PTR _spp$1$[ebp], edi
	cmp	BYTE PTR [eax+24], dl
	jne	$LN154@do_job

; 854  :             {
; 855  :               for (m=xfer_size.y; m--; spp+=m_inc, dpp+=row_gap)

	cmp	DWORD PTR _m$13$[ebp], 0
	je	$LN341@do_job
	mov	eax, DWORD PTR _m$13$[ebp]
$LL73@do_job:

; 856  :                 for (sp=(*spp)+n_start, dp=dpp,

	mov	edi, DWORD PTR [edi]
	dec	eax
	add	edi, DWORD PTR _n_start$1$[ebp]
	mov	DWORD PTR _m$13$[ebp], eax
	mov	eax, DWORD PTR _xfer_size$1$[ebp]

; 857  :                      n=xfer_size.x; n--; dp++, sp+=n_inc)

	test	eax, eax
	je	SHORT $LN263@do_job
	npad	1
$LL76@do_job:
	dec	eax

; 858  :                   if (*sp == 0)

	cmp	BYTE PTR [edi], 0
	mov	DWORD PTR _n$11$[ebp], eax
	jne	SHORT $LN156@do_job

; 859  :                     { // Adjust background samples down.
; 860  :                       have_background = true;
; 861  :                       val = *dp;

	mov	eax, DWORD PTR [esi]

; 862  :                       *dp = (val & KDU_INT32_MIN)

	mov	edx, eax
	and	edx, 2147483647				; 7fffffffH
	mov	BYTE PTR _have_background$1$[ebp], 1
	sar	edx, cl
	and	eax, -2147483648			; 80000000H
	or	edx, eax

; 863  :                           | ((val & KDU_INT32_MAX) >> downshift);
; 864  :                     }
; 865  :                   else

	mov	eax, DWORD PTR _n$11$[ebp]
	mov	DWORD PTR [esi], edx
	mov	dl, BYTE PTR _have_foreground$1$[ebp]
	jmp	SHORT $LN74@do_job
$LN156@do_job:

; 866  :                     have_foreground = true;

	mov	dl, 1
	mov	BYTE PTR _have_foreground$1$[ebp], dl
$LN74@do_job:

; 857  :                      n=xfer_size.x; n--; dp++, sp+=n_inc)

	add	edi, DWORD PTR _n_inc$1$[ebp]
	add	esi, 4
	test	eax, eax
	jne	SHORT $LL76@do_job
$LN263@do_job:

; 854  :             {
; 855  :               for (m=xfer_size.y; m--; spp+=m_inc, dpp+=row_gap)

	mov	esi, DWORD PTR _m_inc$1$[ebp]
	mov	ecx, DWORD PTR _row_gap$1$[ebp]
	mov	edi, DWORD PTR _spp$1$[ebp]
	lea	eax, DWORD PTR [esi*4]
	mov	esi, DWORD PTR _dpp$3$[ebp]
	add	edi, eax
	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	add	esi, eax
	mov	eax, DWORD PTR _m$13$[ebp]
	mov	DWORD PTR _spp$1$[ebp], edi
	mov	DWORD PTR _dpp$3$[ebp], esi
	test	eax, eax
	jne	$LL73@do_job

; 867  :             }
; 868  :           else

	jmp	$LN269@do_job
$LN154@do_job:

; 869  :             {
; 870  :               for (m=xfer_size.y; m--; spp+=m_inc, dpp++)

	mov	esi, DWORD PTR _m$13$[ebp]
	test	esi, esi
	je	$LN341@do_job
	mov	eax, DWORD PTR _dpp$3$[ebp]
	mov	ecx, DWORD PTR _xfer_size$1$[ebp]
$LL79@do_job:
	dec	esi
	mov	DWORD PTR _m$13$[ebp], esi

; 871  :                 for (sp=(*spp)+n_start, dp=dpp,

	mov	esi, DWORD PTR [edi]
	mov	edi, eax
	add	esi, DWORD PTR _n_start$1$[ebp]
	mov	eax, ecx

; 872  :                      n=xfer_size.x; n--; dp+=row_gap, sp+=n_inc)

	test	ecx, ecx
	je	$LN267@do_job
	mov	ecx, DWORD PTR _row_gap$1$[ebp]
	shl	ecx, 2
	mov	DWORD PTR tv2695[ebp], ecx
	npad	2
$LL82@do_job:
	dec	eax

; 873  :                   if (*sp == 0)

	cmp	BYTE PTR [esi], 0
	mov	DWORD PTR _n$12$[ebp], eax
	jne	SHORT $LN158@do_job

; 874  :                     { // Adjust background samples down.
; 875  :                       have_background = true;
; 876  :                       val = *dp;

	mov	eax, DWORD PTR [edi]

; 877  :                       *dp = (val & KDU_INT32_MIN)

	mov	edx, eax
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	and	edx, 2147483647				; 7fffffffH
	sar	edx, cl
	and	eax, -2147483648			; 80000000H

; 878  :                           | ((val & KDU_INT32_MAX) >> downshift);
; 879  :                     }
; 880  :                   else

	mov	ecx, DWORD PTR tv2695[ebp]
	or	edx, eax
	mov	eax, DWORD PTR _n$12$[ebp]
	mov	DWORD PTR [edi], edx
	mov	dl, BYTE PTR _have_foreground$1$[ebp]
	mov	BYTE PTR _have_background$1$[ebp], 1
	jmp	SHORT $LN80@do_job
$LN158@do_job:

; 881  :                     have_foreground = true;

	mov	dl, 1
	mov	BYTE PTR _have_foreground$1$[ebp], dl
$LN80@do_job:

; 872  :                      n=xfer_size.x; n--; dp+=row_gap, sp+=n_inc)

	add	esi, DWORD PTR _n_inc$1$[ebp]
	add	edi, ecx
	test	eax, eax
	jne	SHORT $LL82@do_job
	mov	ecx, DWORD PTR _xfer_size$1$[ebp]
$LN267@do_job:

; 869  :             {
; 870  :               for (m=xfer_size.y; m--; spp+=m_inc, dpp++)

	mov	esi, DWORD PTR _m_inc$1$[ebp]
	mov	edi, DWORD PTR _spp$1$[ebp]
	lea	eax, DWORD PTR [esi*4]
	mov	esi, DWORD PTR _m$13$[ebp]
	add	edi, eax
	mov	eax, DWORD PTR _dpp$3$[ebp]
	add	eax, 4
	mov	DWORD PTR _spp$1$[ebp], edi
	mov	DWORD PTR _dpp$3$[ebp], eax
	test	esi, esi
	jne	$LL79@do_job
	mov	ecx, DWORD PTR _downshift$1$[ebp]
$LN269@do_job:
	mov	dh, BYTE PTR _have_background$1$[ebp]

; 882  :             }
; 883  :           if (!have_foreground)

	test	dl, dl
	jne	SHORT $LN162@do_job
$LN341@do_job:

; 884  :             or_val = (or_val & KDU_INT32_MAX) >> downshift;

	mov	eax, DWORD PTR _or_val$1$[ebp]
	and	eax, 2147483647				; 7fffffffH
	sar	eax, cl
	mov	DWORD PTR _or_val$1$[ebp], eax
$LN162@do_job:

; 898  : 
; 899  :       // Finally, we can encode the block.
; 900  :       int K = (have_background)?K_max_prime:K_max;

	test	dh, dh
	je	$LN171@do_job
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	movzx	eax, WORD PTR [ecx+14]
	jmp	$LN172@do_job
$LN152@do_job:

; 885  :         }
; 886  :       else if (roi != NULL)
; 887  :         {
; 888  :           kdu_byte *sp, **spp=roi+m_start;

	mov	eax, DWORD PTR _roi$1$[ebp]
	lea	edx, DWORD PTR [eax+edi*4]

; 889  :           for (m=xfer_size.y; m--; spp+=m_inc)

	mov	eax, DWORD PTR _m$13$[ebp]
	test	eax, eax
	je	$LN171@do_job
	mov	ecx, DWORD PTR _m_inc$1$[ebp]
	mov	edi, DWORD PTR _xfer_size$1$[ebp]
	lea	esi, DWORD PTR [ecx*4]
	npad	8
$LL85@do_job:
	dec	eax

; 890  :             for (sp=(*spp)+n_start, n=xfer_size.x; n--; sp+=n_inc)

	mov	ecx, edi
	mov	DWORD PTR _m$13$[ebp], eax
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _n_start$1$[ebp]
	test	edi, edi
	je	SHORT $LN343@do_job
	mov	edi, DWORD PTR _n_inc$1$[ebp]
	npad	5
$LL88@do_job:
	dec	ecx

; 891  :               if (*sp != 0)

	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN220@do_job

; 890  :             for (sp=(*spp)+n_start, n=xfer_size.x; n--; sp+=n_inc)

	add	eax, edi
	test	ecx, ecx
	jne	SHORT $LL88@do_job

; 891  :               if (*sp != 0)

	mov	edi, DWORD PTR _xfer_size$1$[ebp]
$LN343@do_job:
	mov	eax, DWORD PTR _m$13$[ebp]
$LN83@do_job:

; 889  :           for (m=xfer_size.y; m--; spp+=m_inc)

	add	edx, esi
	test	eax, eax
	jne	SHORT $LL85@do_job

; 894  :                 }
; 895  :         }
; 896  :       else

	jmp	SHORT $LN171@do_job
$LN220@do_job:

; 892  :                 { // Treat whole block as foreground if it intersects with ROI
; 893  :                   scale_wmse = true; m=0; break;

	mov	edi, DWORD PTR _xfer_size$1$[ebp]
	xor	eax, eax
	mov	BYTE PTR _scale_wmse$1$[ebp], 1
	jmp	SHORT $LN83@do_job
$LN161@do_job:

; 897  :         scale_wmse = true; // Everything belongs to foreground

	mov	BYTE PTR _scale_wmse$1$[ebp], 1
$LN171@do_job:

; 898  : 
; 899  :       // Finally, we can encode the block.
; 900  :       int K = (have_background)?K_max_prime:K_max;

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	movzx	eax, WORD PTR [ecx+12]
$LN172@do_job:

; 901  :       if (K > 30)
; 902  :         {
; 903  :           if (reversible && (K_max_prime > K_max) &&

	mov	edi, DWORD PTR _block$1$[ebp]
	movsx	esi, ax
	cmp	esi, 30					; 0000001eH
	jle	SHORT $LN165@do_job
	cmp	BYTE PTR [ecx+16], 0
	je	SHORT $LN165@do_job
	mov	ax, WORD PTR [ecx+14]
	cmp	ax, WORD PTR [ecx+12]
	jle	SHORT $LN165@do_job
	cmp	BYTE PTR [edi+125], 0
	jne	SHORT $LN165@do_job

; 907  :               KDU_WARNING(w,0); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$2[ebp]
	mov	BYTE PTR [edi+125], 1
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$2[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	OFFSET ??_C@_0BOA@JLICEEPH@The?5ROI?5shift?5?$CI?$GARshift?8?5attribut@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 907  :               KDU_WARNING(w,0); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 917  :             }

	lea	ecx, DWORD PTR _w$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN165@do_job:

; 918  :         }
; 919  :       K = (K>31)?31:K;
; 920  :       or_val &= KDU_INT32_MAX;

	mov	ecx, DWORD PTR _or_val$1$[ebp]
	cmp	esi, 31					; 0000001fH
	mov	eax, 31					; 0000001fH
	cmovg	esi, eax
	and	ecx, 2147483647				; 7fffffffH

; 921  :       if (or_val == 0)

	je	SHORT $LN364@do_job

; 922  :         block->missing_msbs = 31;
; 923  :       else
; 924  :         for (block->missing_msbs=0, or_val<<=1; or_val >= 0; or_val<<=1)

	add	ecx, ecx
	mov	DWORD PTR [edi+44], 0
	js	SHORT $LN90@do_job
	xor	eax, eax
	npad	3
$LL91@do_job:

; 925  :           block->missing_msbs++;

	inc	eax
	add	ecx, ecx
	jns	SHORT $LL91@do_job
$LN364@do_job:
	mov	DWORD PTR [edi+44], eax
$LN90@do_job:

; 926  :       if (block->missing_msbs >= K)

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, esi
	jl	SHORT $LN168@do_job

; 927  :         {
; 928  :           block->missing_msbs = K;

	mov	DWORD PTR [edi+44], esi

; 929  :           block->num_passes = 0;

	mov	DWORD PTR [edi+48], 0

; 930  :         }
; 931  :       else

	jmp	SHORT $LN169@do_job
$LN168@do_job:

; 932  :         {
; 933  :           K -= block->missing_msbs;
; 934  :           block->num_passes = 3*K-2;

	sub	esi, eax
	lea	eax, DWORD PTR [esi-1]
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR [edi+48], eax
$LN169@do_job:

; 937  :       double block_msb_wmse = (scale_wmse)?(msb_wmse*roi_weight):msb_wmse;

	cmp	BYTE PTR _scale_wmse$1$[ebp], 0
	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	je	SHORT $LN173@do_job
	movss	xmm0, DWORD PTR [eax+28]
	mulss	xmm0, DWORD PTR [eax+24]
	jmp	SHORT $LN174@do_job
$LN173@do_job:
	movss	xmm0, DWORD PTR [eax+24]
$LN174@do_job:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h

; 145  :         state->encode(block,reversible,msb_wmse,estimated_slope_threshold);

	push	DWORD PTR _estimated_slope_threshold$1$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	eax, BYTE PTR [eax+16]
	sub	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 937  :       double block_msb_wmse = (scale_wmse)?(msb_wmse*roi_weight):msb_wmse;

	cvtps2pd xmm0, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h

; 145  :         state->encode(block,reversible,msb_wmse,estimated_slope_threshold);

	mov	edx, DWORD PTR [ecx]
	movsd	QWORD PTR [esp], xmm0
	push	eax
	push	edi
	call	DWORD PTR [edx+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 940  :       band.close_block(block,env);

	push	DWORD PTR _ent$GSCopy$1$[ebp]
	push	edi
	mov	edi, DWORD PTR tv2734[ebp]
	mov	ecx, edi
	call	?close_block@kdu_subband@@QAEXPAUkdu_block@@PAVkdu_thread_env@@@Z ; kdu_subband::close_block
	mov	ecx, DWORD PTR _blocks_remaining$1$[ebp]
	mov	eax, DWORD PTR _offset$1$[ebp]
	dec	ecx
	add	eax, DWORD PTR _xfer_size$1$[ebp]
	inc	DWORD PTR _idx$2$[ebp]
	mov	DWORD PTR _blocks_remaining$1$[ebp], ecx
	mov	DWORD PTR _offset$1$[ebp], eax
	test	ecx, ecx
	jg	$LL10@do_job
$LN9@do_job:

; 941  :     }
; 942  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z$0:
	lea	ecx, DWORD PTR _e$6[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z$1:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z$2:
	lea	ecx, DWORD PTR _w$2[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__ehhandler$?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-976]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_job@kd_encoder@@MAEXPAVkdu_thread_entity@@H@Z ENDP	; kd_encoder::do_job
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
;	COMDAT ?push@kd_encoder@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_n$2$ = -4						; size = 4
_n$1$ = -4						; size = 4
_line$ = 8						; size = 4
$T1 = 12						; size = 4
$T2 = 12						; size = 4
_env$ = 12						; size = 4
?push@kd_encoder@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z PROC ; kd_encoder::push, COMDAT
; _this$ = ecx

; 375  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi

; 376  :   if (line.get_width() == 0)

	mov	edi, DWORD PTR _line$[ebp]
	mov	esi, ecx
	cmp	DWORD PTR [edi], 0
	je	$LN35@push

; 377  :     return;
; 378  : 
; 379  :   assert((queue == NULL) || (env != NULL));
; 380  :   if (!initialized)

	cmp	BYTE PTR [esi+21], 0
	push	ebx

; 381  :     { // Allocate all lines -- they will be aligned and contiguous in memory.
; 382  :       if (env != NULL)

	mov	ebx, DWORD PTR _env$[ebp]
	jne	$LN57@push
	test	ebx, ebx
	je	SHORT $LN41@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [ebx+28]
	cmp	BYTE PTR [eax], 0
	jne	$LN102@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN44@push
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN44@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+28], ebx
$LN41@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 386  :         for (n=0; n < buffer_height; n++)

	xor	eax, eax
	mov	DWORD PTR _n$1$[ebp], 0
	cmp	DWORD PTR [esi+88], eax
	je	SHORT $LN14@push
	cmp	ax, WORD PTR [esi+68]
	jge	$LN6@push
$LL4@push:

; 387  :           lines16[n] = allocator->alloc16(0,subband_cols+(int)alignment_offset)

	mov	ebx, DWORD PTR [esi+80]
	movzx	ecx, BYTE PTR [esi+22]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.

	mov	eax, DWORD PTR [esi+56]
	add	ecx, 7
	add	eax, ecx

; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	edx, DWORD PTR [ebx+8]
	and	eax, -8					; fffffff8H
	mov	edi, DWORD PTR [ebx+16]
	add	edi, edx
	lea	eax, DWORD PTR [edx+eax*2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 387  :           lines16[n] = allocator->alloc16(0,subband_cols+(int)alignment_offset)

	mov	edx, DWORD PTR _n$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	DWORD PTR [ebx+8], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 387  :           lines16[n] = allocator->alloc16(0,subband_cols+(int)alignment_offset)

	movzx	eax, BYTE PTR [esi+22]
	lea	ecx, DWORD PTR [edi+eax*2]
	mov	eax, DWORD PTR [esi+88]
	mov	DWORD PTR [eax+edx*4], ecx
	inc	edx
	movsx	eax, WORD PTR [esi+68]
	mov	DWORD PTR _n$1$[ebp], edx
	cmp	edx, eax
	jl	SHORT $LL4@push

; 388  :                      + alignment_offset;
; 389  :       else

	jmp	SHORT $LN97@push
$LN14@push:

; 390  :         for (n=0; n < buffer_height; n++)

	cmp	ax, WORD PTR [esi+68]
	jge	SHORT $LN6@push
$LL7@push:

; 391  :           lines32[n] = allocator->alloc32(0,subband_cols+(int)alignment_offset)

	mov	ebx, DWORD PTR [esi+80]
	movzx	ecx, BYTE PTR [esi+22]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.

	mov	eax, DWORD PTR [esi+56]
	add	ecx, 3
	add	eax, ecx

; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	edx, DWORD PTR [ebx+8]
	and	eax, -4					; fffffffcH
	mov	edi, DWORD PTR [ebx+16]
	add	edi, edx
	lea	eax, DWORD PTR [edx+eax*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 391  :           lines32[n] = allocator->alloc32(0,subband_cols+(int)alignment_offset)

	mov	edx, DWORD PTR _n$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	DWORD PTR [ebx+8], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 391  :           lines32[n] = allocator->alloc32(0,subband_cols+(int)alignment_offset)

	movzx	eax, BYTE PTR [esi+22]
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [esi+92]
	mov	DWORD PTR [eax+edx*4], ecx
	inc	edx
	movsx	eax, WORD PTR [esi+68]
	mov	DWORD PTR _n$2$[ebp], edx
	cmp	edx, eax
	jl	SHORT $LL7@push
$LN97@push:
	mov	ebx, DWORD PTR _env$[ebp]
$LN6@push:

; 392  :                      + alignment_offset;
; 393  :       if (roi_lines != NULL)

	cmp	DWORD PTR [esi+96], 0
	je	SHORT $LN9@push

; 394  :         for (n=0; n < buffer_height; n++)

	xor	eax, eax
	cmp	ax, WORD PTR [esi+68]
	jge	SHORT $LN9@push
	xor	ebx, ebx
$LL10@push:

; 395  :           roi_lines[n] = (kdu_byte *)

	mov	eax, DWORD PTR [esi+56]
	mov	edi, DWORD PTR [esi+80]
	inc	eax
	sar	eax, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.

	add	eax, 7
	and	eax, -8					; fffffff8H

; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi+16]
	add	edx, ecx
	lea	eax, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR [edi+8], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 395  :           roi_lines[n] = (kdu_byte *)

	mov	eax, DWORD PTR [esi+96]
	mov	DWORD PTR [eax+ebx*4], edx
	inc	ebx
	movsx	eax, WORD PTR [esi+68]
	cmp	ebx, eax
	jl	SHORT $LL10@push
	mov	ebx, DWORD PTR _env$[ebp]
$LN9@push:

; 396  :             allocator->alloc16(0,(subband_cols+1)>>1);
; 397  :       initialized = true;

	mov	BYTE PTR [esi+21], 1

; 398  :       if (env != NULL)

	test	ebx, ebx
	je	SHORT $LN94@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [ebx+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+28], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN94@push
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN94@push:
	mov	edi, DWORD PTR _line$[ebp]
$LN57@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 404  :   if (next_free_line == free_line_lim)

	movzx	ecx, WORD PTR [esi+70]
	cmp	cx, WORD PTR [esi+72]
	jne	SHORT $LN23@push

; 405  :     { // This condition can only occur when operating in multi-threaded mode.
; 406  :       // It means we need to wait for some existing block encoding jobs to
; 407  :       // complete, adding ourself to the list of processors to help this
; 408  :       // happen as quickly as possible.
; 409  :       assert(queue != NULL);
; 410  :       env->process_jobs(queue); // Waits only for primary jobs; secondary

	push	1
	push	0
	push	DWORD PTR [esi+100]
	mov	ecx, ebx
	call	?process_jobs@kdu_thread_entity@@QAE_NPAUkdu_thread_queue@@_N1@Z ; kdu_thread_entity::process_jobs

; 411  :                 // jobs (produced by double buffering) may remain on the queue.
; 412  :       if ((free_line_lim > nominal_block_height) ||

	movzx	edx, WORD PTR [esi+66]
	cmp	WORD PTR [esi+72], dx
	jg	SHORT $LN21@push
	cmp	WORD PTR [esi+68], dx
	jle	SHORT $LN21@push

; 415  :       else
; 416  :         next_free_line = nominal_block_height; // Use high memory bank

	mov	WORD PTR [esi+70], dx
	jmp	SHORT $LN20@push
$LN21@push:

; 413  :           (buffer_height <= nominal_block_height))
; 414  :         next_free_line = 0; // Use low memory bank

	xor	eax, eax
	mov	WORD PTR [esi+70], ax
$LN20@push:

; 417  :       if (subband_rows < (int) nominal_block_height)
; 418  :         free_line_lim = next_free_line + (kdu_int16) subband_rows;

	movzx	ecx, WORD PTR [esi+70]
	movsx	eax, dx
	cmp	DWORD PTR [esi+52], eax
	jge	SHORT $LN22@push
	mov	ax, WORD PTR [esi+52]
	add	ax, cx

; 419  :       else

	jmp	SHORT $LN98@push
$LN22@push:

; 420  :         free_line_lim = next_free_line + nominal_block_height;

	lea	eax, DWORD PTR [edx+ecx]
$LN98@push:
	mov	WORD PTR [esi+72], ax
$LN23@push:

; 421  :       assert(free_line_lim <= buffer_height);
; 422  :     }
; 423  : 
; 424  :   // Transfer data
; 425  :   assert(line.get_width() == subband_cols);
; 426  :   if (lines32 != NULL)

	mov	eax, DWORD PTR [esi+92]
	test	eax, eax
	je	SHORT $LN24@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edi+6], 2
	je	SHORT $LN61@push
	xor	edx, edx
	jmp	SHORT $LN62@push
$LN61@push:
	mov	edx, DWORD PTR [edi+8]
$LN62@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 427  :     memcpy(lines32[next_free_line],line.get_buf32(),

	mov	eax, DWORD PTR [esi+56]
	shl	eax, 2
	push	eax
	movsx	eax, cx
	mov	ecx, DWORD PTR [esi+92]
	push	edx
	push	DWORD PTR [ecx+eax*4]

; 428  :            (size_t)(subband_cols<<2));
; 429  :   else

	jmp	SHORT $LN99@push
$LN24@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [edi+6], 2
	je	SHORT $LN65@push
	mov	edx, DWORD PTR [edi+8]
	jmp	SHORT $LN66@push
$LN65@push:
	xor	edx, edx
$LN66@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 430  :     memcpy(lines16[next_free_line],line.get_buf16(),

	mov	eax, DWORD PTR [esi+56]
	add	eax, eax
	movsx	ecx, cx
	push	eax
	mov	eax, DWORD PTR [esi+88]
	push	edx
	push	DWORD PTR [eax+ecx*4]
$LN99@push:
	call	_memcpy
	add	esp, 12					; 0000000cH

; 431  :            (size_t)(subband_cols<<1));
; 432  :   if (roi_node != NULL)

	cmp	DWORD PTR [esi+84], 0
	je	SHORT $LN78@push

; 433  :     {
; 434  :       if (env != NULL)

	test	ebx, ebx
	je	SHORT $LN69@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [ebx+28]
	cmp	BYTE PTR [eax], 0
	jne	$LN104@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN72@push
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN72@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+36], ebx
$LN69@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 436  :       roi_node->pull(roi_lines[next_free_line],subband_cols);

	mov	ecx, DWORD PTR [esi+84]
	movsx	edx, WORD PTR [esi+70]
	mov	eax, DWORD PTR [esi+96]
	push	DWORD PTR [esi+56]
	mov	edi, DWORD PTR [ecx]
	push	DWORD PTR [eax+edx*4]
	call	DWORD PTR [edi+8]

; 437  :       if (env != NULL)

	test	ebx, ebx
	je	SHORT $LN78@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [ebx+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+36], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+32]
	test	eax, eax
	je	SHORT $LN78@push
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN78@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 443  :   next_free_line++;

	inc	WORD PTR [esi+70]
	mov	ax, WORD PTR [esi+70]
	dec	DWORD PTR [esi+52]

; 444  :   if (next_free_line == free_line_lim)

	cmp	ax, WORD PTR [esi+72]
	jne	SHORT $LN95@push

; 445  :     { // We have completely generated a row of blocks; either encode the
; 446  :       // row immediately, or queue up block encoding jobs to do it in the
; 447  :       // background.
; 448  :       if (queue != NULL)

	mov	ecx, DWORD PTR [esi+100]
	test	ecx, ecx
	je	SHORT $LN30@push

; 449  :         {
; 450  :           env->add_jobs(queue,num_jobs_per_row,(subband_rows==0),secondary_seq);

	movzx	eax, WORD PTR [esi+60]
	cmp	DWORD PTR [esi+52], 0
	push	eax
	sete	al
	movzx	eax, al
	push	eax
	movzx	eax, BYTE PTR [esi+23]
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?add_jobs@kdu_thread_entity@@QAEXPAUkdu_thread_queue@@H_NI@Z ; kdu_thread_entity::add_jobs

; 451  :                   // Note: in the double buffered case, new jobs are pushed
; 452  :                   // onto the queue in the "secondary" service state.  Jobs
; 453  :                   // from the previous memory bank which have still not been
; 454  :                   // processed will automatically be elevated to the "primary"
; 455  :                   // service state by this call.
; 456  :           if ((secondary_seq != 0) && (push_block_row == 0))

	cmp	WORD PTR [esi+60], 0
	je	SHORT $LN95@push
	cmp	DWORD PTR [esi+76], 0
	jne	SHORT $LN95@push

; 457  :             { // Special processing for first row of blocks; memory bank 1 is
; 458  :               // still free to push in more rows.
; 459  :               assert(free_line_lim <= nominal_block_height);
; 460  :               next_free_line = nominal_block_height;

	mov	ax, WORD PTR [esi+66]

; 461  :             }
; 462  :           else
; 463  :             return; // This shortcut does not update `push_block_row', but we
; 464  :                     // don't need it in this case.
; 465  :         }
; 466  :       else

	jmp	SHORT $LN100@push
$LN30@push:

; 467  :         {
; 468  :           assert(num_jobs_per_row == 1);
; 469  :           do_job(env,push_block_row);

	push	DWORD PTR [esi+76]
	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [esi+4]
	push	ebx
	call	DWORD PTR [eax+4]

; 470  :           next_free_line = 0; // Memory bank 0 is now free for use.

	xor	eax, eax
$LN100@push:

; 471  :         }
; 472  :       push_block_row++;
; 473  :       if (subband_rows < (int) nominal_block_height)

	movzx	ecx, WORD PTR [esi+66]
	inc	DWORD PTR [esi+76]
	mov	WORD PTR [esi+70], ax
	movsx	eax, cx
	cmp	DWORD PTR [esi+52], eax
	jge	SHORT $LN34@push

; 474  :         free_line_lim = next_free_line + (kdu_int16) subband_rows;

	mov	ax, WORD PTR [esi+52]
	add	ax, WORD PTR [esi+70]
	pop	ebx
	pop	edi

; 475  :       else
; 476  :         free_line_lim = next_free_line + nominal_block_height;

	mov	WORD PTR [esi+72], ax
	pop	esi

; 479  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN34@push:

; 475  :       else
; 476  :         free_line_lim = next_free_line + nominal_block_height;

	mov	ax, WORD PTR [esi+70]
	add	ax, cx
	mov	WORD PTR [esi+72], ax
$LN95@push:
	pop	ebx
$LN35@push:
	pop	edi
	pop	esi

; 479  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN102@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN105@push:
$LN104@push:
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN106@push:
$LN96@push:
	int	3
?push@kd_encoder@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z ENDP ; kd_encoder::push
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
;	COMDAT ??1kd_encoder@@MAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_encoder@@MAE@XZ PROC				; kd_encoder::~kd_encoder, COMDAT
; _this$ = ecx

; 358  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_encoder@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 359  :   if (lines16 != NULL)

	mov	eax, DWORD PTR [esi+88]
	mov	DWORD PTR [esi], OFFSET ??_7kd_encoder@@6Bkdu_push_ifc_base@@@
	mov	DWORD PTR [esi+4], OFFSET ??_7kd_encoder@@6Bkdu_worker@@@
	test	eax, eax
	je	SHORT $LN2@kd_encoder

; 360  :     delete[] lines16;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_encoder:

; 361  :   if (lines32 != NULL)

	mov	eax, DWORD PTR [esi+92]
	test	eax, eax
	je	SHORT $LN3@kd_encoder

; 362  :     delete[] lines32;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@kd_encoder:

; 363  :   if (roi_lines != NULL)

	mov	eax, DWORD PTR [esi+96]
	test	eax, eax
	je	SHORT $LN4@kd_encoder

; 364  :     delete[] roi_lines;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN4@kd_encoder:

; 365  :   if (roi_node != NULL)

	mov	ecx, DWORD PTR [esi+84]
	test	ecx, ecx
	je	SHORT $LN5@kd_encoder

; 366  :     roi_node->release();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN5@kd_encoder:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h

; 96   :     ~kdu_block_encoder() { delete state; }

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN18@kd_encoder
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN18@kd_encoder:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 572  :     virtual ~kdu_push_ifc_base() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_push_ifc_base@@6B@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 106  :     virtual ~kdu_worker() { return; } // Prevent compiler warnings

	mov	DWORD PTR [esi+4], OFFSET ??_7kdu_worker@@6B@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 367  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kd_encoder@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_encoder@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_encoder@@MAE@XZ ENDP				; kd_encoder::~kd_encoder
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
;	COMDAT ?init@kd_encoder@@QAEXVkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
_TEXT	SEGMENT
_dims$ = -32						; size = 16
_nominal_block_size$ = -16				; size = 8
_first_block_size$ = -8					; size = 8
_band$ = 8						; size = 4
_allocator$ = 12					; size = 4
_use_shorts$ = 16					; size = 1
_block_row_samples$3$ = 20				; size = 4
$T1 = 20						; size = 4
_normalization$ = 20					; size = 4
_roi$ = 24						; size = 4
_have_roi_weight$1$ = 27				; size = 1
_env$ = 28						; size = 4
_env_queue$ = 32					; size = 4
?init@kd_encoder@@QAEXVkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z PROC ; kd_encoder::init, COMDAT
; _this$ = ecx

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 249  :   assert((this->allocator == NULL) && (this->queue == NULL));
; 250  :   this->band = band;

	mov	eax, DWORD PTR _band$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 251  :   this->roi_node = roi;
; 252  :   
; 253  :   K_max = (kdu_int16) band.get_K_max();

	lea	ecx, DWORD PTR _band$[ebp]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR _roi$[ebp]
	mov	DWORD PTR [edi+84], eax
	call	?get_K_max@kdu_subband@@QAEHXZ		; kdu_subband::get_K_max

; 254  :   K_max_prime = (kdu_int16) band.get_K_max_prime();

	lea	ecx, DWORD PTR _band$[ebp]
	mov	WORD PTR [edi+16], ax
	call	?get_K_max_prime@kdu_subband@@QAEHXZ	; kdu_subband::get_K_max_prime

; 255  :   reversible = band.get_reversible();

	lea	ecx, DWORD PTR _band$[ebp]
	mov	WORD PTR [edi+18], ax
	call	?get_reversible@kdu_subband@@QAE_NXZ	; kdu_subband::get_reversible

; 256  :   initialized = false;
; 257  :   delta = band.get_delta() * normalization;

	lea	ecx, DWORD PTR _band$[ebp]
	mov	BYTE PTR [edi+20], al
	mov	BYTE PTR [edi+21], 0
	call	?get_delta@kdu_subband@@QAEMXZ		; kdu_subband::get_delta
	fmul	DWORD PTR _normalization$[ebp]

; 258  :   msb_wmse = band.get_msb_wmse();

	lea	ecx, DWORD PTR _band$[ebp]
	fstp	DWORD PTR [edi+24]
	call	?get_msb_wmse@kdu_subband@@QAEMXZ	; kdu_subband::get_msb_wmse

; 259  :   roi_weight = 1.0F;

	lea	eax, DWORD PTR [edi+32]

; 260  :   bool have_roi_weight = band.get_roi_weight(roi_weight);

	lea	ecx, DWORD PTR _band$[ebp]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H
	push	eax
	fstp	DWORD PTR [edi+28]
	call	?get_roi_weight@kdu_subband@@QAE_NAAM@Z	; kdu_subband::get_roi_weight
	mov	BYTE PTR _have_roi_weight$1$[ebp], al

; 261  : 
; 262  :   kdu_dims dims;
; 263  :   band.get_dims(dims);

	lea	ecx, DWORD PTR _band$[ebp]
	lea	eax, DWORD PTR _dims$[ebp]
	xorps	xmm0, xmm0
	push	eax
	movups	XMMWORD PTR _dims$[ebp], xmm0
	call	?get_dims@kdu_subband@@QAEXAAUkdu_dims@@@Z ; kdu_subband::get_dims

; 265  :   band.get_block_size(nominal_block_size,first_block_size);

	lea	eax, DWORD PTR _first_block_size$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _nominal_block_size$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 265  :   band.get_block_size(nominal_block_size,first_block_size);

	push	eax
	lea	eax, DWORD PTR _nominal_block_size$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _nominal_block_size$[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 265  :   band.get_block_size(nominal_block_size,first_block_size);

	push	eax
	lea	ecx, DWORD PTR _band$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _first_block_size$[ebp], 0
	mov	DWORD PTR _first_block_size$[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 265  :   band.get_block_size(nominal_block_size,first_block_size);

	call	?get_block_size@kdu_subband@@QAEXAAUkdu_coords@@0@Z ; kdu_subband::get_block_size

; 266  :   band.get_valid_blocks(block_indices);

	lea	eax, DWORD PTR [edi+36]
	push	eax
	lea	ecx, DWORD PTR _band$[ebp]
	call	?get_valid_blocks@kdu_subband@@QAEXAAUkdu_dims@@@Z ; kdu_subband::get_valid_blocks

; 267  : 
; 268  :   subband_cols = dims.size.x;
; 269  :   subband_rows = dims.size.y;
; 270  :   first_block_width = (kdu_int16) first_block_size.x;

	movzx	eax, WORD PTR _first_block_size$[ebp+4]

; 271  :   nominal_block_width = (kdu_int16) nominal_block_size.x;
; 272  :   nominal_block_height = (kdu_int16) nominal_block_size.y;
; 273  : 
; 274  :   if ((env != NULL) && (subband_cols > 0) && (subband_rows > 0))

	mov	esi, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR _dims$[ebp+12]
	mov	edx, DWORD PTR _dims$[ebp+8]
	mov	WORD PTR [edi+62], ax
	movzx	eax, WORD PTR _nominal_block_size$[ebp+4]
	mov	WORD PTR [edi+64], ax
	movzx	eax, WORD PTR _nominal_block_size$[ebp]
	mov	DWORD PTR [edi+56], ecx
	mov	DWORD PTR [edi+52], edx
	mov	WORD PTR [edi+66], ax
	test	esi, esi
	je	SHORT $LN2@init
	test	ecx, ecx
	jle	SHORT $LN2@init
	test	edx, edx
	jle	SHORT $LN2@init

; 275  :     queue = env->add_queue(this,env_queue,"block encoder");

	push	0
	push	0
	push	OFFSET ??_C@_0O@NOGJKGJJ@block?5encoder?$AA@
	push	DWORD PTR _env_queue$[ebp]
	lea	eax, DWORD PTR [edi+4]
	mov	ecx, esi
	push	eax
	call	?add_queue@kdu_thread_entity@@QAEPAUkdu_thread_queue@@PAVkdu_worker@@PAU2@PBD_J@Z ; kdu_thread_entity::add_queue
	mov	DWORD PTR [edi+100], eax
$LN2@init:

; 276  : 
; 277  :   // Determine how to partition a row of code-blocks into encoding jobs
; 278  :   num_jobs_per_row = 1;
; 279  :   if ((queue != NULL) && (env->get_num_threads() > 1))

	cmp	DWORD PTR [edi+100], 0
	mov	BYTE PTR [edi+23], 1
	je	SHORT $LN47@init
	mov	ecx, esi
	call	?get_num_threads@kdu_thread_entity@@QAEHXZ ; kdu_thread_entity::get_num_threads
	cmp	eax, 1
	jle	SHORT $LN47@init

; 280  :     { // See if we should split up the code-blocks on a row
; 281  :       kdu_long block_row_samples = subband_cols;

	mov	eax, DWORD PTR [edi+56]

; 282  :       if (subband_rows < (int) nominal_block_height)

	mov	ecx, DWORD PTR [edi+52]
	cdq
	mov	ebx, eax
	mov	DWORD PTR _block_row_samples$3$[ebp], edx
	movsx	eax, WORD PTR [edi+66]

; 283  :         block_row_samples *= subband_rows;

	push	edx
	push	ebx
	cmp	ecx, eax
	jge	SHORT $LN4@init
	mov	eax, ecx
$LN4@init:

; 284  :       else
; 285  :         block_row_samples *= nominal_block_height;

	cdq
	push	edx
	push	eax
	call	__allmul

; 286  :       int num_per_row = (int)(block_row_samples / 8192);

	push	0
	push	8192					; 00002000H
	push	edx
	push	eax
	call	__alldiv

; 287  :       assert(num_per_row <= block_indices.size.x);
; 288  :       if (num_per_row > 32)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN6@init

; 289  :         num_per_row = 32;

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN8@init
$LN6@init:

; 290  :       else if (num_per_row < 1)

	mov	ecx, 1
	cmp	eax, ecx
	cmovl	eax, ecx
$LN8@init:

; 291  :         num_per_row = 1;
; 292  :       num_jobs_per_row = (kdu_byte) num_per_row;

	mov	BYTE PTR [edi+23], al
$LN47@init:

; 293  :     }
; 294  : 
; 295  :   // Determine whether or not to use double buffering, and hence buffer height
; 296  :   secondary_seq = 0; // Changed further down if we settle on double buffering

	xor	eax, eax
	mov	WORD PTR [edi+60], ax

; 297  :   buffer_height = nominal_block_height;

	movzx	eax, WORD PTR [edi+66]
	mov	WORD PTR [edi+68], ax

; 298  :   if (subband_rows <= (int) buffer_height)

	cwde
	cmp	DWORD PTR [edi+52], eax
	jg	SHORT $LN9@init

; 299  :     buffer_height = (kdu_int16) subband_rows;

	mov	ax, WORD PTR [edi+52]
	mov	WORD PTR [edi+68], ax
	jmp	SHORT $LN48@init
$LN9@init:

; 300  :   else if ((queue != NULL) && (env->get_num_threads() > 1))

	cmp	DWORD PTR [edi+100], 0
	je	SHORT $LN48@init
	mov	ecx, esi
	call	?get_num_threads@kdu_thread_entity@@QAEHXZ ; kdu_thread_entity::get_num_threads
	cmp	eax, 1
	jle	SHORT $LN48@init

; 301  :     { // We might want to use double buffering in this case.
; 302  :       int ideal_double_buffered_bands = // ceil(9/num_jobs_per_row)
; 303  :                                         1 + (8/ num_jobs_per_row);      

	movzx	ecx, BYTE PTR [edi+23]
	mov	eax, 8
	cdq
	idiv	ecx

; 304  :       if (band.get_band_idx() <= ideal_double_buffered_bands)

	lea	ecx, DWORD PTR _band$[ebp]
	lea	esi, DWORD PTR [eax+1]
	call	?get_band_idx@kdu_subband@@QAEHXZ	; kdu_subband::get_band_idx
	cmp	eax, esi
	jg	SHORT $LN48@init

; 305  :         { // Decided to use double buffering for this subband.  Note that,
; 306  :           // except for the LL subband, band indices start at 1.
; 307  :           if ((subband_rows-first_block_size.y) < (int) nominal_block_height)

	movzx	edx, WORD PTR [edi+66]
	mov	ecx, DWORD PTR [edi+52]
	mov	esi, DWORD PTR _first_block_size$[ebp]
	sub	ecx, esi
	movsx	eax, dx
	cmp	ecx, eax
	jge	SHORT $LN13@init

; 308  :             buffer_height += (kdu_int16)(subband_rows-first_block_size.y);

	mov	ax, WORD PTR [edi+52]
	sub	ax, si
	add	WORD PTR [edi+68], ax

; 309  :           else

	jmp	SHORT $LN14@init
$LN13@init:

; 310  :             buffer_height += nominal_block_height;

	add	WORD PTR [edi+68], dx
$LN14@init:

; 311  :           secondary_seq = (kdu_uint16)

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _band$[ebp]
	call	?access_resolution@kdu_subband@@QAE?AVkdu_resolution@@XZ ; kdu_subband::access_resolution
	mov	ecx, eax
	call	?get_dwt_level@kdu_resolution@@QAEHXZ	; kdu_resolution::get_dwt_level
	mov	ecx, 64					; 00000040H
	sub	ecx, eax
	mov	WORD PTR [edi+60], cx
$LN48@init:

; 312  :             (64 - band.access_resolution().get_dwt_level());
; 313  :         }
; 314  :     }
; 315  : 
; 316  :   // Set up counters
; 317  :   next_free_line = 0;
; 318  :   free_line_lim = (kdu_int16) first_block_size.y;
; 319  :   push_block_row = 0;
; 320  : 
; 321  :   // Establish buffer configuration
; 322  :   alignment_offset = 0;
; 323  :   if (first_block_size.x < subband_cols)

	mov	edx, DWORD PTR [edi+56]
	xor	eax, eax
	mov	cl, BYTE PTR _use_shorts$[ebp]
	mov	WORD PTR [edi+70], ax
	mov	ax, WORD PTR _first_block_size$[ebp]
	mov	WORD PTR [edi+72], ax
	mov	eax, DWORD PTR _first_block_size$[ebp+4]
	mov	DWORD PTR [edi+76], 0
	mov	BYTE PTR [edi+22], 0
	cmp	eax, edx
	jge	SHORT $LN15@init

; 324  :     alignment_offset = (kdu_byte)

	test	cl, cl
	je	SHORT $LN24@init
	neg	eax
	and	eax, 7
	jmp	SHORT $LN25@init
$LN24@init:
	mov	eax, DWORD PTR _first_block_size$[ebp+4]
	neg	eax
	and	eax, 3
$LN25@init:
	mov	BYTE PTR [edi+22], al
$LN15@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR _dims$[ebp+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 327  :   lines16 = NULL;

	mov	DWORD PTR [edi+88], 0

; 328  :   lines32 = NULL;

	mov	DWORD PTR [edi+92], 0

; 329  :   roi_lines = NULL;

	mov	DWORD PTR [edi+96], 0

; 330  :   this->allocator = NULL;

	mov	DWORD PTR [edi+80], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	jle	$LN38@init
	cmp	DWORD PTR _dims$[ebp+8], 0
	jle	$LN38@init
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 333  :   this->allocator = allocator;

	movzx	eax, BYTE PTR [edi+22]
	mov	esi, DWORD PTR _allocator$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 179  :         before+=before; after+=after; // Two bytes per sample

	add	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 334  :   allocator->pre_alloc(use_shorts,0,subband_cols + (int) alignment_offset,

	movsx	ebx, WORD PTR [edi+68]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 179  :         before+=before; after+=after; // Two bytes per sample

	add	eax, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 333  :   this->allocator = allocator;

	mov	DWORD PTR [edi+80], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 180  :         if (!use_shorts)

	test	cl, cl
	jne	SHORT $LN41@init

; 181  :           { before+=before; after+=after; } // Four bytes per sample

	add	eax, eax
$LN41@init:

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	eax, 15					; 0000000fH
	and	eax, -16				; fffffff0H
	imul	eax, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 337  :     lines16 = new kdu_sample16 *[buffer_height];

	mov	ebx, 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	DWORD PTR [esi+4], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 337  :     lines16 = new kdu_sample16 *[buffer_height];

	movsx	eax, WORD PTR [edi+68]
	test	cl, cl
	je	SHORT $LN17@init
	xor	ecx, ecx
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+88], eax

; 338  :   else

	jmp	SHORT $LN49@init
$LN17@init:

; 339  :     lines32 = new kdu_sample32 *[buffer_height];

	xor	ecx, ecx
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+92], eax
$LN49@init:

; 340  :   if (roi_node != NULL)

	mov	ecx, DWORD PTR [edi+84]
	add	esp, 4
	test	ecx, ecx
	je	SHORT $LN19@init

; 341  :     {
; 342  :       if ((K_max_prime == K_max) && !have_roi_weight)

	mov	ax, WORD PTR [edi+18]
	cmp	ax, WORD PTR [edi+16]
	jne	SHORT $LN20@init
	cmp	BYTE PTR _have_roi_weight$1$[ebp], 0
	jne	SHORT $LN20@init

; 343  :         {
; 344  :           roi_node->release();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]

; 345  :           roi_node = NULL;

	mov	DWORD PTR [edi+84], 0
	pop	edi
	pop	esi
	pop	ebx

; 350  :     }
; 351  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN20@init:

; 346  :           return;
; 347  :         }
; 348  :       allocator->pre_alloc(true,0,(subband_cols+1)>>1,buffer_height);

	mov	eax, DWORD PTR [edi+56]
	movsx	ecx, WORD PTR [edi+68]
	inc	eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 179  :         before+=before; after+=after; // Two bytes per sample

	and	eax, -2					; fffffffeH

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	eax, 15					; 0000000fH
	and	eax, -16				; fffffff0H
	imul	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 349  :       roi_lines = new kdu_byte *[buffer_height];

	xor	ecx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	DWORD PTR [esi+4], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 349  :       roi_lines = new kdu_byte *[buffer_height];

	movsx	eax, WORD PTR [edi+68]
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [edi+96], eax
	pop	edi
	pop	esi
	pop	ebx

; 350  :     }
; 351  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN38@init:

; 331  :   if (!dims)
; 332  :     { subband_rows = 0; return; }

	mov	DWORD PTR [edi+52], 0
$LN19@init:
	pop	edi
	pop	esi
	pop	ebx

; 350  :     }
; 351  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?init@kd_encoder@@QAEXVkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ENDP ; kd_encoder::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
;	COMDAT ??0kd_encoder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0kd_encoder@@QAE@XZ PROC				; kd_encoder::kd_encoder, COMDAT
; _this$ = ecx

; 111  :     kd_encoder()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0kd_encoder@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 112  :       { allocator=NULL; initialized=false; roi_node=NULL; queue=NULL;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi+4], OFFSET ??_7kdu_worker@@6B@
	lea	ecx, DWORD PTR [esi+8]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR [esi], OFFSET ??_7kd_encoder@@6Bkdu_push_ifc_base@@@
	mov	DWORD PTR [esi+4], OFFSET ??_7kd_encoder@@6Bkdu_worker@@@
	call	??0kdu_block_encoder@@QAE@XZ		; kdu_block_encoder::kdu_block_encoder
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 5274 :     kdu_subband() { state = NULL; }

	mov	DWORD PTR [esi+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 113  :         lines16=NULL; lines32=NULL; roi_lines=NULL; }

	mov	eax, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 112  :       { allocator=NULL; initialized=false; roi_node=NULL; queue=NULL;

	mov	DWORD PTR [esi+80], 0
	mov	BYTE PTR [esi+21], 0
	mov	DWORD PTR [esi+84], 0
	mov	DWORD PTR [esi+100], 0

; 113  :         lines16=NULL; lines32=NULL; roi_lines=NULL; }

	mov	DWORD PTR [esi+88], 0
	mov	DWORD PTR [esi+92], 0
	mov	DWORD PTR [esi+96], 0
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0kd_encoder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_push_ifc_base@@MAE@XZ		; kdu_push_ifc_base::~kdu_push_ifc_base
__unwindfunclet$??0kd_encoder@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1kdu_worker@@UAE@XZ			; kdu_worker::~kdu_worker
__ehhandler$??0kd_encoder@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0kd_encoder@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0kd_encoder@@QAE@XZ ENDP				; kd_encoder::kd_encoder
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
;	COMDAT ?encode@kdu_block_encoder@@QAEXPAUkdu_block@@_NNG@Z
_TEXT	SEGMENT
_block$ = 8						; size = 4
_reversible$ = 12					; size = 1
_msb_wmse$ = 16						; size = 8
_estimated_slope_threshold$ = 24			; size = 2
?encode@kdu_block_encoder@@QAEXPAUkdu_block@@_NNG@Z PROC ; kdu_block_encoder::encode, COMDAT
; _this$ = ecx

; 99   :       {

	push	ebp
	mov	ebp, esp

; 100  :       /* [SYNOPSIS]
; 101  :            Encodes a single block of samples.
; 102  :            [//]
; 103  :            On entry, `block->num_passes' indicates the number of coding
; 104  :            passes which are to be processed and `block->missing_msbs' the
; 105  :            number of most significant bit-planes which are known to be zero.
; 106  :            The function should process all coding passes, unless this
; 107  :            is not possible given the available implementation precision, or
; 108  :            a non-zero `estimated_slope_threshold' argument allows it to
; 109  :            determine that some passes can be skipped (see below).
; 110  :            [//]
; 111  :            The samples must be in the `block->samples' buffer, organized
; 112  :            in raster scan order.  The sample values themselves are expected
; 113  :            to have a sign-magnitude representation, with the most significant
; 114  :            magnitude bit-plane appearing in bit position 30 and the sign
; 115  :            (1 for -ve) in bit position 31.
; 116  :            [//]
; 117  :            On exit, the `block->byte_buffer' and `block->pass_lengths'
; 118  :            arrays should be filled out, although note that the `num_passes'
; 119  :            value may have been reduced, if the function was able to determine
; 120  :            that some passes would almost certainly be discarded during rate
; 121  :            allocation later on (only if `estimated_slope_threshold' != 0).
; 122  :          [ARG: reversible]
; 123  :            Irrelevant unless distortion-length slopes are to be estimated
; 124  :            (i.e., `msb_wmse' is non-zero).  Whether the subband sample indices
; 125  :            represent reversibly transformed image data or irreversibly
; 126  :            transformed and quantized image data has a subtle impact on the
; 127  :            generation of rate-distortion information.
; 128  :          [ARG: msb_wmse]
; 129  :            If non-zero, the block processor is expected to generate
; 130  :            distortion-length slope information and perform a convex
; 131  :            hull analysis, writing the results to the `block->pass_slopes'
; 132  :            array.  Otherwise, the `block->pass_slopes' array's contents will
; 133  :            not be touched -- no assumption is made concerning their contents.
; 134  :          [ARG: estimated_slope_threshold]
; 135  :            A non-zero value indicates an expected lower bound on the
; 136  :            distortion-length slope threshold which is likely to be selected by
; 137  :            the PCRD-opt rate control algorithm (the logarithmic representation
; 138  :            is identical to that associated with the `block->pass_slopes'
; 139  :            array).  This enables some coding passes which are highly unlikely
; 140  :            to be included in the final compressed representation to be skipped,
; 141  :            thereby saving processing time.  The capability is available only
; 142  :            if `msb_wmse' is also non-zero, meaning that distortion-length
; 143  :            slope values are to be estimated.
; 144  :         */
; 145  :         state->encode(block,reversible,msb_wmse,estimated_slope_threshold);

	push	DWORD PTR _estimated_slope_threshold$[ebp]
	mov	ecx, DWORD PTR [ecx]
	movsd	xmm0, QWORD PTR _msb_wmse$[ebp]
	sub	esp, 8
	mov	eax, DWORD PTR [ecx]
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR _reversible$[ebp]
	push	DWORD PTR _block$[ebp]
	call	DWORD PTR [eax+4]

; 146  :       }

	pop	ebp
	ret	20					; 00000014H
?encode@kdu_block_encoder@@QAEXPAUkdu_block@@_NNG@Z ENDP ; kdu_block_encoder::encode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
;	COMDAT ??1kdu_block_encoder@@QAE@XZ
_TEXT	SEGMENT
??1kdu_block_encoder@@QAE@XZ PROC			; kdu_block_encoder::~kdu_block_encoder, COMDAT
; _this$ = ecx

; 96   :     ~kdu_block_encoder() { delete state; }

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN3@kdu_block_
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN3@kdu_block_:
	ret	0
??1kdu_block_encoder@@QAE@XZ ENDP			; kdu_block_encoder::~kdu_block_encoder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
;	COMDAT ??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_band$ = 8						; size = 4
_allocator$ = 12					; size = 4
_use_shorts$ = 16					; size = 1
_normalization$ = 20					; size = 4
_roi$ = 24						; size = 4
_env$ = 28						; size = 4
_env_queue$ = 32					; size = 4
??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z PROC ; kdu_encoder::kdu_encoder, COMDAT
; _this$ = ecx

; 229  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 230  :   kd_encoder *enc = new kd_encoder;

	push	104					; 00000068H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 598  :     kdu_push_ifc() { state = NULL; }

	mov	DWORD PTR [esi], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp

; 230  :   kd_encoder *enc = new kd_encoder;

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@kdu_encode
	mov	ecx, eax
	call	??0kd_encoder@@QAE@XZ			; kd_encoder::kd_encoder
	jmp	SHORT $LN4@kdu_encode
$LN3@kdu_encode:
	xor	eax, eax
$LN4@kdu_encode:

; 231  :   state = enc;
; 232  :   enc->init(band,allocator,use_shorts,normalization,roi,env,env_queue);

	push	DWORD PTR _env_queue$[ebp]
	movss	xmm0, DWORD PTR _normalization$[ebp]
	push	DWORD PTR _env$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	DWORD PTR _roi$[ebp]
	mov	DWORD PTR [esi], eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, eax
	push	DWORD PTR _use_shorts$[ebp]
	push	DWORD PTR _allocator$[ebp]
	push	DWORD PTR _band$[ebp]
	call	?init@kd_encoder@@QAEXVkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kd_encoder::init

; 233  : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z$0:
	push	104					; 00000068H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ENDP ; kdu_encoder::kdu_encoder
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??0kdu_push_ifc@@QAE@XZ
_TEXT	SEGMENT
??0kdu_push_ifc@@QAE@XZ PROC				; kdu_push_ifc::kdu_push_ifc, COMDAT
; _this$ = ecx

; 598  :     kdu_push_ifc() { state = NULL; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0kdu_push_ifc@@QAE@XZ ENDP				; kdu_push_ifc::kdu_push_ifc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??_Gkdu_push_ifc_base@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkdu_push_ifc_base@@MAEPAXI@Z PROC			; kdu_push_ifc_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 572  :     virtual ~kdu_push_ifc_base() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_push_ifc_base@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkdu_push_ifc_base@@MAEPAXI@Z ENDP			; kdu_push_ifc_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0kdu_push_ifc_base@@QAE@XZ
_TEXT	SEGMENT
??0kdu_push_ifc_base@@QAE@XZ PROC			; kdu_push_ifc_base::kdu_push_ifc_base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kdu_push_ifc_base@@6B@
	mov	eax, ecx
	ret	0
??0kdu_push_ifc_base@@QAE@XZ ENDP			; kdu_push_ifc_base::kdu_push_ifc_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??1kdu_push_ifc_base@@MAE@XZ
_TEXT	SEGMENT
??1kdu_push_ifc_base@@MAE@XZ PROC			; kdu_push_ifc_base::~kdu_push_ifc_base, COMDAT
; _this$ = ecx

; 572  :     virtual ~kdu_push_ifc_base() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_push_ifc_base@@6B@
	ret	0
??1kdu_push_ifc_base@@MAE@XZ ENDP			; kdu_push_ifc_base::~kdu_push_ifc_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_width@kdu_line_buf@@QAEHXZ
_TEXT	SEGMENT
?get_width@kdu_line_buf@@QAEHXZ PROC			; kdu_line_buf::get_width, COMDAT
; _this$ = ecx

; 537  :       /* [SYNOPSIS]
; 538  :            Returns 0 if the object has not been created.  Otherwise, returns
; 539  :            the nominal width of the line.  Remember that the arrays returned
; 540  :            by `get_buf16' and `get_buf32' are typically larger than the actual
; 541  :            line width, as explained in the comments appearing with the
; 542  :            `pre_create' function.
; 543  :       */
; 544  :         return width;

	mov	eax, DWORD PTR [ecx]

; 545  :       }

	ret	0
?get_width@kdu_line_buf@@QAEHXZ ENDP			; kdu_line_buf::get_width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ
_TEXT	SEGMENT
?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ PROC	; kdu_line_buf::get_buf16, COMDAT
; _this$ = ecx

; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN3@get_buf16
	mov	eax, DWORD PTR [ecx+8]

; 414  :       }

	ret	0
$LN3@get_buf16:

; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	xor	eax, eax

; 414  :       }

	ret	0
?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ ENDP	; kdu_line_buf::get_buf16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ
_TEXT	SEGMENT
?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ PROC	; kdu_line_buf::get_buf32, COMDAT
; _this$ = ecx

; 393  :       /* [SYNOPSIS]
; 394  :            Returns NULL if the sample values are of type `kdu_sample16'
; 395  :            instead of `kdu_sample32', or the buffer has not yet been
; 396  :            created.  Otherwise, returns an array which supports accesses
; 397  :            at least with indices in the range 0 to `width'-1, but typically
; 398  :            beyond these bounds -- see `pre_create' for an explanation of
; 399  :            extended access bounds.
; 400  :       */
; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN3@get_buf32
	xor	eax, eax

; 402  :       }

	ret	0
$LN3@get_buf32:

; 393  :       /* [SYNOPSIS]
; 394  :            Returns NULL if the sample values are of type `kdu_sample16'
; 395  :            instead of `kdu_sample32', or the buffer has not yet been
; 396  :            created.  Otherwise, returns an array which supports accesses
; 397  :            at least with indices in the range 0 to `width'-1, but typically
; 398  :            beyond these bounds -- see `pre_create' for an explanation of
; 399  :            extended access bounds.
; 400  :       */
; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	eax, DWORD PTR [ecx+8]

; 402  :       }

	ret	0
?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ ENDP	; kdu_line_buf::get_buf32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z
_TEXT	SEGMENT
_before$ = 8						; size = 4
_after$ = 12						; size = 4
?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z PROC ; kdu_sample_allocator::alloc32, COMDAT
; _this$ = ecx

; 225  :       {

	push	ebp
	mov	ebp, esp
	push	esi

; 226  :       /* [SYNOPSIS]
; 227  :            Same as `alloc16', except that it allocates storage for arrays of
; 228  :            32-bit quantities.  Again, the returned pointer is guaranteed to
; 229  :            be aligned on a 16-byte boundary.
; 230  :       */
; 231  :         assert(!pre_creation_phase);
; 232  :         before = (before+3)&~3; // Round up to nearest multiple of 16 bytes.

	mov	esi, DWORD PTR _before$[ebp]
	push	edi
	mov	edi, ecx
	add	esi, 3

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.

	mov	ecx, DWORD PTR _after$[ebp]
	and	esi, -4					; fffffffcH
	add	ecx, 3
	and	ecx, -4					; fffffffcH

; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+esi*4]
	add	eax, edx
	add	ecx, esi
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [edi+8], ecx
	pop	edi
	pop	esi

; 236  :         assert(bytes_used <= bytes_reserved);
; 237  :         return result;
; 238  :       }

	pop	ebp
	ret	8
?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z ENDP ; kdu_sample_allocator::alloc32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z
_TEXT	SEGMENT
_before$ = 8						; size = 4
_after$ = 12						; size = 4
?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z PROC ; kdu_sample_allocator::alloc16, COMDAT
; _this$ = ecx

; 203  :       {

	push	ebp
	mov	ebp, esp
	push	esi

; 204  :       /* [SYNOPSIS]
; 205  :            Allocate an array with space for `before' entries prior to the
; 206  :            returned pointer and `after' entries after the returned pointer
; 207  :            (including the entry to which the pointer refers).  The returned
; 208  :            pointer is guaranteed to be aligned on a 16-byte boundary.
; 209  :            The pointer may be interpreted as the location of an array which
; 210  :            can accept signed indices, n, in the range -`before' <= n < `after'.
; 211  :            [//]
; 212  :            Before calling this function, you must have pre-allocated sufficient
; 213  :            space through calls to `pre_alloc' and you must have called the
; 214  :            `finalize' member function.
; 215  :       */
; 216  :         assert(!pre_creation_phase);
; 217  :         before = (before+7)&~7; // Round up to nearest multiple of 16 bytes.

	mov	esi, DWORD PTR _before$[ebp]
	push	edi
	mov	edi, ecx
	add	esi, 7

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.

	mov	ecx, DWORD PTR _after$[ebp]
	and	esi, -8					; fffffff8H
	add	ecx, 7
	and	ecx, -8					; fffffff8H

; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+esi*2]
	add	eax, edx
	add	ecx, esi
	lea	ecx, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR [edi+8], ecx
	pop	edi
	pop	esi

; 221  :         assert(bytes_used <= bytes_reserved);
; 222  :         return result;
; 223  :       }

	pop	ebp
	ret	8
?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z ENDP ; kdu_sample_allocator::alloc16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z
_TEXT	SEGMENT
_use_shorts$ = 8					; size = 1
_before$ = 12						; size = 4
_after$ = 16						; size = 4
_num_requests$ = 20					; size = 4
?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z PROC	; kdu_sample_allocator::pre_alloc, COMDAT
; _this$ = ecx

; 168  :       {

	push	ebp
	mov	ebp, esp

; 169  :       /* [SYNOPSIS]
; 170  :            Reserves enough storage for `num_requests' later calls to `alloc16'
; 171  :            (if `use_shorts' is true) or `alloc32' (if `use_shorts' is false).
; 172  :            Space is reserved such that each of these `num_requests' allocations
; 173  :            can return an appropriately aligned pointer to an array which offers
; 174  :            entries at locations n in the range -`before' <= n < `after', where
; 175  :            each entry is of type `kdu_sample16' (if `use_shorts'=true) or
; 176  :            `kdu_sample32' (if `use_shorts'=false).
; 177  :       */
; 178  :         assert(pre_creation_phase);
; 179  :         before+=before; after+=after; // Two bytes per sample

	mov	eax, DWORD PTR _before$[ebp]
	mov	edx, ecx
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _after$[ebp]
	add	eax, eax

; 180  :         if (!use_shorts)

	cmp	BYTE PTR _use_shorts$[ebp], 0
	jne	SHORT $LN2@pre_alloc

; 181  :           { before+=before; after+=after; } // Four bytes per sample

	add	ecx, ecx
	add	eax, eax
$LN2@pre_alloc:

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	ecx, 15					; 0000000fH
	add	eax, 15					; 0000000fH
	and	ecx, -16				; fffffff0H
	and	eax, -16				; fffffff0H
	add	ecx, eax
	imul	ecx, DWORD PTR _num_requests$[ebp]
	add	DWORD PTR [edx+4], ecx

; 183  :       }

	pop	ebp
	ret	16					; 00000010H
?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z ENDP	; kdu_sample_allocator::pre_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_subband@@QAE@XZ
_TEXT	SEGMENT
??0kdu_subband@@QAE@XZ PROC				; kdu_subband::kdu_subband, COMDAT
; _this$ = ecx

; 5274 :     kdu_subband() { state = NULL; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0kdu_subband@@QAE@XZ ENDP				; kdu_subband::kdu_subband
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??7kdu_dims@@QAE_NXZ
_TEXT	SEGMENT
??7kdu_dims@@QAE_NXZ PROC				; kdu_dims::operator!, COMDAT
; _this$ = ecx

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR [ecx+12], 0
	jle	SHORT $LN3@operator
	cmp	DWORD PTR [ecx+8], 0
	jle	SHORT $LN3@operator
	xor	al, al
	ret	0
$LN3@operator:
	mov	al, 1
	ret	0
??7kdu_dims@@QAE_NXZ ENDP				; kdu_dims::operator!
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_dims@@QAE@XZ
_TEXT	SEGMENT
??0kdu_dims@@QAE@XZ PROC				; kdu_dims::kdu_dims, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0

; 304  :     kdu_dims() {};

	mov	eax, ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0

; 304  :     kdu_dims() {};

	ret	0
??0kdu_dims@@QAE@XZ ENDP				; kdu_dims::kdu_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?transpose@kdu_coords@@QAEXXZ
_TEXT	SEGMENT
?transpose@kdu_coords@@QAEXXZ PROC			; kdu_coords::transpose, COMDAT
; _this$ = ecx

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
	ret	0
?transpose@kdu_coords@@QAEXXZ ENDP			; kdu_coords::transpose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_coords@@QAE@XZ
_TEXT	SEGMENT
??0kdu_coords@@QAE@XZ PROC				; kdu_coords::kdu_coords, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kdu_coords@@QAE@XZ ENDP				; kdu_coords::kdu_coords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
??6kdu_message@@QAEAAV0@PBD@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 257  :       { put_text(string); return *this; }

	push	ebp
	mov	ebp, esp
	push	esi
	push	DWORD PTR _string$[ebp]
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@PBD@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?release_lock@kdu_thread_entity@@QAEXH@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
?release_lock@kdu_thread_entity@@QAEXH@Z PROC		; kdu_thread_entity::release_lock, COMDAT
; _this$ = ecx

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _lock_id$[ebp]

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [ecx+eax*8+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN5@release_lo
	mov	DWORD PTR _lock_id$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	jmp	DWORD PTR __imp__ReleaseMutex@4
$LN5@release_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
	ret	4
?release_lock@kdu_thread_entity@@QAEXH@Z ENDP		; kdu_thread_entity::release_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?acquire_lock@kdu_thread_entity@@QAEXH_N@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
$T1 = 12						; size = 4
_allow_exceptions$ = 12					; size = 1
?acquire_lock@kdu_thread_entity@@QAEXH_N@Z PROC		; kdu_thread_entity::acquire_lock, COMDAT
; _this$ = ecx

; 1024 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp

; 1025 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	cmp	BYTE PTR _allow_exceptions$[ebp], 0
	mov	eax, DWORD PTR _lock_id$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edx, DWORD PTR [esi+28]
	lea	edi, DWORD PTR [edx+eax*8]
	je	SHORT $LN2@acquire_lo
	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN9@acquire_lo
$LN2@acquire_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@acquire_lo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN6@acquire_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+4], esi
	pop	edi
	pop	esi
	pop	ebp
	ret	8
$LN9@acquire_lo:

; 1025 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN11@acquire_lo:
$LN8@acquire_lo:
	int	3
?acquire_lock@kdu_thread_entity@@QAEXH_N@Z ENDP		; kdu_thread_entity::acquire_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ??_Gkdu_worker@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkdu_worker@@UAEPAXI@Z PROC				; kdu_worker::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 106  :     virtual ~kdu_worker() { return; } // Prevent compiler warnings

	mov	DWORD PTR [esi], OFFSET ??_7kdu_worker@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkdu_worker@@UAEPAXI@Z ENDP				; kdu_worker::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0kdu_worker@@QAE@XZ
_TEXT	SEGMENT
??0kdu_worker@@QAE@XZ PROC				; kdu_worker::kdu_worker, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kdu_worker@@6B@
	mov	eax, ecx
	ret	0
??0kdu_worker@@QAE@XZ ENDP				; kdu_worker::kdu_worker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ??1kdu_worker@@UAE@XZ
_TEXT	SEGMENT
??1kdu_worker@@UAE@XZ PROC				; kdu_worker::~kdu_worker, COMDAT
; _this$ = ecx

; 106  :     virtual ~kdu_worker() { return; } // Prevent compiler warnings

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_worker@@6B@
	ret	0
??1kdu_worker@@UAE@XZ ENDP				; kdu_worker::~kdu_worker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?unlock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?unlock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::unlock, COMDAT
; _this$ = ecx

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@unlock
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	cmp	eax, 1
	jne	SHORT $LN3@unlock
	mov	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
$LN3@unlock:

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	xor	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
?unlock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?lock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?lock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::lock, COMDAT
; _this$ = ecx

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@lock
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	SHORT $LN3@lock
	mov	al, 1

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
$LN3@lock:

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	xor	al, al

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
?lock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\encoder.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
