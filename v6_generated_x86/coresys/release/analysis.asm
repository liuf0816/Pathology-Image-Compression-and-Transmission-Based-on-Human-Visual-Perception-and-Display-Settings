; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\transform\analysis.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	??0kdu_line_buf@@QAE@XZ				; kdu_line_buf::kdu_line_buf
PUBLIC	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create
PUBLIC	?create@kdu_line_buf@@QAEXXZ			; kdu_line_buf::create
PUBLIC	??1kdu_push_ifc_base@@MAE@XZ			; kdu_push_ifc_base::~kdu_push_ifc_base
PUBLIC	??_Gkdu_push_ifc_base@@MAEPAXI@Z		; kdu_push_ifc_base::`scalar deleting destructor'
PUBLIC	??0kdu_push_ifc@@QAE@XZ				; kdu_push_ifc::kdu_push_ifc
PUBLIC	??0kdu_analysis@@QAE@Vkdu_node@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_analysis::kdu_analysis
PUBLIC	??0kdu_analysis@@QAE@Vkdu_resolution@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_analysis::kdu_analysis
PUBLIC	??0kd_vlift_line@@QAE@XZ			; kd_vlift_line::kd_vlift_line
PUBLIC	?push_line@kd_vlift_queue@@QAEXHPAUkd_vlift_line@@AAPAU2@@Z ; kd_vlift_queue::push_line
PUBLIC	?access_update@kd_vlift_queue@@QAEPAUkd_vlift_line@@HAAPAU2@@Z ; kd_vlift_queue::access_update
PUBLIC	?access_source@kd_vlift_queue@@QAE_NHHQAPAUkd_vlift_line@@AAPAU2@@Z ; kd_vlift_queue::access_source
PUBLIC	?simulate_access_source@kd_vlift_queue@@QAE_NHHAAH@Z ; kd_vlift_queue::simulate_access_source
PUBLIC	?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z ; perform_analysis_lifting_step
PUBLIC	?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z ; perform_analysis_lifting_step
PUBLIC	??0kd_analysis@@QAE@XZ				; kd_analysis::kd_analysis
PUBLIC	?init@kd_analysis@@QAEXVkdu_node@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kd_analysis::init
PUBLIC	??1kd_analysis@@MAE@XZ				; kd_analysis::~kd_analysis
PUBLIC	?push@kd_analysis@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z ; kd_analysis::push
PUBLIC	?simulate_vertical_lifting@kd_analysis@@AAEHH@Z	; kd_analysis::simulate_vertical_lifting
PUBLIC	?horizontal_analysis@kd_analysis@@AAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z ; kd_analysis::horizontal_analysis
PUBLIC	??_Gkd_analysis@@MAEPAXI@Z			; kd_analysis::`scalar deleting destructor'
PUBLIC	__TI1H
PUBLIC	__CTA1H
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
PUBLIC	__CT??_R0H@84
PUBLIC	??_7kdu_push_ifc_base@@6B@			; kdu_push_ifc_base::`vftable'
PUBLIC	??_7kd_analysis@@6B@				; kd_analysis::`vftable'
PUBLIC	??_R4kdu_push_ifc_base@@6B@			; kdu_push_ifc_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_push_ifc_base@@@8			; kdu_push_ifc_base `RTTI Type Descriptor'
PUBLIC	??_R3kdu_push_ifc_base@@8			; kdu_push_ifc_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_push_ifc_base@@8			; kdu_push_ifc_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_push_ifc_base@@8		; kdu_push_ifc_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_analysis@@6B@				; kd_analysis::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_analysis@@@8				; kd_analysis `RTTI Type Descriptor'
PUBLIC	??_R3kd_analysis@@8				; kd_analysis::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_analysis@@8				; kd_analysis::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_analysis@@8			; kd_analysis::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	___isa_available_default
PUBLIC	__real@3ecccccd
PUBLIC	__real@3eff7cee
PUBLIC	__real@3f000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ffa09bdc981b97a
PUBLIC	__real@3ffb5477208894d9
PUBLIC	__real@4000000000000000
PUBLIC	__real@401e666666666666
PUBLIC	__real@40da7ce680000000
PUBLIC	__real@40dc628aa0000000
PUBLIC	__real@c00e297d9a2f0174
PUBLIC	__real@c0bdf90a00000000
PUBLIC	__real@c0db2015c0000000
PUBLIC	__xmm@3f0000003f0000003f0000003f000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	?access_node@kdu_resolution@@QAE?AVkdu_node@@XZ:PROC ; kdu_resolution::access_node
EXTRN	?get_reversible@kdu_resolution@@QAE_NXZ:PROC	; kdu_resolution::get_reversible
EXTRN	?propagate_roi@kdu_resolution@@QAE_NXZ:PROC	; kdu_resolution::propagate_roi
EXTRN	?access_child@kdu_node@@QAE?AV1@H@Z:PROC	; kdu_node::access_child
EXTRN	?access_subband@kdu_node@@QAE?AVkdu_subband@@XZ:PROC ; kdu_node::access_subband
EXTRN	?access_resolution@kdu_node@@QAE?AVkdu_resolution@@XZ:PROC ; kdu_node::access_resolution
EXTRN	?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z:PROC	; kdu_node::get_dims
EXTRN	?get_kernel_id@kdu_node@@QAEHXZ:PROC		; kdu_node::get_kernel_id
EXTRN	?get_kernel_info@kdu_node@@QAEPBUkdu_kernel_step_info@@AAHAAM1AA_N20000_N@Z:PROC ; kdu_node::get_kernel_info
EXTRN	?get_kernel_coefficients@kdu_node@@QAEPBM_N@Z:PROC ; kdu_node::get_kernel_coefficients
EXTRN	?get_bibo_gains@kdu_node@@QAEPBMAAH_N@Z:PROC	; kdu_node::get_bibo_gains
EXTRN	??_Ekdu_push_ifc_base@@MAEPAXI@Z:PROC		; kdu_push_ifc_base::`vector deleting destructor'
EXTRN	??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z:PROC ; kdu_encoder::kdu_encoder
EXTRN	?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z:PROC ; kdu_roi_level::create
EXTRN	?destroy@kdu_roi_level@@QAEXXZ:PROC		; kdu_roi_level::destroy
EXTRN	?acquire_node@kdu_roi_level@@QAEPAVkdu_roi_node@@H@Z:PROC ; kdu_roi_level::acquire_node
EXTRN	??_Ekd_analysis@@MAEPAXI@Z:PROC			; kd_analysis::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_floor:PROC
EXTRN	_memcpy:PROC
EXTRN	?kdu_mmx_level@@3HA:DWORD			; kdu_mmx_level
EXTRN	?kdu_sparcvis_exists@@3_NA:BYTE			; kdu_sparcvis_exists
EXTRN	?kdu_altivec_exists@@3_NA:BYTE			; kdu_altivec_exists
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___isa_available:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?simd_w97_rem@@3PAFA DW 04H DUP (?)			; simd_w97_rem
?simd_w97_preoff@@3PAFA DW 04H DUP (?)			; simd_w97_preoff
_BSS	ENDS
;	COMDAT ___isa_available_default
_BSS	SEGMENT
___isa_available_default DD 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
?simd_w97_rem$initializer$@@3P6AXXZA DD FLAT:??__Esimd_w97_rem@@YAXXZ ; simd_w97_rem$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@3f0000003f0000003f0000003f000000
CONST	SEGMENT
__xmm@3f0000003f0000003f0000003f000000 DB 00H, 00H, 00H, '?', 00H, 00H, 00H
	DB	'?', 00H, 00H, 00H, '?', 00H, 00H, 00H, '?'
CONST	ENDS
;	COMDAT __real@c0db2015c0000000
CONST	SEGMENT
__real@c0db2015c0000000 DQ 0c0db2015c0000000r	; -27776.3
CONST	ENDS
;	COMDAT __real@c0bdf90a00000000
CONST	SEGMENT
__real@c0bdf90a00000000 DQ 0c0bdf90a00000000r	; -7673.04
CONST	ENDS
;	COMDAT __real@c00e297d9a2f0174
CONST	SEGMENT
__real@c00e297d9a2f0174 DQ 0c00e297d9a2f0174r	; -3.77026
CONST	ENDS
;	COMDAT __real@40dc628aa0000000
CONST	SEGMENT
__real@40dc628aa0000000 DQ 040dc628aa0000000r	; 29066.2
CONST	ENDS
;	COMDAT __real@40da7ce680000000
CONST	SEGMENT
__real@40da7ce680000000 DQ 040da7ce680000000r	; 27123.6
CONST	ENDS
;	COMDAT __real@401e666666666666
CONST	SEGMENT
__real@401e666666666666 DQ 0401e666666666666r	; 7.6
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ffb5477208894d9
CONST	SEGMENT
__real@3ffb5477208894d9 DQ 03ffb5477208894d9r	; 1.70812
CONST	ENDS
;	COMDAT __real@3ffa09bdc981b97a
CONST	SEGMENT
__real@3ffa09bdc981b97a DQ 03ffa09bdc981b97ar	; 1.62738
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3eff7cee
CONST	SEGMENT
__real@3eff7cee DD 03eff7ceer			; 0.499
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_analysis@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_analysis@@8 DD FLAT:??_R0?AVkd_analysis@@@8 ; kd_analysis::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_analysis@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_analysis@@8
rdata$r	SEGMENT
??_R2kd_analysis@@8 DD FLAT:??_R1A@?0A@EA@kd_analysis@@8 ; kd_analysis::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_push_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_analysis@@8
rdata$r	SEGMENT
??_R3kd_analysis@@8 DD 00H				; kd_analysis::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_analysis@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_analysis@@@8
data$r	SEGMENT
??_R0?AVkd_analysis@@@8 DD FLAT:??_7type_info@@6B@	; kd_analysis `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_analysis@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_analysis@@6B@
rdata$r	SEGMENT
??_R4kd_analysis@@6B@ DD 00H				; kd_analysis::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_analysis@@@8
	DD	FLAT:??_R3kd_analysis@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_push_ifc_base@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_push_ifc_base@@8 DD FLAT:??_R0?AVkdu_push_ifc_base@@@8 ; kdu_push_ifc_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_push_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_push_ifc_base@@8
rdata$r	SEGMENT
??_R2kdu_push_ifc_base@@8 DD FLAT:??_R1A@?0A@EA@kdu_push_ifc_base@@8 ; kdu_push_ifc_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_push_ifc_base@@8
rdata$r	SEGMENT
??_R3kdu_push_ifc_base@@8 DD 00H			; kdu_push_ifc_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_push_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_push_ifc_base@@@8
data$r	SEGMENT
??_R0?AVkdu_push_ifc_base@@@8 DD FLAT:??_7type_info@@6B@ ; kdu_push_ifc_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_push_ifc_base@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_push_ifc_base@@6B@
rdata$r	SEGMENT
??_R4kdu_push_ifc_base@@6B@ DD 00H			; kdu_push_ifc_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_push_ifc_base@@@8
	DD	FLAT:??_R3kdu_push_ifc_base@@8
rdata$r	ENDS
;	COMDAT ??_7kd_analysis@@6B@
CONST	SEGMENT
??_7kd_analysis@@6B@ DD FLAT:??_R4kd_analysis@@6B@	; kd_analysis::`vftable'
	DD	FLAT:??_Ekd_analysis@@MAEPAXI@Z
	DD	FLAT:?push@kd_analysis@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z
CONST	ENDS
;	COMDAT ??_7kdu_push_ifc_base@@6B@
CONST	SEGMENT
??_7kdu_push_ifc_base@@6B@ DD FLAT:??_R4kdu_push_ifc_base@@6B@ ; kdu_push_ifc_base::`vftable'
	DD	FLAT:??_Ekdu_push_ifc_base@@MAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0H@8
data$r	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
data$r	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kd_analysis@@MAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
?simd_w97_preoff$initializer$@@3P6AXXZA DD FLAT:??__Esimd_w97_preoff@@YAXXZ ; simd_w97_preoff$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_W5X3_v_analysis32@@YA_NPAH000HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_int_coeff$ = -44					; size = 4
_downshift$ = -40					; size = 4
_dst_out$GSCopy$ = -36					; size = 4
_dst_in$GSCopy$ = -32					; size = 4
_src2$GSCopy$ = -28					; size = 4
_src1$GSCopy$ = -24					; size = 4
_vec_offset$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_dst_in$ = 16						; size = 4
_dst_out$ = 20						; size = 4
_samples$ = 24						; size = 4
_step$ = 28						; size = 4
?simd_W5X3_v_analysis32@@YA_NPAH000HPAUkd_lifting_step@@@Z PROC ; simd_W5X3_v_analysis32, COMDAT

; 2048 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2049 :   assert((step->support_length == 2) && (step->icoeffs[0]==step->icoeffs[1]));
; 2050 : #ifndef KDU_NO_SSE
; 2051 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	mov	eax, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR _step$[ebp]
	mov	DWORD PTR _src1$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _src2$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst_in$[ebp]
	mov	DWORD PTR _dst_in$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst_out$[ebp]
	mov	DWORD PTR _dst_out$GSCopy$[ebp], eax
	jge	SHORT $LN5@simd_W5X3_

; 2052 :     return false;

	xor	al, al

; 2098 : done:
; 2099 :     }
; 2100 : #endif KDU_NO_SSE
; 2101 :   return true;
; 2102 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@simd_W5X3_:

; 2053 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN15@simd_W5X3_

; 2054 :     return true;
; 2055 : 
; 2056 :   kdu_int32 vec_offset[4];
; 2057 :   vec_offset[0] = (kdu_int32)((1<<step->downshift)>>1);

	movzx	ecx, BYTE PTR [edx+2]
	mov	eax, 1
	shl	eax, cl
	sar	eax, 1
	mov	DWORD PTR _vec_offset$[ebp], eax

; 2058 :   for (int k=1; k < 4; k++)
; 2059 :     vec_offset[k] = vec_offset[0];

	mov	DWORD PTR _vec_offset$[ebp+4], eax
	mov	DWORD PTR _vec_offset$[ebp+8], eax
	mov	DWORD PTR _vec_offset$[ebp+12], eax

; 2060 :   int int_coeff = step->icoeffs[0];

	mov	eax, DWORD PTR [edx+12]
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _int_coeff$[ebp], eax

; 2061 :   int downshift = step->downshift;

	mov	DWORD PTR _downshift$[ebp], ecx

; 2064 :       MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 2065 :       MOV EAX,src1

	mov	eax, DWORD PTR _src1$GSCopy$[ebp]

; 2066 :       MOV EBX,src2

	mov	ebx, DWORD PTR _src2$GSCopy$[ebp]

; 2067 :       MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$GSCopy$[ebp]

; 2068 :       MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$GSCopy$[ebp]

; 2069 :       MOVDQU XMM0,vec_offset

	movdqu	xmm0, XMMWORD PTR _vec_offset$[ebp]

; 2070 :       MOVD XMM1,downshift

	movd	xmm1, DWORD PTR _downshift$[ebp]

; 2071 :       MOV ECX,int_coeff

	mov	ecx, DWORD PTR _int_coeff$[ebp]

; 2072 :       CMP ECX,1

	cmp	ecx, 1

; 2073 :       MOV ECX,0  // Set up sample counter, without altering status flags

	mov	ecx, 0

; 2074 :       JNE loop_minus1

	jne	SHORT $loop_minus1$17
$loop_plus1$18:

; 2075 : loop_plus1:
; 2076 :       MOVDQA XMM2,XMM0         // start with the offset

	movdqa	xmm2, xmm0

; 2077 :       PADDD XMM2,[EAX+4*ECX]   // add 1'st source sample

	paddd	xmm2, XMMWORD PTR [eax+ecx*4]

; 2078 :       PADDD XMM2,[EBX+4*ECX]   // add 2'nd source sample

	paddd	xmm2, XMMWORD PTR [ebx+ecx*4]

; 2079 :       MOVDQA XMM3,[ESI+4*ECX]

	movdqa	xmm3, XMMWORD PTR [esi+ecx*4]

; 2080 :       PSRAD XMM2,XMM1          // shift rigth by the `downshift' value

	psrad	xmm2, xmm1

; 2081 :       PADDD XMM3,XMM2          // add to dest sample

	paddd	xmm3, xmm2

; 2082 :       MOVDQA [EDI+4*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*4], xmm3

; 2083 :       ADD ECX,4

	add	ecx, 4

; 2084 :       CMP ECX,EDX

	cmp	ecx, edx

; 2085 :       JL loop_plus1

	jl	SHORT $loop_plus1$18

; 2086 :       JMP done

	jmp	SHORT $done$19
$loop_minus1$17:

; 2087 : loop_minus1:
; 2088 :       MOVDQA XMM2,XMM0         // start with the offset

	movdqa	xmm2, xmm0

; 2089 :       PSUBD XMM2,[EAX+4*ECX]   // subtract 1'st source sample

	psubd	xmm2, XMMWORD PTR [eax+ecx*4]

; 2090 :       PSUBD XMM2,[EBX+4*ECX]   // subtract 2'nd source sample

	psubd	xmm2, XMMWORD PTR [ebx+ecx*4]

; 2091 :       MOVDQA XMM3,[ESI+4*ECX]

	movdqa	xmm3, XMMWORD PTR [esi+ecx*4]

; 2092 :       PSRAD XMM2,XMM1          // shift rigth by the `downshift' value

	psrad	xmm2, xmm1

; 2093 :       PADDD XMM3,XMM2          // add to dest sample

	paddd	xmm3, xmm2

; 2094 :       MOVDQA [EDI+4*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*4], xmm3

; 2095 :       ADD ECX,4

	add	ecx, 4

; 2096 :       CMP ECX,EDX

	cmp	ecx, edx

; 2097 :       JL loop_minus1

	jl	SHORT $loop_minus1$17
$done$19:

; 2062 :   assert((int_coeff == 1) || (int_coeff == -1));
; 2063 :   __asm {

	pop	edi
	pop	esi
	pop	ebx
$LN15@simd_W5X3_:

; 2098 : done:
; 2099 :     }
; 2100 : #endif KDU_NO_SSE
; 2101 :   return true;
; 2102 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_W5X3_v_analysis32@@YA_NPAH000HPAUkd_lifting_step@@@Z ENDP ; simd_W5X3_v_analysis32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_W5X3_h_analysis32@@YA_NPAH0HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_int_coeff$ = -36					; size = 4
_src$GSCopy$ = -32					; size = 4
_dst$GSCopy$ = -28					; size = 4
_downshift$ = -24					; size = 4
_vec_offset$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_samples$ = 16						; size = 4
_step$ = 20						; size = 4
?simd_W5X3_h_analysis32@@YA_NPAH0HPAUkd_lifting_step@@@Z PROC ; simd_W5X3_h_analysis32, COMDAT

; 1883 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1884 :   assert((step->support_length == 2) && (step->icoeffs[0]==step->icoeffs[1]));
; 1885 : #ifndef KDU_NO_SSE
; 1886 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	mov	eax, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _step$[ebp]
	mov	DWORD PTR _src$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _dst$GSCopy$[ebp], eax
	jge	SHORT $LN5@simd_W5X3_

; 1887 :     return false;

	xor	al, al

; 1951 : done:
; 1952 :     }
; 1953 : #endif // KDU_NO_SSE
; 1954 :   return true;
; 1955 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@simd_W5X3_:

; 1888 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN15@simd_W5X3_

; 1889 :     return true;
; 1890 : 
; 1891 :   kdu_int32 vec_offset[4];
; 1892 :   vec_offset[0] = (kdu_int32)((1<<step->downshift)>>1);

	movzx	ecx, BYTE PTR [edx+2]
	mov	eax, 1
	shl	eax, cl
	sar	eax, 1
	mov	DWORD PTR _vec_offset$[ebp], eax

; 1893 :   for (int k=1; k < 4; k++)
; 1894 :     vec_offset[k] = vec_offset[0];

	mov	DWORD PTR _vec_offset$[ebp+4], eax
	mov	DWORD PTR _vec_offset$[ebp+8], eax
	mov	DWORD PTR _vec_offset$[ebp+12], eax

; 1895 :   int int_coeff = step->icoeffs[0];

	mov	eax, DWORD PTR [edx+12]
	push	ebx
	push	edi

; 1896 :   int downshift = step->downshift;

	mov	DWORD PTR _downshift$[ebp], ecx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _int_coeff$[ebp], eax

; 1899 :     {
; 1900 :       MOVDQU XMM0,vec_offset

	movdqu	xmm0, XMMWORD PTR _vec_offset$[ebp]

; 1901 :       MOVD XMM1,downshift

	movd	xmm1, DWORD PTR _downshift$[ebp]

; 1902 :       MOV EDX,samples // Set limit for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 1903 :       MOV EDI,dst

	mov	edi, DWORD PTR _dst$GSCopy$[ebp]

; 1904 :       MOV EAX,src     // EAX points to first source sample

	mov	eax, DWORD PTR _src$GSCopy$[ebp]

; 1905 :       MOV EBX,EAX

	mov	ebx, eax

; 1906 :       ADD EBX,4       // EBX points to second source sample

	add	ebx, 4

; 1907 :       TEST EAX,0Fh    // See if EAX is 16-byte aligned

	test	eax, 15					; 0000000fH

; 1908 :       JZ eax_aligned

	je	SHORT $eax_aligned$17

; 1909 :       XCHG EAX,EBX    // Make sure EAX is the aligned address

	xchg	eax, ebx
$eax_aligned$17:

; 1910 : eax_aligned:
; 1911 :       MOV ECX,int_coeff

	mov	ecx, DWORD PTR _int_coeff$[ebp]

; 1912 :       CMP ECX,1

	cmp	ecx, 1

; 1913 :       JNE start_minus1

	jne	SHORT $start_minus1$18

; 1914 : 
; 1915 :       XOR ECX,ECX     // Initialize the sample counter

	xor	ecx, ecx

; 1916 :       MOVDQA XMM2,[EAX+4*ECX]    // Load initial 4 source 1 samples

	movdqa	xmm2, XMMWORD PTR [eax+ecx*4]

; 1917 :       MOVDQU XMM5,[EBX+4*ECX]    // Get initial 4 source 2 samples

	movdqu	xmm5, XMMWORD PTR [ebx+ecx*4]
$loop_plus1$19:

; 1918 : loop_plus1:
; 1919 :       MOVDQA XMM7,XMM0             // Start with the offset

	movdqa	xmm7, xmm0

; 1920 :       PADDD XMM7,XMM2

	paddd	xmm7, xmm2

; 1921 :       MOVDQA XMM2,[EAX+4*ECX+16]  // Pre-load aligned dqword

	movdqa	xmm2, XMMWORD PTR [eax+ecx*4+16]

; 1922 :       PADDD XMM7,XMM5

	paddd	xmm7, xmm5

; 1923 :       MOVDQU XMM5,[EBX+4*ECX+16]

	movdqu	xmm5, XMMWORD PTR [ebx+ecx*4+16]

; 1924 :       MOVDQA XMM3,[EDI+4*ECX]

	movdqa	xmm3, XMMWORD PTR [edi+ecx*4]

; 1925 :       PSRAD XMM7,XMM1

	psrad	xmm7, xmm1

; 1926 :       PADDD XMM3,XMM7

	paddd	xmm3, xmm7

; 1927 :       MOVDQA [EDI+4*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*4], xmm3

; 1928 :       ADD ECX,4

	add	ecx, 4

; 1929 :       CMP ECX,EDX

	cmp	ecx, edx

; 1930 :       JL loop_plus1

	jl	SHORT $loop_plus1$19

; 1931 :       JMP done

	jmp	SHORT $done$20
$start_minus1$18:

; 1932 : 
; 1933 : start_minus1:
; 1934 :       // Invert Lifting Step 1
; 1935 :       XOR ECX,ECX                // Zero sample counter

	xor	ecx, ecx

; 1936 :       MOVDQA XMM2,[EAX+4*ECX]    // Load initial 4 source 1 samples

	movdqa	xmm2, XMMWORD PTR [eax+ecx*4]

; 1937 :       MOVDQU XMM5,[EBX+4*ECX]    // Get initial 4 source 2 samples

	movdqu	xmm5, XMMWORD PTR [ebx+ecx*4]
$loop_minus1$21:

; 1938 : loop_minus1:
; 1939 :       MOVDQA XMM7,XMM0             // Start with the offset

	movdqa	xmm7, xmm0

; 1940 :       PSUBD XMM7,XMM2

	psubd	xmm7, xmm2

; 1941 :       MOVDQA XMM2,[EAX+4*ECX+16]  // Pre-load aligned octet

	movdqa	xmm2, XMMWORD PTR [eax+ecx*4+16]

; 1942 :       PSUBD XMM7,XMM5

	psubd	xmm7, xmm5

; 1943 :       MOVDQU XMM5,[EBX+4*ECX+16]

	movdqu	xmm5, XMMWORD PTR [ebx+ecx*4+16]

; 1944 :       MOVDQA XMM3,[EDI+4*ECX]

	movdqa	xmm3, XMMWORD PTR [edi+ecx*4]

; 1945 :       PSRAD XMM7,XMM1

	psrad	xmm7, xmm1

; 1946 :       PADDD XMM3,XMM7

	paddd	xmm3, xmm7

; 1947 :       MOVDQA [EDI+4*ECX],XMM3

	movdqa	XMMWORD PTR [edi+ecx*4], xmm3

; 1948 :       ADD ECX,4

	add	ecx, 4

; 1949 :       CMP ECX,EDX

	cmp	ecx, edx

; 1950 :       JL loop_minus1

	jl	SHORT $loop_minus1$21
$done$20:

; 1897 :   assert((int_coeff == 1) || (int_coeff == -1));
; 1898 :   __asm

	pop	edi
	pop	ebx
$LN15@simd_W5X3_:

; 1951 : done:
; 1952 :     }
; 1953 : #endif // KDU_NO_SSE
; 1954 :   return true;
; 1955 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_W5X3_h_analysis32@@YA_NPAH0HPAUkd_lifting_step@@@Z ENDP ; simd_W5X3_h_analysis32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_4tap_v_irrev32@@YA_NPAM00000HPAUkd_lifting_step@@_N@Z
_TEXT	SEGMENT
_lambda2$ = -64						; size = 4
_lambda1$ = -48						; size = 4
_lambda0$ = -32						; size = 4
_lambda3$ = -16						; size = 4
_src0$ = 8						; size = 4
_src1$ = 12						; size = 4
_src2$ = 16						; size = 4
_src3$ = 20						; size = 4
_dst_in$ = 24						; size = 4
_dst_out$ = 28						; size = 4
_samples$ = 32						; size = 4
_step$ = 36						; size = 4
_synthesis$ = 40					; size = 1
?simd_4tap_v_irrev32@@YA_NPAM00000HPAUkd_lifting_step@@_N@Z PROC ; simd_4tap_v_irrev32, COMDAT

; 1814 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1815 : #ifdef KDU_NO_SSE
; 1816 :   return false;
; 1817 : #else
; 1818 :   assert((step->support_length >= 3) || (step->support_length <= 4));
; 1819 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	push	ebx
	jge	SHORT $LN2@simd_4tap_

; 1820 :     return false;

	xor	al, al

; 1872 : #endif // !KDU_NO_SSE
; 1873 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_4tap_:

; 1821 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN8@simd_4tap_

; 1822 :     return true;
; 1823 : 
; 1824 :   float lambda0 = step->coeffs[0];

	mov	eax, DWORD PTR _step$[ebp]

; 1825 :   float lambda1 = step->coeffs[1];
; 1826 :   float lambda2 = step->coeffs[2];
; 1827 :   float lambda3 = (step->support_length==4)?(step->coeffs[3]):0.0F;

	cmp	BYTE PTR [eax+1], 4
	mov	ecx, DWORD PTR [eax+8]
	movss	xmm2, DWORD PTR [ecx]
	movss	xmm3, DWORD PTR [ecx+4]
	movss	xmm4, DWORD PTR [ecx+8]
	movss	DWORD PTR _lambda0$[ebp], xmm2
	movss	DWORD PTR _lambda1$[ebp], xmm3
	movss	DWORD PTR _lambda2$[ebp], xmm4
	jne	SHORT $LN6@simd_4tap_
	movss	xmm1, DWORD PTR [ecx+12]
	jmp	SHORT $LN9@simd_4tap_
$LN6@simd_4tap_:
	xorps	xmm1, xmm1
$LN9@simd_4tap_:

; 1828 :   if (synthesis)

	cmp	BYTE PTR _synthesis$[ebp], 0
	movss	DWORD PTR _lambda3$[ebp], xmm1
	je	SHORT $LN4@simd_4tap_

; 1829 :     { lambda0 = -lambda0;  lambda1 = -lambda1;

	movss	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm2, xmm0
	xorps	xmm3, xmm0

; 1830 :       lambda2 = -lambda2;  lambda3 = -lambda3; }

	xorps	xmm4, xmm0
	movss	DWORD PTR _lambda0$[ebp], xmm2
	xorps	xmm1, xmm0
	movss	DWORD PTR _lambda1$[ebp], xmm3
	movss	DWORD PTR _lambda2$[ebp], xmm4
	movss	DWORD PTR _lambda3$[ebp], xmm1
$LN4@simd_4tap_:

; 1831 :   __asm {

	push	esi
	push	edi

; 1832 :       MOVSS XMM0, lambda0

	movss	xmm0, XMMWORD PTR _lambda0$[ebp]

; 1833 :       MOVSS XMM1, lambda1

	movss	xmm1, XMMWORD PTR _lambda1$[ebp]

; 1834 :       MOVSS XMM2, lambda2

	movss	xmm2, XMMWORD PTR _lambda2$[ebp]

; 1835 :       MOVSS XMM3, lambda3

	movss	xmm3, XMMWORD PTR _lambda3$[ebp]

; 1836 :       PUNPCKLDQ XMM0,XMM0

	punpckldq xmm0, xmm0

; 1837 :       PUNPCKLDQ XMM1,XMM1

	punpckldq xmm1, xmm1

; 1838 :       PUNPCKLDQ XMM2,XMM2

	punpckldq xmm2, xmm2

; 1839 :       PUNPCKLDQ XMM3,XMM3

	punpckldq xmm3, xmm3

; 1840 :       PUNPCKLQDQ XMM0,XMM0

	punpcklqdq xmm0, xmm0

; 1841 :       PUNPCKLQDQ XMM1,XMM1

	punpcklqdq xmm1, xmm1

; 1842 :       PUNPCKLQDQ XMM2,XMM2

	punpcklqdq xmm2, xmm2

; 1843 :       PUNPCKLQDQ XMM3,XMM3

	punpcklqdq xmm3, xmm3

; 1844 :       XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx

; 1845 :       MOV EAX,src0

	mov	eax, DWORD PTR _src0$[ebp]

; 1846 :       MOV EBX,src1

	mov	ebx, DWORD PTR _src1$[ebp]

; 1847 :       MOV EDX, src2

	mov	edx, DWORD PTR _src2$[ebp]

; 1848 :       MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$[ebp]

; 1849 :       MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$[ebp]
$loop_dqword$11:

; 1850 : loop_dqword:
; 1851 :       MOVUPS XMM4, [EAX+4*ECX]

	movups	xmm4, XMMWORD PTR [eax+ecx*4]

; 1852 :       MOVUPS XMM5, [EBX+4*ECX]

	movups	xmm5, XMMWORD PTR [ebx+ecx*4]

; 1853 :       MOVUPS XMM6, [EDX+4*ECX]

	movups	xmm6, XMMWORD PTR [edx+ecx*4]

; 1854 :       MOV EDX, src3

	mov	edx, DWORD PTR _src3$[ebp]

; 1855 :       MULPS XMM4, XMM0

	mulps	xmm4, xmm0

; 1856 :       MULPS XMM5, XMM1

	mulps	xmm5, xmm1

; 1857 :       MULPS XMM6, XMM2

	mulps	xmm6, xmm2

; 1858 :       MOVUPS XMM7, [EDX+4*ECX]

	movups	xmm7, XMMWORD PTR [edx+ecx*4]

; 1859 :       ADDPS XMM5, XMM4

	addps	xmm5, xmm4

; 1860 :       MOVAPS XMM4, [ESI+4*ECX]

	movaps	xmm4, XMMWORD PTR [esi+ecx*4]

; 1861 :       MULPS XMM7, XMM3

	mulps	xmm7, xmm3

; 1862 :       ADDPS XMM6, XMM5

	addps	xmm6, xmm5

; 1863 :       ADDPS XMM6, XMM4

	addps	xmm6, xmm4

; 1864 :       ADDPS XMM7, XMM6

	addps	xmm7, xmm6

; 1865 :       MOVAPS [EDI+4*ECX], XMM7

	movaps	XMMWORD PTR [edi+ecx*4], xmm7

; 1866 :       ADD ECX,4

	add	ecx, 4

; 1867 :       MOV EDX, src2

	mov	edx, DWORD PTR _src2$[ebp]

; 1868 :       CMP ECX,samples

	cmp	ecx, DWORD PTR _samples$[ebp]

; 1869 :       JL loop_dqword

	jl	SHORT $loop_dqword$11

; 1831 :   __asm {

	pop	edi
	pop	esi
$LN8@simd_4tap_:

; 1870 :     }
; 1871 :   return true;

	mov	al, 1

; 1872 : #endif // !KDU_NO_SSE
; 1873 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_4tap_v_irrev32@@YA_NPAM00000HPAUkd_lifting_step@@_N@Z ENDP ; simd_4tap_v_irrev32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_2tap_v_irrev32@@YA_NPAM000HPAUkd_lifting_step@@_N@Z
_TEXT	SEGMENT
_lambda0$ = -32						; size = 4
_lambda1$ = -16						; size = 4
_src0$ = 8						; size = 4
_src1$ = 12						; size = 4
_dst_in$ = 16						; size = 4
_dst_out$ = 20						; size = 4
_samples$ = 24						; size = 4
_step$ = 28						; size = 4
_synthesis$ = 32					; size = 1
?simd_2tap_v_irrev32@@YA_NPAM000HPAUkd_lifting_step@@_N@Z PROC ; simd_2tap_v_irrev32, COMDAT

; 1757 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1758 : #ifdef KDU_NO_SSE
; 1759 :   return false;
; 1760 : #else
; 1761 :   assert((step->support_length == 1) || (step->support_length == 2));
; 1762 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	push	ebx
	jge	SHORT $LN2@simd_2tap_

; 1763 :     return false;

	xor	al, al

; 1799 : #endif // !KDU_NO_SSE
; 1800 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_2tap_:

; 1764 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN8@simd_2tap_

; 1765 :     return true;
; 1766 :   float lambda0 = step->coeffs[0];

	mov	eax, DWORD PTR _step$[ebp]

; 1767 :   float lambda1 = (step->support_length==2)?(step->coeffs[1]):0.0F;

	cmp	BYTE PTR [eax+1], 2
	mov	ecx, DWORD PTR [eax+8]
	movss	xmm2, DWORD PTR [ecx]
	movss	DWORD PTR _lambda0$[ebp], xmm2
	jne	SHORT $LN6@simd_2tap_
	movss	xmm1, DWORD PTR [ecx+4]
	jmp	SHORT $LN9@simd_2tap_
$LN6@simd_2tap_:
	xorps	xmm1, xmm1
$LN9@simd_2tap_:

; 1768 :   if (synthesis)

	cmp	BYTE PTR _synthesis$[ebp], 0
	movss	DWORD PTR _lambda1$[ebp], xmm1
	je	SHORT $LN4@simd_2tap_

; 1769 :     { lambda0 = -lambda0;  lambda1 = -lambda1; }

	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _lambda0$[ebp], xmm2
	movss	DWORD PTR _lambda1$[ebp], xmm1
$LN4@simd_2tap_:

; 1770 :   __asm {

	push	esi
	push	edi

; 1771 :       MOVSS XMM0, lambda0

	movss	xmm0, XMMWORD PTR _lambda0$[ebp]

; 1772 :       MOVSS XMM1, lambda1

	movss	xmm1, XMMWORD PTR _lambda1$[ebp]

; 1773 :       PUNPCKLDQ XMM0,XMM0

	punpckldq xmm0, xmm0

; 1774 :       PUNPCKLDQ XMM1,XMM1

	punpckldq xmm1, xmm1

; 1775 :       PUNPCKLQDQ XMM0,XMM0

	punpcklqdq xmm0, xmm0

; 1776 :       PUNPCKLQDQ XMM1,XMM1

	punpcklqdq xmm1, xmm1

; 1777 :       XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx

; 1778 :       MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 1779 :       MOV EAX,src0

	mov	eax, DWORD PTR _src0$[ebp]

; 1780 :       MOV EBX,src1

	mov	ebx, DWORD PTR _src1$[ebp]

; 1781 :       MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$[ebp]

; 1782 :       MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$[ebp]

; 1783 :       MOVAPS XMM4,[EAX]

	movaps	xmm4, XMMWORD PTR [eax]

; 1784 :       MOVAPS XMM5,[EBX]

	movaps	xmm5, XMMWORD PTR [ebx]
$loop_dqword$11:

; 1785 : loop_dqword:
; 1786 :       MULPS XMM4, XMM0

	mulps	xmm4, xmm0

; 1787 :       MULPS XMM5, XMM1

	mulps	xmm5, xmm1

; 1788 :       MOVAPS XMM2, [ESI+4*ECX]

	movaps	xmm2, XMMWORD PTR [esi+ecx*4]

; 1789 :       ADDPS XMM5, XMM4

	addps	xmm5, xmm4

; 1790 :       MOVAPS XMM4, [EAX+4*ECX+16]

	movaps	xmm4, XMMWORD PTR [eax+ecx*4+16]

; 1791 :       ADDPS XMM2, XMM5

	addps	xmm2, xmm5

; 1792 :       MOVAPS XMM5, [EBX+4*ECX+16]

	movaps	xmm5, XMMWORD PTR [ebx+ecx*4+16]

; 1793 :       MOVAPS [EDI+4*ECX], XMM2

	movaps	XMMWORD PTR [edi+ecx*4], xmm2

; 1794 :       ADD ECX,4

	add	ecx, 4

; 1795 :       CMP ECX,EDX

	cmp	ecx, edx

; 1796 :       JL loop_dqword

	jl	SHORT $loop_dqword$11

; 1770 :   __asm {

	pop	edi
	pop	esi
$LN8@simd_2tap_:

; 1797 :     }
; 1798 :   return true;

	mov	al, 1

; 1799 : #endif // !KDU_NO_SSE
; 1800 : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_2tap_v_irrev32@@YA_NPAM000HPAUkd_lifting_step@@_N@Z ENDP ; simd_2tap_v_irrev32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_4tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z
_TEXT	SEGMENT
_lambda2$ = -64						; size = 4
_lambda1$ = -48						; size = 4
_lambda0$ = -32						; size = 4
_lambda3$ = -16						; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_samples$ = 16						; size = 4
_step$ = 20						; size = 4
_synthesis$ = 24					; size = 1
?simd_4tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z PROC ; simd_4tap_h_irrev32, COMDAT

; 1685 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1686 : #ifdef KDU_NO_SSE
; 1687 :   return false;
; 1688 : #else
; 1689 :   assert((step->support_length >= 3) && (step->support_length <= 4));
; 1690 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	jge	SHORT $LN2@simd_4tap_

; 1691 :     return false;

	xor	al, al

; 1743 : #endif // !KDU_NO_SSE
; 1744 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_4tap_:

; 1692 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN8@simd_4tap_

; 1693 :     return true;
; 1694 : 
; 1695 :   float lambda0 = step->coeffs[0];

	mov	eax, DWORD PTR _step$[ebp]

; 1696 :   float lambda1 = step->coeffs[1];
; 1697 :   float lambda2 = step->coeffs[2];
; 1698 :   float lambda3 = (step->support_length==4)?(step->coeffs[3]):0.0F;

	cmp	BYTE PTR [eax+1], 4
	mov	ecx, DWORD PTR [eax+8]
	movss	xmm2, DWORD PTR [ecx]
	movss	xmm3, DWORD PTR [ecx+4]
	movss	xmm4, DWORD PTR [ecx+8]
	movss	DWORD PTR _lambda0$[ebp], xmm2
	movss	DWORD PTR _lambda1$[ebp], xmm3
	movss	DWORD PTR _lambda2$[ebp], xmm4
	jne	SHORT $LN6@simd_4tap_
	movss	xmm1, DWORD PTR [ecx+12]
	jmp	SHORT $LN9@simd_4tap_
$LN6@simd_4tap_:
	xorps	xmm1, xmm1
$LN9@simd_4tap_:

; 1699 :   if (synthesis)

	cmp	BYTE PTR _synthesis$[ebp], 0
	movss	DWORD PTR _lambda3$[ebp], xmm1
	je	SHORT $LN4@simd_4tap_

; 1700 :     { lambda0 = -lambda0;  lambda1 = -lambda1;

	movss	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm2, xmm0
	xorps	xmm3, xmm0

; 1701 :       lambda2 = -lambda2;  lambda3 = -lambda3; }

	xorps	xmm4, xmm0
	movss	DWORD PTR _lambda0$[ebp], xmm2
	xorps	xmm1, xmm0
	movss	DWORD PTR _lambda1$[ebp], xmm3
	movss	DWORD PTR _lambda2$[ebp], xmm4
	movss	DWORD PTR _lambda3$[ebp], xmm1
$LN4@simd_4tap_:

; 1702 :   __asm {

	push	esi
	push	edi

; 1703 :       MOVSS XMM0, lambda0

	movss	xmm0, XMMWORD PTR _lambda0$[ebp]

; 1704 :       MOVSS XMM1, lambda1

	movss	xmm1, XMMWORD PTR _lambda1$[ebp]

; 1705 :       MOVSS XMM2, lambda2

	movss	xmm2, XMMWORD PTR _lambda2$[ebp]

; 1706 :       MOVSS XMM3, lambda3

	movss	xmm3, XMMWORD PTR _lambda3$[ebp]

; 1707 :       PUNPCKLDQ XMM0,XMM0

	punpckldq xmm0, xmm0

; 1708 :       PUNPCKLDQ XMM1,XMM1

	punpckldq xmm1, xmm1

; 1709 :       PUNPCKLDQ XMM2,XMM2

	punpckldq xmm2, xmm2

; 1710 :       PUNPCKLDQ XMM3,XMM3

	punpckldq xmm3, xmm3

; 1711 :       PUNPCKLQDQ XMM0,XMM0

	punpcklqdq xmm0, xmm0

; 1712 :       PUNPCKLQDQ XMM1,XMM1

	punpcklqdq xmm1, xmm1

; 1713 :       PUNPCKLQDQ XMM2,XMM2

	punpcklqdq xmm2, xmm2

; 1714 :       PUNPCKLQDQ XMM3,XMM3

	punpcklqdq xmm3, xmm3

; 1715 :       MOV ESI,src

	mov	esi, DWORD PTR _src$[ebp]

; 1716 :       MOV EDI,dst

	mov	edi, DWORD PTR _dst$[ebp]

; 1717 :       MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 1718 :       XOR ECX,ECX        // Zero sample counter

	xor	ecx, ecx

; 1719 :       MOVUPS XMM4,[ESI]

	movups	xmm4, XMMWORD PTR [esi]

; 1720 :       MOVUPS XMM5,[ESI+4]

	movups	xmm5, XMMWORD PTR [esi+4]

; 1721 :       MOVUPS XMM6,[ESI+8]

	movups	xmm6, XMMWORD PTR [esi+8]

; 1722 :       MOVUPS XMM7,[ESI+12]

	movups	xmm7, XMMWORD PTR [esi+12]
$loop_dqword$11:

; 1723 : loop_dqword:
; 1724 :       MULPS XMM4, XMM0

	mulps	xmm4, xmm0

; 1725 :       MULPS XMM5, XMM1

	mulps	xmm5, xmm1

; 1726 :       ADDPS XMM4, XMM5

	addps	xmm4, xmm5

; 1727 :       MOVAPS XMM5, [EDI+4*ECX]

	movaps	xmm5, XMMWORD PTR [edi+ecx*4]

; 1728 :       MULPS XMM6, XMM2

	mulps	xmm6, xmm2

; 1729 :       ADDPS XMM5, XMM4

	addps	xmm5, xmm4

; 1730 :       MOVUPS XMM4, [ESI+4*ECX+16]

	movups	xmm4, XMMWORD PTR [esi+ecx*4+16]

; 1731 :       MULPS XMM7, XMM3

	mulps	xmm7, xmm3

; 1732 :       ADDPS XMM6, XMM5

	addps	xmm6, xmm5

; 1733 :       MOVUPS XMM5, [ESI+4*ECX+20]

	movups	xmm5, XMMWORD PTR [esi+ecx*4+20]

; 1734 :       ADDPS XMM7, XMM6

	addps	xmm7, xmm6

; 1735 :       MOVUPS XMM6, [ESI+4*ECX+24]

	movups	xmm6, XMMWORD PTR [esi+ecx*4+24]

; 1736 :       MOVAPS [EDI+4*ECX], XMM7

	movaps	XMMWORD PTR [edi+ecx*4], xmm7

; 1737 :       MOVUPS XMM7, [ESI+4*ECX+28]

	movups	xmm7, XMMWORD PTR [esi+ecx*4+28]

; 1738 :       ADD ECX,4

	add	ecx, 4

; 1739 :       CMP ECX,EDX

	cmp	ecx, edx

; 1740 :       JL loop_dqword

	jl	SHORT $loop_dqword$11

; 1702 :   __asm {

	pop	edi
	pop	esi
$LN8@simd_4tap_:

; 1741 :     }
; 1742 :   return true;

	mov	al, 1

; 1743 : #endif // !KDU_NO_SSE
; 1744 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?simd_4tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z ENDP ; simd_4tap_h_irrev32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_2tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z
_TEXT	SEGMENT
_lambda0$ = -32						; size = 4
_lambda1$ = -16						; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_samples$ = 16						; size = 4
_step$ = 20						; size = 4
_synthesis$ = 24					; size = 1
?simd_2tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z PROC ; simd_2tap_h_irrev32, COMDAT

; 1629 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1630 : #ifdef KDU_NO_SSE
; 1631 :   return false;
; 1632 : #else
; 1633 :   assert((step->support_length == 1) || (step->support_length == 2));
; 1634 :   if (kdu_mmx_level < 2)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 2	; kdu_mmx_level
	jge	SHORT $LN2@simd_2tap_

; 1635 :     return false;

	xor	al, al

; 1671 : #endif // !KDU_NO_SSE
; 1672 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_2tap_:

; 1636 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN8@simd_2tap_

; 1637 :     return true;
; 1638 : 
; 1639 :   float lambda0 = step->coeffs[0];

	mov	eax, DWORD PTR _step$[ebp]

; 1640 :   float lambda1 = (step->support_length==2)?(step->coeffs[1]):0.0F;

	cmp	BYTE PTR [eax+1], 2
	mov	ecx, DWORD PTR [eax+8]
	movss	xmm2, DWORD PTR [ecx]
	movss	DWORD PTR _lambda0$[ebp], xmm2
	jne	SHORT $LN6@simd_2tap_
	movss	xmm1, DWORD PTR [ecx+4]
	jmp	SHORT $LN9@simd_2tap_
$LN6@simd_2tap_:
	xorps	xmm1, xmm1
$LN9@simd_2tap_:

; 1641 :   if (synthesis)

	cmp	BYTE PTR _synthesis$[ebp], 0
	movss	DWORD PTR _lambda1$[ebp], xmm1
	je	SHORT $LN4@simd_2tap_

; 1642 :     { lambda0 = -lambda0;  lambda1 = -lambda1; }

	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _lambda0$[ebp], xmm2
	movss	DWORD PTR _lambda1$[ebp], xmm1
$LN4@simd_2tap_:

; 1643 :   __asm {

	push	esi
	push	edi

; 1644 :       MOVSS XMM0, lambda0

	movss	xmm0, XMMWORD PTR _lambda0$[ebp]

; 1645 :       MOVSS XMM1, lambda1

	movss	xmm1, XMMWORD PTR _lambda1$[ebp]

; 1646 :       PUNPCKLDQ XMM0,XMM0

	punpckldq xmm0, xmm0

; 1647 :       PUNPCKLDQ XMM1,XMM1

	punpckldq xmm1, xmm1

; 1648 :       PUNPCKLQDQ XMM0,XMM0

	punpcklqdq xmm0, xmm0

; 1649 :       PUNPCKLQDQ XMM1,XMM1

	punpcklqdq xmm1, xmm1

; 1650 :       MOV ESI,src

	mov	esi, DWORD PTR _src$[ebp]

; 1651 :       MOV EDI,dst

	mov	edi, DWORD PTR _dst$[ebp]

; 1652 : 
; 1653 :       MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 1654 :       XOR ECX,ECX        // Zero sample counter

	xor	ecx, ecx

; 1655 :       MOVUPS XMM4,[ESI]

	movups	xmm4, XMMWORD PTR [esi]

; 1656 :       MOVUPS XMM5,[ESI+4]

	movups	xmm5, XMMWORD PTR [esi+4]
$loop_dqword$11:

; 1657 : loop_dqword:
; 1658 :       MULPS XMM4, XMM0

	mulps	xmm4, xmm0

; 1659 :       MULPS XMM5, XMM1

	mulps	xmm5, xmm1

; 1660 :       MOVAPS XMM2, [EDI+4*ECX]

	movaps	xmm2, XMMWORD PTR [edi+ecx*4]

; 1661 :       ADDPS XMM5, XMM4

	addps	xmm5, xmm4

; 1662 :       MOVUPS XMM4, [ESI+4*ECX+16]

	movups	xmm4, XMMWORD PTR [esi+ecx*4+16]

; 1663 :       ADDPS XMM2, XMM5

	addps	xmm2, xmm5

; 1664 :       MOVUPS XMM5, [ESI+4*ECX+20]

	movups	xmm5, XMMWORD PTR [esi+ecx*4+20]

; 1665 :       MOVAPS [EDI+4*ECX],XMM2

	movaps	XMMWORD PTR [edi+ecx*4], xmm2

; 1666 :       ADD ECX,4

	add	ecx, 4

; 1667 :       CMP ECX,EDX

	cmp	ecx, edx

; 1668 :       JL loop_dqword

	jl	SHORT $loop_dqword$11

; 1643 :   __asm {

	pop	edi
	pop	esi
$LN8@simd_2tap_:

; 1669 :     }
; 1670 :   return true;

	mov	al, 1

; 1671 : #endif // !KDU_NO_SSE
; 1672 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?simd_2tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z ENDP ; simd_2tap_h_irrev32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_downshifted_deinterleave@@YA_NPAF00HH@Z
_TEXT	SEGMENT
_dst2$GSCopy$ = -32					; size = 4
_dst1$GSCopy$ = -28					; size = 4
_src$GSCopy$ = -24					; size = 4
_vec_offset$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_src$ = 8						; size = 4
_dst1$ = 12						; size = 4
_dst2$ = 16						; size = 4
_pairs$ = 20						; size = 4
_downshift$ = 24					; size = 4
?simd_downshifted_deinterleave@@YA_NPAF00HH@Z PROC	; simd_downshifted_deinterleave, COMDAT

; 1485 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1486 :   if (kdu_mmx_level < 1)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 1	; kdu_mmx_level
	mov	eax, DWORD PTR _src$[ebp]
	mov	DWORD PTR _src$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst1$[ebp]
	mov	DWORD PTR _dst1$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst2$[ebp]
	mov	DWORD PTR _dst2$GSCopy$[ebp], eax
	jge	SHORT $LN5@simd_downs

; 1487 :     return false;

	xor	al, al

; 1529 :     }
; 1530 :   return true;
; 1531 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@simd_downs:

; 1488 :   if (pairs <= 0)

	cmp	DWORD PTR _pairs$[ebp], 0
	jle	$LN19@simd_downs

; 1489 :     return true;
; 1490 : 
; 1491 :   kdu_int16 vec_offset[8];
; 1492 :   vec_offset[0] = (kdu_int16)((1<<downshift)>>1);

	mov	ecx, DWORD PTR _downshift$[ebp]
	mov	eax, 1
	shl	eax, cl
	sar	eax, 1
	push	ebx
	mov	WORD PTR _vec_offset$[ebp], ax

; 1493 :   for (int k=1; k < 8; k++)
; 1494 :     vec_offset[k] = vec_offset[0];

	mov	WORD PTR _vec_offset$[ebp+2], ax
	mov	WORD PTR _vec_offset$[ebp+4], ax
	mov	WORD PTR _vec_offset$[ebp+6], ax
	mov	WORD PTR _vec_offset$[ebp+8], ax
	mov	WORD PTR _vec_offset$[ebp+10], ax
	mov	WORD PTR _vec_offset$[ebp+12], ax
	mov	WORD PTR _vec_offset$[ebp+14], ax

; 1498 :           MOV ECX,pairs      // Set up counter used for looping

	mov	ecx, DWORD PTR _pairs$[ebp]

; 1499 :           MOV EAX,src

	mov	eax, DWORD PTR _src$GSCopy$[ebp]

; 1500 :           MOV EBX,dst1

	mov	ebx, DWORD PTR _dst1$GSCopy$[ebp]

; 1501 :           MOV EDX,dst2

	mov	edx, DWORD PTR _dst2$GSCopy$[ebp]

; 1502 :           MOVD MM4,downshift

	movd	mm4, DWORD PTR _downshift$[ebp]

; 1503 :           MOVQ MM5,vec_offset

	movq	mm5, MMWORD PTR _vec_offset$[ebp]
$loop_shift_dilv64$21:

; 1504 : loop_shift_dilv64:
; 1505 :           MOVQ MM0,[EAX]      // Load first source quad

	movq	mm0, MMWORD PTR [eax]

; 1506 :           MOVQ MM1,[EAX+8]    // Load second source quad

	movq	mm1, MMWORD PTR [eax+8]

; 1507 :           PADDW MM0,MM5      // Add the offset to first quad

	paddw	mm0, mm5

; 1508 :           PSRAW MM0,MM4       // Apply downshift to first quad

	psraw	mm0, mm4

; 1509 :           PADDW MM1,MM5      // Add the offset to second quad

	paddw	mm1, mm5

; 1510 :           PSRAW MM1,MM4       // Apply the downshift to second quad

	psraw	mm1, mm4

; 1511 :           MOVQ MM2,MM0        // Make a copy of first shifted quad

	movq	mm2, mm0

; 1512 :           MOVQ MM3,MM1        // Make a copy of second shifted quad

	movq	mm3, mm1

; 1513 :           PSLLD MM0,16

	pslld	mm0, 16					; 00000010H

; 1514 :           PSRAD MM0,16        // Leaves sign extended copies of words 0 and 2

	psrad	mm0, 16					; 00000010H

; 1515 :           PSLLD MM1,16

	pslld	mm1, 16					; 00000010H

; 1516 :           PSRAD MM1,16        // Leaves sign extended copies of words 4 and 6

	psrad	mm1, 16					; 00000010H

; 1517 :           PACKSSDW MM0,MM1    // Leaves words 0,2,4,6 in MM0

	packssdw mm0, mm1

; 1518 :           MOVQ [EBX],MM0      // Save even indexed words in destination 1

	movq	MMWORD PTR [ebx], mm0

; 1519 :           PSRAD MM2,16        // Leaves sign extended copies of words 1 and 3

	psrad	mm2, 16					; 00000010H

; 1520 :           PSRAD MM3,16        // Leaves sign extended copies of words 5 and 7

	psrad	mm3, 16					; 00000010H

; 1521 :           PACKSSDW MM2,MM3    // Leaves words 1,3,5,7 in MM2

	packssdw mm2, mm3

; 1522 :           MOVQ [EDX],MM2      // Save odd indexed words in destination 2

	movq	MMWORD PTR [edx], mm2

; 1523 :           ADD EAX,16

	add	eax, 16					; 00000010H

; 1524 :           ADD EBX,8

	add	ebx, 8

; 1525 :           ADD EDX,8

	add	edx, 8

; 1526 :           SUB ECX,4

	sub	ecx, 4

; 1527 :           JG loop_shift_dilv64

	jg	SHORT $loop_shift_dilv64$21

; 1528 :           EMMS // Clear MMX registers for use by FPU

	emms

; 1495 : 
; 1496 :   // Implementation based on 64-bit operands, using only MMX instructions
; 1497 :   __asm {

	pop	ebx
$LN19@simd_downs:

; 1529 :     }
; 1530 :   return true;
; 1531 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_downshifted_deinterleave@@YA_NPAF00HH@Z ENDP	; simd_downshifted_deinterleave
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_deinterleave@@YA_NPAF00H@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_dst1$ = 12						; size = 4
_dst2$ = 16						; size = 4
_pairs$ = 20						; size = 4
?simd_deinterleave@@YA_NPAF00H@Z PROC			; simd_deinterleave, COMDAT

; 1370 : {

	push	ebp
	mov	ebp, esp

; 1371 :   if (kdu_mmx_level < 1)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 1	; kdu_mmx_level
	jge	SHORT $LN2@simd_deint

; 1372 :     return false;

	xor	al, al

; 1405 : }

	pop	ebp
	ret	0
$LN2@simd_deint:

; 1373 :   if (pairs <= 0)

	cmp	DWORD PTR _pairs$[ebp], 0
	jle	SHORT $LN5@simd_deint

; 1374 :     return true;
; 1375 : 
; 1376 :   // Implementation based on 64-bit operands, using only MMX instructions
; 1377 :   __asm {

	push	ebx

; 1378 :           MOV ECX,pairs      // Set up counter used for looping

	mov	ecx, DWORD PTR _pairs$[ebp]

; 1379 :           MOV EAX,src

	mov	eax, DWORD PTR _src$[ebp]

; 1380 :           MOV EBX,dst1

	mov	ebx, DWORD PTR _dst1$[ebp]

; 1381 :           MOV EDX,dst2

	mov	edx, DWORD PTR _dst2$[ebp]
$loop_dilv64$7:

; 1382 : loop_dilv64:
; 1383 :           MOVQ MM0,[EAX]      // Load first source quad

	movq	mm0, MMWORD PTR [eax]

; 1384 :           MOVQ MM1,[EAX+8]    // Load second source quad

	movq	mm1, MMWORD PTR [eax+8]

; 1385 :           MOVQ MM2,MM0        // Make a copy of first source quad

	movq	mm2, mm0

; 1386 :           MOVQ MM3,MM1        // Make a copy of second source quad

	movq	mm3, mm1

; 1387 :           PSLLD MM0,16

	pslld	mm0, 16					; 00000010H

; 1388 :           PSRAD MM0,16        // Leaves sign extended copies of words 0 and 2

	psrad	mm0, 16					; 00000010H

; 1389 :           PSLLD MM1,16

	pslld	mm1, 16					; 00000010H

; 1390 :           PSRAD MM1,16        // Leaves sign extended copies of words 4 and 6

	psrad	mm1, 16					; 00000010H

; 1391 :           PACKSSDW MM0,MM1    // Leaves words 0,2,4,6 in MM0

	packssdw mm0, mm1

; 1392 :           MOVQ [EBX],MM0      // Save even indexed words in destination 1

	movq	MMWORD PTR [ebx], mm0

; 1393 :           PSRAD MM2,16        // Leaves sign extended copies of words 1 and 3

	psrad	mm2, 16					; 00000010H

; 1394 :           PSRAD MM3,16        // Leaves sign extended copies of words 5 and 7

	psrad	mm3, 16					; 00000010H

; 1395 :           PACKSSDW MM2,MM3    // Leaves words 1,3,5,7 in MM2

	packssdw mm2, mm3

; 1396 :           MOVQ [EDX],MM2      // Save odd indexed words in destination 2

	movq	MMWORD PTR [edx], mm2

; 1397 :           ADD EAX,16

	add	eax, 16					; 00000010H

; 1398 :           ADD EBX,8

	add	ebx, 8

; 1399 :           ADD EDX,8

	add	edx, 8

; 1400 :           SUB ECX,4

	sub	ecx, 4

; 1401 :           JG loop_dilv64

	jg	SHORT $loop_dilv64$7

; 1402 :           EMMS // Clear MMX registers for use by FPU

	emms

; 1374 :     return true;
; 1375 : 
; 1376 :   // Implementation based on 64-bit operands, using only MMX instructions
; 1377 :   __asm {

	pop	ebx
$LN5@simd_deint:

; 1403 :     }
; 1404 :   return true;

	mov	al, 1

; 1405 : }

	pop	ebp
	ret	0
?simd_deinterleave@@YA_NPAF00H@Z ENDP			; simd_deinterleave
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_W9X7_v_analysis@@YA_NPAF000HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_step_idx$ = -56					; size = 4
_dst_out$GSCopy$ = -52					; size = 4
_dst_in$GSCopy$ = -48					; size = 4
_src2$GSCopy$ = -44					; size = 4
_src1$GSCopy$ = -40					; size = 4
_vec_preoff$ = -36					; size = 16
_vec_lambda$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_dst_in$ = 16						; size = 4
_dst_out$ = 20						; size = 4
_samples$ = 24						; size = 4
_step$ = 28						; size = 4
?simd_W9X7_v_analysis@@YA_NPAF000HPAUkd_lifting_step@@@Z PROC ; simd_W9X7_v_analysis, COMDAT

; 1035 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1036 :   if (kdu_mmx_level < 1)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 1	; kdu_mmx_level
	mov	eax, DWORD PTR _src1$[ebp]
	mov	DWORD PTR _src1$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _src2$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst_in$[ebp]
	mov	DWORD PTR _dst_in$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst_out$[ebp]
	mov	DWORD PTR _dst_out$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _step$[ebp]
	jge	SHORT $LN5@simd_W9X7_

; 1037 :     return false;

	xor	al, al

; 1139 :     }
; 1140 :   return true;
; 1141 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@simd_W9X7_:

; 1038 :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN19@simd_W9X7_

; 1039 :     return true;
; 1040 :   int step_idx = step->step_idx;

	movzx	eax, BYTE PTR [eax]
	push	ebx
	mov	DWORD PTR _step_idx$[ebp], eax
	push	esi

; 1041 :   assert((step_idx >= 0) && (step_idx < 4));
; 1042 :   kdu_int16 vec_lambda[8], vec_preoff[8];
; 1043 :   vec_lambda[0] = simd_w97_rem[step_idx];

	mov	cx, WORD PTR ?simd_w97_rem@@3PAFA[eax*2]

; 1044 :   vec_preoff[0] = simd_w97_preoff[step_idx];

	mov	ax, WORD PTR ?simd_w97_preoff@@3PAFA[eax*2]
	push	edi
	mov	WORD PTR _vec_lambda$[ebp], cx
	mov	WORD PTR _vec_preoff$[ebp], ax

; 1045 :   for (int k=1; k < 8; k++)
; 1046 :     {
; 1047 :       vec_lambda[k] = vec_lambda[0];

	mov	WORD PTR _vec_lambda$[ebp+2], cx

; 1048 :       vec_preoff[k] = vec_preoff[0];

	mov	WORD PTR _vec_preoff$[ebp+2], ax
	mov	WORD PTR _vec_lambda$[ebp+4], cx
	mov	WORD PTR _vec_preoff$[ebp+4], ax
	mov	WORD PTR _vec_lambda$[ebp+6], cx
	mov	WORD PTR _vec_preoff$[ebp+6], ax
	mov	WORD PTR _vec_lambda$[ebp+8], cx
	mov	WORD PTR _vec_preoff$[ebp+8], ax
	mov	WORD PTR _vec_lambda$[ebp+10], cx
	mov	WORD PTR _vec_preoff$[ebp+10], ax
	mov	WORD PTR _vec_lambda$[ebp+12], cx
	mov	WORD PTR _vec_preoff$[ebp+12], ax
	mov	WORD PTR _vec_lambda$[ebp+14], cx
	mov	WORD PTR _vec_preoff$[ebp+14], ax

; 1053 :           MOV EDX,samples // Set limit for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 1054 :           MOV EAX,src1

	mov	eax, DWORD PTR _src1$GSCopy$[ebp]

; 1055 :           MOV EBX,src2

	mov	ebx, DWORD PTR _src2$GSCopy$[ebp]

; 1056 :           MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$GSCopy$[ebp]

; 1057 :           MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$GSCopy$[ebp]

; 1058 :           MOVQ MM0,vec_lambda

	movq	mm0, MMWORD PTR _vec_lambda$[ebp]

; 1059 :           MOVQ MM1,vec_preoff

	movq	mm1, MMWORD PTR _vec_preoff$[ebp]

; 1060 :           MOV ECX,step_idx

	mov	ecx, DWORD PTR _step_idx$[ebp]

; 1061 :           CMP ECX,3

	cmp	ecx, 3

; 1062 :           JZ start_step3_analysis64

	je	$start_step3_analysis64$21

; 1063 :           CMP ECX,2

	cmp	ecx, 2

; 1064 :           JZ start_step2_analysis64

	je	SHORT $start_step2_analysis64$22

; 1065 :           CMP ECX,1

	cmp	ecx, 1

; 1066 :           JZ start_step1_analysis64

	je	SHORT $start_step1_analysis64$23

; 1067 : 
; 1068 :           XOR ECX,ECX   // Not really necessary

	xor	ecx, ecx
$loop_step0_analysis64$24:

; 1069 : loop_step0_analysis64:
; 1070 :           MOVQ MM2,[EAX+2*ECX]     // Start with source sample 1

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 1071 :           PADDW MM2,[EBX+2*ECX]   // Add source sample 2

	paddw	mm2, MMWORD PTR [ebx+ecx*2]

; 1072 :           MOVQ MM3,[ESI+2*ECX]

	movq	mm3, MMWORD PTR [esi+ecx*2]

; 1073 :           PSUBW MM3,MM2     // Here is a -1 contribution

	psubw	mm3, mm2

; 1074 :           PSUBW MM3,MM2     // Here is another -1 contribution

	psubw	mm3, mm2

; 1075 :           PADDW MM2,MM1     // Add pre-offset for rounding

	paddw	mm2, mm1

; 1076 :           PMULHW MM2,MM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 1077 :           PADDW MM3,MM2     // Final contribution

	paddw	mm3, mm2

; 1078 :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 1079 :           ADD ECX,4

	add	ecx, 4

; 1080 :           CMP ECX,EDX

	cmp	ecx, edx

; 1081 :           JL loop_step0_analysis64

	jl	SHORT $loop_step0_analysis64$24

; 1082 :           JMP end_analysis64

	jmp	$end_analysis64$25
$start_step1_analysis64$23:

; 1083 : 
; 1084 : start_step1_analysis64:
; 1085 :           XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx

; 1086 :           PXOR MM6,MM6    // Set MM6 to 0's

	pxor	mm6, mm6

; 1087 :           PCMPEQW MM7,MM7 // Set MM7 to 1's

	pcmpeqw	mm7, mm7

; 1088 :           PSUBW MM6,MM7   // Leaves each word in MM6 equal to 1

	psubw	mm6, mm7

; 1089 :           PSLLW MM6,2     // Leave each word in MM6 = 4 (rounding offset)

	psllw	mm6, 2
$loop_step1_analysis64$26:

; 1090 : loop_step1_analysis64:
; 1091 :           MOVQ MM2,[EAX+2*ECX]   // Get source samples 1 to MM2

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 1092 :           PMULHW MM2,MM0         // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 1093 :           PXOR MM4,MM4

	pxor	mm4, mm4

; 1094 :           PSUBW MM4,[EBX+2*ECX] // Get -ve source samples 2 to MM4

	psubw	mm4, MMWORD PTR [ebx+ecx*2]

; 1095 :           PMULHW MM4,MM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	mm4, mm0

; 1096 :           MOVQ MM3,[ESI+2*ECX]

	movq	mm3, MMWORD PTR [esi+ecx*2]

; 1097 :           PSUBW MM2,MM4     // Subtract from non-negated scaled source samples

	psubw	mm2, mm4

; 1098 :           PADDW MM2,MM6     // Add post-offset for rounding

	paddw	mm2, mm6

; 1099 :           PSRAW MM2,3        // Shift result to the right by 3

	psraw	mm2, 3

; 1100 :           PADDW MM3,MM2     // Update destination samples

	paddw	mm3, mm2

; 1101 :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 1102 :           ADD ECX,4

	add	ecx, 4

; 1103 :           CMP ECX,EDX

	cmp	ecx, edx

; 1104 :           JL loop_step1_analysis64

	jl	SHORT $loop_step1_analysis64$26

; 1105 :           JMP end_analysis64

	jmp	SHORT $end_analysis64$25
$start_step2_analysis64$22:

; 1106 : 
; 1107 : start_step2_analysis64:
; 1108 :           XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx
$loop_step2_analysis64$27:

; 1109 : loop_step2_analysis64:
; 1110 :           MOVQ MM2,[EAX+2*ECX]     // Start with source sample 1

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 1111 :           PADDW MM2,[EBX+2*ECX]   // Add source sample 2

	paddw	mm2, MMWORD PTR [ebx+ecx*2]

; 1112 :           MOVQ MM3,[ESI+2*ECX]

	movq	mm3, MMWORD PTR [esi+ecx*2]

; 1113 :           PADDW MM3,MM2     // Here is a +1 contribution

	paddw	mm3, mm2

; 1114 :           PADDW MM2,MM1     // Add pre-offset for rounding

	paddw	mm2, mm1

; 1115 :           PMULHW MM2,MM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 1116 :           PADDW MM3,MM2     // Final contribution

	paddw	mm3, mm2

; 1117 :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 1118 :           ADD ECX,4

	add	ecx, 4

; 1119 :           CMP ECX,EDX

	cmp	ecx, edx

; 1120 :           JL loop_step2_analysis64

	jl	SHORT $loop_step2_analysis64$27

; 1121 :           JMP end_analysis64

	jmp	SHORT $end_analysis64$25
$start_step3_analysis64$21:

; 1122 : 
; 1123 : start_step3_analysis64:
; 1124 :           XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx
$loop_step3_analysis64$28:

; 1125 : loop_step3_analysis64:
; 1126 :           MOVQ MM2,[EAX+2*ECX]     // Start with source sample 1

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 1127 :           PADDW MM2,[EBX+2*ECX]   // Add source sample 2

	paddw	mm2, MMWORD PTR [ebx+ecx*2]

; 1128 :           MOVQ MM3,[ESI+2*ECX]

	movq	mm3, MMWORD PTR [esi+ecx*2]

; 1129 :           PADDW MM2,MM1           // Add pre-offset for rounding

	paddw	mm2, mm1

; 1130 :           PMULHW MM2,MM0           // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 1131 :           PADDW MM3,MM2           // Final contribution

	paddw	mm3, mm2

; 1132 :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 1133 :           ADD ECX,4

	add	ecx, 4

; 1134 :           CMP ECX,EDX

	cmp	ecx, edx

; 1135 :           JL loop_step3_analysis64

	jl	SHORT $loop_step3_analysis64$28
$end_analysis64$25:

; 1136 : 
; 1137 : end_analysis64:
; 1138 :           EMMS               // Clear MMX registers for use by FPU

	emms

; 1049 :     }
; 1050 : 
; 1051 :   // Implementation based on 64-bit operands, using only MMX instructions
; 1052 :   __asm {         

	pop	edi
	pop	esi
	pop	ebx
$LN19@simd_W9X7_:

; 1139 :     }
; 1140 :   return true;
; 1141 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_W9X7_v_analysis@@YA_NPAF000HPAUkd_lifting_step@@@Z ENDP ; simd_W9X7_v_analysis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_W9X7_h_analysis@@YA_NPAF0HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_step_idx$ = -48					; size = 4
_dst$GSCopy$ = -44					; size = 4
_src$GSCopy$ = -40					; size = 4
_vec_preoff$ = -36					; size = 16
_vec_lambda$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_samples$ = 16						; size = 4
_step$ = 20						; size = 4
?simd_W9X7_h_analysis@@YA_NPAF0HPAUkd_lifting_step@@@Z PROC ; simd_W9X7_h_analysis, COMDAT

; 692  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 693  :   if (kdu_mmx_level < 1)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 1	; kdu_mmx_level
	mov	eax, DWORD PTR _src$[ebp]
	mov	DWORD PTR _src$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst$[ebp]
	mov	DWORD PTR _dst$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _step$[ebp]
	jge	SHORT $LN5@simd_W9X7_

; 694  :     return false;

	xor	al, al

; 794  :     }
; 795  :   return true;
; 796  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@simd_W9X7_:

; 695  :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN19@simd_W9X7_

; 696  :     return true;
; 697  :   int step_idx = step->step_idx;

	movzx	eax, BYTE PTR [eax]
	mov	DWORD PTR _step_idx$[ebp], eax
	push	edi

; 698  :   assert((step_idx >= 0) && (step_idx < 4));
; 699  :   kdu_int16 vec_lambda[8], vec_preoff[8];
; 700  :   vec_lambda[0] = simd_w97_rem[step_idx];

	mov	cx, WORD PTR ?simd_w97_rem@@3PAFA[eax*2]

; 701  :   vec_preoff[0] = simd_w97_preoff[step_idx];

	mov	ax, WORD PTR ?simd_w97_preoff@@3PAFA[eax*2]
	mov	WORD PTR _vec_lambda$[ebp], cx
	mov	WORD PTR _vec_preoff$[ebp], ax

; 702  :   for (int k=1; k < 8; k++)
; 703  :     {
; 704  :       vec_lambda[k] = vec_lambda[0];

	mov	WORD PTR _vec_lambda$[ebp+2], cx

; 705  :       vec_preoff[k] = vec_preoff[0];

	mov	WORD PTR _vec_preoff$[ebp+2], ax
	mov	WORD PTR _vec_lambda$[ebp+4], cx
	mov	WORD PTR _vec_preoff$[ebp+4], ax
	mov	WORD PTR _vec_lambda$[ebp+6], cx
	mov	WORD PTR _vec_preoff$[ebp+6], ax
	mov	WORD PTR _vec_lambda$[ebp+8], cx
	mov	WORD PTR _vec_preoff$[ebp+8], ax
	mov	WORD PTR _vec_lambda$[ebp+10], cx
	mov	WORD PTR _vec_preoff$[ebp+10], ax
	mov	WORD PTR _vec_lambda$[ebp+12], cx
	mov	WORD PTR _vec_preoff$[ebp+12], ax
	mov	WORD PTR _vec_lambda$[ebp+14], cx
	mov	WORD PTR _vec_preoff$[ebp+14], ax

; 710  :           MOV EDX,samples // Set limit for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 711  :           MOV EAX,src

	mov	eax, DWORD PTR _src$GSCopy$[ebp]

; 712  :           MOV EDI,dst

	mov	edi, DWORD PTR _dst$GSCopy$[ebp]

; 713  :           MOVQ MM0,vec_lambda

	movq	mm0, MMWORD PTR _vec_lambda$[ebp]

; 714  :           MOVQ MM1,vec_preoff

	movq	mm1, MMWORD PTR _vec_preoff$[ebp]

; 715  :           MOV ECX,step_idx

	mov	ecx, DWORD PTR _step_idx$[ebp]

; 716  :           CMP ECX,3

	cmp	ecx, 3

; 717  :           JZ start_step3_analysis64

	je	$start_step3_analysis64$21

; 718  :           CMP ECX,2

	cmp	ecx, 2

; 719  :           JZ start_step2_analysis64

	je	SHORT $start_step2_analysis64$22

; 720  :           CMP ECX,1

	cmp	ecx, 1

; 721  :           JZ start_step1_analysis64

	je	SHORT $start_step1_analysis64$23

; 722  : 
; 723  :           XOR ECX,ECX   // Not really necessary

	xor	ecx, ecx
$loop_step0_analysis64$24:

; 724  : loop_step0_analysis64:
; 725  :           MOVQ MM2,[EAX+2*ECX]     // Start with source sample 1

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 726  :           PADDW MM2,[EAX+2*ECX+2]   // Add source sample 2

	paddw	mm2, MMWORD PTR [eax+ecx*2+2]

; 727  :           MOVQ MM3,[EDI+2*ECX]

	movq	mm3, MMWORD PTR [edi+ecx*2]

; 728  :           PSUBW MM3,MM2     // Here is a -1 contribution

	psubw	mm3, mm2

; 729  :           PSUBW MM3,MM2     // Here is another -1 contribution

	psubw	mm3, mm2

; 730  :           PADDW MM2,MM1     // Add pre-offset for rounding

	paddw	mm2, mm1

; 731  :           PMULHW MM2,MM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 732  :           PADDW MM3,MM2     // Final contribution

	paddw	mm3, mm2

; 733  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 734  :           ADD ECX,4

	add	ecx, 4

; 735  :           CMP ECX,EDX

	cmp	ecx, edx

; 736  :           JL loop_step0_analysis64

	jl	SHORT $loop_step0_analysis64$24

; 737  :           JMP end_analysis64

	jmp	$end_analysis64$25
$start_step1_analysis64$23:

; 738  : 
; 739  : start_step1_analysis64:
; 740  :           XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx

; 741  :           PXOR MM6,MM6    // Set MM6 to 0's

	pxor	mm6, mm6

; 742  :           PCMPEQW MM7,MM7 // Set MM7 to 1's

	pcmpeqw	mm7, mm7

; 743  :           PSUBW MM6,MM7   // Leaves each word in MM6 equal to 1

	psubw	mm6, mm7

; 744  :           PSLLW MM6,2     // Leave each word in MM6 = 4 (rounding offset)

	psllw	mm6, 2
$loop_step1_analysis64$26:

; 745  : loop_step1_analysis64:
; 746  :           MOVQ MM2,[EAX+2*ECX]   // Get source samples 1 to MM2

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 747  :           PMULHW MM2,MM0         // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 748  :           PXOR MM4,MM4

	pxor	mm4, mm4

; 749  :           PSUBW MM4,[EAX+2*ECX+2] // Get -ve source samples 2 to MM4

	psubw	mm4, MMWORD PTR [eax+ecx*2+2]

; 750  :           PMULHW MM4,MM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	mm4, mm0

; 751  :           MOVQ MM3,[EDI+2*ECX]

	movq	mm3, MMWORD PTR [edi+ecx*2]

; 752  :           PSUBW MM2,MM4     // Subtract from non-negated scaled source samples

	psubw	mm2, mm4

; 753  :           PADDW MM2,MM6     // Add post-offset for rounding

	paddw	mm2, mm6

; 754  :           PSRAW MM2,3        // Shift result to the right by 3

	psraw	mm2, 3

; 755  :           PADDW MM3,MM2     // Update destination samples

	paddw	mm3, mm2

; 756  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 757  :           ADD ECX,4

	add	ecx, 4

; 758  :           CMP ECX,EDX

	cmp	ecx, edx

; 759  :           JL loop_step1_analysis64

	jl	SHORT $loop_step1_analysis64$26

; 760  :           JMP end_analysis64

	jmp	SHORT $end_analysis64$25
$start_step2_analysis64$22:

; 761  : 
; 762  : start_step2_analysis64:
; 763  :           XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx
$loop_step2_analysis64$27:

; 764  : loop_step2_analysis64:
; 765  :           MOVQ MM2,[EAX+2*ECX]     // Start with source sample 1

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 766  :           PADDW MM2,[EAX+2*ECX+2]   // Add source sample 2

	paddw	mm2, MMWORD PTR [eax+ecx*2+2]

; 767  :           MOVQ MM3,[EDI+2*ECX]

	movq	mm3, MMWORD PTR [edi+ecx*2]

; 768  :           PADDW MM3,MM2     // Here is a +1 contribution

	paddw	mm3, mm2

; 769  :           PADDW MM2,MM1     // Add pre-offset for rounding

	paddw	mm2, mm1

; 770  :           PMULHW MM2,MM0     // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 771  :           PADDW MM3,MM2     // Final contribution

	paddw	mm3, mm2

; 772  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 773  :           ADD ECX,4

	add	ecx, 4

; 774  :           CMP ECX,EDX

	cmp	ecx, edx

; 775  :           JL loop_step2_analysis64

	jl	SHORT $loop_step2_analysis64$27

; 776  :           JMP end_analysis64

	jmp	SHORT $end_analysis64$25
$start_step3_analysis64$21:

; 777  : 
; 778  : start_step3_analysis64:
; 779  :           XOR ECX,ECX     // Zero sample counter

	xor	ecx, ecx
$loop_step3_analysis64$28:

; 780  : loop_step3_analysis64:
; 781  :           MOVQ MM2,[EAX+2*ECX]     // Start with source sample 1

	movq	mm2, MMWORD PTR [eax+ecx*2]

; 782  :           PADDW MM2,[EAX+2*ECX+2] // Add source sample 2

	paddw	mm2, MMWORD PTR [eax+ecx*2+2]

; 783  :           MOVQ MM3,[EDI+2*ECX]

	movq	mm3, MMWORD PTR [edi+ecx*2]

; 784  :           PADDW MM2,MM1           // Add pre-offset for rounding

	paddw	mm2, mm1

; 785  :           PMULHW MM2,MM0           // Multiply by lambda and discard 16 LSB's

	pmulhw	mm2, mm0

; 786  :           PADDW MM3,MM2           // Final contribution

	paddw	mm3, mm2

; 787  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 788  :           ADD ECX,4

	add	ecx, 4

; 789  :           CMP ECX,EDX

	cmp	ecx, edx

; 790  :           JL loop_step3_analysis64

	jl	SHORT $loop_step3_analysis64$28
$end_analysis64$25:

; 791  : 
; 792  : end_analysis64:
; 793  :           EMMS               // Clear MMX registers for use by FPU

	emms

; 706  :     }
; 707  : 
; 708  :   // Implementation based on 64-bit operands using only MMX instructions
; 709  :   __asm {         

	pop	edi
$LN19@simd_W9X7_:

; 794  :     }
; 795  :   return true;
; 796  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_W9X7_h_analysis@@YA_NPAF0HPAUkd_lifting_step@@@Z ENDP ; simd_W9X7_h_analysis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_W5X3_v_analysis@@YA_NPAF000HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_int_coeff$ = -44					; size = 4
_downshift$ = -40					; size = 4
_dst_out$GSCopy$ = -36					; size = 4
_dst_in$GSCopy$ = -32					; size = 4
_src2$GSCopy$ = -28					; size = 4
_src1$GSCopy$ = -24					; size = 4
_vec_offset$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_src1$ = 8						; size = 4
_src2$ = 12						; size = 4
_dst_in$ = 16						; size = 4
_dst_out$ = 20						; size = 4
_samples$ = 24						; size = 4
_step$ = 28						; size = 4
?simd_W5X3_v_analysis@@YA_NPAF000HPAUkd_lifting_step@@@Z PROC ; simd_W5X3_v_analysis, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 518  :   assert((step->support_length == 2) && (step->icoeffs[0]==step->icoeffs[1]));
; 519  :   if (kdu_mmx_level < 1)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 1	; kdu_mmx_level
	mov	eax, DWORD PTR _src1$[ebp]
	mov	edx, DWORD PTR _step$[ebp]
	mov	DWORD PTR _src1$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _src2$[ebp]
	mov	DWORD PTR _src2$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst_in$[ebp]
	mov	DWORD PTR _dst_in$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dst_out$[ebp]
	mov	DWORD PTR _dst_out$GSCopy$[ebp], eax
	jge	SHORT $LN5@simd_W5X3_

; 520  :     return false;

	xor	al, al

; 570  :     }
; 571  :   return true;
; 572  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@simd_W5X3_:

; 521  :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN19@simd_W5X3_

; 522  :     return true;
; 523  : 
; 524  :   kdu_int16 vec_offset[8];
; 525  :   vec_offset[0] = (kdu_int16)((1<<step->downshift)>>1);

	movzx	ecx, BYTE PTR [edx+2]
	mov	eax, 1
	shl	eax, cl
	sar	eax, 1
	mov	WORD PTR _vec_offset$[ebp], ax

; 526  :   for (int k=1; k < 8; k++)
; 527  :     vec_offset[k] = vec_offset[0];

	mov	WORD PTR _vec_offset$[ebp+2], ax
	mov	WORD PTR _vec_offset$[ebp+4], ax
	mov	WORD PTR _vec_offset$[ebp+6], ax
	mov	WORD PTR _vec_offset$[ebp+8], ax
	mov	WORD PTR _vec_offset$[ebp+10], ax
	mov	WORD PTR _vec_offset$[ebp+12], ax
	mov	WORD PTR _vec_offset$[ebp+14], ax

; 528  :   int int_coeff = step->icoeffs[0];

	mov	eax, DWORD PTR [edx+12]
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _int_coeff$[ebp], eax

; 529  :   int downshift = step->downshift;

	mov	DWORD PTR _downshift$[ebp], ecx

; 534  :         MOV EDX,samples // Limit for ECX

	mov	edx, DWORD PTR _samples$[ebp]

; 535  :         MOV EAX,src1

	mov	eax, DWORD PTR _src1$GSCopy$[ebp]

; 536  :         MOV EBX,src2

	mov	ebx, DWORD PTR _src2$GSCopy$[ebp]

; 537  :         MOV ESI,dst_in

	mov	esi, DWORD PTR _dst_in$GSCopy$[ebp]

; 538  :         MOV EDI,dst_out

	mov	edi, DWORD PTR _dst_out$GSCopy$[ebp]

; 539  :         MOVQ MM0,vec_offset

	movq	mm0, MMWORD PTR _vec_offset$[ebp]

; 540  :         MOVD MM1,downshift

	movd	mm1, DWORD PTR _downshift$[ebp]

; 541  :         MOV ECX,int_coeff

	mov	ecx, DWORD PTR _int_coeff$[ebp]

; 542  :         CMP ECX,1

	cmp	ecx, 1

; 543  :         MOV ECX,0  // Set up sample counter, without altering status flags

	mov	ecx, 0

; 544  :         JNE loop_minus1_analysis64

	jne	SHORT $loop_minus1_analysis64$21
$loop_plus1_analysis64$22:

; 545  : loop_plus1_analysis64:
; 546  :           MOVQ MM2,MM0             // start with the offset

	movq	mm2, mm0

; 547  :           PADDW MM2,[EAX+2*ECX]   // add 1'st source sample

	paddw	mm2, MMWORD PTR [eax+ecx*2]

; 548  :           PADDW MM2,[EBX+2*ECX]   // add 2'nd source sample

	paddw	mm2, MMWORD PTR [ebx+ecx*2]

; 549  :           MOVQ MM3,[ESI+2*ECX]

	movq	mm3, MMWORD PTR [esi+ecx*2]

; 550  :           PSRAW MM2,MM1            // shift rigth by the `downshift' value

	psraw	mm2, mm1

; 551  :           PADDW MM3,MM2           // add to dest sample

	paddw	mm3, mm2

; 552  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 553  :           ADD ECX,4

	add	ecx, 4

; 554  :           CMP ECX,EDX

	cmp	ecx, edx

; 555  :           JL loop_plus1_analysis64

	jl	SHORT $loop_plus1_analysis64$22

; 556  :         JMP end_analysis64

	jmp	SHORT $end_analysis64$23
$loop_minus1_analysis64$21:

; 557  : loop_minus1_analysis64:
; 558  :           MOVQ MM2,MM0             // start with the offset

	movq	mm2, mm0

; 559  :           PSUBW MM2,[EAX+2*ECX]   // subtract 1'st source sample

	psubw	mm2, MMWORD PTR [eax+ecx*2]

; 560  :           PSUBW MM2,[EBX+2*ECX]   // subtract 2'nd source sample

	psubw	mm2, MMWORD PTR [ebx+ecx*2]

; 561  :           MOVQ MM3,[ESI+2*ECX]

	movq	mm3, MMWORD PTR [esi+ecx*2]

; 562  :           PSRAW MM2,MM1            // shift rigth by the `downshift' value

	psraw	mm2, mm1

; 563  :           PADDW MM3,MM2           // add to dest sample

	paddw	mm3, mm2

; 564  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 565  :           ADD ECX,4

	add	ecx, 4

; 566  :           CMP ECX,EDX

	cmp	ecx, edx

; 567  :           JL loop_minus1_analysis64

	jl	SHORT $loop_minus1_analysis64$21
$end_analysis64$23:

; 568  : end_analysis64:
; 569  :         EMMS // Clear MMX registers for use by FPU

	emms

; 530  :   assert((int_coeff == 1) || (int_coeff == -1));
; 531  : 
; 532  :   // Implementation based on 64-bit operands using only MMX instructions
; 533  :   __asm {

	pop	edi
	pop	esi
	pop	ebx
$LN19@simd_W5X3_:

; 570  :     }
; 571  :   return true;
; 572  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?simd_W5X3_v_analysis@@YA_NPAF000HPAUkd_lifting_step@@@Z ENDP ; simd_W5X3_v_analysis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ?simd_W5X3_h_analysis@@YA_NPAF0HPAUkd_lifting_step@@@Z
_TEXT	SEGMENT
_vec_offset$ = -16					; size = 8
_int_coeff$ = -8					; size = 4
_downshift$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_samples$ = 16						; size = 4
_step$ = 20						; size = 4
?simd_W5X3_h_analysis@@YA_NPAF0HPAUkd_lifting_step@@@Z PROC ; simd_W5X3_h_analysis, COMDAT

; 392  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 393  :   assert((step->support_length == 2) && (step->icoeffs[0]==step->icoeffs[1]));
; 394  :   if (kdu_mmx_level < 1)

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 1	; kdu_mmx_level
	jge	SHORT $LN2@simd_W5X3_

; 395  :     return false;

	xor	al, al

; 444  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@simd_W5X3_:

; 396  :   if (samples <= 0)

	cmp	DWORD PTR _samples$[ebp], 0
	jle	$LN5@simd_W5X3_

; 397  :     return true;
; 398  : 
; 399  :   kdu_int16 vec_offset[4];
; 400  :   vec_offset[0] = vec_offset[1] = vec_offset[2] =

	mov	edx, DWORD PTR _step$[ebp]
	mov	eax, 1
	push	ebx
	push	edi
	movzx	ecx, BYTE PTR [edx+2]
	shl	eax, cl
	sar	eax, 1
	mov	WORD PTR _vec_offset$[ebp+6], ax
	mov	WORD PTR _vec_offset$[ebp+4], ax
	mov	WORD PTR _vec_offset$[ebp+2], ax
	mov	WORD PTR _vec_offset$[ebp], ax

; 401  :     vec_offset[3] = (kdu_int16)((1<<step->downshift)>>1);
; 402  :   int int_coeff = step->icoeffs[0];

	mov	eax, DWORD PTR [edx+12]

; 403  :   int downshift = step->downshift;

	mov	DWORD PTR _downshift$[ebp], ecx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _int_coeff$[ebp], eax

; 408  :         XOR ECX,ECX     // Zero out sample counter

	xor	ecx, ecx

; 409  :         MOV EDX,samples // Limit for sample counter

	mov	edx, DWORD PTR _samples$[ebp]

; 410  :         MOV EAX,src

	mov	eax, DWORD PTR _src$[ebp]

; 411  :         MOV EDI,dst

	mov	edi, DWORD PTR _dst$[ebp]

; 412  :         MOVQ MM0,vec_offset

	movq	mm0, MMWORD PTR _vec_offset$[ebp]

; 413  :         MOVD MM1,downshift

	movd	mm1, DWORD PTR _downshift$[ebp]

; 414  :         MOV EBX,int_coeff

	mov	ebx, DWORD PTR _int_coeff$[ebp]

; 415  :         CMP EBX,1

	cmp	ebx, 1

; 416  :         JNE loop_minus1_analysis64

	jne	SHORT $loop_minus1_analysis64$7
$loop_plus1_analysis64$8:

; 417  : loop_plus1_analysis64:
; 418  :           MOVQ MM2,MM0               // start with the offset

	movq	mm2, mm0

; 419  :           PADDW MM2,[EAX+2*ECX]     // add 1'st source sample

	paddw	mm2, MMWORD PTR [eax+ecx*2]

; 420  :           PADDW MM2,[EAX+2*ECX+2]   // add 2'nd source sample

	paddw	mm2, MMWORD PTR [eax+ecx*2+2]

; 421  :           MOVQ MM3,[EDI+2*ECX]

	movq	mm3, MMWORD PTR [edi+ecx*2]

; 422  :           PSRAW MM2,MM1              // shift rigth by the `downshift' value

	psraw	mm2, mm1

; 423  :           PADDW MM3,MM2             // add to dest sample

	paddw	mm3, mm2

; 424  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 425  :           ADD ECX,4

	add	ecx, 4

; 426  :           CMP ECX,EDX

	cmp	ecx, edx

; 427  :           JL loop_plus1_analysis64

	jl	SHORT $loop_plus1_analysis64$8

; 428  :         JMP end_analysis64

	jmp	SHORT $end_analysis64$9
$loop_minus1_analysis64$7:

; 429  : loop_minus1_analysis64:
; 430  :           MOVQ MM2,MM0               // start with the offset

	movq	mm2, mm0

; 431  :           PSUBW MM2,[EAX+2*ECX]     // subtract 1'st source sample

	psubw	mm2, MMWORD PTR [eax+ecx*2]

; 432  :           PSUBW MM2,[EAX+2*ECX+2]   // subtract 2'nd source sample

	psubw	mm2, MMWORD PTR [eax+ecx*2+2]

; 433  :           MOVQ MM3,[EDI+2*ECX]

	movq	mm3, MMWORD PTR [edi+ecx*2]

; 434  :           PSRAW MM2,MM1              // shift rigth by the `downshift' value

	psraw	mm2, mm1

; 435  :           PADDW MM3,MM2             // add to dest sample

	paddw	mm3, mm2

; 436  :           MOVQ [EDI+2*ECX],MM3

	movq	MMWORD PTR [edi+ecx*2], mm3

; 437  :           ADD ECX,4

	add	ecx, 4

; 438  :           CMP ECX,EDX

	cmp	ecx, edx

; 439  :           JL loop_minus1_analysis64

	jl	SHORT $loop_minus1_analysis64$7
$end_analysis64$9:

; 440  : end_analysis64:
; 441  :         EMMS // Clear MMX registers for use by FPU

	emms

; 404  :   assert((int_coeff == 1) || (int_coeff == -1));
; 405  : 
; 406  :   // Implementation based on 64-bit operands using only MMX instructions
; 407  :   __asm {

	pop	edi
	pop	ebx
$LN5@simd_W5X3_:

; 442  :     }
; 443  :   return true;

	mov	al, 1

; 444  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?simd_W5X3_h_analysis@@YA_NPAF0HPAUkd_lifting_step@@@Z ENDP ; simd_W5X3_h_analysis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ??__Esimd_w97_preoff@@YAXXZ
text$di	SEGMENT
tv89 = -8						; size = 8
tv81 = -8						; size = 8
tv75 = -8						; size = 8
??__Esimd_w97_preoff@@YAXXZ PROC			; `dynamic initializer for 'simd_w97_preoff'', COMDAT

; 68   :    (kdu_int16) floor(0.5 + 0.5/W97_FACT_3)};

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 65   :   {(kdu_int16) floor(0.5 + 0.5/(W97_FACT_0+2.0)),

	fld	QWORD PTR __real@3ffb5477208894d9
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv75[ebp]
	cvttsd2si eax, QWORD PTR tv75[ebp]

; 66   :    0,
; 67   :    (kdu_int16) floor(0.5 + 0.5/(W97_FACT_2-1.0)),

	fld	QWORD PTR __real@c00e297d9a2f0174
	fstp	QWORD PTR [esp]
	mov	WORD PTR ?simd_w97_preoff@@3PAFA, ax
	call	_floor
	fstp	QWORD PTR tv81[ebp]
	cvttsd2si eax, QWORD PTR tv81[ebp]

; 68   :    (kdu_int16) floor(0.5 + 0.5/W97_FACT_3)};

	fld	QWORD PTR __real@3ffa09bdc981b97a
	fstp	QWORD PTR [esp]
	mov	WORD PTR ?simd_w97_preoff@@3PAFA+4, ax
	call	_floor
	fstp	QWORD PTR tv89[ebp]
	cvttsd2si eax, QWORD PTR tv89[ebp]
	add	esp, 8
	mov	WORD PTR ?simd_w97_preoff@@3PAFA+6, ax
	mov	esp, ebp
	pop	ebp
	ret	0
??__Esimd_w97_preoff@@YAXXZ ENDP			; `dynamic initializer for 'simd_w97_preoff''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\msvc_dwt_mmx_local.h
;	COMDAT ??__Esimd_w97_rem@@YAXXZ
text$di	SEGMENT
tv164 = -8						; size = 8
tv92 = -8						; size = 8
tv84 = -8						; size = 8
tv79 = -8						; size = 8
??__Esimd_w97_rem@@YAXXZ PROC				; `dynamic initializer for 'simd_w97_rem'', COMDAT

; 63   :    (kdu_int16) floor(0.5 + W97_FACT_3*(double)(1<<16))};

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 60   :   {(kdu_int16) floor(0.5 + (W97_FACT_0+2.0)*(double)(1<<16)),

	fld	QWORD PTR __real@40da7ce680000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv79[ebp]
	cvttsd2si eax, QWORD PTR tv79[ebp]

; 61   :    (kdu_int16) floor(0.5 + W97_FACT_1*(double)(1<<19)),

	fld	QWORD PTR __real@c0db2015c0000000
	fstp	QWORD PTR [esp]
	mov	WORD PTR ?simd_w97_rem@@3PAFA, ax
	call	_floor
	fstp	QWORD PTR tv84[ebp]
	cvttsd2si eax, QWORD PTR tv84[ebp]

; 62   :    (kdu_int16) floor(0.5 + (W97_FACT_2-1.0)*(double)(1<<16)),

	fld	QWORD PTR __real@c0bdf90a00000000
	fstp	QWORD PTR [esp]
	mov	WORD PTR ?simd_w97_rem@@3PAFA+2, ax
	call	_floor
	fstp	QWORD PTR tv92[ebp]
	cvttsd2si eax, QWORD PTR tv92[ebp]

; 63   :    (kdu_int16) floor(0.5 + W97_FACT_3*(double)(1<<16))};

	fld	QWORD PTR __real@40dc628aa0000000
	fstp	QWORD PTR [esp]
	mov	WORD PTR ?simd_w97_rem@@3PAFA+4, ax
	call	_floor
	fstp	QWORD PTR tv164[ebp]
	cvttsd2si eax, QWORD PTR tv164[ebp]
	add	esp, 8
	mov	WORD PTR ?simd_w97_rem@@3PAFA+6, ax
	mov	esp, ebp
	pop	ebp
	ret	0
??__Esimd_w97_rem@@YAXXZ ENDP				; `dynamic initializer for 'simd_w97_rem''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_analysis@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_analysis@@MAEPAXI@Z PROC				; kd_analysis::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_analysis@@MAE@XZ			; kd_analysis::~kd_analysis
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	704					; 000002c0H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_analysis@@MAEPAXI@Z ENDP				; kd_analysis::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
;	COMDAT ?horizontal_analysis@kd_analysis@@AAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_downshift$1$ = -64					; size = 4
tv4775 = -60						; size = 4
_offset$1$ = -56					; size = 4
_cpp$1$ = -56						; size = 4
_i_lambda$1$ = -56					; size = 4
_downshift$1$ = -56					; size = 4
tv4758 = -56						; size = 4
_k$8$ = -52						; size = 4
_k$6$ = -52						; size = 4
_esp$1$ = -48						; size = 4
_cpp$1$ = -48						; size = 4
_i_lambda$1$ = -48					; size = 4
_k$7$ = -48						; size = 4
tv4729 = -48						; size = 4
_esp$1$ = -48						; size = 4
_sp$2$ = -44						; size = 4
_k$3$ = -44						; size = 4
tv4772 = -44						; size = 4
tv4761 = -44						; size = 4
$T1 = -40						; size = 4
_offset$1$ = -40					; size = 4
tv4730 = -40						; size = 4
$T2 = -36						; size = 4
_cpp$1$ = -32						; size = 4
_t$1$ = -32						; size = 4
_offset$1$ = -32					; size = 4
_sp$1$ = -32						; size = 4
_offset$1$ = -32					; size = 4
_dp$1$ = -32						; size = 4
$T3 = -28						; size = 4
_dp$1$ = -28						; size = 4
_sp$1$ = -28						; size = 4
tv4734 = -24						; size = 4
_width$1$ = -24						; size = 4
_sum$1$ = -20						; size = 4
_support$1$ = -20					; size = 4
_step$1$ = -20						; size = 4
_s$1$ = -16						; size = 4
_support$1$ = -12					; size = 4
_sum$1$ = -12						; size = 4
_c$1$ = -12						; size = 4
_this$1$ = -8						; size = 4
tv4797 = -1						; size = 1
_line$ = 8						; size = 4
_vert_parity$ = 12					; size = 4
_env$ = 16						; size = 4
?horizontal_analysis@kd_analysis@@AAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z PROC ; kd_analysis::horizontal_analysis, COMDAT
; _this$ = ecx

; 951  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 952  :   assert((coset_width[0] == line->cosets[0].get_width()) &&
; 953  :          (coset_width[1] == line->cosets[1].get_width()));
; 954  : 
; 955  :   if (unit_width && (num_hor_steps > 0) && reversible && (x_min & 1))

	cmp	BYTE PTR [ecx+101], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	edx, DWORD PTR _line$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 951  : {

	mov	DWORD PTR _this$1$[ebp], ecx

; 952  :   assert((coset_width[0] == line->cosets[0].get_width()) &&
; 953  :          (coset_width[1] == line->cosets[1].get_width()));
; 954  : 
; 955  :   if (unit_width && (num_hor_steps > 0) && reversible && (x_min & 1))

	je	SHORT $LN64@horizontal
	cmp	DWORD PTR [ecx+32], 0
	jle	SHORT $LN64@horizontal
	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN64@horizontal
	test	BYTE PTR [ecx+84], 1
	je	SHORT $LN64@horizontal

; 956  :     {
; 957  :       assert(hor_xform_exists);
; 958  :       if (!use_shorts)

	cmp	BYTE PTR [ecx+21], 0
	jne	SHORT $LN63@horizontal
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edx+18], 2
	je	SHORT $LN107@horizontal
	xor	eax, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 959  :         line->cosets[1].get_buf32()->ival <<= 1;

	shl	DWORD PTR [eax], 1

; 960  :       else

	jmp	SHORT $LN64@horizontal
$LN107@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	eax, DWORD PTR [edx+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 959  :         line->cosets[1].get_buf32()->ival <<= 1;

	shl	DWORD PTR [eax], 1

; 960  :       else

	jmp	SHORT $LN64@horizontal
$LN63@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [edx+18], 2
	je	SHORT $LN111@horizontal
	mov	eax, DWORD PTR [edx+20]
	jmp	SHORT $LN112@horizontal
$LN111@horizontal:
	xor	eax, eax
$LN112@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 961  :         line->cosets[1].get_buf16()->ival <<= 1;

	shl	WORD PTR [eax], 1
$LN64@horizontal:

; 962  :     }
; 963  : 
; 964  :   int s, c, k, width;
; 965  : 
; 966  :   if ((num_hor_steps == 0) || unit_width)

	mov	eax, DWORD PTR [ecx+32]
	push	ebx
	push	esi
	push	edi
	test	eax, eax
	je	$LN66@horizontal
	cmp	BYTE PTR [ecx+101], 0
	jne	$LN66@horizontal

; 971  :       return;
; 972  :     }
; 973  :   
; 974  :   // Perform horizontal lifting steps.
; 975  :   for (s=0; s < num_hor_steps; s++)

	xor	edx, edx
	mov	DWORD PTR _s$1$[ebp], edx
	test	eax, eax
	jle	$LN6@horizontal
$LL7@horizontal:

; 976  :     {
; 977  :       kd_lifting_step *step = hor_steps + s;

	mov	esi, DWORD PTR _this$1$[ebp]
	lea	ecx, DWORD PTR [edx+edx*4]
	mov	eax, DWORD PTR [esi+52]

; 978  :       if (step->support_length == 0)

	cmp	BYTE PTR [eax+ecx*4+1], 0
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _step$1$[ebp], edx
	je	$LN5@horizontal

; 979  :         continue;
; 980  :       c = 1 - (s & 1); // Coset which is updated by this lifting step

	mov	eax, DWORD PTR _s$1$[ebp]
	mov	ecx, 1
	and	eax, 1
	sub	ecx, eax

; 981  :       width = coset_width[c];
; 982  : 
; 983  :       if (use_shorts)
; 984  :         { // Processing 16-bit samples
; 985  :           kdu_sample16 *sp=line->cosets[1-c].get_buf16();

	mov	eax, DWORD PTR _line$[ebp]
	cmp	BYTE PTR [esi+21], 0
	mov	edi, eax
	mov	DWORD PTR _c$1$[ebp], ecx
	mov	ebx, DWORD PTR [esi+ecx*4+92]
	lea	esi, DWORD PTR [ecx+ecx*2]
	mov	DWORD PTR _width$1$[ebp], ebx
	je	$LN69@horizontal
	shl	esi, 2
	sub	edi, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [edi+18], 2
	je	SHORT $LN117@horizontal
	mov	edi, DWORD PTR [edi+20]
	jmp	SHORT $LN248@horizontal
$LN117@horizontal:
	xor	edi, edi
$LN248@horizontal:
	test	BYTE PTR [esi+eax+6], 2
	mov	DWORD PTR _sp$1$[ebp], edi
	je	SHORT $LN121@horizontal
	mov	esi, DWORD PTR [esi+eax+8]
	jmp	SHORT $LN249@horizontal
$LN121@horizontal:
	xor	esi, esi
$LN249@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 987  :           kdu_sample16 *esp=sp+coset_width[1-c]-1; // End of source buffer

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	eax, 24					; 00000018H
	sub	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	mov	DWORD PTR _dp$1$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 987  :           kdu_sample16 *esp=sp+coset_width[1-c]-1; // End of source buffer

	mov	eax, DWORD PTR [edx+eax*4]
	dec	eax
	lea	eax, DWORD PTR [edi+eax*2]
	mov	DWORD PTR _esp$1$[ebp], eax

; 988  :           if (!hor_symmetric_extension)

	mov	eax, edx
	mov	edx, DWORD PTR _step$1$[ebp]
	cmp	BYTE PTR [eax+59], 0
	jne	$LN71@horizontal

; 989  :             for (k=1; k <= step->extend; k++)

	mov	ecx, 1
	cmp	BYTE PTR [edx+3], cl
	jb	SHORT $LN241@horizontal
	mov	esi, DWORD PTR _esp$1$[ebp]
	lea	ebx, DWORD PTR [edi-2]
	npad	1
$LL10@horizontal:

; 990  :               { sp[-k] = sp[0];  esp[k] = esp[0]; }

	movzx	eax, WORD PTR [edi]
	lea	ebx, DWORD PTR [ebx-2]
	mov	WORD PTR [ebx+2], ax
	movzx	eax, WORD PTR [esi]
	mov	WORD PTR [esi+ecx*2], ax
	inc	ecx
	movzx	eax, BYTE PTR [edx+3]
	cmp	ecx, eax
	jle	SHORT $LL10@horizontal

; 991  :           else

	mov	esi, DWORD PTR _dp$1$[ebp]
	mov	ebx, DWORD PTR _width$1$[ebp]
$LN250@horizontal:
	mov	eax, DWORD PTR _this$1$[ebp]
$LN241@horizontal:
	mov	ecx, DWORD PTR _c$1$[ebp]
$LN12@horizontal:

; 996  :               }
; 997  :           if (x_min & 1)

	test	BYTE PTR [eax+84], 1
	je	SHORT $LN73@horizontal

; 998  :             sp -= c+c-1;

	lea	eax, DWORD PTR [ecx*4]
	mov	ecx, 2
	sub	ecx, eax
	add	edi, ecx
$LN73@horizontal:

; 999  :           sp += step->support_min;
; 1000 : 
; 1001 : #ifdef KDU_SIMD_OPTIMIZATIONS
; 1002 :           if ((step->kernel_id == (kdu_byte) Ckernels_W5X3) &&

	cmp	BYTE PTR [edx+18], 1
	movsx	eax, WORD PTR [edx+4]
	lea	edi, DWORD PTR [edi+eax*2]
	jne	SHORT $LN74@horizontal
	push	edx
	push	ebx
	push	esi
	push	edi
	call	?simd_W5X3_h_analysis@@YA_NPAF0HPAUkd_lifting_step@@@Z ; simd_W5X3_h_analysis
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN5@horizontal
	mov	edx, DWORD PTR _step$1$[ebp]
$LN74@horizontal:

; 1003 :               simd_W5X3_h_analysis(&(sp->ival),&(dp->ival),width,step))
; 1004 :             continue;
; 1005 :           else if ((step->kernel_id == (kdu_byte) Ckernels_W9X7) &&

	cmp	BYTE PTR [edx+18], 0
	jne	SHORT $LN76@horizontal
	push	edx
	push	ebx
	push	esi
	push	edi
	call	?simd_W9X7_h_analysis@@YA_NPAF0HPAUkd_lifting_step@@@Z ; simd_W9X7_h_analysis
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN5@horizontal
	mov	edx, DWORD PTR _step$1$[ebp]
$LN76@horizontal:

; 1006 :                    simd_W9X7_h_analysis(&(sp->ival),&(dp->ival),width,step))
; 1007 :             continue;
; 1008 : #endif // KDU_SIMD_OPTIMIZATIONS
; 1009 :           if ((step->support_length==2)&&(step->icoeffs[0]==step->icoeffs[1]))

	mov	al, BYTE PTR [edx+1]
	cmp	al, 2
	jne	$LN77@horizontal
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i_lambda$1$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+4]
	jne	$LN242@horizontal

; 1010 :             { // Special implementation for symmetric least-dissimilar filters
; 1011 :               kdu_int32 downshift = step->downshift;

	movzx	ecx, BYTE PTR [edx+2]

; 1012 :               kdu_int32 offset = step->rounding_offset;

	movsx	edx, WORD PTR [edx+6]

; 1013 :               kdu_int32 val, i_lambda = step->icoeffs[0];
; 1014 :               if (i_lambda == 1)

	mov	eax, DWORD PTR _i_lambda$1$[ebp]
	mov	DWORD PTR _offset$1$[ebp], edx
	cmp	eax, 1
	jne	$LN79@horizontal

; 1015 :                 for (k=0; k < width; k++)

	test	ebx, ebx
	jle	$LN5@horizontal
	sub	edi, esi
	npad	6
$LL16@horizontal:

; 1016 :                   { val = sp[k].ival;  val += sp[k+1].ival;

	movsx	eax, WORD PTR [edi+esi+2]
	lea	esi, DWORD PTR [esi+2]
	movsx	edx, WORD PTR [edi+esi-2]

; 1017 :                     dp[k].ival += (kdu_int16)((offset+val)>>downshift); }

	add	eax, DWORD PTR _offset$1$[ebp]
	add	edx, eax
	sar	edx, cl
	add	WORD PTR [esi-2], dx
	sub	ebx, 1
	jne	SHORT $LL16@horizontal

; 1018 :               else if (i_lambda == -1)

	jmp	$LN5@horizontal
$LN71@horizontal:

; 992  :             for (k=1; k <= step->extend; k++)

	cmp	BYTE PTR [edx+3], 1
	mov	edi, 1
	jb	SHORT $LN239@horizontal
	mov	eax, DWORD PTR _sp$1$[ebp]
	mov	esi, DWORD PTR _sp$1$[ebp]
	add	eax, -2					; fffffffeH
	mov	ebx, DWORD PTR _esp$1$[ebp]
	mov	DWORD PTR tv4772[ebp], eax
	npad	4
$LL13@horizontal:

; 993  :               { // Apply symmetric extension policy
; 994  :                 sp[-k] = sp[k - ((x_min^s) & 1)];

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	eax, edi
	xor	ecx, DWORD PTR _s$1$[ebp]
	and	ecx, 1
	sub	eax, ecx
	mov	ecx, DWORD PTR tv4772[ebp]
	movzx	eax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx], ax
	sub	ecx, 2

; 995  :                 esp[k] = esp[-k + ((x_max^s) & 1)];

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR tv4772[ebp], ecx
	mov	eax, DWORD PTR [eax+88]
	xor	eax, DWORD PTR _s$1$[ebp]
	and	eax, 1
	sub	eax, edi
	movzx	eax, WORD PTR [ebx+eax*2]
	mov	WORD PTR [ebx+edi*2], ax
	inc	edi
	movzx	eax, BYTE PTR [edx+3]
	cmp	edi, eax
	jle	SHORT $LL13@horizontal
	mov	esi, DWORD PTR _dp$1$[ebp]
	mov	ebx, DWORD PTR _width$1$[ebp]
	mov	edi, DWORD PTR _sp$1$[ebp]
	jmp	$LN250@horizontal
$LN239@horizontal:
	mov	edi, DWORD PTR _sp$1$[ebp]
	jmp	$LN12@horizontal
$LN79@horizontal:

; 1018 :               else if (i_lambda == -1)

	cmp	eax, -1
	jne	SHORT $LN81@horizontal

; 1019 :                 for (k=0; k < width; k++)

	test	ebx, ebx
	jle	$LN5@horizontal
	sub	edi, esi
$LL19@horizontal:

; 1020 :                   { val = sp[k].ival;  val += sp[k+1].ival;

	movsx	eax, WORD PTR [esi+edi+2]
	lea	esi, DWORD PTR [esi+2]

; 1021 :                     dp[k].ival += (kdu_int16)((offset-val)>>downshift); }

	sub	edx, eax
	movsx	eax, WORD PTR [esi+edi-2]
	sub	edx, eax
	sar	edx, cl
	add	WORD PTR [esi-2], dx
	mov	edx, DWORD PTR _offset$1$[ebp]
	sub	ebx, 1
	jne	SHORT $LL19@horizontal

; 1022 :               else

	jmp	$LN5@horizontal
$LN81@horizontal:

; 1023 :                 for (k=0; k < width; k++)

	test	ebx, ebx
	jle	$LN5@horizontal
	sub	edi, esi
$LL22@horizontal:

; 1024 :                   { val = sp[k].ival;  val += sp[k+1].ival;

	movsx	edx, WORD PTR [esi+edi+2]
	lea	esi, DWORD PTR [esi+2]
	movsx	eax, WORD PTR [esi+edi-2]
	add	edx, eax

; 1025 :                     dp[k].ival +=

	imul	edx, DWORD PTR _i_lambda$1$[ebp]
	add	edx, DWORD PTR _offset$1$[ebp]
	sar	edx, cl
	add	WORD PTR [esi-2], dx
	sub	ebx, 1
	jne	SHORT $LL22@horizontal

; 1026 :                       (kdu_int16)((offset+i_lambda*val)>>downshift); }
; 1027 :             }
; 1028 :           else

	jmp	$LN5@horizontal
$LN242@horizontal:
	mov	al, BYTE PTR [edx+1]
$LN77@horizontal:

; 1029 :             { // Generic 16-bit implementation
; 1030 :               int t, support=step->support_length;
; 1031 :               kdu_int32 downshift = step->downshift;
; 1032 :               kdu_int32 offset = step->rounding_offset;

	movsx	ecx, WORD PTR [edx+6]
	movzx	eax, al
	mov	DWORD PTR _support$1$[ebp], eax
	movzx	eax, BYTE PTR [edx+2]
	mov	DWORD PTR _downshift$1$[ebp], eax

; 1033 :               int sum, *cpp = step->icoeffs;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _offset$1$[ebp], ecx
	mov	DWORD PTR _cpp$1$[ebp], eax

; 1034 :               for (k=0; k < width; k++, sp++)

	mov	DWORD PTR _k$3$[ebp], 0
	test	ebx, ebx
	jle	$LN5@horizontal
$LL25@horizontal:
	xor	eax, eax

; 1035 :                 {
; 1036 :                   for (sum=offset, t=0; t < support; t++)

	mov	DWORD PTR _sum$1$[ebp], ecx
	xor	edx, edx
	mov	DWORD PTR $T3[ebp], eax
	xor	ecx, ecx
	cmp	DWORD PTR _support$1$[ebp], 2
	jl	SHORT $LC202@horizontal
	mov	esi, DWORD PTR _support$1$[ebp]
	mov	ebx, DWORD PTR _cpp$1$[ebp]
	dec	esi
	npad	3
$LL203@horizontal:

; 1037 :                     sum += cpp[t] * sp[t].ival;

	movsx	eax, WORD PTR [edi+ecx*2]
	imul	eax, DWORD PTR [ebx+ecx*4]
	add	edx, eax
	movsx	eax, WORD PTR [edi+ecx*2+2]
	imul	eax, DWORD PTR [ebx+ecx*4+4]
	add	ecx, 2
	add	DWORD PTR $T3[ebp], eax
	cmp	ecx, esi
	jl	SHORT $LL203@horizontal
	mov	esi, DWORD PTR _dp$1$[ebp]
	mov	ebx, DWORD PTR _width$1$[ebp]
	mov	eax, DWORD PTR $T3[ebp]
$LC202@horizontal:

; 1035 :                 {
; 1036 :                   for (sum=offset, t=0; t < support; t++)

	cmp	ecx, DWORD PTR _support$1$[ebp]
	jge	SHORT $LN201@horizontal

; 1037 :                     sum += cpp[t] * sp[t].ival;

	movsx	eax, WORD PTR [edi+ecx*2]
	mov	DWORD PTR _sum$1$[ebp], eax
	mov	eax, DWORD PTR _cpp$1$[ebp]
	mov	esi, DWORD PTR _sum$1$[ebp]
	imul	esi, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _offset$1$[ebp]
	mov	DWORD PTR _sum$1$[ebp], esi
	add	DWORD PTR _sum$1$[ebp], eax
	mov	esi, DWORD PTR _dp$1$[ebp]
	mov	eax, DWORD PTR $T3[ebp]
$LN201@horizontal:

; 1038 :                   dp[k].ival += (kdu_int16)(sum >> downshift);

	mov	ecx, DWORD PTR _downshift$1$[ebp]
	add	eax, edx
	add	eax, DWORD PTR _sum$1$[ebp]
	add	edi, 2
	sar	eax, cl
	mov	ecx, DWORD PTR _k$3$[ebp]
	add	WORD PTR [esi+ecx*2], ax
	inc	ecx
	mov	DWORD PTR _k$3$[ebp], ecx
	cmp	ecx, ebx
	mov	ecx, DWORD PTR _offset$1$[ebp]
	jl	$LL25@horizontal

; 1039 :                 }
; 1040 :             }
; 1041 :         }
; 1042 :       else

	jmp	$LN5@horizontal
$LN69@horizontal:

; 1043 :         { // Processing 32-bit samples
; 1044 :           kdu_sample32 *sp=line->cosets[1-c].get_buf32();

	shl	esi, 2
	sub	edi, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edi+18], 2
	je	SHORT $LN125@horizontal
	xor	edi, edi
	jmp	SHORT $LN251@horizontal
$LN125@horizontal:
	mov	edi, DWORD PTR [edi+20]
$LN251@horizontal:
	test	BYTE PTR [esi+eax+6], 2
	mov	DWORD PTR _sp$1$[ebp], edi
	je	SHORT $LN129@horizontal
	xor	esi, esi
	jmp	SHORT $LN252@horizontal
$LN129@horizontal:
	mov	esi, DWORD PTR [esi+eax+8]
$LN252@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 1046 :           kdu_sample32 *esp=sp+coset_width[1-c]-1; // End of source buffer

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	eax, 24					; 00000018H
	sub	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	DWORD PTR _dp$1$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 1046 :           kdu_sample32 *esp=sp+coset_width[1-c]-1; // End of source buffer

	mov	eax, DWORD PTR [edx+eax*4]
	dec	eax
	lea	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR _esp$1$[ebp], eax

; 1047 :           if (!hor_symmetric_extension)

	mov	eax, edx
	mov	edx, DWORD PTR _step$1$[ebp]
	cmp	BYTE PTR [eax+59], 0
	jne	$LN83@horizontal

; 1048 :             for (k=1; k <= step->extend; k++)

	mov	ecx, 1
	cmp	BYTE PTR [edx+3], cl
	jb	SHORT $LN240@horizontal
	mov	esi, DWORD PTR _esp$1$[ebp]
	lea	ebx, DWORD PTR [edi-4]
	npad	2
$LL31@horizontal:

; 1049 :               { sp[-k] = sp[0];  esp[k] = esp[0]; }

	mov	eax, DWORD PTR [edi]
	lea	ebx, DWORD PTR [ebx-4]
	mov	DWORD PTR [ebx+4], eax
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+ecx*4], eax
	inc	ecx
	movzx	eax, BYTE PTR [edx+3]
	cmp	ecx, eax
	jle	SHORT $LL31@horizontal

; 1050 :           else

	mov	esi, DWORD PTR _dp$1$[ebp]
	mov	ebx, DWORD PTR _width$1$[ebp]
$LN253@horizontal:
	mov	eax, DWORD PTR _this$1$[ebp]
$LN240@horizontal:
	mov	ecx, DWORD PTR _c$1$[ebp]
$LN33@horizontal:

; 1055 :               }
; 1056 :           if (x_min & 1)

	test	BYTE PTR [eax+84], 1
	je	SHORT $LN85@horizontal

; 1057 :             sp -= c+c-1;

	lea	eax, DWORD PTR [ecx*8]
	mov	ecx, 4
	sub	ecx, eax
	add	edi, ecx
$LN85@horizontal:

; 1058 :           sp += step->support_min;
; 1059 : 
; 1060 : #ifdef KDU_SIMD_OPTIMIZATIONS
; 1061 :           if ((step->kernel_id == (kdu_byte) Ckernels_W5X3) &&

	cmp	BYTE PTR [edx+18], 1
	movsx	eax, WORD PTR [edx+4]
	lea	edi, DWORD PTR [edi+eax*4]
	mov	DWORD PTR _sp$2$[ebp], edi
	jne	SHORT $LN86@horizontal
	push	edx
	push	ebx
	push	esi
	push	edi
	call	?simd_W5X3_h_analysis32@@YA_NPAH0HPAUkd_lifting_step@@@Z ; simd_W5X3_h_analysis32
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN5@horizontal
	mov	edx, DWORD PTR _step$1$[ebp]
$LN86@horizontal:

; 1062 :               simd_W5X3_h_analysis32(&(sp->ival),&(dp->ival),width,step))
; 1063 :             continue;
; 1064 :           else if (!reversible)

	mov	eax, DWORD PTR _this$1$[ebp]
	cmp	BYTE PTR [eax+20], 0
	jne	$LN93@horizontal

; 1065 :             {
; 1066 :               if (step->support_length <= 2)

	mov	al, BYTE PTR [edx+1]
	cmp	al, 2
	ja	$LN89@horizontal

; 1067 :                 {
; 1068 :                   if (simd_2tap_h_irrev32(&(sp->fval),&(dp->fval),width,

	push	0
	push	edx
	push	ebx
	push	esi
	push	edi
	call	?simd_2tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z ; simd_2tap_h_irrev32

; 1069 :                                           step,false))
; 1070 :                     continue;
; 1071 :                 }

	jmp	$LN255@horizontal
$LN83@horizontal:

; 1051 :             for (k=1; k <= step->extend; k++)

	cmp	BYTE PTR [edx+3], 1
	mov	edi, 1
	jb	SHORT $LN238@horizontal
	mov	eax, DWORD PTR _sp$1$[ebp]
	mov	esi, DWORD PTR _sp$1$[ebp]
	add	eax, -4					; fffffffcH
	mov	ebx, DWORD PTR _esp$1$[ebp]
	mov	DWORD PTR tv4761[ebp], eax
$LL34@horizontal:

; 1052 :               { // Apply symmetric extension policy
; 1053 :                 sp[-k] = sp[k - ((x_min^s) & 1)];

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	eax, edi
	xor	ecx, DWORD PTR _s$1$[ebp]
	and	ecx, 1
	sub	eax, ecx
	mov	ecx, DWORD PTR tv4761[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx], eax
	sub	ecx, 4

; 1054 :                 esp[k] = esp[-k + ((x_max^s) & 1)];

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR tv4761[ebp], ecx
	mov	eax, DWORD PTR [eax+88]
	xor	eax, DWORD PTR _s$1$[ebp]
	and	eax, 1
	sub	eax, edi
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [ebx+edi*4], eax
	inc	edi
	movzx	eax, BYTE PTR [edx+3]
	cmp	edi, eax
	jle	SHORT $LL34@horizontal
	mov	esi, DWORD PTR _dp$1$[ebp]
	mov	ebx, DWORD PTR _width$1$[ebp]
	mov	edi, DWORD PTR _sp$1$[ebp]
	jmp	$LN253@horizontal
$LN238@horizontal:
	mov	edi, DWORD PTR _sp$1$[ebp]
	jmp	$LN33@horizontal
$LN89@horizontal:

; 1072 :               else if (step->support_length <= 4)

	cmp	al, 4
	ja	SHORT $LN93@horizontal

; 1073 :                 {
; 1074 :                   if (simd_4tap_h_irrev32(&(sp->fval),&(dp->fval),width,

	push	0
	push	edx
	push	ebx
	push	esi
	push	edi
	call	?simd_4tap_h_irrev32@@YA_NPAM0HPAUkd_lifting_step@@_N@Z ; simd_4tap_h_irrev32
$LN255@horizontal:
	add	esp, 20					; 00000014H
	test	al, al
	jne	$LN5@horizontal
$LN93@horizontal:

; 1075 :                                           step,false))
; 1076 :                     continue;
; 1077 :                 }
; 1078 :             }
; 1079 : #endif // KDU_SIMD_OPTIMIZATIONS
; 1080 :           if ((step->support_length==2) && (step->coeffs[0]==step->coeffs[1]))

	mov	ecx, DWORD PTR _step$1$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, 2
	jne	$LN94@horizontal
	mov	eax, DWORD PTR [ecx+8]
	movss	xmm1, DWORD PTR [eax]
	ucomiss	xmm1, DWORD PTR [eax+4]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN94@horizontal

; 1081 :             { // Special implementation for symmetric least-dissimilar filters
; 1082 :               if (!reversible)

	mov	eax, DWORD PTR _this$1$[ebp]
	cmp	BYTE PTR [eax+20], 0
	jne	$LN96@horizontal

; 1085 :                   for (k=0; k < width; k++)

	xor	ecx, ecx
	cmp	ebx, 4
	jl	$LC205@horizontal

; 1083 :                 {
; 1084 :                   float lambda = step->coeffs[0];

	mov	edx, edi
	lea	ecx, DWORD PTR [edi+8]
	sub	edx, esi
	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR tv4758[ebp], edx
	lea	edx, DWORD PTR [ebx-4]
	shr	edx, 2
	inc	edx
	lea	edi, DWORD PTR [edx*4]
	mov	DWORD PTR _k$6$[ebp], edi
	mov	edi, DWORD PTR tv4758[ebp]
	npad	7

; 1085 :                   for (k=0; k < width; k++)

$LL206@horizontal:

; 1086 :                     dp[k].fval += lambda*(sp[k].fval+sp[k+1].fval);

	movss	xmm0, DWORD PTR [ecx-8]
	addss	xmm0, DWORD PTR [edi+eax]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax-4]
	movss	DWORD PTR [eax-4], xmm0
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [edi+eax]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR [ecx+8]
	addss	xmm0, DWORD PTR [ecx+4]
	add	ecx, 16					; 00000010H
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [eax+8], xmm0
	add	eax, 16					; 00000010H
	sub	edx, 1
	jne	SHORT $LL206@horizontal
	mov	edi, DWORD PTR _sp$2$[ebp]
	mov	ecx, DWORD PTR _k$6$[ebp]
$LC205@horizontal:

; 1085 :                   for (k=0; k < width; k++)

	cmp	ecx, ebx
	jge	$LN5@horizontal
	sub	edi, esi
	lea	eax, DWORD PTR [esi+ecx*4]
	sub	ebx, ecx
	npad	4
$LC37@horizontal:

; 1086 :                     dp[k].fval += lambda*(sp[k].fval+sp[k+1].fval);

	movss	xmm0, DWORD PTR [eax+edi+4]
	addss	xmm0, DWORD PTR [eax+edi]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	sub	ebx, 1
	jne	SHORT $LC37@horizontal

; 1087 :                 }
; 1088 :               else

	jmp	$LN5@horizontal
$LN96@horizontal:

; 1089 :                 {
; 1090 :                   kdu_int32 downshift = step->downshift;
; 1091 :                   kdu_int32 offset = step->rounding_offset;

	movsx	eax, WORD PTR [ecx+6]
	movzx	edx, BYTE PTR [ecx+2]
	mov	DWORD PTR _offset$1$[ebp], eax

; 1092 :                   kdu_int32 i_lambda = step->icoeffs[0];

	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i_lambda$1$[ebp], ecx

; 1093 :                   if (i_lambda == 1)

	cmp	ecx, 1
	jne	SHORT $LN98@horizontal

; 1094 :                     for (k=0; k < width; k++)

	test	ebx, ebx
	jle	$LN5@horizontal
	sub	edi, esi
	npad	10
$LL40@horizontal:

; 1095 :                       dp[k].ival +=

	mov	eax, DWORD PTR [esi+edi+4]
	lea	esi, DWORD PTR [esi+4]
	add	eax, DWORD PTR [esi+edi-4]
	mov	ecx, edx
	add	eax, DWORD PTR _offset$1$[ebp]
	sar	eax, cl
	add	DWORD PTR [esi-4], eax
	sub	ebx, 1
	jne	SHORT $LL40@horizontal

; 1096 :                         ((offset+sp[k].ival+sp[k+1].ival)>>downshift);
; 1097 :                   else if (i_lambda == -1)

	jmp	$LN5@horizontal
$LN98@horizontal:
	cmp	ecx, -1
	jne	SHORT $LN100@horizontal

; 1098 :                     for (k=0; k < width; k++)

	test	ebx, ebx
	jle	$LN5@horizontal
	sub	edi, esi
	npad	2
$LL43@horizontal:

; 1099 :                       dp[k].ival +=

	mov	eax, DWORD PTR _offset$1$[ebp]
	lea	esi, DWORD PTR [esi+4]
	sub	eax, DWORD PTR [esi+edi]
	mov	ecx, edx
	sub	eax, DWORD PTR [esi+edi-4]
	sar	eax, cl
	add	DWORD PTR [esi-4], eax
	sub	ebx, 1
	jne	SHORT $LL43@horizontal

; 1100 :                         ((offset-sp[k].ival-sp[k+1].ival)>>downshift);
; 1101 :                   else

	jmp	$LN5@horizontal
$LN100@horizontal:

; 1102 :                     for (k=0; k < width; k++)

	test	ebx, ebx
	jle	$LN5@horizontal
	sub	edi, esi
	npad	8
$LL46@horizontal:

; 1103 :                       dp[k].ival +=

	mov	eax, DWORD PTR [esi+edi+4]
	lea	esi, DWORD PTR [esi+4]
	add	eax, DWORD PTR [esi+edi-4]
	imul	eax, ecx
	mov	ecx, edx
	add	eax, DWORD PTR _offset$1$[ebp]
	sar	eax, cl
	add	DWORD PTR [esi-4], eax
	mov	ecx, DWORD PTR _i_lambda$1$[ebp]
	sub	ebx, 1
	jne	SHORT $LL46@horizontal

; 1104 :                       ((offset+i_lambda*(sp[k].ival+sp[k+1].ival))>>downshift);
; 1105 :                 }
; 1106 :             }
; 1107 :           else

	jmp	$LN5@horizontal
$LN94@horizontal:

; 1108 :             { // Generic 32-bit lifting step implementation
; 1109 :               int t, support=step->support_length;

	movzx	eax, dl

; 1110 :               if (!reversible)

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _support$1$[ebp], eax
	cmp	BYTE PTR [edx+20], 0
	jne	$LN102@horizontal

; 1111 :                 {
; 1112 :                   float sum, *cpp = step->coeffs;

	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cpp$1$[ebp], ecx

; 1113 :                   for (k=0; k < width; k++, sp++)

	mov	DWORD PTR _k$7$[ebp], 0
	test	ebx, ebx
	jle	$LN5@horizontal

; 1111 :                 {
; 1112 :                   float sum, *cpp = step->coeffs;

	mov	edx, ecx
	sub	edx, edi
	mov	DWORD PTR tv4734[ebp], edx
$LL49@horizontal:

; 1114 :                     {
; 1115 :                       for (sum=0.0F, t=0; t < support; t++)

	xor	ecx, ecx
	xorps	xmm2, xmm2
	mov	DWORD PTR _t$1$[ebp], ecx
	cmp	eax, 4
	jl	$LC208@horizontal
	mov	edx, DWORD PTR _support$1$[ebp]
	lea	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR _cpp$1$[ebp]
	add	edx, -4					; fffffffcH
	shr	edx, 2
	add	ecx, 12					; 0000000cH
	inc	edx
	lea	esi, DWORD PTR [edx*4]
	mov	DWORD PTR _t$1$[ebp], esi
	mov	esi, DWORD PTR tv4734[ebp]
	npad	11
$LL209@horizontal:

; 1116 :                         sum += cpp[t] * sp[t].fval;

	movss	xmm1, DWORD PTR [eax-4]
	mulss	xmm1, DWORD PTR [ecx-12]
	movss	xmm0, DWORD PTR [eax+esi]
	mulss	xmm0, DWORD PTR [eax]
	addss	xmm2, xmm1
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [ecx-4]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [ecx]
	add	eax, 16					; 00000010H
	add	ecx, 16					; 00000010H
	addss	xmm2, xmm0
	sub	edx, 1
	jne	SHORT $LL209@horizontal
	mov	esi, DWORD PTR _dp$1$[ebp]
	mov	edx, DWORD PTR tv4734[ebp]
	mov	eax, DWORD PTR _support$1$[ebp]
	mov	ecx, DWORD PTR _t$1$[ebp]
$LC208@horizontal:

; 1114 :                     {
; 1115 :                       for (sum=0.0F, t=0; t < support; t++)

	cmp	ecx, eax
	jge	SHORT $LN207@horizontal
	lea	eax, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR _support$1$[ebp]
	sub	ecx, DWORD PTR _t$1$[ebp]
	npad	6
$LC175@horizontal:

; 1116 :                         sum += cpp[t] * sp[t].fval;

	movss	xmm0, DWORD PTR [eax+edx]
	mulss	xmm0, DWORD PTR [eax]
	add	eax, 4
	addss	xmm2, xmm0
	sub	ecx, 1
	jne	SHORT $LC175@horizontal
	mov	eax, DWORD PTR _support$1$[ebp]
$LN207@horizontal:

; 1117 :                       dp[k].fval += sum;

	mov	ecx, DWORD PTR _k$7$[ebp]
	sub	edx, 4
	add	edi, 4
	mov	DWORD PTR tv4734[ebp], edx
	movss	xmm0, DWORD PTR [esi+ecx*4]
	addss	xmm0, xmm2
	movss	DWORD PTR [esi+ecx*4], xmm0
	inc	ecx
	mov	DWORD PTR _k$7$[ebp], ecx
	cmp	ecx, ebx
	jl	$LL49@horizontal

; 1118 :                     }
; 1119 :                 }
; 1120 :               else

	jmp	$LN5@horizontal
$LN102@horizontal:

; 1121 :                 {
; 1122 :                   kdu_int32 downshift = step->downshift;

	movzx	edx, BYTE PTR [ecx+2]
	mov	DWORD PTR _downshift$1$[ebp], edx

; 1123 :                   kdu_int32 offset = step->rounding_offset;

	movsx	edx, WORD PTR [ecx+6]

; 1124 :                   int sum, *cpp = step->icoeffs;

	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR _offset$1$[ebp], edx
	mov	DWORD PTR _cpp$1$[ebp], ecx

; 1125 :                   for (k=0; k < width; k++, sp++)

	mov	DWORD PTR _k$8$[ebp], 0
	test	ebx, ebx
	jle	$LN5@horizontal

; 1121 :                 {
; 1122 :                   kdu_int32 downshift = step->downshift;

	sub	ecx, edi
	mov	DWORD PTR tv4729[ebp], ecx
	npad	5
$LL55@horizontal:

; 1126 :                     {
; 1127 :                       for (sum=offset, t=0; t < support; t++)

	xor	ecx, ecx
	mov	DWORD PTR _sum$1$[ebp], edx
	test	eax, eax
	jle	$LN178@horizontal
	cmp	eax, 8
	jb	$LN178@horizontal
	cmp	DWORD PTR ___isa_available, 2
	jl	$LN178@horizontal
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN247@horizontal
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN247@horizontal:
	mov	edx, DWORD PTR _support$1$[ebp]
	xorps	xmm6, xmm6
	sub	edx, eax
	movaps	xmm5, xmm6
	mov	DWORD PTR tv4730[ebp], edx
	lea	eax, DWORD PTR [edi+8]
	mov	edx, DWORD PTR _cpp$1$[ebp]
$LL58@horizontal:

; 1128 :                         sum += cpp[t] * sp[t].ival;

	movd	xmm2, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [edx+32]
	movd	xmm0, DWORD PTR [eax]
	lea	eax, DWORD PTR [eax+32]
	movd	xmm1, DWORD PTR [eax-36]
	add	ecx, 8
	movd	xmm3, DWORD PTR [eax-40]
	movups	xmm4, XMMWORD PTR [edx-32]
	punpckldq xmm3, xmm0
	movd	xmm0, DWORD PTR [eax-16]
	punpckldq xmm1, xmm2
	movd	xmm2, DWORD PTR [eax-12]
	punpckldq xmm3, xmm1
	movd	xmm1, DWORD PTR [eax-20]
	pmulld	xmm3, xmm4
	paddd	xmm6, xmm3
	movd	xmm3, DWORD PTR [eax-24]
	movups	xmm4, XMMWORD PTR [edx-16]
	punpckldq xmm3, xmm0
	punpckldq xmm1, xmm2
	punpckldq xmm3, xmm1
	pmulld	xmm3, xmm4
	paddd	xmm5, xmm3
	cmp	ecx, DWORD PTR tv4730[ebp]
	jl	SHORT $LL58@horizontal
	mov	eax, DWORD PTR _support$1$[ebp]
	paddd	xmm5, xmm6
	movaps	xmm0, xmm5
	psrldq	xmm0, 8
	paddd	xmm5, xmm0
	movaps	xmm0, xmm5
	psrldq	xmm0, 4
	paddd	xmm5, xmm0
	movd	edx, xmm5
	add	edx, DWORD PTR _offset$1$[ebp]
	mov	DWORD PTR _sum$1$[ebp], edx
$LN178@horizontal:
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR $T1[ebp], 0
	cmp	ecx, eax
	jge	$LN210@horizontal
	sub	eax, ecx

; 1126 :                     {
; 1127 :                       for (sum=offset, t=0; t < support; t++)

	cmp	eax, 2
	jl	SHORT $LC211@horizontal
	mov	eax, DWORD PTR _support$1$[ebp]
	lea	edx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR tv4729[ebp]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR _cpp$1$[ebp]
	dec	eax
	mov	DWORD PTR tv4775[ebp], eax
	mov	esi, eax
$LL213@horizontal:

; 1128 :                         sum += cpp[t] * sp[t].ival;

	mov	eax, DWORD PTR [ebx+ecx*4]
	lea	edx, DWORD PTR [edx+8]
	imul	eax, DWORD PTR [edx-12]
	add	ecx, 2
	add	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR [edi+edx-8]
	imul	eax, DWORD PTR [edx-8]
	add	DWORD PTR $T1[ebp], eax
	cmp	ecx, esi
	jl	SHORT $LL213@horizontal
	mov	esi, DWORD PTR _dp$1$[ebp]
	mov	edi, DWORD PTR _sp$2$[ebp]
	mov	ebx, DWORD PTR _width$1$[ebp]
$LC211@horizontal:

; 1126 :                     {
; 1127 :                       for (sum=offset, t=0; t < support; t++)

	cmp	ecx, DWORD PTR _support$1$[ebp]
	jge	SHORT $LN237@horizontal

; 1128 :                         sum += cpp[t] * sp[t].ival;

	mov	edx, DWORD PTR _cpp$1$[ebp]
	mov	eax, DWORD PTR [edi+ecx*4]
	imul	eax, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _sum$1$[ebp]
	add	edx, eax
	jmp	SHORT $LN212@horizontal
$LN237@horizontal:
	mov	edx, DWORD PTR _sum$1$[ebp]
$LN212@horizontal:
	mov	eax, DWORD PTR $T2[ebp]
	add	eax, DWORD PTR $T1[ebp]
	add	edx, eax
	mov	eax, DWORD PTR _support$1$[ebp]
$LN210@horizontal:

; 1129 :                       dp[k].ival += (sum >> downshift);

	mov	ecx, DWORD PTR _downshift$1$[ebp]
	add	edi, 4
	sub	DWORD PTR tv4729[ebp], 4
	sar	edx, cl
	mov	ecx, DWORD PTR _k$8$[ebp]
	mov	DWORD PTR _sp$2$[ebp], edi
	add	DWORD PTR [esi+ecx*4], edx
	inc	ecx
	mov	edx, DWORD PTR _offset$1$[ebp]
	mov	DWORD PTR _k$8$[ebp], ecx
	cmp	ecx, ebx
	jl	$LL55@horizontal
$LN5@horizontal:

; 971  :       return;
; 972  :     }
; 973  :   
; 974  :   // Perform horizontal lifting steps.
; 975  :   for (s=0; s < num_hor_steps; s++)

	mov	edx, DWORD PTR _s$1$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	inc	edx
	mov	DWORD PTR _s$1$[ebp], edx
	cmp	edx, DWORD PTR [ecx+32]
	jl	$LL7@horizontal
$LN6@horizontal:

; 1137 :   for (c=0; c < 2; c++)

	mov	eax, DWORD PTR _vert_parity$[ebp]
	mov	edi, 2
	mov	ebx, DWORD PTR _env$[ebp]
	lea	esi, DWORD PTR [eax*8+4]
	add	esi, ecx
	npad	4
$LL61@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 650  :         state->push(line,env);

	mov	ecx, DWORD PTR [esi]
	push	ebx
	push	DWORD PTR _line$[ebp]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 1137 :   for (c=0; c < 2; c++)

	add	DWORD PTR _line$[ebp], 12		; 0000000cH
	lea	esi, DWORD PTR [esi+4]
	sub	edi, 1
	jne	SHORT $LL61@horizontal
	pop	edi
	pop	esi
	pop	ebx

; 1138 :     subbands[2*vert_parity+c].push(line->cosets[c],env);
; 1139 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN66@horizontal:

; 968  :       for (c=0; c < 2; c++)

	mov	ebx, DWORD PTR _env$[ebp]
	lea	edi, DWORD PTR [ecx+92]
	xor	esi, esi
$LL4@horizontal:

; 969  :         if (coset_width[c] > 0)

	cmp	DWORD PTR [edi], 0
	jle	SHORT $LN2@horizontal

; 970  :           subbands[2*vert_parity+c].push(line->cosets[c],env);

	mov	eax, DWORD PTR _vert_parity$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 650  :         state->push(line,env);

	push	ebx
	push	edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 970  :           subbands[2*vert_parity+c].push(line->cosets[c],env);

	lea	eax, DWORD PTR [esi+eax*2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 650  :         state->push(line,env);

	mov	ecx, DWORD PTR [ecx+eax*4+4]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	edx, DWORD PTR _line$[ebp]
$LN2@horizontal:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 968  :       for (c=0; c < 2; c++)

	inc	esi
	add	edx, 12					; 0000000cH
	add	edi, 4
	mov	DWORD PTR _line$[ebp], edx
	cmp	esi, 2
	jl	SHORT $LL4@horizontal
	pop	edi
	pop	esi
	pop	ebx

; 1138 :     subbands[2*vert_parity+c].push(line->cosets[c],env);
; 1139 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?horizontal_analysis@kd_analysis@@AAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z ENDP ; kd_analysis::horizontal_analysis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
;	COMDAT ?simulate_vertical_lifting@kd_analysis@@AAEHH@Z
_TEXT	SEGMENT
_src_idx$1$ = -36					; size = 4
tv1139 = -32						; size = 4
_this$1$ = -32						; size = 4
tv1182 = -28						; size = 4
tv1176 = -28						; size = 4
_max_source_request_idx$1$ = -24			; size = 4
_s$3$ = -24						; size = 4
_s_max$1$ = -20						; size = 4
_max_used_lines$1$ = -16				; size = 4
_used_lines$ = -12					; size = 4
tv1140 = -8						; size = 4
_sim_y_max$1$ = -4					; size = 4
tv1175 = 8						; size = 4
tv1143 = 8						; size = 4
_support_max$ = 8					; size = 4
_generated_something$1$ = 11				; size = 1
?simulate_vertical_lifting@kd_analysis@@AAEHH@Z PROC	; kd_analysis::simulate_vertical_lifting, COMDAT
; _this$ = ecx

; 608  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	esi, ecx

; 609  :   int s, s_max, src_idx;
; 610  :   int max_used_lines=0, used_lines=0;

	mov	DWORD PTR _max_used_lines$1$[ebp], 0
	xor	edx, edx
	mov	DWORD PTR _this$1$[ebp], esi
	push	edi

; 611  :   kd_lifting_step *step;
; 612  : 
; 613  :   // Find simple upper bounds to avoid wasting too much simulation effort
; 614  :   int sim_y_max = y_max;

	mov	ebx, DWORD PTR [esi+76]

; 615  :   int delta = sim_y_max - (y_min + support_max + 2);

	mov	eax, ebx
	mov	ecx, DWORD PTR [esi+72]
	sub	eax, ecx
	sub	eax, DWORD PTR _support_max$[ebp]
	sub	eax, 2
	mov	DWORD PTR _sim_y_max$1$[ebp], ebx

; 616  :   if (delta > 0)

	test	eax, eax
	jle	SHORT $LN16@simulate_v

; 617  :     sim_y_max -= delta & ~1;

	and	eax, -2					; fffffffeH
	sub	ebx, eax
	mov	DWORD PTR _sim_y_max$1$[ebp], ebx
$LN16@simulate_v:

; 621  :   for (s=-1; s < num_vert_steps; s++)

	or	ebx, -1
	mov	DWORD PTR [esi+80], ecx
	cmp	DWORD PTR [esi+28], ebx
	jle	$LN3@simulate_v

; 618  : 
; 619  :   // Set up counters for simulation
; 620  :   y_next = y_min;

	mov	DWORD PTR tv1143[ebp], -40		; ffffffd8H
	lea	edx, DWORD PTR [ebx-19]
	npad	1
$LL4@simulate_v:

; 622  :     {
; 623  :       int max_source_request_idx = sim_y_max - ((sim_y_max ^ s) & 1);

	mov	eax, DWORD PTR _sim_y_max$1$[ebp]
	mov	edi, ebx
	xor	edi, eax
	and	edi, 1
	sub	eax, edi
	mov	DWORD PTR _max_source_request_idx$1$[ebp], eax

; 624  :       if (s >= 0)

	test	ebx, ebx
	js	SHORT $LN17@simulate_v

; 625  :         max_source_request_idx = sim_y_max - ((sim_y_max ^ s) & 1) +

	mov	eax, DWORD PTR [esi+48]
	movsx	ecx, WORD PTR [eax+edx+4]
	movzx	eax, BYTE PTR [eax+edx+1]
	add	ecx, eax
	mov	eax, DWORD PTR _sim_y_max$1$[ebp]
	add	ecx, ecx
	add	eax, -2					; fffffffeH
	sub	ecx, edi
	add	eax, ecx
	mov	DWORD PTR _max_source_request_idx$1$[ebp], eax
$LN17@simulate_v:

; 626  :           2*(vert_steps[s].support_min - 1 +
; 627  :              (int) vert_steps[s].support_length);
; 628  :       queues[s].init(y_next,sim_y_max,s,vert_symmetric_extension,

	mov	edi, DWORD PTR [esi+64]
	add	edi, DWORD PTR tv1143[ebp]
	mov	cl, BYTE PTR [esi+58]
	mov	eax, DWORD PTR [esi+80]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 125  :         this->y_min = y_min;  this->y_max = y_max;

	mov	esi, DWORD PTR _sim_y_max$1$[ebp]
	mov	DWORD PTR [edi], eax

; 126  :         head_idx = source_pos = update_pos = y_min - 1000; // Ridiculous value

	add	eax, -1000				; fffffc18H
	mov	DWORD PTR [edi+4], esi

; 127  :         this->symmetric_extension = symmetric_extension;
; 128  :         if ((!symmetric_extension) || (max_source_request_idx < y_max))

	mov	esi, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR tv1182[ebp], eax
	mov	DWORD PTR [edi+28], eax
	mov	DWORD PTR [edi+24], eax
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR _sim_y_max$1$[ebp]
	mov	BYTE PTR [edi+37], bl
	mov	BYTE PTR [edi+36], cl
	test	cl, cl
	je	SHORT $LN31@simulate_v
	mov	ecx, DWORD PTR _max_source_request_idx$1$[ebp]
	cmp	ecx, eax
	jl	SHORT $LN31@simulate_v

; 130  :         else
; 131  :           recycling_lim = 2*y_max - max_source_request_idx;

	add	eax, eax
	sub	eax, ecx
	jmp	SHORT $LN108@simulate_v
$LN31@simulate_v:

; 129  :           recycling_lim = y_max - 1; // Keep last row only

	dec	eax
$LN108@simulate_v:
	mov	DWORD PTR [edi+32], eax

; 132  :         if (queue_idx < 0)

	test	ebx, ebx
	jns	SHORT $LN32@simulate_v

; 133  :           source_pos = recycling_lim = y_max+2; // Block use of `access_source'

	mov	eax, DWORD PTR _sim_y_max$1$[ebp]
	add	eax, 2
	mov	DWORD PTR [edi+32], eax
	mov	DWORD PTR [edi+24], eax
$LN32@simulate_v:

; 134  :         tail_idx = head_idx - 2;

	mov	eax, DWORD PTR tv1182[ebp]
	add	eax, -2					; fffffffeH

; 135  :         head = tail = NULL;

	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+20], eax
	mov	DWORD PTR [edi+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 630  :       if ((s >= 0) && (vert_steps[s].support_length <= 0))

	test	ebx, ebx
	js	SHORT $LN2@simulate_v
	mov	eax, DWORD PTR [esi+48]
	cmp	BYTE PTR [eax+edx+1], 0
	ja	SHORT $LN2@simulate_v

; 631  :         queues[s].source_done();

	mov	ecx, DWORD PTR [esi+64]
	add	ecx, DWORD PTR tv1143[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 145  :         source_pos = recycling_lim = y_max + 2;

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 2
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+24], eax
$LN2@simulate_v:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 621  :   for (s=-1; s < num_vert_steps; s++)

	add	DWORD PTR tv1143[ebp], 40		; 00000028H
	inc	ebx
	add	edx, 20					; 00000014H
	cmp	ebx, DWORD PTR [esi+28]
	jl	$LL4@simulate_v
	xor	edx, edx
$LN3@simulate_v:

; 632  :     }
; 633  :   for (s=0; s <= num_vert_steps; s++)

	xor	edi, edi
	cmp	DWORD PTR [esi+28], edi
	jl	SHORT $LN6@simulate_v
$LL7@simulate_v:

; 634  :     step_next_row_pos[s] = y_min + 1 - ((y_min ^ s) & 1);

	mov	ecx, DWORD PTR [esi+72]
	mov	eax, ecx
	xor	eax, edi
	and	eax, 1
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+68]
	inc	ecx
	mov	DWORD PTR [eax+edi*4], ecx
	inc	edi
	cmp	edi, DWORD PTR [esi+28]
	jle	SHORT $LL7@simulate_v
$LN6@simulate_v:

; 635  : 
; 636  :   // Run the simulator
; 637  :   for (; y_next <= sim_y_max; y_next++)

	mov	eax, DWORD PTR _sim_y_max$1$[ebp]
	cmp	DWORD PTR [esi+80], eax
	jg	$LN99@simulate_v
	npad	3
$LL10@simulate_v:

; 638  :     { // Simulate lines being pushed in one by one
; 639  :       used_lines++; // Simulate getting new input line from the free list
; 640  :       if (used_lines > max_used_lines)

	mov	eax, DWORD PTR _max_used_lines$1$[ebp]
	inc	edx

; 641  :         max_used_lines = used_lines;
; 642  :       queues[-(y_next & 1)].simulate_push_line(y_next,used_lines);

	mov	edi, DWORD PTR [esi+80]
	cmp	edx, eax
	mov	ecx, DWORD PTR [esi+64]
	cmovg	eax, edx
	mov	DWORD PTR _used_lines$[ebp], edx
	mov	DWORD PTR _max_used_lines$1$[ebp], eax
	mov	eax, edi
	and	eax, 1
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 3
	sub	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 252  :         if ((idx < source_pos) && (idx < update_pos))

	cmp	edi, DWORD PTR [ecx+24]
	jge	SHORT $LN37@simulate_v
	cmp	edi, DWORD PTR [ecx+28]
	jge	SHORT $LN37@simulate_v

; 253  :           { // Recycle line immediatel.  It will never contribute.
; 254  :             used_lines--;  return;

	dec	edx
	mov	DWORD PTR _used_lines$[ebp], edx
	jmp	SHORT $LN36@simulate_v
$LN37@simulate_v:

; 255  :           }
; 256  :         if (tail_idx < head_idx)

	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR [ecx+16]
	jge	SHORT $LN38@simulate_v

; 257  :           head_idx = idx;

	mov	DWORD PTR [ecx+16], edi
$LN38@simulate_v:

; 258  :         tail_idx = idx;

	mov	DWORD PTR [ecx+20], edi
$LN36@simulate_v:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 644  :       s_max = 1-(y_next&1); // Most advanced lifting step which might

	mov	eax, DWORD PTR [esi+80]
	mov	ecx, 1
	and	eax, 1
	sub	ecx, eax
	mov	DWORD PTR _s_max$1$[ebp], ecx
$LL11@simulate_v:

; 649  :         {
; 650  :           generated_something = false;

	xor	bl, bl

; 651  :           for (s=0; (s <= s_max) && (s < num_vert_steps); s++)

	xor	eax, eax
	mov	BYTE PTR _generated_something$1$[ebp], bl
	mov	DWORD PTR _s$3$[ebp], eax
	test	ecx, ecx
	js	$LN102@simulate_v

; 649  :         {
; 650  :           generated_something = false;

	xor	edi, edi
	mov	DWORD PTR tv1140[ebp], eax
	mov	DWORD PTR tv1139[ebp], edi
	npad	6
$LL15@simulate_v:

; 651  :           for (s=0; (s <= s_max) && (s < num_vert_steps); s++)

	cmp	eax, DWORD PTR [esi+28]
	jge	$LN102@simulate_v

; 652  :             {
; 653  :               step = vert_steps + s;

	mov	ebx, DWORD PTR [esi+48]
	lea	ecx, DWORD PTR [eax*4]

; 654  :               src_idx = (step_next_row_pos[s] ^ 1) + 2*step->support_min;

	mov	eax, DWORD PTR [esi+68]
	add	ebx, edi
	mov	DWORD PTR tv1176[ebp], ecx
	mov	edi, DWORD PTR [ecx+eax]
	mov	eax, edi
	movsx	ecx, WORD PTR [ebx+4]
	xor	eax, 1
	lea	eax, DWORD PTR [eax+ecx*2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 179  :         update_pos = idx;

	mov	ecx, DWORD PTR tv1140[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 654  :               src_idx = (step_next_row_pos[s] ^ 1) + 2*step->support_min;

	mov	DWORD PTR _src_idx$1$[ebp], eax

; 655  :               if (!queues[s-1].test_update(step_next_row_pos[s],false))

	mov	eax, DWORD PTR [esi+64]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 179  :         update_pos = idx;

	mov	DWORD PTR [eax+ecx-12], edi

; 180  :         return ((idx >= head_idx) && (idx <= tail_idx) &&

	cmp	edi, DWORD PTR [eax+ecx-24]
	jl	$LN106@simulate_v
	cmp	edi, DWORD PTR [eax+ecx-20]
	jg	$LN106@simulate_v
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 657  :               if ((step->support_length > 0) &&

	mov	al, BYTE PTR [ebx+1]
	test	al, al
	je	SHORT $LN21@simulate_v
	lea	ecx, DWORD PTR _used_lines$[ebp]
	movzx	eax, al
	push	ecx
	mov	ecx, DWORD PTR [esi+64]
	add	ecx, DWORD PTR tv1140[ebp]
	push	eax
	push	DWORD PTR _src_idx$1$[ebp]
	call	?simulate_access_source@kd_vlift_queue@@QAE_NHHAAH@Z ; kd_vlift_queue::simulate_access_source
	mov	edx, DWORD PTR _used_lines$[ebp]
	mov	ecx, DWORD PTR tv1140[ebp]
	test	al, al
	je	$LN106@simulate_v
$LN21@simulate_v:

; 658  :                   !queues[s].simulate_access_source(src_idx,
; 659  :                                             step->support_length,used_lines))
; 660  :                 continue; // Can't access all source lines required by step
; 661  :               queues[s-1].simulate_access_update(step_next_row_pos[s],

	mov	eax, DWORD PTR [esi+68]
	add	ecx, DWORD PTR [esi+64]
	mov	edi, DWORD PTR tv1176[ebp]
	mov	edi, DWORD PTR [edi+eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 267  :         if ((idx < head_idx) || (idx > tail_idx))

	mov	eax, DWORD PTR [ecx-24]
	mov	DWORD PTR [ecx-12], edi
	cmp	edi, eax
	jl	SHORT $LN101@simulate_v
	mov	ebx, DWORD PTR [ecx-20]
	cmp	edi, ebx
	jg	SHORT $LN101@simulate_v

; 268  :           return false;
; 269  :         update_pos += 2;

	add	edi, 2
	mov	DWORD PTR [ecx-12], edi

; 270  :         while ((head_idx < update_pos) && (head_idx < source_pos) &&
; 271  :                (tail_idx >= head_idx) && (head_idx < recycling_lim))

	cmp	eax, edi
	jge	SHORT $LN101@simulate_v
	npad	3
$LL47@simulate_v:
	mov	eax, DWORD PTR [ecx-24]
	cmp	eax, DWORD PTR [ecx-16]
	jge	SHORT $LN101@simulate_v
	cmp	ebx, eax
	jl	SHORT $LN101@simulate_v
	cmp	eax, DWORD PTR [ecx-8]
	jge	SHORT $LN101@simulate_v

; 272  :           { head_idx+=2; used_lines--; }

	add	eax, 2
	dec	edx
	mov	DWORD PTR [ecx-24], eax
	cmp	eax, edi
	jl	SHORT $LL47@simulate_v
$LN101@simulate_v:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 664  :               if (used_lines > max_used_lines)

	mov	eax, DWORD PTR _max_used_lines$1$[ebp]
	inc	edx

; 665  :                 max_used_lines = used_lines;
; 666  :               if (s == (num_vert_steps-1))

	mov	ebx, DWORD PTR _s$3$[ebp]
	cmp	edx, eax
	mov	DWORD PTR _used_lines$[ebp], edx
	cmovg	eax, edx
	mov	DWORD PTR _max_used_lines$1$[ebp], eax
	mov	eax, DWORD PTR [esi+28]
	dec	eax
	cmp	ebx, eax
	jne	SHORT $LN23@simulate_v

; 667  :                 { // Last lifting step may have produced a result
; 668  :                   used_lines--; // Put the output line back on the free list

	dec	edx
	mov	DWORD PTR _used_lines$[ebp], edx

; 669  :                 }
; 670  :               else

	jmp	SHORT $LN24@simulate_v
$LN23@simulate_v:

; 671  :                 {
; 672  :                   queues[s+1].simulate_push_line(step_next_row_pos[s],

	mov	eax, DWORD PTR [esi+68]
	lea	ecx, DWORD PTR [ebx*4]
	mov	edi, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR tv1140[ebp]
	add	ecx, DWORD PTR [esi+64]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 252  :         if ((idx < source_pos) && (idx < update_pos))

	cmp	edi, DWORD PTR [ecx+64]
	jge	SHORT $LN53@simulate_v
	cmp	edi, DWORD PTR [ecx+68]
	jge	SHORT $LN53@simulate_v

; 253  :           { // Recycle line immediatel.  It will never contribute.
; 254  :             used_lines--;  return;

	dec	edx
	mov	DWORD PTR _used_lines$[ebp], edx
	jmp	SHORT $LN52@simulate_v
$LN53@simulate_v:

; 255  :           }
; 256  :         if (tail_idx < head_idx)

	mov	eax, DWORD PTR [ecx+60]
	cmp	eax, DWORD PTR [ecx+56]
	jge	SHORT $LN54@simulate_v

; 257  :           head_idx = idx;

	mov	DWORD PTR [ecx+56], edi
$LN54@simulate_v:

; 258  :         tail_idx = idx;

	mov	DWORD PTR [ecx+60], edi
$LN52@simulate_v:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 674  :                   s_max = s+2;

	lea	eax, DWORD PTR [ebx+2]
	mov	DWORD PTR _s_max$1$[ebp], eax
$LN24@simulate_v:

; 675  :                 }
; 676  :               step_next_row_pos[s] += 2;
; 677  :               generated_something = true;

	mov	eax, DWORD PTR [esi+68]
	mov	bl, 1
	mov	ecx, DWORD PTR tv1176[ebp]

; 678  :               if (step_next_row_pos[s] > sim_y_max)

	mov	edi, DWORD PTR _sim_y_max$1$[ebp]
	mov	BYTE PTR _generated_something$1$[ebp], bl
	add	DWORD PTR [eax+ecx], 2
	mov	eax, DWORD PTR [esi+68]
	cmp	DWORD PTR [ecx+eax], edi
	jle	SHORT $LN104@simulate_v

; 679  :                 queues[s].source_done();

	mov	ecx, DWORD PTR [esi+64]
	add	ecx, DWORD PTR tv1140[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 145  :         source_pos = recycling_lim = y_max + 2;

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 2
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+24], eax
$LN104@simulate_v:
	mov	ecx, DWORD PTR tv1140[ebp]
	jmp	SHORT $LN13@simulate_v
$LN106@simulate_v:
	mov	bl, BYTE PTR _generated_something$1$[ebp]
$LN13@simulate_v:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 651  :           for (s=0; (s <= s_max) && (s < num_vert_steps); s++)

	mov	eax, DWORD PTR _s$3$[ebp]
	add	ecx, 40					; 00000028H
	mov	edi, DWORD PTR tv1139[ebp]
	inc	eax
	add	edi, 20					; 00000014H
	mov	DWORD PTR _s$3$[ebp], eax
	mov	DWORD PTR tv1139[ebp], edi
	mov	DWORD PTR tv1140[ebp], ecx
	cmp	eax, DWORD PTR _s_max$1$[ebp]
	jle	$LL15@simulate_v
$LN102@simulate_v:

; 680  :             }
; 681  :           // Finish off by seeing if we can pull an output line from the
; 682  :           // vertical subband which is used as the source for the last
; 683  :           // lifting step -- we need to wait until the line is no longer
; 684  :           // required as a lifting step source, since we will be doing
; 685  :           // in-place horizontal lifting on it.
; 686  :           s = num_vert_steps;

	mov	ecx, DWORD PTR [esi+28]

; 687  :           if (queues[s-1].test_update(step_next_row_pos[s],true))

	mov	eax, DWORD PTR [esi+68]
	lea	edi, DWORD PTR [ecx*4]
	mov	DWORD PTR tv1175[ebp], edi
	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	edi, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [esi+64]
	shl	ecx, 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 179  :         update_pos = idx;

	mov	DWORD PTR [ecx+eax-12], edi

; 180  :         return ((idx >= head_idx) && (idx <= tail_idx) &&

	cmp	edi, DWORD PTR [ecx+eax-24]
	jl	SHORT $LN26@simulate_v
	cmp	edi, DWORD PTR [ecx+eax-20]
	jg	SHORT $LN26@simulate_v
	cmp	edi, DWORD PTR [ecx+eax-16]
	jge	SHORT $LN26@simulate_v
	cmp	edi, DWORD PTR [ecx+eax-8]
	jge	SHORT $LN26@simulate_v
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 689  :               queues[s-1].simulate_access_update(step_next_row_pos[s],

	mov	eax, DWORD PTR [esi+68]
	add	ecx, DWORD PTR [esi+64]
	mov	edi, DWORD PTR tv1175[ebp]
	mov	edi, DWORD PTR [edi+eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 267  :         if ((idx < head_idx) || (idx > tail_idx))

	mov	eax, DWORD PTR [ecx-24]
	mov	DWORD PTR [ecx-12], edi
	cmp	edi, eax
	jl	SHORT $LN103@simulate_v
	mov	ebx, DWORD PTR [ecx-20]
	cmp	edi, ebx
	jg	SHORT $LN103@simulate_v

; 268  :           return false;
; 269  :         update_pos += 2;

	add	edi, 2
	mov	DWORD PTR [ecx-12], edi

; 270  :         while ((head_idx < update_pos) && (head_idx < source_pos) &&
; 271  :                (tail_idx >= head_idx) && (head_idx < recycling_lim))

	cmp	eax, edi
	jge	SHORT $LN103@simulate_v
$LL65@simulate_v:
	mov	eax, DWORD PTR [ecx-24]
	cmp	eax, DWORD PTR [ecx-16]
	jge	SHORT $LN103@simulate_v
	cmp	ebx, eax
	jl	SHORT $LN103@simulate_v
	cmp	eax, DWORD PTR [ecx-8]
	jge	SHORT $LN103@simulate_v

; 272  :           { head_idx+=2; used_lines--; }

	add	eax, 2
	dec	edx
	mov	DWORD PTR [ecx-24], eax
	mov	DWORD PTR _used_lines$[ebp], edx
	cmp	eax, edi
	jl	SHORT $LL65@simulate_v
$LN103@simulate_v:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 691  :               step_next_row_pos[s] += 2;

	mov	ecx, DWORD PTR tv1175[ebp]
	mov	eax, DWORD PTR [esi+68]
	add	DWORD PTR [eax+ecx], 2
	mov	ecx, DWORD PTR _s_max$1$[ebp]
	jmp	$LL11@simulate_v
$LN26@simulate_v:

; 645  :           // now be able to advance for the first time, assuming no earlier
; 646  :           // ones can advance
; 647  :       bool generated_something = true;
; 648  :       while (generated_something)

	mov	ecx, DWORD PTR _s_max$1$[ebp]
	test	bl, bl
	jne	$LL11@simulate_v

; 635  : 
; 636  :   // Run the simulator
; 637  :   for (; y_next <= sim_y_max; y_next++)

	inc	DWORD PTR [esi+80]
	mov	eax, DWORD PTR _sim_y_max$1$[ebp]
	cmp	DWORD PTR [esi+80], eax
	jle	$LL10@simulate_v

; 692  :               generated_something = true;
; 693  :             }
; 694  :         } // End of `while (generated_something)' loop
; 695  :     }
; 696  : 
; 697  :   return max_used_lines;

	mov	eax, DWORD PTR _max_used_lines$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 698  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN99@simulate_v:
	pop	edi
	pop	esi

; 692  :               generated_something = true;
; 693  :             }
; 694  :         } // End of `while (generated_something)' loop
; 695  :     }
; 696  : 
; 697  :   return max_used_lines;

	xor	eax, eax
	pop	ebx

; 698  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?simulate_vertical_lifting@kd_analysis@@AAEHH@Z ENDP	; kd_analysis::simulate_vertical_lifting
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
;	COMDAT ?push@kd_analysis@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_vsub_parity$2$ = -48					; size = 4
tv2731 = -44						; size = 4
tv2775 = -40						; size = 4
_vline_in$3$ = -36					; size = 4
tv2747 = -36						; size = 4
tv2746 = -36						; size = 4
tv2733 = -32						; size = 4
_s$1$ = -28						; size = 4
_queue$1$ = -28						; size = 4
_s_max$1$ = -24						; size = 4
_vline_out$1$ = -20					; size = 4
_step$1$ = -16						; size = 4
tv2745 = -16						; size = 4
tv2741 = -16						; size = 4
tv2736 = -16						; size = 4
_vsub_parity$1$ = -12					; size = 4
tv2740 = -12						; size = 4
_vline_in$2$ = -8					; size = 4
tv2739 = -8						; size = 4
_this$1$ = -4						; size = 4
_dp2$1$ = 8						; size = 4
tv2732 = 8						; size = 4
_line$ = 8						; size = 4
$T1 = 12						; size = 4
_env$ = 12						; size = 4
?push@kd_analysis@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z PROC ; kd_analysis::push, COMDAT
; _this$ = ecx

; 706  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	edx, ecx
	mov	DWORD PTR _this$1$[ebp], edx

; 707  :   assert(y_next <= y_max);
; 708  :   assert(reversible == line.is_absolute());
; 709  :   if (empty)

	cmp	BYTE PTR [edx+102], 0
	je	SHORT $LN55@push

; 710  :     { // in case horizontal extent is 0, but vertical extent non-zero
; 711  :       y_next++;

	inc	DWORD PTR [edx+80]

; 942  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN55@push:

; 712  :       return;
; 713  :     }
; 714  : 
; 715  :   kd_vlift_line *vline_in, *vline_out;
; 716  :   if (!initialized)

	cmp	BYTE PTR [edx+22], 0
	push	ebx
	push	esi
	jne	SHORT $LN107@push

; 717  :     { // Finish creating all the buffers.
; 718  :       if (env != NULL)

	mov	ebx, DWORD PTR _env$[ebp]
	test	ebx, ebx
	je	SHORT $LN95@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	esi, DWORD PTR [ebx+28]
	cmp	BYTE PTR [eax], 0
	jne	$LN313@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN98@push
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	edx, DWORD PTR _this$1$[ebp]
$LN98@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [esi+28], ebx
$LN95@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 720  :       for (vline_in=free_lines; vline_in != NULL; vline_in=vline_in->next)

	mov	esi, DWORD PTR [edx+44]
	test	esi, esi
	je	SHORT $LN3@push
$LL4@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 82   :       { cosets[0].create(); cosets[1].create(); }

	mov	ecx, esi
	call	?create@kdu_line_buf@@QAEXXZ		; kdu_line_buf::create
	lea	ecx, DWORD PTR [esi+12]
	call	?create@kdu_line_buf@@QAEXXZ		; kdu_line_buf::create
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 720  :       for (vline_in=free_lines; vline_in != NULL; vline_in=vline_in->next)

	mov	esi, DWORD PTR [esi+24]
	test	esi, esi
	jne	SHORT $LL4@push
	mov	edx, DWORD PTR _this$1$[ebp]
$LN3@push:

; 721  :         vline_in->create();
; 722  :       initialized = true;

	mov	BYTE PTR [edx+22], 1

; 723  :       if (env != NULL)

	test	ebx, ebx
	je	SHORT $LN107@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [ebx+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+28], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $LN107@push
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	mov	edx, DWORD PTR _this$1$[ebp]
$LN107@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 731  :   int vsub_parity = (vert_xform_exists)?(y_next & 1):0; // vert subband parity

	cmp	BYTE PTR [edx+23], 0
	lea	esi, DWORD PTR [edx+44]
	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR _vline_in$2$[ebp], ebx
	mov	DWORD PTR _queue$1$[ebp], 0
	je	SHORT $LN91@push
	mov	ecx, DWORD PTR [edx+80]
	and	ecx, 1
	jmp	SHORT $LN309@push
$LN91@push:
	xor	ecx, ecx
$LN309@push:

; 732  :   if ((num_vert_steps > 0) && !unit_height)

	cmp	DWORD PTR [edx+28], 0
	mov	DWORD PTR _vsub_parity$1$[ebp], ecx
	jle	SHORT $LN59@push
	cmp	BYTE PTR [edx+100], 0
	jne	SHORT $LN59@push

; 733  :     {
; 734  :       free_lines = vline_in->next;  vline_in->next = NULL;

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR [esi], eax

; 735  :       queue = queues - vsub_parity;

	lea	eax, DWORD PTR [ecx+ecx*4]

; 736  :       queue->push_line(y_next,vline_in,free_lines);

	push	esi
	mov	DWORD PTR [ebx+24], 0
	mov	ecx, DWORD PTR [edx+64]
	shl	eax, 3
	push	ebx
	push	DWORD PTR [edx+80]
	sub	ecx, eax
	mov	DWORD PTR _queue$1$[ebp], ecx
	call	?push_line@kd_vlift_queue@@QAEXHPAUkd_vlift_line@@AAPAU2@@Z ; kd_vlift_queue::push_line
	mov	edx, DWORD PTR _this$1$[ebp]
$LN59@push:

; 737  :     }
; 738  :   y_next++;

	inc	DWORD PTR [edx+80]

; 739  : 
; 740  :   // Copy the samples from `line' to `vline', de-interleaving even and odd
; 741  :   // sub-sequences and supplying any normalizing downshifts, as required.
; 742  :   assert(line.get_width() == (coset_width[0]+coset_width[1]));
; 743  :   int c = x_min & 1; // Index of first coset to be de-interleaved.

	mov	eax, DWORD PTR [edx+84]
	push	edi

; 744  :   int k = (line.get_width()+1)>>1; // May move one extra sample.

	mov	edi, DWORD PTR _line$[ebp]
	and	eax, 1
	mov	esi, DWORD PTR [edi]
	inc	esi
	sar	esi, 1

; 745  :   if (!hor_xform_exists)

	cmp	BYTE PTR [edx+24], 0
	jne	$LN60@push

; 746  :     { // Just transfer contents to coset[0]
; 747  :       if (!use_shorts)

	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN62@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edi+6], 2
	je	SHORT $LN113@push
	xor	ecx, ecx
	jmp	SHORT $LN114@push
$LN113@push:
	mov	ecx, DWORD PTR [edi+8]
$LN114@push:
	test	BYTE PTR [ebx+6], 2
	je	SHORT $LN117@push
	xor	edx, edx
	jmp	SHORT $LN118@push
$LN117@push:
	mov	edx, DWORD PTR [ebx+8]
$LN118@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 752  :           for (; k--; sp+=2, dp+=2)

	test	esi, esi
	je	$LN246@push
	sub	edx, ecx
	npad	4
$LL7@push:

; 753  :             { dp[0] = sp[0];  dp[1] = sp[1]; }

	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+ecx-8], eax
	mov	eax, DWORD PTR [ecx-4]
	mov	DWORD PTR [edx+ecx-4], eax
	sub	esi, 1
	jne	SHORT $LL7@push

; 754  :         }
; 755  :       else

	jmp	$LN246@push
$LN62@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [edi+6], 2
	je	SHORT $LN121@push
	mov	edx, DWORD PTR [edi+8]
	jmp	SHORT $LN122@push
$LN121@push:
	xor	edx, edx
$LN122@push:
	test	BYTE PTR [ebx+6], 2
	je	SHORT $LN125@push
	mov	edi, DWORD PTR [ebx+8]
	jmp	SHORT $LN126@push
$LN125@push:
	xor	edi, edi
$LN126@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 759  :           if (normalizing_downshift == 0)

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	test	ecx, ecx
	jne	SHORT $LN64@push

; 760  :             for (; k--; sp+=2, dp+=2)

	test	esi, esi
	je	$LN246@push
	sub	edi, edx
	npad	8
$LL10@push:

; 761  :               { dp[0] = sp[0]; dp[1] = sp[1]; }

	movzx	eax, WORD PTR [edx]
	lea	edx, DWORD PTR [edx+4]
	mov	WORD PTR [edi+edx-4], ax
	movzx	eax, WORD PTR [edx-2]
	mov	WORD PTR [edi+edx-2], ax
	sub	esi, 1
	jne	SHORT $LL10@push

; 762  :           else

	jmp	$LN246@push
$LN64@push:

; 763  :             {
; 764  :               kdu_int16 offset = (kdu_int16)((1<<normalizing_downshift)>>1);

	mov	eax, 1
	shl	eax, cl
	sar	eax, 1
	movzx	eax, ax

; 765  :               for (; k--; sp+=2, dp+=2)

	test	esi, esi
	je	$LN246@push
	movsx	ebx, ax
$LL13@push:

; 766  :                 {
; 767  :                   dp[0].ival = (sp[0].ival+offset) >> normalizing_downshift;

	movsx	eax, WORD PTR [edx]
	lea	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	edi, DWORD PTR [edi+4]
	add	eax, ebx
	mov	ecx, DWORD PTR [ecx+60]
	sar	eax, cl

; 768  :                   dp[1].ival = (sp[1].ival+offset) >> normalizing_downshift;

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	WORD PTR [edi-4], ax
	movsx	eax, WORD PTR [edx-2]
	add	eax, ebx
	mov	ecx, DWORD PTR [ecx+60]
	sar	eax, cl
	mov	WORD PTR [edi-2], ax
	sub	esi, 1
	jne	SHORT $LL13@push

; 769  :                 }
; 770  :             }
; 771  :         }
; 772  :     }
; 773  :   else

	jmp	$LN302@push
$LN60@push:

; 774  :     { // De-interleave into low- and high-pass cosets
; 775  :       if (!use_shorts)

	cmp	BYTE PTR [edx+21], 0
	jne	SHORT $LN66@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edi+6], 2
	je	SHORT $LN129@push
	xor	edx, edx
	jmp	SHORT $LN130@push
$LN129@push:
	mov	edx, DWORD PTR [edi+8]
$LN130@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 778  :           kdu_sample32 *dp1 = vline_in->cosets[c].get_buf32();

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [eax+ebx+6], 2
	je	SHORT $LN133@push
	xor	ecx, ecx
	jmp	SHORT $LN134@push
$LN133@push:
	mov	ecx, DWORD PTR [eax+ebx+8]
$LN134@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 779  :           kdu_sample32 *dp2 = vline_in->cosets[1-c].get_buf32();

	mov	edi, ebx
	sub	edi, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edi+18], 2
	je	SHORT $LN137@push
	xor	edi, edi
	jmp	SHORT $LN138@push
$LN137@push:
	mov	edi, DWORD PTR [edi+20]
$LN138@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 781  :           for (; k--; sp+=2, dp1++, dp2++)

	test	esi, esi
	je	$LN246@push
	sub	edi, ecx
	npad	5
$LL16@push:

; 782  :             { *dp1 = sp[0]; *dp2 = sp[1]; }

	mov	eax, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax
	lea	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR [edi+ecx-4], eax
	sub	esi, 1
	jne	SHORT $LL16@push

; 783  :         }
; 784  :       else

	jmp	$LN246@push
$LN66@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [edi+6], 2
	je	SHORT $LN141@push
	mov	edi, DWORD PTR [edi+8]
	jmp	SHORT $LN142@push
$LN141@push:
	xor	edi, edi
$LN142@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 787  :           kdu_sample16 *dp1 = vline_in->cosets[c].get_buf16();

	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ecx+ebx+6], 2
	je	SHORT $LN145@push
	mov	ebx, DWORD PTR [ecx+ebx+8]
	jmp	SHORT $LN146@push
$LN145@push:
	xor	ebx, ebx
$LN146@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 788  :           kdu_sample16 *dp2 = vline_in->cosets[1-c].get_buf16();

	mov	eax, DWORD PTR _vline_in$2$[ebp]
	sub	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [eax+18], 2
	je	SHORT $LN149@push
	mov	eax, DWORD PTR [eax+20]
	jmp	SHORT $LN310@push
$LN149@push:
	xor	eax, eax
$LN310@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 789  :           if (normalizing_downshift == 0)

	mov	ecx, DWORD PTR [edx+60]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	mov	DWORD PTR _dp2$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 789  :           if (normalizing_downshift == 0)

	test	ecx, ecx
	jne	SHORT $LN68@push

; 790  :             {
; 791  : #ifdef KDU_SIMD_OPTIMIZATIONS
; 792  :               if (!simd_deinterleave(&(sp->ival),&(dp1->ival),&(dp2->ival),k))

	push	esi
	push	eax
	push	ebx
	push	edi
	call	?simd_deinterleave@@YA_NPAF00H@Z	; simd_deinterleave
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN302@push

; 793  : #endif // KDU_SIMD_OPTIMIZATIONS
; 794  :                 for (; k--; sp+=2, dp1++, dp2++)

	test	esi, esi
	je	$LN302@push
	mov	ecx, DWORD PTR _dp2$1$[ebp]
	sub	ecx, ebx
	npad	6
$LL19@push:

; 795  :                   { *dp1 = sp[0]; *dp2 = sp[1]; }

	movzx	eax, WORD PTR [edi]
	lea	edi, DWORD PTR [edi+4]
	mov	WORD PTR [ebx], ax
	lea	ebx, DWORD PTR [ebx+2]
	movzx	eax, WORD PTR [edi-2]
	mov	WORD PTR [ecx+ebx-2], ax
	sub	esi, 1
	jne	SHORT $LL19@push

; 796  :             }
; 797  :           else

	jmp	SHORT $LN302@push
$LN68@push:

; 798  :             {
; 799  : #ifdef KDU_SIMD_OPTIMIZATIONS
; 800  :               if (!simd_downshifted_deinterleave(&(sp->ival),&(dp1->ival),

	push	ecx
	push	esi
	push	eax
	push	ebx
	push	edi
	call	?simd_downshifted_deinterleave@@YA_NPAF00HH@Z ; simd_downshifted_deinterleave
	add	esp, 20					; 00000014H
	test	al, al
	jne	SHORT $LN302@push

; 801  :                                       &(dp2->ival),k,normalizing_downshift))
; 802  : #endif // KDU_SIMD_OPTIMIZATIONS
; 803  :                 {
; 804  :                   kdu_int16 offset=(kdu_int16)((1<<normalizing_downshift)>>1);

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [ecx+60]
	shl	eax, cl
	sar	eax, 1
	movzx	eax, ax

; 805  :                   for (; k--; sp+=2, dp1++, dp2++)

	test	esi, esi
	je	SHORT $LN302@push
	movsx	edx, ax
$LL22@push:

; 806  :                     {
; 807  :                       dp1->ival = (sp[0].ival+offset) >> normalizing_downshift;

	movsx	eax, WORD PTR [edi]
	lea	edi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	ebx, DWORD PTR [ebx+2]
	add	eax, edx
	mov	ecx, DWORD PTR [ecx+60]
	sar	eax, cl

; 808  :                       dp2->ival = (sp[1].ival+offset) >> normalizing_downshift;

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	WORD PTR [ebx-2], ax
	movsx	eax, WORD PTR [edi-2]
	add	eax, edx
	mov	ecx, DWORD PTR [ecx+60]
	sar	eax, cl
	mov	ecx, DWORD PTR _dp2$1$[ebp]
	mov	WORD PTR [ecx], ax
	add	ecx, 2
	mov	DWORD PTR _dp2$1$[ebp], ecx
	sub	esi, 1
	jne	SHORT $LL22@push
$LN302@push:
	mov	ebx, DWORD PTR _vline_in$2$[ebp]
$LN246@push:

; 809  :                     }
; 810  :                 }
; 811  :             }
; 812  :         }
; 813  :     }
; 814  : 
; 815  :   // Now perform the transform
; 816  :   if (unit_height && reversible && vsub_parity)

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	edi, DWORD PTR _vsub_parity$1$[ebp]
	cmp	BYTE PTR [ecx+100], 0
	je	SHORT $LN30@push
	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN30@push
	test	edi, edi
	je	SHORT $LN30@push

; 817  :     { // Reversible transform of a single odd-indexed sample -- double int vals
; 818  :       assert(vert_xform_exists);
; 819  :       if (!use_shorts)

	cmp	BYTE PTR [ecx+21], 0

; 820  :         { // Working with 32-bit data
; 821  :           kdu_sample32 *dp;
; 822  :           for (c=0; c < 2; c++)

	lea	edx, DWORD PTR [ebx+8]
	mov	esi, 2
	jne	SHORT $LL31@push
$LL25@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [edx-2], 2
	je	SHORT $LN153@push
	xor	eax, eax
	jmp	SHORT $LN154@push
$LN153@push:
	mov	eax, DWORD PTR [edx]
$LN154@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 824  :                  k=vline_in->cosets[c].get_width(); k--; dp++)

	mov	ecx, DWORD PTR [edx-8]
	test	ecx, ecx
	je	SHORT $LN248@push
$LL28@push:

; 825  :               dp->ival <<= 1;

	shl	DWORD PTR [eax], 1
	lea	eax, DWORD PTR [eax+4]
	sub	ecx, 1
	jne	SHORT $LL28@push
$LN248@push:

; 820  :         { // Working with 32-bit data
; 821  :           kdu_sample32 *dp;
; 822  :           for (c=0; c < 2; c++)

	add	edx, 12					; 0000000cH
	sub	esi, 1
	jne	SHORT $LL25@push

; 826  :         }
; 827  :       else

	jmp	SHORT $LN312@push
	npad	6
$LL31@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [edx-2], 2
	je	SHORT $LN159@push
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $LN160@push
$LN159@push:
	xor	eax, eax
$LN160@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 832  :                  k=vline_in->cosets[c].get_width(); k--; dp++)

	mov	ecx, DWORD PTR [edx-8]
	test	ecx, ecx
	je	SHORT $LN251@push
$LL34@push:

; 833  :               dp->ival <<= 1;

	shl	WORD PTR [eax], 1
	lea	eax, DWORD PTR [eax+2]
	sub	ecx, 1
	jne	SHORT $LL34@push
$LN251@push:

; 828  :         { // Working with 16-bit data
; 829  :           kdu_sample16 *dp;
; 830  :           for (c=0; c < 2; c++)

	add	edx, 12					; 0000000cH
	sub	esi, 1
	jne	SHORT $LL31@push
$LN312@push:
	mov	ecx, DWORD PTR _this$1$[ebp]
$LN30@push:

; 834  :         }
; 835  :     }
; 836  : 
; 837  :   if (queue == NULL)

	cmp	DWORD PTR _queue$1$[ebp], 0
	jne	SHORT $LN75@push

; 838  :     horizontal_analysis(vline_in,vsub_parity,env); // No vertical transform

	push	DWORD PTR _env$[ebp]
	push	edi
	push	ebx
	call	?horizontal_analysis@kd_analysis@@AAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z ; kd_analysis::horizontal_analysis
	pop	edi
	pop	esi
	pop	ebx

; 942  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN75@push:

; 839  :   else
; 840  :     { // Need to perform the vertical transform
; 841  :       kd_lifting_step *step;
; 842  :       assert((num_vert_steps > 0) && !unit_height);
; 843  :       int src_idx, s;
; 844  :       int s_max = 1-vsub_parity; // Most advanced lifting step which might

	mov	eax, 1
	sub	eax, edi
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _s_max$1$[ebp], eax
	npad	1
$LL35@push:

; 851  :           for (s=0; (s <= s_max) && (s < num_vert_steps); s++)

	xor	ecx, ecx
	xor	bl, bl
	mov	DWORD PTR _s$1$[ebp], ecx
	test	eax, eax
	js	$LN298@push

; 849  :         {
; 850  :           generated_something = false;

	xor	eax, eax
	mov	DWORD PTR tv2732[ebp], ecx
	mov	DWORD PTR tv2731[ebp], eax
$LL39@push:

; 851  :           for (s=0; (s <= s_max) && (s < num_vert_steps); s++)

	cmp	ecx, DWORD PTR [edi+28]
	jge	$LN298@push

; 852  :             {
; 853  :               step = vert_steps + s;

	mov	esi, DWORD PTR [edi+48]

; 854  :               vsub_parity = 1 - (s & 1); // Parity of output line for this step

	mov	edx, 1
	add	esi, eax
	mov	eax, ecx
	and	eax, 1
	shl	ecx, 2
	sub	edx, eax
	mov	DWORD PTR tv2775[ebp], ecx

; 855  :               src_idx = (step_next_row_pos[s] ^ 1) + 2*step->support_min;

	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR _vsub_parity$2$[ebp], edx
	mov	DWORD PTR _step$1$[ebp], esi
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, edx
	movsx	ecx, WORD PTR [esi+4]
	xor	eax, 1
	lea	ecx, DWORD PTR [eax+ecx*2]

; 856  :               vline_in = vline_out = NULL;
; 857  :               if (!queues[s-1].test_update(step_next_row_pos[s],false))

	mov	eax, DWORD PTR [edi+64]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 179  :         update_pos = idx;

	mov	edi, DWORD PTR tv2732[ebp]

; 180  :         return ((idx >= head_idx) && (idx <= tail_idx) &&

	cmp	edx, DWORD PTR [edi+eax-24]
	mov	DWORD PTR [edi+eax-12], edx
	mov	edi, DWORD PTR _this$1$[ebp]
	jl	$LN37@push
	mov	esi, DWORD PTR tv2732[ebp]
	cmp	edx, DWORD PTR [esi+eax-20]
	mov	esi, DWORD PTR _step$1$[ebp]
	jg	$LN37@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 859  :               if ((step->support_length > 0) &&

	mov	al, BYTE PTR [esi+1]
	test	al, al
	je	SHORT $LN78@push
	lea	edx, DWORD PTR [edi+44]
	movzx	eax, al
	push	edx
	push	DWORD PTR [edi+36]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [edi+64]
	add	ecx, DWORD PTR tv2732[ebp]
	call	?access_source@kd_vlift_queue@@QAE_NHHQAPAUkd_vlift_line@@AAPAU2@@Z ; kd_vlift_queue::access_source
	test	al, al
	je	$LN37@push
$LN78@push:

; 860  :                   !queues[s].access_source(src_idx,step->support_length,
; 861  :                                            vert_source_vlines,free_lines))
; 862  :                 continue; // Can't access all source lines required by step
; 863  :               vline_in =

	mov	eax, DWORD PTR [edi+68]
	lea	ebx, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR tv2775[ebp]
	push	ebx
	push	DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR tv2732[ebp]
	add	ecx, -40				; ffffffd8H
	add	ecx, DWORD PTR [edi+64]
	call	?access_update@kd_vlift_queue@@QAEPAUkd_vlift_line@@HAAPAU2@@Z ; kd_vlift_queue::access_update
	mov	edx, eax

; 864  :                 queues[s-1].access_update(step_next_row_pos[s],free_lines);
; 865  :               vline_out = free_lines;  assert(vline_out != NULL);

	mov	eax, DWORD PTR [ebx]

; 866  :               if (step->support_length <= 0)

	mov	ebx, DWORD PTR _step$1$[ebp]
	mov	DWORD PTR _vline_out$1$[ebp], eax
	cmp	BYTE PTR [ebx+1], 0
	ja	$LN79@push

; 867  :                 {
; 868  :                   if (use_shorts)

	cmp	BYTE PTR [edi+21], 0

; 869  :                     for (c=0; c < 2; c++)

	lea	ebx, DWORD PTR [edi+92]
	lea	esi, DWORD PTR [edx+8]
	lea	edi, DWORD PTR [eax+6]
	je	SHORT $LN81@push
	sub	eax, edx
	mov	DWORD PTR tv2745[ebp], 2
	mov	DWORD PTR tv2747[ebp], eax
$LL42@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [esi-2], 2
	je	SHORT $LN171@push
	mov	edx, DWORD PTR [esi]
	jmp	SHORT $LN172@push
$LN171@push:
	xor	edx, edx
$LN172@push:
	test	BYTE PTR [edi], 2
	je	SHORT $LN175@push
	mov	ecx, DWORD PTR [eax+esi]
	jmp	SHORT $LN176@push
$LN175@push:
	xor	ecx, ecx
$LN176@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 870  :                       memcpy(vline_out->cosets[c].get_buf16(),

	mov	eax, DWORD PTR [ebx]
	add	eax, eax
	push	eax
	push	edx
	push	ecx
	call	_memcpy
	mov	eax, DWORD PTR tv2747[ebp]
	add	esp, 12					; 0000000cH
	add	ebx, 4
	add	esi, 12					; 0000000cH
	add	edi, 12					; 0000000cH
	sub	DWORD PTR tv2745[ebp], 1
	jne	SHORT $LL42@push

; 871  :                              vline_in->cosets[c].get_buf16(),
; 872  :                              (size_t)(coset_width[c]<<1));
; 873  :                   else

	mov	edi, DWORD PTR _this$1$[ebp]
	jmp	$LN47@push
$LN81@push:

; 874  :                     for (c=0; c < 2; c++)

	sub	eax, edx
	mov	DWORD PTR tv2741[ebp], 2
	mov	DWORD PTR tv2746[ebp], eax
$LL45@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [esi-2], 2
	je	SHORT $LN179@push
	xor	edx, edx
	jmp	SHORT $LN180@push
$LN179@push:
	mov	edx, DWORD PTR [esi]
$LN180@push:
	test	BYTE PTR [edi], 2
	je	SHORT $LN183@push
	xor	ecx, ecx
	jmp	SHORT $LN184@push
$LN183@push:
	mov	ecx, DWORD PTR [esi+eax]
$LN184@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 875  :                       memcpy(vline_out->cosets[c].get_buf32(),

	mov	eax, DWORD PTR [ebx]
	shl	eax, 2
	push	eax
	push	edx
	push	ecx
	call	_memcpy
	mov	eax, DWORD PTR tv2746[ebp]
	add	esp, 12					; 0000000cH
	add	ebx, 4
	add	esi, 12					; 0000000cH
	add	edi, 12					; 0000000cH
	sub	DWORD PTR tv2741[ebp], 1
	jne	SHORT $LL45@push

; 876  :                              vline_in->cosets[c].get_buf32(),
; 877  :                              (size_t)(coset_width[c]<<2));
; 878  :                 }
; 879  :               else

	mov	edi, DWORD PTR _this$1$[ebp]
	jmp	$LN47@push
$LN79@push:

; 880  :                 {
; 881  :                   int k;
; 882  :                   for (c=0; c < 2; c++)

	lea	eax, DWORD PTR [edx+6]
	mov	DWORD PTR tv2736[ebp], 2
	mov	DWORD PTR tv2739[ebp], eax
	lea	ecx, DWORD PTR [edi+92]
	mov	eax, DWORD PTR _vline_out$1$[ebp]
	sub	edx, eax
	mov	DWORD PTR _vline_in$3$[ebp], edx
	mov	edx, DWORD PTR tv2736[ebp]
	mov	DWORD PTR tv2740[ebp], ecx
	lea	esi, DWORD PTR [eax+8]
	mov	eax, -8					; fffffff8H
	sub	eax, DWORD PTR _vline_out$1$[ebp]
	mov	DWORD PTR tv2733[ebp], eax
	mov	eax, DWORD PTR tv2739[ebp]
$LL48@push:

; 883  :                     {
; 884  :                       if (coset_width[c] == 0)

	cmp	DWORD PTR [ecx], 0
	je	$LN46@push

; 885  :                         continue;
; 886  :                       if (use_shorts)
; 887  :                         {
; 888  :                           kdu_sample16 **bf=(kdu_sample16 **) vert_source_bufs;

	mov	edx, DWORD PTR [edi+40]

; 889  :                           for (k=0; k < (int) step->support_length; k++)

	xor	ecx, ecx
	cmp	BYTE PTR [edi+21], cl
	je	SHORT $LN84@push
	cmp	BYTE PTR [ebx+1], cl
	jbe	SHORT $LN50@push
	npad	4
$LL51@push:

; 890  :                             bf[k]=vert_source_vlines[k]->cosets[c].get_buf16();

	mov	eax, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [eax+ecx*4]
	add	eax, DWORD PTR tv2733[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [eax+esi+6], 2
	je	SHORT $LN187@push
	mov	eax, DWORD PTR [eax+esi+8]
	jmp	SHORT $LN188@push
$LN187@push:
	xor	eax, eax
$LN188@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 890  :                             bf[k]=vert_source_vlines[k]->cosets[c].get_buf16();

	mov	DWORD PTR [edx+ecx*4], eax
	inc	ecx
	movzx	eax, BYTE PTR [ebx+1]
	cmp	ecx, eax
	jl	SHORT $LL51@push
$LN50@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [esi-2], 2
	je	SHORT $LN191@push
	mov	ecx, DWORD PTR [esi]
	jmp	SHORT $LN192@push
$LN191@push:
	xor	ecx, ecx
$LN192@push:
	mov	eax, DWORD PTR tv2739[ebp]
	test	BYTE PTR [eax], 2
	je	SHORT $LN195@push
	mov	eax, DWORD PTR _vline_in$3$[ebp]
	mov	eax, DWORD PTR [eax+esi]
	jmp	SHORT $LN196@push
$LN195@push:
	xor	eax, eax
$LN196@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 891  :                           perform_analysis_lifting_step(step,bf,

	mov	edi, DWORD PTR tv2740[ebp]
	push	0
	push	DWORD PTR [edi]
	push	ecx
	push	eax
	push	edx
	push	ebx
	call	?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z ; perform_analysis_lifting_step

; 892  :                                       vline_in->cosets[c].get_buf16(),
; 893  :                                       vline_out->cosets[c].get_buf16(),
; 894  :                                       coset_width[c],0);
; 895  :                         }
; 896  :                       else

	jmp	SHORT $LN311@push
$LN84@push:

; 897  :                         {
; 898  :                           kdu_sample32 **bf=(kdu_sample32 **) vert_source_bufs;
; 899  :                           for (k=0; k < (int) step->support_length; k++)

	cmp	BYTE PTR [ebx+1], cl
	jbe	SHORT $LN53@push
	npad	7
$LL54@push:

; 900  :                             bf[k]=vert_source_vlines[k]->cosets[c].get_buf32();

	mov	eax, DWORD PTR [edi+36]
	mov	eax, DWORD PTR [eax+ecx*4]
	add	eax, DWORD PTR tv2733[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [eax+esi+6], 2
	je	SHORT $LN199@push
	xor	eax, eax
	jmp	SHORT $LN200@push
$LN199@push:
	mov	eax, DWORD PTR [eax+esi+8]
$LN200@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 900  :                             bf[k]=vert_source_vlines[k]->cosets[c].get_buf32();

	mov	DWORD PTR [edx+ecx*4], eax
	inc	ecx
	movzx	eax, BYTE PTR [ebx+1]
	cmp	ecx, eax
	jl	SHORT $LL54@push
$LN53@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [esi-2], 2
	je	SHORT $LN203@push
	xor	ecx, ecx
	jmp	SHORT $LN204@push
$LN203@push:
	mov	ecx, DWORD PTR [esi]
$LN204@push:
	mov	eax, DWORD PTR tv2739[ebp]
	test	BYTE PTR [eax], 2
	je	SHORT $LN207@push
	xor	eax, eax
	jmp	SHORT $LN208@push
$LN207@push:
	mov	eax, DWORD PTR _vline_in$3$[ebp]
	mov	eax, DWORD PTR [eax+esi]
$LN208@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 901  :                           perform_analysis_lifting_step(step,bf,

	mov	edi, DWORD PTR tv2740[ebp]
	push	0
	push	DWORD PTR [edi]
	push	ecx
	push	eax
	push	edx
	push	ebx
	call	?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z ; perform_analysis_lifting_step
$LN311@push:
	mov	edx, DWORD PTR tv2736[ebp]
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR tv2739[ebp]
	mov	ecx, DWORD PTR tv2740[ebp]
	mov	edi, DWORD PTR _this$1$[ebp]
$LN46@push:

; 880  :                 {
; 881  :                   int k;
; 882  :                   for (c=0; c < 2; c++)

	add	ecx, 4
	add	eax, 12					; 0000000cH
	add	esi, 12					; 0000000cH
	mov	DWORD PTR tv2740[ebp], ecx
	sub	edx, 1
	mov	DWORD PTR tv2739[ebp], eax
	mov	DWORD PTR tv2736[ebp], edx
	jne	$LL48@push
$LN47@push:

; 902  :                                       vline_in->cosets[c].get_buf32(),
; 903  :                                       vline_out->cosets[c].get_buf32(),
; 904  :                                       coset_width[c],0);
; 905  :                         }
; 906  :                     }
; 907  :                 }
; 908  : 
; 909  :               if (s == (num_vert_steps-1))

	mov	eax, DWORD PTR [edi+28]
	mov	esi, DWORD PTR _s$1$[ebp]
	dec	eax
	cmp	esi, eax
	jne	SHORT $LN86@push

; 910  :                 { // Last lifting step produced a result
; 911  :                   horizontal_analysis(vline_out,vsub_parity,env);

	push	DWORD PTR _env$[ebp]
	mov	ecx, edi
	push	DWORD PTR _vsub_parity$2$[ebp]
	push	DWORD PTR _vline_out$1$[ebp]
	call	?horizontal_analysis@kd_analysis@@AAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z ; kd_analysis::horizontal_analysis

; 912  :                 }
; 913  :               else

	jmp	SHORT $LN87@push
$LN86@push:

; 914  :                 { // Output from this step is pushed into next input queue
; 915  :                   free_lines = vline_out->next; // Strip it from free list

	mov	ecx, DWORD PTR _vline_out$1$[ebp]
	lea	edx, DWORD PTR [edi+44]

; 916  :                   vline_out->next = NULL;
; 917  :                   queues[s+1].push_line(step_next_row_pos[s],vline_out,

	push	edx
	push	ecx
	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [ecx+24], 0
	lea	ecx, DWORD PTR [esi*4]
	mov	eax, DWORD PTR [edi+68]
	push	DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR tv2732[ebp]
	add	ecx, 40					; 00000028H
	add	ecx, DWORD PTR [edi+64]
	call	?push_line@kd_vlift_queue@@QAEXHPAUkd_vlift_line@@AAPAU2@@Z ; kd_vlift_queue::push_line

; 918  :                                         free_lines);
; 919  :                   s_max = s + 2;

	lea	eax, DWORD PTR [esi+2]
	mov	DWORD PTR _s_max$1$[ebp], eax
$LN87@push:

; 920  :                 }
; 921  : 
; 922  :               generated_something = true;

	mov	eax, DWORD PTR [edi+68]
	mov	bl, 1

; 923  :               step_next_row_pos[s] += 2;

	mov	ecx, DWORD PTR tv2775[ebp]
	add	DWORD PTR [eax+ecx], 2

; 924  :               if (step_next_row_pos[s] > y_max)

	mov	eax, DWORD PTR [edi+68]
	mov	eax, DWORD PTR [ecx+eax]
	cmp	eax, DWORD PTR [edi+76]
	jle	SHORT $LN37@push

; 925  :                 queues[s].source_done();

	mov	ecx, DWORD PTR [edi+64]
	add	ecx, DWORD PTR tv2732[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 145  :         source_pos = recycling_lim = y_max + 2;

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 2
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+24], eax
$LN37@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 851  :           for (s=0; (s <= s_max) && (s < num_vert_steps); s++)

	mov	ecx, DWORD PTR _s$1$[ebp]
	mov	eax, DWORD PTR tv2731[ebp]
	inc	ecx
	add	DWORD PTR tv2732[ebp], 40		; 00000028H
	add	eax, 20					; 00000014H
	mov	DWORD PTR _s$1$[ebp], ecx
	mov	DWORD PTR tv2731[ebp], eax
	cmp	ecx, DWORD PTR _s_max$1$[ebp]
	jle	$LL39@push
$LN298@push:

; 926  :             }
; 927  :           // Finish off by seeing if we can pull an output line from the
; 928  :           // vertical subband which is used as the lifting step source for
; 929  :           // the last lifting step
; 930  :           s = num_vert_steps;

	mov	esi, DWORD PTR [edi+28]

; 931  :           if (queues[s-1].test_update(step_next_row_pos[s],true))

	mov	eax, DWORD PTR [edi+68]
	lea	edx, DWORD PTR [esi+esi*4]
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [edi+64]
	shl	edx, 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 179  :         update_pos = idx;

	mov	DWORD PTR [edx+eax-12], ecx

; 180  :         return ((idx >= head_idx) && (idx <= tail_idx) &&

	cmp	ecx, DWORD PTR [edx+eax-24]
	jl	SHORT $LN89@push
	cmp	ecx, DWORD PTR [edx+eax-20]
	jg	SHORT $LN89@push
	cmp	ecx, DWORD PTR [edx+eax-16]
	jge	SHORT $LN89@push
	cmp	ecx, DWORD PTR [edx+eax-8]
	jge	SHORT $LN89@push
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 933  :               vline_out =

	mov	ecx, DWORD PTR [edi+64]
	lea	eax, DWORD PTR [edi+44]
	push	eax
	mov	eax, DWORD PTR [edi+68]
	add	ecx, -40				; ffffffd8H
	add	ecx, edx
	push	DWORD PTR [eax+esi*4]
	call	?access_update@kd_vlift_queue@@QAEPAUkd_vlift_line@@HAAPAU2@@Z ; kd_vlift_queue::access_update

; 934  :                 queues[s-1].access_update(step_next_row_pos[s],free_lines);
; 935  :               assert(vline_out != NULL);
; 936  :               step_next_row_pos[s] += 2;

	mov	ecx, DWORD PTR [edi+68]

; 937  :               generated_something = true;
; 938  :               horizontal_analysis(vline_out,(s+1)&1,env);

	push	DWORD PTR _env$[ebp]
	add	DWORD PTR [ecx+esi*4], 2
	lea	ecx, DWORD PTR [esi-1]
	and	ecx, 1
	push	ecx
	push	eax
	mov	ecx, edi
	call	?horizontal_analysis@kd_analysis@@AAEXPAUkd_vlift_line@@HPAVkdu_thread_env@@@Z ; kd_analysis::horizontal_analysis
	mov	eax, DWORD PTR _s_max$1$[ebp]
	jmp	$LL35@push
$LN89@push:

; 845  :           // now be able to advance for the first time, assuming no earlier
; 846  :           // ones can advance
; 847  :       bool generated_something = true;
; 848  :       while (generated_something)

	mov	eax, DWORD PTR _s_max$1$[ebp]
	test	bl, bl
	jne	$LL35@push
	pop	edi
	pop	esi
	pop	ebx

; 942  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN313@push:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN315@push:
$LN308@push:
	int	3
?push@kd_analysis@@MAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z ENDP ; kd_analysis::push
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_roi_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
;	COMDAT ??1kd_analysis@@MAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_analysis@@MAE@XZ PROC				; kd_analysis::~kd_analysis, COMDAT
; _this$ = ecx

; 575  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_analysis@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR [edi], OFFSET ??_7kd_analysis@@6B@
	lea	esi, DWORD PTR [edi+4]
	mov	ebx, 4
$LL4@kd_analysi:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 616  :     bool exists() { return (state==NULL)?false:true; }

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 578  :     if (subbands[n].exists())

	je	SHORT $LN2@kd_analysi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 606  :         if (state != NULL) delete state;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]

; 607  :         state = NULL;

	mov	DWORD PTR [esi], 0
$LN2@kd_analysi:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 577  :   for (n=0; n < 4; n++)

	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL4@kd_analysi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_roi_processing.h

; 131  :     bool exists() { return (state != NULL); }

	cmp	DWORD PTR [edi+104], ebx
	lea	ecx, DWORD PTR [edi+104]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 580  :   if (roi_level.exists())

	je	SHORT $LN6@kd_analysi

; 581  :     roi_level.destroy(); // Important to do this last, giving descendants a

	call	?destroy@kdu_roi_level@@QAEXXZ		; kdu_roi_level::destroy
$LN6@kd_analysi:

; 582  :                          // chance to call the `release' function on their
; 583  :                          // `roi_node' interfaces.
; 584  :   if (coeff_handle != NULL)

	mov	eax, DWORD PTR [edi+108]
	test	eax, eax
	je	SHORT $LN7@kd_analysi

; 585  :     delete[] coeff_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@kd_analysi:

; 586  :   if (icoeff_handle != NULL)

	mov	eax, DWORD PTR [edi+112]
	test	eax, eax
	je	SHORT $LN8@kd_analysi

; 587  :     delete[] icoeff_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@kd_analysi:

; 588  :   if (source_buf_handle != NULL)

	mov	eax, DWORD PTR [edi+116]
	test	eax, eax
	je	SHORT $LN9@kd_analysi

; 589  :     delete[] source_buf_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN9@kd_analysi:

; 590  :   if (line_handle != NULL)

	mov	eax, DWORD PTR [edi+120]
	test	eax, eax
	je	SHORT $LN10@kd_analysi

; 591  :     delete[] line_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN10@kd_analysi:

; 592  :   if (vert_step_handle != NULL)

	mov	eax, DWORD PTR [edi+124]
	test	eax, eax
	je	SHORT $LN11@kd_analysi

; 593  :     delete[] vert_step_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN11@kd_analysi:

; 594  :   if (hor_step_handle != NULL)

	mov	eax, DWORD PTR [edi+128]
	test	eax, eax
	je	SHORT $LN12@kd_analysi

; 595  :     delete[] hor_step_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN12@kd_analysi:

; 596  :   if (queue_handle != NULL)

	mov	eax, DWORD PTR [edi+132]
	test	eax, eax
	je	SHORT $LN13@kd_analysi

; 597  :     delete[] queue_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN13@kd_analysi:

; 598  :   if (next_row_pos_handle != NULL)

	mov	eax, DWORD PTR [edi+136]
	test	eax, eax
	je	SHORT $LN33@kd_analysi

; 599  :     delete[] next_row_pos_handle;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN33@kd_analysi:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 572  :     virtual ~kdu_push_ifc_base() { return; }

	mov	DWORD PTR [edi], OFFSET ??_7kdu_push_ifc_base@@6B@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 600  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kd_analysis@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_analysis@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_analysis@@MAE@XZ ENDP				; kd_analysis::~kd_analysis
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
;	COMDAT ?init@kd_analysis@@QAEXVkdu_node@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
_TEXT	SEGMENT
_dims$ = -156						; size = 16
_env$GSCopy$1$ = -140					; size = 4
_env_queue$GSCopy$1$ = -136				; size = 4
_roi$GSCopy$1$ = -132					; size = 4
_hor_high_gain$ = -128					; size = 4
_hor_low_gain$ = -124					; size = 4
_vert_high_gain$ = -120					; size = 4
_vert_low_gain$ = -116					; size = 4
_res$ = -112						; size = 4
_allocator$GSCopy$1$ = -108				; size = 4
_use_shorts$GSCopy$ = -104				; size = 1
_hor_bibo_gains$1$ = -100				; size = 4
$T1 = -100						; size = 4
_low_max$2 = -100					; size = 4
_low_min$3 = -100					; size = 4
_vert_bibo_gains$1$ = -96				; size = 4
$T4 = -96						; size = 4
_low_min$5 = -96					; size = 4
_high_min$6 = -96					; size = 4
_both_cosets$1$ = -89					; size = 1
_this$GSCopy$1$ = -88					; size = 4
tv3323 = -88						; size = 4
_kernel_id$1$ = -84					; size = 4
tv3334 = -84						; size = 4
_max_source_request_idx$1$ = -80			; size = 4
_max_kernel_support$1$ = -80				; size = 4
_max$2$ = -80						; size = 4
_absolute$ = -80					; size = 1
_coeff_next$1$ = -76					; size = 4
_max$1$ = -76						; size = 4
tv3615 = -72						; size = 8
tv3589 = -72						; size = 8
_min$ = -72						; size = 8
_y_min$1$ = -68						; size = 4
_odd_width$1$ = -68					; size = 4
_n$4$ = -68						; size = 4
_n$2$ = -68						; size = 4
tv3356 = -68						; size = 4
$T7 = -68						; size = 4
_ns$8 = -68						; size = 4
$T9 = -68						; size = 4
_high_max$10 = -68					; size = 4
_low_max$11 = -68					; size = 4
_fact$2$ = -64						; size = 4
_fact$2$ = -64						; size = 4
_this$1$ = -64						; size = 4
tv3388 = -64						; size = 4
$T12 = -64						; size = 4
_high_min$13 = -64					; size = 4
_high_max$14 = -64					; size = 4
_icoeff_next$1$ = -60					; size = 4
_min$1$ = -60						; size = 4
_s$5$ = -56						; size = 4
_s$4$ = -56						; size = 4
_s$3$ = -56						; size = 4
_vert_step_info$1$ = -56				; size = 4
_roi_child$1$ = -52					; size = 4
_buf_pos_extent$2$ = -52				; size = 4
_coefficients$1$ = -52					; size = 4
_coefficients$1$ = -52					; size = 4
_s$2$ = -52						; size = 4
_s$1$ = -52						; size = 4
_max_extend$1$ = -48					; size = 4
_max_step_length$1$ = -48				; size = 4
tv3340 = -48						; size = 4
tv3333 = -48						; size = 4
_use_shorts$GSCopy$1$ = -41				; size = 1
_required_line_buffers$1$ = -40				; size = 4
_extend_left$1$ = -40					; size = 4
_total_coeffs$1$ = -40					; size = 4
tv3339 = -40						; size = 4
_child$ = -36						; size = 16
_child_ranges$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_node$ = 8						; size = 4
_allocator$ = 12					; size = 4
_use_shorts$ = 16					; size = 1
_normalization$ = 20					; size = 4
_roi$ = 24						; size = 4
_env$ = 28						; size = 4
_env_queue$ = 32					; size = 4
?init@kd_analysis@@QAEXVkdu_node@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z PROC ; kd_analysis::init, COMDAT
; _this$ = ecx

; 145  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR _allocator$GSCopy$1$[ebp], eax
	mov	al, BYTE PTR _use_shorts$[ebp]
	mov	BYTE PTR _use_shorts$GSCopy$1$[ebp], al
	mov	BYTE PTR _use_shorts$GSCopy$[ebp], al
	mov	eax, DWORD PTR _env$[ebp]
	push	esi
	mov	DWORD PTR _env$GSCopy$1$[ebp], eax
	mov	esi, ecx
	mov	eax, DWORD PTR _env_queue$[ebp]

; 146  :   kdu_resolution res = node.access_resolution();

	lea	ecx, DWORD PTR _node$[ebp]
	push	edi
	mov	edi, DWORD PTR _roi$[ebp]
	mov	DWORD PTR _env_queue$GSCopy$1$[ebp], eax
	lea	eax, DWORD PTR _res$[ebp]
	push	eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], esi
	mov	DWORD PTR _roi$GSCopy$1$[ebp], edi
	call	?access_resolution@kdu_node@@QAE?AVkdu_resolution@@XZ ; kdu_node::access_resolution

; 147  :   if ((roi != NULL) && !res.propagate_roi())

	test	edi, edi
	je	SHORT $LN59@init
	lea	ecx, DWORD PTR _res$[ebp]
	call	?propagate_roi@kdu_resolution@@QAE_NXZ	; kdu_resolution::propagate_roi
	test	al, al
	jne	SHORT $LN58@init

; 148  :     {
; 149  :       roi->release();

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]

; 150  :       roi = NULL;

	mov	DWORD PTR _roi$GSCopy$1$[ebp], 0

; 151  :     }
; 152  :   if (roi != NULL)

	jmp	SHORT $LN59@init
$LN58@init:

; 153  :     roi_level.create(node,roi);

	push	edi
	push	DWORD PTR _node$[ebp]
	lea	ecx, DWORD PTR [esi+104]
	call	?create@kdu_roi_level@@QAEXVkdu_node@@PAVkdu_roi_node@@@Z ; kdu_roi_level::create
$LN59@init:

; 154  : 
; 155  :   this->reversible = res.get_reversible();

	lea	ecx, DWORD PTR _res$[ebp]
	call	?get_reversible@kdu_resolution@@QAE_NXZ	; kdu_resolution::get_reversible
	mov	BYTE PTR [esi+20], al

; 156  :   this->use_shorts = use_shorts;
; 157  :   this->initialized = false;
; 158  :   this->free_lines = NULL;
; 159  :   this->queues = NULL;
; 160  :   this->vert_source_vlines = NULL;
; 161  :   this->vert_source_bufs = NULL;
; 162  :   this->vert_steps = this->hor_steps = NULL;
; 163  :   this->num_vert_steps = this->num_hor_steps = 0;
; 164  :   this->vert_symmetric_extension = this->hor_symmetric_extension = false;
; 165  :   int kernel_id = node.get_kernel_id();

	lea	ecx, DWORD PTR _node$[ebp]
	mov	al, BYTE PTR _use_shorts$GSCopy$1$[ebp]
	mov	BYTE PTR [esi+21], al
	mov	BYTE PTR [esi+22], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+28], 0
	mov	WORD PTR [esi+58], 0
	call	?get_kernel_id@kdu_node@@QAEHXZ		; kdu_node::get_kernel_id
	mov	DWORD PTR _kernel_id$1$[ebp], eax

; 166  :   coeff_handle = NULL;
; 167  :   icoeff_handle = NULL;
; 168  :   source_buf_handle = NULL;
; 169  :   line_handle = NULL;
; 170  :   vert_step_handle = hor_step_handle = NULL;
; 171  :   queue_handle = NULL;
; 172  : 
; 173  :   // Get output dimensions
; 174  :   kdu_dims dims;  node.get_dims(dims);

	lea	ecx, DWORD PTR _node$[ebp]
	lea	eax, DWORD PTR _dims$[ebp]
	mov	DWORD PTR [esi+108], 0
	xorps	xmm0, xmm0
	mov	DWORD PTR [esi+112], 0
	push	eax
	mov	DWORD PTR [esi+116], 0
	mov	DWORD PTR [esi+120], 0
	mov	DWORD PTR [esi+128], 0
	mov	DWORD PTR [esi+124], 0
	mov	DWORD PTR [esi+132], 0
	movups	XMMWORD PTR _dims$[ebp], xmm0
	call	?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z	; kdu_node::get_dims
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	ecx, DWORD PTR _dims$[ebp+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 176  :   min = dims.pos; max = min + dims.size; max.x--; max.y--;

	mov	edx, DWORD PTR _dims$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	dec	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 176  :   min = dims.pos; max = min + dims.size; max.x--; max.y--;

	mov	edi, DWORD PTR _dims$[ebp+4]
	add	ecx, edx
	mov	eax, DWORD PTR _dims$[ebp+12]
	mov	DWORD PTR _min$1$[ebp], edi
	dec	edi
	add	edi, eax
	mov	DWORD PTR _max$2$[ebp], ecx

; 177  :   y_min = min.y; y_max = max.y;

	mov	DWORD PTR [esi+76], ecx

; 178  :   x_min = min.x;  x_max = max.x;

	mov	ecx, DWORD PTR _min$1$[ebp]
	mov	DWORD PTR _min$[ebp], edx
	mov	DWORD PTR _max$1$[ebp], edi
	mov	DWORD PTR [esi+72], edx
	mov	DWORD PTR [esi+84], ecx
	mov	DWORD PTR [esi+88], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	test	eax, eax
	jle	SHORT $LN148@init
	cmp	DWORD PTR _dims$[ebp+8], 0
	jle	SHORT $LN148@init
	xor	cl, cl
	jmp	SHORT $LN149@init
$LN148@init:
	mov	cl, 1
$LN149@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 181  :   unit_height = (y_min==y_max);

	cmp	edx, DWORD PTR _max$2$[ebp]
	mov	BYTE PTR [esi+102], cl
	sete	al

; 182  :   unit_width = (x_min==x_max);

	cmp	DWORD PTR _min$1$[ebp], edi
	mov	BYTE PTR [esi+100], al
	sete	al
	mov	BYTE PTR [esi+101], al

; 183  : 
; 184  :   if (empty)

	test	cl, cl
	jne	$LN56@init

; 185  :     return;
; 186  : 
; 187  :   // Get basic structure
; 188  :   kdu_node child[4] =
; 189  :     {node.access_child(LL_BAND), node.access_child(HL_BAND),

	push	0
	lea	eax, DWORD PTR _child$[ebp]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?access_child@kdu_node@@QAE?AV1@H@Z	; kdu_node::access_child
	push	1
	lea	eax, DWORD PTR _child$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?access_child@kdu_node@@QAE?AV1@H@Z	; kdu_node::access_child

; 190  :      node.access_child(LH_BAND), node.access_child(HH_BAND)};

	push	2
	lea	eax, DWORD PTR _child$[ebp+8]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?access_child@kdu_node@@QAE?AV1@H@Z	; kdu_node::access_child
	push	3
	lea	eax, DWORD PTR _child$[ebp+12]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?access_child@kdu_node@@QAE?AV1@H@Z	; kdu_node::access_child
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4988 :     bool exists() { return (state==NULL)?false:true; }

	cmp	DWORD PTR _child$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 196  :   const kdu_kernel_step_info *vert_step_info=NULL, *hor_step_info=NULL;

	mov	DWORD PTR _vert_step_info$1$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4988 :     bool exists() { return (state==NULL)?false:true; }

	setne	cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 199  :   int max_kernel_support = 0;

	mov	DWORD PTR _max_kernel_support$1$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4988 :     bool exists() { return (state==NULL)?false:true; }

	cmp	DWORD PTR _child$[ebp+4], 0
	mov	BYTE PTR [esi+23], cl
	setne	al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 200  :   int total_coeffs = 0;

	mov	DWORD PTR _total_coeffs$1$[ebp], 0
	mov	BYTE PTR [esi+24], al

; 201  :   float vert_low_gain=1.0F, vert_high_gain=1.0F;

	mov	DWORD PTR _vert_low_gain$[ebp], 1065353216 ; 3f800000H
	mov	DWORD PTR _vert_high_gain$[ebp], 1065353216 ; 3f800000H

; 202  :   float hor_low_gain=1.0F, hor_high_gain=1.0F;

	mov	DWORD PTR _hor_low_gain$[ebp], 1065353216 ; 3f800000H
	mov	DWORD PTR _hor_high_gain$[ebp], 1065353216 ; 3f800000H

; 203  :   if (vert_xform_exists)

	test	cl, cl
	je	$LN61@init

; 204  :     {
; 205  :       int low_min, low_max, high_min, high_max, max_step_length;
; 206  :       vert_step_info =

	push	1
	lea	eax, DWORD PTR _high_max$14[ebp]
	push	eax
	lea	eax, DWORD PTR _high_min$6[ebp]
	push	eax
	lea	eax, DWORD PTR _low_max$11[ebp]
	push	eax
	lea	eax, DWORD PTR _low_min$3[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+58]
	push	eax
	lea	eax, DWORD PTR [esi+56]
	push	eax
	lea	eax, DWORD PTR _vert_high_gain$[ebp]
	push	eax
	lea	eax, DWORD PTR _vert_low_gain$[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+28]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?get_kernel_info@kdu_node@@QAEPBUkdu_kernel_step_info@@AAHAAM1AA_N20000_N@Z ; kdu_node::get_kernel_info

; 207  :         node.get_kernel_info(num_vert_steps,vert_low_gain,vert_high_gain,
; 208  :                              vert_symmetric,vert_symmetric_extension,
; 209  :                              low_min,low_max,high_min,high_max,true);
; 210  :       max_kernel_support =

	mov	edx, DWORD PTR _high_min$6[ebp]
	mov	edi, eax
	cmp	DWORD PTR _low_min$3[ebp], edx
	mov	eax, DWORD PTR _high_max$14[ebp]
	cmovl	edx, DWORD PTR _low_min$3[ebp]
	cmp	DWORD PTR _low_max$11[ebp], eax
	mov	DWORD PTR _vert_step_info$1$[ebp], edi
	cmovg	eax, DWORD PTR _low_max$11[ebp]
	sub	eax, edx
	mov	DWORD PTR _max_kernel_support$1$[ebp], eax

; 211  :         ((low_max > high_max)?low_max:high_max) -
; 212  :         ((low_min < high_min)?low_min:high_min);
; 213  :       if (num_vert_steps <= 4)

	mov	eax, DWORD PTR [esi+28]
	cmp	eax, 4
	jg	SHORT $LN62@init

; 214  :         vert_steps = step_store;

	lea	eax, DWORD PTR [esi+404]

; 215  :       else

	jmp	SHORT $LN321@init
$LN62@init:

; 216  :         vert_steps = vert_step_handle = new kd_lifting_step[num_vert_steps];

	xor	ecx, ecx
	mov	edx, 20					; 00000014H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+124], eax
$LN321@init:

; 217  :       for (max_step_length=0, s=0; s < num_vert_steps; s++)

	xor	ecx, ecx
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR _max_step_length$1$[ebp], ecx
	mov	DWORD PTR _s$1$[ebp], ecx
	cmp	DWORD PTR [esi+28], ecx
	jle	$LN315@init
	xor	edx, edx
	npad	7
$LL4@init:

; 218  :         {
; 219  :           vert_steps[s].support_min = (kdu_int16)

	mov	ecx, DWORD PTR [esi+48]
	lea	edx, DWORD PTR [edx+20]
	movzx	eax, WORD PTR [edi+4]
	lea	edi, DWORD PTR [edi+16]
	mov	WORD PTR [edx+ecx-16], ax

; 220  :             vert_step_info[s].support_min;
; 221  :           vert_steps[s].support_length = (kdu_byte)

	mov	ecx, DWORD PTR [esi+48]
	mov	al, BYTE PTR [edi-16]
	mov	BYTE PTR [edx+ecx-19], al

; 222  :             vert_step_info[s].support_length;
; 223  :           vert_steps[s].downshift = (kdu_byte)

	mov	ecx, DWORD PTR [esi+48]
	mov	al, BYTE PTR [edi-8]
	mov	BYTE PTR [edx+ecx-18], al

; 224  :             vert_step_info[s].downshift;
; 225  :           vert_steps[s].rounding_offset = (kdu_int16)

	mov	ecx, DWORD PTR [esi+48]
	movzx	eax, WORD PTR [edi-4]
	mov	WORD PTR [edx+ecx-14], ax

; 226  :             vert_step_info[s].rounding_offset;
; 227  :           vert_steps[s].kernel_id = (kdu_byte) kernel_id;

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR _kernel_id$1$[ebp]
	mov	BYTE PTR [edx+eax-2], cl

; 228  :           vert_steps[s].reversible = reversible;

	mov	ecx, DWORD PTR [esi+48]
	mov	al, BYTE PTR [esi+20]
	mov	BYTE PTR [edx+ecx-3], al

; 229  :           if (max_step_length < (int)(vert_step_info[s].support_length))

	mov	eax, DWORD PTR [edi-16]
	mov	ecx, DWORD PTR _max_step_length$1$[ebp]
	cmp	ecx, eax
	cmovl	ecx, eax

; 230  :             max_step_length = vert_step_info[s].support_length;
; 231  :           total_coeffs += vert_step_info[s].support_length;

	add	DWORD PTR _total_coeffs$1$[ebp], eax
	mov	eax, DWORD PTR _s$1$[ebp]
	inc	eax
	mov	DWORD PTR _max_step_length$1$[ebp], ecx
	mov	DWORD PTR _s$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+28]
	jl	SHORT $LL4@init

; 232  :         }
; 233  :       if (max_step_length <= 4)

	cmp	ecx, 4
	jle	SHORT $LN319@init

; 235  :       else
; 236  :         vert_source_bufs = source_buf_handle = new void *[2*max_step_length];

	lea	eax, DWORD PTR [ecx+ecx]
	mov	edx, 4
	xor	ecx, ecx
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR _max_step_length$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+116], eax
	jmp	SHORT $LN322@init
$LN319@init:
	mov	ecx, DWORD PTR _max_step_length$1$[ebp]
$LN315@init:

; 234  :         vert_source_bufs = source_buf_store;

	lea	eax, DWORD PTR [esi+204]
$LN322@init:
	mov	edi, DWORD PTR _max$1$[ebp]
	mov	DWORD PTR [esi+40], eax

; 237  :       vert_source_vlines =

	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+36], eax
$LN61@init:

; 238  :         (kd_vlift_line **)(vert_source_bufs+max_step_length);
; 239  :     }
; 240  :   if (hor_xform_exists)

	cmp	BYTE PTR [esi+24], 0
	je	$LN67@init

; 241  :     {
; 242  :       int low_min, low_max, high_min, high_max;
; 243  :       hor_step_info =

	push	0
	lea	eax, DWORD PTR _high_max$10[ebp]
	push	eax
	lea	eax, DWORD PTR _high_min$13[ebp]
	push	eax
	lea	eax, DWORD PTR _low_max$2[ebp]
	push	eax
	lea	eax, DWORD PTR _low_min$5[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+59]
	push	eax
	lea	eax, DWORD PTR [esi+57]
	push	eax
	lea	eax, DWORD PTR _hor_high_gain$[ebp]
	push	eax
	lea	eax, DWORD PTR _hor_low_gain$[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+32]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?get_kernel_info@kdu_node@@QAEPBUkdu_kernel_step_info@@AAHAAM1AA_N20000_N@Z ; kdu_node::get_kernel_info
	mov	edi, eax

; 244  :         node.get_kernel_info(num_hor_steps,hor_low_gain,hor_high_gain,
; 245  :                              hor_symmetric,hor_symmetric_extension,
; 246  :                              low_min,low_max,high_min,high_max,false);
; 247  :       if (hor_step_info == vert_step_info)

	cmp	edi, DWORD PTR _vert_step_info$1$[ebp]
	jne	SHORT $LN69@init

; 248  :         hor_steps = vert_steps;

	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+52], ecx
	jmp	SHORT $LN72@init
$LN69@init:

; 249  :       else if ((num_hor_steps+num_vert_steps) <= 4)

	mov	edx, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [esi+28]
	lea	eax, DWORD PTR [edx+ecx]
	cmp	eax, 4
	jg	SHORT $LN71@init

; 250  :         hor_steps = step_store + num_vert_steps;

	lea	eax, DWORD PTR [ecx*4+101]
	add	eax, ecx
	lea	eax, DWORD PTR [esi+eax*4]

; 251  :       else

	jmp	SHORT $LN323@init
$LN71@init:

; 252  :         hor_steps = hor_step_handle = new kd_lifting_step[num_hor_steps];

	xor	ecx, ecx
	mov	eax, edx
	mov	edx, 20					; 00000014H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+128], eax
$LN323@init:
	mov	DWORD PTR [esi+52], eax
$LN72@init:

; 253  :       if (hor_steps != vert_steps)

	mov	eax, DWORD PTR [esi+52]
	cmp	eax, DWORD PTR [esi+48]
	je	SHORT $LN6@init

; 254  :         for (s=0; s < num_hor_steps; s++)

	cmp	DWORD PTR [esi+32], 0
	mov	DWORD PTR _s$2$[ebp], 0
	jle	SHORT $LN6@init
	xor	edx, edx
	add	edi, 8
$LL7@init:

; 255  :           {
; 256  :             hor_steps[s].support_min = (kdu_int16)

	mov	ecx, DWORD PTR [esi+52]
	lea	edx, DWORD PTR [edx+20]
	movzx	eax, WORD PTR [edi-4]
	lea	edi, DWORD PTR [edi+16]
	mov	WORD PTR [ecx+edx-16], ax

; 257  :               hor_step_info[s].support_min;
; 258  :             hor_steps[s].support_length = (kdu_byte)

	mov	ecx, DWORD PTR [esi+52]
	mov	al, BYTE PTR [edi-24]
	mov	BYTE PTR [ecx+edx-19], al

; 259  :               hor_step_info[s].support_length;
; 260  :             hor_steps[s].downshift = (kdu_byte)

	mov	ecx, DWORD PTR [esi+52]
	mov	al, BYTE PTR [edi-16]
	mov	BYTE PTR [ecx+edx-18], al

; 261  :               hor_step_info[s].downshift;
; 262  :             hor_steps[s].rounding_offset = (kdu_int16)

	mov	ecx, DWORD PTR [esi+52]
	movzx	eax, WORD PTR [edi-12]
	mov	WORD PTR [ecx+edx-14], ax

; 263  :               hor_step_info[s].rounding_offset;
; 264  :             hor_steps[s].kernel_id = (kdu_byte) kernel_id;

	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR _kernel_id$1$[ebp]
	mov	BYTE PTR [eax+edx-2], cl

; 265  :             hor_steps[s].reversible = reversible;

	mov	ecx, DWORD PTR [esi+52]
	mov	al, BYTE PTR [esi+20]
	mov	BYTE PTR [ecx+edx-3], al

; 266  :             total_coeffs += hor_step_info[s].support_length;

	mov	eax, DWORD PTR _total_coeffs$1$[ebp]
	add	eax, DWORD PTR [edi-24]
	mov	DWORD PTR _total_coeffs$1$[ebp], eax
	mov	eax, DWORD PTR _s$2$[ebp]
	inc	eax
	mov	DWORD PTR _s$2$[ebp], eax
	cmp	eax, DWORD PTR [esi+32]
	jl	SHORT $LL7@init
$LN6@init:

; 267  :           }
; 268  : 
; 269  :       coset_width[0] = ((max.x+2)>>1) - ((min.x+1)>>1);

	mov	edi, DWORD PTR _min$1$[ebp]
	mov	edx, DWORD PTR _max$1$[ebp]
	lea	ecx, DWORD PTR [edi+1]

; 270  :       coset_width[1] = ((max.x+1)>>1) - (min.x>>1);

	sar	edi, 1
	lea	eax, DWORD PTR [edx+2]
	sar	ecx, 1
	sar	eax, 1
	sub	eax, ecx
	mov	DWORD PTR [esi+92], eax
	lea	eax, DWORD PTR [edx+1]
	sar	eax, 1
	sub	eax, edi
	mov	DWORD PTR [esi+96], eax

; 271  :     }
; 272  :   else

	jmp	SHORT $LN68@init
$LN67@init:

; 273  :     {
; 274  :       coset_width[0] = max.x+1-min.x;

	sub	edi, DWORD PTR _min$1$[ebp]
	inc	edi

; 275  :       coset_width[1] = 0;

	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+92], edi
$LN68@init:

; 276  :     }
; 277  : 
; 278  :   // Next, allocate coefficient storage and initialize lifting steps
; 279  :   float *coeff_next = coeff_store;
; 280  :   int *icoeff_next = icoeff_store;
; 281  :   if (total_coeffs > 8)

	mov	edi, DWORD PTR _total_coeffs$1$[ebp]
	lea	eax, DWORD PTR [esi+140]
	mov	DWORD PTR _coeff_next$1$[ebp], eax
	lea	eax, DWORD PTR [esi+172]
	mov	DWORD PTR _icoeff_next$1$[ebp], eax
	cmp	edi, 8
	jle	SHORT $LN74@init

; 282  :     {
; 283  :       coeff_next = coeff_handle = new float[total_coeffs];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR _coeff_next$1$[ebp], eax

; 284  :       icoeff_next = icoeff_handle = new int[total_coeffs];

	xor	ecx, ecx
	mov	DWORD PTR [esi+108], eax
	mov	edx, 4
	mov	eax, edi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 8
	mov	DWORD PTR _icoeff_next$1$[ebp], eax
	mov	DWORD PTR [esi+112], eax
$LN74@init:

; 285  :     }
; 286  :   if (vert_xform_exists)

	cmp	BYTE PTR [esi+23], 0
	je	$LN9@init

; 287  :     {
; 288  :       const float *coefficients = node.get_kernel_coefficients(true);

	push	1
	lea	ecx, DWORD PTR _node$[ebp]
	call	?get_kernel_coefficients@kdu_node@@QAEPBM_N@Z ; kdu_node::get_kernel_coefficients
	mov	edx, eax

; 289  :       for (s=0; s < num_vert_steps; s++)

	xor	eax, eax
	mov	DWORD PTR _coefficients$1$[ebp], edx
	mov	DWORD PTR _s$3$[ebp], eax
	cmp	DWORD PTR [esi+28], eax
	jle	$LN9@init

; 287  :     {
; 288  :       const float *coefficients = node.get_kernel_coefficients(true);

	xor	ecx, ecx
	mov	DWORD PTR tv3340[ebp], ecx
$LL10@init:

; 290  :         {
; 291  :           kd_lifting_step *step = vert_steps + s;

	mov	edi, DWORD PTR [esi+48]
	add	edi, ecx

; 292  :           step->step_idx = (kdu_byte) s;
; 293  : 
; 294  :           step->coeffs = coeff_next;
; 295  :           step->icoeffs = icoeff_next;
; 296  :           step->add_shorts_first = false;
; 297  : #ifdef KDU_SIMD_OPTIMIZATIONS
; 298  :           if ((kernel_id == Ckernels_W9X7) && (s != 1) &&

	cmp	DWORD PTR _kernel_id$1$[ebp], 0
	mov	ecx, DWORD PTR _coeff_next$1$[ebp]
	mov	BYTE PTR [edi], al
	mov	DWORD PTR [edi+8], ecx
	mov	ecx, DWORD PTR _icoeff_next$1$[ebp]
	mov	DWORD PTR [edi+12], ecx
	mov	BYTE PTR [edi+16], 0
	jne	SHORT $LN76@init
	cmp	eax, 1
	je	SHORT $LN76@init
	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 0	; kdu_mmx_level
	jg	SHORT $LN77@init
	cmp	BYTE PTR ?kdu_sparcvis_exists@@3_NA, 0	; kdu_sparcvis_exists
	jne	SHORT $LN77@init
	cmp	BYTE PTR ?kdu_altivec_exists@@3_NA, 0	; kdu_altivec_exists
	je	SHORT $LN76@init
$LN77@init:

; 299  :               ((kdu_mmx_level>0)||kdu_sparcvis_exists||kdu_altivec_exists))
; 300  :             step->add_shorts_first = true;

	mov	BYTE PTR [edi+16], 1
$LN76@init:

; 301  : #endif // KDU_SIMD_OPTIMIZATIONS
; 302  :           float fact, max_factor = 0.4F;

	movss	xmm1, DWORD PTR __real@3ecccccd

; 303  :           for (n=0; n < step->support_length; n++)

	xor	ecx, ecx
	cmp	BYTE PTR [edi+1], cl
	jbe	SHORT $LN12@init
$LL13@init:

; 304  :             {
; 305  :               step->coeffs[n] = fact = coefficients[n];

	mov	eax, DWORD PTR [edi+8]
	movss	xmm2, DWORD PTR [edx+ecx*4]

; 306  :               if (fact > max_factor)

	comiss	xmm2, xmm1
	movss	DWORD PTR [eax+ecx*4], xmm2
	jbe	SHORT $LN78@init

; 307  :                 max_factor = fact;

	movaps	xmm1, xmm2
	jmp	SHORT $LN11@init
$LN78@init:

; 308  :               else if (fact < -max_factor)

	movss	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm0, xmm1
	xorps	xmm0, xmm3
	comiss	xmm0, xmm2
	jbe	SHORT $LN11@init

; 309  :                 max_factor = -fact;

	movaps	xmm1, xmm2
	xorps	xmm1, xmm3
$LN11@init:

; 303  :           for (n=0; n < step->support_length; n++)

	movzx	eax, BYTE PTR [edi+1]
	inc	ecx
	cmp	ecx, eax
	jl	SHORT $LL13@init
$LN12@init:

; 310  :             }
; 311  :           if (!reversible)

	cmp	BYTE PTR [esi+20], 0
	jne	SHORT $LN83@init

; 312  :             { // Find appropriate downshift and rounding_offset values
; 313  :               for (step->downshift=16; max_factor >= 0.499F; max_factor*=0.5F)

	movss	xmm0, DWORD PTR __real@3eff7cee
	comiss	xmm1, xmm0
	mov	BYTE PTR [edi+2], 16			; 00000010H
	jb	SHORT $LN15@init
	movss	xmm2, DWORD PTR __real@3f000000
	mov	al, 16					; 00000010H
	npad	3
$LL16@init:
	mulss	xmm1, xmm2

; 314  :                 step->downshift--;

	add	al, 255					; 000000ffH
	comiss	xmm1, xmm0
	jae	SHORT $LL16@init
	mov	BYTE PTR [edi+2], al
$LN15@init:

; 315  :               if (step->downshift > 15)

	mov	al, BYTE PTR [edi+2]
	cmp	al, 15					; 0000000fH
	jbe	SHORT $LN82@init

; 316  :                 step->rounding_offset = KDU_INT16_MAX;

	mov	eax, 32767				; 00007fffH

; 317  :               else

	jmp	SHORT $LN324@init
$LN82@init:

; 318  :                 step->rounding_offset = (kdu_int16)(1<<(step->downshift-1));

	movzx	ecx, al
	mov	eax, 1
	dec	ecx
	shl	ax, cl
$LN324@init:
	mov	WORD PTR [edi+6], ax
$LN83@init:

; 319  :             }
; 320  :           fact = (float)(1<<step->downshift);

	mov	cl, BYTE PTR [edi+2]
	mov	eax, 1
	shl	eax, cl

; 321  :           for (n=0; n < step->support_length; n++)

	cmp	BYTE PTR [edi+1], 0
	mov	DWORD PTR _n$2$[ebp], 0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR _fact$2$[ebp], xmm1
	jbe	SHORT $LN18@init
	mov	esi, DWORD PTR _n$2$[ebp]
$LL19@init:

; 322  :             step->icoeffs[n] = (int) floor(0.5 + step->coeffs[n] * fact);

	mov	eax, DWORD PTR [edi+8]
	sub	esp, 8
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, xmm1
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv3615[ebp], xmm0
	fld	QWORD PTR tv3615[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR [edi+12]
	movss	xmm1, DWORD PTR _fact$2$[ebp]
	mov	DWORD PTR [ecx+esi*4], eax
	inc	esi
	movzx	eax, BYTE PTR [edi+1]
	cmp	esi, eax
	jl	SHORT $LL19@init
	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	edx, DWORD PTR _coefficients$1$[ebp]
$LN18@init:

; 323  :           coeff_next += step->support_length;

	movzx	eax, BYTE PTR [edi+1]
	mov	ecx, DWORD PTR tv3340[ebp]
	shl	eax, 2
	add	ecx, 20					; 00000014H
	add	DWORD PTR _coeff_next$1$[ebp], eax

; 324  :           icoeff_next += step->support_length;
; 325  :           coefficients += step->support_length;

	add	edx, eax
	add	DWORD PTR _icoeff_next$1$[ebp], eax
	mov	eax, DWORD PTR _s$3$[ebp]
	inc	eax

; 326  : 
; 327  :           step->extend = 0; // Not used in the vertical direction

	mov	BYTE PTR [edi+3], 0
	mov	DWORD PTR _coefficients$1$[ebp], edx
	mov	DWORD PTR _s$3$[ebp], eax
	mov	DWORD PTR tv3340[ebp], ecx
	cmp	eax, DWORD PTR [esi+28]
	jl	$LL10@init
$LN9@init:

; 328  :         }
; 329  :     }
; 330  : 
; 331  :   int max_extend=0;

	xor	edi, edi

; 332  :   if (hor_xform_exists)

	cmp	BYTE PTR [esi+24], 0
	mov	DWORD PTR _max_extend$1$[ebp], edi
	je	$LN21@init

; 333  :     {
; 334  :       const float *coefficients = node.get_kernel_coefficients(false);

	push	edi
	lea	ecx, DWORD PTR _node$[ebp]
	call	?get_kernel_coefficients@kdu_node@@QAEPBM_N@Z ; kdu_node::get_kernel_coefficients
	mov	DWORD PTR _coefficients$1$[ebp], eax

; 335  :       for (s=0; s < num_hor_steps; s++)

	xor	eax, eax
	mov	DWORD PTR _s$4$[ebp], eax
	cmp	DWORD PTR [esi+32], eax
	jle	$LN21@init

; 333  :     {
; 334  :       const float *coefficients = node.get_kernel_coefficients(false);

	xor	edx, edx
	mov	DWORD PTR tv3339[ebp], edx
	npad	5
$LL22@init:

; 336  :         {
; 337  :           kd_lifting_step *step = hor_steps + s;

	mov	edi, DWORD PTR [esi+52]

; 338  :           if (hor_steps != vert_steps)

	cmp	edi, DWORD PTR [esi+48]
	je	$LN85@init

; 339  :             {
; 340  :               step->step_idx = (kdu_byte) s;
; 341  :               step->coeffs = coeff_next;
; 342  :               step->icoeffs = icoeff_next;
; 343  :               step->add_shorts_first = false;
; 344  : #ifdef KDU_SIMD_OPTIMIZATIONS
; 345  :               if ((kernel_id == Ckernels_W9X7) && (s != 1) &&

	cmp	DWORD PTR _kernel_id$1$[ebp], 0
	mov	ecx, DWORD PTR _coeff_next$1$[ebp]
	mov	DWORD PTR [edi+edx+8], ecx
	mov	ecx, DWORD PTR _icoeff_next$1$[ebp]
	mov	BYTE PTR [edi+edx], al
	mov	DWORD PTR [edi+edx+12], ecx
	mov	BYTE PTR [edi+edx+16], 0
	jne	SHORT $LN87@init
	cmp	eax, 1
	je	SHORT $LN87@init
	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 0	; kdu_mmx_level
	jg	SHORT $LN88@init
	cmp	BYTE PTR ?kdu_sparcvis_exists@@3_NA, 0	; kdu_sparcvis_exists
	jne	SHORT $LN88@init
	cmp	BYTE PTR ?kdu_altivec_exists@@3_NA, 0	; kdu_altivec_exists
	je	SHORT $LN87@init
$LN88@init:

; 346  :                   ((kdu_mmx_level>0)||kdu_sparcvis_exists||kdu_altivec_exists))
; 347  :                 step->add_shorts_first = true;

	mov	BYTE PTR [edi+edx+16], 1
$LN87@init:

; 348  : #endif // KDU_SIMD_OPTIMIZATIONS
; 349  :               float fact, max_factor = 0.4F;

	movss	xmm1, DWORD PTR __real@3ecccccd

; 350  :               for (n=0; n < step->support_length; n++)

	xor	ecx, ecx
	cmp	BYTE PTR [edi+edx+1], cl
	jbe	SHORT $LN24@init
	mov	esi, DWORD PTR _coefficients$1$[ebp]
$LL25@init:

; 351  :                 {
; 352  :                   step->coeffs[n] = fact = coefficients[n];

	mov	eax, DWORD PTR [edi+edx+8]
	movss	xmm2, DWORD PTR [esi+ecx*4]

; 353  :                   if (fact > max_factor)

	comiss	xmm2, xmm1
	movss	DWORD PTR [eax+ecx*4], xmm2
	jbe	SHORT $LN89@init

; 354  :                     max_factor = fact;

	movaps	xmm1, xmm2
	jmp	SHORT $LN23@init
$LN89@init:

; 355  :                   else if (fact < -max_factor)

	movss	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	movaps	xmm0, xmm1
	xorps	xmm0, xmm3
	comiss	xmm0, xmm2
	jbe	SHORT $LN23@init

; 356  :                     max_factor = -fact;

	movaps	xmm1, xmm2
	xorps	xmm1, xmm3
$LN23@init:

; 350  :               for (n=0; n < step->support_length; n++)

	movzx	eax, BYTE PTR [edi+edx+1]
	inc	ecx
	cmp	ecx, eax
	jl	SHORT $LL25@init
	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
$LN24@init:

; 357  :                 }
; 358  :               if (!reversible)

	cmp	BYTE PTR [esi+20], 0
	jne	SHORT $LN94@init

; 359  :                 { // Find appropriate downshift and rounding_offset values
; 360  :                   for (step->downshift=16;
; 361  :                        max_factor >= 0.499F; max_factor*=0.5F)

	movss	xmm0, DWORD PTR __real@3eff7cee
	comiss	xmm1, xmm0
	mov	BYTE PTR [edi+edx+2], 16		; 00000010H
	jb	SHORT $LN27@init
	movss	xmm2, DWORD PTR __real@3f000000
	mov	al, 16					; 00000010H
$LL28@init:
	mulss	xmm1, xmm2

; 362  :                     step->downshift--;

	add	al, 255					; 000000ffH
	comiss	xmm1, xmm0
	jae	SHORT $LL28@init
	mov	BYTE PTR [edi+edx+2], al
$LN27@init:

; 363  :                   if (step->downshift > 15)

	mov	al, BYTE PTR [edi+edx+2]
	cmp	al, 15					; 0000000fH
	jbe	SHORT $LN93@init

; 364  :                     step->rounding_offset = KDU_INT16_MAX;

	mov	eax, 32767				; 00007fffH

; 365  :                   else

	jmp	SHORT $LN325@init
$LN93@init:

; 366  :                     step->rounding_offset = (kdu_int16)(1<<(step->downshift-1));

	movzx	ecx, al
	mov	eax, 1
	dec	ecx
	shl	ax, cl
$LN325@init:
	mov	WORD PTR [edi+edx+6], ax
$LN94@init:

; 367  :                 }
; 368  :               fact = (float)(1<<step->downshift);

	mov	cl, BYTE PTR [edi+edx+2]
	mov	eax, 1
	shl	eax, cl

; 369  :               for (n=0; n < step->support_length; n++)

	cmp	BYTE PTR [edi+edx+1], 0
	mov	DWORD PTR _n$4$[ebp], 0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR _fact$2$[ebp], xmm1
	jbe	SHORT $LN30@init
	mov	esi, DWORD PTR _n$4$[ebp]
	npad	9
$LL31@init:

; 370  :                 step->icoeffs[n] = (int) floor(0.5 + step->coeffs[n] * fact);

	mov	eax, DWORD PTR [edi+edx+8]
	sub	esp, 8
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, xmm1
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv3589[ebp], xmm0
	fld	QWORD PTR tv3589[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	edx, DWORD PTR tv3339[ebp]
	movss	xmm1, DWORD PTR _fact$2$[ebp]
	mov	ecx, DWORD PTR [edi+edx+12]
	mov	DWORD PTR [ecx+esi*4], eax
	inc	esi
	movzx	eax, BYTE PTR [edi+edx+1]
	cmp	esi, eax
	jl	SHORT $LL31@init
	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
$LN30@init:

; 371  :               coeff_next += step->support_length;

	movzx	eax, BYTE PTR [edi+edx+1]
	shl	eax, 2
	add	DWORD PTR _coeff_next$1$[ebp], eax

; 372  :               icoeff_next += step->support_length;

	add	DWORD PTR _icoeff_next$1$[ebp], eax
$LN85@init:

; 373  :             }
; 374  :           else
; 375  :             { // Horizontal and vertical lifting steps should be identical
; 376  :               for (n=0; n < step->support_length; n++)
; 377  :                 assert(step->coeffs[n] == coefficients[n]);
; 378  :             }
; 379  : 
; 380  :           coefficients += step->support_length;

	movzx	ecx, BYTE PTR [edi+edx+1]
	mov	eax, DWORD PTR _coefficients$1$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 381  : 
; 382  :           int extend_left = -step->support_min;
; 383  :           int extend_right = step->support_min-1 + (int) step->support_length;

	dec	ecx
	mov	DWORD PTR _coefficients$1$[ebp], eax
	movsx	eax, WORD PTR [edi+edx+4]
	mov	DWORD PTR _extend_left$1$[ebp], eax
	add	ecx, eax
	neg	DWORD PTR _extend_left$1$[ebp]

; 384  :           if (x_min & 1)

	test	BYTE PTR [esi+84], 1
	je	SHORT $LN95@init

; 385  :             extend_left += (s & 1)?(-1):1;

	test	BYTE PTR _s$4$[ebp], 1
	mov	eax, 0
	sete	al
	lea	eax, DWORD PTR [eax*2-1]
	add	DWORD PTR _extend_left$1$[ebp], eax
$LN95@init:

; 386  :           if (!(x_max & 1))

	test	BYTE PTR [esi+88], 1
	jne	SHORT $LN96@init

; 387  :             extend_right += (s & 1)?1:(-1);

	test	BYTE PTR _s$4$[ebp], 1
	mov	eax, 0
	setne	al
	lea	ecx, DWORD PTR [ecx+eax*2]
	dec	ecx
$LN96@init:

; 388  :           int extend = (extend_left > extend_right)?extend_left:extend_right;

	cmp	DWORD PTR _extend_left$1$[ebp], ecx
	cmovg	ecx, DWORD PTR _extend_left$1$[ebp]

; 389  :           extend = (extend < 0)?0:extend;

	xor	eax, eax
	test	ecx, ecx
	cmovs	ecx, eax

; 390  :           if (extend > max_extend)

	mov	eax, DWORD PTR _max_extend$1$[ebp]
	cmp	ecx, eax

; 391  :             max_extend = extend;
; 392  :           assert(extend < 256);
; 393  :           step->extend = (kdu_byte) extend;

	mov	BYTE PTR [edi+edx+3], cl
	cmovg	eax, ecx
	add	edx, 20					; 00000014H
	mov	DWORD PTR _max_extend$1$[ebp], eax
	mov	eax, DWORD PTR _s$4$[ebp]
	inc	eax
	mov	DWORD PTR tv3339[ebp], edx
	mov	DWORD PTR _s$4$[ebp], eax
	cmp	eax, DWORD PTR [esi+32]
	jl	$LL22@init
	mov	edi, DWORD PTR _max_extend$1$[ebp]
$LN21@init:

; 394  :         }
; 395  :     }
; 396  : 
; 397  :   // Create line queues
; 398  :   if ((num_vert_steps > 0) && !unit_height)

	mov	eax, DWORD PTR [esi+28]
	lea	ecx, DWORD PTR [esi+28]
	test	eax, eax
	jle	SHORT $LN98@init
	cmp	BYTE PTR [esi+100], 0
	jne	SHORT $LN98@init

; 399  :     {
; 400  :       if (num_vert_steps <= 4)

	cmp	eax, 4
	jg	SHORT $LN99@init

; 401  :         queues = queue_store;

	lea	eax, DWORD PTR [esi+484]

; 402  :       else

	jmp	SHORT $LN326@init
$LN99@init:

; 403  :         queues = queue_handle = new kd_vlift_queue[num_vert_steps+1];

	xor	ecx, ecx
	inc	eax
	mov	edx, 40					; 00000028H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+132], eax
	lea	ecx, DWORD PTR [esi+28]
$LN326@init:
	mov	DWORD PTR [esi+64], eax

; 404  :       queues += 1; // So we can access first queue with index -1

	add	DWORD PTR [esi+64], 40			; 00000028H
$LN98@init:

; 405  :     }
; 406  : 
; 407  :   // Create `step_next_row_pos' array
; 408  :   step_next_row_pos = NULL;
; 409  :   if (num_vert_steps > 0)

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+68], 0
	test	eax, eax
	jle	SHORT $LN103@init

; 410  :     {
; 411  :       if (num_vert_steps <= 4)

	cmp	eax, 4
	jg	SHORT $LN102@init

; 412  :         step_next_row_pos = next_row_pos_store;

	lea	eax, DWORD PTR [esi+684]

; 413  :       else

	jmp	SHORT $LN327@init
$LN102@init:

; 414  :         step_next_row_pos = next_row_pos_handle = new int[num_vert_steps+1];

	xor	ecx, ecx
	inc	eax
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+136], eax
$LN327@init:
	mov	DWORD PTR [esi+68], eax
$LN103@init:

; 415  :     }
; 416  : 
; 417  :   // Find allocation parameters for internal line buffers
; 418  :   int buf_neg_extent = max_extend;
; 419  :   int buf_pos_extent = coset_width[0];

	mov	ecx, DWORD PTR [esi+92]

; 420  :   if (buf_pos_extent < coset_width[1])
; 421  :     buf_pos_extent = coset_width[1];
; 422  :   buf_pos_extent += max_extend;
; 423  : 
; 424  :   // Simulate vertical lifting process to find number of line buffers required
; 425  :   int required_line_buffers = 1; // Need this if no vertical transform

	mov	eax, 1
	cmp	ecx, DWORD PTR [esi+96]
	mov	DWORD PTR _required_line_buffers$1$[ebp], eax
	cmovl	ecx, DWORD PTR [esi+96]
	add	ecx, edi

; 426  :   if ((num_vert_steps > 0) && !unit_height)

	cmp	DWORD PTR [esi+28], 0
	mov	DWORD PTR _buf_pos_extent$2$[ebp], ecx
	jle	$LN106@init
	cmp	BYTE PTR [esi+100], 0
	jne	$LN106@init

; 427  :     required_line_buffers = simulate_vertical_lifting(max_kernel_support);

	push	DWORD PTR _max_kernel_support$1$[ebp]
	mov	ecx, esi
	call	?simulate_vertical_lifting@kd_analysis@@AAEHH@Z ; kd_analysis::simulate_vertical_lifting
	mov	DWORD PTR _required_line_buffers$1$[ebp], eax

; 428  :   if (required_line_buffers > 6)

	cmp	eax, 6
	jle	SHORT $LN106@init

; 429  :     line_handle = new kd_vlift_line[required_line_buffers];

	xor	ecx, ecx
	mov	edx, 28					; 0000001cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edi, eax
	add	esp, 4
	mov	eax, DWORD PTR _required_line_buffers$1$[ebp]
	mov	DWORD PTR $T9[ebp], edi
	test	edi, edi
	je	SHORT $LN129@init
	mov	edx, eax
	test	eax, eax
	je	SHORT $LN130@init
	lea	ecx, DWORD PTR [edi+7]
$LL155@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx-7], 0
	lea	ecx, DWORD PTR [ecx+28]
	mov	WORD PTR [ecx-29], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx-27], 0
	mov	DWORD PTR [ecx-23], 0
	mov	WORD PTR [ecx-17], 0
	mov	DWORD PTR [ecx-15], 0
	sub	edx, 1
	jne	SHORT $LL155@init
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 429  :     line_handle = new kd_vlift_line[required_line_buffers];

	jmp	SHORT $LN130@init
$LN129@init:
	xor	edi, edi
$LN130@init:
	mov	DWORD PTR [esi+120], edi
$LN106@init:

; 430  :   for (free_lines=NULL, n=0; n < required_line_buffers; n++)

	mov	DWORD PTR [esi+44], 0
	test	eax, eax
	jle	$LN36@init
	xor	edi, edi
$LL37@init:

; 431  :     {
; 432  :       if (line_handle == NULL)

	mov	ecx, DWORD PTR [esi+120]

; 433  :         { line_store[n].next = free_lines;  free_lines = line_store + n; }

	mov	eax, DWORD PTR [esi+44]
	test	ecx, ecx
	jne	SHORT $LN107@init
	lea	ecx, DWORD PTR [edi+236]
	add	ecx, esi
	mov	DWORD PTR [ecx+24], eax
	mov	DWORD PTR [esi+44], ecx

; 434  :       else

	jmp	SHORT $LN108@init
$LN107@init:

; 435  :         { line_handle[n].next = free_lines; free_lines = line_handle + n; }

	mov	DWORD PTR [edi+ecx+24], eax
	mov	eax, DWORD PTR [esi+120]
	add	eax, edi
	mov	DWORD PTR [esi+44], eax
$LN108@init:

; 436  :       free_lines->pre_create(allocator,coset_width[0],coset_width[1],

	mov	al, BYTE PTR [esi+24]
	mov	ecx, DWORD PTR [esi+92]
	mov	edx, DWORD PTR [esi+44]
	mov	BYTE PTR _both_cosets$1$[ebp], al
	mov	al, BYTE PTR [esi+20]
	mov	BYTE PTR _absolute$[ebp], al
	mov	eax, DWORD PTR [esi+96]
	mov	DWORD PTR _odd_width$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 75   :         cosets[0].pre_create(allocator,even_width,absolute,use_shorts,

	mov	eax, DWORD PTR _buf_pos_extent$2$[ebp]
	sub	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 436  :       free_lines->pre_create(allocator,coset_width[0],coset_width[1],

	mov	DWORD PTR _this$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 75   :         cosets[0].pre_create(allocator,even_width,absolute,use_shorts,

	push	eax
	push	DWORD PTR _max_extend$1$[ebp]
	push	DWORD PTR _use_shorts$GSCopy$[ebp]
	push	DWORD PTR _absolute$[ebp]
	push	ecx
	push	DWORD PTR _allocator$GSCopy$1$[ebp]
	mov	ecx, edx
	call	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create

; 76   :                              neg_extent,pos_extent-even_width);
; 77   :         if (both_cosets)

	cmp	BYTE PTR _both_cosets$1$[ebp], 0
	je	SHORT $LN35@init

; 78   :           cosets[1].pre_create(allocator,odd_width,absolute,use_shorts,

	mov	ecx, DWORD PTR _odd_width$1$[ebp]
	mov	eax, DWORD PTR _buf_pos_extent$2$[ebp]
	sub	eax, ecx
	push	eax
	push	DWORD PTR _max_extend$1$[ebp]
	push	DWORD PTR _use_shorts$GSCopy$[ebp]
	push	DWORD PTR _absolute$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	DWORD PTR _allocator$GSCopy$1$[ebp]
	add	ecx, 12					; 0000000cH
	call	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create
$LN35@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 430  :   for (free_lines=NULL, n=0; n < required_line_buffers; n++)

	add	edi, 28					; 0000001cH
	sub	DWORD PTR _required_line_buffers$1$[ebp], 1
	jne	$LL37@init
$LN36@init:

; 437  :                              reversible,use_shorts,
; 438  :                              buf_neg_extent,buf_pos_extent,hor_xform_exists);
; 439  :     }
; 440  : 
; 441  :   // Set up vertical counters and queues
; 442  :   y_next = y_min;
; 443  :   if (queues != NULL)

	cmp	DWORD PTR [esi+64], 0

; 444  :     for (s=-1; s < num_vert_steps; s++)

	lea	edi, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi+72]
	mov	DWORD PTR [esi+80], eax
	je	$LN39@init
	or	ecx, -1
	mov	DWORD PTR _s$5$[ebp], ecx
	cmp	DWORD PTR [edi], ecx
	jle	$LN39@init
	mov	DWORD PTR tv3334[ebp], -40		; ffffffd8H
	mov	DWORD PTR tv3333[ebp], -20		; ffffffecH
$LL40@init:

; 445  :       {
; 446  :         int max_source_request_idx = y_max - ((y_max ^ s) & 1);

	mov	edi, DWORD PTR [esi+76]
	mov	edx, edi
	xor	edx, ecx
	mov	eax, edi
	and	edx, 1
	sub	eax, edx
	mov	DWORD PTR _max_source_request_idx$1$[ebp], eax

; 447  :         if (s >= 0)

	test	ecx, ecx
	js	SHORT $LN110@init

; 448  :           max_source_request_idx = y_max - ((y_max ^ s) & 1) +

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR tv3333[ebp]
	mov	esi, DWORD PTR tv3333[ebp]
	movsx	ecx, WORD PTR [ecx+eax+4]
	movzx	eax, BYTE PTR [esi+eax+1]
	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	add	ecx, eax
	add	ecx, ecx
	lea	eax, DWORD PTR [edi-2]
	sub	ecx, edx
	add	eax, ecx
	mov	DWORD PTR _max_source_request_idx$1$[ebp], eax
$LN110@init:

; 449  :             2*(vert_steps[s].support_min - 1 +
; 450  :                (int) vert_steps[s].support_length);
; 451  :         queues[s].init(y_min,y_max,s,vert_symmetric_extension,

	mov	edx, DWORD PTR [esi+64]
	add	edx, DWORD PTR tv3334[ebp]
	mov	eax, DWORD PTR [esi+72]
	mov	cl, BYTE PTR [esi+58]
	mov	DWORD PTR _y_min$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 124  :         this->queue_idx = (kdu_byte) queue_idx;

	mov	eax, DWORD PTR _s$5$[ebp]
	mov	BYTE PTR [edx+37], al

; 125  :         this->y_min = y_min;  this->y_max = y_max;

	mov	eax, DWORD PTR _y_min$1$[ebp]
	mov	DWORD PTR [edx], eax

; 126  :         head_idx = source_pos = update_pos = y_min - 1000; // Ridiculous value

	add	eax, -1000				; fffffc18H
	mov	DWORD PTR [edx+4], edi
	mov	DWORD PTR tv3356[ebp], eax
	mov	DWORD PTR [edx+28], eax
	mov	DWORD PTR [edx+24], eax
	mov	DWORD PTR [edx+16], eax

; 127  :         this->symmetric_extension = symmetric_extension;

	mov	BYTE PTR [edx+36], cl

; 128  :         if ((!symmetric_extension) || (max_source_request_idx < y_max))

	test	cl, cl
	je	SHORT $LN174@init
	mov	ecx, DWORD PTR _max_source_request_idx$1$[ebp]
	cmp	ecx, edi
	jl	SHORT $LN174@init

; 130  :         else
; 131  :           recycling_lim = 2*y_max - max_source_request_idx;

	lea	eax, DWORD PTR [edi+edi]
	sub	eax, ecx
	jmp	SHORT $LN328@init
$LN174@init:

; 129  :           recycling_lim = y_max - 1; // Keep last row only

	lea	eax, DWORD PTR [edi-1]
$LN328@init:

; 132  :         if (queue_idx < 0)

	mov	ecx, DWORD PTR _s$5$[ebp]
	mov	DWORD PTR [edx+32], eax
	test	ecx, ecx
	jns	SHORT $LN175@init

; 133  :           source_pos = recycling_lim = y_max+2; // Block use of `access_source'

	lea	eax, DWORD PTR [edi+2]
	mov	DWORD PTR [edx+32], eax
	mov	DWORD PTR [edx+24], eax
$LN175@init:

; 134  :         tail_idx = head_idx - 2;

	mov	eax, DWORD PTR tv3356[ebp]
	add	eax, -2					; fffffffeH

; 135  :         head = tail = NULL;

	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+20], eax
	mov	DWORD PTR [edx+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 453  :         if ((s >= 0) && (vert_steps[s].support_length <= 0))

	test	ecx, ecx
	js	SHORT $LN38@init
	mov	eax, DWORD PTR [esi+48]
	mov	edx, DWORD PTR tv3333[ebp]
	cmp	BYTE PTR [edx+eax+1], 0
	ja	SHORT $LN38@init

; 454  :           queues[s].source_done();

	mov	ecx, DWORD PTR [esi+64]
	add	ecx, DWORD PTR tv3334[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h

; 145  :         source_pos = recycling_lim = y_max + 2;

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 2
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+24], eax
	mov	ecx, DWORD PTR _s$5$[ebp]
$LN38@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 444  :     for (s=-1; s < num_vert_steps; s++)

	add	DWORD PTR tv3333[ebp], 20		; 00000014H
	lea	edi, DWORD PTR [esi+28]
	add	DWORD PTR tv3334[ebp], 40		; 00000028H
	inc	ecx
	mov	DWORD PTR _s$5$[ebp], ecx
	cmp	ecx, DWORD PTR [edi]
	jl	$LL40@init
$LN39@init:

; 455  :       }
; 456  :   if (vert_xform_exists)

	cmp	BYTE PTR [esi+23], 0
	je	SHORT $LN42@init

; 457  :     for (s=0; s < (((int) num_vert_steps)+1); s++)

	mov	eax, DWORD PTR [edi]
	xor	edx, edx
	inc	eax
	test	eax, eax
	jle	SHORT $LN42@init
	npad	5
$LL43@init:

; 458  :       step_next_row_pos[s] = y_min + 1 - ((y_min ^ s) & 1);

	mov	ecx, DWORD PTR [esi+72]
	mov	eax, ecx
	xor	eax, edx
	and	eax, 1
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+68]
	inc	ecx
	mov	DWORD PTR [eax+edx*4], ecx
	inc	edx
	mov	eax, DWORD PTR [edi]
	inc	eax
	cmp	edx, eax
	jl	SHORT $LL43@init
$LN42@init:

; 459  : 
; 460  :   // Now determine the normalizing downshift and subband nominal ranges.
; 461  :   float child_ranges[4] =
; 462  :     {normalization, normalization, normalization, normalization};
; 463  :   normalizing_downshift = 0;
; 464  :   if (!reversible)

	cmp	BYTE PTR [esi+20], 0
	movss	xmm0, DWORD PTR _normalization$[ebp]
	movaps	xmm1, xmm0
	movss	DWORD PTR _child_ranges$[ebp+4], xmm0
	movss	DWORD PTR _child_ranges$[ebp], xmm1
	movss	DWORD PTR _child_ranges$[ebp+8], xmm1
	movss	DWORD PTR _child_ranges$[ebp+12], xmm0
	mov	DWORD PTR [esi+60], 0
	jne	$LN51@init

; 465  :     {
; 466  :       int ns;
; 467  :       const float *vert_bibo_gains = node.get_bibo_gains(ns,true);

	push	1
	lea	eax, DWORD PTR _ns$8[ebp]
	push	eax
	lea	ecx, DWORD PTR _node$[ebp]
	call	?get_bibo_gains@kdu_node@@QAEPBMAAH_N@Z	; kdu_node::get_bibo_gains
	mov	edi, eax

; 468  :       assert(ns == num_vert_steps);
; 469  :       const float *hor_bibo_gains = node.get_bibo_gains(ns,false);

	lea	ecx, DWORD PTR _node$[ebp]
	push	0
	lea	eax, DWORD PTR _ns$8[ebp]
	mov	DWORD PTR _vert_bibo_gains$1$[ebp], edi
	push	eax
	call	?get_bibo_gains@kdu_node@@QAEPBMAAH_N@Z	; kdu_node::get_bibo_gains

; 470  :       assert(ns == num_hor_steps);
; 471  : 
; 472  :       float bibo_max = normalization; // Not a true BIBO gain; this value just

	movss	xmm4, DWORD PTR _normalization$[ebp]
	mov	edx, eax

; 473  :                                        // means leave normalization alone.
; 474  : 
; 475  :       // Find BIBO gains from vertical analysis steps (these are done first)
; 476  :       if ((num_vert_steps > 0) && !unit_height)

	mov	eax, DWORD PTR [esi+28]
	movaps	xmm2, xmm4
	movsd	xmm7, QWORD PTR __real@4000000000000000

; 477  :         {
; 478  :           child_ranges[LL_BAND] /= vert_low_gain;

	movaps	xmm3, xmm4
	mov	DWORD PTR _hor_bibo_gains$1$[ebp], edx

; 479  :           child_ranges[HL_BAND] /= vert_low_gain;
; 480  :           child_ranges[LH_BAND] /= vert_high_gain;

	movaps	xmm5, xmm4
	test	eax, eax
	jle	$LN45@init

; 473  :                                        // means leave normalization alone.
; 474  : 
; 475  :       // Find BIBO gains from vertical analysis steps (these are done first)
; 476  :       if ((num_vert_steps > 0) && !unit_height)

	cmp	BYTE PTR [esi+100], 0
	jne	$LN45@init

; 481  :           child_ranges[HH_BAND] /= vert_high_gain;
; 482  : 
; 483  :           float bibo_prev, bibo_in, bibo_out;
; 484  : 
; 485  :           // Find cumulative horizontal gain to input of node.
; 486  :           bibo_prev = hor_bibo_gains[0] * normalization;

	movaps	xmm6, xmm4
	mulss	xmm6, DWORD PTR [edx]
	divss	xmm3, DWORD PTR _vert_low_gain$[ebp]

; 487  :           for (bibo_in=bibo_prev, n=0; n < num_vert_steps; n++,

	movaps	xmm0, xmm6
	movss	DWORD PTR _child_ranges$[ebp], xmm3
	movss	DWORD PTR _child_ranges$[ebp+4], xmm3
	divss	xmm5, DWORD PTR _vert_high_gain$[ebp]
	movss	DWORD PTR _child_ranges$[ebp+8], xmm5
	movss	DWORD PTR _child_ranges$[ebp+12], xmm5
	test	eax, eax
	jle	SHORT $LN45@init

; 493  :               if (use_shorts && vert_steps[n].add_shorts_first)

	lea	edx, DWORD PTR [edi+4]
	xor	ecx, ecx
	mov	edi, eax
	npad	4
$LL46@init:

; 488  :                bibo_in=bibo_out)
; 489  :             {
; 490  :               bibo_out = bibo_prev * vert_bibo_gains[n+1];

	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR [edx]

; 491  :               if (bibo_out > bibo_max)

	comiss	xmm1, xmm2
	jbe	SHORT $LN115@init

; 492  :                 bibo_max = bibo_out; // Fit representation to lifting outputs

	movaps	xmm2, xmm1
$LN115@init:

; 493  :               if (use_shorts && vert_steps[n].add_shorts_first)

	cmp	BYTE PTR _use_shorts$GSCopy$1$[ebp], 0
	je	SHORT $LN44@init
	mov	eax, DWORD PTR [esi+48]
	cmp	BYTE PTR [ecx+eax+16], 0
	je	SHORT $LN44@init

; 494  :                 {
; 495  :                   bibo_in *= 2.0; // Avoid overflow during pre-accumulation

	cvtss2sd xmm0, xmm0
	mulsd	xmm0, xmm7
	cvtsd2ss xmm0, xmm0

; 496  :                   if (bibo_in > bibo_max)

	comiss	xmm0, xmm2
	jbe	SHORT $LN44@init

; 497  :                     bibo_max = bibo_in;

	movaps	xmm2, xmm0
$LN44@init:

; 487  :           for (bibo_in=bibo_prev, n=0; n < num_vert_steps; n++,

	add	edx, 4
	add	ecx, 20					; 00000014H
	movaps	xmm0, xmm1
	sub	edi, 1
	jne	SHORT $LL46@init
	mov	eax, DWORD PTR [esi+28]
	mov	edx, DWORD PTR _hor_bibo_gains$1$[ebp]
$LN45@init:

; 498  :                 }
; 499  :             }
; 500  :         }
; 501  : 
; 502  :       // Find BIBO gains from horizonal analysis steps
; 503  :       if ((num_hor_steps > 0) && !unit_width)

	mov	edi, DWORD PTR [esi+32]
	test	edi, edi
	jle	$LN48@init
	cmp	BYTE PTR [esi+101], 0
	jne	$LN48@init

; 504  :         {
; 505  :           child_ranges[LL_BAND] /= hor_low_gain;
; 506  :           child_ranges[HL_BAND] /= hor_high_gain;

	movss	xmm0, DWORD PTR _hor_high_gain$[ebp]

; 507  :           child_ranges[LH_BAND] /= hor_low_gain;
; 508  :           child_ranges[HH_BAND] /= hor_high_gain;

	movss	xmm1, DWORD PTR _child_ranges$[ebp+12]

; 509  : 
; 510  :           float bibo_prev, bibo_in, bibo_out;
; 511  : 
; 512  :           // Find maximum gain at output of vertical decomposition, if any
; 513  :           bibo_prev = vert_bibo_gains[num_vert_steps];

	mov	ecx, DWORD PTR _vert_bibo_gains$1$[ebp]
	divss	xmm3, DWORD PTR _hor_low_gain$[ebp]
	divss	xmm5, DWORD PTR _hor_low_gain$[ebp]
	movss	DWORD PTR _child_ranges$[ebp], xmm3
	movss	xmm3, DWORD PTR _child_ranges$[ebp+4]
	movss	DWORD PTR _child_ranges$[ebp+8], xmm5
	divss	xmm3, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR _child_ranges$[ebp+4], xmm3
	movss	xmm3, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR _child_ranges$[ebp+12], xmm1

; 514  :           if ((num_vert_steps > 0) &&

	test	eax, eax
	jle	SHORT $LN119@init
	movss	xmm0, DWORD PTR [ecx+eax*4-4]
	comiss	xmm0, xmm3
	jbe	SHORT $LN119@init

; 515  :               (vert_bibo_gains[num_vert_steps-1] > bibo_prev))
; 516  :             bibo_prev = vert_bibo_gains[num_vert_steps-1];

	movaps	xmm3, xmm0
$LN119@init:

; 517  :           bibo_prev *= normalization; // Account for fact that gains reported

	mulss	xmm3, xmm4

; 518  :                    // by `kdu_node::get_bibo_gains' assume `normalization'=1
; 519  : 
; 520  :           for (bibo_in=bibo_prev, n=0; n < num_hor_steps; n++,

	movaps	xmm0, xmm3
	test	edi, edi
	jle	SHORT $LN48@init

; 526  :               if (use_shorts && hor_steps[n].add_shorts_first)

	xor	ecx, ecx
	add	edx, 4
	npad	5
$LL49@init:

; 521  :                bibo_in=bibo_out)
; 522  :             {
; 523  :               bibo_out = bibo_prev * hor_bibo_gains[n+1];

	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR [edx]

; 524  :               if (bibo_out > bibo_max)

	comiss	xmm1, xmm2
	jbe	SHORT $LN120@init

; 525  :                 bibo_max = bibo_out; // Fit representation to lifting outputs

	movaps	xmm2, xmm1
$LN120@init:

; 526  :               if (use_shorts && hor_steps[n].add_shorts_first)

	cmp	BYTE PTR _use_shorts$GSCopy$1$[ebp], 0
	je	SHORT $LN47@init
	mov	eax, DWORD PTR [esi+52]
	cmp	BYTE PTR [ecx+eax+16], 0
	je	SHORT $LN47@init

; 527  :                 {
; 528  :                   bibo_in *= 2.0; // Avoid overflow during pre-accumulation

	cvtss2sd xmm0, xmm0
	mulsd	xmm0, xmm7
	cvtsd2ss xmm0, xmm0

; 529  :                   if (bibo_in > bibo_max)

	comiss	xmm0, xmm2
	jbe	SHORT $LN47@init

; 530  :                     bibo_max = bibo_in;

	movaps	xmm2, xmm0
$LN47@init:

; 518  :                    // by `kdu_node::get_bibo_gains' assume `normalization'=1
; 519  : 
; 520  :           for (bibo_in=bibo_prev, n=0; n < num_hor_steps; n++,

	add	edx, 4
	add	ecx, 20					; 00000014H
	movaps	xmm0, xmm1
	sub	edi, 1
	jne	SHORT $LL49@init
$LN48@init:

; 531  :                 }
; 532  :             }
; 533  :         }
; 534  : 
; 535  :       if (use_shorts)

	cmp	BYTE PTR _use_shorts$GSCopy$1$[ebp], 0
	je	SHORT $LN51@init

; 536  :         {
; 537  :           float overflow_limit = 1.0F * (float)(1<<(16-KDU_FIX_POINT));
; 538  :             // This is the largest numeric range which can be represented in
; 539  :             // our signed 16-bit fixed-point representation without overflow.
; 540  :           while (bibo_max > 0.95*overflow_limit)

	movsd	xmm3, QWORD PTR __real@401e666666666666
	xorps	xmm0, xmm0
	cvtss2sd xmm0, xmm2
	comisd	xmm0, xmm3
	jbe	SHORT $LN51@init
	movaps	xmm4, XMMWORD PTR __xmm@3f0000003f0000003f0000003f000000
	mov	eax, DWORD PTR [esi+60]
	movups	xmm1, XMMWORD PTR _child_ranges$[ebp]
	movsd	xmm5, QWORD PTR __real@3fe0000000000000
$LL50@init:

; 541  :             { // Leave a little extra headroom to allow for approximations in
; 542  :               // the numerical BIBO gain calculations.
; 543  :               normalizing_downshift++;
; 544  :               for (int b=0; b < 4; b++)
; 545  :                 child_ranges[b] *= 0.5F;

	xorps	xmm0, xmm0
	mulps	xmm1, xmm4
	inc	eax

; 546  :               bibo_max *= 0.5;

	cvtss2sd xmm0, xmm2
	movups	XMMWORD PTR _child_ranges$[ebp], xmm1
	mulsd	xmm0, xmm5
	cvtpd2ps xmm2, xmm0
	cvtps2pd xmm0, xmm2
	comisd	xmm0, xmm3
	ja	SHORT $LL50@init
	mov	DWORD PTR [esi+60], eax
$LN51@init:

; 552  :   for (n=0; n < 4; n++)

	lea	eax, DWORD PTR [esi+4]
	xor	edi, edi
	mov	DWORD PTR tv3323[ebp], eax
	npad	3
$LL57@init:
	lea	eax, DWORD PTR _child$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4994 :     bool operator!() { return (state==NULL)?true:false; }

	cmp	DWORD PTR [eax+edi*4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 552  :   for (n=0; n < 4; n++)

	lea	eax, DWORD PTR [eax+edi*4]

; 553  :     {
; 554  :       if (!child[n])

	je	$LN55@init

; 555  :         continue;
; 556  :       kdu_roi_node *roi_child = NULL;
; 557  :       if (roi != NULL)

	cmp	DWORD PTR _roi$GSCopy$1$[ebp], 0
	mov	DWORD PTR _roi_child$1$[ebp], 0
	je	SHORT $LN125@init

; 558  :         roi_child = roi_level.acquire_node(n);

	push	edi
	lea	ecx, DWORD PTR [esi+104]
	call	?acquire_node@kdu_roi_level@@QAEPAVkdu_roi_node@@H@Z ; kdu_roi_level::acquire_node
	mov	DWORD PTR _roi_child$1$[ebp], eax
	lea	eax, DWORD PTR _child$[ebp]
	lea	eax, DWORD PTR [eax+edi*4]
$LN125@init:

; 559  :       if (!child[n].access_child(LL_BAND))

	push	0
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	mov	ecx, eax
	call	?access_child@kdu_node@@QAE?AV1@H@Z	; kdu_node::access_child
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4994 :     bool operator!() { return (state==NULL)?true:false; }

	cmp	DWORD PTR [eax], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 559  :       if (!child[n].access_child(LL_BAND))

	jne	SHORT $LN126@init

; 560  :         subbands[n] = kdu_encoder(child[n].access_subband(),allocator,

	lea	eax, DWORD PTR $T12[ebp]
	lea	ecx, DWORD PTR _child$[ebp]
	push	eax
	lea	ecx, DWORD PTR [ecx+edi*4]
	call	?access_subband@kdu_node@@QAE?AVkdu_subband@@XZ ; kdu_node::access_subband
	push	DWORD PTR _env_queue$GSCopy$1$[ebp]
	movss	xmm0, DWORD PTR _child_ranges$[ebp+edi*4]
	push	DWORD PTR _env$GSCopy$1$[ebp]
	push	DWORD PTR _roi_child$1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	push	DWORD PTR _use_shorts$GSCopy$[ebp]
	push	DWORD PTR _allocator$GSCopy$1$[ebp]
	push	DWORD PTR [eax]
	call	??0kdu_encoder@@QAE@Vkdu_subband@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_encoder::kdu_encoder

; 561  :                                   use_shorts,child_ranges[n],roi_child,
; 562  :                                   env,env_queue);
; 563  :       else

	jmp	SHORT $LN329@init
$LN126@init:

; 564  :         subbands[n] = kdu_analysis(child[n],allocator,use_shorts,

	push	DWORD PTR _env_queue$GSCopy$1$[ebp]
	movss	xmm0, DWORD PTR _child_ranges$[ebp+edi*4]
	lea	eax, DWORD PTR _child$[ebp]
	push	DWORD PTR _env$GSCopy$1$[ebp]
	lea	eax, DWORD PTR [eax+edi*4]
	push	DWORD PTR _roi_child$1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T4[ebp]
	push	DWORD PTR _use_shorts$GSCopy$[ebp]
	push	DWORD PTR _allocator$GSCopy$1$[ebp]
	push	DWORD PTR [eax]
	call	??0kdu_analysis@@QAE@Vkdu_node@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kdu_analysis::kdu_analysis
$LN329@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 2048 :   { state = rhs.state; return *this; }

	mov	ecx, DWORD PTR tv3323[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN55@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 552  :   for (n=0; n < 4; n++)

	add	DWORD PTR tv3323[ebp], 4
	inc	edi
	cmp	edi, 4
	jl	$LL57@init
$LN56@init:

; 565  :                                    child_ranges[n],roi_child,
; 566  :                                    env,env_queue);
; 567  :     }
; 568  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?init@kd_analysis@@QAEXVkdu_node@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ENDP ; kd_analysis::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_roi_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis_local.h
;	COMDAT ??0kd_analysis@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0kd_analysis@@QAE@XZ PROC				; kd_analysis::kd_analysis, COMDAT
; _this$ = ecx

; 70   :     kd_analysis()

	push	ebp
	mov	ebp, esp
	push	ecx

; 71   :       {

	mov	DWORD PTR [ecx], OFFSET ??_7kd_analysis@@6B@

; 155  :     int *next_row_pos_handle; // Used to allocate `step_next_row_pos'

	lea	eax, DWORD PTR [ecx+236]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 598  :     kdu_push_ifc() { state = NULL; }

	mov	DWORD PTR [ecx+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis_local.h

; 155  :     int *next_row_pos_handle; // Used to allocate `step_next_row_pos'

	mov	edx, 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 598  :     kdu_push_ifc() { state = NULL; }

	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis_local.h

; 70   :     kd_analysis()

	mov	DWORD PTR _this$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_roi_processing.h

; 124  :     kdu_roi_level() { state = NULL; }

	mov	DWORD PTR [ecx+104], 0
	npad	5
$LL16@kd_analysi:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax+28]
	mov	WORD PTR [eax-22], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [eax-20], 0
	mov	DWORD PTR [eax-16], 0
	mov	WORD PTR [eax-10], 0
	mov	DWORD PTR [eax-8], 0
	sub	edx, 1
	jne	SHORT $LL16@kd_analysi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis_local.h

; 72   :         vert_source_vlines=NULL; vert_source_bufs=NULL;

	mov	DWORD PTR [ecx+36], edx

; 73   :         free_lines=NULL; vert_steps=hor_steps=NULL; queues=NULL;
; 74   :         coeff_handle=NULL; icoeff_handle=NULL; source_buf_handle=NULL;
; 75   :         line_handle=NULL; vert_step_handle=hor_step_handle=NULL;
; 76   :         queue_handle=NULL; next_row_pos_handle=NULL;
; 77   :       }

	mov	eax, ecx
	mov	DWORD PTR [ecx+40], edx
	mov	DWORD PTR [ecx+44], edx
	mov	DWORD PTR [ecx+52], edx
	mov	DWORD PTR [ecx+48], edx
	mov	DWORD PTR [ecx+64], edx
	mov	DWORD PTR [ecx+108], edx
	mov	DWORD PTR [ecx+112], edx
	mov	DWORD PTR [ecx+116], edx
	mov	DWORD PTR [ecx+120], edx
	mov	DWORD PTR [ecx+128], edx
	mov	DWORD PTR [ecx+124], edx
	mov	DWORD PTR [ecx+132], edx
	mov	DWORD PTR [ecx+136], edx
	mov	esp, ebp
	pop	ebp
	ret	0
??0kd_analysis@@QAE@XZ ENDP				; kd_analysis::kd_analysis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_roi_processing.h
;	COMDAT ?exists@kdu_roi_level@@QAE_NXZ
_TEXT	SEGMENT
?exists@kdu_roi_level@@QAE_NXZ PROC			; kdu_roi_level::exists, COMDAT
; _this$ = ecx

; 131  :     bool exists() { return (state != NULL); }

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al
	ret	0
?exists@kdu_roi_level@@QAE_NXZ ENDP			; kdu_roi_level::exists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_roi_processing.h
;	COMDAT ??0kdu_roi_level@@QAE@XZ
_TEXT	SEGMENT
??0kdu_roi_level@@QAE@XZ PROC				; kdu_roi_level::kdu_roi_level, COMDAT
; _this$ = ecx

; 124  :     kdu_roi_level() { state = NULL; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0kdu_roi_level@@QAE@XZ ENDP				; kdu_roi_level::kdu_roi_level
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
;	COMDAT ?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z
_TEXT	SEGMENT
_i_lambda$1$ = -48					; size = 4
tv3503 = -48						; size = 4
tv3467 = -48						; size = 4
tv3459 = -48						; size = 4
tv3457 = -48						; size = 4
_downshift$1$ = -44					; size = 4
tv3476 = -44						; size = 4
tv3460 = -44						; size = 4
tv3477 = -40						; size = 4
tv3463 = -40						; size = 4
tv3502 = -36						; size = 4
tv3478 = -36						; size = 4
_offset$1$ = -32					; size = 4
tv3495 = -32						; size = 4
_sum$1$ = -28						; size = 4
tv3496 = -28						; size = 4
_fpp$1$ = -24						; size = 4
tv3493 = -24						; size = 4
$T1 = -20						; size = 4
tv3488 = -20						; size = 4
tv3473 = -20						; size = 4
tv3471 = -20						; size = 4
tv3469 = -20						; size = 4
tv3465 = -20						; size = 4
_support$1$ = -16					; size = 4
_t$1$ = -16						; size = 4
_downshift$1$ = -16					; size = 4
tv3483 = -16						; size = 4
_offset$1$ = -12					; size = 4
_in$1$ = -12						; size = 4
$T2 = -8						; size = 4
_k$2$ = -8						; size = 4
_sp1$1$ = -8						; size = 4
_out$1$ = -4						; size = 4
_step$ = 8						; size = 4
_src_ptrs$ = 12						; size = 4
_in$ = 16						; size = 4
_out$ = 20						; size = 4
_sp2$1$ = 24						; size = 4
_width$ = 24						; size = 4
_x_off$ = 28						; size = 4
?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z PROC ; perform_analysis_lifting_step, COMDAT

; 1155 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi

; 1156 :   int k;
; 1157 : 
; 1158 :   if (width <= 0)

	mov	esi, DWORD PTR _width$[ebp]
	test	esi, esi
	jle	$LN23@perform_an

; 1159 :     return;
; 1160 :   while (x_off > 4)

	push	ebx
	mov	ebx, DWORD PTR _in$[ebp]
	push	edi
	mov	edi, DWORD PTR _x_off$[ebp]
	cmp	edi, 4
	jle	SHORT $LN96@perform_an
	lea	ecx, DWORD PTR [edi-5]
	shr	ecx, 2
	inc	ecx
	mov	eax, ecx
	shl	ecx, 4
	neg	eax
	lea	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, ecx
	mov	DWORD PTR _x_off$[ebp], edi
	add	ebx, ecx
	jmp	SHORT $LN101@perform_an
$LN96@perform_an:
	mov	eax, DWORD PTR _out$[ebp]
$LN101@perform_an:

; 1161 :     { x_off -= 4; in += 4; out += 4; }
; 1162 :   width += x_off;
; 1163 : 
; 1164 : #ifdef KDU_SIMD_OPTIMIZATIONS
; 1165 :   if (step->kernel_id == (kdu_byte) Ckernels_W5X3)

	mov	ecx, DWORD PTR _step$[ebp]
	add	esi, edi
	mov	DWORD PTR _in$1$[ebp], ebx
	mov	DWORD PTR _out$1$[ebp], eax
	mov	DWORD PTR _width$[ebp], esi
	cmp	BYTE PTR [ecx+18], 1
	jne	SHORT $LN29@perform_an

; 1166 :     {
; 1167 :       if (simd_W5X3_v_analysis32(&(src_ptrs[0]->ival),&(src_ptrs[1]->ival),

	push	ecx
	push	esi
	push	eax
	mov	eax, DWORD PTR _src_ptrs$[ebp]
	push	ebx
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	?simd_W5X3_v_analysis32@@YA_NPAH000HPAUkd_lifting_step@@@Z ; simd_W5X3_v_analysis32
	add	esp, 24					; 00000018H

; 1168 :                                  &(in->ival),&(out->ival),width,step))
; 1169 :        return;
; 1170 :     }

	jmp	SHORT $LN103@perform_an
$LN29@perform_an:

; 1171 :   else if (!step->reversible)

	cmp	BYTE PTR [ecx+17], 0
	jne	SHORT $LN37@perform_an

; 1172 :     {
; 1173 :       if (step->support_length <= 2)

	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, 2
	ja	SHORT $LN33@perform_an

; 1174 :         {
; 1175 :           if (simd_2tap_v_irrev32(&(src_ptrs[0]->fval),

	push	0
	push	ecx
	mov	ecx, DWORD PTR _src_ptrs$[ebp]
	push	esi
	push	eax
	movzx	eax, dl
	push	ebx
	push	DWORD PTR [ecx+eax*4-4]
	push	DWORD PTR [ecx]
	call	?simd_2tap_v_irrev32@@YA_NPAM000HPAUkd_lifting_step@@_N@Z ; simd_2tap_v_irrev32
	add	esp, 28					; 0000001cH

; 1176 :                                   &(src_ptrs[step->support_length-1]->fval),
; 1177 :                                   &(in->fval),&(out->fval),width,step,false))
; 1178 :             return;
; 1179 :         }

	jmp	SHORT $LN103@perform_an
$LN33@perform_an:

; 1180 :       else if (step->support_length <= 4)

	cmp	dl, 4
	ja	SHORT $LN37@perform_an

; 1181 :         {
; 1182 :           if (simd_4tap_v_irrev32(&(src_ptrs[0]->fval),&(src_ptrs[1]->fval),

	push	0
	push	ecx
	mov	ecx, DWORD PTR _src_ptrs$[ebp]
	push	esi
	push	eax
	movzx	eax, dl
	push	ebx
	push	DWORD PTR [ecx+eax*4-4]
	push	DWORD PTR [ecx+8]
	push	DWORD PTR [ecx+4]
	push	DWORD PTR [ecx]
	call	?simd_4tap_v_irrev32@@YA_NPAM00000HPAUkd_lifting_step@@_N@Z ; simd_4tap_v_irrev32
	add	esp, 36					; 00000024H
$LN103@perform_an:
	test	al, al
	jne	$LN99@perform_an
$LN37@perform_an:

; 1183 :                                   &(src_ptrs[2]->fval),
; 1184 :                                   &(src_ptrs[step->support_length-1]->fval),
; 1185 :                                   &(in->fval),&(out->fval),width,step,false))
; 1186 :             return;
; 1187 :         }
; 1188 :     }
; 1189 : #endif // KDU_SIMD_OPTIMIZATIONS
; 1190 :   if ((step->support_length==2) && (step->coeffs[0]==step->coeffs[1]))

	mov	eax, DWORD PTR _step$[ebp]
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, 2
	jne	$LN38@perform_an
	mov	eax, DWORD PTR [eax+8]
	movss	xmm1, DWORD PTR [eax]
	ucomiss	xmm1, DWORD PTR [eax+4]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN98@perform_an

; 1191 :     { // Special implementation for symmetric least-dissimilar filters
; 1192 :       kdu_sample32 *sp1=src_ptrs[0], *sp2=src_ptrs[1];

	mov	eax, DWORD PTR _src_ptrs$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 1193 :       if (!step->reversible)

	mov	eax, DWORD PTR _step$[ebp]
	mov	DWORD PTR _sp1$1$[ebp], ecx
	cmp	BYTE PTR [eax+17], 0
	jne	$LN40@perform_an
	cmp	edi, esi
	jge	$LN99@perform_an
	mov	eax, esi
	sub	eax, edi

; 1194 :         {
; 1195 :           float lambda = step->coeffs[0];
; 1196 :           for (k=x_off; k < width; k++)

	cmp	eax, 4
	jl	$LN97@perform_an
	lea	eax, DWORD PTR [esi-3]
	mov	DWORD PTR tv3503[ebp], eax
	lea	ecx, DWORD PTR [ecx+edi*4]
	mov	eax, DWORD PTR _out$1$[ebp]
	add	ecx, 4
	lea	esi, DWORD PTR [eax+12]
	lea	esi, DWORD PTR [esi+edi*4]
	mov	DWORD PTR tv3496[ebp], esi
	lea	esi, DWORD PTR [edi+2]
	lea	esi, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR tv3495[ebp], esi
	mov	esi, edx
	sub	esi, DWORD PTR _sp1$1$[ebp]
	mov	DWORD PTR tv3493[ebp], esi
	mov	esi, ebx
	sub	esi, DWORD PTR _sp1$1$[ebp]
	mov	DWORD PTR tv3488[ebp], esi
	mov	esi, eax
	sub	esi, DWORD PTR _sp1$1$[ebp]
	mov	DWORD PTR tv3483[ebp], esi
	mov	esi, edx
	sub	esi, ebx
	mov	DWORD PTR tv3478[ebp], esi
	mov	esi, eax
	sub	esi, ebx
	mov	ebx, edx
	sub	ebx, eax
	mov	DWORD PTR tv3477[ebp], esi
	mov	eax, DWORD PTR tv3495[ebp]
	mov	DWORD PTR tv3476[ebp], ebx
	mov	ebx, DWORD PTR tv3496[ebp]
	npad	11
$LL78@perform_an:

; 1197 :             out[k].fval = in[k].fval + lambda*(sp1[k].fval+sp2[k].fval);

	movss	xmm0, DWORD PTR [edx+edi*4]
	add	edi, 4
	addss	xmm0, DWORD PTR [ecx-4]
	mov	esi, DWORD PTR tv3493[ebp]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax-8]
	movss	DWORD PTR [ebx-12], xmm0
	movss	xmm0, DWORD PTR [esi+ecx]
	addss	xmm0, DWORD PTR [ecx]
	mov	esi, DWORD PTR tv3488[ebp]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [esi+ecx]
	mov	esi, DWORD PTR tv3483[ebp]
	movss	DWORD PTR [esi+ecx], xmm0
	mov	esi, DWORD PTR tv3478[ebp]
	movss	xmm0, DWORD PTR [esi+eax]
	addss	xmm0, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR tv3477[ebp]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esi+eax], xmm0
	mov	esi, DWORD PTR tv3476[ebp]
	movss	xmm0, DWORD PTR [esi+ebx]
	addss	xmm0, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR _width$[ebp]
	add	ecx, 16					; 00000010H
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+4]
	add	eax, 16					; 00000010H
	movss	DWORD PTR [ebx], xmm0
	add	ebx, 16					; 00000010H
	cmp	edi, DWORD PTR tv3503[ebp]
	jl	$LL78@perform_an
	mov	ebx, DWORD PTR _in$1$[ebp]
	mov	ecx, DWORD PTR _sp1$1$[ebp]
$LN97@perform_an:
	mov	eax, DWORD PTR _out$1$[ebp]

; 1194 :         {
; 1195 :           float lambda = step->coeffs[0];
; 1196 :           for (k=x_off; k < width; k++)

	cmp	edi, esi
	jge	$LN99@perform_an
	sub	edx, DWORD PTR _sp1$1$[ebp]
	lea	ecx, DWORD PTR [ecx+edi*4]
	sub	ebx, DWORD PTR _sp1$1$[ebp]
	sub	eax, DWORD PTR _sp1$1$[ebp]
	sub	esi, edi
	npad	10
$LC6@perform_an:

; 1197 :             out[k].fval = in[k].fval + lambda*(sp1[k].fval+sp2[k].fval);

	movss	xmm0, DWORD PTR [ecx+edx]
	addss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [ecx+ebx]
	movss	DWORD PTR [ecx+eax], xmm0
	add	ecx, 4
	sub	esi, 1
	jne	SHORT $LC6@perform_an
	pop	edi
	pop	ebx
	pop	esi

; 1241 :             }
; 1242 :         }
; 1243 :     }
; 1244 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@perform_an:

; 1198 :         }
; 1199 :       else
; 1200 :         {
; 1201 :           kdu_int32 downshift = step->downshift;

	movzx	ecx, BYTE PTR [eax+2]
	mov	DWORD PTR _downshift$1$[ebp], ecx

; 1202 :           kdu_int32 offset = step->rounding_offset;

	movsx	ecx, WORD PTR [eax+6]

; 1203 :           kdu_int32 i_lambda = step->icoeffs[0];

	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _offset$1$[ebp], ecx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _i_lambda$1$[ebp], eax

; 1204 :           if (i_lambda == 1)

	cmp	eax, 1
	jne	SHORT $LN42@perform_an

; 1205 :             for (k=x_off; k < width; k++)

	cmp	edi, esi
	jge	$LN99@perform_an
	mov	eax, DWORD PTR _sp1$1$[ebp]
	sub	edx, eax
	mov	DWORD PTR _sp2$1$[ebp], edx
	sub	ebx, eax
	mov	edx, DWORD PTR _out$1$[ebp]
	sub	edx, eax
	sub	esi, edi
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR _sp2$1$[ebp]
	mov	DWORD PTR tv3473[ebp], ecx
$LL9@perform_an:

; 1206 :               out[k].ival = in[k].ival +

	mov	eax, DWORD PTR [ecx+edi]
	add	eax, DWORD PTR _offset$1$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sar	eax, cl
	mov	ecx, DWORD PTR tv3473[ebp]
	add	eax, DWORD PTR [ecx+ebx]
	mov	DWORD PTR [ecx+edx], eax
	add	ecx, 4
	mov	DWORD PTR tv3473[ebp], ecx
	sub	esi, 1
	jne	SHORT $LL9@perform_an
	pop	edi
	pop	ebx
	pop	esi

; 1241 :             }
; 1242 :         }
; 1243 :     }
; 1244 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@perform_an:

; 1207 :                 ((offset + sp1[k].ival + sp2[k].ival) >> downshift);
; 1208 :           else if (i_lambda == -1)

	cmp	eax, -1
	jne	SHORT $LN44@perform_an

; 1209 :             for (k=x_off; k < width; k++)

	cmp	edi, esi
	jge	$LN99@perform_an
	mov	eax, DWORD PTR _sp1$1$[ebp]
	sub	edx, eax
	mov	DWORD PTR _sp2$1$[ebp], edx
	sub	ebx, eax
	mov	edx, DWORD PTR _out$1$[ebp]
	sub	edx, eax
	sub	esi, edi
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR _sp2$1$[ebp]
	mov	DWORD PTR tv3471[ebp], ecx
$LL12@perform_an:

; 1210 :               out[k].ival = in[k].ival +

	mov	eax, DWORD PTR _offset$1$[ebp]
	sub	eax, DWORD PTR [edi+ecx]
	sub	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sar	eax, cl
	mov	ecx, DWORD PTR tv3471[ebp]
	add	eax, DWORD PTR [ebx+ecx]
	mov	DWORD PTR [edx+ecx], eax
	add	ecx, 4
	mov	DWORD PTR tv3471[ebp], ecx
	sub	esi, 1
	jne	SHORT $LL12@perform_an
	pop	edi
	pop	ebx
	pop	esi

; 1241 :             }
; 1242 :         }
; 1243 :     }
; 1244 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@perform_an:

; 1211 :                 ((offset - sp1[k].ival - sp2[k].ival) >> downshift);
; 1212 :           else
; 1213 :             for (k=x_off; k < width; k++)

	cmp	edi, esi
	jge	$LN99@perform_an
	mov	eax, DWORD PTR _sp1$1$[ebp]
	sub	edx, eax
	mov	DWORD PTR _sp2$1$[ebp], edx
	sub	ebx, eax
	mov	edx, DWORD PTR _out$1$[ebp]
	sub	edx, eax
	sub	esi, edi
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR _sp2$1$[ebp]
	mov	DWORD PTR tv3469[ebp], ecx
	npad	4
$LL15@perform_an:

; 1214 :               out[k].ival = in[k].ival +

	mov	eax, DWORD PTR [edi+ecx]
	add	eax, DWORD PTR [ecx]
	imul	eax, DWORD PTR _i_lambda$1$[ebp]
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	add	eax, DWORD PTR _offset$1$[ebp]
	sar	eax, cl
	mov	ecx, DWORD PTR tv3469[ebp]
	add	eax, DWORD PTR [ebx+ecx]
	mov	DWORD PTR [edx+ecx], eax
	add	ecx, 4
	mov	DWORD PTR tv3469[ebp], ecx
	sub	esi, 1
	jne	SHORT $LL15@perform_an
	pop	edi
	pop	ebx
	pop	esi

; 1241 :             }
; 1242 :         }
; 1243 :     }
; 1244 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN98@perform_an:
	mov	eax, DWORD PTR _step$[ebp]
$LN38@perform_an:

; 1215 :                 ((offset + i_lambda*(sp1[k].ival+sp2[k].ival))>>downshift);
; 1216 :         }
; 1217 :     }
; 1218 :   else
; 1219 :     { // More general 32-bit processing
; 1220 :       int t;
; 1221 :       if (!step->reversible)

	cmp	BYTE PTR [eax+17], 0
	jne	$LN46@perform_an

; 1222 :         {
; 1223 :           for (t=0; t < step->support_length; t++, in=out)

	xor	edx, edx
	mov	DWORD PTR _t$1$[ebp], edx
	test	cl, cl
	je	$LN99@perform_an
	mov	ecx, DWORD PTR _out$1$[ebp]
	npad	7
$LL18@perform_an:

; 1224 :             {
; 1225 :               kdu_sample32 *sp = src_ptrs[t];

	mov	edi, DWORD PTR _src_ptrs$[ebp]

; 1226 :               float lambda = step->coeffs[t];

	mov	eax, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR _t$1$[ebp]
	movss	xmm1, DWORD PTR [eax+edi*4]

; 1227 :               for (k=x_off; k < width; k++)

	mov	edi, DWORD PTR _x_off$[ebp]
	mov	DWORD PTR _k$2$[ebp], edi
	cmp	edi, esi
	jge	$LN16@perform_an
	mov	eax, esi
	sub	eax, edi
	cmp	eax, 4
	jl	$LC80@perform_an
	lea	eax, DWORD PTR [esi-3]
	mov	esi, ecx
	mov	DWORD PTR tv3502[ebp], eax
	sub	esi, ebx
	lea	eax, DWORD PTR [edi+2]
	mov	DWORD PTR tv3460[ebp], esi
	inc	edi
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv3467[ebp], eax
	lea	eax, DWORD PTR [ebx+edi*4]
	mov	edi, edx
	sub	edi, ebx
	mov	ebx, edx
	sub	ebx, ecx
	mov	DWORD PTR tv3465[ebp], edi
	mov	ecx, DWORD PTR _k$2$[ebp]
	mov	edi, DWORD PTR tv3467[ebp]
	mov	esi, DWORD PTR tv3465[ebp]
	mov	DWORD PTR tv3463[ebp], ebx
	mov	ebx, DWORD PTR tv3460[ebp]
$LL81@perform_an:

; 1228 :                 out[k].fval = in[k].fval + lambda*sp[k].fval;

	movss	xmm0, DWORD PTR [edx+ecx*4]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax-4]
	movss	DWORD PTR [edi-8], xmm0
	movss	xmm0, DWORD PTR [esi+eax]
	mov	esi, DWORD PTR tv3463[ebp]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax+ebx], xmm0
	movss	xmm0, DWORD PTR [esi+edi]
	mov	esi, DWORD PTR tv3465[ebp]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [edi], xmm0
	movss	xmm0, DWORD PTR [edx+ecx*4+12]
	add	ecx, 4
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+8]
	add	eax, 16					; 00000010H
	movss	DWORD PTR [edi+4], xmm0
	add	edi, 16					; 00000010H
	cmp	ecx, DWORD PTR tv3502[ebp]
	jl	SHORT $LL81@perform_an
	mov	esi, DWORD PTR _width$[ebp]
	mov	ebx, DWORD PTR _in$1$[ebp]
	mov	DWORD PTR _k$2$[ebp], ecx
	mov	ecx, DWORD PTR _out$1$[ebp]
$LC80@perform_an:

; 1227 :               for (k=x_off; k < width; k++)

	mov	eax, DWORD PTR _k$2$[ebp]
	cmp	eax, esi
	jge	SHORT $LN16@perform_an
	sub	ecx, ebx
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv3459[ebp], ecx
	sub	edx, ebx
	mov	ebx, DWORD PTR tv3459[ebp]
	mov	ecx, esi
	sub	ecx, DWORD PTR _k$2$[ebp]
	npad	12
$LC21@perform_an:

; 1228 :                 out[k].fval = in[k].fval + lambda*sp[k].fval;

	movss	xmm0, DWORD PTR [edx+eax]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ebx+eax], xmm0
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LC21@perform_an
	mov	ecx, DWORD PTR _out$1$[ebp]
$LN16@perform_an:

; 1222 :         {
; 1223 :           for (t=0; t < step->support_length; t++, in=out)

	mov	eax, DWORD PTR _step$[ebp]
	mov	ebx, ecx
	mov	edx, DWORD PTR _t$1$[ebp]
	inc	edx
	mov	DWORD PTR _in$1$[ebp], ebx
	mov	DWORD PTR _t$1$[ebp], edx
	movzx	eax, BYTE PTR [eax+1]
	cmp	edx, eax
	mov	eax, DWORD PTR _step$[ebp]
	jl	$LL18@perform_an
	pop	edi
	pop	ebx
	pop	esi

; 1241 :             }
; 1242 :         }
; 1243 :     }
; 1244 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@perform_an:

; 1229 :             }
; 1230 :         }
; 1231 :       else
; 1232 :         {
; 1233 :           kdu_int32 downshift = step->downshift;

	movzx	edx, BYTE PTR [eax+2]
	mov	DWORD PTR _downshift$1$[ebp], edx

; 1234 :           kdu_int32 offset = step->rounding_offset;

	movsx	edx, WORD PTR [eax+6]

; 1235 :           int sum, *fpp, support=step->support_length;

	movzx	ecx, cl
	mov	DWORD PTR _offset$1$[ebp], edx
	mov	DWORD PTR _support$1$[ebp], ecx

; 1236 :           for (k=x_off; k < width; k++)

	cmp	edi, esi
	jge	$LN99@perform_an
	mov	ecx, DWORD PTR _out$1$[ebp]
	sub	ebx, ecx
	mov	DWORD PTR _in$1$[ebp], ebx
$LL24@perform_an:

; 1237 :             {
; 1238 :               for (fpp=step->icoeffs, sum=offset, t=0; t < support; t++)

	mov	eax, DWORD PTR [eax+12]
	mov	esi, DWORD PTR _width$[ebp]
	mov	DWORD PTR _sum$1$[ebp], edx
	xor	edx, edx
	cmp	DWORD PTR _support$1$[ebp], 2
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR _fpp$1$[ebp], eax
	jl	SHORT $LC83@perform_an
	mov	esi, DWORD PTR _src_ptrs$[ebp]
	lea	ecx, DWORD PTR [eax+4]
	mov	eax, esi
	sub	eax, DWORD PTR _fpp$1$[ebp]
	mov	DWORD PTR tv3457[ebp], eax
	mov	ebx, eax
	npad	8
$LL84@perform_an:

; 1239 :                 sum += fpp[t] * (src_ptrs[t])[k].ival;

	mov	eax, DWORD PTR [esi+edx*4]
	lea	ecx, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR _src_ptrs$[ebp]
	add	edx, 2
	mov	eax, DWORD PTR [eax+edi*4]
	imul	eax, DWORD PTR [ecx-12]
	add	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR [ebx+ecx-8]
	mov	eax, DWORD PTR [eax+edi*4]
	imul	eax, DWORD PTR [ecx-8]
	add	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _support$1$[ebp]
	dec	eax
	cmp	edx, eax
	jl	SHORT $LL84@perform_an
	mov	esi, DWORD PTR _width$[ebp]
	mov	ebx, DWORD PTR _in$1$[ebp]
	mov	ecx, DWORD PTR _out$1$[ebp]
$LC83@perform_an:

; 1237 :             {
; 1238 :               for (fpp=step->icoeffs, sum=offset, t=0; t < support; t++)

	cmp	edx, DWORD PTR _support$1$[ebp]
	jge	SHORT $LN82@perform_an

; 1239 :                 sum += fpp[t] * (src_ptrs[t])[k].ival;

	mov	eax, DWORD PTR _src_ptrs$[ebp]
	mov	esi, DWORD PTR _fpp$1$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+edi*4]
	imul	eax, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _offset$1$[ebp]
	mov	DWORD PTR _sum$1$[ebp], eax
$LN82@perform_an:

; 1236 :           for (k=x_off; k < width; k++)

	mov	eax, DWORD PTR $T2[ebp]
	lea	edx, DWORD PTR [ecx+edi*4]
	add	eax, DWORD PTR $T1[ebp]
	inc	edi
	add	eax, DWORD PTR _sum$1$[ebp]

; 1240 :               out[k].ival = in[k].ival + (sum >> downshift);

	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sar	eax, cl
	add	eax, DWORD PTR [edx+ebx]
	mov	ecx, DWORD PTR _out$1$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _step$[ebp]
	mov	edx, DWORD PTR _offset$1$[ebp]
	cmp	edi, esi
	jl	$LL24@perform_an
$LN99@perform_an:
	pop	edi
	pop	ebx
$LN23@perform_an:
	pop	esi

; 1241 :             }
; 1242 :         }
; 1243 :     }
; 1244 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample32@@PAT2@2HH@Z ENDP ; perform_analysis_lifting_step
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
;	COMDAT ?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z
_TEXT	SEGMENT
_downshift$1$ = -44					; size = 4
tv1227 = -40						; size = 4
_sum$1$ = -36						; size = 4
_offset$1$ = -32					; size = 4
_fpp$1$ = -28						; size = 4
$T1 = -24						; size = 4
_i_lambda$1$ = -24					; size = 4
_support$1$ = -20					; size = 4
_downshift$1$ = -20					; size = 4
$T2 = -16						; size = 4
_offset$1$ = -16					; size = 4
_in$1$ = -12						; size = 4
_out$1$ = -8						; size = 4
tv1250 = -1						; size = 1
_step$ = 8						; size = 4
_src_ptrs$ = 12						; size = 4
_in$ = 16						; size = 4
_out$ = 20						; size = 4
_sp2$1$ = 24						; size = 4
_sp1$1$ = 24						; size = 4
_width$ = 24						; size = 4
_x_off$ = 28						; size = 4
?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z PROC ; perform_analysis_lifting_step, COMDAT

; 1255 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi

; 1256 :   int k;
; 1257 : 
; 1258 :   if (width <= 0)

	mov	esi, DWORD PTR _width$[ebp]
	test	esi, esi
	jle	$LN14@perform_an

; 1259 :     return;
; 1260 :   while (x_off > 8)

	push	ebx
	mov	ebx, DWORD PTR _in$[ebp]
	push	edi
	mov	edi, DWORD PTR _x_off$[ebp]
	cmp	edi, 8
	jle	SHORT $LN57@perform_an
	lea	ecx, DWORD PTR [edi-9]
	shr	ecx, 3
	inc	ecx
	mov	eax, ecx
	shl	ecx, 4
	neg	eax
	lea	edi, DWORD PTR [edi+eax*8]
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, ecx
	add	ebx, ecx
	jmp	SHORT $LN61@perform_an
$LN57@perform_an:
	mov	eax, DWORD PTR _out$[ebp]
$LN61@perform_an:

; 1261 :     { x_off -= 8; in += 8; out += 8; }
; 1262 :   width += x_off;
; 1263 : 
; 1264 : #ifdef KDU_SIMD_OPTIMIZATIONS
; 1265 :   if ((step->kernel_id == (kdu_byte) Ckernels_W5X3) &&

	mov	ecx, DWORD PTR _step$[ebp]
	add	esi, edi
	mov	DWORD PTR _in$1$[ebp], ebx
	mov	DWORD PTR _out$1$[ebp], eax
	mov	DWORD PTR _width$[ebp], esi
	cmp	BYTE PTR [ecx+18], 1
	jne	SHORT $LN20@perform_an
	push	ecx
	push	esi
	push	eax
	mov	eax, DWORD PTR _src_ptrs$[ebp]
	push	ebx
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	?simd_W5X3_v_analysis@@YA_NPAF000HPAUkd_lifting_step@@@Z ; simd_W5X3_v_analysis
	add	esp, 24					; 00000018H
	test	al, al
	jne	$LN59@perform_an
	mov	ecx, DWORD PTR _step$[ebp]
$LN20@perform_an:

; 1266 :     simd_W5X3_v_analysis(&(src_ptrs[0]->ival),&(src_ptrs[1]->ival),
; 1267 :                          &(in->ival),&(out->ival),width,step))
; 1268 :      return;
; 1269 :   else if ((step->kernel_id == (kdu_byte) Ckernels_W9X7) &&

	cmp	BYTE PTR [ecx+18], 0
	jne	SHORT $LN22@perform_an
	mov	eax, DWORD PTR _src_ptrs$[ebp]
	push	ecx
	push	esi
	push	DWORD PTR _out$1$[ebp]
	push	ebx
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	?simd_W9X7_v_analysis@@YA_NPAF000HPAUkd_lifting_step@@@Z ; simd_W9X7_v_analysis
	add	esp, 24					; 00000018H
	test	al, al
	jne	$LN59@perform_an
	mov	ecx, DWORD PTR _step$[ebp]
$LN22@perform_an:

; 1270 :            simd_W9X7_v_analysis(&(src_ptrs[0]->ival),&(src_ptrs[1]->ival),
; 1271 :                                 &(in->ival),&(out->ival),width,step))
; 1272 :     return;
; 1273 : #endif // KDU_SIMD_OPTIMIZATIONS
; 1274 :   if ((step->support_length==2) && (step->icoeffs[0]==step->icoeffs[1]))

	mov	al, BYTE PTR [ecx+1]
	cmp	al, 2
	jne	$LN23@perform_an
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _i_lambda$1$[ebp], edx
	cmp	edx, DWORD PTR [eax+4]
	jne	$LN58@perform_an

; 1275 :     {
; 1276 :       kdu_sample16 *sp1=src_ptrs[0], *sp2=src_ptrs[1];
; 1277 :       kdu_int32 downshift = step->downshift;

	movzx	ecx, BYTE PTR [ecx+2]

; 1278 :       kdu_int32 offset = (1<<downshift)>>1;

	mov	edx, 1
	mov	eax, DWORD PTR _src_ptrs$[ebp]
	shl	edx, cl
	mov	DWORD PTR _downshift$1$[ebp], ecx
	mov	ecx, edx
	mov	DWORD PTR _offset$1$[ebp], edx
	mov	ebx, DWORD PTR [eax]

; 1279 :       kdu_int32 val, i_lambda=step->icoeffs[0];
; 1280 :       if (i_lambda == 1)

	mov	edx, DWORD PTR _i_lambda$1$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sar	ecx, 1
	mov	DWORD PTR _sp1$1$[ebp], ebx
	mov	DWORD PTR _offset$1$[ebp], ecx
	cmp	edx, 1
	jne	SHORT $LN25@perform_an

; 1281 :         for (k=x_off; k < width; k++)

	cmp	edi, esi
	jge	$LN59@perform_an
	mov	edx, DWORD PTR _sp1$1$[ebp]
	lea	ebx, DWORD PTR [ebx+edi*2]
	sub	DWORD PTR _in$1$[ebp], edx
	sub	eax, edx
	sub	DWORD PTR _out$1$[ebp], edx
	sub	esi, edi
	mov	edi, DWORD PTR _in$1$[ebp]
	mov	DWORD PTR _sp2$1$[ebp], eax
	npad	5
$LL6@perform_an:

; 1282 :           {
; 1283 :             val = sp1[k].ival;  val += sp2[k].ival;

	movsx	eax, WORD PTR [eax+ebx]
	lea	ebx, DWORD PTR [ebx+2]
	movsx	edx, WORD PTR [ebx-2]

; 1284 :             out[k].ival = in[k].ival + (kdu_int16)((offset+val)>>downshift);

	add	eax, ecx
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	add	edx, eax
	mov	eax, DWORD PTR _out$1$[ebp]
	sar	edx, cl
	add	dx, WORD PTR [edi+ebx-2]
	mov	ecx, DWORD PTR _offset$1$[ebp]
	mov	WORD PTR [eax+ebx-2], dx
	mov	eax, DWORD PTR _sp2$1$[ebp]
	sub	esi, 1
	jne	SHORT $LL6@perform_an
	pop	edi
	pop	ebx
	pop	esi

; 1309 :         }
; 1310 :     }
; 1311 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@perform_an:

; 1285 :           }
; 1286 :       else if (i_lambda == -1)

	cmp	edx, -1
	jne	SHORT $LN27@perform_an

; 1287 :         for (k=x_off; k < width; k++)

	cmp	edi, esi
	jge	$LN59@perform_an
	mov	edx, DWORD PTR _sp1$1$[ebp]
	lea	ebx, DWORD PTR [ebx+edi*2]
	sub	DWORD PTR _in$1$[ebp], edx
	sub	eax, edx
	sub	DWORD PTR _out$1$[ebp], edx
	sub	esi, edi
	mov	edi, DWORD PTR _in$1$[ebp]
	mov	DWORD PTR _sp2$1$[ebp], eax
$LL9@perform_an:

; 1288 :           {
; 1289 :             val = sp1[k].ival;  val += sp2[k].ival;

	movsx	eax, WORD PTR [ebx+eax]
	lea	ebx, DWORD PTR [ebx+2]

; 1290 :             out[k].ival = in[k].ival + (kdu_int16)((offset-val) >> downshift);

	mov	edx, ecx
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sub	edx, eax
	movsx	eax, WORD PTR [ebx-2]
	sub	edx, eax
	mov	eax, DWORD PTR _out$1$[ebp]
	sar	edx, cl
	add	dx, WORD PTR [ebx+edi-2]
	mov	ecx, DWORD PTR _offset$1$[ebp]
	mov	WORD PTR [ebx+eax-2], dx
	mov	eax, DWORD PTR _sp2$1$[ebp]
	sub	esi, 1
	jne	SHORT $LL9@perform_an
	pop	edi
	pop	ebx
	pop	esi

; 1309 :         }
; 1310 :     }
; 1311 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@perform_an:

; 1291 :           }
; 1292 :       else
; 1293 :         for (k=x_off; k < width; k++)

	cmp	edi, esi
	jge	$LN59@perform_an
	mov	edx, DWORD PTR _sp1$1$[ebp]
	lea	ebx, DWORD PTR [ebx+edi*2]
	sub	DWORD PTR _in$1$[ebp], edx
	sub	eax, edx
	sub	DWORD PTR _out$1$[ebp], edx
	sub	esi, edi
	mov	edi, DWORD PTR _in$1$[ebp]
	mov	DWORD PTR _sp2$1$[ebp], eax
	npad	7
$LL12@perform_an:

; 1294 :           {
; 1295 :             val = sp1[k].ival;  val += sp2[k].ival;  val *= i_lambda;

	movsx	edx, WORD PTR [ebx+eax]
	lea	ebx, DWORD PTR [ebx+2]
	movsx	eax, WORD PTR [ebx-2]
	add	edx, eax

; 1296 :             out[k].ival = in[k].ival + (kdu_int16)((offset+val) >> downshift);

	mov	eax, DWORD PTR _out$1$[ebp]
	imul	edx, DWORD PTR _i_lambda$1$[ebp]
	add	edx, ecx
	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sar	edx, cl
	add	dx, WORD PTR [ebx+edi-2]
	mov	ecx, DWORD PTR _offset$1$[ebp]
	mov	WORD PTR [ebx+eax-2], dx
	mov	eax, DWORD PTR _sp2$1$[ebp]
	sub	esi, 1
	jne	SHORT $LL12@perform_an
	pop	edi
	pop	ebx
	pop	esi

; 1309 :         }
; 1310 :     }
; 1311 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN58@perform_an:
	mov	al, BYTE PTR [ecx+1]
$LN23@perform_an:

; 1297 :           }
; 1298 :     }
; 1299 :   else
; 1300 :     { // More general 16-bit processing
; 1301 :       kdu_int32 downshift = step->downshift;

	movzx	edx, BYTE PTR [ecx+2]
	mov	DWORD PTR _downshift$1$[ebp], edx

; 1302 :       kdu_int32 offset = step->rounding_offset;

	movsx	edx, WORD PTR [ecx+6]

; 1303 :       int t, sum, *fpp, support=step->support_length;

	movzx	eax, al
	mov	DWORD PTR _offset$1$[ebp], edx
	mov	DWORD PTR _support$1$[ebp], eax

; 1304 :       for (k=x_off; k < width; k++)

	cmp	edi, esi
	jge	$LN59@perform_an
	mov	edx, DWORD PTR _out$1$[ebp]
	sub	ebx, edx
	mov	DWORD PTR _in$1$[ebp], ebx
	npad	2
$LL15@perform_an:

; 1305 :         {
; 1306 :           for (fpp=step->icoeffs, sum=offset, t=0; t < support; t++)

	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _offset$1$[ebp]
	mov	esi, DWORD PTR _width$[ebp]
	mov	DWORD PTR _sum$1$[ebp], ecx
	xor	ecx, ecx
	cmp	DWORD PTR _support$1$[ebp], 2
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR _fpp$1$[ebp], eax
	jl	SHORT $LC49@perform_an
	mov	esi, DWORD PTR _src_ptrs$[ebp]
	lea	edx, DWORD PTR [eax+4]
	mov	eax, esi
	sub	eax, DWORD PTR _fpp$1$[ebp]
	mov	DWORD PTR tv1227[ebp], eax
	mov	ebx, eax
$LL50@perform_an:

; 1307 :             sum += fpp[t] * (src_ptrs[t])[k].ival;

	mov	eax, DWORD PTR [esi+ecx*4]
	lea	edx, DWORD PTR [edx+8]
	mov	esi, DWORD PTR _src_ptrs$[ebp]
	add	ecx, 2
	movsx	eax, WORD PTR [eax+edi*2]
	imul	eax, DWORD PTR [edx-12]
	add	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR [ebx+edx-8]
	movsx	eax, WORD PTR [eax+edi*2]
	imul	eax, DWORD PTR [edx-8]
	add	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _support$1$[ebp]
	dec	eax
	cmp	ecx, eax
	jl	SHORT $LL50@perform_an
	mov	esi, DWORD PTR _width$[ebp]
	mov	ebx, DWORD PTR _in$1$[ebp]
	mov	edx, DWORD PTR _out$1$[ebp]
$LC49@perform_an:

; 1305 :         {
; 1306 :           for (fpp=step->icoeffs, sum=offset, t=0; t < support; t++)

	cmp	ecx, DWORD PTR _support$1$[ebp]
	jge	SHORT $LN48@perform_an

; 1307 :             sum += fpp[t] * (src_ptrs[t])[k].ival;

	mov	eax, DWORD PTR _src_ptrs$[ebp]
	mov	esi, DWORD PTR _fpp$1$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	movsx	eax, WORD PTR [eax+edi*2]
	imul	eax, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _offset$1$[ebp]
	mov	DWORD PTR _sum$1$[ebp], eax
$LN48@perform_an:

; 1304 :       for (k=x_off; k < width; k++)

	mov	eax, DWORD PTR $T2[ebp]
	lea	edx, DWORD PTR [edx+edi*2]
	add	eax, DWORD PTR $T1[ebp]
	inc	edi
	add	eax, DWORD PTR _sum$1$[ebp]

; 1308 :           out[k].ival = in[k].ival + (kdu_int16)(sum >> downshift);

	mov	ecx, DWORD PTR _downshift$1$[ebp]
	sar	eax, cl
	add	ax, WORD PTR [edx+ebx]
	mov	ecx, DWORD PTR _step$[ebp]
	mov	WORD PTR [edx], ax
	mov	edx, DWORD PTR _out$1$[ebp]
	cmp	edi, esi
	jl	$LL15@perform_an
$LN59@perform_an:
	pop	edi
	pop	ebx
$LN14@perform_an:
	pop	esi

; 1309 :         }
; 1310 :     }
; 1311 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?perform_analysis_lifting_step@@YAXPAUkd_lifting_step@@QAPATkdu_sample16@@PAT2@2HH@Z ENDP ; perform_analysis_lifting_step
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?simulate_access_source@kd_vlift_queue@@QAE_NHHAAH@Z
_TEXT	SEGMENT
_idx$2$ = 8						; size = 4
_idx$ = 8						; size = 4
_num$ = 12						; size = 4
_used_lines$ = 16					; size = 4
?simulate_access_source@kd_vlift_queue@@QAE_NHHAAH@Z PROC ; kd_vlift_queue::simulate_access_source, COMDAT
; _this$ = ecx

; 276  :       { /* Used in the simulation phase to discover buffer requirements.

	push	ebp
	mov	ebp, esp

; 277  :            `used_lines' represents the total number of lines which would
; 278  :            be allocated from the free list during real processing. */
; 279  :         assert((((idx ^ queue_idx) & 1) == 0) && (idx >= source_pos));
; 280  :         source_pos = idx; // At least this large

	mov	eax, DWORD PTR _idx$[ebp]
	mov	edx, ecx
	push	ebx

; 281  :         num--;  idx += num<<1; // Find index of last requested line; allows

	mov	ebx, DWORD PTR _num$[ebp]
	sub	ebx, 1
	push	esi
	push	edi
	mov	DWORD PTR [edx+24], eax
	lea	ecx, DWORD PTR [eax+ebx*2]
	mov	DWORD PTR _idx$2$[ebp], ecx

; 282  :                                // us to detect failure as early as possible
; 283  :         int k;
; 284  :         for (; num >= 0; idx-=2, num--)

	js	SHORT $LN3@simulate_a

; 287  :             while ((k < y_min) || (k > y_max))

	mov	esi, DWORD PTR [edx]
	mov	edi, DWORD PTR [edx+4]
$LL4@simulate_a:

; 285  :           {
; 286  :             k = idx;

	mov	eax, ecx
$LL5@simulate_a:

; 287  :             while ((k < y_min) || (k > y_max))

	cmp	eax, esi
	jl	SHORT $LN31@simulate_a
	cmp	eax, edi
	jle	SHORT $LN6@simulate_a

; 291  :                 k = (symmetric_extension)?(2*y_max-k):(y_max-((y_max^k)&1));

	cmp	BYTE PTR [edx+36], 0
	je	SHORT $LN17@simulate_a
	lea	ecx, DWORD PTR [edi+edi]
	sub	ecx, eax
	jmp	SHORT $LL4@simulate_a
$LN17@simulate_a:
	mov	ecx, edi
	xor	ecx, eax
	mov	eax, edi
	and	ecx, 1
	sub	eax, ecx
	jmp	SHORT $LL5@simulate_a
$LN31@simulate_a:

; 288  :               if (k < y_min)
; 289  :                 k = (symmetric_extension)?(2*y_min-k):(y_min+((y_min^k)&1));

	cmp	BYTE PTR [edx+36], 0
	je	SHORT $LN15@simulate_a
	lea	ecx, DWORD PTR [esi+esi]
	sub	ecx, eax
	jmp	SHORT $LL4@simulate_a
$LN15@simulate_a:
	xor	eax, esi
	and	eax, 1
	add	eax, esi

; 290  :               else

	jmp	SHORT $LL5@simulate_a
$LN6@simulate_a:

; 292  :             if ((k < head_idx) || (k > tail_idx)) return false;

	cmp	eax, DWORD PTR [edx+16]
	jl	SHORT $LN23@simulate_a
	cmp	eax, DWORD PTR [edx+20]
	jg	SHORT $LN23@simulate_a

; 282  :                                // us to detect failure as early as possible
; 283  :         int k;
; 284  :         for (; num >= 0; idx-=2, num--)

	mov	ecx, DWORD PTR _idx$2$[ebp]
	sub	ecx, 2
	sub	ebx, 1
	mov	DWORD PTR _idx$2$[ebp], ecx
	jns	SHORT $LL4@simulate_a
$LN3@simulate_a:

; 293  :           }
; 294  :         source_pos += 2; // Advance `source_pos' when successful

	add	DWORD PTR [edx+24], 2

; 295  :         while ((head_idx < update_pos) && (head_idx < source_pos) &&
; 296  :                (tail_idx >= head_idx) && (head_idx < recycling_lim))

	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [edx+28]
	jge	SHORT $LN38@simulate_a
	mov	ecx, DWORD PTR _used_lines$[ebp]
$LL7@simulate_a:
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $LN38@simulate_a
	cmp	DWORD PTR [edx+20], eax
	jl	SHORT $LN38@simulate_a
	cmp	eax, DWORD PTR [edx+32]
	jge	SHORT $LN38@simulate_a

; 297  :           { head_idx+=2; used_lines--; }

	add	eax, 2
	mov	DWORD PTR [edx+16], eax
	dec	DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [edx+28]
	jl	SHORT $LL7@simulate_a
$LN38@simulate_a:
	pop	edi
	pop	esi

; 298  :         return true;

	mov	al, 1
	pop	ebx

; 299  :       }

	pop	ebp
	ret	12					; 0000000cH
$LN23@simulate_a:
	pop	edi
	pop	esi

; 292  :             if ((k < head_idx) || (k > tail_idx)) return false;

	xor	al, al
	pop	ebx

; 299  :       }

	pop	ebp
	ret	12					; 0000000cH
?simulate_access_source@kd_vlift_queue@@QAE_NHHAAH@Z ENDP ; kd_vlift_queue::simulate_access_source
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?simulate_access_update@kd_vlift_queue@@QAE_NHAAH@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_used_lines$ = 12					; size = 4
?simulate_access_update@kd_vlift_queue@@QAE_NHAAH@Z PROC ; kd_vlift_queue::simulate_access_update, COMDAT
; _this$ = ecx

; 261  :       { /* Used in the simulation phase to discover buffer requirements.

	push	ebp
	mov	ebp, esp

; 262  :            Returns false if `access_update' would have returned NULL.
; 263  :            `used_lines' represents the total number of lines which would be
; 264  :            allocated from the free list during real processing. */
; 265  :         assert((((idx ^ queue_idx) & 1) == 0) && (idx >= update_pos));
; 266  :         update_pos = idx; // At least this large

	mov	eax, DWORD PTR _idx$[ebp]

; 267  :         if ((idx < head_idx) || (idx > tail_idx))

	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx+28], eax
	cmp	eax, edx
	jl	SHORT $LN5@simulate_a
	cmp	eax, DWORD PTR [ecx+20]
	jg	SHORT $LN5@simulate_a

; 269  :         update_pos += 2;

	add	eax, 2
	mov	DWORD PTR [ecx+28], eax

; 270  :         while ((head_idx < update_pos) && (head_idx < source_pos) &&
; 271  :                (tail_idx >= head_idx) && (head_idx < recycling_lim))

	cmp	edx, eax
	jge	SHORT $LN3@simulate_a
	mov	edx, DWORD PTR _used_lines$[ebp]
$LL2@simulate_a:
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [ecx+24]
	jge	SHORT $LN3@simulate_a
	cmp	DWORD PTR [ecx+20], eax
	jl	SHORT $LN3@simulate_a
	cmp	eax, DWORD PTR [ecx+32]
	jge	SHORT $LN3@simulate_a

; 272  :           { head_idx+=2; used_lines--; }

	add	eax, 2
	mov	DWORD PTR [ecx+16], eax
	dec	DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [ecx+28]
	jl	SHORT $LL2@simulate_a
$LN3@simulate_a:

; 273  :         return true;

	mov	al, 1

; 274  :       }

	pop	ebp
	ret	8
$LN5@simulate_a:

; 268  :           return false;

	xor	al, al

; 274  :       }

	pop	ebp
	ret	8
?simulate_access_update@kd_vlift_queue@@QAE_NHAAH@Z ENDP ; kd_vlift_queue::simulate_access_update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?simulate_push_line@kd_vlift_queue@@QAEXHAAH@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_used_lines$ = 12					; size = 4
?simulate_push_line@kd_vlift_queue@@QAEXHAAH@Z PROC	; kd_vlift_queue::simulate_push_line, COMDAT
; _this$ = ecx

; 250  :       { /* Used in the simulation phase to discover buffer requirements. */

	push	ebp
	mov	ebp, esp

; 251  :         assert(((idx ^ queue_idx) & 1) == 0);
; 252  :         if ((idx < source_pos) && (idx < update_pos))

	mov	edx, DWORD PTR _idx$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $LN2@simulate_p
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN2@simulate_p

; 253  :           { // Recycle line immediatel.  It will never contribute.
; 254  :             used_lines--;  return;

	mov	eax, DWORD PTR _used_lines$[ebp]
	dec	DWORD PTR [eax]

; 259  :       }

	pop	ebp
	ret	8
$LN2@simulate_p:

; 255  :           }
; 256  :         if (tail_idx < head_idx)

	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR [ecx+16]
	jge	SHORT $LN3@simulate_p

; 257  :           head_idx = idx;

	mov	DWORD PTR [ecx+16], edx
$LN3@simulate_p:

; 258  :         tail_idx = idx;

	mov	DWORD PTR [ecx+20], edx

; 259  :       }

	pop	ebp
	ret	8
?simulate_push_line@kd_vlift_queue@@QAEXHAAH@Z ENDP	; kd_vlift_queue::simulate_push_line
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?access_source@kd_vlift_queue@@QAE_NHHQAPAUkd_vlift_line@@AAPAU2@@Z
_TEXT	SEGMENT
_idx$2$ = 8						; size = 4
_idx$ = 8						; size = 4
_num$ = 12						; size = 4
_lines$ = 16						; size = 4
_free_list$ = 20					; size = 4
?access_source@kd_vlift_queue@@QAE_NHHQAPAUkd_vlift_line@@AAPAU2@@Z PROC ; kd_vlift_queue::access_source, COMDAT
; _this$ = ecx

; 208  :       { /* Use this function to access the source lines for lifting step

	push	ebp
	mov	ebp, esp

; 209  :            `queue_idx'.  The number of required lines is given by `num'
; 210  :            and the location of the first line is given by `idx'.  The function
; 211  :            returns false if one or more of the requested lines is unavailable.
; 212  :            Otherwise, it returns true and also advances the internal
; 213  :            `source_pos' pointer to `idx'+2.  You may not invoke this
; 214  :            function for the queue whose `queue_index' value is -1.
; 215  :               Perhaps the most important feature of this function is that
; 216  :            it implements the boundary extension policy automatically.  This
; 217  :            means that the range of requested lines can lie outside the range
; 218  :            of actual available lines. */
; 219  :         assert((((idx ^ queue_idx) & 1) == 0) && (idx >= source_pos));
; 220  :         source_pos = idx; // At least this large

	mov	eax, DWORD PTR _idx$[ebp]
	mov	edx, ecx

; 221  :         num--;  idx += num<<1; // Find index of last requested line; allows

	mov	ecx, DWORD PTR _num$[ebp]
	dec	ecx
	push	esi
	mov	DWORD PTR [edx+24], eax
	mov	DWORD PTR _num$[ebp], ecx
	lea	esi, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR _idx$2$[ebp], esi

; 222  :                               // us to detect failure as early as possible
; 223  :         if ((idx > tail_idx) && (idx <= y_max))

	cmp	esi, DWORD PTR [edx+20]
	jle	SHORT $LN12@access_sou
	cmp	esi, DWORD PTR [edx+4]
	jg	SHORT $LN12@access_sou

; 224  :           return false; // Almost all failures are detected here, in practice

	xor	al, al
	pop	esi

; 246  :       }

	pop	ebp
	ret	16					; 00000010H
$LN12@access_sou:

; 225  :         int k;
; 226  :         for (lines+=num; num >= 0; idx-=2, num--, lines--)

	mov	eax, DWORD PTR _lines$[ebp]
	push	ebx
	push	edi
	lea	ebx, DWORD PTR [eax+ecx*4]
	test	ecx, ecx
	js	$LN3@access_sou
	npad	6
$LL4@access_sou:

; 227  :           {
; 228  :             k = idx;
; 229  :             while ((k < y_min) || (k > y_max))

	mov	edi, DWORD PTR [edx+4]
	mov	eax, esi
	mov	esi, DWORD PTR [edx]
$LL5@access_sou:
	cmp	eax, esi
	jl	SHORT $LN39@access_sou
	cmp	eax, edi
	jle	SHORT $LN6@access_sou

; 233  :                 k = (symmetric_extension)?(2*y_max-k):(y_max-((y_max^k)&1));

	cmp	BYTE PTR [edx+36], 0
	je	SHORT $LN22@access_sou
	lea	ecx, DWORD PTR [edi+edi]
	sub	ecx, eax
	mov	eax, ecx
	jmp	SHORT $LL5@access_sou
$LN22@access_sou:
	mov	ecx, edi
	xor	ecx, eax
	mov	eax, edi
	and	ecx, 1
	sub	eax, ecx
	jmp	SHORT $LL5@access_sou
$LN39@access_sou:

; 230  :               if (k < y_min)
; 231  :                 k = (symmetric_extension)?(2*y_min-k):(y_min+((y_min^k)&1));

	cmp	BYTE PTR [edx+36], 0
	je	SHORT $LN20@access_sou
	lea	ecx, DWORD PTR [esi+esi]
	sub	ecx, eax
	mov	eax, ecx
	jmp	SHORT $LL5@access_sou
$LN20@access_sou:
	xor	eax, esi
	and	eax, 1
	add	eax, esi

; 232  :               else

	jmp	SHORT $LL5@access_sou
$LN6@access_sou:

; 234  :             if ((k < head_idx) || (k > tail_idx)) return false;

	cmp	eax, DWORD PTR [edx+16]
	jl	$LN29@access_sou
	cmp	eax, DWORD PTR [edx+20]
	jg	$LN29@access_sou

; 235  :             for (*lines=head; k > head_idx; k-=2, *lines=(*lines)->next);

	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [ebx], ecx
	cmp	eax, DWORD PTR [edx+16]
	jle	SHORT $LN2@access_sou
	npad	1
$LL9@access_sou:
	mov	ecx, DWORD PTR [ebx]
	sub	eax, 2
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [ebx], ecx
	cmp	eax, DWORD PTR [edx+16]
	jg	SHORT $LL9@access_sou
$LN2@access_sou:

; 225  :         int k;
; 226  :         for (lines+=num; num >= 0; idx-=2, num--, lines--)

	mov	ecx, DWORD PTR _num$[ebp]
	sub	ebx, 4
	mov	esi, DWORD PTR _idx$2$[ebp]
	dec	ecx
	sub	esi, 2
	mov	DWORD PTR _num$[ebp], ecx
	mov	DWORD PTR _idx$2$[ebp], esi
	test	ecx, ecx
	jns	$LL4@access_sou
$LN3@access_sou:

; 236  :           }
; 237  :         source_pos += 2; // Advance `source_pos' when successful

	add	DWORD PTR [edx+24], 2

; 238  :         while ((head_idx < update_pos) && (head_idx < source_pos) &&
; 239  :                (head != NULL) && (head_idx < recycling_lim))

	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [edx+28]
	jge	SHORT $LN46@access_sou
	mov	edi, DWORD PTR _free_list$[ebp]
	npad	7
$LL10@access_sou:
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $LN46@access_sou
	mov	esi, DWORD PTR [edx+8]
	test	esi, esi
	je	SHORT $LN46@access_sou
	cmp	eax, DWORD PTR [edx+32]
	jge	SHORT $LN46@access_sou

; 240  :           {
; 241  :             head_idx+=2;  kd_vlift_line *new_head = head->next;

	add	eax, 2
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [esi+24]

; 242  :             head->next = free_list;  free_list = head;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [edi], eax

; 243  :             if ((head = new_head) == NULL) tail = NULL;

	mov	DWORD PTR [edx+8], ecx
	test	ecx, ecx
	jne	SHORT $LN18@access_sou
	mov	DWORD PTR [edx+12], ecx
$LN18@access_sou:

; 238  :         while ((head_idx < update_pos) && (head_idx < source_pos) &&
; 239  :                (head != NULL) && (head_idx < recycling_lim))

	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR [edx+28]
	jl	SHORT $LL10@access_sou
$LN46@access_sou:
	pop	edi
	pop	ebx

; 244  :           }
; 245  :         return true;

	mov	al, 1
	pop	esi

; 246  :       }

	pop	ebp
	ret	16					; 00000010H
$LN29@access_sou:
	pop	edi
	pop	ebx

; 234  :             if ((k < head_idx) || (k > tail_idx)) return false;

	xor	al, al
	pop	esi

; 246  :       }

	pop	ebp
	ret	16					; 00000010H
?access_source@kd_vlift_queue@@QAE_NHHQAPAUkd_vlift_line@@AAPAU2@@Z ENDP ; kd_vlift_queue::access_source
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?access_update@kd_vlift_queue@@QAEPAUkd_vlift_line@@HAAPAU2@@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_free_list$ = 12					; size = 4
?access_update@kd_vlift_queue@@QAEPAUkd_vlift_line@@HAAPAU2@@Z PROC ; kd_vlift_queue::access_update, COMDAT
; _this$ = ecx

; 185  :       { /* Use this function to access the next line which needs to be

	push	ebp
	mov	ebp, esp

; 186  :            updated by lifting step `queue_idx'+1.   The index of the line
; 187  :            is given by `idx', which must have the same parity as `queue_idx'.
; 188  :            If the function succeeds, it advances its internal record of the
; 189  :            next line to be accessed in subsequent calls. */
; 190  :         assert((((idx ^ queue_idx) & 1) == 0) && (idx >= update_pos));
; 191  :         update_pos = idx; // At least this large

	mov	edx, DWORD PTR _idx$[ebp]
	push	esi

; 192  :         if ((idx < head_idx) || (idx > tail_idx))

	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx+28], edx
	cmp	edx, esi
	jl	SHORT $LN8@access_upd
	cmp	edx, DWORD PTR [ecx+20]
	jg	SHORT $LN8@access_upd

; 194  :         kd_vlift_line *result = head;

	push	edi
	mov	edi, DWORD PTR [ecx+8]

; 195  :         for (; idx > head_idx; idx-=2, result=result->next);

	cmp	edx, esi
	jle	SHORT $LN3@access_upd

; 194  :         kd_vlift_line *result = head;

	mov	eax, edx
	sub	eax, esi
	dec	eax
	shr	eax, 1
	inc	eax
$LL4@access_upd:

; 195  :         for (; idx > head_idx; idx-=2, result=result->next);

	mov	edi, DWORD PTR [edi+24]
	sub	eax, 1
	jne	SHORT $LL4@access_upd
$LN3@access_upd:

; 196  :         assert(result != NULL);
; 197  :         update_pos += 2;

	lea	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+28], eax

; 198  :         while ((head_idx < source_pos) && (head_idx < update_pos) &&
; 199  :                (head != NULL) && (head_idx < recycling_lim))

	cmp	esi, DWORD PTR [ecx+24]
	jge	SHORT $LN18@access_upd
	push	ebx
	mov	ebx, DWORD PTR _free_list$[ebp]
	npad	3
$LL5@access_upd:
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [ecx+28]
	jge	SHORT $LN19@access_upd
	mov	esi, DWORD PTR [ecx+8]
	test	esi, esi
	je	SHORT $LN19@access_upd
	cmp	eax, DWORD PTR [ecx+32]
	jge	SHORT $LN19@access_upd

; 200  :           { head_idx+=2;  kd_vlift_line *new_head = head->next;

	add	eax, 2
	mov	DWORD PTR [ecx+16], eax
	mov	edx, DWORD PTR [esi+24]

; 201  :             head->next = free_list;  free_list = head;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ebx], eax

; 202  :             if ((head = new_head) == NULL) tail = NULL;

	mov	DWORD PTR [ecx+8], edx
	test	edx, edx
	jne	SHORT $LN9@access_upd
	mov	DWORD PTR [ecx+12], edx
$LN9@access_upd:

; 198  :         while ((head_idx < source_pos) && (head_idx < update_pos) &&
; 199  :                (head != NULL) && (head_idx < recycling_lim))

	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR [ecx+24]
	jl	SHORT $LL5@access_upd
$LN19@access_upd:
	pop	ebx
$LN18@access_upd:

; 203  :           }
; 204  :         return result;

	mov	eax, edi
	pop	edi
	pop	esi

; 205  :       }

	pop	ebp
	ret	8
$LN8@access_upd:

; 193  :           return NULL;

	xor	eax, eax
	pop	esi

; 205  :       }

	pop	ebp
	ret	8
?access_update@kd_vlift_queue@@QAEPAUkd_vlift_line@@HAAPAU2@@Z ENDP ; kd_vlift_queue::access_update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?test_update@kd_vlift_queue@@QAE_NH_N@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_need_exclusive_use$ = 12				; size = 1
?test_update@kd_vlift_queue@@QAE_NH_N@Z PROC		; kd_vlift_queue::test_update, COMDAT
; _this$ = ecx

; 170  :       { /* Returns true if the line identified by `idx' is currently available.

	push	ebp
	mov	ebp, esp

; 171  :            Also sets the `update_pos' member equal to `idx' to make it clear
; 172  :            that no calls to `access_update' will attempt to access earlier
; 173  :            rows than this.  If `need_exclusive_use' is true and the
; 174  :            line identified by `idx' might be required by future calls to
; 175  :            `access_source', the function returns false.  For this function
; 176  :            to work correctly in conjunction with the `need_exclusive_use'
; 177  :            option, you must remember to call `source_done' once you have
; 178  :            finished all calls to `access_source'. */
; 179  :         update_pos = idx;

	mov	eax, DWORD PTR _idx$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 180  :         return ((idx >= head_idx) && (idx <= tail_idx) &&

	cmp	eax, DWORD PTR [ecx+16]
	jl	SHORT $LN3@test_updat
	cmp	eax, DWORD PTR [ecx+20]
	jg	SHORT $LN3@test_updat
	cmp	BYTE PTR _need_exclusive_use$[ebp], 0
	je	SHORT $LN5@test_updat
	cmp	eax, DWORD PTR [ecx+24]
	jge	SHORT $LN3@test_updat
	cmp	eax, DWORD PTR [ecx+32]
	jge	SHORT $LN3@test_updat
$LN5@test_updat:
	mov	al, 1

; 181  :                 ((!need_exclusive_use) ||
; 182  :                  ((idx < source_pos) && (idx < recycling_lim))));
; 183  :       }

	pop	ebp
	ret	8
$LN3@test_updat:

; 180  :         return ((idx >= head_idx) && (idx <= tail_idx) &&

	xor	al, al

; 181  :                 ((!need_exclusive_use) ||
; 182  :                  ((idx < source_pos) && (idx < recycling_lim))));
; 183  :       }

	pop	ebp
	ret	8
?test_update@kd_vlift_queue@@QAE_NH_N@Z ENDP		; kd_vlift_queue::test_update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?push_line@kd_vlift_queue@@QAEXHPAUkd_vlift_line@@AAPAU2@@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_line$ = 12						; size = 4
_free_list$ = 16					; size = 4
?push_line@kd_vlift_queue@@QAEXHPAUkd_vlift_line@@AAPAU2@@Z PROC ; kd_vlift_queue::push_line, COMDAT
; _this$ = ecx

; 150  :       { /* Used to push new lines into the queue.  The `idx' argument is

	push	ebp
	mov	ebp, esp

; 151  :            the absolute location of this line.  It must have the same
; 152  :            parity (LSB) as the `queue_idx' identifier for this queue. */
; 153  :         assert(((idx ^ queue_idx) & 1) == 0);
; 154  :         if ((idx < source_pos) && (idx < update_pos))

	mov	edx, DWORD PTR _idx$[ebp]
	push	esi
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $LN4@push_line
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN4@push_line

; 155  :           { // Recycle line immediately; it will never contribute.  Also
; 156  :             // recycle any existing lines on the queue.
; 157  :             line->next = free_list;  free_list = line;

	mov	esi, DWORD PTR _free_list$[ebp]
	mov	edx, DWORD PTR _line$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+24], eax
	mov	DWORD PTR [esi], edx

; 158  :             while ((tail=head) != NULL)

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+12], eax
	test	eax, eax
	je	SHORT $LN1@push_line
	npad	8
$LL2@push_line:

; 159  :               { head=tail->next;  tail->next=free_list;  free_list=tail; }

	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+24], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+12], eax
	test	eax, eax
	jne	SHORT $LL2@push_line
	pop	esi

; 168  :       }

	pop	ebp
	ret	12					; 0000000cH
$LN4@push_line:

; 160  :             return;
; 161  :           }
; 162  :         line->next = NULL;

	mov	eax, DWORD PTR _line$[ebp]
	mov	DWORD PTR [eax+24], 0

; 163  :         if (tail == NULL)

	mov	esi, DWORD PTR [ecx+12]
	test	esi, esi
	jne	SHORT $LN5@push_line

; 164  :           { head = tail = line;  head_idx = idx;  }

	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+16], edx

; 165  :         else
; 166  :           { assert(idx == (tail_idx+2));  tail = tail->next = line; }

	mov	DWORD PTR [ecx+12], eax

; 167  :         tail_idx = idx;

	mov	DWORD PTR [ecx+20], edx
	pop	esi

; 168  :       }

	pop	ebp
	ret	12					; 0000000cH
$LN5@push_line:

; 165  :         else
; 166  :           { assert(idx == (tail_idx+2));  tail = tail->next = line; }

	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [ecx+12], eax

; 167  :         tail_idx = idx;

	mov	DWORD PTR [ecx+20], edx
$LN1@push_line:
	pop	esi

; 168  :       }

	pop	ebp
	ret	12					; 0000000cH
?push_line@kd_vlift_queue@@QAEXHPAUkd_vlift_line@@AAPAU2@@Z ENDP ; kd_vlift_queue::push_line
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?source_done@kd_vlift_queue@@QAEXXZ
_TEXT	SEGMENT
?source_done@kd_vlift_queue@@QAEXXZ PROC		; kd_vlift_queue::source_done, COMDAT
; _this$ = ecx

; 141  :            to `access_source'.  This sets `recycling_lim' and `source_pos'
; 142  :            both beyond the value of `y_max' so that they no longer influence
; 143  :            the behaviour of the stripe recycling machinery or the conditions
; 144  :            under which `test_update' will return true. */
; 145  :         source_pos = recycling_lim = y_max + 2;

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 2
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+24], eax

; 146  :           // We won't bother trying to recycle stripes here, since this should
; 147  :           // happen soon enough on the next call to `access_update'.
; 148  :       }

	ret	0
?source_done@kd_vlift_queue@@QAEXXZ ENDP		; kd_vlift_queue::source_done
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?init@kd_vlift_queue@@QAEXHHH_NH@Z
_TEXT	SEGMENT
_y_min$ = 8						; size = 4
_y_max$ = 12						; size = 4
_queue_idx$ = 16					; size = 4
_symmetric_extension$ = 20				; size = 1
_max_source_request_idx$ = 24				; size = 4
?init@kd_vlift_queue@@QAEXHHH_NH@Z PROC			; kd_vlift_queue::init, COMDAT
; _this$ = ecx

; 118  :       { /* For the interpretation of most of the arguments, see the notes

	push	ebp
	mov	ebp, esp

; 119  :            below, describe the member variables with the same names.
; 120  :            The `max_source_request_idx' argument identifies the location of
; 121  :            the last line which will ever be requested via `access_source'.
; 122  :            This is used to determine the `recycling_lim' value. */
; 123  :         assert(((max_source_request_idx ^ queue_idx) & 1) == 0);
; 124  :         this->queue_idx = (kdu_byte) queue_idx;
; 125  :         this->y_min = y_min;  this->y_max = y_max;

	mov	eax, DWORD PTR _y_min$[ebp]
	mov	edx, DWORD PTR _y_max$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _queue_idx$[ebp]
	push	esi

; 126  :         head_idx = source_pos = update_pos = y_min - 1000; // Ridiculous value

	lea	esi, DWORD PTR [eax-1000]
	mov	DWORD PTR [ecx], eax

; 127  :         this->symmetric_extension = symmetric_extension;

	mov	al, BYTE PTR _symmetric_extension$[ebp]
	mov	BYTE PTR [ecx+37], bl
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+28], esi
	mov	DWORD PTR [ecx+24], esi
	mov	DWORD PTR [ecx+16], esi
	mov	BYTE PTR [ecx+36], al

; 128  :         if ((!symmetric_extension) || (max_source_request_idx < y_max))

	test	al, al
	je	SHORT $LN4@init
	cmp	DWORD PTR _max_source_request_idx$[ebp], edx
	jl	SHORT $LN4@init

; 130  :         else
; 131  :           recycling_lim = 2*y_max - max_source_request_idx;

	lea	eax, DWORD PTR [edx+edx]
	sub	eax, DWORD PTR _max_source_request_idx$[ebp]
	jmp	SHORT $LN7@init
$LN4@init:

; 129  :           recycling_lim = y_max - 1; // Keep last row only

	lea	eax, DWORD PTR [edx-1]
$LN7@init:
	mov	DWORD PTR [ecx+32], eax

; 132  :         if (queue_idx < 0)

	test	ebx, ebx
	jns	SHORT $LN5@init

; 133  :           source_pos = recycling_lim = y_max+2; // Block use of `access_source'

	lea	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+32], eax
	mov	DWORD PTR [ecx+24], eax
$LN5@init:

; 134  :         tail_idx = head_idx - 2;

	lea	eax, DWORD PTR [esi-2]

; 135  :         head = tail = NULL;

	mov	DWORD PTR [ecx+12], 0
	pop	esi
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+8], 0
	pop	ebx

; 136  :       }

	pop	ebp
	ret	20					; 00000014H
?init@kd_vlift_queue@@QAEXHHH_NH@Z ENDP			; kd_vlift_queue::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??0kd_vlift_line@@QAE@XZ
_TEXT	SEGMENT
??0kd_vlift_line@@QAE@XZ PROC				; kd_vlift_line::kd_vlift_line, COMDAT
; _this$ = ecx

; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	WORD PTR [ecx+6], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	WORD PTR [ecx+18], 0
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0kd_vlift_line@@QAE@XZ ENDP				; kd_vlift_line::kd_vlift_line
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?create@kd_vlift_line@@QAEXXZ
_TEXT	SEGMENT
?create@kd_vlift_line@@QAEXXZ PROC			; kd_vlift_line::create, COMDAT
; _this$ = ecx

; 82   :       { cosets[0].create(); cosets[1].create(); }

	push	esi
	mov	esi, ecx
	call	?create@kdu_line_buf@@QAEXXZ		; kdu_line_buf::create
	lea	ecx, DWORD PTR [esi+12]
	pop	esi
	jmp	?create@kdu_line_buf@@QAEXXZ		; kdu_line_buf::create
?create@kd_vlift_line@@QAEXXZ ENDP			; kd_vlift_line::create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\transform_local.h
;	COMDAT ?pre_create@kd_vlift_line@@QAEXPAVkdu_sample_allocator@@HH_N1HH1@Z
_TEXT	SEGMENT
_allocator$ = 8						; size = 4
_even_width$ = 12					; size = 4
_odd_width$ = 16					; size = 4
_absolute$ = 20						; size = 1
_use_shorts$ = 24					; size = 1
_neg_extent$ = 28					; size = 4
_pos_extent$ = 32					; size = 4
_both_cosets$ = 36					; size = 1
?pre_create@kd_vlift_line@@QAEXPAVkdu_sample_allocator@@HH_N1HH1@Z PROC ; kd_vlift_line::pre_create, COMDAT
; _this$ = ecx

; 74   :       {

	push	ebp
	mov	ebp, esp

; 75   :         cosets[0].pre_create(allocator,even_width,absolute,use_shorts,

	mov	edx, DWORD PTR _even_width$[ebp]
	push	esi
	mov	esi, DWORD PTR _pos_extent$[ebp]
	mov	eax, esi
	push	edi
	sub	eax, edx
	mov	edi, ecx
	push	eax
	push	DWORD PTR _neg_extent$[ebp]
	push	DWORD PTR _use_shorts$[ebp]
	push	DWORD PTR _absolute$[ebp]
	push	edx
	push	DWORD PTR _allocator$[ebp]
	call	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create

; 76   :                              neg_extent,pos_extent-even_width);
; 77   :         if (both_cosets)

	cmp	BYTE PTR _both_cosets$[ebp], 0
	je	SHORT $LN2@pre_create

; 78   :           cosets[1].pre_create(allocator,odd_width,absolute,use_shorts,

	mov	eax, DWORD PTR _odd_width$[ebp]
	lea	ecx, DWORD PTR [edi+12]
	sub	esi, eax
	push	esi
	push	DWORD PTR _neg_extent$[ebp]
	push	DWORD PTR _use_shorts$[ebp]
	push	DWORD PTR _absolute$[ebp]
	push	eax
	push	DWORD PTR _allocator$[ebp]
	call	?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ; kdu_line_buf::pre_create
$LN2@pre_create:
	pop	edi
	pop	esi

; 79   :                                neg_extent,pos_extent-odd_width);
; 80   :       }

	pop	ebp
	ret	32					; 00000020H
?pre_create@kd_vlift_line@@QAEXPAVkdu_sample_allocator@@HH_N1HH1@Z ENDP ; kd_vlift_line::pre_create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
;	COMDAT ??0kdu_analysis@@QAE@Vkdu_resolution@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
$T2 = -4						; size = 4
_resolution$ = 8					; size = 4
_allocator$ = 12					; size = 4
_use_shorts$ = 16					; size = 1
_normalization$ = 20					; size = 4
_roi$ = 24						; size = 4
_env$ = 28						; size = 4
_env_queue$ = 32					; size = 4
??0kdu_analysis@@QAE@Vkdu_resolution@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z PROC ; kdu_analysis::kdu_analysis, COMDAT
; _this$ = ecx

; 125  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 126  :   kd_analysis *obj = new kd_analysis;

	push	704					; 000002c0H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 598  :     kdu_push_ifc() { state = NULL; }

	mov	DWORD PTR [edi], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 126  :   kd_analysis *obj = new kd_analysis;

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	test	eax, eax
	je	SHORT $LN3@kdu_analys
	mov	ecx, eax
	call	??0kd_analysis@@QAE@XZ			; kd_analysis::kd_analysis
	mov	esi, eax
	jmp	SHORT $LN4@kdu_analys
$LN3@kdu_analys:
	xor	esi, esi
$LN4@kdu_analys:

; 127  :   state = obj;
; 128  :   obj->init(resolution.access_node(),allocator,use_shorts,

	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edi], esi
	push	eax
	lea	ecx, DWORD PTR _resolution$[ebp]
	call	?access_node@kdu_resolution@@QAE?AVkdu_node@@XZ ; kdu_resolution::access_node
	push	DWORD PTR _env_queue$[ebp]
	movss	xmm0, DWORD PTR _normalization$[ebp]
	push	DWORD PTR _env$[ebp]
	push	DWORD PTR _roi$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, esi
	push	DWORD PTR _use_shorts$[ebp]
	push	DWORD PTR _allocator$[ebp]
	push	DWORD PTR [eax]
	call	?init@kd_analysis@@QAEXVkdu_node@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kd_analysis::init

; 129  :             normalization,roi,env,env_queue);
; 130  : }

	mov	eax, edi
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
??0kdu_analysis@@QAE@Vkdu_resolution@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ENDP ; kdu_analysis::kdu_analysis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
;	COMDAT ??0kdu_analysis@@QAE@Vkdu_node@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_node$ = 8						; size = 4
_allocator$ = 12					; size = 4
_use_shorts$ = 16					; size = 1
_normalization$ = 20					; size = 4
_roi$ = 24						; size = 4
_env$ = 28						; size = 4
_env_queue$ = 32					; size = 4
??0kdu_analysis@@QAE@Vkdu_node@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z PROC ; kdu_analysis::kdu_analysis, COMDAT
; _this$ = ecx

; 110  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 111  :   kd_analysis *obj = new kd_analysis;

	push	704					; 000002c0H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h

; 598  :     kdu_push_ifc() { state = NULL; }

	mov	DWORD PTR [esi], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp

; 111  :   kd_analysis *obj = new kd_analysis;

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN3@kdu_analys
	mov	ecx, eax
	call	??0kd_analysis@@QAE@XZ			; kd_analysis::kd_analysis
	jmp	SHORT $LN4@kdu_analys
$LN3@kdu_analys:
	xor	eax, eax
$LN4@kdu_analys:

; 112  :   state = obj;
; 113  :   obj->init(node,allocator,use_shorts,normalization,roi,env,env_queue);

	push	DWORD PTR _env_queue$[ebp]
	movss	xmm0, DWORD PTR _normalization$[ebp]
	push	DWORD PTR _env$[ebp]
	mov	DWORD PTR [esi], eax
	push	DWORD PTR _roi$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, eax
	push	DWORD PTR _use_shorts$[ebp]
	push	DWORD PTR _allocator$[ebp]
	push	DWORD PTR _node$[ebp]
	call	?init@kd_analysis@@QAEXVkdu_node@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ; kd_analysis::init

; 114  : }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
??0kdu_analysis@@QAE@Vkdu_node@@PAVkdu_sample_allocator@@_NMPAVkdu_roi_node@@PAVkdu_thread_env@@PAUkdu_thread_queue@@@Z ENDP ; kdu_analysis::kdu_analysis
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?push@kdu_push_ifc@@QAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_line$ = 8						; size = 4
_env$ = 12						; size = 4
?push@kdu_push_ifc@@QAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z PROC ; kdu_push_ifc::push, COMDAT
; _this$ = ecx

; 641  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 642  :              Delivers all samples from the `line' buffer across the interface.
; 643  :            [ARG: env]
; 644  :              If the object was constructed for multi-threaded processing
; 645  :              (see the constructors for `kdu_analysis' and `kdu_encoder'),
; 646  :              you MUST pass a non-NULL `env' argument in here, identifying
; 647  :              the thread which is performing the `push' call.  Otherwise,
; 648  :              the `env' argument should be ignored.
; 649  :         */
; 650  :         state->push(line,env);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]

; 651  :       }

	pop	ebp

; 642  :              Delivers all samples from the `line' buffer across the interface.
; 643  :            [ARG: env]
; 644  :              If the object was constructed for multi-threaded processing
; 645  :              (see the constructors for `kdu_analysis' and `kdu_encoder'),
; 646  :              you MUST pass a non-NULL `env' argument in here, identifying
; 647  :              the thread which is performing the `push' call.  Otherwise,
; 648  :              the `env' argument should be ignored.
; 649  :         */
; 650  :         state->push(line,env);

	jmp	DWORD PTR [eax+4]
?push@kdu_push_ifc@@QAEXAAVkdu_line_buf@@PAVkdu_thread_env@@@Z ENDP ; kdu_push_ifc::push
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??4kdu_push_ifc@@QAEAAV0@Vkdu_encoder@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4kdu_push_ifc@@QAEAAV0@Vkdu_encoder@@@Z PROC		; kdu_push_ifc::operator=, COMDAT
; _this$ = ecx

; 2050 :   { state = rhs.state; return *this; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4kdu_push_ifc@@QAEAAV0@Vkdu_encoder@@@Z ENDP		; kdu_push_ifc::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??4kdu_push_ifc@@QAEAAV0@Vkdu_analysis@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4kdu_push_ifc@@QAEAAV0@Vkdu_analysis@@@Z PROC		; kdu_push_ifc::operator=, COMDAT
; _this$ = ecx

; 2048 :   { state = rhs.state; return *this; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4kdu_push_ifc@@QAEAAV0@Vkdu_analysis@@@Z ENDP		; kdu_push_ifc::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?exists@kdu_push_ifc@@QAE_NXZ
_TEXT	SEGMENT
?exists@kdu_push_ifc@@QAE_NXZ PROC			; kdu_push_ifc::exists, COMDAT
; _this$ = ecx

; 616  :     bool exists() { return (state==NULL)?false:true; }

	cmp	DWORD PTR [ecx], 0
	setne	al
	ret	0
?exists@kdu_push_ifc@@QAE_NXZ ENDP			; kdu_push_ifc::exists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?destroy@kdu_push_ifc@@QAEXXZ
_TEXT	SEGMENT
?destroy@kdu_push_ifc@@QAEXXZ PROC			; kdu_push_ifc::destroy, COMDAT
; _this$ = ecx

; 605  :       {

	push	esi
	mov	esi, ecx

; 606  :         if (state != NULL) delete state;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@destroy
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN6@destroy:

; 607  :         state = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 608  :       }

	ret	0
?destroy@kdu_push_ifc@@QAEXXZ ENDP			; kdu_push_ifc::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??0kdu_push_ifc@@QAE@XZ
_TEXT	SEGMENT
??0kdu_push_ifc@@QAE@XZ PROC				; kdu_push_ifc::kdu_push_ifc, COMDAT
; _this$ = ecx

; 598  :     kdu_push_ifc() { state = NULL; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0kdu_push_ifc@@QAE@XZ ENDP				; kdu_push_ifc::kdu_push_ifc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??_Gkdu_push_ifc_base@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkdu_push_ifc_base@@MAEPAXI@Z PROC			; kdu_push_ifc_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 572  :     virtual ~kdu_push_ifc_base() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_push_ifc_base@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkdu_push_ifc_base@@MAEPAXI@Z ENDP			; kdu_push_ifc_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0kdu_push_ifc_base@@QAE@XZ
_TEXT	SEGMENT
??0kdu_push_ifc_base@@QAE@XZ PROC			; kdu_push_ifc_base::kdu_push_ifc_base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kdu_push_ifc_base@@6B@
	mov	eax, ecx
	ret	0
??0kdu_push_ifc_base@@QAE@XZ ENDP			; kdu_push_ifc_base::kdu_push_ifc_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??1kdu_push_ifc_base@@MAE@XZ
_TEXT	SEGMENT
??1kdu_push_ifc_base@@MAE@XZ PROC			; kdu_push_ifc_base::~kdu_push_ifc_base, COMDAT
; _this$ = ecx

; 572  :     virtual ~kdu_push_ifc_base() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_push_ifc_base@@6B@
	ret	0
??1kdu_push_ifc_base@@MAE@XZ ENDP			; kdu_push_ifc_base::~kdu_push_ifc_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_width@kdu_line_buf@@QAEHXZ
_TEXT	SEGMENT
?get_width@kdu_line_buf@@QAEHXZ PROC			; kdu_line_buf::get_width, COMDAT
; _this$ = ecx

; 537  :       /* [SYNOPSIS]
; 538  :            Returns 0 if the object has not been created.  Otherwise, returns
; 539  :            the nominal width of the line.  Remember that the arrays returned
; 540  :            by `get_buf16' and `get_buf32' are typically larger than the actual
; 541  :            line width, as explained in the comments appearing with the
; 542  :            `pre_create' function.
; 543  :       */
; 544  :         return width;

	mov	eax, DWORD PTR [ecx]

; 545  :       }

	ret	0
?get_width@kdu_line_buf@@QAEHXZ ENDP			; kdu_line_buf::get_width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ
_TEXT	SEGMENT
?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ PROC	; kdu_line_buf::get_buf16, COMDAT
; _this$ = ecx

; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN3@get_buf16
	mov	eax, DWORD PTR [ecx+8]

; 414  :       }

	ret	0
$LN3@get_buf16:

; 405  :       /* [SYNOPSIS]
; 406  :            Returns NULL if the sample values are of type `kdu_sample32'
; 407  :            instead of `kdu_sample16', or the buffer has not yet been
; 408  :            created.  Otherwise, returns an array which supports accesses
; 409  :            at least with indices in the range 0 to `width'-1, but typically
; 410  :            beyond these bounds -- see `pre_create' for an explanation of
; 411  :            extended access bounds.
; 412  :       */
; 413  :         return (flags & KD_LINE_BUF_SHORTS)?buf16:NULL;

	xor	eax, eax

; 414  :       }

	ret	0
?get_buf16@kdu_line_buf@@QAEPATkdu_sample16@@XZ ENDP	; kdu_line_buf::get_buf16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ
_TEXT	SEGMENT
?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ PROC	; kdu_line_buf::get_buf32, COMDAT
; _this$ = ecx

; 393  :       /* [SYNOPSIS]
; 394  :            Returns NULL if the sample values are of type `kdu_sample16'
; 395  :            instead of `kdu_sample32', or the buffer has not yet been
; 396  :            created.  Otherwise, returns an array which supports accesses
; 397  :            at least with indices in the range 0 to `width'-1, but typically
; 398  :            beyond these bounds -- see `pre_create' for an explanation of
; 399  :            extended access bounds.
; 400  :       */
; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	test	BYTE PTR [ecx+6], 2
	je	SHORT $LN3@get_buf32
	xor	eax, eax

; 402  :       }

	ret	0
$LN3@get_buf32:

; 393  :       /* [SYNOPSIS]
; 394  :            Returns NULL if the sample values are of type `kdu_sample16'
; 395  :            instead of `kdu_sample32', or the buffer has not yet been
; 396  :            created.  Otherwise, returns an array which supports accesses
; 397  :            at least with indices in the range 0 to `width'-1, but typically
; 398  :            beyond these bounds -- see `pre_create' for an explanation of
; 399  :            extended access bounds.
; 400  :       */
; 401  :         return (flags & KD_LINE_BUF_SHORTS)?NULL:buf32;

	mov	eax, DWORD PTR [ecx+8]

; 402  :       }

	ret	0
?get_buf32@kdu_line_buf@@QAEPATkdu_sample32@@XZ ENDP	; kdu_line_buf::get_buf32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?destroy@kdu_line_buf@@QAEXXZ
_TEXT	SEGMENT
?destroy@kdu_line_buf@@QAEXXZ PROC			; kdu_line_buf::destroy, COMDAT
; _this$ = ecx

; 380  :       /* [SYNOPSIS]
; 381  :            Restores the object to its uninitialized state ready for a new
; 382  :            `pre_create' call.  Does not actually destroy any storage, since
; 383  :            the `kdu_sample_allocator' object from which storage is served
; 384  :            does not permit individual deallocation of storage blocks.
; 385  :       */
; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx], 0
	mov	WORD PTR [ecx+6], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx+8], 0

; 388  :       }

	ret	0
?destroy@kdu_line_buf@@QAEXXZ ENDP			; kdu_line_buf::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?create@kdu_line_buf@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?create@kdu_line_buf@@QAEXXZ PROC			; kdu_line_buf::create, COMDAT
; _this$ = ecx

; 361  :       {

	push	ebp
	mov	ebp, esp
	push	ecx

; 362  :       /* [SYNOPSIS]
; 363  :            Finalizes creation of storage which was initiated by `pre_create'.
; 364  :            Does nothing at all if the `pre_create' function was not called,
; 365  :            or the object was previously created and has not been destroyed.
; 366  :            Otherwise, you may not call this function until the
; 367  :            `kdu_sample_allocator' object supplied to `pre_create' has had
; 368  :            its `finalize' member function called.
; 369  :       */
; 370  :         if (!pre_created)

	cmp	BYTE PTR [ecx+7], 0
	mov	DWORD PTR _this$1$[ebp], ecx
	je	SHORT $LN4@create

; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)

	test	BYTE PTR [ecx+6], 2
	push	ebx

; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);

	mov	ebx, DWORD PTR [ecx+8]
	push	esi
	mov	BYTE PTR [ecx+7], 0
	push	edi
	movzx	edi, BYTE PTR [ecx+4]

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.
; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	edx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+16]

; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);

	movzx	ecx, BYTE PTR [ecx+5]
	je	SHORT $LN3@create

; 217  :         before = (before+7)&~7; // Round up to nearest multiple of 16 bytes.

	add	edi, 7
	and	edi, -8					; fffffff8H

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.
; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	lea	esi, DWORD PTR [eax+edi*2]
	mov	eax, DWORD PTR _this$1$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR [eax]
	add	eax, 7
	add	eax, ecx
	and	eax, -8					; fffffff8H
	add	eax, edi
	pop	edi
	lea	eax, DWORD PTR [edx+eax*2]

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.
; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	DWORD PTR [ebx+8], eax

; 375  :         else
; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [eax+8], esi
	pop	esi
	pop	ebx

; 377  :       }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@create:

; 221  :         assert(bytes_used <= bytes_reserved);
; 222  :         return result;
; 223  :       }
; 224  :     kdu_sample32 *alloc32(int before, int after)
; 225  :       {
; 226  :       /* [SYNOPSIS]
; 227  :            Same as `alloc16', except that it allocates storage for arrays of
; 228  :            32-bit quantities.  Again, the returned pointer is guaranteed to
; 229  :            be aligned on a 16-byte boundary.
; 230  :       */
; 231  :         assert(!pre_creation_phase);
; 232  :         before = (before+3)&~3; // Round up to nearest multiple of 16 bytes.

	add	edi, 3
	and	edi, -4					; fffffffcH

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.
; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	lea	esi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _this$1$[ebp]
	add	esi, edx
	mov	eax, DWORD PTR [eax]
	add	eax, 3
	add	eax, ecx
	and	eax, -4					; fffffffcH
	add	eax, edi
	pop	edi
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ebx+8], eax

; 375  :         else
; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [eax+8], esi
	pop	esi
	pop	ebx
$LN4@create:

; 377  :       }

	mov	esp, ebp
	pop	ebp
	ret	0
?create@kdu_line_buf@@QAEXXZ ENDP			; kdu_line_buf::create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z
_TEXT	SEGMENT
_allocator$ = 8						; size = 4
_width$ = 12						; size = 4
_absolute$ = 16						; size = 1
_use_shorts$ = 20					; size = 1
_extend_left$ = 24					; size = 4
_extend_right$ = 28					; size = 4
?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z PROC ; kdu_line_buf::pre_create, COMDAT
; _this$ = ecx

; 294  :       {

	push	ebp
	mov	ebp, esp

; 295  :       /* [SYNOPSIS]
; 296  :            Declares the characteristics of the internal storage which will
; 297  :            later be created by `create'.  If `use_shorts' is true, the sample
; 298  :            values will have 16 bits each and normalized values will use a
; 299  :            fixed point representation with KDU_FIX_POINT fraction bits.
; 300  :            Otherwise, the sample values have 32 bits each and normalized
; 301  :            values use a true floating point representation.
; 302  :            [//]
; 303  :            This function essentially calls `allocator->pre_create', requesting
; 304  :            enough storage for a line with `width' samples, providing for legal
; 305  :            accesses up to `extend_left' samples before the beginning of the
; 306  :            line and `extend_right' samples beyond the end of the line.
; 307  :            [//]
; 308  :            Moreover, the returned line buffer is aligned on a 16-byte
; 309  :            boundary, the `extend_left' and `extend_right' values are rounded
; 310  :            up to the nearest multiple of 16 bytes, and the length of the
; 311  :            right-extended buffer is also rounded up to a multiple of 16 bytes.
; 312  :            Finally, it is possible to read at least 16 bytes beyond the
; 313  :            end of the extended region, although writes to these extra 16
; 314  :            bytes might overwrite data belonging to a different line.
; 315  :          [ARG: allocator]
; 316  :            Pointer to the object which will later be used to complete the
; 317  :            allocation of storage for the line.  The pointer is saved
; 318  :            internally until such time as the `create' function is called, so
; 319  :            you must be careful not to delete this object.  You must also be
; 320  :            careful to call its `kdu_sample_allocator::finalize' function
; 321  :            before calling `create'.
; 322  :          [ARG: width]
; 323  :            Nominal width of (number of samples in) the line.  Note that space
; 324  :            reserved for access to `extend_left' samples to the left and
; 325  :            `extend_right' samples to the right.  Moreover, additional
; 326  :            samples may often be accessed to the left and right of the nominal
; 327  :            line boundaries due to the alignment policy discussed above.
; 328  :          [ARG: absolute]
; 329  :            If true, the sample values in the line buffer are to be used in
; 330  :            JPEG2000's reversible processing path, which works with absolute
; 331  :            integers.  otherwise, the line is prepared for use with the
; 332  :            irreversible processing path, which works with normalized
; 333  :            (floating or fixed point) quantities.
; 334  :          [ARG: use_shorts]
; 335  :            If true, space is allocated for 16-bit sample values
; 336  :            (array entries will be of type `kdu_sample16').  Otherwise, the
; 337  :            line buffer will hold samples of type `kdu_sample32'.
; 338  :          [ARG: extend_left]
; 339  :            This quantity should be small, since it will be represented
; 340  :            internally using 8-bit numbers, after rounding up to an
; 341  :            appropriately aligned value.  It would be unusual to select
; 342  :            values larger than 16 or perhaps 32.
; 343  :          [ARG: extend_right]
; 344  :            This quantity should be small, since it will be represented
; 345  :            internally using 8-bit numbers, after rounding up to an
; 346  :            appropriately aligned value.  It would be unusual to select
; 347  :            values larger than 16 or perhaps 32.
; 348  :       */
; 349  :         assert((!pre_created) && (this->allocator == NULL)); this->width=width;
; 350  :         flags = (use_shorts)?KD_LINE_BUF_SHORTS:0; 
; 351  :         flags |= (absolute)?KD_LINE_BUF_ABSOLUTE:0;

	cmp	BYTE PTR _absolute$[ebp], 0
	mov	eax, DWORD PTR _width$[ebp]
	push	ebx
	setne	dl
	push	esi
	mov	esi, ecx
	mov	cl, BYTE PTR _use_shorts$[ebp]
	push	edi

; 352  :         this->allocator = allocator;

	mov	edi, DWORD PTR _allocator$[ebp]
	mov	DWORD PTR [esi], eax
	mov	al, cl
	neg	al
	mov	DWORD PTR [esi+8], edi
	sbb	al, al
	and	al, 2
	or	dl, al

; 353  :         buf_before = (kdu_byte) extend_left; // Rounded up automatically
; 354  :         buf_after = (kdu_byte)

	test	cl, cl
	mov	ecx, DWORD PTR _extend_right$[ebp]
	mov	al, cl
	setne	bl
	mov	BYTE PTR [esi+6], dl
	mov	edx, DWORD PTR _extend_left$[ebp]
	neg	al
	mov	BYTE PTR [esi+4], dl
	lea	ebx, DWORD PTR [ebx*4+3]
	and	bl, al
	add	bl, cl

; 355  :           (extend_right + ((-extend_right) & ((use_shorts)?7:3)));
; 356  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);

	movzx	ecx, dl

; 180  :         if (!use_shorts)

	mov	dl, BYTE PTR _use_shorts$[ebp]
	add	ecx, ecx

; 355  :           (extend_right + ((-extend_right) & ((use_shorts)?7:3)));
; 356  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);

	movzx	eax, bl
	mov	BYTE PTR [esi+5], bl

; 179  :         before+=before; after+=after; // Two bytes per sample

	mov	ebx, DWORD PTR _width$[ebp]
	add	eax, ebx
	add	eax, eax

; 180  :         if (!use_shorts)

	test	dl, dl
	jne	SHORT $LN4@pre_create

; 181  :           { before+=before; after+=after; } // Four bytes per sample

	add	ecx, ecx
	add	eax, eax
$LN4@pre_create:

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	ecx, 15					; 0000000fH
	add	eax, 15					; 0000000fH
	and	eax, -16				; fffffff0H
	and	ecx, -16				; fffffff0H
	add	ecx, eax
	add	DWORD PTR [edi+4], ecx

; 357  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);

	movzx	eax, BYTE PTR [esi+5]
	movzx	ecx, BYTE PTR [esi+4]

; 179  :         before+=before; after+=after; // Two bytes per sample

	add	eax, ebx
	add	ecx, ecx
	add	eax, eax

; 180  :         if (!use_shorts)

	test	dl, dl
	jne	SHORT $LN7@pre_create

; 181  :           { before+=before; after+=after; } // Four bytes per sample

	add	ecx, ecx
	add	eax, eax
$LN7@pre_create:

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	ecx, 15					; 0000000fH
	add	eax, 15					; 0000000fH
	and	ecx, -16				; fffffff0H
	and	eax, -16				; fffffff0H
	add	ecx, DWORD PTR [edi+4]
	add	eax, ecx
	mov	DWORD PTR [edi+4], eax
	pop	edi

; 358  :         pre_created = true;

	mov	BYTE PTR [esi+7], 1
	pop	esi
	pop	ebx

; 359  :       }

	pop	ebp
	ret	24					; 00000018H
?pre_create@kdu_line_buf@@QAEXPAVkdu_sample_allocator@@H_N1HH@Z ENDP ; kdu_line_buf::pre_create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ??0kdu_line_buf@@QAE@XZ
_TEXT	SEGMENT
??0kdu_line_buf@@QAE@XZ PROC				; kdu_line_buf::kdu_line_buf, COMDAT
; _this$ = ecx

; 291  :     void pre_create(kdu_sample_allocator *allocator,
; 292  :                     int width, bool absolute, bool use_shorts,
; 293  :                     int extend_left=2, int extend_right=2)
; 294  :       {
; 295  :       /* [SYNOPSIS]
; 296  :            Declares the characteristics of the internal storage which will
; 297  :            later be created by `create'.  If `use_shorts' is true, the sample
; 298  :            values will have 16 bits each and normalized values will use a
; 299  :            fixed point representation with KDU_FIX_POINT fraction bits.
; 300  :            Otherwise, the sample values have 32 bits each and normalized
; 301  :            values use a true floating point representation.
; 302  :            [//]
; 303  :            This function essentially calls `allocator->pre_create', requesting
; 304  :            enough storage for a line with `width' samples, providing for legal
; 305  :            accesses up to `extend_left' samples before the beginning of the
; 306  :            line and `extend_right' samples beyond the end of the line.
; 307  :            [//]
; 308  :            Moreover, the returned line buffer is aligned on a 16-byte
; 309  :            boundary, the `extend_left' and `extend_right' values are rounded
; 310  :            up to the nearest multiple of 16 bytes, and the length of the
; 311  :            right-extended buffer is also rounded up to a multiple of 16 bytes.
; 312  :            Finally, it is possible to read at least 16 bytes beyond the
; 313  :            end of the extended region, although writes to these extra 16
; 314  :            bytes might overwrite data belonging to a different line.
; 315  :          [ARG: allocator]
; 316  :            Pointer to the object which will later be used to complete the
; 317  :            allocation of storage for the line.  The pointer is saved
; 318  :            internally until such time as the `create' function is called, so
; 319  :            you must be careful not to delete this object.  You must also be
; 320  :            careful to call its `kdu_sample_allocator::finalize' function
; 321  :            before calling `create'.
; 322  :          [ARG: width]
; 323  :            Nominal width of (number of samples in) the line.  Note that space
; 324  :            reserved for access to `extend_left' samples to the left and
; 325  :            `extend_right' samples to the right.  Moreover, additional
; 326  :            samples may often be accessed to the left and right of the nominal
; 327  :            line boundaries due to the alignment policy discussed above.
; 328  :          [ARG: absolute]
; 329  :            If true, the sample values in the line buffer are to be used in
; 330  :            JPEG2000's reversible processing path, which works with absolute
; 331  :            integers.  otherwise, the line is prepared for use with the
; 332  :            irreversible processing path, which works with normalized
; 333  :            (floating or fixed point) quantities.
; 334  :          [ARG: use_shorts]
; 335  :            If true, space is allocated for 16-bit sample values
; 336  :            (array entries will be of type `kdu_sample16').  Otherwise, the
; 337  :            line buffer will hold samples of type `kdu_sample32'.
; 338  :          [ARG: extend_left]
; 339  :            This quantity should be small, since it will be represented
; 340  :            internally using 8-bit numbers, after rounding up to an
; 341  :            appropriately aligned value.  It would be unusual to select
; 342  :            values larger than 16 or perhaps 32.
; 343  :          [ARG: extend_right]
; 344  :            This quantity should be small, since it will be represented
; 345  :            internally using 8-bit numbers, after rounding up to an
; 346  :            appropriately aligned value.  It would be unusual to select
; 347  :            values larger than 16 or perhaps 32.
; 348  :       */
; 349  :         assert((!pre_created) && (this->allocator == NULL)); this->width=width;
; 350  :         flags = (use_shorts)?KD_LINE_BUF_SHORTS:0; 
; 351  :         flags |= (absolute)?KD_LINE_BUF_ABSOLUTE:0;
; 352  :         this->allocator = allocator;
; 353  :         buf_before = (kdu_byte) extend_left; // Rounded up automatically
; 354  :         buf_after = (kdu_byte)
; 355  :           (extend_right + ((-extend_right) & ((use_shorts)?7:3)));
; 356  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);
; 357  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);
; 358  :         pre_created = true;
; 359  :       }
; 360  :     void create()
; 361  :       {
; 362  :       /* [SYNOPSIS]
; 363  :            Finalizes creation of storage which was initiated by `pre_create'.
; 364  :            Does nothing at all if the `pre_create' function was not called,
; 365  :            or the object was previously created and has not been destroyed.
; 366  :            Otherwise, you may not call this function until the
; 367  :            `kdu_sample_allocator' object supplied to `pre_create' has had
; 368  :            its `finalize' member function called.
; 369  :       */
; 370  :         if (!pre_created)
; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)
; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);
; 375  :         else
; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);
; 377  :       }
; 378  :     void destroy()
; 379  :       {
; 380  :       /* [SYNOPSIS]
; 381  :            Restores the object to its uninitialized state ready for a new
; 382  :            `pre_create' call.  Does not actually destroy any storage, since
; 383  :            the `kdu_sample_allocator' object from which storage is served
; 384  :            does not permit individual deallocation of storage blocks.
; 385  :       */
; 386  :         width=0; flags=0; pre_created=false;

	mov	DWORD PTR [ecx], 0

; 290  :     kdu_line_buf() { destroy(); }

	mov	eax, ecx

; 291  :     void pre_create(kdu_sample_allocator *allocator,
; 292  :                     int width, bool absolute, bool use_shorts,
; 293  :                     int extend_left=2, int extend_right=2)
; 294  :       {
; 295  :       /* [SYNOPSIS]
; 296  :            Declares the characteristics of the internal storage which will
; 297  :            later be created by `create'.  If `use_shorts' is true, the sample
; 298  :            values will have 16 bits each and normalized values will use a
; 299  :            fixed point representation with KDU_FIX_POINT fraction bits.
; 300  :            Otherwise, the sample values have 32 bits each and normalized
; 301  :            values use a true floating point representation.
; 302  :            [//]
; 303  :            This function essentially calls `allocator->pre_create', requesting
; 304  :            enough storage for a line with `width' samples, providing for legal
; 305  :            accesses up to `extend_left' samples before the beginning of the
; 306  :            line and `extend_right' samples beyond the end of the line.
; 307  :            [//]
; 308  :            Moreover, the returned line buffer is aligned on a 16-byte
; 309  :            boundary, the `extend_left' and `extend_right' values are rounded
; 310  :            up to the nearest multiple of 16 bytes, and the length of the
; 311  :            right-extended buffer is also rounded up to a multiple of 16 bytes.
; 312  :            Finally, it is possible to read at least 16 bytes beyond the
; 313  :            end of the extended region, although writes to these extra 16
; 314  :            bytes might overwrite data belonging to a different line.
; 315  :          [ARG: allocator]
; 316  :            Pointer to the object which will later be used to complete the
; 317  :            allocation of storage for the line.  The pointer is saved
; 318  :            internally until such time as the `create' function is called, so
; 319  :            you must be careful not to delete this object.  You must also be
; 320  :            careful to call its `kdu_sample_allocator::finalize' function
; 321  :            before calling `create'.
; 322  :          [ARG: width]
; 323  :            Nominal width of (number of samples in) the line.  Note that space
; 324  :            reserved for access to `extend_left' samples to the left and
; 325  :            `extend_right' samples to the right.  Moreover, additional
; 326  :            samples may often be accessed to the left and right of the nominal
; 327  :            line boundaries due to the alignment policy discussed above.
; 328  :          [ARG: absolute]
; 329  :            If true, the sample values in the line buffer are to be used in
; 330  :            JPEG2000's reversible processing path, which works with absolute
; 331  :            integers.  otherwise, the line is prepared for use with the
; 332  :            irreversible processing path, which works with normalized
; 333  :            (floating or fixed point) quantities.
; 334  :          [ARG: use_shorts]
; 335  :            If true, space is allocated for 16-bit sample values
; 336  :            (array entries will be of type `kdu_sample16').  Otherwise, the
; 337  :            line buffer will hold samples of type `kdu_sample32'.
; 338  :          [ARG: extend_left]
; 339  :            This quantity should be small, since it will be represented
; 340  :            internally using 8-bit numbers, after rounding up to an
; 341  :            appropriately aligned value.  It would be unusual to select
; 342  :            values larger than 16 or perhaps 32.
; 343  :          [ARG: extend_right]
; 344  :            This quantity should be small, since it will be represented
; 345  :            internally using 8-bit numbers, after rounding up to an
; 346  :            appropriately aligned value.  It would be unusual to select
; 347  :            values larger than 16 or perhaps 32.
; 348  :       */
; 349  :         assert((!pre_created) && (this->allocator == NULL)); this->width=width;
; 350  :         flags = (use_shorts)?KD_LINE_BUF_SHORTS:0; 
; 351  :         flags |= (absolute)?KD_LINE_BUF_ABSOLUTE:0;
; 352  :         this->allocator = allocator;
; 353  :         buf_before = (kdu_byte) extend_left; // Rounded up automatically
; 354  :         buf_after = (kdu_byte)
; 355  :           (extend_right + ((-extend_right) & ((use_shorts)?7:3)));
; 356  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);
; 357  :         allocator->pre_alloc(use_shorts,buf_before,width+buf_after,1);
; 358  :         pre_created = true;
; 359  :       }
; 360  :     void create()
; 361  :       {
; 362  :       /* [SYNOPSIS]
; 363  :            Finalizes creation of storage which was initiated by `pre_create'.
; 364  :            Does nothing at all if the `pre_create' function was not called,
; 365  :            or the object was previously created and has not been destroyed.
; 366  :            Otherwise, you may not call this function until the
; 367  :            `kdu_sample_allocator' object supplied to `pre_create' has had
; 368  :            its `finalize' member function called.
; 369  :       */
; 370  :         if (!pre_created)
; 371  :           return;
; 372  :         pre_created = false;
; 373  :         if (flags & KD_LINE_BUF_SHORTS)
; 374  :           buf16 = allocator->alloc16(buf_before,width+buf_after);
; 375  :         else
; 376  :           buf32 = allocator->alloc32(buf_before,width+buf_after);
; 377  :       }
; 378  :     void destroy()
; 379  :       {
; 380  :       /* [SYNOPSIS]
; 381  :            Restores the object to its uninitialized state ready for a new
; 382  :            `pre_create' call.  Does not actually destroy any storage, since
; 383  :            the `kdu_sample_allocator' object from which storage is served
; 384  :            does not permit individual deallocation of storage blocks.
; 385  :       */
; 386  :         width=0; flags=0; pre_created=false;

	mov	WORD PTR [ecx+6], 0

; 387  :         allocator=NULL; buf16=NULL; buf32=NULL;

	mov	DWORD PTR [ecx+8], 0

; 290  :     kdu_line_buf() { destroy(); }

	ret	0
??0kdu_line_buf@@QAE@XZ ENDP				; kdu_line_buf::kdu_line_buf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z
_TEXT	SEGMENT
_before$ = 8						; size = 4
_after$ = 12						; size = 4
?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z PROC ; kdu_sample_allocator::alloc32, COMDAT
; _this$ = ecx

; 225  :       {

	push	ebp
	mov	ebp, esp
	push	esi

; 226  :       /* [SYNOPSIS]
; 227  :            Same as `alloc16', except that it allocates storage for arrays of
; 228  :            32-bit quantities.  Again, the returned pointer is guaranteed to
; 229  :            be aligned on a 16-byte boundary.
; 230  :       */
; 231  :         assert(!pre_creation_phase);
; 232  :         before = (before+3)&~3; // Round up to nearest multiple of 16 bytes.

	mov	esi, DWORD PTR _before$[ebp]
	push	edi
	mov	edi, ecx
	add	esi, 3

; 233  :         after = (after+3)&~3; // Round up to nearest multiple of 16 bytes.

	mov	ecx, DWORD PTR _after$[ebp]
	and	esi, -4					; fffffffcH
	add	ecx, 3
	and	ecx, -4					; fffffffcH

; 234  :         kdu_sample32 *result = (kdu_sample32 *)(buffer+bytes_used);
; 235  :         result += before; bytes_used += (before+after)<<2;

	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+esi*4]
	add	eax, edx
	add	ecx, esi
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [edi+8], ecx
	pop	edi
	pop	esi

; 236  :         assert(bytes_used <= bytes_reserved);
; 237  :         return result;
; 238  :       }

	pop	ebp
	ret	8
?alloc32@kdu_sample_allocator@@QAEPATkdu_sample32@@HH@Z ENDP ; kdu_sample_allocator::alloc32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z
_TEXT	SEGMENT
_before$ = 8						; size = 4
_after$ = 12						; size = 4
?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z PROC ; kdu_sample_allocator::alloc16, COMDAT
; _this$ = ecx

; 203  :       {

	push	ebp
	mov	ebp, esp
	push	esi

; 204  :       /* [SYNOPSIS]
; 205  :            Allocate an array with space for `before' entries prior to the
; 206  :            returned pointer and `after' entries after the returned pointer
; 207  :            (including the entry to which the pointer refers).  The returned
; 208  :            pointer is guaranteed to be aligned on a 16-byte boundary.
; 209  :            The pointer may be interpreted as the location of an array which
; 210  :            can accept signed indices, n, in the range -`before' <= n < `after'.
; 211  :            [//]
; 212  :            Before calling this function, you must have pre-allocated sufficient
; 213  :            space through calls to `pre_alloc' and you must have called the
; 214  :            `finalize' member function.
; 215  :       */
; 216  :         assert(!pre_creation_phase);
; 217  :         before = (before+7)&~7; // Round up to nearest multiple of 16 bytes.

	mov	esi, DWORD PTR _before$[ebp]
	push	edi
	mov	edi, ecx
	add	esi, 7

; 218  :         after = (after+7)&~7; // Round up to nearest multiple of 16 bytes.

	mov	ecx, DWORD PTR _after$[ebp]
	and	esi, -8					; fffffff8H
	add	ecx, 7
	and	ecx, -8					; fffffff8H

; 219  :         kdu_sample16 *result = (kdu_sample16 *)(buffer+bytes_used);
; 220  :         result += before; bytes_used += (before+after)<<1;

	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+esi*2]
	add	eax, edx
	add	ecx, esi
	lea	ecx, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR [edi+8], ecx
	pop	edi
	pop	esi

; 221  :         assert(bytes_used <= bytes_reserved);
; 222  :         return result;
; 223  :       }

	pop	ebp
	ret	8
?alloc16@kdu_sample_allocator@@QAEPATkdu_sample16@@HH@Z ENDP ; kdu_sample_allocator::alloc16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_sample_processing.h
;	COMDAT ?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z
_TEXT	SEGMENT
_use_shorts$ = 8					; size = 1
_before$ = 12						; size = 4
_after$ = 16						; size = 4
_num_requests$ = 20					; size = 4
?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z PROC	; kdu_sample_allocator::pre_alloc, COMDAT
; _this$ = ecx

; 168  :       {

	push	ebp
	mov	ebp, esp

; 169  :       /* [SYNOPSIS]
; 170  :            Reserves enough storage for `num_requests' later calls to `alloc16'
; 171  :            (if `use_shorts' is true) or `alloc32' (if `use_shorts' is false).
; 172  :            Space is reserved such that each of these `num_requests' allocations
; 173  :            can return an appropriately aligned pointer to an array which offers
; 174  :            entries at locations n in the range -`before' <= n < `after', where
; 175  :            each entry is of type `kdu_sample16' (if `use_shorts'=true) or
; 176  :            `kdu_sample32' (if `use_shorts'=false).
; 177  :       */
; 178  :         assert(pre_creation_phase);
; 179  :         before+=before; after+=after; // Two bytes per sample

	mov	eax, DWORD PTR _before$[ebp]
	mov	edx, ecx
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _after$[ebp]
	add	eax, eax

; 180  :         if (!use_shorts)

	cmp	BYTE PTR _use_shorts$[ebp], 0
	jne	SHORT $LN2@pre_alloc

; 181  :           { before+=before; after+=after; } // Four bytes per sample

	add	ecx, ecx
	add	eax, eax
$LN2@pre_alloc:

; 182  :         bytes_reserved += num_requests*(((15+before)&~15) + ((15+after)&~15));

	add	ecx, 15					; 0000000fH
	add	eax, 15					; 0000000fH
	and	ecx, -16				; fffffff0H
	and	eax, -16				; fffffff0H
	add	ecx, eax
	imul	ecx, DWORD PTR _num_requests$[ebp]
	add	DWORD PTR [edx+4], ecx

; 183  :       }

	pop	ebp
	ret	16					; 00000010H
?pre_alloc@kdu_sample_allocator@@QAEX_NHHH@Z ENDP	; kdu_sample_allocator::pre_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??7kdu_node@@QAE_NXZ
_TEXT	SEGMENT
??7kdu_node@@QAE_NXZ PROC				; kdu_node::operator!, COMDAT
; _this$ = ecx

; 4994 :     bool operator!() { return (state==NULL)?true:false; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
??7kdu_node@@QAE_NXZ ENDP				; kdu_node::operator!
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?exists@kdu_node@@QAE_NXZ
_TEXT	SEGMENT
?exists@kdu_node@@QAE_NXZ PROC				; kdu_node::exists, COMDAT
; _this$ = ecx

; 4988 :     bool exists() { return (state==NULL)?false:true; }

	cmp	DWORD PTR [ecx], 0
	setne	al
	ret	0
?exists@kdu_node@@QAE_NXZ ENDP				; kdu_node::exists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??7kdu_dims@@QAE_NXZ
_TEXT	SEGMENT
??7kdu_dims@@QAE_NXZ PROC				; kdu_dims::operator!, COMDAT
; _this$ = ecx

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR [ecx+12], 0
	jle	SHORT $LN3@operator
	cmp	DWORD PTR [ecx+8], 0
	jle	SHORT $LN3@operator
	xor	al, al
	ret	0
$LN3@operator:
	mov	al, 1
	ret	0
??7kdu_dims@@QAE_NXZ ENDP				; kdu_dims::operator!
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_dims@@QAE@XZ
_TEXT	SEGMENT
??0kdu_dims@@QAE@XZ PROC				; kdu_dims::kdu_dims, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0

; 304  :     kdu_dims() {};

	mov	eax, ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0

; 304  :     kdu_dims() {};

	ret	0
??0kdu_dims@@QAE@XZ ENDP				; kdu_dims::kdu_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??Hkdu_coords@@QAE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??Hkdu_coords@@QAE?AU0@ABU0@@Z PROC			; kdu_coords::operator+, COMDAT
; _this$ = ecx

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	esi
	mov	esi, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [esi+4]
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	pop	esi
	pop	ebp
	ret	8
??Hkdu_coords@@QAE?AU0@ABU0@@Z ENDP			; kdu_coords::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_coords@@QAE@XZ
_TEXT	SEGMENT
??0kdu_coords@@QAE@XZ PROC				; kdu_coords::kdu_coords, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kdu_coords@@QAE@XZ ENDP				; kdu_coords::kdu_coords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?release_lock@kdu_thread_entity@@QAEXH@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
?release_lock@kdu_thread_entity@@QAEXH@Z PROC		; kdu_thread_entity::release_lock, COMDAT
; _this$ = ecx

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _lock_id$[ebp]

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [ecx+eax*8+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN5@release_lo
	mov	DWORD PTR _lock_id$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	jmp	DWORD PTR __imp__ReleaseMutex@4
$LN5@release_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
	ret	4
?release_lock@kdu_thread_entity@@QAEXH@Z ENDP		; kdu_thread_entity::release_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?acquire_lock@kdu_thread_entity@@QAEXH_N@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
$T1 = 12						; size = 4
_allow_exceptions$ = 12					; size = 1
?acquire_lock@kdu_thread_entity@@QAEXH_N@Z PROC		; kdu_thread_entity::acquire_lock, COMDAT
; _this$ = ecx

; 1024 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp

; 1025 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	cmp	BYTE PTR _allow_exceptions$[ebp], 0
	mov	eax, DWORD PTR _lock_id$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edx, DWORD PTR [esi+28]
	lea	edi, DWORD PTR [edx+eax*8]
	je	SHORT $LN2@acquire_lo
	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN9@acquire_lo
$LN2@acquire_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@acquire_lo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN6@acquire_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+4], esi
	pop	edi
	pop	esi
	pop	ebp
	ret	8
$LN9@acquire_lo:

; 1025 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN11@acquire_lo:
$LN8@acquire_lo:
	int	3
?acquire_lock@kdu_thread_entity@@QAEXH_N@Z ENDP		; kdu_thread_entity::acquire_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?unlock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?unlock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::unlock, COMDAT
; _this$ = ecx

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@unlock
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	cmp	eax, 1
	jne	SHORT $LN3@unlock
	mov	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
$LN3@unlock:

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	xor	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
?unlock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?lock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?lock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::lock, COMDAT
; _this$ = ecx

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@lock
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	SHORT $LN3@lock
	mov	al, 1

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
$LN3@lock:

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	xor	al, al

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
?lock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\transform\analysis.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
