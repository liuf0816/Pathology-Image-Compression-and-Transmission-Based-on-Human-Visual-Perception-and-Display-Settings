; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\coding\block_decoder.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	??1kdu_block_decoder_base@@MAE@XZ		; kdu_block_decoder_base::~kdu_block_decoder_base
PUBLIC	??_Gkdu_block_decoder_base@@MAEPAXI@Z		; kdu_block_decoder_base::`scalar deleting destructor'
PUBLIC	??0kdu_block_decoder@@QAE@XZ			; kdu_block_decoder::kdu_block_decoder
PUBLIC	?check_out@mq_decoder@@QAEXAAH0000AAPAE0@Z	; mq_decoder::check_out
PUBLIC	?check_in@mq_decoder@@QAEXHHHHHPAEH@Z		; mq_decoder::check_in
PUBLIC	?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z	; kd_block_decoder::decode
PUBLIC	??_Gkd_block_decoder@@UAEPAXI@Z			; kd_block_decoder::`scalar deleting destructor'
PUBLIC	??_7kdu_block_decoder_base@@6B@			; kdu_block_decoder_base::`vftable'
PUBLIC	??_7kd_block_decoder@@6B@			; kd_block_decoder::`vftable'
PUBLIC	??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@	; `string'
PUBLIC	??_C@_0LM@KLFCJLNO@Encountered?5incorrectly?5terminat@ ; `string'
PUBLIC	??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@ ; `string'
PUBLIC	??_C@_0DD@CFAHIJHG@One?5or?5more?5corrupted?5block?5bit?9@ ; `string'
PUBLIC	??_R4kdu_block_decoder_base@@6B@		; kdu_block_decoder_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_block_decoder_base@@@8		; kdu_block_decoder_base `RTTI Type Descriptor'
PUBLIC	??_R3kdu_block_decoder_base@@8			; kdu_block_decoder_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_block_decoder_base@@8			; kdu_block_decoder_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_block_decoder_base@@8		; kdu_block_decoder_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_block_decoder@@6B@			; kd_block_decoder::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_block_decoder@@@8			; kd_block_decoder `RTTI Type Descriptor'
PUBLIC	??_R3kd_block_decoder@@8			; kd_block_decoder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_block_decoder@@8			; kd_block_decoder::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_block_decoder@@8		; kd_block_decoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??0kdu_error@@QAE@PBD@Z:PROC			; kdu_error::kdu_error
EXTRN	??1kdu_error@@UAE@XZ:PROC			; kdu_error::~kdu_error
EXTRN	??0kdu_warning@@QAE@PBD@Z:PROC			; kdu_warning::kdu_warning
EXTRN	??1kdu_warning@@UAE@XZ:PROC			; kdu_warning::~kdu_warning
EXTRN	__imp__clock:PROC
EXTRN	?set_max_samples@kdu_block@@QAEXH@Z:PROC	; kdu_block::set_max_samples
EXTRN	?set_max_contexts@kdu_block@@QAEXH@Z:PROC	; kdu_block::set_max_contexts
EXTRN	??_Ekdu_block_decoder_base@@MAEPAXI@Z:PROC	; kdu_block_decoder_base::`vector deleting destructor'
EXTRN	?start@mq_decoder@@QAEXPAEH_N@Z:PROC		; mq_decoder::start
EXTRN	?finish@mq_decoder@@QAE_N_N@Z:PROC		; mq_decoder::finish
EXTRN	?mq_decode_run@mq_decoder@@QAEXAAH@Z:PROC	; mq_decoder::mq_decode_run
EXTRN	??_Ekd_block_decoder@@UAEPAXI@Z:PROC		; kd_block_decoder::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	?kdu_mmx_level@@3HA:DWORD			; kdu_mmx_level
EXTRN	?kdu_pentium_cmov_exists@@3_NA:BYTE		; kdu_pentium_cmov_exists
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?hl_sig_lut@@3PAEA:BYTE				; hl_sig_lut
EXTRN	?lh_sig_lut@@3PAEA:BYTE				; lh_sig_lut
EXTRN	?hh_sig_lut@@3PAEA:BYTE				; hh_sig_lut
EXTRN	?sign_lut@@3PAEA:BYTE				; sign_lut
EXTRN	?p_bar_table@mq_decoder@@2PAHA:BYTE		; mq_decoder::p_bar_table
EXTRN	?transition_table@mq_decoder@@2PAUmqd_transition@@A:BYTE ; mq_decoder::transition_table
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@kd_block_decoder@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_block_decoder@@8 DD FLAT:??_R0?AVkd_block_decoder@@@8 ; kd_block_decoder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_block_decoder@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_block_decoder@@8
rdata$r	SEGMENT
??_R2kd_block_decoder@@8 DD FLAT:??_R1A@?0A@EA@kd_block_decoder@@8 ; kd_block_decoder::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_block_decoder_base@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_block_decoder@@8
rdata$r	SEGMENT
??_R3kd_block_decoder@@8 DD 00H				; kd_block_decoder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_block_decoder@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_block_decoder@@@8
data$r	SEGMENT
??_R0?AVkd_block_decoder@@@8 DD FLAT:??_7type_info@@6B@	; kd_block_decoder `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_block_decoder@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_block_decoder@@6B@
rdata$r	SEGMENT
??_R4kd_block_decoder@@6B@ DD 00H			; kd_block_decoder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_block_decoder@@@8
	DD	FLAT:??_R3kd_block_decoder@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_block_decoder_base@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_block_decoder_base@@8 DD FLAT:??_R0?AVkdu_block_decoder_base@@@8 ; kdu_block_decoder_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_block_decoder_base@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_block_decoder_base@@8
rdata$r	SEGMENT
??_R2kdu_block_decoder_base@@8 DD FLAT:??_R1A@?0A@EA@kdu_block_decoder_base@@8 ; kdu_block_decoder_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_block_decoder_base@@8
rdata$r	SEGMENT
??_R3kdu_block_decoder_base@@8 DD 00H			; kdu_block_decoder_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_block_decoder_base@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_block_decoder_base@@@8
data$r	SEGMENT
??_R0?AVkdu_block_decoder_base@@@8 DD FLAT:??_7type_info@@6B@ ; kdu_block_decoder_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_block_decoder_base@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_block_decoder_base@@6B@
rdata$r	SEGMENT
??_R4kdu_block_decoder_base@@6B@ DD 00H			; kdu_block_decoder_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_block_decoder_base@@@8
	DD	FLAT:??_R3kdu_block_decoder_base@@8
rdata$r	ENDS
;	COMDAT ??_C@_0DD@CFAHIJHG@One?5or?5more?5corrupted?5block?5bit?9@
CONST	SEGMENT
??_C@_0DD@CFAHIJHG@One?5or?5more?5corrupted?5block?5bit?9@ DB 'One or mor'
	DB	'e corrupted block bit-streams detected.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
CONST	SEGMENT
??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@ DB 'Kakadu Core Warning'
	DB	':', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0LM@KLFCJLNO@Encountered?5incorrectly?5terminat@
CONST	SEGMENT
??_C@_0LM@KLFCJLNO@Encountered?5incorrectly?5terminat@ DB 'Encountered in'
	DB	'correctly terminated codeword segment, or invalid SEGMARK sym'
	DB	'bol in code-block bit-stream.  You may like to use the "resil'
	DB	'ient" mode to recover from and conceal such errors.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
CONST	SEGMENT
??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@ DB 'Kakadu Core Error:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_7kd_block_decoder@@6B@
CONST	SEGMENT
??_7kd_block_decoder@@6B@ DD FLAT:??_R4kd_block_decoder@@6B@ ; kd_block_decoder::`vftable'
	DD	FLAT:??_Ekd_block_decoder@@UAEPAXI@Z
	DD	FLAT:?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z
CONST	ENDS
_DATA	SEGMENT
?significance_luts@@3PAPAEA DD FLAT:?lh_sig_lut@@3PAEA	; significance_luts
	DD	FLAT:?hl_sig_lut@@3PAEA
	DD	FLAT:?lh_sig_lut@@3PAEA
	DD	FLAT:?hh_sig_lut@@3PAEA
_DATA	ENDS
;	COMDAT ??_7kdu_block_decoder_base@@6B@
CONST	SEGMENT
??_7kdu_block_decoder_base@@6B@ DD FLAT:??_R4kdu_block_decoder_base@@6B@ ; kdu_block_decoder_base::`vftable'
	DD	FLAT:??_Ekdu_block_decoder_base@@MAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z$1
__ehfuncinfo$?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
;	COMDAT ?decode_cleanup_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z
_TEXT	SEGMENT
_width_by2$1$ = -60					; size = 4
_val$2$ = -56						; size = 4
tv1193 = -56						; size = 4
tv1192 = -56						; size = 4
tv1190 = -56						; size = 4
tv1188 = -56						; size = 4
tv1187 = -56						; size = 4
tv1186 = -56						; size = 4
tv1185 = -56						; size = 4
tv1184 = -56						; size = 4
tv1182 = -56						; size = 4
tv1177 = -56						; size = 4
tv1176 = -56						; size = 4
tv1168 = -56						; size = 4
tv1167 = -56						; size = 4
tv1165 = -56						; size = 4
tv1162 = -56						; size = 4
tv1161 = -56						; size = 4
_val$4$ = -52						; size = 4
_val$3$ = -52						; size = 4
_val$1$ = -52						; size = 4
tv1157 = -52						; size = 4
tv1155 = -52						; size = 4
tv1153 = -52						; size = 4
tv1134 = -52						; size = 4
tv1133 = -52						; size = 4
tv1132 = -52						; size = 4
tv1131 = -52						; size = 4
tv1129 = -52						; size = 4
tv1042 = -48						; size = 4
_D$21$ = -44						; size = 4
_D$19$ = -44						; size = 4
_D$17$ = -44						; size = 4
_D$15$ = -44						; size = 4
_D$13$ = -44						; size = 4
tv1195 = -44						; size = 4
tv1125 = -44						; size = 4
tv1124 = -44						; size = 4
tv1121 = -44						; size = 4
tv1119 = -44						; size = 4
_D$11$ = -44						; size = 4
_D$9$ = -44						; size = 4
_D$7$ = -44						; size = 4
_sig_lut$1$ = -40					; size = 4
_c$1$ = -36						; size = 4
_run_state$1$ = -32					; size = 4
_one_point_five$1$ = -28				; size = 4
_sym$14$ = -24						; size = 4
_sym$12$ = -24						; size = 4
_sym$11$ = -24						; size = 4
_sym$9$ = -24						; size = 4
_sym$8$ = -24						; size = 4
_sym$6$ = -24						; size = 4
_sym$5$ = -24						; size = 4
_sym$3$ = -24						; size = 4
_run_state$2$ = -20					; size = 4
tv1128 = -16						; size = 4
tv1126 = -16						; size = 4
tv1123 = -16						; size = 4
tv1122 = -16						; size = 4
_t$1$ = -16						; size = 4
_S$1$ = -12						; size = 4
_D$2$ = -8						; size = 4
_A$1$ = -4						; size = 4
_coder$ = 8						; size = 4
_states$ = 12						; size = 4
_state_ref$8$ = 16					; size = 4
_state_ref$7$ = 16					; size = 4
_state_ref$6$ = 16					; size = 4
_state_ref$5$ = 16					; size = 4
_state_ref$4$ = 16					; size = 4
_state_ref$3$ = 16					; size = 4
_state_ref$2$ = 16					; size = 4
_state_ref$1$ = 16					; size = 4
_sym$13$ = 16						; size = 4
_sym$2$ = 16						; size = 4
_p$ = 16						; size = 4
_causal$ = 20						; size = 1
_cword$1$ = 24						; size = 4
_sym$1$ = 24						; size = 4
tv1194 = 24						; size = 4
_orientation$ = 24					; size = 4
_samples$ = 28						; size = 4
_contexts$ = 32						; size = 4
_width$ = 36						; size = 4
_num_stripes$ = 40					; size = 4
_context_row_gap$ = 44					; size = 4
?decode_cleanup_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z PROC ; decode_cleanup_pass, COMDAT

; 646  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 147  :         assert(active && (!checked_out) && MQ_segment); checked_out = true;

	mov	ecx, DWORD PTR _coder$[ebp]
	push	ebx
	push	esi
	push	edi

; 148  :         A = this->A; C = this->C;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]

; 150  :         t = this->t; temp = this->temp; store = this->buf_next; S = this->S;

	mov	ebx, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [ecx+12]
	lea	edx, DWORD PTR [eax-8388608]
	mov	BYTE PTR [ecx+28], 1
	cmp	edi, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 666  :   kdu_int32 one_point_five = 1<<p; one_point_five += (one_point_five>>1);

	mov	DWORD PTR _one_point_five$1$[ebp], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 150  :         t = this->t; temp = this->temp; store = this->buf_next; S = this->S;

	mov	DWORD PTR _t$1$[ebp], ebx
	cmovl	edx, edi
	sub	eax, edx
	mov	DWORD PTR _D$2$[ebp], edx
	mov	DWORD PTR _A$1$[ebp], eax
	sub	edi, edx
	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR _S$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 660  :   register mqd_state run_state = states[KAPPA_RUN_BASE]; // 64-bit register

	mov	ecx, DWORD PTR _states$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	mov	DWORD PTR _run_state$1$[ebp], ecx
	mov	ecx, DWORD PTR _states$[ebp]
	mov	ecx, DWORD PTR [ecx+76]
	mov	DWORD PTR _run_state$2$[ebp], ecx

; 661  :   register kdu_int32 sym;
; 662  :   register kdu_int32 val;
; 663  :   register kdu_byte *sig_lut = significance_luts[orientation];

	mov	ecx, DWORD PTR _orientation$[ebp]
	mov	ecx, DWORD PTR ?significance_luts@@3PAPAEA[ecx*4]
	mov	DWORD PTR _sig_lut$1$[ebp], ecx

; 666  :   kdu_int32 one_point_five = 1<<p; one_point_five += (one_point_five>>1);

	mov	ecx, DWORD PTR _p$[ebp]
	shl	DWORD PTR _one_point_five$1$[ebp], cl
	mov	ecx, DWORD PTR _one_point_five$1$[ebp]
	sar	ecx, 1
	add	DWORD PTR _one_point_five$1$[ebp], ecx

; 667  :   int r, width_by2=width+width, width_by3=width_by2+width;
; 668  : 
; 669  :   assert((context_row_gap - width) == EXTRA_DECODE_CWORDS);
; 670  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_DECODE_CWORDS, sp += width_by3)

	cmp	DWORD PTR _num_stripes$[ebp], 0
	mov	ecx, DWORD PTR _width$[ebp]
	lea	ebx, DWORD PTR [ecx+ecx]
	mov	DWORD PTR _width_by2$1$[ebp], ebx
	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	ebx, DWORD PTR _t$1$[ebp]
	jle	$LN3@decode_cle
	shl	ecx, 2
	mov	DWORD PTR tv1042[ebp], ecx
	npad	1
$LL4@decode_cle:

; 671  :     for (c=width; c > 0; c--, sp++, cp++)

	mov	ecx, DWORD PTR _width$[ebp]
	test	ecx, ecx
	mov	DWORD PTR _c$1$[ebp], ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	jle	$LN2@decode_cle
$LL7@decode_cle:

; 672  :       {
; 673  :         if (*cp == 0)

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR tv1195[ebp], ecx
	test	ecx, ecx
	jne	$LN17@decode_cle

; 674  :           { // Enter the run mode.
; 675  : #ifdef USE_FAST_MACROS // Try to skip over four stripe columns at once
; 676  :             if ((cp[3] == 0) && ((run_state.p_bar_mps & 1) == 0))

	mov	ecx, DWORD PTR _contexts$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR tv1194[ebp], ecx
	cmp	DWORD PTR [ecx], 0
	mov	ecx, DWORD PTR _run_state$1$[ebp]
	jne	SHORT $LN44@decode_cle
	test	cl, 1
	jne	SHORT $LN44@decode_cle

; 677  :               {
; 678  :                 D -= run_state.p_bar_mps<<2;

	shl	ecx, 2
	sub	edx, ecx
	mov	DWORD PTR _D$2$[ebp], edx

; 679  :                 if (D >= 0)

	js	SHORT $LN45@decode_cle

; 680  :                   { // Succeeded in skipping 4 columns at once!
; 681  :                     cp += 3; c -= 3; sp += 3;

	mov	edx, DWORD PTR _samples$[ebp]
	sub	DWORD PTR _c$1$[ebp], 3
	add	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR tv1194[ebp]

; 682  :                     continue;

	jmp	$LN5@decode_cle
$LN45@decode_cle:

; 683  :                   }
; 684  :                 D += run_state.p_bar_mps<<2; // Put back the change.

	mov	ecx, DWORD PTR _run_state$1$[ebp]
	lea	edx, DWORD PTR [edx+ecx*4]
$LN44@decode_cle:

; 685  :               }
; 686  : #endif // USE_FAST_MACROS
; 687  :             _mq_dec_(coder,sym,run_state);

	sub	edx, ecx
	and	ecx, 1
	add	edx, ecx
	mov	DWORD PTR _sym$1$[ebp], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	mov	DWORD PTR _D$2$[ebp], edx
	jns	$LN46@decode_cle
	add	ecx, edx
	add	edi, edx
	mov	edx, DWORD PTR _run_state$1$[ebp]
	sub	edx, DWORD PTR _sym$1$[ebp]
	mov	DWORD PTR _A$1$[ebp], ecx
	test	edi, edi
	js	SHORT $LN47@decode_cle
	cmp	ecx, edx
	jge	SHORT $LN49@decode_cle
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$1$[ebp]
	mov	DWORD PTR _sym$1$[ebp], ecx
	mov	ecx, DWORD PTR _run_state$2$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR _run_state$2$[ebp], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	mov	DWORD PTR _run_state$1$[ebp], edx
	jmp	SHORT $LL10@decode_cle
$LN49@decode_cle:
	mov	edx, DWORD PTR _run_state$2$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR _run_state$1$[ebp], edx
	mov	edx, DWORD PTR _run_state$2$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR _run_state$2$[ebp], edx
	jmp	SHORT $LL10@decode_cle
$LN47@decode_cle:
	add	edi, edx
	cmp	ecx, edx
	jge	SHORT $LN51@decode_cle
	mov	ecx, DWORD PTR _run_state$2$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _run_state$1$[ebp], ecx
	mov	ecx, DWORD PTR _run_state$2$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	jmp	SHORT $LN353@decode_cle
$LN51@decode_cle:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$1$[ebp]
	mov	DWORD PTR _sym$1$[ebp], ecx
	mov	ecx, DWORD PTR _run_state$2$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _run_state$1$[ebp], ecx
	mov	ecx, DWORD PTR _run_state$2$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
$LN353@decode_cle:
	mov	DWORD PTR _run_state$2$[ebp], ecx
	mov	ecx, edx
$LL10@decode_cle:
	test	ebx, ebx
	jne	SHORT $LN53@decode_cle
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN54@decode_cle
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN56@decode_cle
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN55@decode_cle
$LN56@decode_cle:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN55@decode_cle
$LN54@decode_cle:
	inc	eax
$LN55@decode_cle:
	add	edi, esi
$LN53@decode_cle:
	add	ecx, ecx
	add	edi, edi
	dec	ebx
	cmp	ecx, 8388608				; 00800000H
	jl	SHORT $LL10@decode_cle
	lea	edx, DWORD PTR [ecx-8388608]
	mov	DWORD PTR _t$1$[ebp], ebx
	cmp	edi, edx
	cmovl	edx, edi
	sub	ecx, edx
	mov	DWORD PTR _D$2$[ebp], edx
	mov	DWORD PTR _A$1$[ebp], ecx
	sub	edi, edx
$LN46@decode_cle:

; 688  :             if (!sym)

	cmp	DWORD PTR _sym$1$[ebp], 0
	je	$LN340@decode_cle

; 689  :               continue;
; 690  :             _mq_dec_run_(coder,sym); // Returns run length in `sym'.

	sub	edx, 5636352				; 00560100H
	mov	DWORD PTR _sym$2$[ebp], 0
	jns	$LN60@decode_cle
	add	ecx, edx
	add	edi, edx
	js	SHORT $LN61@decode_cle
	cmp	ecx, 5636352				; 00560100H
	jge	SHORT $LL13@decode_cle
	mov	DWORD PTR _sym$2$[ebp], 2
	jmp	SHORT $LL13@decode_cle
$LN61@decode_cle:
	mov	edx, DWORD PTR _sym$2$[ebp]
	add	edi, 5636352				; 00560100H
	cmp	ecx, 5636352				; 00560100H
	mov	ecx, 2
	cmovge	edx, ecx
	mov	ecx, 5636352				; 00560100H
	mov	DWORD PTR _sym$2$[ebp], edx
$LL13@decode_cle:
	test	ebx, ebx
	jne	SHORT $LN65@decode_cle
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN66@decode_cle
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN68@decode_cle
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN67@decode_cle
$LN68@decode_cle:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN67@decode_cle
$LN66@decode_cle:
	inc	eax
$LN67@decode_cle:
	add	edi, esi
$LN65@decode_cle:
	add	ecx, ecx
	add	edi, edi
	dec	ebx
	cmp	ecx, 8388608				; 00800000H
	jl	SHORT $LL13@decode_cle
	lea	edx, DWORD PTR [ecx-8388608]
	mov	DWORD PTR _t$1$[ebp], ebx
	cmp	edi, edx
	cmovl	edx, edi
	sub	ecx, edx
	sub	edi, edx
	mov	DWORD PTR _A$1$[ebp], ecx
$LN60@decode_cle:
	sub	edx, 5636352				; 00560100H
	mov	DWORD PTR _D$2$[ebp], edx
	jns	$LN71@decode_cle
	add	ecx, edx
	add	edi, edx
	js	SHORT $LN72@decode_cle
	cmp	ecx, 5636352				; 00560100H
	jge	SHORT $LL16@decode_cle
	inc	DWORD PTR _sym$2$[ebp]
	jmp	SHORT $LL16@decode_cle
$LN72@decode_cle:
	add	edi, 5636352				; 00560100H
	cmp	ecx, 5636352				; 00560100H
	jl	SHORT $LN75@decode_cle
	inc	DWORD PTR _sym$2$[ebp]
$LN75@decode_cle:
	mov	ecx, 5636352				; 00560100H
$LL16@decode_cle:
	test	ebx, ebx
	jne	SHORT $LN76@decode_cle
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN77@decode_cle
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN79@decode_cle
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN78@decode_cle
$LN79@decode_cle:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN78@decode_cle
$LN77@decode_cle:
	inc	eax
$LN78@decode_cle:
	add	edi, esi
$LN76@decode_cle:
	add	ecx, ecx
	add	edi, edi
	dec	ebx
	cmp	ecx, 8388608				; 00800000H
	jl	SHORT $LL16@decode_cle
	lea	edx, DWORD PTR [ecx-8388608]
	mov	DWORD PTR _t$1$[ebp], ebx
	cmp	edi, edx
	cmovl	edx, edi
	sub	ecx, edx
	mov	DWORD PTR _D$2$[ebp], edx
	mov	DWORD PTR _A$1$[ebp], ecx
	sub	edi, edx
$LN71@decode_cle:

; 691  :             cword = *cp;
; 692  :             switch (sym) {

	mov	ecx, DWORD PTR _sym$2$[ebp]
	mov	DWORD PTR _cword$1$[ebp], 0
	cmp	ecx, 3
	ja	SHORT $LN335@decode_cle
	jmp	DWORD PTR $LN363@decode_cle[ecx*4]
$LN335@decode_cle:
	mov	ecx, DWORD PTR tv1195[ebp]
$LN17@decode_cle:

; 693  :               case 0: goto row_0_significant;
; 694  :               case 1: goto row_1_significant;
; 695  :               case 2: goto row_2_significant;
; 696  :               case 3: goto row_3_significant;
; 697  :               }
; 698  :           }
; 699  :         cword = *cp;

	mov	DWORD PTR _cword$1$[ebp], ecx

; 700  :         if (!(cword & (CLEANUP_MEMBER_MASK<<0)))

	test	ecx, 3145744				; 00300010H
	jne	$row_1$364

; 701  :           { // Process first row of stripe column (row 0)
; 702  :             state_ref = states+KAPPA_SIG_BASE+sig_lut[cword & NBRHD_MASK];

	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8]

; 703  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR _D$2$[ebp]
	mov	DWORD PTR _state_ref$1$[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	sub	edx, ecx
	mov	DWORD PTR _D$7$[ebp], ecx
	and	ecx, 1
	add	edx, ecx
	mov	DWORD PTR _sym$3$[ebp], ecx
	mov	DWORD PTR _D$2$[ebp], edx
	jns	$LN91@decode_cle
	mov	ecx, DWORD PTR _A$1$[ebp]
	add	edi, edx
	add	ecx, edx
	mov	edx, DWORD PTR _D$7$[ebp]
	sub	edx, DWORD PTR _sym$3$[ebp]
	mov	DWORD PTR _A$1$[ebp], ecx
	mov	DWORD PTR _D$7$[ebp], edx
	test	edi, edi
	js	SHORT $LN92@decode_cle
	cmp	ecx, edx
	jge	SHORT $LN94@decode_cle
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$3$[ebp]
	mov	DWORD PTR _sym$3$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$1$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1119[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1119[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL21@decode_cle
$LN94@decode_cle:
	mov	ecx, DWORD PTR _state_ref$1$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1121[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1121[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL21@decode_cle
$LN92@decode_cle:
	add	edi, edx
	cmp	ecx, edx
	jge	SHORT $LN96@decode_cle
	mov	ecx, DWORD PTR _state_ref$1$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1122[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1122[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN354@decode_cle
$LN96@decode_cle:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$3$[ebp]
	mov	DWORD PTR _sym$3$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$1$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1123[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1123[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN354@decode_cle:
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _D$7$[ebp]
$LL21@decode_cle:
	test	ebx, ebx
	jne	SHORT $LN98@decode_cle
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN99@decode_cle
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN101@decode_cle
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN100@decode_cle
$LN101@decode_cle:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN100@decode_cle
$LN99@decode_cle:
	inc	eax
$LN100@decode_cle:
	add	edi, esi
$LN98@decode_cle:
	add	edx, edx
	add	edi, edi
	dec	ebx
	cmp	edx, 8388608				; 00800000H
	jl	SHORT $LL21@decode_cle
	lea	ecx, DWORD PTR [edx-8388608]
	mov	DWORD PTR _t$1$[ebp], ebx
	cmp	edi, ecx
	cmovl	ecx, edi
	sub	edx, ecx
	mov	DWORD PTR _D$2$[ebp], ecx
	sub	edi, ecx
	mov	DWORD PTR _A$1$[ebp], edx
	mov	ecx, DWORD PTR _sym$3$[ebp]
$LN91@decode_cle:

; 704  :             if (!sym)

	test	ecx, ecx
	je	$LN339@decode_cle
$row_0_significant$365:

; 705  :               goto row_1;
; 706  : row_0_significant:
; 707  :             // Decode sign bit
; 708  :             sym = cword & ((CHI_BIT>>3) | (SIGMA_CC_BIT>>3) |
; 709  :                            (CHI_BIT<<3) | (SIGMA_CC_BIT<<3));
; 710  :             sym >>= 1; // Shift down so that top sigma bit has address 0
; 711  :             sym |= (cp[-1] & ((CHI_BIT<<0) | (SIGMA_CC_BIT<<0))) >> (1+1);
; 712  :             sym |= (cp[ 1] & ((CHI_BIT<<0) | (SIGMA_CC_BIT<<0))) >> (1-1);

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR _cword$1$[ebp]
	and	ecx, 17039490				; 01040082H
	sar	edx, 1
	and	edx, 1048584				; 00100008H
	or	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	sar	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 2097168				; 00200010H
	or	edx, ecx

; 713  :             sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma

	mov	ecx, edx
	sar	ecx, 16					; 00000010H

; 714  :             val = sign_lut[sym & 0x000000FF];

	or	ecx, edx

; 715  :             state_ref = states + KAPPA_SIGN_BASE + (val>>1);

	mov	edx, DWORD PTR _states$[ebp]
	movzx	ecx, cl
	add	edx, 80					; 00000050H
	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _val$1$[ebp], ecx
	sar	ecx, 1
	lea	ecx, DWORD PTR [edx+ecx*8]

; 716  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _state_ref$2$[ebp], ecx
	mov	ecx, DWORD PTR _D$2$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _D$9$[ebp], edx
	and	edx, 1
	add	ecx, edx
	mov	DWORD PTR _sym$5$[ebp], edx
	mov	DWORD PTR _D$2$[ebp], ecx
	jns	$LN106@decode_cle
	mov	edx, DWORD PTR _A$1$[ebp]
	add	edi, ecx
	add	edx, ecx
	mov	ecx, DWORD PTR _D$9$[ebp]
	sub	ecx, DWORD PTR _sym$5$[ebp]
	mov	DWORD PTR _A$1$[ebp], edx
	mov	DWORD PTR _D$9$[ebp], ecx
	test	edi, edi
	js	SHORT $LN107@decode_cle
	cmp	edx, ecx
	jge	SHORT $LN109@decode_cle
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$5$[ebp]
	mov	DWORD PTR _sym$5$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1124[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1124[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL24@decode_cle
$LN109@decode_cle:
	mov	ecx, DWORD PTR _state_ref$2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1125[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1125[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL24@decode_cle
$LN107@decode_cle:
	add	edi, ecx
	cmp	edx, ecx
	jge	SHORT $LN111@decode_cle
	mov	ecx, DWORD PTR _state_ref$2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1126[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1126[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN355@decode_cle
$LN111@decode_cle:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$5$[ebp]
	mov	DWORD PTR _sym$5$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1128[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1128[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN355@decode_cle:
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _D$9$[ebp]
$LL24@decode_cle:
	test	ebx, ebx
	jne	SHORT $LN113@decode_cle
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN114@decode_cle
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN116@decode_cle
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN115@decode_cle
$LN116@decode_cle:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN115@decode_cle
$LN114@decode_cle:
	inc	eax
$LN115@decode_cle:
	add	edi, esi
$LN113@decode_cle:
	add	edx, edx
	add	edi, edi
	dec	ebx
	cmp	edx, 8388608				; 00800000H
	jl	SHORT $LL24@decode_cle
	lea	ecx, DWORD PTR [edx-8388608]
	mov	DWORD PTR _t$1$[ebp], ebx
	cmp	edi, ecx
	cmovl	ecx, edi
	sub	edx, ecx
	mov	DWORD PTR _D$2$[ebp], ecx
	mov	DWORD PTR _A$1$[ebp], edx
	sub	edi, ecx
	mov	edx, DWORD PTR _sym$5$[ebp]
$LN106@decode_cle:

; 717  :             sym ^= (val & 1); // Sign bit recovered in LSB.

	mov	ecx, DWORD PTR _val$1$[ebp]
	and	ecx, 1
	xor	edx, ecx

; 718  :             // Broadcast neighbourhood context changes
; 719  :             if (!causal)

	cmp	BYTE PTR _causal$[ebp], 0
	mov	DWORD PTR _sym$5$[ebp], edx
	jne	SHORT $LN119@decode_cle

; 720  :               {
; 721  :                 cp[-context_row_gap-1] |=(SIGMA_BR_BIT<<9);

	mov	ecx, DWORD PTR _context_row_gap$[ebp]
	mov	edx, DWORD PTR _contexts$[ebp]
	shl	ecx, 2
	sub	edx, ecx

; 722  :                 cp[-context_row_gap  ] |=(SIGMA_BC_BIT<<9)|(sym<<NEXT_CHI_POS);

	mov	ecx, DWORD PTR _sym$5$[ebp]
	shl	ecx, 31					; 0000001fH
	or	ecx, 65536				; 00010000H
	or	DWORD PTR [edx-4], 131072		; 00020000H
	or	DWORD PTR [edx], ecx

; 723  :                 cp[-context_row_gap+1] |=(SIGMA_BL_BIT<<9);

	or	DWORD PTR [edx+4], 32768		; 00008000H
	mov	edx, DWORD PTR _sym$5$[ebp]
$LN119@decode_cle:

; 724  :               }
; 725  :             cp[-1] |= (SIGMA_CR_BIT<<0);

	mov	ecx, DWORD PTR _contexts$[ebp]
	or	DWORD PTR [ecx-4], 32			; 00000020H

; 726  :             cp[1]  |= (SIGMA_CL_BIT<<0);

	or	DWORD PTR [ecx+4], 8

; 727  :             cword |= (SIGMA_CC_BIT<<0) | (sym<<CHI_POS);

	mov	ecx, edx
	shl	ecx, 21					; 00000015H
	or	ecx, 16					; 00000010H
	or	DWORD PTR _cword$1$[ebp], ecx

; 728  :             sp[0] = (sym<<31) + one_point_five;

	imul	ecx, edx, -2147483648
	mov	edx, DWORD PTR _samples$[ebp]
	add	ecx, DWORD PTR _one_point_five$1$[ebp]
	mov	DWORD PTR [edx], ecx
$LN339@decode_cle:
	mov	ecx, DWORD PTR _cword$1$[ebp]
$row_1$364:

; 729  :           }
; 730  : row_1:
; 731  :         if (!(cword & (CLEANUP_MEMBER_MASK<<3)))

	test	ecx, 25165952				; 01800080H
	jne	$row_2$366

; 732  :           { // Process second row of stripe column (row 1)
; 733  :             state_ref = states+KAPPA_SIG_BASE+sig_lut[(cword>>3) & NBRHD_MASK];

	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	sar	ecx, 3
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8]

; 734  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _state_ref$3$[ebp], ecx
	mov	ecx, DWORD PTR _D$2$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _D$11$[ebp], edx
	and	edx, 1
	add	ecx, edx
	mov	DWORD PTR _sym$6$[ebp], edx
	mov	DWORD PTR _D$2$[ebp], ecx
	jns	$LN121@decode_cle
	mov	edx, DWORD PTR _A$1$[ebp]
	add	edi, ecx
	add	edx, ecx
	mov	ecx, DWORD PTR _D$11$[ebp]
	sub	ecx, DWORD PTR _sym$6$[ebp]
	mov	DWORD PTR _A$1$[ebp], edx
	mov	DWORD PTR _D$11$[ebp], ecx
	test	edi, edi
	js	SHORT $LN122@decode_cle
	cmp	edx, ecx
	jge	SHORT $LN124@decode_cle
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$6$[ebp]
	mov	DWORD PTR _sym$6$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$3$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1129[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1129[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL27@decode_cle
$LN124@decode_cle:
	mov	ecx, DWORD PTR _state_ref$3$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1131[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1131[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL27@decode_cle
$LN122@decode_cle:
	add	edi, ecx
	cmp	edx, ecx
	jge	SHORT $LN126@decode_cle
	mov	ecx, DWORD PTR _state_ref$3$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1132[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1132[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN356@decode_cle
$LN126@decode_cle:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$6$[ebp]
	mov	DWORD PTR _sym$6$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$3$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1133[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1133[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN356@decode_cle:
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _D$11$[ebp]
$LL27@decode_cle:
	test	ebx, ebx
	jne	SHORT $LN128@decode_cle
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN129@decode_cle
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN131@decode_cle
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN130@decode_cle
$LN131@decode_cle:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN130@decode_cle
$LN129@decode_cle:
	inc	eax
$LN130@decode_cle:
	add	edi, esi
$LN128@decode_cle:
	add	edx, edx
	add	edi, edi
	dec	ebx
	cmp	edx, 8388608				; 00800000H
	jl	SHORT $LL27@decode_cle
	lea	ecx, DWORD PTR [edx-8388608]
	mov	DWORD PTR _t$1$[ebp], ebx
	cmp	edi, ecx
	cmovl	ecx, edi
	sub	edx, ecx
	mov	DWORD PTR _D$2$[ebp], ecx
	mov	DWORD PTR _A$1$[ebp], edx
	sub	edi, ecx
	mov	edx, DWORD PTR _sym$6$[ebp]
$LN121@decode_cle:

; 735  :             if (!sym)

	test	edx, edx
	je	$LN338@decode_cle
$row_1_significant$367:

; 736  :               goto row_2;
; 737  : row_1_significant:
; 738  :             // Decode sign bit
; 739  :             sym = cword & ((CHI_BIT<<0) | (SIGMA_CC_BIT<<0) |
; 740  :                            (CHI_BIT<<6) | (SIGMA_CC_BIT<<6));
; 741  :             sym >>= 4; // Shift down so that top sigma bit has address 0
; 742  :             sym |= (cp[-1] & ((CHI_BIT<<3) | (SIGMA_CC_BIT<<3))) >> (4+1);
; 743  :             sym |= (cp[ 1] & ((CHI_BIT<<3) | (SIGMA_CC_BIT<<3))) >> (4-1);

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR _cword$1$[ebp]
	and	ecx, 136315920				; 08200410H
	sar	edx, 1
	and	edx, 8388672				; 00800040H
	or	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	sar	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 16777344				; 01000080H
	or	edx, ecx
	sar	edx, 3

; 744  :             sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma

	mov	ecx, edx
	sar	ecx, 16					; 00000010H

; 745  :             val = sign_lut[sym & 0x000000FF];

	or	ecx, edx

; 746  :             state_ref = states + KAPPA_SIGN_BASE + (val>>1);

	mov	edx, DWORD PTR _states$[ebp]
	movzx	ecx, cl
	add	edx, 80					; 00000050H
	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _val$2$[ebp], ecx
	sar	ecx, 1
	lea	ecx, DWORD PTR [edx+ecx*8]

; 747  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _state_ref$4$[ebp], ecx
	mov	ecx, DWORD PTR _D$2$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _D$13$[ebp], edx
	and	edx, 1
	add	ecx, edx
	mov	DWORD PTR _sym$8$[ebp], edx
	mov	DWORD PTR _D$2$[ebp], ecx
	jns	$LN136@decode_cle
	mov	edx, DWORD PTR _A$1$[ebp]
	add	edi, ecx
	add	edx, ecx
	mov	ecx, DWORD PTR _D$13$[ebp]
	sub	ecx, DWORD PTR _sym$8$[ebp]
	mov	DWORD PTR _A$1$[ebp], edx
	mov	DWORD PTR _D$13$[ebp], ecx
	test	edi, edi
	js	SHORT $LN137@decode_cle
	cmp	edx, ecx
	jge	SHORT $LN139@decode_cle
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$8$[ebp]
	mov	DWORD PTR _sym$8$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$4$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1134[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1134[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL30@decode_cle
$LN139@decode_cle:
	mov	ecx, DWORD PTR _state_ref$4$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1153[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1153[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL30@decode_cle
$LN137@decode_cle:
	add	edi, ecx
	cmp	edx, ecx
	jge	SHORT $LN141@decode_cle
	mov	ecx, DWORD PTR _state_ref$4$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1155[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1155[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN357@decode_cle
$LN141@decode_cle:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$8$[ebp]
	mov	DWORD PTR _sym$8$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$4$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1157[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1157[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN357@decode_cle:
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _D$13$[ebp]
$LL30@decode_cle:
	test	ebx, ebx
	jne	SHORT $LN143@decode_cle
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN144@decode_cle
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN146@decode_cle
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN145@decode_cle
$LN146@decode_cle:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN145@decode_cle
$LN144@decode_cle:
	inc	eax
$LN145@decode_cle:
	add	edi, esi
$LN143@decode_cle:
	add	edx, edx
	add	edi, edi
	dec	ebx
	cmp	edx, 8388608				; 00800000H
	jl	SHORT $LL30@decode_cle
	lea	ecx, DWORD PTR [edx-8388608]
	mov	DWORD PTR _t$1$[ebp], ebx
	cmp	edi, ecx
	cmovl	ecx, edi
	sub	edx, ecx
	mov	DWORD PTR _D$2$[ebp], ecx
	mov	DWORD PTR _A$1$[ebp], edx
	sub	edi, ecx
	mov	edx, DWORD PTR _sym$8$[ebp]
$LN136@decode_cle:

; 748  :             sym ^= (val & 1); // Sign bit recovered in LSB.

	mov	ecx, DWORD PTR _val$2$[ebp]

; 749  :             // Broadcast neighbourhood context changes
; 750  :             cp[-1] |= (SIGMA_CR_BIT<<3);
; 751  :             cp[1]  |= (SIGMA_CL_BIT<<3);
; 752  :             cword |= (SIGMA_CC_BIT<<3) | (sym<<(CHI_POS+3));
; 753  :             sp[width] = (sym<<31) + one_point_five;

	mov	ebx, DWORD PTR _width$[ebp]
	and	ecx, 1
	xor	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	or	DWORD PTR [ecx-4], 256			; 00000100H
	or	DWORD PTR [ecx+4], 64			; 00000040H
	mov	ecx, edx
	shl	ecx, 24					; 00000018H
	or	ecx, 128				; 00000080H
	or	DWORD PTR _cword$1$[ebp], ecx
	imul	ecx, edx, -2147483648
	mov	edx, DWORD PTR _samples$[ebp]
	add	ecx, DWORD PTR _one_point_five$1$[ebp]
	mov	DWORD PTR [edx+ebx*4], ecx
	mov	ebx, DWORD PTR _t$1$[ebp]
$LN338@decode_cle:
	mov	ecx, DWORD PTR _cword$1$[ebp]
$row_2$366:

; 754  :           }
; 755  : row_2:
; 756  :         if (!(cword & (CLEANUP_MEMBER_MASK<<6)))

	test	ecx, 201327616				; 0c000400H
	jne	$row_3$368

; 757  :           { // Process third row of stripe column (row 2)
; 758  :             state_ref = states+KAPPA_SIG_BASE+sig_lut[(cword>>6) & NBRHD_MASK];

	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	sar	ecx, 6
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8]

; 759  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _state_ref$5$[ebp], ecx
	mov	ecx, DWORD PTR _D$2$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _D$15$[ebp], edx
	and	edx, 1
	add	ecx, edx
	mov	DWORD PTR _sym$9$[ebp], edx
	mov	DWORD PTR _D$2$[ebp], ecx
	jns	$LN150@decode_cle
	mov	edx, DWORD PTR _A$1$[ebp]
	add	edi, ecx
	add	edx, ecx
	mov	ecx, DWORD PTR _D$15$[ebp]
	sub	ecx, DWORD PTR _sym$9$[ebp]
	mov	DWORD PTR _A$1$[ebp], edx
	mov	DWORD PTR _D$15$[ebp], ecx
	test	edi, edi
	js	SHORT $LN151@decode_cle
	cmp	edx, ecx
	jge	SHORT $LN153@decode_cle
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$9$[ebp]
	mov	DWORD PTR _sym$9$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$5$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1161[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1161[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	$LL33@decode_cle
$LN153@decode_cle:
	mov	ecx, DWORD PTR _state_ref$5$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1162[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1162[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL33@decode_cle
$LN151@decode_cle:
	add	edi, ecx
	cmp	edx, ecx
	jge	SHORT $LN155@decode_cle
	mov	ecx, DWORD PTR _state_ref$5$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1165[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1165[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN358@decode_cle
$LN155@decode_cle:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$9$[ebp]
	mov	DWORD PTR _sym$9$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$5$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1167[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1167[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN358@decode_cle:
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _D$15$[ebp]
	npad	2
$LL33@decode_cle:
	test	ebx, ebx
	jne	SHORT $LN157@decode_cle
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN158@decode_cle
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN160@decode_cle
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN159@decode_cle
$LN160@decode_cle:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN159@decode_cle
$LN158@decode_cle:
	inc	eax
$LN159@decode_cle:
	add	edi, esi
$LN157@decode_cle:
	add	edx, edx
	add	edi, edi
	dec	ebx
	cmp	edx, 8388608				; 00800000H
	jl	SHORT $LL33@decode_cle
	lea	ecx, DWORD PTR [edx-8388608]
	mov	DWORD PTR _t$1$[ebp], ebx
	cmp	edi, ecx
	cmovl	ecx, edi
	sub	edx, ecx
	mov	DWORD PTR _D$2$[ebp], ecx
	mov	DWORD PTR _A$1$[ebp], edx
	sub	edi, ecx
	mov	edx, DWORD PTR _sym$9$[ebp]
$LN150@decode_cle:

; 760  :             if (!sym)

	test	edx, edx
	je	$LN337@decode_cle
$row_2_significant$369:

; 761  :               goto row_3;
; 762  : row_2_significant:
; 763  :             // Decode sign bit
; 764  :             sym = cword & ((CHI_BIT<<3) | (SIGMA_CC_BIT<<3) |
; 765  :                            (CHI_BIT<<9) | (SIGMA_CC_BIT<<9));
; 766  :             sym >>= 7; // Shift down so that top sigma bit has address 0
; 767  :             sym |= (cp[-1] & ((CHI_BIT<<6) | (SIGMA_CC_BIT<<6))) >> (7+1);
; 768  :             sym |= (cp[ 1] & ((CHI_BIT<<6) | (SIGMA_CC_BIT<<6))) >> (7-1);

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR _cword$1$[ebp]
	and	ecx, 1090527360				; 41002080H
	sar	edx, 1
	and	edx, 67109376				; 04000200H
	or	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	sar	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 134218752				; 08000400H
	or	edx, ecx
	sar	edx, 6

; 769  :             sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma

	mov	ecx, edx
	sar	ecx, 16					; 00000010H

; 770  :             val = sign_lut[sym & 0x000000FF];

	or	ecx, edx

; 771  :             state_ref = states + KAPPA_SIGN_BASE + (val>>1);

	mov	edx, DWORD PTR _states$[ebp]
	movzx	ecx, cl
	add	edx, 80					; 00000050H
	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _val$3$[ebp], ecx
	sar	ecx, 1
	lea	ecx, DWORD PTR [edx+ecx*8]

; 772  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _state_ref$6$[ebp], ecx
	mov	ecx, DWORD PTR _D$2$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _D$17$[ebp], edx
	and	edx, 1
	add	ecx, edx
	mov	DWORD PTR _sym$11$[ebp], edx
	mov	DWORD PTR _D$2$[ebp], ecx
	jns	$LN165@decode_cle
	mov	edx, DWORD PTR _A$1$[ebp]
	add	edi, ecx
	add	edx, ecx
	mov	ecx, DWORD PTR _D$17$[ebp]
	sub	ecx, DWORD PTR _sym$11$[ebp]
	mov	DWORD PTR _A$1$[ebp], edx
	mov	DWORD PTR _D$17$[ebp], ecx
	test	edi, edi
	js	SHORT $LN166@decode_cle
	cmp	edx, ecx
	jge	SHORT $LN168@decode_cle
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$11$[ebp]
	mov	DWORD PTR _sym$11$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$6$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1168[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1168[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	$LL36@decode_cle
$LN168@decode_cle:
	mov	ecx, DWORD PTR _state_ref$6$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1176[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1176[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL36@decode_cle
$LN166@decode_cle:
	add	edi, ecx
	cmp	edx, ecx
	jge	SHORT $LN170@decode_cle
	mov	ecx, DWORD PTR _state_ref$6$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1177[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1177[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN359@decode_cle
$LN170@decode_cle:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$11$[ebp]
	mov	DWORD PTR _sym$11$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$6$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1182[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1182[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN359@decode_cle:
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _D$17$[ebp]
$LL36@decode_cle:
	test	ebx, ebx
	jne	SHORT $LN172@decode_cle
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN173@decode_cle
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN175@decode_cle
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN174@decode_cle
$LN175@decode_cle:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN174@decode_cle
$LN173@decode_cle:
	inc	eax
$LN174@decode_cle:
	add	edi, esi
$LN172@decode_cle:
	add	edx, edx
	add	edi, edi
	dec	ebx
	cmp	edx, 8388608				; 00800000H
	jl	SHORT $LL36@decode_cle
	lea	ecx, DWORD PTR [edx-8388608]
	mov	DWORD PTR _t$1$[ebp], ebx
	cmp	edi, ecx
	cmovl	ecx, edi
	sub	edx, ecx
	mov	DWORD PTR _D$2$[ebp], ecx
	mov	DWORD PTR _A$1$[ebp], edx
	sub	edi, ecx
	mov	edx, DWORD PTR _sym$11$[ebp]
$LN165@decode_cle:

; 773  :             sym ^= (val & 1); // Sign bit recovered in LSB.

	mov	ecx, DWORD PTR _val$3$[ebp]

; 774  :             // Broadcast neighbourhood context changes
; 775  :             cp[-1] |= (SIGMA_CR_BIT<<6);
; 776  :             cp[1]  |= (SIGMA_CL_BIT<<6);
; 777  :             cword |= (SIGMA_CC_BIT<<6) | (sym << (CHI_POS+6));
; 778  :             sp[width_by2] = (sym<<31) + one_point_five;

	mov	ebx, DWORD PTR _width_by2$1$[ebp]
	and	ecx, 1
	xor	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	or	DWORD PTR [ecx-4], 2048			; 00000800H
	or	DWORD PTR [ecx+4], 512			; 00000200H
	mov	ecx, edx
	shl	ecx, 27					; 0000001bH
	or	ecx, 1024				; 00000400H
	or	DWORD PTR _cword$1$[ebp], ecx
	imul	ecx, edx, -2147483648
	mov	edx, DWORD PTR _samples$[ebp]
	add	ecx, DWORD PTR _one_point_five$1$[ebp]
	mov	DWORD PTR [edx+ebx*4], ecx
	mov	ebx, DWORD PTR _t$1$[ebp]
$LN337@decode_cle:
	mov	ecx, DWORD PTR _cword$1$[ebp]
$row_3$368:

; 779  :           }
; 780  : row_3:
; 781  :         if (!(cword & (CLEANUP_MEMBER_MASK<<9)))

	test	ecx, 1610620928				; 60002000H
	jne	$done$370

; 782  :           { // Process fourth row of stripe column (row 3)
; 783  :             state_ref = states+KAPPA_SIG_BASE+sig_lut[(cword>>9) & NBRHD_MASK];

	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	sar	ecx, 9
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8]

; 784  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _state_ref$7$[ebp], ecx
	mov	ecx, DWORD PTR _D$2$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _D$19$[ebp], edx
	and	edx, 1
	add	ecx, edx
	mov	DWORD PTR _sym$12$[ebp], edx
	mov	DWORD PTR _D$2$[ebp], ecx
	jns	$LN179@decode_cle
	mov	edx, DWORD PTR _A$1$[ebp]
	add	edi, ecx
	add	edx, ecx
	mov	ecx, DWORD PTR _D$19$[ebp]
	sub	ecx, DWORD PTR _sym$12$[ebp]
	mov	DWORD PTR _A$1$[ebp], edx
	mov	DWORD PTR _D$19$[ebp], ecx
	test	edi, edi
	js	SHORT $LN180@decode_cle
	cmp	edx, ecx
	jge	SHORT $LN182@decode_cle
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$12$[ebp]
	mov	DWORD PTR _sym$12$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$7$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1184[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1184[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	$LL39@decode_cle
$LN182@decode_cle:
	mov	ecx, DWORD PTR _state_ref$7$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1185[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1185[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL39@decode_cle
$LN180@decode_cle:
	add	edi, ecx
	cmp	edx, ecx
	jge	SHORT $LN184@decode_cle
	mov	ecx, DWORD PTR _state_ref$7$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1186[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1186[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN360@decode_cle
$LN184@decode_cle:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$12$[ebp]
	mov	DWORD PTR _sym$12$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$7$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1187[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1187[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN360@decode_cle:
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _D$19$[ebp]
$LL39@decode_cle:
	test	ebx, ebx
	jne	SHORT $LN186@decode_cle
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN187@decode_cle
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN189@decode_cle
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN188@decode_cle
$LN189@decode_cle:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN188@decode_cle
$LN187@decode_cle:
	inc	eax
$LN188@decode_cle:
	add	edi, esi
$LN186@decode_cle:
	add	edx, edx
	add	edi, edi
	dec	ebx
	cmp	edx, 8388608				; 00800000H
	jl	SHORT $LL39@decode_cle
	lea	ecx, DWORD PTR [edx-8388608]
	mov	DWORD PTR _t$1$[ebp], ebx
	cmp	edi, ecx
	cmovl	ecx, edi
	sub	edx, ecx
	mov	DWORD PTR _D$2$[ebp], ecx
	mov	DWORD PTR _A$1$[ebp], edx
	sub	edi, ecx
	mov	edx, DWORD PTR _sym$12$[ebp]
$LN179@decode_cle:

; 785  :             if (!sym)

	test	edx, edx
	je	$LN336@decode_cle
$row_3_significant$371:

; 786  :               goto done;
; 787  : row_3_significant:
; 788  :             // Decode sign bit
; 789  :             sym = cword & ((CHI_BIT<<6) | (SIGMA_CC_BIT<<6) |
; 790  :                                 0       | (SIGMA_CC_BIT<<12));
; 791  :             sym >>= 10; // Shift down so that top sigma bit has address 0

	mov	edx, DWORD PTR _cword$1$[ebp]
	mov	ecx, edx
	sar	ecx, 10					; 0000000aH
	and	ecx, 131137				; 00020041H
	mov	DWORD PTR _sym$13$[ebp], ecx

; 792  :             if (cword < 0) // Use the fact that NEXT_CHI_BIT = 31

	test	edx, edx
	jns	SHORT $LN194@decode_cle

; 793  :               sym |= CHI_BIT<<(12-10);

	or	ecx, 8388608				; 00800000H
	mov	DWORD PTR _sym$13$[ebp], ecx
$LN194@decode_cle:

; 794  :             sym |= (cp[-1] & ((CHI_BIT<<9) | (SIGMA_CC_BIT<<9))) >> (10+1);
; 795  :             sym |= (cp[ 1] & ((CHI_BIT<<9) | (SIGMA_CC_BIT<<9))) >> (10-1);

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 1073750016				; 40002000H
	sar	edx, 2
	and	edx, 268437504				; 10000800H
	or	edx, ecx
	mov	ecx, DWORD PTR _sym$13$[ebp]
	sar	edx, 9
	or	ecx, edx

; 796  :             sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma
; 797  :             val = sign_lut[sym & 0x000000FF];
; 798  :             state_ref = states + KAPPA_SIGN_BASE + (val>>1);

	mov	edx, DWORD PTR _states$[ebp]
	mov	DWORD PTR _sym$13$[ebp], ecx
	add	edx, 80					; 00000050H
	sar	ecx, 16					; 00000010H
	or	ecx, DWORD PTR _sym$13$[ebp]
	movzx	ecx, cl
	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _val$4$[ebp], ecx
	sar	ecx, 1
	lea	ecx, DWORD PTR [edx+ecx*8]

; 799  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _state_ref$8$[ebp], ecx
	mov	ecx, DWORD PTR _D$2$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _D$21$[ebp], edx
	and	edx, 1
	add	ecx, edx
	mov	DWORD PTR _sym$14$[ebp], edx
	mov	DWORD PTR _D$2$[ebp], ecx
	jns	$LN195@decode_cle
	mov	edx, DWORD PTR _A$1$[ebp]
	add	edi, ecx
	add	edx, ecx
	mov	ecx, DWORD PTR _D$21$[ebp]
	sub	ecx, DWORD PTR _sym$14$[ebp]
	mov	DWORD PTR _A$1$[ebp], edx
	mov	DWORD PTR _D$21$[ebp], ecx
	test	edi, edi
	js	SHORT $LN196@decode_cle
	cmp	edx, ecx
	jge	SHORT $LN198@decode_cle
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$14$[ebp]
	mov	DWORD PTR _sym$14$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$8$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1188[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1188[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	$LL42@decode_cle
$LN198@decode_cle:
	mov	ecx, DWORD PTR _state_ref$8$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1190[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1190[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL42@decode_cle
$LN196@decode_cle:
	add	edi, ecx
	cmp	edx, ecx
	jge	SHORT $LN200@decode_cle
	mov	ecx, DWORD PTR _state_ref$8$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1192[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1192[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN361@decode_cle
$LN200@decode_cle:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$14$[ebp]
	mov	DWORD PTR _sym$14$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$8$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1193[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1193[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN361@decode_cle:
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _D$21$[ebp]
	npad	6
$LL42@decode_cle:
	test	ebx, ebx
	jne	SHORT $LN202@decode_cle
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN203@decode_cle
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN205@decode_cle
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN204@decode_cle
$LN205@decode_cle:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN204@decode_cle
$LN203@decode_cle:
	inc	eax
$LN204@decode_cle:
	add	edi, esi
$LN202@decode_cle:
	add	edx, edx
	add	edi, edi
	dec	ebx
	cmp	edx, 8388608				; 00800000H
	jl	SHORT $LL42@decode_cle
	lea	ecx, DWORD PTR [edx-8388608]
	mov	DWORD PTR _t$1$[ebp], ebx
	cmp	edi, ecx
	cmovl	ecx, edi
	sub	edx, ecx
	mov	DWORD PTR _D$2$[ebp], ecx
	mov	DWORD PTR _A$1$[ebp], edx
	sub	edi, ecx
	mov	edx, DWORD PTR _sym$14$[ebp]
$LN195@decode_cle:

; 800  :             sym ^= (val & 1); // Sign bit recovered in LSB.

	mov	ecx, DWORD PTR _val$4$[ebp]

; 801  :             // Broadcast neighbourhood context changes
; 802  :             cp[context_row_gap-1] |= SIGMA_TR_BIT;

	mov	ebx, DWORD PTR _context_row_gap$[ebp]
	and	ecx, 1
	xor	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	DWORD PTR _sym$14$[ebp], edx
	or	DWORD PTR [ecx+ebx*4-4], 4

; 803  :             cp[context_row_gap  ] |= SIGMA_TC_BIT | (sym<<PREV_CHI_POS);

	mov	ecx, edx
	mov	edx, DWORD PTR _contexts$[ebp]
	shl	ecx, 18					; 00000012H
	or	ecx, 2
	or	DWORD PTR [edx+ebx*4], ecx

; 804  :             cp[context_row_gap+1] |= SIGMA_TL_BIT;

	mov	ecx, edx
	mov	edx, ebx

; 805  :             cp[-1] |= (SIGMA_CR_BIT<<9);
; 806  :             cp[1]  |= (SIGMA_CL_BIT<<9);
; 807  :             cword |= (SIGMA_CC_BIT<<9) | (sym<<(CHI_POS+9));
; 808  :             sp[width_by3] = (sym<<31) + one_point_five;

	mov	ebx, DWORD PTR tv1042[ebp]
	or	DWORD PTR [ecx+edx*4+4], 1
	or	DWORD PTR [ecx-4], 16384		; 00004000H
	or	DWORD PTR [ecx+4], 4096			; 00001000H
	mov	ecx, DWORD PTR _sym$14$[ebp]
	mov	edx, DWORD PTR _samples$[ebp]
	shl	ecx, 30					; 0000001eH
	or	ecx, 8192				; 00002000H
	or	DWORD PTR _cword$1$[ebp], ecx
	imul	ecx, DWORD PTR _sym$14$[ebp], -2147483648
	add	ecx, DWORD PTR _one_point_five$1$[ebp]
	mov	DWORD PTR [ebx+edx], ecx
	mov	ebx, DWORD PTR _t$1$[ebp]
$LN336@decode_cle:
	mov	ecx, DWORD PTR _cword$1$[ebp]
$done$370:

; 809  :           }
; 810  : done:
; 811  :         cword |= (cword << (MU_POS - SIGMA_CC_POS)) &
; 812  :                  ((MU_BIT<<0)|(MU_BIT<<3)|(MU_BIT<<6)|(MU_BIT<<9));
; 813  :         cword &= ~((PI_BIT<<0)|(PI_BIT<<3)|(PI_BIT<<6)|(PI_BIT<<9));
; 814  :         *cp = cword;

	mov	edx, DWORD PTR _contexts$[ebp]
	and	ecx, 9360				; 00002490H
	shl	ecx, 15					; 0000000fH
	or	ecx, DWORD PTR _cword$1$[ebp]
	and	ecx, -613416961				; db6fffffH
	mov	DWORD PTR [edx], ecx
$LN340@decode_cle:
	mov	edx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR _contexts$[ebp]
$LN5@decode_cle:

; 671  :     for (c=width; c > 0; c--, sp++, cp++)

	dec	DWORD PTR _c$1$[ebp]
	add	edx, 4
	add	ecx, 4
	mov	DWORD PTR _samples$[ebp], edx
	cmp	DWORD PTR _c$1$[ebp], 0
	mov	edx, DWORD PTR _D$2$[ebp]
	mov	DWORD PTR _contexts$[ebp], ecx
	jg	$LL7@decode_cle
$LN2@decode_cle:

; 667  :   int r, width_by2=width+width, width_by3=width_by2+width;
; 668  : 
; 669  :   assert((context_row_gap - width) == EXTRA_DECODE_CWORDS);
; 670  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_DECODE_CWORDS, sp += width_by3)

	mov	ebx, DWORD PTR tv1042[ebp]
	add	ecx, 12					; 0000000cH
	dec	DWORD PTR _num_stripes$[ebp]
	add	DWORD PTR _samples$[ebp], ebx
	cmp	DWORD PTR _num_stripes$[ebp], 0
	mov	ebx, DWORD PTR _t$1$[ebp]
	mov	DWORD PTR _contexts$[ebp], ecx
	jg	$LL4@decode_cle
$LN3@decode_cle:

; 817  :   states[KAPPA_RUN_BASE] = run_state;

	mov	edx, DWORD PTR _states$[ebp]
	mov	ecx, DWORD PTR _run_state$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 161  :         this->A = A+D; this->C = C+D;

	mov	ebx, DWORD PTR _coder$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 817  :   states[KAPPA_RUN_BASE] = run_state;

	mov	DWORD PTR [edx+72], ecx
	mov	ecx, DWORD PTR _run_state$2$[ebp]
	mov	DWORD PTR [edx+76], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 160  :         assert(active && checked_out && MQ_segment); checked_out = false;

	mov	ecx, DWORD PTR _coder$[ebp]

; 161  :         this->A = A+D; this->C = C+D;

	mov	edx, DWORD PTR _D$2$[ebp]
	mov	BYTE PTR [ecx+28], 0
	mov	ecx, DWORD PTR _A$1$[ebp]
	add	ecx, edx
	mov	DWORD PTR [ebx], ecx
	lea	ecx, DWORD PTR [edi+edx]
	mov	edx, ebx

; 162  :         this->t = t; this->temp = temp; this->buf_next = store; this->S = S;

	mov	ebx, DWORD PTR _t$1$[ebp]
	pop	edi
	mov	DWORD PTR [edx+12], esi
	mov	DWORD PTR [edx+20], eax
	mov	eax, DWORD PTR _S$1$[ebp]
	pop	esi
	mov	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [edx+4], ecx
	mov	DWORD PTR [edx+24], eax
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 819  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN363@decode_cle:
	DD	$row_0_significant$365
	DD	$row_1_significant$367
	DD	$row_2_significant$369
	DD	$row_3_significant$371
?decode_cleanup_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z ENDP ; decode_cleanup_pass
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
;	COMDAT ?decode_mag_ref_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NPAH3HHH@Z
_TEXT	SEGMENT
_val$2$ = -56						; size = 4
_D$8$ = -56						; size = 4
_D$6$ = -56						; size = 4
_val$4$ = -52						; size = 4
_val$3$ = -52						; size = 4
_val$1$ = -52						; size = 4
_D$4$ = -52						; size = 4
_width_by2$1$ = -48					; size = 4
_D$10$ = -44						; size = 4
_D$2$ = -44						; size = 4
tv631 = -40						; size = 4
_c$1$ = -36						; size = 4
_C$1$ = -32						; size = 4
_cword$1$ = -28						; size = 4
_state_ref$4$ = -24					; size = 4
_state_ref$3$ = -24					; size = 4
_state_ref$2$ = -24					; size = 4
_state_ref$1$ = -24					; size = 4
_half_lsb$1$ = -20					; size = 4
_sym$4$ = -16						; size = 4
_sym$3$ = -16						; size = 4
_sym$2$ = -16						; size = 4
_sym$1$ = -16						; size = 4
_S$1$ = -12						; size = 4
_t$1$ = -8						; size = 4
_A$1$ = -4						; size = 4
_coder$ = 8						; size = 4
_states$ = 12						; size = 4
_p$ = 16						; size = 4
_causal$ = 20						; size = 1
_samples$ = 24						; size = 4
_contexts$ = 28						; size = 4
_width$ = 32						; size = 4
_num_stripes$ = 36					; size = 4
_context_row_gap$ = 40					; size = 4
?decode_mag_ref_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NPAH3HHH@Z PROC ; decode_mag_ref_pass, COMDAT

; 532  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 147  :         assert(active && (!checked_out) && MQ_segment); checked_out = true;

	mov	ecx, DWORD PTR _coder$[ebp]
	push	ebx
	push	esi
	push	edi

; 148  :         A = this->A; C = this->C;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]

; 150  :         t = this->t; temp = this->temp; store = this->buf_next; S = this->S;

	mov	edx, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [ecx+20]
	lea	ebx, DWORD PTR [eax-8388608]
	mov	BYTE PTR [ecx+28], 1
	cmp	edi, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 549  :   kdu_int32 half_lsb = (1<<p)>>1;

	mov	DWORD PTR _half_lsb$1$[ebp], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 150  :         t = this->t; temp = this->temp; store = this->buf_next; S = this->S;

	mov	DWORD PTR _t$1$[ebp], edx
	cmovl	ebx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 552  :   states += KAPPA_MAG_BASE;

	add	DWORD PTR _states$[ebp], 120		; 00000078H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 149  :         D = A-MQD_A_MIN; D = (C<D)?C:D; A -= D; C -= D;

	sub	eax, ebx
	sub	edi, ebx
	mov	DWORD PTR _A$1$[ebp], eax

; 150  :         t = this->t; temp = this->temp; store = this->buf_next; S = this->S;

	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR _S$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 549  :   kdu_int32 half_lsb = (1<<p)>>1;

	mov	ecx, DWORD PTR _p$[ebp]
	shl	DWORD PTR _half_lsb$1$[ebp], cl

; 550  :   int r, width_by2=width+width, width_by3=width_by2+width;

	mov	ecx, DWORD PTR _width$[ebp]
	sar	DWORD PTR _half_lsb$1$[ebp], 1

; 553  :   assert((context_row_gap - width) == EXTRA_DECODE_CWORDS);
; 554  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_DECODE_CWORDS, sp += width_by3)

	cmp	DWORD PTR _num_stripes$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 149  :         D = A-MQD_A_MIN; D = (C<D)?C:D; A -= D; C -= D;

	mov	DWORD PTR _C$1$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 550  :   int r, width_by2=width+width, width_by3=width_by2+width;

	lea	edi, DWORD PTR [ecx+ecx]
	mov	DWORD PTR _width_by2$1$[ebp], edi
	lea	ecx, DWORD PTR [ecx+ecx*2]

; 553  :   assert((context_row_gap - width) == EXTRA_DECODE_CWORDS);
; 554  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_DECODE_CWORDS, sp += width_by3)

	mov	edi, DWORD PTR _C$1$[ebp]
	jle	$LN3@decode_mag
	mov	edx, DWORD PTR _contexts$[ebp]
	shl	ecx, 2
	mov	DWORD PTR tv631[ebp], ecx
$LL4@decode_mag:

; 555  :     for (c=width; c > 0; c--, sp++, cp++)

	mov	ecx, DWORD PTR _width$[ebp]
	test	ecx, ecx
	mov	DWORD PTR _c$1$[ebp], ecx
	mov	ecx, DWORD PTR _samples$[ebp]
	jle	$LN2@decode_mag
$LL7@decode_mag:

; 556  :       {
; 557  :         if ((*cp & ((MU_BIT<<0)|(MU_BIT<<3)|(MU_BIT<<6)|(MU_BIT<<9))) == 0)

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR _cword$1$[ebp], ecx
	test	ecx, 306708480				; 12480000H
	jne	SHORT $LN23@decode_mag

; 558  :           { // Invoke speedup trick to skip over runs of all-0 neighbourhoods
; 559  :             for (cp+=2; *cp == 0; cp+=2, c-=2, sp+=2);

	add	edx, 8
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN9@decode_mag
	mov	ecx, DWORD PTR _samples$[ebp]
	npad	5
$LL10@decode_mag:
	sub	DWORD PTR _c$1$[ebp], 2
	add	edx, 8
	add	ecx, 8
	cmp	DWORD PTR [edx], 0
	je	SHORT $LL10@decode_mag
	mov	DWORD PTR _samples$[ebp], ecx
$LN9@decode_mag:

; 560  :             cp-=2;

	sub	edx, 8

; 561  :             continue;

	jmp	$LN160@decode_mag
$LN23@decode_mag:

; 562  :           }
; 563  :         cword = *cp;
; 564  :         if (cword & (MU_BIT<<0))

	test	ecx, 524288				; 00080000H
	je	$LN24@decode_mag

; 565  :           { // Process first row of stripe column
; 566  :             val = sp[0];

	mov	ecx, DWORD PTR _samples$[ebp]

; 567  :             sym = (val & KDU_INT32_MAX) >> p;
; 568  :             state_ref = states;

	mov	edx, DWORD PTR _states$[ebp]
	mov	DWORD PTR _state_ref$1$[ebp], edx
	mov	ecx, DWORD PTR [ecx]
	mov	edx, ecx
	and	edx, 2147483647				; 7fffffffH
	mov	DWORD PTR _val$1$[ebp], ecx
	mov	ecx, DWORD PTR _p$[ebp]
	sar	edx, cl

; 569  :             if (sym < 4)

	cmp	edx, 4
	jge	SHORT $LN25@decode_mag

; 570  :               {
; 571  :                 if (cword & (NBRHD_MASK<<0))

	test	DWORD PTR _cword$1$[ebp], 495		; 000001efH
	je	SHORT $LN155@decode_mag

; 572  :                   state_ref++;

	mov	edx, DWORD PTR _states$[ebp]
	add	edx, 8
	mov	DWORD PTR _state_ref$1$[ebp], edx

; 573  :               }
; 574  :             else

	jmp	SHORT $LN26@decode_mag
$LN25@decode_mag:

; 575  :               state_ref += 2;

	mov	edx, DWORD PTR _states$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _state_ref$1$[ebp], edx
	jmp	SHORT $LN26@decode_mag
$LN155@decode_mag:
	mov	edx, DWORD PTR _state_ref$1$[ebp]
$LN26@decode_mag:

; 576  :             _mq_dec_(coder,sym,*state_ref);

	mov	ecx, DWORD PTR [edx]
	sub	ebx, ecx
	mov	DWORD PTR _sym$1$[ebp], ecx
	and	DWORD PTR _sym$1$[ebp], 1
	add	ebx, DWORD PTR _sym$1$[ebp]
	jns	$LN28@decode_mag
	add	DWORD PTR _A$1$[ebp], ebx
	add	edi, ebx
	mov	ebx, DWORD PTR _sym$1$[ebp]
	sub	ecx, ebx
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR _D$2$[ebp], ecx
	test	edi, edi
	js	SHORT $LN29@decode_mag
	cmp	DWORD PTR _A$1$[ebp], ecx
	jge	SHORT $LN31@decode_mag
	mov	ecx, 1
	sub	ecx, ebx
	mov	ebx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR _sym$1$[ebp], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LN165@decode_mag
$LN31@decode_mag:
	mov	ebx, DWORD PTR _state_ref$1$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LN165@decode_mag
$LN29@decode_mag:
	add	edi, ecx
	cmp	DWORD PTR _A$1$[ebp], ecx
	jge	SHORT $LN33@decode_mag
	mov	ebx, DWORD PTR _state_ref$1$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN161@decode_mag
$LN33@decode_mag:
	mov	ecx, 1
	sub	ecx, ebx
	mov	ebx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR _sym$1$[ebp], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+12]
$LN161@decode_mag:
	mov	edx, DWORD PTR _D$2$[ebp]
$LN165@decode_mag:
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
	npad	1
$LL13@decode_mag:
	test	ecx, ecx
	jne	SHORT $LN35@decode_mag
	cmp	eax, 255				; 000000ffH
	mov	ecx, 8
	movzx	eax, BYTE PTR [esi]
	jne	SHORT $LN36@decode_mag
	inc	esi
	cmp	eax, 143				; 0000008fH
	jle	SHORT $LN38@decode_mag
	dec	esi
	mov	eax, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN37@decode_mag
$LN38@decode_mag:
	mov	ecx, 7
	add	edi, eax
	jmp	SHORT $LN37@decode_mag
$LN36@decode_mag:
	inc	esi
$LN37@decode_mag:
	add	edi, eax
$LN35@decode_mag:
	add	edx, edx
	add	edi, edi
	dec	ecx
	cmp	edx, 8388608				; 00800000H
	jl	SHORT $LL13@decode_mag
	lea	ebx, DWORD PTR [edx-8388608]
	mov	DWORD PTR _t$1$[ebp], ecx
	cmp	edi, ebx
	cmovl	ebx, edi
	sub	edx, ebx
	sub	edi, ebx
	mov	DWORD PTR _A$1$[ebp], edx
	mov	DWORD PTR _C$1$[ebp], edi
$LN28@decode_mag:

; 577  :             val ^= ((1-sym)<<p);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, 1
	sub	edx, DWORD PTR _sym$1$[ebp]
	shl	edx, cl

; 578  :             val |= half_lsb;
; 579  :             sp[0] = val;

	mov	ecx, DWORD PTR _samples$[ebp]
	xor	edx, DWORD PTR _val$1$[ebp]
	or	edx, DWORD PTR _half_lsb$1$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR _cword$1$[ebp]
$LN24@decode_mag:

; 580  :           }
; 581  :         if (cword & (MU_BIT<<3))

	test	ecx, 4194304				; 00400000H
	je	$LN41@decode_mag

; 582  :           { // Process second row of stripe column
; 583  :             val = sp[width];

	mov	edx, DWORD PTR _width$[ebp]
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]

; 584  :             sym = (val & KDU_INT32_MAX) >> p;
; 585  :             state_ref = states;

	mov	edx, DWORD PTR _states$[ebp]
	mov	DWORD PTR _state_ref$2$[ebp], edx
	mov	edx, ecx
	and	edx, 2147483647				; 7fffffffH
	mov	DWORD PTR _val$2$[ebp], ecx
	mov	ecx, DWORD PTR _p$[ebp]
	sar	edx, cl

; 586  :             if (sym < 4)

	cmp	edx, 4
	jge	SHORT $LN42@decode_mag

; 587  :               {
; 588  :                 if (cword & (NBRHD_MASK<<3))

	test	DWORD PTR _cword$1$[ebp], 3960		; 00000f78H
	je	SHORT $LN157@decode_mag

; 589  :                   state_ref++;

	mov	edx, DWORD PTR _states$[ebp]
	add	edx, 8
	mov	DWORD PTR _state_ref$2$[ebp], edx

; 590  :               }
; 591  :             else

	jmp	SHORT $LN43@decode_mag
$LN42@decode_mag:

; 592  :               state_ref += 2;

	mov	edx, DWORD PTR _states$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _state_ref$2$[ebp], edx
	jmp	SHORT $LN43@decode_mag
$LN157@decode_mag:
	mov	edx, DWORD PTR _state_ref$2$[ebp]
$LN43@decode_mag:

; 593  :             _mq_dec_(coder,sym,*state_ref);

	mov	ecx, DWORD PTR [edx]
	sub	ebx, ecx
	mov	DWORD PTR _sym$2$[ebp], ecx
	and	DWORD PTR _sym$2$[ebp], 1
	add	ebx, DWORD PTR _sym$2$[ebp]
	mov	DWORD PTR _D$10$[ebp], ebx
	jns	$LN45@decode_mag
	add	DWORD PTR _A$1$[ebp], ebx
	add	edi, ebx
	mov	ebx, DWORD PTR _sym$2$[ebp]
	sub	ecx, ebx
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR _D$4$[ebp], ecx
	test	edi, edi
	js	SHORT $LN46@decode_mag
	cmp	DWORD PTR _A$1$[ebp], ecx
	jge	SHORT $LN48@decode_mag
	mov	ecx, 1
	sub	ecx, ebx
	mov	ebx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR _sym$2$[ebp], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LN166@decode_mag
$LN48@decode_mag:
	mov	ebx, DWORD PTR _state_ref$2$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LN166@decode_mag
$LN46@decode_mag:
	add	edi, ecx
	cmp	DWORD PTR _A$1$[ebp], ecx
	jge	SHORT $LN50@decode_mag
	mov	ebx, DWORD PTR _state_ref$2$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN162@decode_mag
$LN50@decode_mag:
	mov	ecx, 1
	sub	ecx, ebx
	mov	ebx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR _sym$2$[ebp], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+12]
$LN162@decode_mag:
	mov	edx, DWORD PTR _D$4$[ebp]
$LN166@decode_mag:
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
	npad	2
$LL16@decode_mag:
	test	ecx, ecx
	jne	SHORT $LN52@decode_mag
	cmp	eax, 255				; 000000ffH
	mov	ecx, 8
	movzx	eax, BYTE PTR [esi]
	jne	SHORT $LN53@decode_mag
	inc	esi
	cmp	eax, 143				; 0000008fH
	jle	SHORT $LN55@decode_mag
	dec	esi
	mov	eax, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN54@decode_mag
$LN55@decode_mag:
	mov	ecx, 7
	add	edi, eax
	jmp	SHORT $LN54@decode_mag
$LN53@decode_mag:
	inc	esi
$LN54@decode_mag:
	add	edi, eax
$LN52@decode_mag:
	add	edx, edx
	add	edi, edi
	dec	ecx
	cmp	edx, 8388608				; 00800000H
	jl	SHORT $LL16@decode_mag
	lea	ebx, DWORD PTR [edx-8388608]
	mov	DWORD PTR _t$1$[ebp], ecx
	cmp	edi, ebx
	cmovl	ebx, edi
	sub	edx, ebx
	mov	DWORD PTR _D$10$[ebp], ebx
	sub	edi, ebx
	mov	DWORD PTR _A$1$[ebp], edx
	mov	DWORD PTR _C$1$[ebp], edi
$LN45@decode_mag:

; 594  :             val ^= ((1-sym)<<p);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, 1
	sub	edx, DWORD PTR _sym$2$[ebp]

; 595  :             val |= half_lsb;
; 596  :             sp[width] = val;

	mov	ebx, DWORD PTR _width$[ebp]
	shl	edx, cl
	mov	ecx, DWORD PTR _samples$[ebp]
	xor	edx, DWORD PTR _val$2$[ebp]
	or	edx, DWORD PTR _half_lsb$1$[ebp]
	mov	DWORD PTR [ecx+ebx*4], edx
	mov	ebx, DWORD PTR _D$10$[ebp]
	mov	ecx, DWORD PTR _cword$1$[ebp]
$LN41@decode_mag:

; 597  :           }
; 598  :         if (cword & (MU_BIT<<6))

	test	ecx, 33554432				; 02000000H
	je	$LN58@decode_mag

; 599  :           { // Process third row of stripe column
; 600  :             val = sp[width_by2];

	mov	edx, DWORD PTR _width_by2$1$[ebp]
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]

; 601  :             sym = (val & KDU_INT32_MAX) >> p;
; 602  :             state_ref = states;

	mov	edx, DWORD PTR _states$[ebp]
	mov	DWORD PTR _state_ref$3$[ebp], edx
	mov	edx, ecx
	and	edx, 2147483647				; 7fffffffH
	mov	DWORD PTR _val$3$[ebp], ecx
	mov	ecx, DWORD PTR _p$[ebp]
	sar	edx, cl

; 603  :             if (sym < 4)

	cmp	edx, 4
	jge	SHORT $LN59@decode_mag

; 604  :               {
; 605  :                 if (cword & (NBRHD_MASK<<6))

	test	DWORD PTR _cword$1$[ebp], 31680		; 00007bc0H
	je	SHORT $LN158@decode_mag

; 606  :                   state_ref++;

	mov	edx, DWORD PTR _states$[ebp]
	add	edx, 8
	mov	DWORD PTR _state_ref$3$[ebp], edx

; 607  :               }
; 608  :             else

	jmp	SHORT $LN60@decode_mag
$LN59@decode_mag:

; 609  :               state_ref += 2;

	mov	edx, DWORD PTR _states$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _state_ref$3$[ebp], edx
	jmp	SHORT $LN60@decode_mag
$LN158@decode_mag:
	mov	edx, DWORD PTR _state_ref$3$[ebp]
$LN60@decode_mag:

; 610  :             _mq_dec_(coder,sym,*state_ref);

	mov	ecx, DWORD PTR [edx]
	sub	ebx, ecx
	mov	DWORD PTR _sym$3$[ebp], ecx
	and	DWORD PTR _sym$3$[ebp], 1
	add	ebx, DWORD PTR _sym$3$[ebp]
	jns	$LN62@decode_mag
	add	DWORD PTR _A$1$[ebp], ebx
	add	edi, ebx
	mov	ebx, DWORD PTR _sym$3$[ebp]
	sub	ecx, ebx
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR _D$6$[ebp], ecx
	test	edi, edi
	js	SHORT $LN63@decode_mag
	cmp	DWORD PTR _A$1$[ebp], ecx
	jge	SHORT $LN65@decode_mag
	mov	ecx, 1
	sub	ecx, ebx
	mov	ebx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR _sym$3$[ebp], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LN167@decode_mag
$LN65@decode_mag:
	mov	ebx, DWORD PTR _state_ref$3$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LN167@decode_mag
$LN63@decode_mag:
	add	edi, ecx
	cmp	DWORD PTR _A$1$[ebp], ecx
	jge	SHORT $LN67@decode_mag
	mov	ebx, DWORD PTR _state_ref$3$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN163@decode_mag
$LN67@decode_mag:
	mov	ecx, 1
	sub	ecx, ebx
	mov	ebx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR _sym$3$[ebp], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+12]
$LN163@decode_mag:
	mov	edx, DWORD PTR _D$6$[ebp]
$LN167@decode_mag:
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL19@decode_mag:
	test	ecx, ecx
	jne	SHORT $LN69@decode_mag
	cmp	eax, 255				; 000000ffH
	mov	ecx, 8
	movzx	eax, BYTE PTR [esi]
	jne	SHORT $LN70@decode_mag
	inc	esi
	cmp	eax, 143				; 0000008fH
	jle	SHORT $LN72@decode_mag
	dec	esi
	mov	eax, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN71@decode_mag
$LN72@decode_mag:
	mov	ecx, 7
	add	edi, eax
	jmp	SHORT $LN71@decode_mag
$LN70@decode_mag:
	inc	esi
$LN71@decode_mag:
	add	edi, eax
$LN69@decode_mag:
	add	edx, edx
	add	edi, edi
	dec	ecx
	cmp	edx, 8388608				; 00800000H
	jl	SHORT $LL19@decode_mag
	lea	ebx, DWORD PTR [edx-8388608]
	mov	DWORD PTR _t$1$[ebp], ecx
	cmp	edi, ebx
	cmovl	ebx, edi
	sub	edx, ebx
	sub	edi, ebx
	mov	DWORD PTR _A$1$[ebp], edx
	mov	DWORD PTR _C$1$[ebp], edi
$LN62@decode_mag:

; 611  :             val ^= ((1-sym)<<p);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, 1
	sub	edx, DWORD PTR _sym$3$[ebp]

; 612  :             val |= half_lsb;
; 613  :             sp[width_by2] = val;

	mov	edi, DWORD PTR _width_by2$1$[ebp]
	shl	edx, cl
	mov	ecx, DWORD PTR _samples$[ebp]
	xor	edx, DWORD PTR _val$3$[ebp]
	or	edx, DWORD PTR _half_lsb$1$[ebp]
	mov	DWORD PTR [ecx+edi*4], edx
	mov	edi, DWORD PTR _C$1$[ebp]
	mov	ecx, DWORD PTR _cword$1$[ebp]
$LN58@decode_mag:

; 614  :           }
; 615  :         if (cword & (MU_BIT<<9))

	test	ecx, 268435456				; 10000000H
	je	$LN159@decode_mag

; 616  :           { // Process fourth row of stripe column
; 617  :             val = sp[width_by3];

	mov	edx, DWORD PTR tv631[ebp]
	mov	ecx, DWORD PTR _samples$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]

; 618  :             sym = (val & KDU_INT32_MAX) >> p;
; 619  :             state_ref = states;

	mov	edx, DWORD PTR _states$[ebp]
	mov	DWORD PTR _state_ref$4$[ebp], edx
	mov	edx, ecx
	and	edx, 2147483647				; 7fffffffH
	mov	DWORD PTR _val$4$[ebp], ecx
	mov	ecx, DWORD PTR _p$[ebp]
	sar	edx, cl

; 620  :             if (sym < 4)

	cmp	edx, 4
	jge	SHORT $LN76@decode_mag

; 621  :               {
; 622  :                 if (cword & (NBRHD_MASK<<9))

	test	DWORD PTR _cword$1$[ebp], 253440	; 0003de00H
	je	SHORT $LN156@decode_mag

; 623  :                   state_ref++;

	mov	edx, DWORD PTR _states$[ebp]
	add	edx, 8
	mov	DWORD PTR _state_ref$4$[ebp], edx

; 624  :               }
; 625  :             else

	jmp	SHORT $LN77@decode_mag
$LN76@decode_mag:

; 626  :               state_ref += 2;

	mov	edx, DWORD PTR _states$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _state_ref$4$[ebp], edx
	jmp	SHORT $LN77@decode_mag
$LN156@decode_mag:
	mov	edx, DWORD PTR _state_ref$4$[ebp]
$LN77@decode_mag:

; 627  :             _mq_dec_(coder,sym,*state_ref);

	mov	ecx, DWORD PTR [edx]
	sub	ebx, ecx
	mov	DWORD PTR _sym$4$[ebp], ecx
	and	DWORD PTR _sym$4$[ebp], 1
	add	ebx, DWORD PTR _sym$4$[ebp]
	jns	$LN79@decode_mag
	add	DWORD PTR _A$1$[ebp], ebx
	add	edi, ebx
	mov	ebx, DWORD PTR _sym$4$[ebp]
	sub	ecx, ebx
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR _D$8$[ebp], ecx
	test	edi, edi
	js	SHORT $LN80@decode_mag
	cmp	DWORD PTR _A$1$[ebp], ecx
	jge	SHORT $LN82@decode_mag
	mov	ecx, 1
	sub	ecx, ebx
	mov	ebx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR _sym$4$[ebp], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LN168@decode_mag
$LN82@decode_mag:
	mov	ebx, DWORD PTR _state_ref$4$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LN168@decode_mag
$LN80@decode_mag:
	add	edi, ecx
	cmp	DWORD PTR _A$1$[ebp], ecx
	jge	SHORT $LN84@decode_mag
	mov	ebx, DWORD PTR _state_ref$4$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN164@decode_mag
$LN84@decode_mag:
	mov	ecx, 1
	sub	ecx, ebx
	mov	ebx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR _sym$4$[ebp], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR [edx+12]
$LN164@decode_mag:
	mov	edx, DWORD PTR _D$8$[ebp]
$LN168@decode_mag:
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR _t$1$[ebp]
$LL22@decode_mag:
	test	ecx, ecx
	jne	SHORT $LN86@decode_mag
	cmp	eax, 255				; 000000ffH
	mov	ecx, 8
	movzx	eax, BYTE PTR [esi]
	jne	SHORT $LN87@decode_mag
	inc	esi
	cmp	eax, 143				; 0000008fH
	jle	SHORT $LN89@decode_mag
	dec	esi
	mov	eax, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN88@decode_mag
$LN89@decode_mag:
	mov	ecx, 7
	add	edi, eax
	jmp	SHORT $LN88@decode_mag
$LN87@decode_mag:
	inc	esi
$LN88@decode_mag:
	add	edi, eax
$LN86@decode_mag:
	add	edx, edx
	add	edi, edi
	dec	ecx
	cmp	edx, 8388608				; 00800000H
	jl	SHORT $LL22@decode_mag
	lea	ebx, DWORD PTR [edx-8388608]
	mov	DWORD PTR _t$1$[ebp], ecx
	cmp	edi, ebx
	cmovl	ebx, edi
	sub	edx, ebx
	sub	edi, ebx
	mov	DWORD PTR _A$1$[ebp], edx
	mov	DWORD PTR _C$1$[ebp], edi
$LN79@decode_mag:

; 628  :             val ^= ((1-sym)<<p);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, 1
	sub	edx, DWORD PTR _sym$4$[ebp]

; 629  :             val |= half_lsb;
; 630  :             sp[width_by3] = val;

	mov	edi, DWORD PTR tv631[ebp]
	shl	edx, cl
	xor	edx, DWORD PTR _val$4$[ebp]
	mov	ecx, DWORD PTR _samples$[ebp]
	or	edx, DWORD PTR _half_lsb$1$[ebp]
	mov	DWORD PTR [edi+ecx], edx
	mov	edi, DWORD PTR _C$1$[ebp]
	mov	edx, DWORD PTR _contexts$[ebp]
	jmp	SHORT $LN5@decode_mag
$LN159@decode_mag:
	mov	edx, DWORD PTR _contexts$[ebp]
$LN160@decode_mag:
	mov	ecx, DWORD PTR _samples$[ebp]
$LN5@decode_mag:

; 555  :     for (c=width; c > 0; c--, sp++, cp++)

	dec	DWORD PTR _c$1$[ebp]
	add	ecx, 4
	add	edx, 4
	mov	DWORD PTR _samples$[ebp], ecx
	cmp	DWORD PTR _c$1$[ebp], 0
	mov	DWORD PTR _contexts$[ebp], edx
	jg	$LL7@decode_mag
$LN2@decode_mag:

; 553  :   assert((context_row_gap - width) == EXTRA_DECODE_CWORDS);
; 554  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_DECODE_CWORDS, sp += width_by3)

	dec	DWORD PTR _num_stripes$[ebp]
	add	edx, 12					; 0000000cH
	add	ecx, DWORD PTR tv631[ebp]
	cmp	DWORD PTR _num_stripes$[ebp], 0
	mov	DWORD PTR _contexts$[ebp], edx
	mov	DWORD PTR _samples$[ebp], ecx
	jg	$LL4@decode_mag
$LN3@decode_mag:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 160  :         assert(active && checked_out && MQ_segment); checked_out = false;

	mov	ecx, DWORD PTR _coder$[ebp]

; 161  :         this->A = A+D; this->C = C+D;

	mov	edx, DWORD PTR _coder$[ebp]
	mov	BYTE PTR [ecx+28], 0
	mov	ecx, DWORD PTR _A$1$[ebp]
	add	ecx, ebx
	mov	DWORD PTR [edx], ecx
	lea	ecx, DWORD PTR [edi+ebx]
	mov	ebx, edx

; 162  :         this->t = t; this->temp = temp; this->buf_next = store; this->S = S;

	mov	edx, DWORD PTR _t$1$[ebp]
	pop	edi
	mov	DWORD PTR [ebx+12], eax
	mov	eax, DWORD PTR _S$1$[ebp]
	mov	DWORD PTR [ebx+20], esi
	pop	esi

; 161  :         this->A = A+D; this->C = C+D;

	mov	DWORD PTR [ebx+4], ecx

; 162  :         this->t = t; this->temp = temp; this->buf_next = store; this->S = S;

	mov	DWORD PTR [ebx+8], edx
	mov	DWORD PTR [ebx+24], eax
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 635  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?decode_mag_ref_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NPAH3HHH@Z ENDP ; decode_mag_ref_pass
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
;	COMDAT ?decode_mag_ref_pass_raw@@YAXAAVmq_decoder@@H_NPAH2HHH@Z
_TEXT	SEGMENT
_width_by2$1$ = -20					; size = 4
tv393 = -16						; size = 4
_c$1$ = -12						; size = 4
_half_lsb$1$ = -8					; size = 4
_cword$1$ = -4						; size = 4
_coder$ = 8						; size = 4
_p$ = 12						; size = 4
_causal$ = 16						; size = 1
_samples$ = 20						; size = 4
_t$1$ = 24						; size = 4
_contexts$ = 24						; size = 4
_width$ = 28						; size = 4
_num_stripes$ = 32					; size = 4
_context_row_gap$ = 36					; size = 4
?decode_mag_ref_pass_raw@@YAXAAVmq_decoder@@H_NPAH2HHH@Z PROC ; decode_mag_ref_pass_raw, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 472  :   kdu_int32 half_lsb = (1<<p)>>1;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 154  :         assert(active && (!checked_out) && !MQ_segment); checked_out = true;

	mov	eax, DWORD PTR _coder$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 472  :   kdu_int32 half_lsb = (1<<p)>>1;

	shl	edx, cl
	sar	edx, 1

; 476  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_DECODE_CWORDS, sp += width_by3)

	cmp	DWORD PTR _num_stripes$[ebp], 0
	mov	DWORD PTR _half_lsb$1$[ebp], edx
	mov	edx, DWORD PTR _width$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _contexts$[ebp]
	push	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 155  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	esi, DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 473  :   int r, width_by2=width+width, width_by3=width_by2+width;

	lea	ecx, DWORD PTR [edx+edx]
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 155  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	edi, DWORD PTR [eax+12]
	mov	BYTE PTR [eax+28], 1
	mov	eax, DWORD PTR [eax+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 473  :   int r, width_by2=width+width, width_by3=width_by2+width;

	mov	DWORD PTR _width_by2$1$[ebp], ecx
	lea	ecx, DWORD PTR [edx+edx*2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 155  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	DWORD PTR _t$1$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 476  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_DECODE_CWORDS, sp += width_by3)

	jle	$LN3@decode_mag
	shl	ecx, 2
	mov	DWORD PTR tv393[ebp], ecx
	mov	ecx, DWORD PTR _samples$[ebp]
	npad	3
$LL4@decode_mag:

; 477  :     for (c=width; c > 0; c--, sp++, cp++)

	cmp	DWORD PTR _width$[ebp], 0
	mov	DWORD PTR _c$1$[ebp], edx
	jle	$LN2@decode_mag
	npad	3
$LL7@decode_mag:

; 478  :       {
; 479  :         if ((*cp & ((MU_BIT<<0)|(MU_BIT<<3)|(MU_BIT<<6)|(MU_BIT<<9))) == 0)

	mov	ecx, DWORD PTR [ebx]
	test	ecx, 306708480				; 12480000H
	mov	DWORD PTR _cword$1$[ebp], ecx
	mov	ecx, DWORD PTR _samples$[ebp]
	jne	SHORT $LN11@decode_mag

; 480  :           { // Invoke speedup trick to skip over runs of all-0 neighbourhoods
; 481  :             for (cp+=2; *cp == 0; cp+=2, c-=2, sp+=2);

	add	ebx, 8
	cmp	DWORD PTR [ebx], 0
	jne	SHORT $LN9@decode_mag
	npad	8
$LL10@decode_mag:
	add	ebx, 8
	sub	edx, 2
	add	ecx, 8
	cmp	DWORD PTR [ebx], 0
	je	SHORT $LL10@decode_mag
$LN9@decode_mag:

; 482  :             cp-=2;

	sub	ebx, 8

; 483  :             continue;

	jmp	$LN5@decode_mag
$LN11@decode_mag:

; 484  :           }
; 485  :         cword = *cp;
; 486  :         if (cword & (MU_BIT<<0))

	mov	edx, DWORD PTR _cword$1$[ebp]
	test	edx, 524288				; 00080000H
	je	SHORT $LN12@decode_mag

; 487  :           { // Process first row of stripe column
; 488  :             _raw_dec_(coder,sym);

	test	esi, esi
	jne	SHORT $LN15@decode_mag
	cmp	edi, 255				; 000000ffH
	mov	esi, 8
	movzx	edi, BYTE PTR [eax]
	jne	SHORT $LN14@decode_mag
	inc	eax
	cmp	edi, 143				; 0000008fH
	jle	SHORT $LN16@decode_mag
	mov	edi, 255				; 000000ffH
	dec	eax
	jmp	SHORT $LN15@decode_mag
$LN16@decode_mag:
	mov	esi, 7
	jmp	SHORT $LN15@decode_mag
$LN14@decode_mag:
	inc	eax
$LN15@decode_mag:
	dec	esi
	mov	edx, edi
	mov	ecx, esi
	mov	DWORD PTR _t$1$[ebp], esi
	sar	edx, cl

; 489  :             sym = (1-sym)<<p;

	mov	esi, 1
	mov	ecx, DWORD PTR _p$[ebp]
	and	edx, 1
	sub	esi, edx
	mov	edx, DWORD PTR _cword$1$[ebp]
	shl	esi, cl

; 490  :             sym ^= sp[0];

	mov	ecx, DWORD PTR _samples$[ebp]
	xor	esi, DWORD PTR [ecx]

; 491  :             sym |= half_lsb;

	or	esi, DWORD PTR _half_lsb$1$[ebp]

; 492  :             sp[0] = sym;

	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR _t$1$[ebp]
$LN12@decode_mag:

; 493  :           }
; 494  :         if (cword & (MU_BIT<<3))

	test	edx, 4194304				; 00400000H
	je	SHORT $LN18@decode_mag

; 495  :           { // Process second row of stripe column
; 496  :             _raw_dec_(coder,sym);

	test	esi, esi
	jne	SHORT $LN21@decode_mag
	cmp	edi, 255				; 000000ffH
	mov	esi, 8
	movzx	edi, BYTE PTR [eax]
	jne	SHORT $LN20@decode_mag
	inc	eax
	cmp	edi, 143				; 0000008fH
	jle	SHORT $LN22@decode_mag
	mov	edi, 255				; 000000ffH
	dec	eax
	jmp	SHORT $LN21@decode_mag
$LN22@decode_mag:
	mov	esi, 7
	jmp	SHORT $LN21@decode_mag
$LN20@decode_mag:
	inc	eax
$LN21@decode_mag:
	dec	esi
	mov	edx, edi
	mov	ecx, esi
	mov	DWORD PTR _t$1$[ebp], esi
	sar	edx, cl

; 497  :             sym = (1-sym)<<p;

	mov	esi, 1
	mov	ecx, DWORD PTR _p$[ebp]
	and	edx, 1
	sub	esi, edx

; 498  :             sym ^= sp[width];

	mov	edx, DWORD PTR _width$[ebp]
	shl	esi, cl
	mov	ecx, DWORD PTR _samples$[ebp]
	xor	esi, DWORD PTR [ecx+edx*4]

; 499  :             sym |= half_lsb;

	or	esi, DWORD PTR _half_lsb$1$[ebp]

; 500  :             sp[width] = sym;

	mov	DWORD PTR [ecx+edx*4], esi
	mov	edx, DWORD PTR _cword$1$[ebp]
$LN18@decode_mag:

; 501  :           }
; 502  :         if (cword & (MU_BIT<<6))

	test	edx, 33554432				; 02000000H
	je	SHORT $LN24@decode_mag

; 503  :           { // Process third row of stripe column
; 504  :             _raw_dec_(coder,sym);

	mov	ecx, DWORD PTR _t$1$[ebp]
	test	ecx, ecx
	jne	SHORT $LN27@decode_mag
	cmp	edi, 255				; 000000ffH
	mov	ecx, 8
	movzx	edi, BYTE PTR [eax]
	jne	SHORT $LN26@decode_mag
	inc	eax
	cmp	edi, 143				; 0000008fH
	jle	SHORT $LN28@decode_mag
	mov	edi, 255				; 000000ffH
	dec	eax
	jmp	SHORT $LN27@decode_mag
$LN28@decode_mag:
	mov	ecx, 7
	jmp	SHORT $LN27@decode_mag
$LN26@decode_mag:
	inc	eax
$LN27@decode_mag:
	dec	ecx
	mov	edx, edi
	sar	edx, cl

; 505  :             sym = (1-sym)<<p;

	mov	esi, 1
	and	edx, 1
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	ecx, DWORD PTR _p$[ebp]
	sub	esi, edx

; 506  :             sym ^= sp[width_by2];

	mov	edx, DWORD PTR _width_by2$1$[ebp]
	shl	esi, cl
	mov	ecx, DWORD PTR _samples$[ebp]
	xor	esi, DWORD PTR [ecx+edx*4]

; 507  :             sym |= half_lsb;

	or	esi, DWORD PTR _half_lsb$1$[ebp]

; 508  :             sp[width_by2] = sym;

	mov	DWORD PTR [ecx+edx*4], esi
	mov	edx, DWORD PTR _cword$1$[ebp]
$LN24@decode_mag:

; 509  :           }
; 510  :         if (cword & (MU_BIT<<9))

	test	edx, 268435456				; 10000000H
	je	SHORT $LN53@decode_mag

; 511  :           { // Process fourth row of stripe column
; 512  :             _raw_dec_(coder,sym);

	mov	ecx, DWORD PTR _t$1$[ebp]
	test	ecx, ecx
	jne	SHORT $LN33@decode_mag
	cmp	edi, 255				; 000000ffH
	mov	ecx, 8
	movzx	edi, BYTE PTR [eax]
	jne	SHORT $LN32@decode_mag
	inc	eax
	cmp	edi, 143				; 0000008fH
	jle	SHORT $LN34@decode_mag
	mov	edi, 255				; 000000ffH
	dec	eax
	jmp	SHORT $LN33@decode_mag
$LN34@decode_mag:
	mov	ecx, 7
	jmp	SHORT $LN33@decode_mag
$LN32@decode_mag:
	inc	eax
$LN33@decode_mag:
	dec	ecx
	mov	edx, edi
	sar	edx, cl

; 513  :             sym = (1-sym)<<p;

	mov	esi, 1
	and	edx, 1
	mov	DWORD PTR _t$1$[ebp], ecx
	mov	ecx, DWORD PTR _p$[ebp]
	sub	esi, edx

; 514  :             sym ^= sp[width_by3];

	mov	edx, DWORD PTR tv393[ebp]
	shl	esi, cl
	mov	ecx, DWORD PTR _samples$[ebp]
	xor	esi, DWORD PTR [edx+ecx]

; 515  :             sym |= half_lsb;

	or	esi, DWORD PTR _half_lsb$1$[ebp]

; 516  :             sp[width_by3] = sym;

	mov	DWORD PTR [edx+ecx], esi
$LN53@decode_mag:
	mov	edx, DWORD PTR _c$1$[ebp]
	mov	esi, DWORD PTR _t$1$[ebp]
$LN5@decode_mag:

; 477  :     for (c=width; c > 0; c--, sp++, cp++)

	dec	edx
	add	ecx, 4
	add	ebx, 4
	mov	DWORD PTR _c$1$[ebp], edx
	mov	DWORD PTR _samples$[ebp], ecx
	test	edx, edx
	jg	$LL7@decode_mag
$LN2@decode_mag:

; 476  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_DECODE_CWORDS, sp += width_by3)

	mov	edx, DWORD PTR _num_stripes$[ebp]
	add	ebx, 12					; 0000000cH
	add	ecx, DWORD PTR tv393[ebp]
	dec	edx
	mov	DWORD PTR _num_stripes$[ebp], edx
	test	edx, edx
	mov	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _samples$[ebp], ecx
	jg	$LL4@decode_mag
$LN3@decode_mag:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 166  :         assert(active && checked_out && !MQ_segment); checked_out = false;

	mov	ecx, DWORD PTR _coder$[ebp]

; 167  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+12], edi
	pop	edi
	mov	DWORD PTR [ecx+8], esi
	pop	esi

; 166  :         assert(active && checked_out && !MQ_segment); checked_out = false;

	mov	BYTE PTR [ecx+28], 0

; 167  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+20], eax
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 521  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?decode_mag_ref_pass_raw@@YAXAAVmq_decoder@@H_NPAH2HHH@Z ENDP ; decode_mag_ref_pass_raw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
;	COMDAT ?decode_sig_prop_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z
_TEXT	SEGMENT
_width_by2$1$ = -52					; size = 4
_val$2$ = -48						; size = 4
tv1248 = -48						; size = 4
tv1247 = -48						; size = 4
tv1245 = -48						; size = 4
tv1244 = -48						; size = 4
tv1243 = -48						; size = 4
tv1241 = -48						; size = 4
tv1240 = -48						; size = 4
tv1238 = -48						; size = 4
tv1237 = -48						; size = 4
tv1236 = -48						; size = 4
tv1234 = -48						; size = 4
tv1233 = -48						; size = 4
tv1232 = -48						; size = 4
tv1231 = -48						; size = 4
tv1230 = -48						; size = 4
tv1229 = -48						; size = 4
_val$4$ = -44						; size = 4
_val$3$ = -44						; size = 4
_val$1$ = -44						; size = 4
tv1227 = -44						; size = 4
tv1226 = -44						; size = 4
tv1225 = -44						; size = 4
tv1224 = -44						; size = 4
tv1222 = -44						; size = 4
tv1221 = -44						; size = 4
tv1220 = -44						; size = 4
tv1219 = -44						; size = 4
tv1205 = -40						; size = 4
tv1215 = -36						; size = 4
tv1214 = -36						; size = 4
tv1210 = -36						; size = 4
tv1207 = -36						; size = 4
_D$16$ = -36						; size = 4
_D$14$ = -36						; size = 4
_D$12$ = -36						; size = 4
_D$10$ = -36						; size = 4
_D$8$ = -36						; size = 4
_D$6$ = -36						; size = 4
_D$4$ = -36						; size = 4
_D$2$ = -36						; size = 4
_sig_lut$1$ = -32					; size = 4
_c$1$ = -28						; size = 4
_one_point_five$1$ = -24				; size = 4
_sym$12$ = -20						; size = 4
_sym$10$ = -20						; size = 4
_sym$9$ = -20						; size = 4
_sym$7$ = -20						; size = 4
_sym$6$ = -20						; size = 4
_sym$4$ = -20						; size = 4
_sym$3$ = -20						; size = 4
_sym$1$ = -20						; size = 4
_S$1$ = -16						; size = 4
_D$18$ = -12						; size = 4
tv1218 = -12						; size = 4
tv1216 = -12						; size = 4
tv1213 = -12						; size = 4
tv1211 = -12						; size = 4
_store$1$ = -8						; size = 4
_A$1$ = -4						; size = 4
_coder$ = 8						; size = 4
_states$ = 12						; size = 4
_sym$11$ = 16						; size = 4
_state_ref$8$ = 16					; size = 4
_state_ref$7$ = 16					; size = 4
_state_ref$6$ = 16					; size = 4
_state_ref$5$ = 16					; size = 4
_state_ref$4$ = 16					; size = 4
_state_ref$3$ = 16					; size = 4
_state_ref$2$ = 16					; size = 4
_state_ref$1$ = 16					; size = 4
_p$ = 16						; size = 4
_causal$ = 20						; size = 1
_cword$1$ = 24						; size = 4
_orientation$ = 24					; size = 4
_samples$ = 28						; size = 4
_contexts$ = 32						; size = 4
_width$ = 36						; size = 4
_num_stripes$ = 40					; size = 4
_context_row_gap$ = 44					; size = 4
?decode_sig_prop_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z PROC ; decode_sig_prop_pass, COMDAT

; 304  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 147  :         assert(active && (!checked_out) && MQ_segment); checked_out = true;

	mov	ecx, DWORD PTR _coder$[ebp]
	push	ebx
	push	esi
	push	edi

; 148  :         A = this->A; C = this->C;

	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]

; 150  :         t = this->t; temp = this->temp; store = this->buf_next; S = this->S;

	mov	ebx, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx-8388608]
	mov	BYTE PTR [ecx+28], 1
	cmp	edi, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 322  :   kdu_int32 one_point_five = 1<<p; one_point_five += (one_point_five>>1);

	mov	DWORD PTR _one_point_five$1$[ebp], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 149  :         D = A-MQD_A_MIN; D = (C<D)?C:D; A -= D; C -= D;

	cmovl	eax, edi
	sub	edx, eax
	mov	DWORD PTR _D$18$[ebp], eax
	sub	edi, eax
	mov	DWORD PTR _A$1$[ebp], edx

; 150  :         t = this->t; temp = this->temp; store = this->buf_next; S = this->S;

	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR _S$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 319  :   register  kdu_byte *sig_lut = significance_luts[orientation];

	mov	ecx, DWORD PTR _orientation$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 150  :         t = this->t; temp = this->temp; store = this->buf_next; S = this->S;

	mov	DWORD PTR _store$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 319  :   register  kdu_byte *sig_lut = significance_luts[orientation];

	mov	ecx, DWORD PTR ?significance_luts@@3PAPAEA[ecx*4]
	mov	DWORD PTR _sig_lut$1$[ebp], ecx

; 322  :   kdu_int32 one_point_five = 1<<p; one_point_five += (one_point_five>>1);

	mov	ecx, DWORD PTR _p$[ebp]
	shl	DWORD PTR _one_point_five$1$[ebp], cl
	mov	ecx, DWORD PTR _one_point_five$1$[ebp]
	sar	ecx, 1
	add	DWORD PTR _one_point_five$1$[ebp], ecx

; 323  :   int r, width_by2=width+width, width_by3=width_by2+width;
; 324  : 
; 325  :   assert((context_row_gap - width) == EXTRA_DECODE_CWORDS);
; 326  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_DECODE_CWORDS, sp += width_by3)

	cmp	DWORD PTR _num_stripes$[ebp], 0
	mov	ecx, DWORD PTR _width$[ebp]
	lea	edx, DWORD PTR [ecx+ecx]
	mov	DWORD PTR _width_by2$1$[ebp], edx
	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	edx, DWORD PTR _A$1$[ebp]
	jle	$LN3@decode_sig
	shl	ecx, 2
	mov	DWORD PTR tv1205[ebp], ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
$LL4@decode_sig:

; 327  :     for (c=width; c > 0; c--, sp++, cp++)

	mov	eax, DWORD PTR _width$[ebp]
	test	eax, eax
	mov	DWORD PTR _c$1$[ebp], eax
	mov	eax, DWORD PTR _store$1$[ebp]
	jle	$LN2@decode_sig
$LL7@decode_sig:

; 328  :       {
; 329  :         if (*cp == 0)

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	mov	DWORD PTR _cword$1$[ebp], edx
	mov	edx, DWORD PTR _A$1$[ebp]
	jne	SHORT $LN35@decode_sig

; 330  :           { // Invoke speedup trick to skip over runs of all-0 neighbourhoods
; 331  :             for (cp+=3; *cp == 0; cp+=3, c-=3, sp+=3);

	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN9@decode_sig
	mov	eax, DWORD PTR _samples$[ebp]
	mov	edx, DWORD PTR _c$1$[ebp]
	npad	5
$LL10@decode_sig:
	add	ecx, 12					; 0000000cH
	sub	edx, 3
	add	eax, 12					; 0000000cH
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LL10@decode_sig
	mov	DWORD PTR _c$1$[ebp], edx
	mov	edx, DWORD PTR _A$1$[ebp]
	mov	DWORD PTR _samples$[ebp], eax
	mov	eax, DWORD PTR _store$1$[ebp]
$LN9@decode_sig:

; 332  :             cp-=3;

	sub	ecx, 12					; 0000000cH

; 333  :             continue;

	jmp	$LN5@decode_sig
$LN35@decode_sig:

; 334  :           }
; 335  :         cword = *cp;
; 336  :         if ((cword & (NBRHD_MASK<<0)) && !(cword & (SIG_PROP_MEMBER_MASK<<0)))

	mov	ecx, DWORD PTR _cword$1$[ebp]
	and	ecx, 495				; 000001efH
	je	$LN262@decode_sig
	test	DWORD PTR _cword$1$[ebp], 2097168	; 00200010H
	jne	$LN262@decode_sig

; 337  :           { // Process first row of stripe column (row 0)
; 338  :             state_ref = states+KAPPA_SIG_BASE+sig_lut[cword & NBRHD_MASK];

	mov	eax, DWORD PTR _sig_lut$1$[ebp]
	movzx	ecx, BYTE PTR [ecx+eax]
	mov	eax, DWORD PTR _states$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*8]

; 339  :             _mq_dec_(coder,sym,*state_ref);

	mov	eax, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _state_ref$1$[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _sym$1$[ebp], ecx
	mov	DWORD PTR _D$2$[ebp], ecx
	mov	ecx, DWORD PTR _D$18$[ebp]
	sub	ecx, DWORD PTR _sym$1$[ebp]
	and	DWORD PTR _sym$1$[ebp], 1
	add	ecx, DWORD PTR _sym$1$[ebp]
	mov	DWORD PTR _D$18$[ebp], ecx
	jns	$LN37@decode_sig
	add	edx, ecx
	add	edi, ecx
	mov	ecx, DWORD PTR _D$2$[ebp]
	sub	ecx, DWORD PTR _sym$1$[ebp]
	mov	DWORD PTR _A$1$[ebp], edx
	mov	DWORD PTR _D$2$[ebp], ecx
	test	edi, edi
	js	SHORT $LN38@decode_sig
	cmp	edx, ecx
	jge	SHORT $LN40@decode_sig
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$1$[ebp]
	mov	DWORD PTR _sym$1$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$1$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1207[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1207[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL13@decode_sig
$LN40@decode_sig:
	mov	ecx, DWORD PTR _state_ref$1$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1210[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1210[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL13@decode_sig
$LN38@decode_sig:
	add	edi, ecx
	cmp	edx, ecx
	jge	SHORT $LN42@decode_sig
	mov	ecx, DWORD PTR _state_ref$1$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1211[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1211[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN271@decode_sig
$LN42@decode_sig:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$1$[ebp]
	mov	DWORD PTR _sym$1$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$1$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1213[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1213[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN271@decode_sig:
	mov	edx, DWORD PTR _state_ref$1$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _D$2$[ebp]
	npad	2
$LL13@decode_sig:
	test	ebx, ebx
	jne	SHORT $LN44@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN45@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN47@decode_sig
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN46@decode_sig
$LN47@decode_sig:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN46@decode_sig
$LN45@decode_sig:
	inc	eax
$LN46@decode_sig:
	add	edi, esi
$LN44@decode_sig:
	add	edx, edx
	add	edi, edi
	dec	ebx
	cmp	edx, 8388608				; 00800000H
	jl	SHORT $LL13@decode_sig
	lea	ecx, DWORD PTR [edx-8388608]
	mov	DWORD PTR _store$1$[ebp], eax
	cmp	edi, ecx
	cmovl	ecx, edi
	sub	edx, ecx
	mov	DWORD PTR _D$18$[ebp], ecx
	mov	DWORD PTR _A$1$[ebp], edx
	sub	edi, ecx
$LN37@decode_sig:

; 340  :             if (!sym)

	cmp	DWORD PTR _sym$1$[ebp], 0
	jne	SHORT $LN50@decode_sig

; 341  :               { cword |= (PI_BIT<<0); goto row_1; }

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	edx, 1048576				; 00100000H
	mov	DWORD PTR _cword$1$[ebp], edx
	jmp	$row_1$280
$LN50@decode_sig:

; 342  :             // Decode sign bit
; 343  :             sym = cword & ((CHI_BIT>>3) | (SIGMA_CC_BIT>>3) |
; 344  :                            (CHI_BIT<<3) | (SIGMA_CC_BIT<<3));
; 345  :             sym >>= 1; // Shift down so that top sigma bit has address 0
; 346  :             sym |= (cp[-1] & ((CHI_BIT<<0) | (SIGMA_CC_BIT<<0))) >> (1+1);
; 347  :             sym |= (cp[ 1] & ((CHI_BIT<<0) | (SIGMA_CC_BIT<<0))) >> (1-1);

	mov	edx, DWORD PTR _contexts$[ebp]
	mov	ecx, DWORD PTR _cword$1$[ebp]
	and	ecx, 17039490				; 01040082H
	mov	edx, DWORD PTR [edx-4]
	sar	edx, 1
	and	edx, 1048584				; 00100008H
	or	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	sar	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 2097168				; 00200010H
	or	edx, ecx

; 348  :             sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma

	mov	ecx, edx
	sar	ecx, 16					; 00000010H

; 349  :             val = sign_lut[sym & 0x000000FF];

	or	ecx, edx

; 350  :             state_ref = states + KAPPA_SIGN_BASE + (val>>1);

	mov	edx, DWORD PTR _states$[ebp]
	movzx	ecx, cl
	add	edx, 80					; 00000050H
	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _val$1$[ebp], ecx
	sar	ecx, 1
	lea	ecx, DWORD PTR [edx+ecx*8]

; 351  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR _D$18$[ebp]
	mov	DWORD PTR _state_ref$2$[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	sub	edx, ecx
	mov	DWORD PTR _D$4$[ebp], ecx
	and	ecx, 1
	add	edx, ecx
	mov	DWORD PTR _sym$3$[ebp], ecx
	mov	DWORD PTR _D$18$[ebp], edx
	jns	$LN52@decode_sig
	mov	ecx, DWORD PTR _A$1$[ebp]
	add	edi, edx
	add	ecx, edx
	mov	edx, DWORD PTR _D$4$[ebp]
	sub	edx, DWORD PTR _sym$3$[ebp]
	mov	DWORD PTR _A$1$[ebp], ecx
	mov	DWORD PTR _D$4$[ebp], edx
	test	edi, edi
	js	SHORT $LN53@decode_sig
	cmp	ecx, edx
	jge	SHORT $LN55@decode_sig
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$3$[ebp]
	mov	DWORD PTR _sym$3$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1214[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1214[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL16@decode_sig
$LN55@decode_sig:
	mov	ecx, DWORD PTR _state_ref$2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1215[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1215[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL16@decode_sig
$LN53@decode_sig:
	add	edi, edx
	cmp	ecx, edx
	jge	SHORT $LN57@decode_sig
	mov	ecx, DWORD PTR _state_ref$2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1216[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1216[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN272@decode_sig
$LN57@decode_sig:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$3$[ebp]
	mov	DWORD PTR _sym$3$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$2$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1218[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1218[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN272@decode_sig:
	mov	edx, DWORD PTR _state_ref$2$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _D$4$[ebp]
$LL16@decode_sig:
	test	ebx, ebx
	jne	SHORT $LN59@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN60@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN62@decode_sig
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN61@decode_sig
$LN62@decode_sig:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN61@decode_sig
$LN60@decode_sig:
	inc	eax
$LN61@decode_sig:
	add	edi, esi
$LN59@decode_sig:
	add	ecx, ecx
	add	edi, edi
	dec	ebx
	cmp	ecx, 8388608				; 00800000H
	jl	SHORT $LL16@decode_sig
	lea	edx, DWORD PTR [ecx-8388608]
	mov	DWORD PTR _store$1$[ebp], eax
	cmp	edi, edx
	cmovl	edx, edi
	sub	ecx, edx
	mov	DWORD PTR _D$18$[ebp], edx
	mov	DWORD PTR _A$1$[ebp], ecx
	sub	edi, edx
	mov	ecx, DWORD PTR _sym$3$[ebp]
$LN52@decode_sig:

; 352  :             sym ^= (val & 1); // Sign bit recovered in LSB.

	mov	edx, DWORD PTR _val$1$[ebp]
	and	edx, 1
	xor	ecx, edx

; 353  :             // Broadcast neighbourhood context changes
; 354  :             if (!causal)

	cmp	BYTE PTR _causal$[ebp], 0
	mov	DWORD PTR _sym$3$[ebp], ecx
	jne	SHORT $LN65@decode_sig

; 355  :               {
; 356  :                 cp[-context_row_gap-1] |=(SIGMA_BR_BIT<<9);

	mov	ecx, DWORD PTR _context_row_gap$[ebp]
	mov	edx, DWORD PTR _contexts$[ebp]
	shl	ecx, 2
	sub	edx, ecx

; 357  :                 cp[-context_row_gap  ] |=(SIGMA_BC_BIT<<9)|(sym<<NEXT_CHI_POS);

	mov	ecx, DWORD PTR _sym$3$[ebp]
	shl	ecx, 31					; 0000001fH
	or	ecx, 65536				; 00010000H
	or	DWORD PTR [edx-4], 131072		; 00020000H
	or	DWORD PTR [edx], ecx

; 358  :                 cp[-context_row_gap+1] |=(SIGMA_BL_BIT<<9);

	or	DWORD PTR [edx+4], 32768		; 00008000H
	mov	ecx, DWORD PTR _sym$3$[ebp]
$LN65@decode_sig:

; 359  :               }
; 360  :             cp[-1] |= (SIGMA_CR_BIT<<0);

	mov	edx, DWORD PTR _contexts$[ebp]

; 361  :             cp[1]  |= (SIGMA_CL_BIT<<0);
; 362  :             cword |= (SIGMA_CC_BIT<<0) | (PI_BIT<<0) | (sym<<CHI_POS);
; 363  :             sp[0] = (sym<<31) + one_point_five;

	mov	eax, DWORD PTR _samples$[ebp]
	shl	ecx, 21					; 00000015H
	or	ecx, 1048592				; 00100010H
	or	DWORD PTR [edx-4], 32			; 00000020H
	or	DWORD PTR [edx+4], 8
	mov	edx, DWORD PTR _cword$1$[ebp]
	or	edx, ecx
	imul	ecx, DWORD PTR _sym$3$[ebp], -2147483648
	mov	DWORD PTR _cword$1$[ebp], edx
	add	ecx, DWORD PTR _one_point_five$1$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _store$1$[ebp]
	jmp	SHORT $row_1$280
$LN262@decode_sig:
	mov	edx, DWORD PTR _cword$1$[ebp]
$row_1$280:

; 364  :           }
; 365  : row_1:
; 366  :         if ((cword & (NBRHD_MASK<<3)) && !(cword & (SIG_PROP_MEMBER_MASK<<3)))

	test	edx, 3960				; 00000f78H
	je	$row_2$281
	test	edx, 16777344				; 01000080H
	jne	$row_2$281

; 367  :           { // Process second row of stripe column (row 1)
; 368  :             state_ref = states+KAPPA_SIG_BASE+sig_lut[(cword>>3) & NBRHD_MASK];

	mov	ecx, edx
	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	sar	ecx, 3
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8]

; 369  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR _D$18$[ebp]
	mov	DWORD PTR _state_ref$3$[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	sub	edx, ecx
	mov	DWORD PTR _D$6$[ebp], ecx
	and	ecx, 1
	add	edx, ecx
	mov	DWORD PTR _sym$4$[ebp], ecx
	mov	DWORD PTR _D$18$[ebp], edx
	jns	$LN67@decode_sig
	mov	ecx, DWORD PTR _A$1$[ebp]
	add	edi, edx
	add	ecx, edx
	mov	edx, DWORD PTR _D$6$[ebp]
	sub	edx, DWORD PTR _sym$4$[ebp]
	mov	DWORD PTR _A$1$[ebp], ecx
	mov	DWORD PTR _D$6$[ebp], edx
	test	edi, edi
	js	SHORT $LN68@decode_sig
	cmp	ecx, edx
	jge	SHORT $LN70@decode_sig
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$4$[ebp]
	mov	DWORD PTR _sym$4$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$3$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1219[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1219[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL19@decode_sig
$LN70@decode_sig:
	mov	ecx, DWORD PTR _state_ref$3$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1220[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1220[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL19@decode_sig
$LN68@decode_sig:
	add	edi, edx
	cmp	ecx, edx
	jge	SHORT $LN72@decode_sig
	mov	ecx, DWORD PTR _state_ref$3$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1221[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1221[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN273@decode_sig
$LN72@decode_sig:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$4$[ebp]
	mov	DWORD PTR _sym$4$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$3$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1222[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1222[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN273@decode_sig:
	mov	edx, DWORD PTR _state_ref$3$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _D$6$[ebp]
$LL19@decode_sig:
	test	ebx, ebx
	jne	SHORT $LN74@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN75@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN77@decode_sig
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN76@decode_sig
$LN77@decode_sig:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN76@decode_sig
$LN75@decode_sig:
	inc	eax
$LN76@decode_sig:
	add	edi, esi
$LN74@decode_sig:
	add	ecx, ecx
	add	edi, edi
	dec	ebx
	cmp	ecx, 8388608				; 00800000H
	jl	SHORT $LL19@decode_sig
	lea	edx, DWORD PTR [ecx-8388608]
	mov	DWORD PTR _store$1$[ebp], eax
	cmp	edi, edx
	cmovl	edx, edi
	sub	ecx, edx
	mov	DWORD PTR _D$18$[ebp], edx
	mov	DWORD PTR _A$1$[ebp], ecx
	sub	edi, edx
	mov	ecx, DWORD PTR _sym$4$[ebp]
$LN67@decode_sig:

; 370  :             if (!sym)

	test	ecx, ecx
	jne	SHORT $LN80@decode_sig

; 371  :               { cword |= (PI_BIT<<3); goto row_2; }

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	edx, 8388608				; 00800000H
	mov	DWORD PTR _cword$1$[ebp], edx
	jmp	$row_2$281
$LN80@decode_sig:

; 372  :             // Decode sign bit
; 373  :             sym = cword & ((CHI_BIT<<0) | (SIGMA_CC_BIT<<0) |
; 374  :                            (CHI_BIT<<6) | (SIGMA_CC_BIT<<6));
; 375  :             sym >>= 4; // Shift down so that top sigma bit has address 0
; 376  :             sym |= (cp[-1] & ((CHI_BIT<<3) | (SIGMA_CC_BIT<<3))) >> (4+1);
; 377  :             sym |= (cp[ 1] & ((CHI_BIT<<3) | (SIGMA_CC_BIT<<3))) >> (4-1);

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR _cword$1$[ebp]
	and	ecx, 136315920				; 08200410H
	sar	edx, 1
	and	edx, 8388672				; 00800040H
	or	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	sar	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 16777344				; 01000080H
	or	edx, ecx
	sar	edx, 3

; 378  :             sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma

	mov	ecx, edx
	sar	ecx, 16					; 00000010H

; 379  :             val = sign_lut[sym & 0x000000FF];

	or	ecx, edx

; 380  :             state_ref = states + KAPPA_SIGN_BASE + (val>>1);

	mov	edx, DWORD PTR _states$[ebp]
	movzx	ecx, cl
	add	edx, 80					; 00000050H
	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _val$2$[ebp], ecx
	sar	ecx, 1
	lea	ecx, DWORD PTR [edx+ecx*8]

; 381  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR _D$18$[ebp]
	mov	DWORD PTR _state_ref$4$[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	sub	edx, ecx
	mov	DWORD PTR _D$8$[ebp], ecx
	and	ecx, 1
	add	edx, ecx
	mov	DWORD PTR _sym$6$[ebp], ecx
	mov	DWORD PTR _D$18$[ebp], edx
	jns	$LN82@decode_sig
	mov	ecx, DWORD PTR _A$1$[ebp]
	add	edi, edx
	add	ecx, edx
	mov	edx, DWORD PTR _D$8$[ebp]
	sub	edx, DWORD PTR _sym$6$[ebp]
	mov	DWORD PTR _A$1$[ebp], ecx
	mov	DWORD PTR _D$8$[ebp], edx
	test	edi, edi
	js	SHORT $LN83@decode_sig
	cmp	ecx, edx
	jge	SHORT $LN85@decode_sig
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$6$[ebp]
	mov	DWORD PTR _sym$6$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$4$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1224[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1224[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL22@decode_sig
$LN85@decode_sig:
	mov	ecx, DWORD PTR _state_ref$4$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1225[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1225[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL22@decode_sig
$LN83@decode_sig:
	add	edi, edx
	cmp	ecx, edx
	jge	SHORT $LN87@decode_sig
	mov	ecx, DWORD PTR _state_ref$4$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1226[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1226[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN274@decode_sig
$LN87@decode_sig:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$6$[ebp]
	mov	DWORD PTR _sym$6$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$4$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1227[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1227[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN274@decode_sig:
	mov	edx, DWORD PTR _state_ref$4$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _D$8$[ebp]
	npad	2
$LL22@decode_sig:
	test	ebx, ebx
	jne	SHORT $LN89@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN90@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN92@decode_sig
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN91@decode_sig
$LN92@decode_sig:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN91@decode_sig
$LN90@decode_sig:
	inc	eax
$LN91@decode_sig:
	add	edi, esi
$LN89@decode_sig:
	add	ecx, ecx
	add	edi, edi
	dec	ebx
	cmp	ecx, 8388608				; 00800000H
	jl	SHORT $LL22@decode_sig
	lea	edx, DWORD PTR [ecx-8388608]
	mov	DWORD PTR _store$1$[ebp], eax
	cmp	edi, edx
	cmovl	edx, edi
	sub	ecx, edx
	mov	DWORD PTR _D$18$[ebp], edx
	mov	DWORD PTR _A$1$[ebp], ecx
	sub	edi, edx
	mov	ecx, DWORD PTR _sym$6$[ebp]
$LN82@decode_sig:

; 382  :             sym ^= (val & 1); // Sign bit recovered in LSB.

	mov	edx, DWORD PTR _val$2$[ebp]

; 383  :             // Broadcast neighbourhood context changes
; 384  :             cp[-1] |= (SIGMA_CR_BIT<<3);
; 385  :             cp[1]  |= (SIGMA_CL_BIT<<3);
; 386  :             cword |= (SIGMA_CC_BIT<<3) | (PI_BIT<<3) | (sym<<(CHI_POS+3));
; 387  :             sp[width] = (sym<<31) + one_point_five;

	mov	eax, DWORD PTR _samples$[ebp]
	and	edx, 1
	xor	ecx, edx
	mov	edx, DWORD PTR _contexts$[ebp]
	mov	DWORD PTR _sym$6$[ebp], ecx
	shl	ecx, 24					; 00000018H
	or	ecx, 8388736				; 00800080H
	or	DWORD PTR _cword$1$[ebp], ecx
	or	DWORD PTR [edx-4], 256			; 00000100H
	or	DWORD PTR [edx+4], 64			; 00000040H
	imul	ecx, DWORD PTR _sym$6$[ebp], -2147483648
	mov	edx, DWORD PTR _width$[ebp]
	add	ecx, DWORD PTR _one_point_five$1$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	eax, DWORD PTR _store$1$[ebp]
	mov	edx, DWORD PTR _cword$1$[ebp]
$row_2$281:

; 388  :           }
; 389  : row_2:
; 390  :         if ((cword & (NBRHD_MASK<<6)) && !(cword & (SIG_PROP_MEMBER_MASK<<6)))

	test	edx, 31680				; 00007bc0H
	je	$row_3$282
	test	edx, 134218752				; 08000400H
	jne	$row_3$282

; 391  :           { // Process third row of stripe column (row 2)
; 392  :             state_ref = states+KAPPA_SIG_BASE+sig_lut[(cword>>6) & NBRHD_MASK];

	mov	ecx, edx
	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	sar	ecx, 6
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8]

; 393  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR _D$18$[ebp]
	mov	DWORD PTR _state_ref$5$[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	sub	edx, ecx
	mov	DWORD PTR _D$10$[ebp], ecx
	and	ecx, 1
	add	edx, ecx
	mov	DWORD PTR _sym$7$[ebp], ecx
	mov	DWORD PTR _D$18$[ebp], edx
	jns	$LN96@decode_sig
	mov	ecx, DWORD PTR _A$1$[ebp]
	add	edi, edx
	add	ecx, edx
	mov	edx, DWORD PTR _D$10$[ebp]
	sub	edx, DWORD PTR _sym$7$[ebp]
	mov	DWORD PTR _A$1$[ebp], ecx
	mov	DWORD PTR _D$10$[ebp], edx
	test	edi, edi
	js	SHORT $LN97@decode_sig
	cmp	ecx, edx
	jge	SHORT $LN99@decode_sig
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$7$[ebp]
	mov	DWORD PTR _sym$7$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$5$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1229[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1229[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL25@decode_sig
$LN99@decode_sig:
	mov	ecx, DWORD PTR _state_ref$5$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1230[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1230[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL25@decode_sig
$LN97@decode_sig:
	add	edi, edx
	cmp	ecx, edx
	jge	SHORT $LN101@decode_sig
	mov	ecx, DWORD PTR _state_ref$5$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1231[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1231[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN275@decode_sig
$LN101@decode_sig:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$7$[ebp]
	mov	DWORD PTR _sym$7$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$5$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1232[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1232[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN275@decode_sig:
	mov	edx, DWORD PTR _state_ref$5$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _D$10$[ebp]
	npad	6
$LL25@decode_sig:
	test	ebx, ebx
	jne	SHORT $LN103@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN104@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN106@decode_sig
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN105@decode_sig
$LN106@decode_sig:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN105@decode_sig
$LN104@decode_sig:
	inc	eax
$LN105@decode_sig:
	add	edi, esi
$LN103@decode_sig:
	add	ecx, ecx
	add	edi, edi
	dec	ebx
	cmp	ecx, 8388608				; 00800000H
	jl	SHORT $LL25@decode_sig
	lea	edx, DWORD PTR [ecx-8388608]
	mov	DWORD PTR _store$1$[ebp], eax
	cmp	edi, edx
	cmovl	edx, edi
	sub	ecx, edx
	mov	DWORD PTR _D$18$[ebp], edx
	mov	DWORD PTR _A$1$[ebp], ecx
	sub	edi, edx
	mov	ecx, DWORD PTR _sym$7$[ebp]
$LN96@decode_sig:

; 394  :             if (!sym)

	test	ecx, ecx
	jne	SHORT $LN109@decode_sig

; 395  :               { cword |= (PI_BIT<<6); goto row_3; }

	mov	edx, DWORD PTR _cword$1$[ebp]
	or	edx, 67108864				; 04000000H
	mov	DWORD PTR _cword$1$[ebp], edx
	jmp	$row_3$282
$LN109@decode_sig:

; 396  :             // Decode sign bit
; 397  :             sym = cword & ((CHI_BIT<<3) | (SIGMA_CC_BIT<<3) |
; 398  :                            (CHI_BIT<<9) | (SIGMA_CC_BIT<<9));
; 399  :             sym >>= 7; // Shift down so that top sigma bit has address 0
; 400  :             sym |= (cp[-1] & ((CHI_BIT<<6) | (SIGMA_CC_BIT<<6))) >> (7+1);
; 401  :             sym |= (cp[ 1] & ((CHI_BIT<<6) | (SIGMA_CC_BIT<<6))) >> (7-1);

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR _cword$1$[ebp]
	and	ecx, 1090527360				; 41002080H
	sar	edx, 1
	and	edx, 67109376				; 04000200H
	or	edx, ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	sar	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 134218752				; 08000400H
	or	edx, ecx
	sar	edx, 6

; 402  :             sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma

	mov	ecx, edx
	sar	ecx, 16					; 00000010H

; 403  :             val = sign_lut[sym & 0x000000FF];

	or	ecx, edx

; 404  :             state_ref = states + KAPPA_SIGN_BASE + (val>>1);

	mov	edx, DWORD PTR _states$[ebp]
	movzx	ecx, cl
	add	edx, 80					; 00000050H
	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _val$3$[ebp], ecx
	sar	ecx, 1
	lea	ecx, DWORD PTR [edx+ecx*8]

; 405  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR _D$18$[ebp]
	mov	DWORD PTR _state_ref$6$[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	sub	edx, ecx
	mov	DWORD PTR _D$12$[ebp], ecx
	and	ecx, 1
	add	edx, ecx
	mov	DWORD PTR _sym$9$[ebp], ecx
	mov	DWORD PTR _D$18$[ebp], edx
	jns	$LN111@decode_sig
	mov	ecx, DWORD PTR _A$1$[ebp]
	add	edi, edx
	add	ecx, edx
	mov	edx, DWORD PTR _D$12$[ebp]
	sub	edx, DWORD PTR _sym$9$[ebp]
	mov	DWORD PTR _A$1$[ebp], ecx
	mov	DWORD PTR _D$12$[ebp], edx
	test	edi, edi
	js	SHORT $LN112@decode_sig
	cmp	ecx, edx
	jge	SHORT $LN114@decode_sig
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$9$[ebp]
	mov	DWORD PTR _sym$9$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$6$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1233[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1233[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL28@decode_sig
$LN114@decode_sig:
	mov	ecx, DWORD PTR _state_ref$6$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1234[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1234[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL28@decode_sig
$LN112@decode_sig:
	add	edi, edx
	cmp	ecx, edx
	jge	SHORT $LN116@decode_sig
	mov	ecx, DWORD PTR _state_ref$6$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1236[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1236[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN276@decode_sig
$LN116@decode_sig:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$9$[ebp]
	mov	DWORD PTR _sym$9$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$6$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1237[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1237[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN276@decode_sig:
	mov	edx, DWORD PTR _state_ref$6$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _D$12$[ebp]
	npad	4
$LL28@decode_sig:
	test	ebx, ebx
	jne	SHORT $LN118@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN119@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN121@decode_sig
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN120@decode_sig
$LN121@decode_sig:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN120@decode_sig
$LN119@decode_sig:
	inc	eax
$LN120@decode_sig:
	add	edi, esi
$LN118@decode_sig:
	add	ecx, ecx
	add	edi, edi
	dec	ebx
	cmp	ecx, 8388608				; 00800000H
	jl	SHORT $LL28@decode_sig
	lea	edx, DWORD PTR [ecx-8388608]
	mov	DWORD PTR _store$1$[ebp], eax
	cmp	edi, edx
	cmovl	edx, edi
	sub	ecx, edx
	mov	DWORD PTR _D$18$[ebp], edx
	mov	DWORD PTR _A$1$[ebp], ecx
	sub	edi, edx
	mov	ecx, DWORD PTR _sym$9$[ebp]
$LN111@decode_sig:

; 406  :             sym ^= (val & 1); // Sign bit recovered in LSB.

	mov	edx, DWORD PTR _val$3$[ebp]

; 407  :             // Broadcast neighbourhood context changes
; 408  :             cp[-1] |= (SIGMA_CR_BIT<<6);
; 409  :             cp[1]  |= (SIGMA_CL_BIT<<6);
; 410  :             cword |= (SIGMA_CC_BIT<<6) | (PI_BIT<<6) | (sym << (CHI_POS+6));
; 411  :             sp[width_by2] = (sym<<31) + one_point_five;

	mov	eax, DWORD PTR _samples$[ebp]
	and	edx, 1
	xor	ecx, edx
	mov	edx, DWORD PTR _contexts$[ebp]
	mov	DWORD PTR _sym$9$[ebp], ecx
	shl	ecx, 27					; 0000001bH
	or	ecx, 67109888				; 04000400H
	or	DWORD PTR _cword$1$[ebp], ecx
	or	DWORD PTR [edx-4], 2048			; 00000800H
	or	DWORD PTR [edx+4], 512			; 00000200H
	imul	ecx, DWORD PTR _sym$9$[ebp], -2147483648
	mov	edx, DWORD PTR _width_by2$1$[ebp]
	add	ecx, DWORD PTR _one_point_five$1$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	eax, DWORD PTR _store$1$[ebp]
	mov	edx, DWORD PTR _cword$1$[ebp]
$row_3$282:

; 412  :           }
; 413  : row_3:
; 414  :         if ((cword & (NBRHD_MASK<<9)) && !(cword & (SIG_PROP_MEMBER_MASK<<9)))

	test	edx, 253440				; 0003de00H
	je	$done$283
	test	edx, 1073750016				; 40002000H
	jne	$done$283

; 415  :           { // Process fourth row of stripe column (row 3)
; 416  :             state_ref = states+KAPPA_SIG_BASE+sig_lut[(cword>>9) & NBRHD_MASK];

	mov	ecx, edx
	mov	edx, DWORD PTR _sig_lut$1$[ebp]
	sar	ecx, 9
	and	ecx, 495				; 000001efH
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR _states$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8]

; 417  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR _D$18$[ebp]
	mov	DWORD PTR _state_ref$7$[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	sub	edx, ecx
	mov	DWORD PTR _D$14$[ebp], ecx
	and	ecx, 1
	add	edx, ecx
	mov	DWORD PTR _sym$10$[ebp], ecx
	mov	DWORD PTR _D$18$[ebp], edx
	jns	$LN125@decode_sig
	mov	ecx, DWORD PTR _A$1$[ebp]
	add	edi, edx
	add	ecx, edx
	mov	edx, DWORD PTR _D$14$[ebp]
	sub	edx, DWORD PTR _sym$10$[ebp]
	mov	DWORD PTR _A$1$[ebp], ecx
	mov	DWORD PTR _D$14$[ebp], edx
	test	edi, edi
	js	SHORT $LN126@decode_sig
	cmp	ecx, edx
	jge	SHORT $LN128@decode_sig
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$10$[ebp]
	mov	DWORD PTR _sym$10$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$7$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1238[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1238[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL31@decode_sig
$LN128@decode_sig:
	mov	ecx, DWORD PTR _state_ref$7$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1240[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1240[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL31@decode_sig
$LN126@decode_sig:
	add	edi, edx
	cmp	ecx, edx
	jge	SHORT $LN130@decode_sig
	mov	ecx, DWORD PTR _state_ref$7$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1241[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1241[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN277@decode_sig
$LN130@decode_sig:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$10$[ebp]
	mov	DWORD PTR _sym$10$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$7$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1243[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1243[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN277@decode_sig:
	mov	edx, DWORD PTR _state_ref$7$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _D$14$[ebp]
	npad	3
$LL31@decode_sig:
	test	ebx, ebx
	jne	SHORT $LN132@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN133@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN135@decode_sig
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN134@decode_sig
$LN135@decode_sig:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN134@decode_sig
$LN133@decode_sig:
	inc	eax
$LN134@decode_sig:
	add	edi, esi
$LN132@decode_sig:
	add	ecx, ecx
	add	edi, edi
	dec	ebx
	cmp	ecx, 8388608				; 00800000H
	jl	SHORT $LL31@decode_sig
	lea	edx, DWORD PTR [ecx-8388608]
	mov	DWORD PTR _store$1$[ebp], eax
	cmp	edi, edx
	cmovl	edx, edi
	sub	ecx, edx
	mov	DWORD PTR _D$18$[ebp], edx
	mov	DWORD PTR _A$1$[ebp], ecx
	sub	edi, edx
	mov	ecx, DWORD PTR _sym$10$[ebp]
$LN125@decode_sig:

; 418  :             if (!sym)
; 419  :               { cword |= (PI_BIT<<9); goto done; }

	mov	edx, DWORD PTR _cword$1$[ebp]
	test	ecx, ecx
	jne	SHORT $LN138@decode_sig
	or	edx, 536870912				; 20000000H
	jmp	$done$283
$LN138@decode_sig:

; 420  :             // Decode sign bit
; 421  :             sym = cword & ((CHI_BIT<<6) | (SIGMA_CC_BIT<<6) |
; 422  :                                 0       | (SIGMA_CC_BIT<<12));
; 423  :             sym >>= 10; // Shift down so that top sigma bit has address 0

	mov	ecx, edx
	sar	ecx, 10					; 0000000aH
	and	ecx, 131137				; 00020041H
	mov	DWORD PTR _sym$11$[ebp], ecx

; 424  :             if (cword < 0) // Use the fact that NEXT_CHI_BIT = 31

	test	edx, edx
	jns	SHORT $LN140@decode_sig

; 425  :               sym |= CHI_BIT<<(12-10);

	or	ecx, 8388608				; 00800000H
	mov	DWORD PTR _sym$11$[ebp], ecx
$LN140@decode_sig:

; 426  :             sym |= (cp[-1] & ((CHI_BIT<<9) | (SIGMA_CC_BIT<<9))) >> (10+1);
; 427  :             sym |= (cp[ 1] & ((CHI_BIT<<9) | (SIGMA_CC_BIT<<9))) >> (10-1);

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR [ecx+4]
	and	ecx, 1073750016				; 40002000H
	sar	edx, 2
	and	edx, 268437504				; 10000800H
	or	edx, ecx
	mov	ecx, DWORD PTR _sym$11$[ebp]
	sar	edx, 9
	or	ecx, edx

; 428  :             sym |= (sym >> (CHI_POS-1-SIGMA_CC_POS)); // Interleave chi & sigma
; 429  :             val = sign_lut[sym & 0x000000FF];
; 430  :             state_ref = states + KAPPA_SIGN_BASE + (val>>1);

	mov	edx, DWORD PTR _states$[ebp]
	mov	DWORD PTR _sym$11$[ebp], ecx
	add	edx, 80					; 00000050H
	sar	ecx, 16					; 00000010H
	or	ecx, DWORD PTR _sym$11$[ebp]
	movzx	ecx, cl
	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]
	mov	DWORD PTR _val$4$[ebp], ecx
	sar	ecx, 1
	lea	ecx, DWORD PTR [edx+ecx*8]

; 431  :             _mq_dec_(coder,sym,*state_ref);

	mov	edx, DWORD PTR _D$18$[ebp]
	mov	DWORD PTR _state_ref$8$[ebp], ecx
	mov	ecx, DWORD PTR [ecx]
	sub	edx, ecx
	mov	DWORD PTR _D$16$[ebp], ecx
	and	ecx, 1
	add	edx, ecx
	mov	DWORD PTR _sym$12$[ebp], ecx
	mov	DWORD PTR _D$18$[ebp], edx
	jns	$LN141@decode_sig
	mov	ecx, DWORD PTR _A$1$[ebp]
	add	edi, edx
	add	ecx, edx
	mov	edx, DWORD PTR _D$16$[ebp]
	sub	edx, DWORD PTR _sym$12$[ebp]
	mov	DWORD PTR _A$1$[ebp], ecx
	mov	DWORD PTR _D$16$[ebp], edx
	test	edi, edi
	js	SHORT $LN142@decode_sig
	cmp	ecx, edx
	jge	SHORT $LN144@decode_sig
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$12$[ebp]
	mov	DWORD PTR _sym$12$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$8$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1244[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1244[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL34@decode_sig
$LN144@decode_sig:
	mov	ecx, DWORD PTR _state_ref$8$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1245[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1245[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _A$1$[ebp]
	jmp	SHORT $LL34@decode_sig
$LN142@decode_sig:
	add	edi, edx
	cmp	ecx, edx
	jge	SHORT $LN146@decode_sig
	mov	ecx, DWORD PTR _state_ref$8$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1247[ebp], edx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1247[ebp]
	mov	ecx, DWORD PTR [edx+4]
	jmp	SHORT $LN278@decode_sig
$LN146@decode_sig:
	mov	ecx, 1
	sub	ecx, DWORD PTR _sym$12$[ebp]
	mov	DWORD PTR _sym$12$[ebp], ecx
	mov	ecx, DWORD PTR _state_ref$8$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv1248[ebp], edx
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR tv1248[ebp]
	mov	ecx, DWORD PTR [edx+12]
$LN278@decode_sig:
	mov	edx, DWORD PTR _state_ref$8$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR _D$16$[ebp]
	npad	4
$LL34@decode_sig:
	test	ebx, ebx
	jne	SHORT $LN148@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	ebx, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN149@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN151@decode_sig
	dec	eax
	mov	esi, 255				; 000000ffH
	inc	DWORD PTR _S$1$[ebp]
	jmp	SHORT $LN150@decode_sig
$LN151@decode_sig:
	mov	ebx, 7
	add	edi, esi
	jmp	SHORT $LN150@decode_sig
$LN149@decode_sig:
	inc	eax
$LN150@decode_sig:
	add	edi, esi
$LN148@decode_sig:
	add	ecx, ecx
	add	edi, edi
	dec	ebx
	cmp	ecx, 8388608				; 00800000H
	jl	SHORT $LL34@decode_sig
	lea	edx, DWORD PTR [ecx-8388608]
	mov	DWORD PTR _store$1$[ebp], eax
	cmp	edi, edx
	cmovl	edx, edi
	sub	ecx, edx
	mov	DWORD PTR _D$18$[ebp], edx
	mov	DWORD PTR _A$1$[ebp], ecx
	sub	edi, edx
	mov	ecx, DWORD PTR _sym$12$[ebp]
$LN141@decode_sig:

; 432  :             sym ^= (val & 1); // Sign bit recovered in LSB.

	mov	edx, DWORD PTR _val$4$[ebp]

; 433  :             // Broadcast neighbourhood context changes
; 434  :             cp[context_row_gap-1] |= SIGMA_TR_BIT;

	mov	eax, DWORD PTR _context_row_gap$[ebp]
	and	edx, 1
	xor	ecx, edx
	mov	edx, DWORD PTR _contexts$[ebp]
	mov	DWORD PTR _sym$12$[ebp], ecx

; 435  :             cp[context_row_gap  ] |= SIGMA_TC_BIT | (sym<<PREV_CHI_POS);

	shl	ecx, 18					; 00000012H
	or	ecx, 2
	or	DWORD PTR [edx+eax*4], ecx

; 436  :             cp[context_row_gap+1] |= SIGMA_TL_BIT;

	mov	ecx, eax
	or	DWORD PTR [edx+eax*4-4], 4

; 437  :             cp[-1] |= (SIGMA_CR_BIT<<9);
; 438  :             cp[1]  |= (SIGMA_CL_BIT<<9);
; 439  :             cword |= (SIGMA_CC_BIT<<9) | (PI_BIT<<9) | (sym<<(CHI_POS+9));
; 440  :             sp[width_by3] = (sym<<31) + one_point_five;

	mov	eax, DWORD PTR tv1205[ebp]
	or	DWORD PTR [edx+ecx*4+4], 1
	mov	ecx, DWORD PTR _sym$12$[ebp]
	or	DWORD PTR [edx-4], 16384		; 00004000H
	or	DWORD PTR [edx+4], 4096			; 00001000H
	mov	edx, DWORD PTR _samples$[ebp]
	shl	ecx, 30					; 0000001eH
	or	ecx, 536879104				; 20002000H
	or	DWORD PTR _cword$1$[ebp], ecx
	imul	ecx, DWORD PTR _sym$12$[ebp], -2147483648
	add	ecx, DWORD PTR _one_point_five$1$[ebp]
	mov	DWORD PTR [eax+edx], ecx
	mov	eax, DWORD PTR _store$1$[ebp]
	mov	edx, DWORD PTR _cword$1$[ebp]
$done$283:

; 441  :           }
; 442  : done:
; 443  :         *cp = cword;

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR _A$1$[ebp]
$LN5@decode_sig:

; 327  :     for (c=width; c > 0; c--, sp++, cp++)

	dec	DWORD PTR _c$1$[ebp]
	add	ecx, 4
	add	DWORD PTR _samples$[ebp], 4
	cmp	DWORD PTR _c$1$[ebp], 0
	mov	DWORD PTR _contexts$[ebp], ecx
	jg	$LL7@decode_sig
$LN2@decode_sig:

; 323  :   int r, width_by2=width+width, width_by3=width_by2+width;
; 324  : 
; 325  :   assert((context_row_gap - width) == EXTRA_DECODE_CWORDS);
; 326  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_DECODE_CWORDS, sp += width_by3)

	mov	eax, DWORD PTR tv1205[ebp]
	add	ecx, 12					; 0000000cH
	dec	DWORD PTR _num_stripes$[ebp]
	add	DWORD PTR _samples$[ebp], eax
	cmp	DWORD PTR _num_stripes$[ebp], 0
	mov	eax, DWORD PTR _store$1$[ebp]
	mov	DWORD PTR _contexts$[ebp], ecx
	jg	$LL4@decode_sig
$LN3@decode_sig:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 160  :         assert(active && checked_out && MQ_segment); checked_out = false;

	mov	ecx, DWORD PTR _coder$[ebp]
	mov	BYTE PTR [ecx+28], 0

; 161  :         this->A = A+D; this->C = C+D;

	mov	ecx, DWORD PTR _D$18$[ebp]
	add	ecx, edx
	mov	edx, DWORD PTR _coder$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR _D$18$[ebp]
	add	ecx, edi

; 162  :         this->t = t; this->temp = temp; this->buf_next = store; this->S = S;

	mov	DWORD PTR [edx+12], esi
	pop	edi
	mov	DWORD PTR [edx+20], eax
	mov	eax, DWORD PTR _S$1$[ebp]
	pop	esi
	mov	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [edx+4], ecx
	mov	DWORD PTR [edx+24], eax
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 447  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?decode_sig_prop_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z ENDP ; decode_sig_prop_pass
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
;	COMDAT ?decode_sig_prop_pass_raw@@YAXAAVmq_decoder@@H_NPAH2HHH@Z
_TEXT	SEGMENT
_sym$4$ = -20						; size = 4
_width_by2$1$ = -16					; size = 4
tv658 = -12						; size = 4
_c$1$ = -8						; size = 4
_one_point_five$1$ = -4					; size = 4
_coder$ = 8						; size = 4
_sym$1$ = 12						; size = 4
_cword$1$ = 12						; size = 4
_p$ = 12						; size = 4
_causal$ = 16						; size = 1
_samples$ = 20						; size = 4
_contexts$ = 24						; size = 4
_width$ = 28						; size = 4
_num_stripes$ = 32					; size = 4
_context_row_gap$ = 36					; size = 4
?decode_sig_prop_pass_raw@@YAXAAVmq_decoder@@H_NPAH2HHH@Z PROC ; decode_sig_prop_pass_raw, COMDAT

; 199  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 214  :   kdu_int32 one_point_five = 1<<p; one_point_five += (one_point_five>>1);

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 154  :         assert(active && (!checked_out) && !MQ_segment); checked_out = true;

	mov	eax, DWORD PTR _coder$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 214  :   kdu_int32 one_point_five = 1<<p; one_point_five += (one_point_five>>1);

	shl	edx, cl
	push	ebx

; 215  :   int r, width_by2=width+width, width_by3=width_by2+width;

	mov	ebx, DWORD PTR _width$[ebp]
	mov	ecx, edx
	sar	ecx, 1
	add	edx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 154  :         assert(active && (!checked_out) && !MQ_segment); checked_out = true;

	mov	BYTE PTR [eax+28], 1
	push	esi

; 155  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	esi, DWORD PTR [eax+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 215  :   int r, width_by2=width+width, width_by3=width_by2+width;

	lea	ecx, DWORD PTR [ebx+ebx]
	mov	DWORD PTR _width_by2$1$[ebp], ecx
	add	ecx, ebx

; 216  : 
; 217  :   assert((context_row_gap - width) == EXTRA_DECODE_CWORDS);
; 218  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_DECODE_CWORDS, sp += width_by3)

	cmp	DWORD PTR _num_stripes$[ebp], 0
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 155  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	edi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 214  :   kdu_int32 one_point_five = 1<<p; one_point_five += (one_point_five>>1);

	mov	DWORD PTR _one_point_five$1$[ebp], edx

; 216  : 
; 217  :   assert((context_row_gap - width) == EXTRA_DECODE_CWORDS);
; 218  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_DECODE_CWORDS, sp += width_by3)

	jle	$LN3@decode_sig
	mov	edx, DWORD PTR _samples$[ebp]
	shl	ecx, 2
	mov	DWORD PTR tv658[ebp], ecx
	mov	ecx, DWORD PTR _contexts$[ebp]
	npad	3
$LL4@decode_sig:

; 219  :     for (c=width; c > 0; c--, sp++, cp++)

	mov	DWORD PTR _c$1$[ebp], ebx
	test	ebx, ebx
	jle	$LN2@decode_sig
	npad	5
$LL7@decode_sig:

; 220  :       {
; 221  :         if (*cp == 0)

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR _cword$1$[ebp], ebx
	test	ebx, ebx
	je	$LN5@decode_sig

; 222  :           continue;
; 223  :         cword = *cp;
; 224  :         if ((cword & (NBRHD_MASK<<0)) && !(cword & (SIG_PROP_MEMBER_MASK<<0)))

	test	ebx, 495				; 000001efH
	je	$row_1$77
	test	ebx, 2097168				; 00200010H
	jne	$row_1$77

; 225  :           { // Process first row of stripe column (row 0)
; 226  :             _raw_dec_(coder,sym);

	test	edi, edi
	jne	SHORT $LN12@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	edi, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN11@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN13@decode_sig
	mov	esi, 255				; 000000ffH
	dec	eax
	jmp	SHORT $LN12@decode_sig
$LN13@decode_sig:
	mov	edi, 7
	jmp	SHORT $LN12@decode_sig
$LN11@decode_sig:
	inc	eax
$LN12@decode_sig:
	dec	edi
	mov	edx, esi
	mov	ecx, edi
	sar	edx, cl
	test	dl, 1

; 227  :             if (!sym)

	jne	SHORT $LN15@decode_sig

; 228  :               { cword |= (PI_BIT<<0); goto row_1; }

	or	ebx, 1048576				; 00100000H
	jmp	$LN75@decode_sig
$LN15@decode_sig:

; 229  :             // Decode sign bit
; 230  :             _raw_dec_(coder,sym);

	test	edi, edi
	jne	SHORT $LN19@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	edi, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN18@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN20@decode_sig
	mov	esi, 255				; 000000ffH
	dec	eax
	jmp	SHORT $LN19@decode_sig
$LN20@decode_sig:
	mov	edi, 7
	jmp	SHORT $LN19@decode_sig
$LN18@decode_sig:
	inc	eax
$LN19@decode_sig:
	dec	edi
	mov	edx, esi
	mov	ecx, edi
	sar	edx, cl
	and	edx, 1

; 231  :             // Broadcast neighbourhood context changes
; 232  :             if (!causal)

	cmp	BYTE PTR _causal$[ebp], 0
	mov	DWORD PTR _sym$1$[ebp], edx
	jne	SHORT $LN22@decode_sig

; 233  :               {
; 234  :                 cp[-context_row_gap-1] |=(SIGMA_BR_BIT<<9);

	mov	ecx, DWORD PTR _context_row_gap$[ebp]
	mov	edx, DWORD PTR _contexts$[ebp]
	shl	ecx, 2
	sub	edx, ecx

; 235  :                 cp[-context_row_gap  ] |=(SIGMA_BC_BIT<<9)|(sym<<NEXT_CHI_POS);

	mov	ecx, DWORD PTR _sym$1$[ebp]
	shl	ecx, 31					; 0000001fH
	or	ecx, 65536				; 00010000H
	or	DWORD PTR [edx-4], 131072		; 00020000H
	or	DWORD PTR [edx], ecx

; 236  :                 cp[-context_row_gap+1] |=(SIGMA_BL_BIT<<9);

	or	DWORD PTR [edx+4], 32768		; 00008000H
	mov	edx, DWORD PTR _sym$1$[ebp]
$LN22@decode_sig:

; 237  :               }
; 238  :             cp[-1] |= (SIGMA_CR_BIT<<0);

	mov	ecx, DWORD PTR _contexts$[ebp]
	or	DWORD PTR [ecx-4], 32			; 00000020H

; 239  :             cp[1]  |= (SIGMA_CL_BIT<<0);

	or	DWORD PTR [ecx+4], 8

; 240  :             cword |= (SIGMA_CC_BIT<<0) | (PI_BIT<<0) | (sym<<CHI_POS);

	mov	ecx, edx
	shl	ecx, 21					; 00000015H
	or	ecx, 1048592				; 00100010H
	or	ebx, ecx

; 241  :             sp[0] = (sym<<31) + one_point_five;

	imul	ecx, edx, -2147483648
	mov	edx, DWORD PTR _samples$[ebp]
	add	ecx, DWORD PTR _one_point_five$1$[ebp]
	mov	DWORD PTR [edx], ecx
$LN75@decode_sig:

; 240  :             cword |= (SIGMA_CC_BIT<<0) | (PI_BIT<<0) | (sym<<CHI_POS);

	mov	DWORD PTR _cword$1$[ebp], ebx
$row_1$77:

; 242  :           }
; 243  : row_1:
; 244  :         if ((cword & (NBRHD_MASK<<3)) && !(cword & (SIG_PROP_MEMBER_MASK<<3)))

	test	ebx, 3960				; 00000f78H
	je	$row_2$78
	test	ebx, 16777344				; 01000080H
	jne	$row_2$78

; 245  :           { // Process second row of stripe column (row 1)
; 246  :             _raw_dec_(coder,sym);

	test	edi, edi
	jne	SHORT $LN26@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	edi, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN25@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN27@decode_sig
	mov	esi, 255				; 000000ffH
	dec	eax
	jmp	SHORT $LN26@decode_sig
$LN27@decode_sig:
	mov	edi, 7
	jmp	SHORT $LN26@decode_sig
$LN25@decode_sig:
	inc	eax
$LN26@decode_sig:
	dec	edi
	mov	edx, esi
	mov	ecx, edi
	sar	edx, cl
	test	dl, 1

; 247  :             if (!sym)

	jne	SHORT $LN29@decode_sig

; 248  :               { cword |= (PI_BIT<<3); goto row_2; }

	or	ebx, 8388608				; 00800000H
	mov	DWORD PTR _cword$1$[ebp], ebx
	jmp	SHORT $row_2$78
$LN29@decode_sig:

; 249  :             // Decode sign bit
; 250  :             _raw_dec_(coder,sym);

	test	edi, edi
	jne	SHORT $LN33@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	edi, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN32@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN34@decode_sig
	mov	esi, 255				; 000000ffH
	dec	eax
	jmp	SHORT $LN33@decode_sig
$LN34@decode_sig:
	mov	edi, 7
	jmp	SHORT $LN33@decode_sig
$LN32@decode_sig:
	inc	eax
$LN33@decode_sig:
	dec	edi
	mov	edx, esi
	mov	ecx, edi
	sar	edx, cl

; 251  :             // Broadcast neighbourhood context changes
; 252  :             cp[-1] |= (SIGMA_CR_BIT<<3);

	mov	ecx, DWORD PTR _contexts$[ebp]
	and	edx, 1
	or	DWORD PTR [ecx-4], 256			; 00000100H

; 253  :             cp[1]  |= (SIGMA_CL_BIT<<3);

	or	DWORD PTR [ecx+4], 64			; 00000040H

; 254  :             cword |= (SIGMA_CC_BIT<<3) | (PI_BIT<<3) | (sym<<(CHI_POS+3));

	mov	ecx, edx
	shl	ecx, 24					; 00000018H
	or	ecx, 8388736				; 00800080H
	or	ebx, ecx

; 255  :             sp[width] = (sym<<31) + one_point_five;

	imul	ecx, edx, -2147483648
	mov	edx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _cword$1$[ebp], ebx
	mov	ebx, DWORD PTR _width$[ebp]
	add	ecx, DWORD PTR _one_point_five$1$[ebp]
	mov	DWORD PTR [edx+ebx*4], ecx
	mov	ebx, DWORD PTR _cword$1$[ebp]
$row_2$78:

; 256  :           }
; 257  : row_2:
; 258  :         if ((cword & (NBRHD_MASK<<6)) && !(cword & (SIG_PROP_MEMBER_MASK<<6)))

	test	ebx, 31680				; 00007bc0H
	je	$row_3$79
	test	ebx, 134218752				; 08000400H
	jne	$row_3$79

; 259  :           { // Process third row of stripe column (row 2)
; 260  :             _raw_dec_(coder,sym);

	test	edi, edi
	jne	SHORT $LN39@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	edi, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN38@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN40@decode_sig
	mov	esi, 255				; 000000ffH
	dec	eax
	jmp	SHORT $LN39@decode_sig
$LN40@decode_sig:
	mov	edi, 7
	jmp	SHORT $LN39@decode_sig
$LN38@decode_sig:
	inc	eax
$LN39@decode_sig:
	dec	edi
	mov	edx, esi
	mov	ecx, edi
	sar	edx, cl
	test	dl, 1

; 261  :             if (!sym)

	jne	SHORT $LN42@decode_sig

; 262  :               { cword |= (PI_BIT<<6); goto row_3; }

	or	ebx, 67108864				; 04000000H
	mov	DWORD PTR _cword$1$[ebp], ebx
	jmp	SHORT $row_3$79
$LN42@decode_sig:

; 263  :             // Decode sign bit
; 264  :             _raw_dec_(coder,sym);

	test	edi, edi
	jne	SHORT $LN46@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	edi, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN45@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN47@decode_sig
	mov	esi, 255				; 000000ffH
	dec	eax
	jmp	SHORT $LN46@decode_sig
$LN47@decode_sig:
	mov	edi, 7
	jmp	SHORT $LN46@decode_sig
$LN45@decode_sig:
	inc	eax
$LN46@decode_sig:
	dec	edi
	mov	edx, esi
	mov	ecx, edi
	sar	edx, cl

; 265  :             // Broadcast neighbourhood context changes
; 266  :             cp[-1] |= (SIGMA_CR_BIT<<6);

	mov	ecx, DWORD PTR _contexts$[ebp]
	and	edx, 1
	or	DWORD PTR [ecx-4], 2048			; 00000800H

; 267  :             cp[1]  |= (SIGMA_CL_BIT<<6);

	or	DWORD PTR [ecx+4], 512			; 00000200H

; 268  :             cword |= (SIGMA_CC_BIT<<6) | (PI_BIT<<6) | (sym << (CHI_POS+6));

	mov	ecx, edx
	shl	ecx, 27					; 0000001bH
	or	ecx, 67109888				; 04000400H
	or	ebx, ecx

; 269  :             sp[width_by2] = (sym<<31) + one_point_five;

	imul	ecx, edx, -2147483648
	mov	edx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR _cword$1$[ebp], ebx
	mov	ebx, DWORD PTR _width_by2$1$[ebp]
	add	ecx, DWORD PTR _one_point_five$1$[ebp]
	mov	DWORD PTR [edx+ebx*4], ecx
	mov	ebx, DWORD PTR _cword$1$[ebp]
$row_3$79:

; 270  :           }
; 271  : row_3:
; 272  :         if ((cword & (NBRHD_MASK<<9)) && !(cword & (SIG_PROP_MEMBER_MASK<<9)))

	test	ebx, 253440				; 0003de00H
	je	$done$80
	test	ebx, 1073750016				; 40002000H
	jne	$done$80

; 273  :           { // Process fourth row of stripe column (row 3)
; 274  :             _raw_dec_(coder,sym);

	test	edi, edi
	jne	SHORT $LN52@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	edi, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN51@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN53@decode_sig
	mov	esi, 255				; 000000ffH
	dec	eax
	jmp	SHORT $LN52@decode_sig
$LN53@decode_sig:
	mov	edi, 7
	jmp	SHORT $LN52@decode_sig
$LN51@decode_sig:
	inc	eax
$LN52@decode_sig:
	dec	edi
	mov	edx, esi
	mov	ecx, edi
	sar	edx, cl
	test	dl, 1

; 275  :             if (!sym)

	jne	SHORT $LN55@decode_sig

; 276  :               { cword |= (PI_BIT<<9); goto done; }

	or	ebx, 536870912				; 20000000H
	jmp	$done$80
$LN55@decode_sig:

; 277  :             // Decode sign bit
; 278  :             _raw_dec_(coder,sym);

	test	edi, edi
	jne	SHORT $LN59@decode_sig
	cmp	esi, 255				; 000000ffH
	mov	edi, 8
	movzx	esi, BYTE PTR [eax]
	jne	SHORT $LN58@decode_sig
	inc	eax
	cmp	esi, 143				; 0000008fH
	jle	SHORT $LN60@decode_sig
	mov	esi, 255				; 000000ffH
	dec	eax
	jmp	SHORT $LN59@decode_sig
$LN60@decode_sig:
	mov	edi, 7
	jmp	SHORT $LN59@decode_sig
$LN58@decode_sig:
	inc	eax
$LN59@decode_sig:

; 279  :             // Broadcast neighbourhood context changes
; 280  :             cp[context_row_gap-1] |= SIGMA_TR_BIT;

	mov	ebx, DWORD PTR _context_row_gap$[ebp]
	dec	edi
	mov	ecx, edi
	mov	edx, esi
	sar	edx, cl
	mov	ecx, DWORD PTR _contexts$[ebp]
	and	edx, 1
	mov	DWORD PTR _sym$4$[ebp], edx
	or	DWORD PTR [ecx+ebx*4-4], 4

; 281  :             cp[context_row_gap  ] |= SIGMA_TC_BIT | (sym<<PREV_CHI_POS);

	mov	ecx, edx
	mov	edx, DWORD PTR _contexts$[ebp]
	shl	ecx, 18					; 00000012H
	or	ecx, 2
	or	DWORD PTR [edx+ebx*4], ecx

; 282  :             cp[context_row_gap+1] |= SIGMA_TL_BIT;

	mov	ecx, edx
	mov	edx, ebx

; 283  :             cp[-1] |= (SIGMA_CR_BIT<<9);
; 284  :             cp[1]  |= (SIGMA_CL_BIT<<9);
; 285  :             cword |= (SIGMA_CC_BIT<<9) | (PI_BIT<<9) | (sym<<(CHI_POS+9));
; 286  :             sp[width_by3] = (sym<<31) + one_point_five;

	mov	ebx, DWORD PTR tv658[ebp]
	or	DWORD PTR [ecx+edx*4+4], 1
	or	DWORD PTR [ecx-4], 16384		; 00004000H
	or	DWORD PTR [ecx+4], 4096			; 00001000H
	mov	ecx, DWORD PTR _sym$4$[ebp]
	mov	edx, DWORD PTR _samples$[ebp]
	shl	ecx, 30					; 0000001eH
	or	ecx, 536879104				; 20002000H
	or	DWORD PTR _cword$1$[ebp], ecx
	imul	ecx, DWORD PTR _sym$4$[ebp], -2147483648
	add	ecx, DWORD PTR _one_point_five$1$[ebp]
	mov	DWORD PTR [ebx+edx], ecx
	mov	ebx, DWORD PTR _cword$1$[ebp]
$done$80:

; 287  :           }
; 288  : done:
; 289  :         *cp = cword;

	mov	ecx, DWORD PTR _contexts$[ebp]
	mov	edx, DWORD PTR _samples$[ebp]
	mov	DWORD PTR [ecx], ebx
$LN5@decode_sig:

; 219  :     for (c=width; c > 0; c--, sp++, cp++)

	mov	ebx, DWORD PTR _c$1$[ebp]
	add	edx, 4
	dec	ebx
	mov	DWORD PTR _samples$[ebp], edx
	add	ecx, 4
	mov	DWORD PTR _c$1$[ebp], ebx
	mov	DWORD PTR _contexts$[ebp], ecx
	test	ebx, ebx
	jg	$LL7@decode_sig
	mov	ebx, DWORD PTR _width$[ebp]
$LN2@decode_sig:

; 216  : 
; 217  :   assert((context_row_gap - width) == EXTRA_DECODE_CWORDS);
; 218  :   for (r=num_stripes; r > 0; r--, cp += EXTRA_DECODE_CWORDS, sp += width_by3)

	dec	DWORD PTR _num_stripes$[ebp]
	add	ecx, 12					; 0000000cH
	add	edx, DWORD PTR tv658[ebp]
	cmp	DWORD PTR _num_stripes$[ebp], 0
	mov	DWORD PTR _contexts$[ebp], ecx
	mov	DWORD PTR _samples$[ebp], edx
	jg	$LL4@decode_sig
$LN3@decode_sig:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 166  :         assert(active && checked_out && !MQ_segment); checked_out = false;

	mov	ecx, DWORD PTR _coder$[ebp]

; 167  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+8], edi
	pop	edi
	mov	DWORD PTR [ecx+12], esi
	pop	esi

; 166  :         assert(active && checked_out && !MQ_segment); checked_out = false;

	mov	BYTE PTR [ecx+28], 0

; 167  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	DWORD PTR [ecx+20], eax
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?decode_sig_prop_pass_raw@@YAXAAVmq_decoder@@H_NPAH2HHH@Z ENDP ; decode_sig_prop_pass_raw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
;	COMDAT ?reset_states@@YAXQAUmqd_state@@@Z
_TEXT	SEGMENT
_states$ = 8						; size = 4
?reset_states@@YAXQAUmqd_state@@@Z PROC			; reset_states, COMDAT

; 146  : {

	push	ebp
	mov	ebp, esp

; 147  :   for (int n=0; n < 18; n++)

	mov	edx, DWORD PTR _states$[ebp]
	xor	eax, eax
	npad	8
$LL4@reset_stat:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 201  :   p_bar_mps = (mq_decoder::p_bar_table[Sigma] << 8) + s;

	mov	ecx, DWORD PTR ?p_bar_table@mq_decoder@@2PAHA
	shl	ecx, 8
	mov	DWORD PTR [edx+eax*8], ecx

; 202  :   transition = mq_decoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR [edx+eax*8+4], OFFSET ?transition_table@mq_decoder@@2PAUmqd_transition@@A ; mq_decoder::transition_table
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 147  :   for (int n=0; n < 18; n++)

	inc	eax
	cmp	eax, 18					; 00000012H
	jl	SHORT $LL4@reset_stat
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 201  :   p_bar_mps = (mq_decoder::p_bar_table[Sigma] << 8) + s;

	mov	eax, DWORD PTR ?p_bar_table@mq_decoder@@2PAHA+16
	shl	eax, 8
	mov	DWORD PTR [edx], eax

; 202  :   transition = mq_decoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR [edx+4], OFFSET ?transition_table@mq_decoder@@2PAUmqd_transition@@A+128

; 201  :   p_bar_mps = (mq_decoder::p_bar_table[Sigma] << 8) + s;

	mov	eax, DWORD PTR ?p_bar_table@mq_decoder@@2PAHA+12
	shl	eax, 8
	mov	DWORD PTR [edx+72], eax

; 202  :   transition = mq_decoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR [edx+76], OFFSET ?transition_table@mq_decoder@@2PAUmqd_transition@@A+96
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 151  : }

	pop	ebp
	ret	0
?reset_states@@YAXQAUmqd_state@@@Z ENDP			; reset_states
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
;	COMDAT ??_Gkd_block_decoder@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_block_decoder@@UAEPAXI@Z PROC			; kd_block_decoder::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 161  :       { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_block_decoder_base@@6B@
	je	SHORT $LN10@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_block_decoder@@UAEPAXI@Z ENDP			; kd_block_decoder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
;	COMDAT ??1kd_block_decoder@@UAE@XZ
_TEXT	SEGMENT
??1kd_block_decoder@@UAE@XZ PROC			; kd_block_decoder::~kd_block_decoder, COMDAT
; _this$ = ecx

; 161  :       { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_block_decoder_base@@6B@
	ret	0
??1kd_block_decoder@@UAE@XZ ENDP			; kd_block_decoder::~kd_block_decoder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
;	COMDAT ?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z
_TEXT	SEGMENT
_w$2 = -360						; size = 20
_e$3 = -340						; size = 20
_this$1$ = -320						; size = 4
_n$1$ = -316						; size = 4
tv1219 = -312						; size = 4
tv1168 = -308						; size = 4
tv1208 = -304						; size = 4
_segment_start_z$4 = -300				; size = 4
_buf$1$ = -296						; size = 4
_max_original_passes$1$ = -292				; size = 4
_num_rows$1$ = -288					; size = 4
_cpu_counter$1$ = -284					; size = 4
_num_passes$2$ = -280					; size = 4
tv1184 = -276						; size = 4
tv1110 = -272						; size = 4
_run$5 = -268						; size = 4
tv1211 = -264						; size = 4
tv1169 = -260						; size = 4
_p$1$ = -256						; size = 4
tv1209 = -252						; size = 4
_segment_bytes$1$ = -248				; size = 4
_last_segmark_z$1$ = -244				; size = 4
_segment_passes$2$ = -240				; size = 4
_k$1$ = -236						; size = 4
_block$GSCopy$1$ = -232					; size = 4
_causal$6 = -228					; size = 1
_samples$1$ = -224					; size = 4
_context_words$1$ = -220				; size = 4
_num_cols$1$ = -216					; size = 4
_context_row_gap$1$ = -212				; size = 4
_num_stripes$1$ = -208					; size = 4
_er_check$1$ = -202					; size = 1
_bypass$1$ = -201					; size = 1
_coder$ = -200						; size = 40
_states$ = -160						; size = 144
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_block$ = 8						; size = 4
?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z PROC	; kd_block_decoder::decode, COMDAT
; _this$ = ecx

; 845  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 348				; 0000015cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$1$[ebp], ecx
	mov	ecx, DWORD PTR _block$[ebp]
	mov	DWORD PTR _block$GSCopy$1$[ebp], ecx

; 846  :   // Get dimensions.
; 847  :   int num_cols = block->size.x;
; 848  :   int num_rows = block->size.y;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _num_rows$1$[ebp], edx

; 849  :   int num_stripes = (num_rows+3)>>2;

	add	edx, 3
	sar	edx, 2
	mov	DWORD PTR _num_cols$1$[ebp], eax
	mov	DWORD PTR _num_stripes$1$[ebp], edx

; 850  :   int num_samples = (num_stripes<<2)*num_cols;

	lea	edi, DWORD PTR [edx*4]
	imul	edi, eax

; 851  :   int context_row_gap = num_cols + EXTRA_DECODE_CWORDS;
; 852  :   int num_context_words = (num_stripes+2)*context_row_gap+1;

	lea	esi, DWORD PTR [edx+2]
	add	eax, 3
	imul	esi, eax
	mov	DWORD PTR _context_row_gap$1$[ebp], eax
	inc	esi

; 853  :   
; 854  :   // Prepare enough storage.
; 855  :   if (block->max_samples < num_samples)

	cmp	DWORD PTR [ecx+116], edi
	jge	SHORT $LN17@decode

; 856  :     block->set_max_samples((num_samples > 4096)?num_samples:4096);

	mov	eax, 4096				; 00001000H
	cmp	edi, eax
	cmovg	eax, edi
	push	eax
	call	?set_max_samples@kdu_block@@QAEXH@Z	; kdu_block::set_max_samples
	mov	ecx, DWORD PTR _block$GSCopy$1$[ebp]
$LN17@decode:

; 857  :   if (block->max_contexts < num_context_words)

	cmp	DWORD PTR [ecx+120], esi
	jge	SHORT $LN18@decode

; 858  :     block->set_max_contexts((num_context_words > 1600)?num_context_words:1600);

	mov	eax, 1600				; 00000640H
	cmp	esi, eax
	cmovg	eax, esi
	push	eax
	call	?set_max_contexts@kdu_block@@QAEXH@Z	; kdu_block::set_max_contexts
	mov	ecx, DWORD PTR _block$GSCopy$1$[ebp]
$LN18@decode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 6340 :         if (cpu_iterations == 0) return 1;

	cmp	DWORD PTR [ecx+132], 0
	jne	SHORT $LN80@decode
	mov	DWORD PTR _cpu_counter$1$[ebp], 1
	jmp	SHORT $LN79@decode
$LN80@decode:

; 6341 :         cpu_start = clock(); return cpu_iterations;

	call	DWORD PTR __imp__clock
	mov	ecx, DWORD PTR _block$GSCopy$1$[ebp]
	mov	DWORD PTR [ecx+144], eax
	mov	eax, DWORD PTR [ecx+132]
	mov	DWORD PTR _cpu_counter$1$[ebp], eax
$LN79@decode:
	mov	ecx, DWORD PTR _context_row_gap$1$[ebp]
	lea	edx, DWORD PTR [edi*4]
	mov	edi, DWORD PTR _block$GSCopy$1$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR _num_stripes$1$[ebp]
	and	DWORD PTR _num_rows$1$[ebp], 3
	lea	esi, DWORD PTR [ecx*4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 124  :       { active = false; buf_start = buf_next = NULL; }

	mov	BYTE PTR _coder$[ebp+30], 0
	mov	DWORD PTR _coder$[ebp+20], 0
	mov	DWORD PTR _coder$[ebp+16], 0
	mov	DWORD PTR tv1211[ebp], edx
	mov	DWORD PTR tv1209[ebp], esi
	lea	eax, DWORD PTR [eax*4+4]
	mov	DWORD PTR tv1208[ebp], eax
	npad	6
$LL4@decode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 869  :       kdu_int32 *samples = block->sample_buffer;

	mov	eax, DWORD PTR [edi+108]

; 870  :       memset(samples,0,(size_t)(num_samples<<2));

	push	edx
	push	0
	push	eax
	mov	DWORD PTR _samples$1$[ebp], eax
	call	_memset

; 871  :       kdu_int32 *context_words = block->context_buffer + context_row_gap + 1;

	mov	eax, DWORD PTR [edi+112]

; 872  :       memset(context_words-1,0,(size_t)((num_stripes*context_row_gap+1)<<2));

	push	DWORD PTR tv1208[ebp]
	add	eax, 4
	add	esi, eax
	push	0
	mov	DWORD PTR _context_words$1$[ebp], esi
	lea	eax, DWORD PTR [esi-4]
	push	eax
	call	_memset

; 873  :       if (num_rows & 3)

	mov	ecx, DWORD PTR _num_rows$1$[ebp]
	add	esp, 24					; 00000018H
	test	ecx, ecx
	je	SHORT $LN147@decode

; 874  :         {
; 875  :           kdu_int32 oob_marker;
; 876  :           if ((num_rows & 3) == 1) // Last 3 rows of last stripe unoccupied

	cmp	ecx, 1
	jne	SHORT $LN20@decode

; 877  :             oob_marker = (OOB_MARKER<<3) | (OOB_MARKER<<6) | (OOB_MARKER<<9);

	mov	eax, 1224736768				; 49000000H
	jmp	SHORT $LN22@decode
$LN20@decode:

; 878  :           else if ((num_rows & 3) == 2) // Last 2 rows of last stripe are empty

	cmp	ecx, 2
	mov	eax, 1073741824				; 40000000H
	mov	ecx, 1207959552				; 48000000H
	cmove	eax, ecx
$LN22@decode:

; 879  :             oob_marker = (OOB_MARKER << 6) | (OOB_MARKER << 9);
; 880  :           else
; 881  :             oob_marker = (OOB_MARKER << 9);
; 882  :           kdu_int32 *cp = context_words + (num_stripes-1)*context_row_gap;

	mov	ecx, DWORD PTR _num_stripes$1$[ebp]

; 883  :           for (int k=num_cols; k > 0; k--)

	mov	edx, DWORD PTR _num_cols$1$[ebp]
	dec	ecx
	imul	ecx, DWORD PTR _context_row_gap$1$[ebp]
	lea	edi, DWORD PTR [esi+ecx*4]
	test	edx, edx
	jle	SHORT $LN144@decode

; 879  :             oob_marker = (OOB_MARKER << 6) | (OOB_MARKER << 9);
; 880  :           else
; 881  :             oob_marker = (OOB_MARKER << 9);
; 882  :           kdu_int32 *cp = context_words + (num_stripes-1)*context_row_gap;

	mov	ecx, edx
	rep stosd
$LN144@decode:
	mov	edi, DWORD PTR _block$GSCopy$1$[ebp]
	jmp	SHORT $LN7@decode
$LN147@decode:
	mov	edx, DWORD PTR _num_cols$1$[ebp]
$LN7@decode:

; 884  :             *(cp++) = oob_marker;
; 885  :         }
; 886  :       if (context_row_gap > num_cols)

	lea	eax, DWORD PTR [edx+3]
	cmp	eax, edx
	jle	SHORT $LN9@decode

; 887  :         { // Initialize the extra context words between lines to OOB
; 888  :           kdu_int32 oob_marker =
; 889  :             OOB_MARKER | (OOB_MARKER<<3) | (OOB_MARKER<<6) | (OOB_MARKER<<9);
; 890  :           assert(context_row_gap >= (num_cols+3));
; 891  :           kdu_int32 *cp = context_words + num_cols;

	lea	eax, DWORD PTR [esi+edx*4]

; 892  :           for (int k=num_stripes; k > 0; k--, cp+=context_row_gap)

	mov	edx, DWORD PTR _num_stripes$1$[ebp]
	mov	ecx, edx
	test	edx, edx
	jle	SHORT $LN9@decode
	mov	edx, DWORD PTR tv1209[ebp]
	npad	13
$LL10@decode:

; 893  :             cp[0] = cp[1] = cp[2] = oob_marker; // Need 3 OOB words after line

	mov	DWORD PTR [eax+8], 1226833920		; 49200000H
	dec	ecx
	mov	DWORD PTR [eax+4], 1226833920		; 49200000H
	mov	DWORD PTR [eax], 1226833920		; 49200000H
	add	eax, edx
	test	ecx, ecx
	jg	SHORT $LL10@decode
$LN9@decode:

; 894  :         }
; 895  : 
; 896  :       // Determine which passes we can decode and where to put them.
; 897  : 
; 898  :       int p_max = 30 - block->missing_msbs; // Index of most significant plane
; 899  :       int max_original_passes =
; 900  :         (block->K_max_prime - block->missing_msbs)*3-2;

	mov	eax, DWORD PTR [edi+40]
	mov	esi, 30					; 0000001eH
	sub	eax, DWORD PTR [edi+44]
	sub	esi, DWORD PTR [edi+44]
	mov	DWORD PTR _p$1$[ebp], esi
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, -2					; fffffffeH
	mov	DWORD PTR _max_original_passes$1$[ebp], eax

; 901  :       if (max_original_passes <= 0)

	test	eax, eax
	jle	$LN3@decode

; 902  :         break; // Break out of the timing loop; nothing to decode.
; 903  :       int num_passes = 3*p_max-2; // 1 plane for dequantization signalling
; 904  :       if (num_passes > block->num_passes)
; 905  :         num_passes = block->num_passes;
; 906  : 
; 907  :       // Now decode the passes one by one.
; 908  : 
; 909  :       int p = p_max; // Bit-plane counter
; 910  :       int z = 0; // Coding pass index
; 911  :       int k=2; // Coding pass category; start with cleanup pass
; 912  :       int segment_start_z;
; 913  :       int segment_passes = 0; // Num coding passes in current codeword segment.
; 914  :       bool segment_truncated = false;
; 915  :       int segment_bytes = 0;
; 916  :       kdu_byte *buf = block->byte_buffer;

	mov	eax, DWORD PTR [edi+60]
	lea	ecx, DWORD PTR [esi-1]
	lea	ecx, DWORD PTR [esi+ecx*2]
	mov	DWORD PTR _buf$1$[ebp], eax
	cmp	ecx, DWORD PTR [edi+48]
	mov	DWORD PTR _last_segmark_z$1$[ebp], 0
	cmovg	ecx, DWORD PTR [edi+48]
	xor	edx, edx
	mov	DWORD PTR _num_passes$2$[ebp], ecx

; 917  :       bool bypass = false;
; 918  :       bool causal = (block->modes & Cmodes_CAUSAL) != 0;

	mov	ecx, DWORD PTR [edi+28]
	mov	eax, ecx
	shr	eax, 3
	and	al, 1
	mov	DWORD PTR _k$1$[ebp], 2
	mov	DWORD PTR _segment_passes$2$[ebp], edx
	mov	BYTE PTR tv1110[ebp], dl
	mov	BYTE PTR _bypass$1$[ebp], dl
	mov	BYTE PTR _causal$6[ebp], al

; 919  :       bool er_check = (block->modes & Cmodes_ERTERM) &&

	test	cl, 16					; 00000010H
	je	SHORT $LN71@decode
	cmp	BYTE PTR [edi+37], dl
	jne	SHORT $LN70@decode
	cmp	BYTE PTR [edi+36], dl
	je	SHORT $LN71@decode
$LN70@decode:
	mov	BYTE PTR _er_check$1$[ebp], 1
	jmp	SHORT $LN72@decode
$LN71@decode:
	mov	BYTE PTR _er_check$1$[ebp], dl
$LN72@decode:

; 920  :                       (block->fussy || block->resilient);
; 921  :       for (; z < num_passes; z++, k++)

	mov	eax, DWORD PTR _num_passes$2$[ebp]
	test	eax, eax
	jle	$LN143@decode
	mov	ecx, 10					; 0000000aH
	mov	DWORD PTR tv1169[ebp], eax
	sub	ecx, eax
	mov	DWORD PTR tv1184[ebp], 16		; 00000010H
	mov	eax, DWORD PTR _k$1$[ebp]
	mov	DWORD PTR tv1168[ebp], ecx
	mov	ecx, edx
$LL13@decode:

; 922  :         {
; 923  :           if (k == 3)

	cmp	eax, 3
	jne	SHORT $LN27@decode

; 924  :             { k=0; p--; } // Move on to next bit-plane.

	dec	esi
	mov	DWORD PTR _k$1$[ebp], 0
	mov	DWORD PTR _p$1$[ebp], esi
$LN27@decode:

; 925  :           if (segment_passes == 0)

	test	edx, edx
	jne	$LN28@decode

; 926  :             { // Need to start a new codeword segment.
; 927  :               segment_start_z = z;
; 928  :               segment_passes = max_original_passes;
; 929  :               if (block->modes & Cmodes_BYPASS)

	mov	eax, DWORD PTR [edi+28]
	mov	esi, DWORD PTR _max_original_passes$1$[ebp]
	mov	DWORD PTR _segment_start_z$4[ebp], ecx
	test	al, 1
	je	SHORT $LN33@decode

; 930  :                 {
; 931  :                   if (z < 10)

	cmp	ecx, 10					; 0000000aH
	jge	SHORT $LN30@decode

; 932  :                     segment_passes = 10-z;

	mov	esi, DWORD PTR tv1168[ebp]
	mov	edx, DWORD PTR tv1169[ebp]
	add	esi, edx
	jmp	SHORT $LN33@decode
$LN30@decode:

; 933  :                   else if (k == 2) // Cleanup pass.

	cmp	DWORD PTR _k$1$[ebp], 2
	jne	SHORT $LN32@decode

; 934  :                     { segment_passes = 1; bypass = false; }

	mov	esi, 1
	mov	BYTE PTR _bypass$1$[ebp], 0

; 935  :                   else

	jmp	SHORT $LN33@decode
$LN32@decode:

; 936  :                     {
; 937  :                       segment_passes = 2;

	mov	esi, 2

; 938  :                       bypass = true;

	mov	BYTE PTR _bypass$1$[ebp], 1
$LN33@decode:

; 939  :                     }
; 940  :                 }
; 941  :               if (block->modes & Cmodes_RESTART)

	test	al, 4
	mov	eax, 1
	cmovne	esi, eax

; 942  :                 segment_passes = 1;
; 943  :               segment_truncated = false;

	xor	dl, dl
	mov	DWORD PTR _segment_passes$2$[ebp], esi
	mov	DWORD PTR tv1110[ebp], edx

; 944  :               if ((z+segment_passes) > num_passes)

	lea	eax, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR _num_passes$2$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN36@decode

; 945  :                 {
; 946  :                   segment_passes = num_passes - z;
; 947  :                   if (num_passes < max_original_passes)

	cmp	ecx, DWORD PTR _max_original_passes$1$[ebp]
	mov	eax, 1
	mov	esi, DWORD PTR tv1169[ebp]
	movzx	edx, dl
	cmovl	edx, eax
	mov	DWORD PTR _segment_passes$2$[ebp], esi
	mov	DWORD PTR tv1110[ebp], edx
$LN36@decode:

; 948  :                     segment_truncated = true;
; 949  :                 }
; 950  :               segment_bytes = 0;

	xor	ecx, ecx

; 951  :               for (int n=0; n < segment_passes; n++)

	xor	edx, edx
	mov	DWORD PTR _segment_bytes$1$[ebp], ecx
	test	esi, esi
	jle	SHORT $LN117@decode
	cmp	esi, 8
	jb	SHORT $LN117@decode

; 952  :                 segment_bytes += block->pass_lengths[z+n];

	mov	ecx, DWORD PTR [edi+52]
	mov	eax, esi
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN149@decode
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN149@decode:
	xorps	xmm2, xmm2
	sub	esi, eax

; 951  :               for (int n=0; n < segment_passes; n++)

	mov	eax, DWORD PTR tv1184[ebp]
	movaps	xmm1, xmm2
	npad	5
$LL16@decode:

; 952  :                 segment_bytes += block->pass_lengths[z+n];

	movups	xmm0, XMMWORD PTR [ecx+eax-16]
	add	edx, 8
	lea	eax, DWORD PTR [eax+32]
	paddd	xmm2, xmm0
	movups	xmm0, XMMWORD PTR [ecx+eax-32]
	paddd	xmm1, xmm0
	cmp	edx, esi
	jl	SHORT $LL16@decode
	paddd	xmm1, xmm2
	movaps	xmm0, xmm1
	psrldq	xmm0, 8
	paddd	xmm1, xmm0
	movaps	xmm0, xmm1
	psrldq	xmm0, 4
	paddd	xmm1, xmm0
	movd	ecx, xmm1
	mov	DWORD PTR _segment_bytes$1$[ebp], ecx
$LN117@decode:
	mov	eax, DWORD PTR _segment_passes$2$[ebp]
	xor	esi, esi
	xor	edi, edi
	cmp	edx, eax
	jge	$LN126@decode
	sub	eax, edx

; 951  :               for (int n=0; n < segment_passes; n++)

	cmp	eax, 2
	jl	SHORT $LC127@decode

; 952  :                 segment_bytes += block->pass_lengths[z+n];

	mov	eax, DWORD PTR _block$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR _last_segmark_z$1$[ebp]
	mov	eax, DWORD PTR [eax+52]
	mov	DWORD PTR tv1219[ebp], eax
	lea	ecx, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR _segment_passes$2$[ebp]
	sub	eax, edx
	shl	ecx, 2
	sub	eax, 2
	shr	eax, 1
	inc	eax
	lea	edx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _n$1$[ebp], edx
	mov	edx, DWORD PTR tv1219[ebp]
$LL129@decode:
	add	esi, DWORD PTR [edx+ecx]
	lea	ecx, DWORD PTR [ecx+8]
	add	edi, DWORD PTR [edx+ecx-4]
	sub	eax, 1
	jne	SHORT $LL129@decode
	mov	edx, DWORD PTR _n$1$[ebp]
$LC127@decode:

; 951  :               for (int n=0; n < segment_passes; n++)

	cmp	edx, DWORD PTR _segment_passes$2$[ebp]
	jge	SHORT $LN128@decode

; 952  :                 segment_bytes += block->pass_lengths[z+n];

	mov	eax, DWORD PTR _block$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR _last_segmark_z$1$[ebp]
	add	eax, edx
	mov	edx, DWORD PTR _segment_bytes$1$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _segment_bytes$1$[ebp], edx
$LN128@decode:
	mov	ecx, DWORD PTR _segment_bytes$1$[ebp]
	lea	eax, DWORD PTR [edi+esi]
	add	ecx, eax
	mov	DWORD PTR _segment_bytes$1$[ebp], ecx
$LN126@decode:

; 953  :               coder.start(buf,segment_bytes,!bypass);

	cmp	BYTE PTR _bypass$1$[ebp], 0
	mov	esi, DWORD PTR _buf$1$[ebp]
	sete	al
	movzx	eax, al
	push	eax
	push	ecx
	push	esi
	lea	ecx, DWORD PTR _coder$[ebp]
	call	?start@mq_decoder@@QAEXPAEH_N@Z		; mq_decoder::start

; 954  :               buf += segment_bytes;

	add	esi, DWORD PTR _segment_bytes$1$[ebp]
	mov	edi, DWORD PTR _block$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR _last_segmark_z$1$[ebp]
	mov	DWORD PTR _buf$1$[ebp], esi
	mov	esi, DWORD PTR _p$1$[ebp]
$LN28@decode:

; 955  :             }
; 956  :           if ((z == 0) || (block->modes & Cmodes_RESET))

	test	ecx, ecx
	je	SHORT $LN38@decode
	test	BYTE PTR [edi+28], 2
	je	SHORT $LN37@decode
$LN38@decode:
	mov	ecx, DWORD PTR ?p_bar_table@mq_decoder@@2PAHA

; 147  :   for (int n=0; n < 18; n++)

	xor	eax, eax
	shl	ecx, 8
$LL87@decode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 201  :   p_bar_mps = (mq_decoder::p_bar_table[Sigma] << 8) + s;

	mov	DWORD PTR _states$[ebp+eax*8], ecx

; 202  :   transition = mq_decoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR _states$[ebp+eax*8+4], OFFSET ?transition_table@mq_decoder@@2PAUmqd_transition@@A ; mq_decoder::transition_table
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 147  :   for (int n=0; n < 18; n++)

	inc	eax
	cmp	eax, 18					; 00000012H
	jl	SHORT $LL87@decode
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h

; 201  :   p_bar_mps = (mq_decoder::p_bar_table[Sigma] << 8) + s;

	mov	eax, DWORD PTR ?p_bar_table@mq_decoder@@2PAHA+16
	shl	eax, 8
	mov	DWORD PTR _states$[ebp], eax
	mov	eax, DWORD PTR ?p_bar_table@mq_decoder@@2PAHA+12
	shl	eax, 8

; 202  :   transition = mq_decoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR _states$[ebp+4], OFFSET ?transition_table@mq_decoder@@2PAUmqd_transition@@A+128

; 201  :   p_bar_mps = (mq_decoder::p_bar_table[Sigma] << 8) + s;

	mov	DWORD PTR _states$[ebp+72], eax

; 202  :   transition = mq_decoder::transition_table + ((Sigma<<1) + s);

	mov	DWORD PTR _states$[ebp+76], OFFSET ?transition_table@mq_decoder@@2PAUmqd_transition@@A+96
$LN37@decode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 962  :                 asm_decode_sig_prop_pass(coder,states,p,causal,

	push	DWORD PTR _context_row_gap$1$[ebp]
	mov	eax, DWORD PTR _this$1$[ebp]
	push	DWORD PTR _num_stripes$1$[ebp]
	push	DWORD PTR _num_cols$1$[ebp]
	cmp	BYTE PTR [eax+4], 0
	push	DWORD PTR _context_words$1$[ebp]
	mov	eax, DWORD PTR _k$1$[ebp]
	push	DWORD PTR _samples$1$[ebp]
	je	$LN39@decode

; 957  :             reset_states(states);
; 958  : #ifdef KDU_ASM_OPTIMIZATIONS
; 959  :           if (use_pentium_speedups)
; 960  :             { // Invoke highly optimized machine-specific forms where available
; 961  :               if ((k == 0) && !bypass)

	test	eax, eax
	jne	SHORT $LN43@decode
	cmp	BYTE PTR _bypass$1$[ebp], al
	jne	$LN140@decode

; 962  :                 asm_decode_sig_prop_pass(coder,states,p,causal,

	push	DWORD PTR [edi+32]
	lea	eax, DWORD PTR _states$[ebp]
	push	DWORD PTR _causal$6[ebp]
	push	esi
	push	eax
	lea	eax, DWORD PTR _coder$[ebp]
	push	eax
	call	?asm_decode_sig_prop_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z ; asm_decode_sig_prop_pass
	jmp	$LN150@decode
$LN43@decode:

; 963  :                           block->orientation,samples,context_words,
; 964  :                           num_cols,num_stripes,context_row_gap);
; 965  :               else if (k == 0)
; 966  :                 decode_sig_prop_pass_raw(coder,p,causal,samples,
; 967  :                           context_words,num_cols,num_stripes,context_row_gap);
; 968  :               else if ((k == 1) && !bypass)

	cmp	eax, 1
	jne	SHORT $LN47@decode
	cmp	BYTE PTR _bypass$1$[ebp], 0

; 969  :                 asm_decode_mag_ref_pass(coder,states,p,causal,samples,

	push	DWORD PTR _causal$6[ebp]
	push	esi
	jne	$LN141@decode
	lea	eax, DWORD PTR _states$[ebp]
	push	eax
	lea	eax, DWORD PTR _coder$[ebp]
	push	eax
	call	?asm_decode_mag_ref_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NPAH3HHH@Z ; asm_decode_mag_ref_pass
	add	esp, 36					; 00000024H
	jmp	$LN56@decode
$LN47@decode:

; 970  :                           context_words,num_cols,num_stripes,context_row_gap);
; 971  :               else if (k == 1)
; 972  :                 decode_mag_ref_pass_raw(coder,p,causal,samples,
; 973  :                           context_words,num_cols,num_stripes,context_row_gap);
; 974  :               else
; 975  :                 asm_decode_cleanup_pass(coder,states,p,causal,

	push	DWORD PTR [edi+32]
	lea	eax, DWORD PTR _states$[ebp]
	push	DWORD PTR _causal$6[ebp]
	push	esi
	push	eax
	lea	eax, DWORD PTR _coder$[ebp]
	push	eax
	call	?asm_decode_cleanup_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z ; asm_decode_cleanup_pass

; 976  :                           block->orientation,samples,context_words,
; 977  :                           num_cols,num_stripes,context_row_gap);
; 978  :             }
; 979  :           else

	jmp	$LN150@decode
$LN39@decode:

; 980  : #endif // KDU_ASM_OPTIMIZATIONS
; 981  :           if ((k == 0) && !bypass)

	test	eax, eax
	jne	SHORT $LN51@decode
	cmp	BYTE PTR _bypass$1$[ebp], al
	jne	SHORT $LN140@decode

; 982  :             decode_sig_prop_pass(coder,states,p,causal,

	push	DWORD PTR [edi+32]
	lea	eax, DWORD PTR _states$[ebp]
	push	DWORD PTR _causal$6[ebp]
	push	esi
	push	eax
	lea	eax, DWORD PTR _coder$[ebp]
	push	eax
	call	?decode_sig_prop_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z ; decode_sig_prop_pass
	jmp	SHORT $LN150@decode
$LN140@decode:

; 983  :                           block->orientation,samples,context_words,
; 984  :                           num_cols,num_stripes,context_row_gap);
; 985  :           else if (k == 0)
; 986  :             decode_sig_prop_pass_raw(coder,p,causal,samples,

	push	DWORD PTR _causal$6[ebp]
	lea	eax, DWORD PTR _coder$[ebp]
	push	esi
	push	eax
	call	?decode_sig_prop_pass_raw@@YAXAAVmq_decoder@@H_NPAH2HHH@Z ; decode_sig_prop_pass_raw
	add	esp, 32					; 00000020H
	jmp	SHORT $LN56@decode
$LN51@decode:

; 987  :                           context_words,num_cols,num_stripes,context_row_gap);
; 988  :           else if ((k == 1) && !bypass)

	cmp	eax, 1
	jne	SHORT $LN55@decode
	cmp	BYTE PTR _bypass$1$[ebp], 0

; 989  :             decode_mag_ref_pass(coder,states,p,causal,samples,

	push	DWORD PTR _causal$6[ebp]
	push	esi
	jne	SHORT $LN141@decode
	lea	eax, DWORD PTR _states$[ebp]
	push	eax
	lea	eax, DWORD PTR _coder$[ebp]
	push	eax
	call	?decode_mag_ref_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NPAH3HHH@Z ; decode_mag_ref_pass
	add	esp, 36					; 00000024H
	jmp	SHORT $LN56@decode
$LN141@decode:

; 990  :                           context_words,num_cols,num_stripes,context_row_gap);
; 991  :           else if (k == 1)
; 992  :             decode_mag_ref_pass_raw(coder,p,causal,samples,

	lea	eax, DWORD PTR _coder$[ebp]
	push	eax
	call	?decode_mag_ref_pass_raw@@YAXAAVmq_decoder@@H_NPAH2HHH@Z ; decode_mag_ref_pass_raw
	add	esp, 32					; 00000020H

; 993  :                           context_words,num_cols,num_stripes,context_row_gap);
; 994  :           else

	jmp	SHORT $LN56@decode
$LN55@decode:

; 995  :             decode_cleanup_pass(coder,states,p,causal,

	push	DWORD PTR [edi+32]
	lea	eax, DWORD PTR _states$[ebp]
	push	DWORD PTR _causal$6[ebp]
	push	esi
	push	eax
	lea	eax, DWORD PTR _coder$[ebp]
	push	eax
	call	?decode_cleanup_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z ; decode_cleanup_pass
$LN150@decode:
	add	esp, 40					; 00000028H
$LN56@decode:

; 996  :                           block->orientation,samples,context_words,
; 997  :                           num_cols,num_stripes,context_row_gap);
; 998  :           if ((block->modes & Cmodes_SEGMARK) && (k==2))

	test	BYTE PTR [edi+28], 32			; 00000020H
	je	SHORT $LN58@decode
	cmp	DWORD PTR _k$1$[ebp], 2
	jne	SHORT $LN58@decode

; 999  :             {
; 1000 :               kdu_int32 run, segmark;
; 1001 :               coder.mq_decode_run(run); segmark = run<<2;

	lea	eax, DWORD PTR _run$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _coder$[ebp]
	call	?mq_decode_run@mq_decoder@@QAEXAAH@Z	; mq_decoder::mq_decode_run
	mov	eax, DWORD PTR _run$5[ebp]

; 1002 :               coder.mq_decode_run(run); segmark += run;

	lea	ecx, DWORD PTR _coder$[ebp]
	lea	esi, DWORD PTR [eax*4]
	lea	eax, DWORD PTR _run$5[ebp]
	push	eax
	call	?mq_decode_run@mq_decoder@@QAEXAAH@Z	; mq_decoder::mq_decode_run
	add	esi, DWORD PTR _run$5[ebp]

; 1003 :               if ((segmark != 0x0A) && (block->fussy || block->resilient))

	cmp	esi, 10					; 0000000aH
	je	SHORT $LN146@decode
	cmp	BYTE PTR [edi+37], 0
	jne	$LN59@decode
	cmp	BYTE PTR [edi+36], 0
	jne	$LN59@decode
$LN146@decode:
	mov	esi, DWORD PTR _p$1$[ebp]
$LN58@decode:

; 1011 :                 }
; 1012 :             }
; 1013 :           segment_passes--;

	mov	edx, DWORD PTR _segment_passes$2$[ebp]
	sub	edx, 1
	mov	DWORD PTR _segment_passes$2$[ebp], edx

; 1014 :           if (segment_passes == 0)

	jne	SHORT $LN11@decode

; 1015 :             {
; 1016 :               if (!coder.finish(er_check && !segment_truncated))

	cmp	BYTE PTR _er_check$1$[ebp], 0
	je	SHORT $LN75@decode
	cmp	BYTE PTR tv1110[ebp], 0
	jne	SHORT $LN75@decode
	mov	al, 1
	jmp	SHORT $LN76@decode
$LN75@decode:
	xor	al, al
$LN76@decode:
	push	eax
	lea	ecx, DWORD PTR _coder$[ebp]
	call	?finish@mq_decoder@@QAE_N_N@Z		; mq_decoder::finish
	test	al, al
	je	$LN109@decode
	mov	edx, DWORD PTR _segment_passes$2$[ebp]
$LN11@decode:

; 920  :                       (block->fussy || block->resilient);
; 921  :       for (; z < num_passes; z++, k++)

	mov	ecx, DWORD PTR _last_segmark_z$1$[ebp]
	mov	eax, DWORD PTR _k$1$[ebp]
	inc	ecx
	add	DWORD PTR tv1184[ebp], 4
	inc	eax
	dec	DWORD PTR tv1169[ebp]
	mov	DWORD PTR _last_segmark_z$1$[ebp], ecx
	mov	DWORD PTR _k$1$[ebp], eax
	cmp	ecx, DWORD PTR _num_passes$2$[ebp]
	jl	$LL13@decode
$LN143@decode:

; 1054 :         }
; 1055 :     } while (error_found || ((--cpu_counter) > 0));

	mov	eax, DWORD PTR _cpu_counter$1$[ebp]
	mov	esi, DWORD PTR tv1209[ebp]
	dec	eax
	mov	edx, DWORD PTR tv1211[ebp]
	mov	DWORD PTR _cpu_counter$1$[ebp], eax
	test	eax, eax
	jg	$LL4@decode
$LN3@decode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 6345 :         if (cpu_iterations == 0) return;

	cmp	DWORD PTR [edi+132], 0
	je	SHORT $LN99@decode

; 6346 :         cpu_time += clock() - cpu_start;

	call	DWORD PTR __imp__clock
	sub	eax, DWORD PTR [edi+144]
	add	DWORD PTR [edi+148], eax

; 6347 :         cpu_unique_samples += size.x*size.y;

	mov	eax, DWORD PTR [edi]
	imul	eax, DWORD PTR [edi+4]
	cdq
	add	DWORD PTR [edi+136], eax
	adc	DWORD PTR [edi+140], edx
$LN99@decode:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 1057 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN59@decode:

; 1004 :                 { // Segmark not detected correctly.
; 1005 :                   error_found = true;
; 1006 :                   block->num_passes = (z > 2)?(z-2):0;

	mov	eax, DWORD PTR _last_segmark_z$1$[ebp]
	cmp	eax, 2
	jle	SHORT $LN73@decode
	add	eax, -2					; fffffffeH
	jmp	SHORT $LN74@decode
$LN73@decode:
	xor	eax, eax
$LN74@decode:

; 1007 :                   if (er_check && (segment_start_z > block->num_passes))

	cmp	BYTE PTR _er_check$1$[ebp], 0
	mov	DWORD PTR [edi+48], eax
	je	SHORT $LN60@decode
	mov	ecx, DWORD PTR _segment_start_z$4[ebp]
	cmp	ecx, eax
	jle	SHORT $LN60@decode

; 1008 :                     block->num_passes = segment_start_z;

	mov	DWORD PTR [edi+48], ecx
$LN60@decode:

; 1009 :                   coder.finish(); // `mq_coder' must be properly closed down.

	push	0
	lea	ecx, DWORD PTR _coder$[ebp]
	call	?finish@mq_decoder@@QAE_N_N@Z		; mq_decoder::finish

; 1010 :                   break;

	jmp	SHORT $LN142@decode
$LN109@decode:

; 1017 :                 { // Error has been detected in the current codeword segment.
; 1018 :                   error_found = true;
; 1019 :                   block->num_passes = segment_start_z;
; 1020 :                   if (block->modes & Cmodes_SEGMARK)

	test	BYTE PTR [edi+28], 32			; 00000020H
	mov	ecx, DWORD PTR _segment_start_z$4[ebp]
	mov	DWORD PTR [edi+48], ecx
	je	SHORT $LN142@decode

; 1021 :                     { // It may be that a valid segmark was detected after
; 1022 :                       // the start of the segment, prior to the current
; 1023 :                       // error.  This situation could occur if the ERTERM
; 1024 :                       // mode switch was used without the RESTART mode
; 1025 :                       // switch, in which case the above code would cause
; 1026 :                       // the entire block to be discarded, where there may
; 1027 :                       // be useful segmark information.
; 1028 :                       int last_segmark_z = z-k-1;

	mov	eax, DWORD PTR _last_segmark_z$1$[ebp]
	sub	eax, DWORD PTR _k$1$[ebp]
	dec	eax

; 1029 :                          // This is the last pass (not including the current
; 1030 :                          // one which is known to be in error), at the end
; 1031 :                          // of which a valid segmark symbol was detected.
; 1032 :                       if (last_segmark_z >= segment_start_z)

	cmp	eax, ecx
	jl	SHORT $LN142@decode

; 1033 :                         block->num_passes = last_segmark_z+1;

	inc	eax
	mov	DWORD PTR [edi+48], eax
$LN142@decode:

; 1034 :                     }
; 1035 :                   break;
; 1036 :                 }
; 1037 :             }
; 1038 :         }
; 1039 :       if (error_found)
; 1040 :         {
; 1041 :           if (block->fussy)

	cmp	BYTE PTR [edi+37], 0
	je	SHORT $LN66@decode

; 1042 :             { KDU_ERROR(e,0); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0LM@KLFCJLNO@Encountered?5incorrectly?5terminat@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 1042 :             { KDU_ERROR(e,0); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 1047 :             }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	esi, DWORD PTR tv1209[ebp]
	mov	edx, DWORD PTR tv1211[ebp]
	jmp	$LL4@decode
$LN66@decode:

; 1048 :           else if (!block->errors_detected)

	cmp	BYTE PTR [edi+124], 0
	mov	esi, DWORD PTR tv1209[ebp]
	mov	edx, DWORD PTR tv1211[ebp]
	jne	$LL4@decode

; 1051 :               KDU_WARNING(w,0); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$2[ebp]
	mov	BYTE PTR [edi+124], 1
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$2[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	OFFSET ??_C@_0DD@CFAHIJHG@One?5or?5more?5corrupted?5block?5bit?9@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 1051 :               KDU_WARNING(w,0); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp

; 1053 :             }

	lea	ecx, DWORD PTR _w$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning

; 1054 :         }
; 1055 :     } while (error_found || ((--cpu_counter) > 0));

	mov	edx, DWORD PTR tv1211[ebp]
	jmp	$LL4@decode
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z$1:
	lea	ecx, DWORD PTR _w$2[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__ehhandler$?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-360]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decode@kd_block_decoder@@MAEXPAUkdu_block@@@Z ENDP	; kd_block_decoder::decode
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
;	COMDAT ??0kd_block_decoder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0kd_block_decoder@@QAE@XZ PROC			; kd_block_decoder::kd_block_decoder, COMDAT
; _this$ = ecx

; 124  :     kd_block_decoder()

	push	ebp
	mov	ebp, esp
	push	ecx

; 125  :       {

	mov	DWORD PTR [ecx], OFFSET ??_7kd_block_decoder@@6B@

; 126  :         use_pentium_speedups = false;

	mov	BYTE PTR [ecx+4], 0

; 127  :         use_pentium_speedups = (kdu_mmx_level > 0) && kdu_pentium_cmov_exists;

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 0	; kdu_mmx_level
	mov	DWORD PTR _this$[ebp], ecx
	jle	SHORT $LN3@kd_block_d
	cmp	BYTE PTR ?kdu_pentium_cmov_exists@@3_NA, 0 ; kdu_pentium_cmov_exists
	je	SHORT $LN3@kd_block_d
	mov	BYTE PTR [ecx+4], 1

; 128  :       }

	mov	eax, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@kd_block_d:

; 127  :         use_pentium_speedups = (kdu_mmx_level > 0) && kdu_pentium_cmov_exists;

	mov	BYTE PTR [ecx+4], 0

; 128  :       }

	mov	eax, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??0kd_block_decoder@@QAE@XZ ENDP			; kd_block_decoder::kd_block_decoder
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\msvc_block_decode_asm.h
;	COMDAT ?asm_decode_cleanup_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z
_TEXT	SEGMENT
_cp_to_sp_adjust$ = -64					; size = 4
_is_causal$ = -60					; size = 4
_A_var$ = -56						; size = 4
_D_var$ = -52						; size = 4
_cp_to_sp3$ = -48					; size = 4
_stripe_end$ = -44					; size = 4
_cp_to_sp2$ = -40					; size = 4
_cp_to_sp1$ = -36					; size = 4
_cp_to_sp0$ = -32					; size = 4
_sig_lut$ = -28						; size = 4
_C_var$ = -24						; size = 4
_t_var$ = -20						; size = 4
_temp_var$ = -16					; size = 4
_S_var$ = -12						; size = 4
_one_point_five$ = -8					; size = 4
_store_var$ = -4					; size = 4
_coder$ = 8						; size = 4
_states$ = 12						; size = 4
_p$ = 16						; size = 4
_causal$ = 20						; size = 1
_orientation$ = 24					; size = 4
_samples$ = 28						; size = 4
_contexts$ = 32						; size = 4
_width$ = 36						; size = 4
_num_stripes$ = 40					; size = 4
_context_row_gap$ = 44					; size = 4
?asm_decode_cleanup_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z PROC ; asm_decode_cleanup_pass, COMDAT

; 1002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 1003 :   if ((num_stripes <= 0) || (width <= 0))

	cmp	DWORD PTR _num_stripes$[ebp], 0
	jle	SHORT $LN3@asm_decode
	cmp	DWORD PTR _width$[ebp], 0
	jg	SHORT $LN2@asm_decode
$LN3@asm_decode:

; 1004 :     return;

	jmp	$LN1@asm_decode
$LN2@asm_decode:

; 1005 :   kdu_int32 A_var, C_var, D_var, t_var, temp_var;
; 1006 :   kdu_byte *store_var;
; 1007 :   int S_var;
; 1008 :   coder.check_out(A_var,C_var,D_var,t_var,temp_var,store_var,S_var);

	lea	eax, DWORD PTR _S_var$[ebp]
	push	eax
	lea	ecx, DWORD PTR _store_var$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp_var$[ebp]
	push	edx
	lea	eax, DWORD PTR _t_var$[ebp]
	push	eax
	lea	ecx, DWORD PTR _D_var$[ebp]
	push	ecx
	lea	edx, DWORD PTR _C_var$[ebp]
	push	edx
	lea	eax, DWORD PTR _A_var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _coder$[ebp]
	call	?check_out@mq_decoder@@QAEXAAH0000AAPAE0@Z ; mq_decoder::check_out

; 1009 :   kdu_byte *sig_lut = significance_luts[orientation];

	mov	ecx, DWORD PTR _orientation$[ebp]
	mov	edx, DWORD PTR ?significance_luts@@3PAPAEA[ecx*4]
	mov	DWORD PTR _sig_lut$[ebp], edx

; 1010 :   kdu_int32 one_point_five = 1<<p; one_point_five += (one_point_five>>1);

	mov	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	shl	eax, cl
	mov	DWORD PTR _one_point_five$[ebp], eax
	mov	ecx, DWORD PTR _one_point_five$[ebp]
	sar	ecx, 1
	add	ecx, DWORD PTR _one_point_five$[ebp]
	mov	DWORD PTR _one_point_five$[ebp], ecx

; 1011 :   int is_causal = (causal)?1:0;

	movzx	edx, BYTE PTR _causal$[ebp]
	neg	edx
	sbb	edx, edx
	neg	edx
	mov	DWORD PTR _is_causal$[ebp], edx

; 1012 :   context_row_gap <<= 2; // Convert to number of bytes

	mov	eax, DWORD PTR _context_row_gap$[ebp]
	shl	eax, 2
	mov	DWORD PTR _context_row_gap$[ebp], eax

; 1013 :   width <<= 2; // Convert to number of bytes

	mov	ecx, DWORD PTR _width$[ebp]
	shl	ecx, 2
	mov	DWORD PTR _width$[ebp], ecx

; 1014 :     /* The following offsets are used to convert a context word pointer
; 1015 :        to a sample pointer.  The offsets are correct for the first
; 1016 :        stripe and must be adjusted from stripe to stripe by the addition
; 1017 :        of 3*width-EXTRA_DECODE_CWORDS. */
; 1018 :   int cp_to_sp0 = (int)((samples-contexts)<<2); // Offset for row 0

	mov	edx, DWORD PTR _samples$[ebp]
	sub	edx, DWORD PTR _contexts$[ebp]
	sar	edx, 2
	shl	edx, 2
	mov	DWORD PTR _cp_to_sp0$[ebp], edx

; 1019 :   int cp_to_sp1 = cp_to_sp0+width; // Offset for row 1

	mov	eax, DWORD PTR _cp_to_sp0$[ebp]
	add	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _cp_to_sp1$[ebp], eax

; 1020 :   int cp_to_sp2 = cp_to_sp1+width; // Offset for row 2

	mov	ecx, DWORD PTR _cp_to_sp1$[ebp]
	add	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _cp_to_sp2$[ebp], ecx

; 1021 :   int cp_to_sp3 = cp_to_sp2+width; // Offset for row 3

	mov	edx, DWORD PTR _cp_to_sp2$[ebp]
	add	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _cp_to_sp3$[ebp], edx

; 1022 :   int cp_to_sp_adjust = 3*width-4*EXTRA_DECODE_CWORDS;

	imul	eax, DWORD PTR _width$[ebp], 3
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR _cp_to_sp_adjust$[ebp], eax

; 1023 :   kdu_int32 *stripe_end; // Points to context word beyond end of current stripe
; 1024 : 
; 1025 :   __asm {
; 1026 :     MOV EDI,contexts // Set EDI aside to hold the context word pointer

	mov	edi, DWORD PTR _contexts$[ebp]

; 1027 :     MOV EDX,D_var // Set EDX aside to hold the critical MQ variable, D

	mov	edx, DWORD PTR _D_var$[ebp]

; 1028 :     MOV ESI,A_var // Set ESI aside to hold the MQ coder's A register

	mov	esi, DWORD PTR _A_var$[ebp]
$next_stripe$11:

; 1029 : next_stripe:
; 1030 :     MOV EAX,width

	mov	eax, DWORD PTR _width$[ebp]

; 1031 :     ADD EAX,EDI

	add	eax, edi

; 1032 :     MOV stripe_end,EAX // Set end pointer for this stripe

	mov	DWORD PTR _stripe_end$[ebp], eax
$next_stripe_column$12:

; 1033 : next_stripe_column:
; 1034 :     MOV ECX,[EDI]

	mov	ecx, DWORD PTR [edi]

; 1035 :     TEST ECX,ECX

	test	ecx, ecx

; 1036 :     JNZ row0

	jne	$row0$13

; 1037 :     // Enter the run mode.
; 1038 :     MOV ECX,states

	mov	ecx, DWORD PTR _states$[ebp]

; 1039 :     ADD ECX,KAPPA_RUN_BASE*8 // Gets address of run context to ECX

	add	ecx, 72					; 00000048H

; 1040 :     MOV EAX,[ECX] // Get `p_bar_mps' to EAX

	mov	eax, DWORD PTR [ecx]

; 1041 :     TEST EAX,1

	test	eax, 1

; 1042 :     JNZ decode_single_symbol_with_mps1

	jne	SHORT $decode_single_symbol_with_mps1$14

; 1043 :     // Try to skip over 4 columns at once
; 1044 :     MOV EBX,[EDI+12]

	mov	ebx, DWORD PTR [edi+12]

; 1045 :     TEST EBX,EBX

	test	ebx, ebx

; 1046 :     JNZ decode_single_symbol_with_mps0

	jne	SHORT $decode_single_symbol_with_mps0$15

; 1047 :     SHL EAX,2

	shl	eax, 2

; 1048 :     SUB EDX,EAX

	sub	edx, eax

; 1049 :     JL multi_symbol_decode_failed

	jl	SHORT $multi_symbol_decode_failed$16

; 1050 :     ADD EDI,16

	add	edi, 16					; 00000010H

; 1051 :     CMP EDI,stripe_end

	cmp	edi, DWORD PTR _stripe_end$[ebp]

; 1052 :     JNZ next_stripe_column

	jne	SHORT $next_stripe_column$12

; 1053 :     JMP advance_stripe

	jmp	$advance_stripe$17
$multi_symbol_decode_failed$16:

; 1054 : multi_symbol_decode_failed:
; 1055 :     ADD EDX,EAX

	add	edx, eax

; 1056 :     SHR EAX,2

	shr	eax, 2
$decode_single_symbol_with_mps0$15:

; 1057 : decode_single_symbol_with_mps0:
; 1058 :     SUB EDX,EAX

	sub	edx, eax

; 1059 :     JGE uninterrupted_run // MPS decoded and it is 0

	jge	SHORT $uninterrupted_run$18

; 1060 :     CALL mq_non_cdp

	call	$mq_non_cdp$19

; 1061 :     TEST EAX,1

	test	eax, 1

; 1062 :     JNZ run_interruption

	jne	SHORT $run_interruption$20
$uninterrupted_run$18:

; 1063 : uninterrupted_run:
; 1064 :     ADD EDI,4

	add	edi, 4

; 1065 :     CMP EDI,stripe_end

	cmp	edi, DWORD PTR _stripe_end$[ebp]

; 1066 :     JNZ next_stripe_column

	jne	SHORT $next_stripe_column$12

; 1067 :     JMP advance_stripe

	jmp	$advance_stripe$17
$decode_single_symbol_with_mps1$14:

; 1068 : decode_single_symbol_with_mps1:
; 1069 :     SUB EDX,EAX

	sub	edx, eax

; 1070 :     ADD EDX,1 // Compensate for the non-zero MPS bit in EAX

	add	edx, 1

; 1071 :     JGE run_interruption // MPS decoded but it is 1

	jge	SHORT $run_interruption$20

; 1072 :     CALL mq_non_cdp

	call	$mq_non_cdp$19

; 1073 :     TEST EAX,1

	test	eax, 1

; 1074 :     JZ uninterrupted_run

	je	SHORT $uninterrupted_run$18
$run_interruption$20:

; 1075 : run_interruption:
; 1076 :     ASM_MQ_DECODE_RUN  // Returns with the run in the 2 LSB's of EAX

	xor	eax, eax
	mov	ecx, DWORD PTR _C_var$[ebp]
	sub	edx, 5636352				; 00560100H
	jge	$run_bit0$21
	add	esi, edx
	add	ecx, edx
	jl	SHORT $run_bit1_Clt0$22
	cmp	esi, 5636352				; 00560100H
	jge	SHORT $run_bit1_renorm$23
	mov	eax, 2
	jmp	SHORT $run_bit1_renorm$23
$run_bit1_Clt0$22:
	add	ecx, 5636352				; 00560100H
	cmp	esi, 5636352				; 00560100H
	mov	esi, 5636352				; 00560100H
	jl	SHORT $run_bit1_renorm$23
	mov	eax, 2
$run_bit1_renorm$23:
	mov	ebx, DWORD PTR _t_var$[ebp]
$run_bit1_renorm_once$24:
	test	ebx, ebx
	jne	SHORT $run_bit1_have_more_bits$25
	mov	edx, DWORD PTR _temp_var$[ebp]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $run_bit1_no_ff$26
	mov	ebx, DWORD PTR _store_var$[ebp]
	movzx	edx, BYTE PTR [ebx]
	cmp	edx, 143				; 0000008fH
	jle	SHORT $run_bit1_temp_le8F$27
	mov	edx, 255				; 000000ffH
	mov	ebx, DWORD PTR _S_var$[ebp]
	add	ebx, 1
	mov	DWORD PTR _S_var$[ebp], ebx
	mov	ebx, 8
	jmp	SHORT $run_bit1_complete_fill_lsbs$28
$run_bit1_temp_le8F$27:
	add	ecx, edx
	add	ebx, 1
	mov	DWORD PTR _store_var$[ebp], ebx
	mov	ebx, 7
	jmp	SHORT $run_bit1_complete_fill_lsbs$28
$run_bit1_no_ff$26:
	mov	ebx, DWORD PTR _store_var$[ebp]
	movzx	edx, BYTE PTR [ebx]
	add	ebx, 1
	mov	DWORD PTR _store_var$[ebp], ebx
	mov	ebx, 8
$run_bit1_complete_fill_lsbs$28:
	add	ecx, edx
	mov	DWORD PTR _temp_var$[ebp], edx
$run_bit1_have_more_bits$25:
	add	esi, esi
	add	ecx, ecx
	sub	ebx, 1
	test	esi, 8388608				; 00800000H
	je	SHORT $run_bit1_renorm_once$24
	mov	DWORD PTR _t_var$[ebp], ebx
	mov	edx, esi
	sub	edx, 8388608				; 00800000H
	cmp	ecx, edx
	cmovl	edx, ecx
	sub	esi, edx
	sub	ecx, edx
$run_bit0$21:
	sub	edx, 5636352				; 00560100H
	jge	$run_finished$29
	add	esi, edx
	add	ecx, edx
	jl	SHORT $run_bit0_Clt0$30
	cmp	esi, 5636352				; 00560100H
	jge	SHORT $run_bit0_renorm$31
	add	eax, 1
	jmp	SHORT $run_bit0_renorm$31
$run_bit0_Clt0$30:
	add	ecx, 5636352				; 00560100H
	cmp	esi, 5636352				; 00560100H
	mov	esi, 5636352				; 00560100H
	jl	SHORT $run_bit0_renorm$31
	add	eax, 1
$run_bit0_renorm$31:
	mov	ebx, DWORD PTR _t_var$[ebp]
$run_bit0_renorm_once$32:
	test	ebx, ebx
	jne	SHORT $run_bit0_have_more_bits$33
	mov	edx, DWORD PTR _temp_var$[ebp]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $run_bit0_no_ff$34
	mov	ebx, DWORD PTR _store_var$[ebp]
	movzx	edx, BYTE PTR [ebx]
	cmp	edx, 143				; 0000008fH
	jle	SHORT $run_bit0_temp_le8F$35
	mov	edx, 255				; 000000ffH
	mov	ebx, DWORD PTR _S_var$[ebp]
	add	ebx, 1
	mov	DWORD PTR _S_var$[ebp], ebx
	mov	ebx, 8
	jmp	SHORT $run_bit0_complete_fill_lsbs$36
$run_bit0_temp_le8F$35:
	add	ecx, edx
	add	ebx, 1
	mov	DWORD PTR _store_var$[ebp], ebx
	mov	ebx, 7
	jmp	SHORT $run_bit0_complete_fill_lsbs$36
$run_bit0_no_ff$34:
	mov	ebx, DWORD PTR _store_var$[ebp]
	movzx	edx, BYTE PTR [ebx]
	add	ebx, 1
	mov	DWORD PTR _store_var$[ebp], ebx
	mov	ebx, 8
$run_bit0_complete_fill_lsbs$36:
	add	ecx, edx
	mov	DWORD PTR _temp_var$[ebp], edx
$run_bit0_have_more_bits$33:
	add	esi, esi
	add	ecx, ecx
	sub	ebx, 1
	test	esi, 8388608				; 00800000H
	je	SHORT $run_bit0_renorm_once$32
	mov	DWORD PTR _t_var$[ebp], ebx
	mov	edx, esi
	sub	edx, 8388608				; 00800000H
	cmp	ecx, edx
	cmovl	edx, ecx
	sub	esi, edx
	sub	ecx, edx
$run_finished$29:
	mov	DWORD PTR _C_var$[ebp], ecx

; 1077 :     MOV ECX,[EDI] // Get context word back again

	mov	ecx, DWORD PTR [edi]

; 1078 :     TEST EAX,EAX

	test	eax, eax

; 1079 :     JZ row0_significant

	je	SHORT $row0_significant$37

; 1080 :     JP row3_significant // Parity means there are an even number of 1's (run=3)

	jp	$row3_significant$38

; 1081 :     TEST EAX,1

	test	eax, 1

; 1082 :     JNZ row1_significant

	jne	$row1_significant$39

; 1083 :     JMP row2_significant

	jmp	$row2_significant$40
$row0$13:

; 1084 : row0:
; 1085 :       // Test for coding pass membership
; 1086 :       TEST ECX,__CLEANUP_MEMBER_MASK*1

	test	ecx, 3145744				; 00300010H

; 1087 :       JNZ row1

	jne	$row1$41

; 1088 :       // Find pointer to the relevant context state record
; 1089 :       AND ECX,__NBRHD_MASK

	and	ecx, 495				; 000001efH

; 1090 :       ADD ECX,sig_lut

	add	ecx, DWORD PTR _sig_lut$[ebp]

; 1091 :       MOVZX ECX,byte ptr [ECX]

	movzx	ecx, BYTE PTR [ecx]

; 1092 :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 1093 :       LEA ECX,[EBX+8*ECX]

	lea	ecx, DWORD PTR [ebx+ecx*8]

; 1094 :       // decode symbol
; 1095 :       MOV EAX,[ECX] // Get `p_bar_mps' to EAX

	mov	eax, DWORD PTR [ecx]

; 1096 :       SUB EDX,EAX

	sub	edx, eax

; 1097 :       AND EAX,1 // Get MPS identity in LSB of EAX

	and	eax, 1

; 1098 :       ADD EDX,EAX // Correct for the effect of the MPS

	add	edx, eax

; 1099 :       JGE significance_test0

	jge	SHORT $significance_test0$42

; 1100 :       CALL mq_non_cdp

	call	$mq_non_cdp$19
$significance_test0$42:

; 1101 : significance_test0:
; 1102 :       MOV ECX,[EDI] // Get context word back again

	mov	ecx, DWORD PTR [edi]

; 1103 :       TEST EAX,EAX // If symbol != 0

	test	eax, eax

; 1104 :       JZ row1

	je	$row1$41
$row0_significant$37:

; 1105 : row0_significant:
; 1106 :       // If we get here, we know that stripe row 0 is newly significant
; 1107 :       AND ECX,__CHI_BIT/8+__SIGMA_CC_BIT/8+__CHI_BIT*8+__SIGMA_CC_BIT*8

	and	ecx, 17039490				; 01040082H

; 1108 :       SHR ECX,1

	shr	ecx, 1

; 1109 :       MOV EAX,[EDI-4] // Get context word on left

	mov	eax, DWORD PTR [edi-4]

; 1110 :       AND EAX,__CHI_BIT+__SIGMA_CC_BIT

	and	eax, 2097168				; 00200010H

; 1111 :       SHR EAX,2

	shr	eax, 2

; 1112 :       ADD ECX,EAX

	add	ecx, eax

; 1113 :       MOV EAX,[EDI+4] // Get context word on right

	mov	eax, DWORD PTR [edi+4]

; 1114 :       AND EAX,__CHI_BIT+__SIGMA_CC_BIT

	and	eax, 2097168				; 00200010H

; 1115 :       ADD ECX,EAX

	add	ecx, eax

; 1116 :       MOV EAX,ECX

	mov	eax, ecx

; 1117 :       SHR EAX,CHI_POS-1-SIGMA_CC_POS

	shr	eax, 16					; 00000010H

; 1118 :       OR ECX,EAX

	or	ecx, eax

; 1119 :       AND ECX,0x000000FF

	and	ecx, 255				; 000000ffH

; 1120 :       MOVZX ECX,byte ptr [sign_lut+ECX]

	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]

; 1121 :       MOV EAX,ECX // Save the sign LUT result in EAX

	mov	eax, ecx

; 1122 :       SHR ECX,1 // Get context label part of the LUT result

	shr	ecx, 1

; 1123 :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 1124 :       LEA ECX,[EBX+8*ECX+8*KAPPA_SIGN_BASE] // ECX has pointer to context state

	lea	ecx, DWORD PTR [ebx+ecx*8+80]

; 1125 :       MOV EBX,[ECX] // Get `p_bar_mps' to EBX

	mov	ebx, DWORD PTR [ecx]

; 1126 :       XOR EAX,EBX

	xor	eax, ebx

; 1127 :       AND EAX,1 // Leaves EAX with the MPS sign value in its LSB.

	and	eax, 1

; 1128 :       BTR EBX,0 // Leaves `p_bar' in EBX

	btr	ebx, 0

; 1129 :       SUB EDX,EBX

	sub	edx, ebx

; 1130 :       JGE row0_broadcast

	jge	SHORT $row0_broadcast$43

; 1131 :       CALL mq_non_cdp

	call	$mq_non_cdp$19
$row0_broadcast$43:

; 1132 : row0_broadcast: // Process newly significant sample; sign is in LSB of EAX
; 1133 :       // Broadcast significance and sign to last row of previous stripe
; 1134 :       MOV EBX,is_causal

	mov	ebx, DWORD PTR _is_causal$[ebp]

; 1135 :       TEST EBX,EBX

	test	ebx, ebx

; 1136 :       JNZ row0_skip_non_causal

	jne	SHORT $row0_skip_non_causal$44

; 1137 :       MOV EBX,EDI

	mov	ebx, edi

; 1138 :       SUB EBX,context_row_gap

	sub	ebx, DWORD PTR _context_row_gap$[ebp]

; 1139 :       MOV ECX,[EBX-4]

	mov	ecx, DWORD PTR [ebx-4]

; 1140 :       OR ECX,__SIGMA_BR_BIT*512

	or	ecx, 131072				; 00020000H

; 1141 :       MOV [EBX-4],ECX

	mov	DWORD PTR [ebx-4], ecx

; 1142 :       MOV ECX,EAX

	mov	ecx, eax

; 1143 :       SHL ECX,NEXT_CHI_POS

	shl	ecx, 31					; 0000001fH

; 1144 :       OR ECX,[EBX]

	or	ecx, DWORD PTR [ebx]

; 1145 :       OR ECX,__SIGMA_BC_BIT*512

	or	ecx, 65536				; 00010000H

; 1146 :       MOV [EBX],ECX

	mov	DWORD PTR [ebx], ecx

; 1147 :       MOV ECX,[EBX+4]

	mov	ecx, DWORD PTR [ebx+4]

; 1148 :       OR ECX,__SIGMA_BL_BIT*512

	or	ecx, 32768				; 00008000H

; 1149 :       MOV [EBX+4],ECX

	mov	DWORD PTR [ebx+4], ecx
$row0_skip_non_causal$44:

; 1150 : row0_skip_non_causal:
; 1151 :       // Broadcast significance to left and right neighbours
; 1152 :       MOV ECX,[EDI-4]

	mov	ecx, DWORD PTR [edi-4]

; 1153 :       OR ECX,__SIGMA_CR_BIT*1

	or	ecx, 32					; 00000020H

; 1154 :       MOV [EDI-4],ECX

	mov	DWORD PTR [edi-4], ecx

; 1155 :       MOV ECX,[EDI+4]

	mov	ecx, DWORD PTR [edi+4]

; 1156 :       OR ECX,__SIGMA_CL_BIT*1

	or	ecx, 8

; 1157 :       MOV [EDI+4],ECX

	mov	DWORD PTR [edi+4], ecx

; 1158 :       // Recover and update context word, using ECX register
; 1159 :       MOV ECX,EAX

	mov	ecx, eax

; 1160 :       SHL ECX,CHI_POS

	shl	ecx, 21					; 00000015H

; 1161 :       OR ECX,[EDI]

	or	ecx, DWORD PTR [edi]

; 1162 :       OR ECX,__SIGMA_CC_BIT*1

	or	ecx, 16					; 00000010H

; 1163 :       MOV [EDI],ECX

	mov	DWORD PTR [edi], ecx

; 1164 :       // Write newly significant sample value
; 1165 :       SHL EAX,31 // Get sign bit of result into right position

	shl	eax, 31					; 0000001fH

; 1166 :       ADD EAX,one_point_five

	add	eax, DWORD PTR _one_point_five$[ebp]

; 1167 :       MOV EBX,cp_to_sp0

	mov	ebx, DWORD PTR _cp_to_sp0$[ebp]

; 1168 :       MOV [EDI+EBX],EAX

	mov	DWORD PTR [edi+ebx], eax
$row1$41:

; 1169 : row1:
; 1170 :       // Test for coding pass membership
; 1171 :       TEST ECX,__CLEANUP_MEMBER_MASK*8

	test	ecx, 25165952				; 01800080H

; 1172 :       JNZ row2

	jne	$row2$45

; 1173 :       // Find pointer to the relevant context state record
; 1174 :       SHR ECX,3

	shr	ecx, 3

; 1175 :       AND ECX,__NBRHD_MASK

	and	ecx, 495				; 000001efH

; 1176 :       ADD ECX,sig_lut

	add	ecx, DWORD PTR _sig_lut$[ebp]

; 1177 :       MOVZX ECX,byte ptr [ECX]

	movzx	ecx, BYTE PTR [ecx]

; 1178 :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 1179 :       LEA ECX,[EBX+8*ECX]

	lea	ecx, DWORD PTR [ebx+ecx*8]

; 1180 :       // Decode symbol
; 1181 :       MOV EAX,[ECX] // Get `p_bar_mps' to EAX

	mov	eax, DWORD PTR [ecx]

; 1182 :       SUB EDX,EAX

	sub	edx, eax

; 1183 :       AND EAX,1 // Get MPS identity in LSB of EAX

	and	eax, 1

; 1184 :       ADD EDX,EAX // Correct for the effect of the MPS

	add	edx, eax

; 1185 :       JGE significance_test1

	jge	SHORT $significance_test1$46

; 1186 :       CALL mq_non_cdp

	call	$mq_non_cdp$19
$significance_test1$46:

; 1187 : significance_test1:
; 1188 :       MOV ECX,[EDI] // Get context word back again

	mov	ecx, DWORD PTR [edi]

; 1189 :       TEST EAX,EAX // If symbol != 0

	test	eax, eax

; 1190 :       JZ row2

	je	$row2$45
$row1_significant$39:

; 1191 : row1_significant:
; 1192 :       // If we get here, we know that stripe row 1 is newly significant
; 1193 :       AND ECX,__CHI_BIT+__SIGMA_CC_BIT+__CHI_BIT*64+__SIGMA_CC_BIT*64

	and	ecx, 136315920				; 08200410H

; 1194 :       SHR ECX,4

	shr	ecx, 4

; 1195 :       MOV EAX,[EDI-4] // Get context word on left

	mov	eax, DWORD PTR [edi-4]

; 1196 :       AND EAX,__CHI_BIT*8+__SIGMA_CC_BIT*8

	and	eax, 16777344				; 01000080H

; 1197 :       SHR EAX,5

	shr	eax, 5

; 1198 :       ADD ECX,EAX

	add	ecx, eax

; 1199 :       MOV EAX,[EDI+4] // Get context word on right

	mov	eax, DWORD PTR [edi+4]

; 1200 :       AND EAX,__CHI_BIT*8+__SIGMA_CC_BIT*8

	and	eax, 16777344				; 01000080H

; 1201 :       SHR EAX,3

	shr	eax, 3

; 1202 :       ADD ECX,EAX

	add	ecx, eax

; 1203 :       MOV EAX,ECX

	mov	eax, ecx

; 1204 :       SHR EAX,CHI_POS-1-SIGMA_CC_POS

	shr	eax, 16					; 00000010H

; 1205 :       OR ECX,EAX

	or	ecx, eax

; 1206 :       AND ECX,0x000000FF

	and	ecx, 255				; 000000ffH

; 1207 :       MOVZX ECX,byte ptr [sign_lut+ECX]

	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]

; 1208 :       MOV EAX,ECX // Save the sign LUT result in EAX

	mov	eax, ecx

; 1209 :       SHR ECX,1 // Get context label part of the LUT result

	shr	ecx, 1

; 1210 :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 1211 :       LEA ECX,[EBX+8*ECX+8*KAPPA_SIGN_BASE] // ECX has pointer to context state

	lea	ecx, DWORD PTR [ebx+ecx*8+80]

; 1212 :       MOV EBX,[ECX] // Get `p_bar_mps' to EBX

	mov	ebx, DWORD PTR [ecx]

; 1213 :       XOR EAX,EBX

	xor	eax, ebx

; 1214 :       AND EAX,1 // Leaves EAX with the MPS sign value in its LSB.

	and	eax, 1

; 1215 :       BTR EBX,0 // Leaves `p_bar' in EBX

	btr	ebx, 0

; 1216 :       SUB EDX,EBX

	sub	edx, ebx

; 1217 :       JGE row1_broadcast

	jge	SHORT $row1_broadcast$47

; 1218 :       CALL mq_non_cdp

	call	$mq_non_cdp$19
$row1_broadcast$47:

; 1219 : row1_broadcast: // Process newly significant sample; sign is in LSB of EAX
; 1220 :       // Broadcast significance to left and right neighbours
; 1221 :       MOV ECX,[EDI-4]

	mov	ecx, DWORD PTR [edi-4]

; 1222 :       OR ECX,__SIGMA_CR_BIT*8

	or	ecx, 256				; 00000100H

; 1223 :       MOV [EDI-4],ECX

	mov	DWORD PTR [edi-4], ecx

; 1224 :       MOV ECX,[EDI+4]

	mov	ecx, DWORD PTR [edi+4]

; 1225 :       OR ECX,__SIGMA_CL_BIT*8

	or	ecx, 64					; 00000040H

; 1226 :       MOV [EDI+4],ECX

	mov	DWORD PTR [edi+4], ecx

; 1227 :       // Recover and update context word, using ECX register
; 1228 :       MOV ECX,EAX

	mov	ecx, eax

; 1229 :       SHL ECX,CHI_POS+3

	shl	ecx, 24					; 00000018H

; 1230 :       OR ECX,[EDI]

	or	ecx, DWORD PTR [edi]

; 1231 :       OR ECX,__SIGMA_CC_BIT*8

	or	ecx, 128				; 00000080H

; 1232 :       MOV [EDI],ECX

	mov	DWORD PTR [edi], ecx

; 1233 :       // Write new significant sample value
; 1234 :       SHL EAX,31 // Get sign bit of result into right position

	shl	eax, 31					; 0000001fH

; 1235 :       ADD EAX,one_point_five

	add	eax, DWORD PTR _one_point_five$[ebp]

; 1236 :       MOV EBX,cp_to_sp1

	mov	ebx, DWORD PTR _cp_to_sp1$[ebp]

; 1237 :       MOV [EDI+EBX],EAX

	mov	DWORD PTR [edi+ebx], eax
$row2$45:

; 1238 : row2:
; 1239 :       // Test for coding pass membership
; 1240 :       TEST ECX,__CLEANUP_MEMBER_MASK*64

	test	ecx, 201327616				; 0c000400H

; 1241 :       JNZ row3

	jne	$row3$48

; 1242 :       // Find pointer to the relevant context state record
; 1243 :       SHR ECX,6

	shr	ecx, 6

; 1244 :       AND ECX,__NBRHD_MASK

	and	ecx, 495				; 000001efH

; 1245 :       ADD ECX,sig_lut

	add	ecx, DWORD PTR _sig_lut$[ebp]

; 1246 :       MOVZX ECX,byte ptr [ECX]

	movzx	ecx, BYTE PTR [ecx]

; 1247 :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 1248 :       LEA ECX,[EBX+8*ECX]

	lea	ecx, DWORD PTR [ebx+ecx*8]

; 1249 :       // Decode symbol
; 1250 :       MOV EAX,[ECX] // Get `p_bar_mps' to EAX

	mov	eax, DWORD PTR [ecx]

; 1251 :       SUB EDX,EAX

	sub	edx, eax

; 1252 :       AND EAX,1 // Get MPS identity in LSB of EAX

	and	eax, 1

; 1253 :       ADD EDX,EAX // Correct for the effect of the MPS

	add	edx, eax

; 1254 :       JGE significance_test2

	jge	SHORT $significance_test2$49

; 1255 :       CALL mq_non_cdp

	call	$mq_non_cdp$19
$significance_test2$49:

; 1256 : significance_test2:
; 1257 :       MOV ECX,[EDI] // Get context word back again

	mov	ecx, DWORD PTR [edi]

; 1258 :       TEST EAX,EAX // If symbol != 0

	test	eax, eax

; 1259 :       JZ row3

	je	$row3$48
$row2_significant$40:

; 1260 : row2_significant:
; 1261 :       // If we get here, we know that stripe row 2 is newly significant
; 1262 :       AND ECX,__CHI_BIT*8+__SIGMA_CC_BIT*8+__CHI_BIT*512+__SIGMA_CC_BIT*512

	and	ecx, 1090527360				; 41002080H

; 1263 :       SHR ECX,7

	shr	ecx, 7

; 1264 :       MOV EAX,[EDI-4] // Get context word on left

	mov	eax, DWORD PTR [edi-4]

; 1265 :       AND EAX,__CHI_BIT*64+__SIGMA_CC_BIT*64

	and	eax, 134218752				; 08000400H

; 1266 :       SHR EAX,8

	shr	eax, 8

; 1267 :       ADD ECX,EAX

	add	ecx, eax

; 1268 :       MOV EAX,[EDI+4] // Get context word on right

	mov	eax, DWORD PTR [edi+4]

; 1269 :       AND EAX,__CHI_BIT*64+__SIGMA_CC_BIT*64

	and	eax, 134218752				; 08000400H

; 1270 :       SHR EAX,6

	shr	eax, 6

; 1271 :       ADD ECX,EAX

	add	ecx, eax

; 1272 :       MOV EAX,ECX

	mov	eax, ecx

; 1273 :       SHR EAX,CHI_POS-1-SIGMA_CC_POS

	shr	eax, 16					; 00000010H

; 1274 :       OR ECX,EAX

	or	ecx, eax

; 1275 :       AND ECX,0x000000FF

	and	ecx, 255				; 000000ffH

; 1276 :       MOVZX ECX,byte ptr [sign_lut+ECX]

	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]

; 1277 :       MOV EAX,ECX // Save the sign LUT result in EAX

	mov	eax, ecx

; 1278 :       SHR ECX,1 // Get context label part of the LUT result

	shr	ecx, 1

; 1279 :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 1280 :       LEA ECX,[EBX+8*ECX+8*KAPPA_SIGN_BASE] // ECX has pointer to context state

	lea	ecx, DWORD PTR [ebx+ecx*8+80]

; 1281 :       MOV EBX,[ECX] // Get `p_bar_mps' to EBX

	mov	ebx, DWORD PTR [ecx]

; 1282 :       XOR EAX,EBX

	xor	eax, ebx

; 1283 :       AND EAX,1 // Leaves EAX with the MPS sign value in its LSB.

	and	eax, 1

; 1284 :       BTR EBX,0 // Leaves `p_bar' in EBX

	btr	ebx, 0

; 1285 :       SUB EDX,EBX

	sub	edx, ebx

; 1286 :       JGE row2_broadcast

	jge	SHORT $row2_broadcast$50

; 1287 :       CALL mq_non_cdp

	call	$mq_non_cdp$19
$row2_broadcast$50:

; 1288 : row2_broadcast: // Process newly significant sample; sign is in LSB of EAX
; 1289 :       // Broadcast significance to left and right neighbours
; 1290 :       MOV ECX,[EDI-4]

	mov	ecx, DWORD PTR [edi-4]

; 1291 :       OR ECX,__SIGMA_CR_BIT*64

	or	ecx, 2048				; 00000800H

; 1292 :       MOV [EDI-4],ECX

	mov	DWORD PTR [edi-4], ecx

; 1293 :       MOV ECX,[EDI+4]

	mov	ecx, DWORD PTR [edi+4]

; 1294 :       OR ECX,__SIGMA_CL_BIT*64

	or	ecx, 512				; 00000200H

; 1295 :       MOV [EDI+4],ECX

	mov	DWORD PTR [edi+4], ecx

; 1296 :       // Recover and update context word, using ECX register
; 1297 :       MOV ECX,EAX

	mov	ecx, eax

; 1298 :       SHL ECX,CHI_POS+6

	shl	ecx, 27					; 0000001bH

; 1299 :       OR ECX,[EDI]

	or	ecx, DWORD PTR [edi]

; 1300 :       OR ECX,__SIGMA_CC_BIT*64

	or	ecx, 1024				; 00000400H

; 1301 :       MOV [EDI],ECX

	mov	DWORD PTR [edi], ecx

; 1302 :       // Write new significant sample value
; 1303 :       SHL EAX,31 // Get sign bit of result into right position

	shl	eax, 31					; 0000001fH

; 1304 :       ADD EAX,one_point_five

	add	eax, DWORD PTR _one_point_five$[ebp]

; 1305 :       MOV EBX,cp_to_sp2

	mov	ebx, DWORD PTR _cp_to_sp2$[ebp]

; 1306 :       MOV [EDI+EBX],EAX

	mov	DWORD PTR [edi+ebx], eax
$row3$48:

; 1307 : row3:
; 1308 :       // Test for coding pass membership
; 1309 :       TEST ECX,__CLEANUP_MEMBER_MASK*512

	test	ecx, 1610620928				; 60002000H

; 1310 :       JNZ advance_stripe_column

	jne	$advance_stripe_column$51

; 1311 :       // Find pointer to the relevant context state record
; 1312 :       SHR ECX,9

	shr	ecx, 9

; 1313 :       AND ECX,__NBRHD_MASK

	and	ecx, 495				; 000001efH

; 1314 :       ADD ECX,sig_lut

	add	ecx, DWORD PTR _sig_lut$[ebp]

; 1315 :       MOVZX ECX,byte ptr [ECX]

	movzx	ecx, BYTE PTR [ecx]

; 1316 :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 1317 :       LEA ECX,[EBX+8*ECX]

	lea	ecx, DWORD PTR [ebx+ecx*8]

; 1318 :       // Decode symbol
; 1319 :       MOV EAX,[ECX] // Get `p_bar_mps' to EAX

	mov	eax, DWORD PTR [ecx]

; 1320 :       SUB EDX,EAX

	sub	edx, eax

; 1321 :       AND EAX,1 // Get MPS identity in LSB of EAX

	and	eax, 1

; 1322 :       ADD EDX,EAX // Correct for the effect of the MPS

	add	edx, eax

; 1323 :       JGE significance_test3

	jge	SHORT $significance_test3$52

; 1324 :       CALL mq_non_cdp

	call	$mq_non_cdp$19
$significance_test3$52:

; 1325 : significance_test3:
; 1326 :       MOV ECX,[EDI] // Get context word back again

	mov	ecx, DWORD PTR [edi]

; 1327 :       TEST EAX,EAX // If symbol != 0

	test	eax, eax

; 1328 :       JZ advance_stripe_column

	je	$advance_stripe_column$51
$row3_significant$38:

; 1329 : row3_significant:
; 1330 :       // If we get here, we know that stripe row 3 is newly significant
; 1331 :       MOV EBX,ECX // Make copy of ECX for exceptional sign processing

	mov	ebx, ecx

; 1332 :       AND ECX,__CHI_BIT*64+__SIGMA_CC_BIT*64+__SIGMA_CC_BIT*4096

	and	ecx, 134284288				; 08010400H

; 1333 :       SHR ECX,10

	shr	ecx, 10					; 0000000aH

; 1334 :       TEST EBX,EBX

	test	ebx, ebx

; 1335 :       JGE no_exceptional_sign_processing

	jge	SHORT $no_exceptional_sign_processing$53

; 1336 :       OR ECX,__CHI_BIT*4

	or	ecx, 8388608				; 00800000H
$no_exceptional_sign_processing$53:

; 1337 : no_exceptional_sign_processing:
; 1338 :       MOV EAX,[EDI-4] // Get context word on left

	mov	eax, DWORD PTR [edi-4]

; 1339 :       AND EAX,__CHI_BIT*512+__SIGMA_CC_BIT*512

	and	eax, 1073750016				; 40002000H

; 1340 :       SHR EAX,11

	shr	eax, 11					; 0000000bH

; 1341 :       ADD ECX,EAX

	add	ecx, eax

; 1342 :       MOV EAX,[EDI+4] // Get context word on right

	mov	eax, DWORD PTR [edi+4]

; 1343 :       AND EAX,__CHI_BIT*512+__SIGMA_CC_BIT*512

	and	eax, 1073750016				; 40002000H

; 1344 :       SHR EAX,9

	shr	eax, 9

; 1345 :       ADD ECX,EAX

	add	ecx, eax

; 1346 :       MOV EAX,ECX

	mov	eax, ecx

; 1347 :       SHR EAX,CHI_POS-1-SIGMA_CC_POS

	shr	eax, 16					; 00000010H

; 1348 :       OR ECX,EAX

	or	ecx, eax

; 1349 :       AND ECX,0x000000FF

	and	ecx, 255				; 000000ffH

; 1350 :       MOVZX ECX,byte ptr [sign_lut+ECX]

	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]

; 1351 :       MOV EAX,ECX // Save the sign LUT result in EAX

	mov	eax, ecx

; 1352 :       SHR ECX,1 // Get context label part of the LUT result

	shr	ecx, 1

; 1353 :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 1354 :       LEA ECX,[EBX+8*ECX+8*KAPPA_SIGN_BASE] // ECX has pointer to context state

	lea	ecx, DWORD PTR [ebx+ecx*8+80]

; 1355 :       MOV EBX,[ECX] // Get `p_bar_mps' to EBX

	mov	ebx, DWORD PTR [ecx]

; 1356 :       XOR EAX,EBX

	xor	eax, ebx

; 1357 :       AND EAX,1 // Leaves EAX with the MPS sign value in its LSB.

	and	eax, 1

; 1358 :       BTR EBX,0 // Leaves `p_bar' in EBX

	btr	ebx, 0

; 1359 :       SUB EDX,EBX

	sub	edx, ebx

; 1360 :       JGE row3_broadcast

	jge	SHORT $row3_broadcast$54

; 1361 :       CALL mq_non_cdp

	call	$mq_non_cdp$19
$row3_broadcast$54:

; 1362 : row3_broadcast: // Process newly significant sample; sign is in LSB of EAX
; 1363 :       // Broadcast significance and sign to first row of next stripe
; 1364 :       MOV EBX,EDI

	mov	ebx, edi

; 1365 :       ADD EBX,context_row_gap

	add	ebx, DWORD PTR _context_row_gap$[ebp]

; 1366 :       MOV ECX,[EBX-4]

	mov	ecx, DWORD PTR [ebx-4]

; 1367 :       OR ECX,__SIGMA_TR_BIT

	or	ecx, 4

; 1368 :       MOV [EBX-4],ECX

	mov	DWORD PTR [ebx-4], ecx

; 1369 :       MOV ECX,EAX

	mov	ecx, eax

; 1370 :       SHL ECX,PREV_CHI_POS

	shl	ecx, 18					; 00000012H

; 1371 :       OR ECX,[EBX]

	or	ecx, DWORD PTR [ebx]

; 1372 :       OR ECX,__SIGMA_TC_BIT

	or	ecx, 2

; 1373 :       MOV [EBX],ECX

	mov	DWORD PTR [ebx], ecx

; 1374 :       MOV ECX,[EBX+4]

	mov	ecx, DWORD PTR [ebx+4]

; 1375 :       OR ECX,__SIGMA_TL_BIT

	or	ecx, 1

; 1376 :       MOV [EBX+4],ECX

	mov	DWORD PTR [ebx+4], ecx

; 1377 :       // Broadcast significance to left and right neighbours
; 1378 :       MOV ECX,[EDI-4]

	mov	ecx, DWORD PTR [edi-4]

; 1379 :       OR ECX,__SIGMA_CR_BIT*512

	or	ecx, 16384				; 00004000H

; 1380 :       MOV [EDI-4],ECX

	mov	DWORD PTR [edi-4], ecx

; 1381 :       MOV ECX,[EDI+4]

	mov	ecx, DWORD PTR [edi+4]

; 1382 :       OR ECX,__SIGMA_CL_BIT*512

	or	ecx, 4096				; 00001000H

; 1383 :       MOV [EDI+4],ECX

	mov	DWORD PTR [edi+4], ecx

; 1384 :       // Recover and update context word, using ECX register
; 1385 :       MOV ECX,EAX

	mov	ecx, eax

; 1386 :       SHL ECX,CHI_POS+9

	shl	ecx, 30					; 0000001eH

; 1387 :       OR ECX,[EDI]

	or	ecx, DWORD PTR [edi]

; 1388 :       OR ECX,__SIGMA_CC_BIT*512

	or	ecx, 8192				; 00002000H

; 1389 :       MOV [EDI],ECX

	mov	DWORD PTR [edi], ecx

; 1390 :       // Write new significant sample value
; 1391 :       SHL EAX,31 // Get sign bit of result into right position

	shl	eax, 31					; 0000001fH

; 1392 :       ADD EAX,one_point_five

	add	eax, DWORD PTR _one_point_five$[ebp]

; 1393 :       MOV EBX,cp_to_sp3

	mov	ebx, DWORD PTR _cp_to_sp3$[ebp]

; 1394 :       MOV [EDI+EBX],EAX

	mov	DWORD PTR [edi+ebx], eax
$advance_stripe_column$51:

; 1395 : advance_stripe_column:
; 1396 :     MOV EBX,ECX

	mov	ebx, ecx

; 1397 :     SHL EBX,MU_POS-SIGMA_CC_POS

	shl	ebx, 15					; 0000000fH

; 1398 :     AND EBX,__MU_BIT+__MU_BIT*8+__MU_BIT*64+__MU_BIT*512

	and	ebx, 306708480				; 12480000H

; 1399 :     OR ECX,EBX

	or	ecx, ebx

; 1400 :     AND ECX,0xFFFFFFFF-__PI_BIT-__PI_BIT*8-__PI_BIT*64-__PI_BIT*512

	and	ecx, -613416961				; db6fffffH

; 1401 :     MOV [EDI],ECX

	mov	DWORD PTR [edi], ecx

; 1402 :     ADD EDI,4

	add	edi, 4

; 1403 :     CMP EDI,stripe_end

	cmp	edi, DWORD PTR _stripe_end$[ebp]

; 1404 :     JNZ next_stripe_column

	jne	$next_stripe_column$12
$advance_stripe$17:

; 1405 : advance_stripe:
; 1406 :     ADD EDI,EXTRA_DECODE_CWORDS*4

	add	edi, 12					; 0000000cH

; 1407 :     MOV EAX,cp_to_sp_adjust

	mov	eax, DWORD PTR _cp_to_sp_adjust$[ebp]

; 1408 :     MOV EBX,cp_to_sp0

	mov	ebx, DWORD PTR _cp_to_sp0$[ebp]

; 1409 :     ADD EBX,EAX

	add	ebx, eax

; 1410 :     MOV cp_to_sp0,EBX

	mov	DWORD PTR _cp_to_sp0$[ebp], ebx

; 1411 :     MOV EBX,cp_to_sp1

	mov	ebx, DWORD PTR _cp_to_sp1$[ebp]

; 1412 :     ADD EBX,EAX

	add	ebx, eax

; 1413 :     MOV cp_to_sp1,EBX

	mov	DWORD PTR _cp_to_sp1$[ebp], ebx

; 1414 :     MOV EBX,cp_to_sp2

	mov	ebx, DWORD PTR _cp_to_sp2$[ebp]

; 1415 :     ADD EBX,EAX

	add	ebx, eax

; 1416 :     MOV cp_to_sp2,EBX

	mov	DWORD PTR _cp_to_sp2$[ebp], ebx

; 1417 :     MOV EBX,cp_to_sp3

	mov	ebx, DWORD PTR _cp_to_sp3$[ebp]

; 1418 :     ADD EBX,EAX

	add	ebx, eax

; 1419 :     MOV cp_to_sp3,EBX

	mov	DWORD PTR _cp_to_sp3$[ebp], ebx

; 1420 :     MOV EAX,num_stripes

	mov	eax, DWORD PTR _num_stripes$[ebp]

; 1421 :     SUB EAX,1

	sub	eax, 1

; 1422 :     MOV num_stripes,EAX

	mov	DWORD PTR _num_stripes$[ebp], eax

; 1423 :     JNZ next_stripe

	jne	$next_stripe$11

; 1424 :     JMP finished

	jmp	$finished$55
$mq_non_cdp$19:

; 1425 :     // We insert local fast function calls here
; 1426 : mq_non_cdp:
; 1427 :     ASM_MQ_NON_CDP_DECODE

	mov	ebx, DWORD PTR [ecx]
	add	esi, edx
	btr	ebx, 0
	add	edx, DWORD PTR _C_var$[ebp]
	jl	SHORT $non_cdp_Clt0$56
	cmp	esi, ebx
	jge	SHORT $non_cdp_Cge0_AgeP$57
	xor	eax, 1
	mov	ebx, DWORD PTR [ecx+4]
	movq	mm0, MMWORD PTR [ebx+8]
	movq	MMWORD PTR [ecx], mm0
	jmp	SHORT $non_cdp_renorm$58
$non_cdp_Cge0_AgeP$57:
	mov	ebx, DWORD PTR [ecx+4]
	movq	mm0, MMWORD PTR [ebx]
	movq	MMWORD PTR [ecx], mm0
	jmp	SHORT $non_cdp_renorm$58
$non_cdp_Clt0$56:
	add	edx, ebx
	cmp	esi, ebx
	mov	esi, ebx
	jge	SHORT $non_cdp_Clt0_AgeP$59
	mov	ebx, DWORD PTR [ecx+4]
	movq	mm0, MMWORD PTR [ebx]
	movq	MMWORD PTR [ecx], mm0
	jmp	SHORT $non_cdp_renorm$58
$non_cdp_Clt0_AgeP$59:
	xor	eax, 1
	mov	ebx, DWORD PTR [ecx+4]
	movq	mm0, MMWORD PTR [ebx+8]
	movq	MMWORD PTR [ecx], mm0
$non_cdp_renorm$58:
	mov	ebx, DWORD PTR _t_var$[ebp]
$non_cdp_renorm_once$60:
	test	ebx, ebx
	jne	SHORT $non_cdp_have_more_bits$61
	mov	ecx, DWORD PTR _temp_var$[ebp]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $non_cdp_no_ff$62
	mov	ebx, DWORD PTR _store_var$[ebp]
	movzx	ecx, BYTE PTR [ebx]
	cmp	ecx, 143				; 0000008fH
	jle	SHORT $non_cdp_temp_le8F$63
	mov	ecx, 255				; 000000ffH
	mov	ebx, DWORD PTR _S_var$[ebp]
	add	ebx, 1
	mov	DWORD PTR _S_var$[ebp], ebx
	mov	ebx, 8
	jmp	SHORT $non_cdp_complete_fill_lsbs$64
$non_cdp_temp_le8F$63:
	add	edx, ecx
	add	ebx, 1
	mov	DWORD PTR _store_var$[ebp], ebx
	mov	ebx, 7
	jmp	SHORT $non_cdp_complete_fill_lsbs$64
$non_cdp_no_ff$62:
	mov	ebx, DWORD PTR _store_var$[ebp]
	movzx	ecx, BYTE PTR [ebx]
	add	ebx, 1
	mov	DWORD PTR _store_var$[ebp], ebx
	mov	ebx, 8
$non_cdp_complete_fill_lsbs$64:
	add	edx, ecx
	mov	DWORD PTR _temp_var$[ebp], ecx
$non_cdp_have_more_bits$61:
	add	esi, esi
	add	edx, edx
	sub	ebx, 1
	test	esi, 8388608				; 00800000H
	je	SHORT $non_cdp_renorm_once$60
	mov	DWORD PTR _t_var$[ebp], ebx
	mov	ebx, esi
	sub	ebx, 8388608				; 00800000H
	cmp	edx, ebx
	cmovl	ebx, edx
	sub	esi, ebx
	sub	edx, ebx
	mov	DWORD PTR _C_var$[ebp], edx
	mov	edx, ebx

; 1428 :     ret // Return from fast function call

	ret	0
$finished$55:

; 1429 : finished:
; 1430 :     MOV D_var,EDX // Save the D register ready for `coder.check_in'

	mov	DWORD PTR _D_var$[ebp], edx

; 1431 :     MOV A_var,ESI // Save the A register ready for `coder.check_in'

	mov	DWORD PTR _A_var$[ebp], esi

; 1432 :     EMMS // Restore the FPU registers from any MMX calls which we have used

	emms

; 1433 :   }
; 1434 : 
; 1435 :   coder.check_in(A_var,C_var,D_var,t_var,temp_var,store_var,S_var);

	mov	ecx, DWORD PTR _S_var$[ebp]
	push	ecx
	mov	edx, DWORD PTR _store_var$[ebp]
	push	edx
	mov	eax, DWORD PTR _temp_var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t_var$[ebp]
	push	ecx
	mov	edx, DWORD PTR _D_var$[ebp]
	push	edx
	mov	eax, DWORD PTR _C_var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _A_var$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _coder$[ebp]
	call	?check_in@mq_decoder@@QAEXHHHHHPAEH@Z	; mq_decoder::check_in
$LN1@asm_decode:

; 1436 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?asm_decode_cleanup_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z ENDP ; asm_decode_cleanup_pass
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\msvc_block_decode_asm.h
;	COMDAT ?asm_decode_mag_ref_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NPAH3HHH@Z
_TEXT	SEGMENT
_cp_to_sp_adjust$ = -64					; size = 4
_stripe_end$ = -60					; size = 4
_A_var$ = -56						; size = 4
_C_var$ = -52						; size = 4
_D_var$ = -48						; size = 4
_t_var$ = -44						; size = 4
_temp_var$ = -40					; size = 4
_S_var$ = -36						; size = 4
_cp_to_sp3$ = -32					; size = 4
_half_lsb$ = -28					; size = 4
_states_2$ = -24					; size = 4
_store_var$ = -20					; size = 4
_cp_to_sp2$ = -16					; size = 4
_cp_to_sp1$ = -12					; size = 4
_cp_to_sp0$ = -8					; size = 4
_mag_mask$ = -4						; size = 4
_coder$ = 8						; size = 4
_states$ = 12						; size = 4
_p$ = 16						; size = 4
_causal$ = 20						; size = 1
_samples$ = 24						; size = 4
_contexts$ = 28						; size = 4
_width$ = 32						; size = 4
_num_stripes$ = 36					; size = 4
_context_row_gap$ = 40					; size = 4
?asm_decode_mag_ref_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NPAH3HHH@Z PROC ; asm_decode_mag_ref_pass, COMDAT

; 783  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 784  :   if ((num_stripes <= 0) || (width <= 0))

	cmp	DWORD PTR _num_stripes$[ebp], 0
	jle	SHORT $LN3@asm_decode
	cmp	DWORD PTR _width$[ebp], 0
	jg	SHORT $LN2@asm_decode
$LN3@asm_decode:

; 785  :     return;

	jmp	$LN1@asm_decode
$LN2@asm_decode:

; 786  :   kdu_int32 A_var, C_var, D_var, t_var, temp_var;
; 787  :   kdu_byte *store_var;
; 788  :   int S_var;
; 789  :   coder.check_out(A_var,C_var,D_var,t_var,temp_var,store_var,S_var);

	lea	eax, DWORD PTR _S_var$[ebp]
	push	eax
	lea	ecx, DWORD PTR _store_var$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp_var$[ebp]
	push	edx
	lea	eax, DWORD PTR _t_var$[ebp]
	push	eax
	lea	ecx, DWORD PTR _D_var$[ebp]
	push	ecx
	lea	edx, DWORD PTR _C_var$[ebp]
	push	edx
	lea	eax, DWORD PTR _A_var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _coder$[ebp]
	call	?check_out@mq_decoder@@QAEXAAH0000AAPAE0@Z ; mq_decoder::check_out

; 790  :   kdu_int32 half_lsb = (1<<p)>>1;

	mov	edx, 1
	mov	ecx, DWORD PTR _p$[ebp]
	shl	edx, cl
	sar	edx, 1
	mov	DWORD PTR _half_lsb$[ebp], edx

; 791  :   context_row_gap <<= 2; // Convert to number of bytes

	mov	eax, DWORD PTR _context_row_gap$[ebp]
	shl	eax, 2
	mov	DWORD PTR _context_row_gap$[ebp], eax

; 792  :   width <<= 2; // Convert to number of bytes

	mov	ecx, DWORD PTR _width$[ebp]
	shl	ecx, 2
	mov	DWORD PTR _width$[ebp], ecx

; 793  :     /* The following offsets are used to convert a context word pointer
; 794  :        to a sample pointer.  The offsets are correct for the first
; 795  :        stripe and must be adjusted from stripe to stripe by the addition
; 796  :        of 3*width-EXTRA_DECODE_CWORDS. */
; 797  :   int cp_to_sp0 = (int)((samples-contexts)<<2); // Offset for row 0

	mov	edx, DWORD PTR _samples$[ebp]
	sub	edx, DWORD PTR _contexts$[ebp]
	sar	edx, 2
	shl	edx, 2
	mov	DWORD PTR _cp_to_sp0$[ebp], edx

; 798  :   int cp_to_sp1 = cp_to_sp0+width; // Offset for row 1

	mov	eax, DWORD PTR _cp_to_sp0$[ebp]
	add	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _cp_to_sp1$[ebp], eax

; 799  :   int cp_to_sp2 = cp_to_sp1+width; // Offset for row 2

	mov	ecx, DWORD PTR _cp_to_sp1$[ebp]
	add	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _cp_to_sp2$[ebp], ecx

; 800  :   int cp_to_sp3 = cp_to_sp2+width; // Offset for row 3

	mov	edx, DWORD PTR _cp_to_sp2$[ebp]
	add	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _cp_to_sp3$[ebp], edx

; 801  :   int cp_to_sp_adjust = 3*width-4*EXTRA_DECODE_CWORDS;

	imul	eax, DWORD PTR _width$[ebp], 3
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR _cp_to_sp_adjust$[ebp], eax

; 802  :   kdu_int32 *stripe_end; // Points to context word beyond end of current stripe
; 803  :   kdu_int32 mag_mask = -1; mag_mask <<= (p+2); mag_mask &= KDU_INT32_MAX;

	mov	DWORD PTR _mag_mask$[ebp], -1
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 2
	mov	edx, DWORD PTR _mag_mask$[ebp]
	shl	edx, cl
	mov	DWORD PTR _mag_mask$[ebp], edx
	mov	eax, DWORD PTR _mag_mask$[ebp]
	and	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _mag_mask$[ebp], eax

; 804  :   states += KAPPA_MAG_BASE;

	mov	ecx, DWORD PTR _states$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR _states$[ebp], ecx

; 805  :   mqd_state *states_2 = states+2;

	mov	edx, DWORD PTR _states$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _states_2$[ebp], edx

; 806  : 
; 807  :   __asm {
; 808  :     MOV EDI,contexts // Set EDI aside to hold the context word pointer

	mov	edi, DWORD PTR _contexts$[ebp]

; 809  :     MOV EDX,D_var // Set EDX aside to hold the critical MQ variable, D

	mov	edx, DWORD PTR _D_var$[ebp]

; 810  :     MOV ESI,A_var // Set ESI aside to hold the MQ coder's A register

	mov	esi, DWORD PTR _A_var$[ebp]
$next_stripe$11:

; 811  : next_stripe:
; 812  :     MOV EAX,width

	mov	eax, DWORD PTR _width$[ebp]

; 813  :     ADD EAX,EDI

	add	eax, edi

; 814  :     MOV stripe_end,EAX // Set end pointer for this stripe

	mov	DWORD PTR _stripe_end$[ebp], eax
$next_stripe_column$12:

; 815  : next_stripe_column:
; 816  :     MOV ECX,[EDI]

	mov	ecx, DWORD PTR [edi]

; 817  :     TEST ECX,__MU_BIT+__MU_BIT*8+__MU_BIT*64+__MU_BIT*512

	test	ecx, 306708480				; 12480000H

; 818  :     JNZ row0

	jne	SHORT $row0$13
$speedup_loop$14:

; 819  : speedup_loop:
; 820  :     // Invoke speedup trick to skip over runs of all-zero neighbourhoods
; 821  :     MOV ECX,[EDI+8]

	mov	ecx, DWORD PTR [edi+8]

; 822  :     ADD EDI,8

	add	edi, 8

; 823  :     TEST ECX,ECX

	test	ecx, ecx

; 824  :     JZ speedup_loop

	je	SHORT $speedup_loop$14

; 825  :     SUB EDI,4

	sub	edi, 4

; 826  :     CMP EDI,stripe_end

	cmp	edi, DWORD PTR _stripe_end$[ebp]

; 827  :     JNZ next_stripe_column

	jne	SHORT $next_stripe_column$12

; 828  :     JMP advance_stripe

	jmp	$advance_stripe$15
$row0$13:

; 829  : row0:
; 830  :       // Test for coding pass membership
; 831  :       TEST ECX,__MU_BIT*1

	test	ecx, 524288				; 00080000H

; 832  :       JZ row1

	je	SHORT $row1$16

; 833  :       // Find pointer to the relevant context state record
; 834  :       MOV EBX,cp_to_sp0

	mov	ebx, DWORD PTR _cp_to_sp0$[ebp]

; 835  :       MOV EAX,[EDI+EBX]

	mov	eax, DWORD PTR [edi+ebx]

; 836  :       TEST EAX,mag_mask

	test	eax, DWORD PTR _mag_mask$[ebp]

; 837  :       JZ row0_first_mag_ref

	je	SHORT $row0_first_mag_ref$17

; 838  :       MOV ECX,states_2

	mov	ecx, DWORD PTR _states_2$[ebp]

; 839  :       JMP row0_decoding

	jmp	SHORT $row0_decoding$18
$row0_first_mag_ref$17:

; 840  : row0_first_mag_ref:
; 841  :       TEST ECX,__NBRHD_MASK*1

	test	ecx, 495				; 000001efH

; 842  :       MOV ECX,states

	mov	ecx, DWORD PTR _states$[ebp]

; 843  :       JZ row0_decoding

	je	SHORT $row0_decoding$18

; 844  :       ADD ECX,8

	add	ecx, 8
$row0_decoding$18:

; 845  : row0_decoding: // Now we are ready to decode the symbol; ECX points to context
; 846  :       MOV EAX,[ECX] // Get `p_bar_mps' to EAX

	mov	eax, DWORD PTR [ecx]

; 847  :       SUB EDX,EAX

	sub	edx, eax

; 848  :       AND EAX,1 // Get MPS identity in LSB of EAX

	and	eax, 1

; 849  :       ADD EDX,EAX // Correct for the effect of the MPS

	add	edx, eax

; 850  :       JGE row0_decoded

	jge	SHORT $row0_decoded$19

; 851  :       CALL mq_non_cdp

	call	$mq_non_cdp$20

; 852  :       MOV EBX,cp_to_sp0 // Reload the sample offset

	mov	ebx, DWORD PTR _cp_to_sp0$[ebp]
$row0_decoded$19:

; 853  : row0_decoded: // Ready to update sample; EBX holds address offset from EDI
; 854  :       MOV CL,byte ptr [p]

	mov	cl, BYTE PTR _p$[ebp]

; 855  :       XOR EAX,1

	xor	eax, 1

; 856  :       SHL EAX,CL

	shl	eax, cl

; 857  :       XOR EAX,[EDI+EBX]

	xor	eax, DWORD PTR [edi+ebx]

; 858  :       OR EAX,half_lsb

	or	eax, DWORD PTR _half_lsb$[ebp]

; 859  :       MOV [EDI+EBX],EAX

	mov	DWORD PTR [edi+ebx], eax

; 860  :       MOV ECX,[EDI]

	mov	ecx, DWORD PTR [edi]
$row1$16:

; 861  : row1:
; 862  :       // Test for coding pass membership
; 863  :       TEST ECX,__MU_BIT*8

	test	ecx, 4194304				; 00400000H

; 864  :       JZ row2

	je	SHORT $row2$21

; 865  :       // Find pointer to the relevant context state record
; 866  :       MOV EBX,cp_to_sp1

	mov	ebx, DWORD PTR _cp_to_sp1$[ebp]

; 867  :       MOV EAX,[EDI+EBX]

	mov	eax, DWORD PTR [edi+ebx]

; 868  :       TEST EAX,mag_mask

	test	eax, DWORD PTR _mag_mask$[ebp]

; 869  :       JZ row1_first_mag_ref

	je	SHORT $row1_first_mag_ref$22

; 870  :       MOV ECX,states_2

	mov	ecx, DWORD PTR _states_2$[ebp]

; 871  :       JMP row1_decoding

	jmp	SHORT $row1_decoding$23
$row1_first_mag_ref$22:

; 872  : row1_first_mag_ref:
; 873  :       TEST ECX,__NBRHD_MASK*8

	test	ecx, 3960				; 00000f78H

; 874  :       MOV ECX,states

	mov	ecx, DWORD PTR _states$[ebp]

; 875  :       JZ row1_decoding

	je	SHORT $row1_decoding$23

; 876  :       ADD ECX,8

	add	ecx, 8
$row1_decoding$23:

; 877  : row1_decoding: // Now we are ready to decode the symbol; ECX points to context
; 878  :       MOV EAX,[ECX] // Get `p_bar_mps' to EAX

	mov	eax, DWORD PTR [ecx]

; 879  :       SUB EDX,EAX

	sub	edx, eax

; 880  :       AND EAX,1 // Get MPS identity in LSB of EAX

	and	eax, 1

; 881  :       ADD EDX,EAX // Correct for the effect of the MPS

	add	edx, eax

; 882  :       JGE row1_decoded

	jge	SHORT $row1_decoded$24

; 883  :       CALL mq_non_cdp

	call	$mq_non_cdp$20

; 884  :       MOV EBX,cp_to_sp1 // Reload the sample offset

	mov	ebx, DWORD PTR _cp_to_sp1$[ebp]
$row1_decoded$24:

; 885  : row1_decoded: // Ready to update sample; EBX holds address offset from EDI
; 886  :       MOV CL,byte ptr [p]

	mov	cl, BYTE PTR _p$[ebp]

; 887  :       XOR EAX,1

	xor	eax, 1

; 888  :       SHL EAX,CL

	shl	eax, cl

; 889  :       XOR EAX,[EDI+EBX]

	xor	eax, DWORD PTR [edi+ebx]

; 890  :       OR EAX,half_lsb

	or	eax, DWORD PTR _half_lsb$[ebp]

; 891  :       MOV [EDI+EBX],EAX

	mov	DWORD PTR [edi+ebx], eax

; 892  :       MOV ECX,[EDI]

	mov	ecx, DWORD PTR [edi]
$row2$21:

; 893  : row2:
; 894  :       // Test for coding pass membership
; 895  :       TEST ECX,__MU_BIT*64

	test	ecx, 33554432				; 02000000H

; 896  :       JZ row3

	je	SHORT $row3$25

; 897  :       // Find pointer to the relevant context state record
; 898  :       MOV EBX,cp_to_sp2

	mov	ebx, DWORD PTR _cp_to_sp2$[ebp]

; 899  :       MOV EAX,[EDI+EBX]

	mov	eax, DWORD PTR [edi+ebx]

; 900  :       TEST EAX,mag_mask

	test	eax, DWORD PTR _mag_mask$[ebp]

; 901  :       JZ row2_first_mag_ref

	je	SHORT $row2_first_mag_ref$26

; 902  :       MOV ECX,states_2

	mov	ecx, DWORD PTR _states_2$[ebp]

; 903  :       JMP row2_decoding

	jmp	SHORT $row2_decoding$27
$row2_first_mag_ref$26:

; 904  : row2_first_mag_ref:
; 905  :       TEST ECX,__NBRHD_MASK*64

	test	ecx, 31680				; 00007bc0H

; 906  :       MOV ECX,states

	mov	ecx, DWORD PTR _states$[ebp]

; 907  :       JZ row2_decoding

	je	SHORT $row2_decoding$27

; 908  :       ADD ECX,8

	add	ecx, 8
$row2_decoding$27:

; 909  : row2_decoding: // Now we are ready to decode the symbol; ECX points to context
; 910  :       MOV EAX,[ECX] // Get `p_bar_mps' to EAX

	mov	eax, DWORD PTR [ecx]

; 911  :       SUB EDX,EAX

	sub	edx, eax

; 912  :       AND EAX,1 // Get MPS identity in LSB of EAX

	and	eax, 1

; 913  :       ADD EDX,EAX // Correct for the effect of the MPS

	add	edx, eax

; 914  :       JGE row2_decoded

	jge	SHORT $row2_decoded$28

; 915  :       CALL mq_non_cdp

	call	$mq_non_cdp$20

; 916  :       MOV EBX,cp_to_sp2 // Reload the sample offset

	mov	ebx, DWORD PTR _cp_to_sp2$[ebp]
$row2_decoded$28:

; 917  : row2_decoded: // Ready to update sample; EBX holds address offset from EDI
; 918  :       MOV CL,byte ptr [p]

	mov	cl, BYTE PTR _p$[ebp]

; 919  :       XOR EAX,1

	xor	eax, 1

; 920  :       SHL EAX,CL

	shl	eax, cl

; 921  :       XOR EAX,[EDI+EBX]

	xor	eax, DWORD PTR [edi+ebx]

; 922  :       OR EAX,half_lsb

	or	eax, DWORD PTR _half_lsb$[ebp]

; 923  :       MOV [EDI+EBX],EAX

	mov	DWORD PTR [edi+ebx], eax

; 924  :       MOV ECX,[EDI]

	mov	ecx, DWORD PTR [edi]
$row3$25:

; 925  : row3:
; 926  :       // Test for coding pass membership
; 927  :       TEST ECX,__MU_BIT*512

	test	ecx, 268435456				; 10000000H

; 928  :       JZ advance_stripe_column

	je	SHORT $advance_stripe_column$29

; 929  :       // Find pointer to the relevant context state record
; 930  :       MOV EBX,cp_to_sp3

	mov	ebx, DWORD PTR _cp_to_sp3$[ebp]

; 931  :       MOV EAX,[EDI+EBX]

	mov	eax, DWORD PTR [edi+ebx]

; 932  :       TEST EAX,mag_mask

	test	eax, DWORD PTR _mag_mask$[ebp]

; 933  :       JZ row3_first_mag_ref

	je	SHORT $row3_first_mag_ref$30

; 934  :       MOV ECX,states_2

	mov	ecx, DWORD PTR _states_2$[ebp]

; 935  :       JMP row3_decoding

	jmp	SHORT $row3_decoding$31
$row3_first_mag_ref$30:

; 936  : row3_first_mag_ref:
; 937  :       TEST ECX,__NBRHD_MASK*512

	test	ecx, 253440				; 0003de00H

; 938  :       MOV ECX,states

	mov	ecx, DWORD PTR _states$[ebp]

; 939  :       JZ row3_decoding

	je	SHORT $row3_decoding$31

; 940  :       ADD ECX,8

	add	ecx, 8
$row3_decoding$31:

; 941  : row3_decoding: // Now we are ready to decode the symbol; ECX points to context
; 942  :       MOV EAX,[ECX] // Get `p_bar_mps' to EAX

	mov	eax, DWORD PTR [ecx]

; 943  :       SUB EDX,EAX

	sub	edx, eax

; 944  :       AND EAX,1 // Get MPS identity in LSB of EAX

	and	eax, 1

; 945  :       ADD EDX,EAX // Correct for the effect of the MPS

	add	edx, eax

; 946  :       JGE row3_decoded

	jge	SHORT $row3_decoded$32

; 947  :       CALL mq_non_cdp

	call	$mq_non_cdp$20

; 948  :       MOV EBX,cp_to_sp3 // Reload the sample offset

	mov	ebx, DWORD PTR _cp_to_sp3$[ebp]
$row3_decoded$32:

; 949  : row3_decoded: // Ready to update sample; EBX holds address offset from EDI
; 950  :       MOV CL,byte ptr [p]

	mov	cl, BYTE PTR _p$[ebp]

; 951  :       XOR EAX,1

	xor	eax, 1

; 952  :       SHL EAX,CL

	shl	eax, cl

; 953  :       XOR EAX,[EDI+EBX]

	xor	eax, DWORD PTR [edi+ebx]

; 954  :       OR EAX,half_lsb

	or	eax, DWORD PTR _half_lsb$[ebp]

; 955  :       MOV [EDI+EBX],EAX

	mov	DWORD PTR [edi+ebx], eax
$advance_stripe_column$29:

; 956  : advance_stripe_column:
; 957  :     ADD EDI,4

	add	edi, 4

; 958  :     CMP EDI,stripe_end

	cmp	edi, DWORD PTR _stripe_end$[ebp]

; 959  :     JNZ next_stripe_column

	jne	$next_stripe_column$12
$advance_stripe$15:

; 960  : advance_stripe:
; 961  :     ADD EDI,EXTRA_DECODE_CWORDS*4

	add	edi, 12					; 0000000cH

; 962  :     MOV EAX,cp_to_sp_adjust

	mov	eax, DWORD PTR _cp_to_sp_adjust$[ebp]

; 963  :     MOV EBX,cp_to_sp0

	mov	ebx, DWORD PTR _cp_to_sp0$[ebp]

; 964  :     ADD EBX,EAX

	add	ebx, eax

; 965  :     MOV cp_to_sp0,EBX

	mov	DWORD PTR _cp_to_sp0$[ebp], ebx

; 966  :     MOV EBX,cp_to_sp1

	mov	ebx, DWORD PTR _cp_to_sp1$[ebp]

; 967  :     ADD EBX,EAX

	add	ebx, eax

; 968  :     MOV cp_to_sp1,EBX

	mov	DWORD PTR _cp_to_sp1$[ebp], ebx

; 969  :     MOV EBX,cp_to_sp2

	mov	ebx, DWORD PTR _cp_to_sp2$[ebp]

; 970  :     ADD EBX,EAX

	add	ebx, eax

; 971  :     MOV cp_to_sp2,EBX

	mov	DWORD PTR _cp_to_sp2$[ebp], ebx

; 972  :     MOV EBX,cp_to_sp3

	mov	ebx, DWORD PTR _cp_to_sp3$[ebp]

; 973  :     ADD EBX,EAX

	add	ebx, eax

; 974  :     MOV cp_to_sp3,EBX

	mov	DWORD PTR _cp_to_sp3$[ebp], ebx

; 975  :     MOV EAX,num_stripes

	mov	eax, DWORD PTR _num_stripes$[ebp]

; 976  :     SUB EAX,1

	sub	eax, 1

; 977  :     MOV num_stripes,EAX

	mov	DWORD PTR _num_stripes$[ebp], eax

; 978  :     JNZ next_stripe

	jne	$next_stripe$11

; 979  :     JMP finished

	jmp	$finished$33
$mq_non_cdp$20:

; 980  :     // We insert local fast function calls here
; 981  : mq_non_cdp:
; 982  :     ASM_MQ_NON_CDP_DECODE

	mov	ebx, DWORD PTR [ecx]
	add	esi, edx
	btr	ebx, 0
	add	edx, DWORD PTR _C_var$[ebp]
	jl	SHORT $non_cdp_Clt0$34
	cmp	esi, ebx
	jge	SHORT $non_cdp_Cge0_AgeP$35
	xor	eax, 1
	mov	ebx, DWORD PTR [ecx+4]
	movq	mm0, MMWORD PTR [ebx+8]
	movq	MMWORD PTR [ecx], mm0
	jmp	SHORT $non_cdp_renorm$36
$non_cdp_Cge0_AgeP$35:
	mov	ebx, DWORD PTR [ecx+4]
	movq	mm0, MMWORD PTR [ebx]
	movq	MMWORD PTR [ecx], mm0
	jmp	SHORT $non_cdp_renorm$36
$non_cdp_Clt0$34:
	add	edx, ebx
	cmp	esi, ebx
	mov	esi, ebx
	jge	SHORT $non_cdp_Clt0_AgeP$37
	mov	ebx, DWORD PTR [ecx+4]
	movq	mm0, MMWORD PTR [ebx]
	movq	MMWORD PTR [ecx], mm0
	jmp	SHORT $non_cdp_renorm$36
$non_cdp_Clt0_AgeP$37:
	xor	eax, 1
	mov	ebx, DWORD PTR [ecx+4]
	movq	mm0, MMWORD PTR [ebx+8]
	movq	MMWORD PTR [ecx], mm0
$non_cdp_renorm$36:
	mov	ebx, DWORD PTR _t_var$[ebp]
$non_cdp_renorm_once$38:
	test	ebx, ebx
	jne	SHORT $non_cdp_have_more_bits$39
	mov	ecx, DWORD PTR _temp_var$[ebp]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $non_cdp_no_ff$40
	mov	ebx, DWORD PTR _store_var$[ebp]
	movzx	ecx, BYTE PTR [ebx]
	cmp	ecx, 143				; 0000008fH
	jle	SHORT $non_cdp_temp_le8F$41
	mov	ecx, 255				; 000000ffH
	mov	ebx, DWORD PTR _S_var$[ebp]
	add	ebx, 1
	mov	DWORD PTR _S_var$[ebp], ebx
	mov	ebx, 8
	jmp	SHORT $non_cdp_complete_fill_lsbs$42
$non_cdp_temp_le8F$41:
	add	edx, ecx
	add	ebx, 1
	mov	DWORD PTR _store_var$[ebp], ebx
	mov	ebx, 7
	jmp	SHORT $non_cdp_complete_fill_lsbs$42
$non_cdp_no_ff$40:
	mov	ebx, DWORD PTR _store_var$[ebp]
	movzx	ecx, BYTE PTR [ebx]
	add	ebx, 1
	mov	DWORD PTR _store_var$[ebp], ebx
	mov	ebx, 8
$non_cdp_complete_fill_lsbs$42:
	add	edx, ecx
	mov	DWORD PTR _temp_var$[ebp], ecx
$non_cdp_have_more_bits$39:
	add	esi, esi
	add	edx, edx
	sub	ebx, 1
	test	esi, 8388608				; 00800000H
	je	SHORT $non_cdp_renorm_once$38
	mov	DWORD PTR _t_var$[ebp], ebx
	mov	ebx, esi
	sub	ebx, 8388608				; 00800000H
	cmp	edx, ebx
	cmovl	ebx, edx
	sub	esi, ebx
	sub	edx, ebx
	mov	DWORD PTR _C_var$[ebp], edx
	mov	edx, ebx

; 983  :     ret // Return from fast function call

	ret	0
$finished$33:

; 984  : finished:
; 985  :     MOV D_var,EDX // Save the D register ready for `coder.check_in'

	mov	DWORD PTR _D_var$[ebp], edx

; 986  :     MOV A_var,ESI // Save the A register ready for `coder.check_in'

	mov	DWORD PTR _A_var$[ebp], esi

; 987  :     EMMS // Restore the FPU registers from any MMX calls which we may have used

	emms

; 988  :   }
; 989  : 
; 990  :   coder.check_in(A_var,C_var,D_var,t_var,temp_var,store_var,S_var);

	mov	eax, DWORD PTR _S_var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _store_var$[ebp]
	push	ecx
	mov	edx, DWORD PTR _temp_var$[ebp]
	push	edx
	mov	eax, DWORD PTR _t_var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _D_var$[ebp]
	push	ecx
	mov	edx, DWORD PTR _C_var$[ebp]
	push	edx
	mov	eax, DWORD PTR _A_var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _coder$[ebp]
	call	?check_in@mq_decoder@@QAEXHHHHHPAEH@Z	; mq_decoder::check_in
$LN1@asm_decode:

; 991  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?asm_decode_mag_ref_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NPAH3HHH@Z ENDP ; asm_decode_mag_ref_pass
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\msvc_block_decode_asm.h
;	COMDAT ?asm_decode_sig_prop_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z
_TEXT	SEGMENT
_cp_to_sp_adjust$ = -64					; size = 4
_is_causal$ = -60					; size = 4
_stripe_end$ = -56					; size = 4
_A_var$ = -52						; size = 4
_C_var$ = -48						; size = 4
_D_var$ = -44						; size = 4
_t_var$ = -40						; size = 4
_temp_var$ = -36					; size = 4
_S_var$ = -32						; size = 4
_cp_to_sp3$ = -28					; size = 4
_cp_to_sp2$ = -24					; size = 4
_cp_to_sp1$ = -20					; size = 4
_cp_to_sp0$ = -16					; size = 4
_sig_lut$ = -12						; size = 4
_store_var$ = -8					; size = 4
_one_point_five$ = -4					; size = 4
_coder$ = 8						; size = 4
_states$ = 12						; size = 4
_p$ = 16						; size = 4
_causal$ = 20						; size = 1
_orientation$ = 24					; size = 4
_samples$ = 28						; size = 4
_contexts$ = 32						; size = 4
_width$ = 36						; size = 4
_num_stripes$ = 40					; size = 4
_context_row_gap$ = 44					; size = 4
?asm_decode_sig_prop_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z PROC ; asm_decode_sig_prop_pass, COMDAT

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 366  :   if ((num_stripes <= 0) || (width <= 0))

	cmp	DWORD PTR _num_stripes$[ebp], 0
	jle	SHORT $LN3@asm_decode
	cmp	DWORD PTR _width$[ebp], 0
	jg	SHORT $LN2@asm_decode
$LN3@asm_decode:

; 367  :     return;

	jmp	$LN1@asm_decode
$LN2@asm_decode:

; 368  :   kdu_int32 A_var, C_var, D_var, t_var, temp_var;
; 369  :   kdu_byte *store_var;
; 370  :   int S_var;
; 371  :   coder.check_out(A_var,C_var,D_var,t_var,temp_var,store_var,S_var);

	lea	eax, DWORD PTR _S_var$[ebp]
	push	eax
	lea	ecx, DWORD PTR _store_var$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp_var$[ebp]
	push	edx
	lea	eax, DWORD PTR _t_var$[ebp]
	push	eax
	lea	ecx, DWORD PTR _D_var$[ebp]
	push	ecx
	lea	edx, DWORD PTR _C_var$[ebp]
	push	edx
	lea	eax, DWORD PTR _A_var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _coder$[ebp]
	call	?check_out@mq_decoder@@QAEXAAH0000AAPAE0@Z ; mq_decoder::check_out

; 372  :   kdu_byte *sig_lut = significance_luts[orientation];

	mov	ecx, DWORD PTR _orientation$[ebp]
	mov	edx, DWORD PTR ?significance_luts@@3PAPAEA[ecx*4]
	mov	DWORD PTR _sig_lut$[ebp], edx

; 373  :   kdu_int32 one_point_five = 1<<p; one_point_five += (one_point_five>>1);

	mov	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	shl	eax, cl
	mov	DWORD PTR _one_point_five$[ebp], eax
	mov	ecx, DWORD PTR _one_point_five$[ebp]
	sar	ecx, 1
	add	ecx, DWORD PTR _one_point_five$[ebp]
	mov	DWORD PTR _one_point_five$[ebp], ecx

; 374  :   int is_causal = (causal)?1:0;

	movzx	edx, BYTE PTR _causal$[ebp]
	neg	edx
	sbb	edx, edx
	neg	edx
	mov	DWORD PTR _is_causal$[ebp], edx

; 375  :   context_row_gap <<= 2; // Convert to number of bytes

	mov	eax, DWORD PTR _context_row_gap$[ebp]
	shl	eax, 2
	mov	DWORD PTR _context_row_gap$[ebp], eax

; 376  :   width <<= 2; // Convert to number of bytes

	mov	ecx, DWORD PTR _width$[ebp]
	shl	ecx, 2
	mov	DWORD PTR _width$[ebp], ecx

; 377  :     /* The following offsets are used to convert a context word pointer
; 378  :        to a sample pointer.  The offsets are correct for the first
; 379  :        stripe and must be adjusted from stripe to stripe by the addition
; 380  :        of 3*width-EXTRA_DECODE_CWORDS. */
; 381  :   int cp_to_sp0 = (int)((samples-contexts)<<2); // Offset for row 0

	mov	edx, DWORD PTR _samples$[ebp]
	sub	edx, DWORD PTR _contexts$[ebp]
	sar	edx, 2
	shl	edx, 2
	mov	DWORD PTR _cp_to_sp0$[ebp], edx

; 382  :   int cp_to_sp1 = cp_to_sp0+width; // Offset for row 1

	mov	eax, DWORD PTR _cp_to_sp0$[ebp]
	add	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _cp_to_sp1$[ebp], eax

; 383  :   int cp_to_sp2 = cp_to_sp1+width; // Offset for row 2

	mov	ecx, DWORD PTR _cp_to_sp1$[ebp]
	add	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _cp_to_sp2$[ebp], ecx

; 384  :   int cp_to_sp3 = cp_to_sp2+width; // Offset for row 3

	mov	edx, DWORD PTR _cp_to_sp2$[ebp]
	add	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _cp_to_sp3$[ebp], edx

; 385  :   int cp_to_sp_adjust = 3*width-4*EXTRA_DECODE_CWORDS;

	imul	eax, DWORD PTR _width$[ebp], 3
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR _cp_to_sp_adjust$[ebp], eax

; 386  :   kdu_int32 *stripe_end; // Points to context word beyond end of current stripe
; 387  : 
; 388  :   __asm {
; 389  :     MOV EDI,contexts // Set EDI aside to hold the context word pointer

	mov	edi, DWORD PTR _contexts$[ebp]

; 390  :     MOV EDX,D_var // Set EDX aside to hold the critical MQ variable, D

	mov	edx, DWORD PTR _D_var$[ebp]

; 391  :     MOV ESI,A_var // Set ESI aside to hold the MQ coder's A register

	mov	esi, DWORD PTR _A_var$[ebp]
$next_stripe$11:

; 392  : next_stripe:
; 393  :     MOV EAX,width

	mov	eax, DWORD PTR _width$[ebp]

; 394  :     ADD EAX,EDI

	add	eax, edi

; 395  :     MOV stripe_end,EAX // Set end pointer for this stripe

	mov	DWORD PTR _stripe_end$[ebp], eax
$next_stripe_column$12:

; 396  : next_stripe_column:
; 397  :     MOV ECX,[EDI]

	mov	ecx, DWORD PTR [edi]

; 398  :     TEST ECX,ECX

	test	ecx, ecx

; 399  :     JNZ row0

	jne	SHORT $row0$13
$speedup_loop$14:

; 400  : speedup_loop:
; 401  :     // Invoke speedup trick to skip over runs of all-zero neighbourhoods
; 402  :     MOV ECX,[EDI+12]

	mov	ecx, DWORD PTR [edi+12]

; 403  :     ADD EDI,12

	add	edi, 12					; 0000000cH

; 404  :     TEST ECX,ECX

	test	ecx, ecx

; 405  :     JZ speedup_loop

	je	SHORT $speedup_loop$14

; 406  :     SUB EDI,8

	sub	edi, 8

; 407  :     CMP EDI,stripe_end

	cmp	edi, DWORD PTR _stripe_end$[ebp]

; 408  :     JNZ next_stripe_column

	jne	SHORT $next_stripe_column$12

; 409  :     JMP advance_stripe

	jmp	$advance_stripe$15
$row0$13:

; 410  : row0:
; 411  :       // Test for coding pass membership
; 412  :       MOV EBX,ECX

	mov	ebx, ecx

; 413  :       AND EBX,__NBRHD_MASK*1

	and	ebx, 495				; 000001efH

; 414  :       JZ row1

	je	$row1$16

; 415  :       TEST ECX,__SIG_PROP_MEMBER_MASK*1

	test	ecx, 2097168				; 00200010H

; 416  :       JNZ row1

	jne	$row1$16

; 417  :       OR ECX,__PI_BIT*1

	or	ecx, 1048576				; 00100000H

; 418  :       MOV [EDI],ECX // Save context word indicating that sample belongs to pass

	mov	DWORD PTR [edi], ecx

; 419  :       // Find pointer to the relevant context state record
; 420  :       AND ECX,__NBRHD_MASK

	and	ecx, 495				; 000001efH

; 421  :       ADD ECX,sig_lut

	add	ecx, DWORD PTR _sig_lut$[ebp]

; 422  :       MOVZX ECX,byte ptr [ECX]

	movzx	ecx, BYTE PTR [ecx]

; 423  :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 424  :       LEA ECX,[EBX+8*ECX]

	lea	ecx, DWORD PTR [ebx+ecx*8]

; 425  :       // decode symbol
; 426  :       MOV EAX,[ECX] // Get `p_bar_mps' to EAX

	mov	eax, DWORD PTR [ecx]

; 427  :       SUB EDX,EAX

	sub	edx, eax

; 428  :       AND EAX,1 // Get MPS identity in LSB of EAX

	and	eax, 1

; 429  :       ADD EDX,EAX // Correct for the effect of the MPS

	add	edx, eax

; 430  :       JGE significance_test0

	jge	SHORT $significance_test0$17

; 431  :       CALL mq_non_cdp

	call	$mq_non_cdp$18
$significance_test0$17:

; 432  : significance_test0:
; 433  :       MOV ECX,[EDI] // Get context word back again

	mov	ecx, DWORD PTR [edi]

; 434  :       TEST EAX,EAX // If symbol != 0

	test	eax, eax

; 435  :       JZ row1

	je	$row1$16

; 436  :       // If we get here, we know that stripe row 0 is newly significant
; 437  :       AND ECX,__CHI_BIT/8+__SIGMA_CC_BIT/8+__CHI_BIT*8+__SIGMA_CC_BIT*8

	and	ecx, 17039490				; 01040082H

; 438  :       SHR ECX,1

	shr	ecx, 1

; 439  :       MOV EAX,[EDI-4] // Get context word on left

	mov	eax, DWORD PTR [edi-4]

; 440  :       AND EAX,__CHI_BIT+__SIGMA_CC_BIT

	and	eax, 2097168				; 00200010H

; 441  :       SHR EAX,2

	shr	eax, 2

; 442  :       ADD ECX,EAX

	add	ecx, eax

; 443  :       MOV EAX,[EDI+4] // Get context word on right

	mov	eax, DWORD PTR [edi+4]

; 444  :       AND EAX,__CHI_BIT+__SIGMA_CC_BIT

	and	eax, 2097168				; 00200010H

; 445  :       ADD ECX,EAX

	add	ecx, eax

; 446  :       MOV EAX,ECX

	mov	eax, ecx

; 447  :       SHR EAX,CHI_POS-1-SIGMA_CC_POS

	shr	eax, 16					; 00000010H

; 448  :       OR ECX,EAX

	or	ecx, eax

; 449  :       AND ECX,0x000000FF

	and	ecx, 255				; 000000ffH

; 450  :       MOVZX ECX,byte ptr [sign_lut+ECX]

	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]

; 451  :       MOV EAX,ECX // Save the sign LUT result in EAX

	mov	eax, ecx

; 452  :       SHR ECX,1 // Get context label part of the LUT result

	shr	ecx, 1

; 453  :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 454  :       LEA ECX,[EBX+8*ECX+8*KAPPA_SIGN_BASE] // ECX has pointer to context state

	lea	ecx, DWORD PTR [ebx+ecx*8+80]

; 455  :       MOV EBX,[ECX] // Get `p_bar_mps' to EBX

	mov	ebx, DWORD PTR [ecx]

; 456  :       XOR EAX,EBX

	xor	eax, ebx

; 457  :       AND EAX,1 // Leaves EAX with the MPS sign value in its LSB.

	and	eax, 1

; 458  :       BTR EBX,0 // Leaves `p_bar' in EBX

	btr	ebx, 0

; 459  :       SUB EDX,EBX

	sub	edx, ebx

; 460  :       JGE row0_broadcast

	jge	SHORT $row0_broadcast$19

; 461  :       CALL mq_non_cdp

	call	$mq_non_cdp$18
$row0_broadcast$19:

; 462  : row0_broadcast: // Process newly significant sample; sign is in LSB of EAX
; 463  :       // Broadcast significance and sign to last row of previous stripe
; 464  :       MOV EBX,is_causal

	mov	ebx, DWORD PTR _is_causal$[ebp]

; 465  :       TEST EBX,EBX

	test	ebx, ebx

; 466  :       JNZ row0_skip_non_causal

	jne	SHORT $row0_skip_non_causal$20

; 467  :       MOV EBX,EDI

	mov	ebx, edi

; 468  :       SUB EBX,context_row_gap

	sub	ebx, DWORD PTR _context_row_gap$[ebp]

; 469  :       MOV ECX,[EBX-4]

	mov	ecx, DWORD PTR [ebx-4]

; 470  :       OR ECX,__SIGMA_BR_BIT*512

	or	ecx, 131072				; 00020000H

; 471  :       MOV [EBX-4],ECX

	mov	DWORD PTR [ebx-4], ecx

; 472  :       MOV ECX,EAX

	mov	ecx, eax

; 473  :       SHL ECX,NEXT_CHI_POS

	shl	ecx, 31					; 0000001fH

; 474  :       OR ECX,[EBX]

	or	ecx, DWORD PTR [ebx]

; 475  :       OR ECX,__SIGMA_BC_BIT*512

	or	ecx, 65536				; 00010000H

; 476  :       MOV [EBX],ECX

	mov	DWORD PTR [ebx], ecx

; 477  :       MOV ECX,[EBX+4]

	mov	ecx, DWORD PTR [ebx+4]

; 478  :       OR ECX,__SIGMA_BL_BIT*512

	or	ecx, 32768				; 00008000H

; 479  :       MOV [EBX+4],ECX

	mov	DWORD PTR [ebx+4], ecx
$row0_skip_non_causal$20:

; 480  : row0_skip_non_causal:
; 481  :       // Broadcast significance to left and right neighbours
; 482  :       MOV ECX,[EDI-4]

	mov	ecx, DWORD PTR [edi-4]

; 483  :       OR ECX,__SIGMA_CR_BIT*1

	or	ecx, 32					; 00000020H

; 484  :       MOV [EDI-4],ECX

	mov	DWORD PTR [edi-4], ecx

; 485  :       MOV ECX,[EDI+4]

	mov	ecx, DWORD PTR [edi+4]

; 486  :       OR ECX,__SIGMA_CL_BIT*1

	or	ecx, 8

; 487  :       MOV [EDI+4],ECX

	mov	DWORD PTR [edi+4], ecx

; 488  :       // Recover and update context word, using ECX register
; 489  :       MOV ECX,EAX

	mov	ecx, eax

; 490  :       SHL ECX,CHI_POS

	shl	ecx, 21					; 00000015H

; 491  :       OR ECX,[EDI]

	or	ecx, DWORD PTR [edi]

; 492  :       OR ECX,__SIGMA_CC_BIT*1

	or	ecx, 16					; 00000010H

; 493  :       MOV [EDI],ECX

	mov	DWORD PTR [edi], ecx

; 494  :       // Write newly significant sample value
; 495  :       SHL EAX,31 // Get sign bit of result into right position

	shl	eax, 31					; 0000001fH

; 496  :       ADD EAX,one_point_five

	add	eax, DWORD PTR _one_point_five$[ebp]

; 497  :       MOV EBX,cp_to_sp0

	mov	ebx, DWORD PTR _cp_to_sp0$[ebp]

; 498  :       MOV [EDI+EBX],EAX

	mov	DWORD PTR [edi+ebx], eax
$row1$16:

; 499  : row1:
; 500  :       // Test for coding pass membership
; 501  :       MOV EBX,ECX

	mov	ebx, ecx

; 502  :       AND EBX,__NBRHD_MASK*8

	and	ebx, 3960				; 00000f78H

; 503  :       JZ row2

	je	$row2$21

; 504  :       TEST ECX,__SIG_PROP_MEMBER_MASK*8

	test	ecx, 16777344				; 01000080H

; 505  :       JNZ row2

	jne	$row2$21

; 506  :       OR ECX,__PI_BIT*8

	or	ecx, 8388608				; 00800000H

; 507  :       MOV [EDI],ECX // Save context word indicating that sample belongs to pass

	mov	DWORD PTR [edi], ecx

; 508  :       // Find pointer to the relevant context state record
; 509  :       SHR ECX,3

	shr	ecx, 3

; 510  :       AND ECX,__NBRHD_MASK

	and	ecx, 495				; 000001efH

; 511  :       ADD ECX,sig_lut

	add	ecx, DWORD PTR _sig_lut$[ebp]

; 512  :       MOVZX ECX,byte ptr [ECX]

	movzx	ecx, BYTE PTR [ecx]

; 513  :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 514  :       LEA ECX,[EBX+8*ECX]

	lea	ecx, DWORD PTR [ebx+ecx*8]

; 515  :       // Decode symbol
; 516  :       MOV EAX,[ECX] // Get `p_bar_mps' to EAX

	mov	eax, DWORD PTR [ecx]

; 517  :       SUB EDX,EAX

	sub	edx, eax

; 518  :       AND EAX,1 // Get MPS identity in LSB of EAX

	and	eax, 1

; 519  :       ADD EDX,EAX // Correct for the effect of the MPS

	add	edx, eax

; 520  :       JGE significance_test1

	jge	SHORT $significance_test1$22

; 521  :       CALL mq_non_cdp

	call	$mq_non_cdp$18
$significance_test1$22:

; 522  : significance_test1:
; 523  :       MOV ECX,[EDI] // Get context word back again

	mov	ecx, DWORD PTR [edi]

; 524  :       TEST EAX,EAX // If symbol != 0

	test	eax, eax

; 525  :       JZ row2

	je	$row2$21

; 526  :       // If we get here, we know that stripe row 1 is newly significant
; 527  :       AND ECX,__CHI_BIT+__SIGMA_CC_BIT+__CHI_BIT*64+__SIGMA_CC_BIT*64

	and	ecx, 136315920				; 08200410H

; 528  :       SHR ECX,4

	shr	ecx, 4

; 529  :       MOV EAX,[EDI-4] // Get context word on left

	mov	eax, DWORD PTR [edi-4]

; 530  :       AND EAX,__CHI_BIT*8+__SIGMA_CC_BIT*8

	and	eax, 16777344				; 01000080H

; 531  :       SHR EAX,5

	shr	eax, 5

; 532  :       ADD ECX,EAX

	add	ecx, eax

; 533  :       MOV EAX,[EDI+4] // Get context word on right

	mov	eax, DWORD PTR [edi+4]

; 534  :       AND EAX,__CHI_BIT*8+__SIGMA_CC_BIT*8

	and	eax, 16777344				; 01000080H

; 535  :       SHR EAX,3

	shr	eax, 3

; 536  :       ADD ECX,EAX

	add	ecx, eax

; 537  :       MOV EAX,ECX

	mov	eax, ecx

; 538  :       SHR EAX,CHI_POS-1-SIGMA_CC_POS

	shr	eax, 16					; 00000010H

; 539  :       OR ECX,EAX

	or	ecx, eax

; 540  :       AND ECX,0x000000FF

	and	ecx, 255				; 000000ffH

; 541  :       MOVZX ECX,byte ptr [sign_lut+ECX]

	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]

; 542  :       MOV EAX,ECX // Save the sign LUT result in EAX

	mov	eax, ecx

; 543  :       SHR ECX,1 // Get context label part of the LUT result

	shr	ecx, 1

; 544  :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 545  :       LEA ECX,[EBX+8*ECX+8*KAPPA_SIGN_BASE] // ECX has pointer to context state

	lea	ecx, DWORD PTR [ebx+ecx*8+80]

; 546  :       MOV EBX,[ECX] // Get `p_bar_mps' to EBX

	mov	ebx, DWORD PTR [ecx]

; 547  :       XOR EAX,EBX

	xor	eax, ebx

; 548  :       AND EAX,1 // Leaves EAX with the MPS sign value in its LSB.

	and	eax, 1

; 549  :       BTR EBX,0 // Leaves `p_bar' in EBX

	btr	ebx, 0

; 550  :       SUB EDX,EBX

	sub	edx, ebx

; 551  :       JGE row1_broadcast

	jge	SHORT $row1_broadcast$23

; 552  :       CALL mq_non_cdp

	call	$mq_non_cdp$18
$row1_broadcast$23:

; 553  : row1_broadcast: // Process newly significant sample; sign is in LSB of EAX
; 554  :       // Broadcast significance to left and right neighbours
; 555  :       MOV ECX,[EDI-4]

	mov	ecx, DWORD PTR [edi-4]

; 556  :       OR ECX,__SIGMA_CR_BIT*8

	or	ecx, 256				; 00000100H

; 557  :       MOV [EDI-4],ECX

	mov	DWORD PTR [edi-4], ecx

; 558  :       MOV ECX,[EDI+4]

	mov	ecx, DWORD PTR [edi+4]

; 559  :       OR ECX,__SIGMA_CL_BIT*8

	or	ecx, 64					; 00000040H

; 560  :       MOV [EDI+4],ECX

	mov	DWORD PTR [edi+4], ecx

; 561  :       // Recover and update context word, using ECX register
; 562  :       MOV ECX,EAX

	mov	ecx, eax

; 563  :       SHL ECX,CHI_POS+3

	shl	ecx, 24					; 00000018H

; 564  :       OR ECX,[EDI]

	or	ecx, DWORD PTR [edi]

; 565  :       OR ECX,__SIGMA_CC_BIT*8

	or	ecx, 128				; 00000080H

; 566  :       MOV [EDI],ECX

	mov	DWORD PTR [edi], ecx

; 567  :       // Write new significant sample value
; 568  :       SHL EAX,31 // Get sign bit of result into right position

	shl	eax, 31					; 0000001fH

; 569  :       ADD EAX,one_point_five

	add	eax, DWORD PTR _one_point_five$[ebp]

; 570  :       MOV EBX,cp_to_sp1

	mov	ebx, DWORD PTR _cp_to_sp1$[ebp]

; 571  :       MOV [EDI+EBX],EAX

	mov	DWORD PTR [edi+ebx], eax
$row2$21:

; 572  : row2:
; 573  :       // Test for coding pass membership
; 574  :       MOV EBX,ECX

	mov	ebx, ecx

; 575  :       AND EBX,__NBRHD_MASK*64

	and	ebx, 31680				; 00007bc0H

; 576  :       JZ row3

	je	$row3$24

; 577  :       TEST ECX,__SIG_PROP_MEMBER_MASK*64

	test	ecx, 134218752				; 08000400H

; 578  :       JNZ row3

	jne	$row3$24

; 579  :       OR ECX,__PI_BIT*64

	or	ecx, 67108864				; 04000000H

; 580  :       MOV [EDI],ECX // Save context word indicating that sample belongs to pass

	mov	DWORD PTR [edi], ecx

; 581  :       // Find pointer to the relevant context state record
; 582  :       SHR ECX,6

	shr	ecx, 6

; 583  :       AND ECX,__NBRHD_MASK

	and	ecx, 495				; 000001efH

; 584  :       ADD ECX,sig_lut

	add	ecx, DWORD PTR _sig_lut$[ebp]

; 585  :       MOVZX ECX,byte ptr [ECX]

	movzx	ecx, BYTE PTR [ecx]

; 586  :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 587  :       LEA ECX,[EBX+8*ECX]

	lea	ecx, DWORD PTR [ebx+ecx*8]

; 588  :       // Decode symbol
; 589  :       MOV EAX,[ECX] // Get `p_bar_mps' to EAX

	mov	eax, DWORD PTR [ecx]

; 590  :       SUB EDX,EAX

	sub	edx, eax

; 591  :       AND EAX,1 // Get MPS identity in LSB of EAX

	and	eax, 1

; 592  :       ADD EDX,EAX // Correct for the effect of the MPS

	add	edx, eax

; 593  :       JGE significance_test2

	jge	SHORT $significance_test2$25

; 594  :       CALL mq_non_cdp

	call	$mq_non_cdp$18
$significance_test2$25:

; 595  : significance_test2:
; 596  :       MOV ECX,[EDI] // Get context word back again

	mov	ecx, DWORD PTR [edi]

; 597  :       TEST EAX,EAX // If symbol != 0

	test	eax, eax

; 598  :       JZ row3

	je	$row3$24

; 599  :       // If we get here, we know that stripe row 2 is newly significant
; 600  :       AND ECX,__CHI_BIT*8+__SIGMA_CC_BIT*8+__CHI_BIT*512+__SIGMA_CC_BIT*512

	and	ecx, 1090527360				; 41002080H

; 601  :       SHR ECX,7

	shr	ecx, 7

; 602  :       MOV EAX,[EDI-4] // Get context word on left

	mov	eax, DWORD PTR [edi-4]

; 603  :       AND EAX,__CHI_BIT*64+__SIGMA_CC_BIT*64

	and	eax, 134218752				; 08000400H

; 604  :       SHR EAX,8

	shr	eax, 8

; 605  :       ADD ECX,EAX

	add	ecx, eax

; 606  :       MOV EAX,[EDI+4] // Get context word on right

	mov	eax, DWORD PTR [edi+4]

; 607  :       AND EAX,__CHI_BIT*64+__SIGMA_CC_BIT*64

	and	eax, 134218752				; 08000400H

; 608  :       SHR EAX,6

	shr	eax, 6

; 609  :       ADD ECX,EAX

	add	ecx, eax

; 610  :       MOV EAX,ECX

	mov	eax, ecx

; 611  :       SHR EAX,CHI_POS-1-SIGMA_CC_POS

	shr	eax, 16					; 00000010H

; 612  :       OR ECX,EAX

	or	ecx, eax

; 613  :       AND ECX,0x000000FF

	and	ecx, 255				; 000000ffH

; 614  :       MOVZX ECX,byte ptr [sign_lut+ECX]

	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]

; 615  :       MOV EAX,ECX // Save the sign LUT result in EAX

	mov	eax, ecx

; 616  :       SHR ECX,1 // Get context label part of the LUT result

	shr	ecx, 1

; 617  :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 618  :       LEA ECX,[EBX+8*ECX+8*KAPPA_SIGN_BASE] // ECX has pointer to context state

	lea	ecx, DWORD PTR [ebx+ecx*8+80]

; 619  :       MOV EBX,[ECX] // Get `p_bar_mps' to EBX

	mov	ebx, DWORD PTR [ecx]

; 620  :       XOR EAX,EBX

	xor	eax, ebx

; 621  :       AND EAX,1 // Leaves EAX with the MPS sign value in its LSB.

	and	eax, 1

; 622  :       BTR EBX,0 // Leaves `p_bar' in EBX

	btr	ebx, 0

; 623  :       SUB EDX,EBX

	sub	edx, ebx

; 624  :       JGE row2_broadcast

	jge	SHORT $row2_broadcast$26

; 625  :       CALL mq_non_cdp

	call	$mq_non_cdp$18
$row2_broadcast$26:

; 626  : row2_broadcast: // Process newly significant sample; sign is in LSB of EAX
; 627  :       // Broadcast significance to left and right neighbours
; 628  :       MOV ECX,[EDI-4]

	mov	ecx, DWORD PTR [edi-4]

; 629  :       OR ECX,__SIGMA_CR_BIT*64

	or	ecx, 2048				; 00000800H

; 630  :       MOV [EDI-4],ECX

	mov	DWORD PTR [edi-4], ecx

; 631  :       MOV ECX,[EDI+4]

	mov	ecx, DWORD PTR [edi+4]

; 632  :       OR ECX,__SIGMA_CL_BIT*64

	or	ecx, 512				; 00000200H

; 633  :       MOV [EDI+4],ECX

	mov	DWORD PTR [edi+4], ecx

; 634  :       // Recover and update context word, using ECX register
; 635  :       MOV ECX,EAX

	mov	ecx, eax

; 636  :       SHL ECX,CHI_POS+6

	shl	ecx, 27					; 0000001bH

; 637  :       OR ECX,[EDI]

	or	ecx, DWORD PTR [edi]

; 638  :       OR ECX,__SIGMA_CC_BIT*64

	or	ecx, 1024				; 00000400H

; 639  :       MOV [EDI],ECX

	mov	DWORD PTR [edi], ecx

; 640  :       // Write new significant sample value
; 641  :       SHL EAX,31 // Get sign bit of result into right position

	shl	eax, 31					; 0000001fH

; 642  :       ADD EAX,one_point_five

	add	eax, DWORD PTR _one_point_five$[ebp]

; 643  :       MOV EBX,cp_to_sp2

	mov	ebx, DWORD PTR _cp_to_sp2$[ebp]

; 644  :       MOV [EDI+EBX],EAX

	mov	DWORD PTR [edi+ebx], eax
$row3$24:

; 645  : row3:
; 646  :       // Test for coding pass membership
; 647  :       MOV EBX,ECX

	mov	ebx, ecx

; 648  :       AND EBX,__NBRHD_MASK*512

	and	ebx, 253440				; 0003de00H

; 649  :       JZ advance_stripe_column

	je	$advance_stripe_column$27

; 650  :       TEST ECX,__SIG_PROP_MEMBER_MASK*512

	test	ecx, 1073750016				; 40002000H

; 651  :       JNZ advance_stripe_column

	jne	$advance_stripe_column$27

; 652  :       OR ECX,__PI_BIT*512

	or	ecx, 536870912				; 20000000H

; 653  :       MOV [EDI],ECX // Save context word indicating that sample belongs to pass

	mov	DWORD PTR [edi], ecx

; 654  :       // Find pointer to the relevant context state record
; 655  :       SHR ECX,9

	shr	ecx, 9

; 656  :       AND ECX,__NBRHD_MASK

	and	ecx, 495				; 000001efH

; 657  :       ADD ECX,sig_lut

	add	ecx, DWORD PTR _sig_lut$[ebp]

; 658  :       MOVZX ECX,byte ptr [ECX]

	movzx	ecx, BYTE PTR [ecx]

; 659  :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 660  :       LEA ECX,[EBX+8*ECX]

	lea	ecx, DWORD PTR [ebx+ecx*8]

; 661  :       // Decode symbol
; 662  :       MOV EAX,[ECX] // Get `p_bar_mps' to EAX

	mov	eax, DWORD PTR [ecx]

; 663  :       SUB EDX,EAX

	sub	edx, eax

; 664  :       AND EAX,1 // Get MPS identity in LSB of EAX

	and	eax, 1

; 665  :       ADD EDX,EAX // Correct for the effect of the MPS

	add	edx, eax

; 666  :       JGE significance_test3

	jge	SHORT $significance_test3$28

; 667  :       CALL mq_non_cdp

	call	$mq_non_cdp$18
$significance_test3$28:

; 668  : significance_test3:
; 669  :       MOV ECX,[EDI] // Get context word back again

	mov	ecx, DWORD PTR [edi]

; 670  :       TEST EAX,EAX // If symbol != 0

	test	eax, eax

; 671  :       JZ advance_stripe_column

	je	$advance_stripe_column$27

; 672  :       // If we get here, we know that stripe row 3 is newly significant
; 673  :       MOV EBX,ECX // Make copy of ECX for exceptional sign processing

	mov	ebx, ecx

; 674  :       AND ECX,__CHI_BIT*64+__SIGMA_CC_BIT*64+__SIGMA_CC_BIT*4096

	and	ecx, 134284288				; 08010400H

; 675  :       SHR ECX,10

	shr	ecx, 10					; 0000000aH

; 676  :       TEST EBX,EBX

	test	ebx, ebx

; 677  :       JGE no_exceptional_sign_processing

	jge	SHORT $no_exceptional_sign_processing$29

; 678  :       OR ECX,__CHI_BIT*4

	or	ecx, 8388608				; 00800000H
$no_exceptional_sign_processing$29:

; 679  : no_exceptional_sign_processing:
; 680  :       MOV EAX,[EDI-4] // Get context word on left

	mov	eax, DWORD PTR [edi-4]

; 681  :       AND EAX,__CHI_BIT*512+__SIGMA_CC_BIT*512

	and	eax, 1073750016				; 40002000H

; 682  :       SHR EAX,11

	shr	eax, 11					; 0000000bH

; 683  :       ADD ECX,EAX

	add	ecx, eax

; 684  :       MOV EAX,[EDI+4] // Get context word on right

	mov	eax, DWORD PTR [edi+4]

; 685  :       AND EAX,__CHI_BIT*512+__SIGMA_CC_BIT*512

	and	eax, 1073750016				; 40002000H

; 686  :       SHR EAX,9

	shr	eax, 9

; 687  :       ADD ECX,EAX

	add	ecx, eax

; 688  :       MOV EAX,ECX

	mov	eax, ecx

; 689  :       SHR EAX,CHI_POS-1-SIGMA_CC_POS

	shr	eax, 16					; 00000010H

; 690  :       OR ECX,EAX

	or	ecx, eax

; 691  :       AND ECX,0x000000FF

	and	ecx, 255				; 000000ffH

; 692  :       MOVZX ECX,byte ptr [sign_lut+ECX]

	movzx	ecx, BYTE PTR ?sign_lut@@3PAEA[ecx]

; 693  :       MOV EAX,ECX // Save the sign LUT result in EAX

	mov	eax, ecx

; 694  :       SHR ECX,1 // Get context label part of the LUT result

	shr	ecx, 1

; 695  :       MOV EBX,states

	mov	ebx, DWORD PTR _states$[ebp]

; 696  :       LEA ECX,[EBX+8*ECX+8*KAPPA_SIGN_BASE] // ECX has pointer to context state

	lea	ecx, DWORD PTR [ebx+ecx*8+80]

; 697  :       MOV EBX,[ECX] // Get `p_bar_mps' to EBX

	mov	ebx, DWORD PTR [ecx]

; 698  :       XOR EAX,EBX

	xor	eax, ebx

; 699  :       AND EAX,1 // Leaves EAX with the MPS sign value in its LSB.

	and	eax, 1

; 700  :       BTR EBX,0 // Leaves `p_bar' in EBX

	btr	ebx, 0

; 701  :       SUB EDX,EBX

	sub	edx, ebx

; 702  :       JGE row3_broadcast

	jge	SHORT $row3_broadcast$30

; 703  :       CALL mq_non_cdp

	call	$mq_non_cdp$18
$row3_broadcast$30:

; 704  : row3_broadcast: // Process newly significant sample; sign is in LSB of EAX
; 705  :       // Broadcast significance and sign to first row of next stripe
; 706  :       MOV EBX,EDI

	mov	ebx, edi

; 707  :       ADD EBX,context_row_gap

	add	ebx, DWORD PTR _context_row_gap$[ebp]

; 708  :       MOV ECX,[EBX-4]

	mov	ecx, DWORD PTR [ebx-4]

; 709  :       OR ECX,__SIGMA_TR_BIT

	or	ecx, 4

; 710  :       MOV [EBX-4],ECX

	mov	DWORD PTR [ebx-4], ecx

; 711  :       MOV ECX,EAX

	mov	ecx, eax

; 712  :       SHL ECX,PREV_CHI_POS

	shl	ecx, 18					; 00000012H

; 713  :       OR ECX,[EBX]

	or	ecx, DWORD PTR [ebx]

; 714  :       OR ECX,__SIGMA_TC_BIT

	or	ecx, 2

; 715  :       MOV [EBX],ECX

	mov	DWORD PTR [ebx], ecx

; 716  :       MOV ECX,[EBX+4]

	mov	ecx, DWORD PTR [ebx+4]

; 717  :       OR ECX,__SIGMA_TL_BIT

	or	ecx, 1

; 718  :       MOV [EBX+4],ECX

	mov	DWORD PTR [ebx+4], ecx

; 719  :       // Broadcast significance to left and right neighbours
; 720  :       MOV ECX,[EDI-4]

	mov	ecx, DWORD PTR [edi-4]

; 721  :       OR ECX,__SIGMA_CR_BIT*512

	or	ecx, 16384				; 00004000H

; 722  :       MOV [EDI-4],ECX

	mov	DWORD PTR [edi-4], ecx

; 723  :       MOV ECX,[EDI+4]

	mov	ecx, DWORD PTR [edi+4]

; 724  :       OR ECX,__SIGMA_CL_BIT*512

	or	ecx, 4096				; 00001000H

; 725  :       MOV [EDI+4],ECX

	mov	DWORD PTR [edi+4], ecx

; 726  :       // Recover and update context word, using ECX register
; 727  :       MOV ECX,EAX

	mov	ecx, eax

; 728  :       SHL ECX,CHI_POS+9

	shl	ecx, 30					; 0000001eH

; 729  :       OR ECX,[EDI]

	or	ecx, DWORD PTR [edi]

; 730  :       OR ECX,__SIGMA_CC_BIT*512

	or	ecx, 8192				; 00002000H

; 731  :       MOV [EDI],ECX

	mov	DWORD PTR [edi], ecx

; 732  :       // Write new significant sample value
; 733  :       SHL EAX,31 // Get sign bit of result into right position

	shl	eax, 31					; 0000001fH

; 734  :       ADD EAX,one_point_five

	add	eax, DWORD PTR _one_point_five$[ebp]

; 735  :       MOV EBX,cp_to_sp3

	mov	ebx, DWORD PTR _cp_to_sp3$[ebp]

; 736  :       MOV [EDI+EBX],EAX

	mov	DWORD PTR [edi+ebx], eax
$advance_stripe_column$27:

; 737  : advance_stripe_column:
; 738  :     ADD EDI,4

	add	edi, 4

; 739  :     CMP EDI,stripe_end

	cmp	edi, DWORD PTR _stripe_end$[ebp]

; 740  :     JNZ next_stripe_column

	jne	$next_stripe_column$12
$advance_stripe$15:

; 741  : advance_stripe:
; 742  :     ADD EDI,EXTRA_DECODE_CWORDS*4

	add	edi, 12					; 0000000cH

; 743  :     MOV EAX,cp_to_sp_adjust

	mov	eax, DWORD PTR _cp_to_sp_adjust$[ebp]

; 744  :     MOV EBX,cp_to_sp0

	mov	ebx, DWORD PTR _cp_to_sp0$[ebp]

; 745  :     ADD EBX,EAX

	add	ebx, eax

; 746  :     MOV cp_to_sp0,EBX

	mov	DWORD PTR _cp_to_sp0$[ebp], ebx

; 747  :     MOV EBX,cp_to_sp1

	mov	ebx, DWORD PTR _cp_to_sp1$[ebp]

; 748  :     ADD EBX,EAX

	add	ebx, eax

; 749  :     MOV cp_to_sp1,EBX

	mov	DWORD PTR _cp_to_sp1$[ebp], ebx

; 750  :     MOV EBX,cp_to_sp2

	mov	ebx, DWORD PTR _cp_to_sp2$[ebp]

; 751  :     ADD EBX,EAX

	add	ebx, eax

; 752  :     MOV cp_to_sp2,EBX

	mov	DWORD PTR _cp_to_sp2$[ebp], ebx

; 753  :     MOV EBX,cp_to_sp3

	mov	ebx, DWORD PTR _cp_to_sp3$[ebp]

; 754  :     ADD EBX,EAX

	add	ebx, eax

; 755  :     MOV cp_to_sp3,EBX

	mov	DWORD PTR _cp_to_sp3$[ebp], ebx

; 756  :     MOV EAX,num_stripes

	mov	eax, DWORD PTR _num_stripes$[ebp]

; 757  :     SUB EAX,1

	sub	eax, 1

; 758  :     MOV num_stripes,EAX

	mov	DWORD PTR _num_stripes$[ebp], eax

; 759  :     JNZ next_stripe

	jne	$next_stripe$11

; 760  :     JMP finished

	jmp	$finished$31
$mq_non_cdp$18:

; 761  :     // We insert local fast function calls here
; 762  : mq_non_cdp:
; 763  :     ASM_MQ_NON_CDP_DECODE

	mov	ebx, DWORD PTR [ecx]
	add	esi, edx
	btr	ebx, 0
	add	edx, DWORD PTR _C_var$[ebp]
	jl	SHORT $non_cdp_Clt0$32
	cmp	esi, ebx
	jge	SHORT $non_cdp_Cge0_AgeP$33
	xor	eax, 1
	mov	ebx, DWORD PTR [ecx+4]
	movq	mm0, MMWORD PTR [ebx+8]
	movq	MMWORD PTR [ecx], mm0
	jmp	SHORT $non_cdp_renorm$34
$non_cdp_Cge0_AgeP$33:
	mov	ebx, DWORD PTR [ecx+4]
	movq	mm0, MMWORD PTR [ebx]
	movq	MMWORD PTR [ecx], mm0
	jmp	SHORT $non_cdp_renorm$34
$non_cdp_Clt0$32:
	add	edx, ebx
	cmp	esi, ebx
	mov	esi, ebx
	jge	SHORT $non_cdp_Clt0_AgeP$35
	mov	ebx, DWORD PTR [ecx+4]
	movq	mm0, MMWORD PTR [ebx]
	movq	MMWORD PTR [ecx], mm0
	jmp	SHORT $non_cdp_renorm$34
$non_cdp_Clt0_AgeP$35:
	xor	eax, 1
	mov	ebx, DWORD PTR [ecx+4]
	movq	mm0, MMWORD PTR [ebx+8]
	movq	MMWORD PTR [ecx], mm0
$non_cdp_renorm$34:
	mov	ebx, DWORD PTR _t_var$[ebp]
$non_cdp_renorm_once$36:
	test	ebx, ebx
	jne	SHORT $non_cdp_have_more_bits$37
	mov	ecx, DWORD PTR _temp_var$[ebp]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $non_cdp_no_ff$38
	mov	ebx, DWORD PTR _store_var$[ebp]
	movzx	ecx, BYTE PTR [ebx]
	cmp	ecx, 143				; 0000008fH
	jle	SHORT $non_cdp_temp_le8F$39
	mov	ecx, 255				; 000000ffH
	mov	ebx, DWORD PTR _S_var$[ebp]
	add	ebx, 1
	mov	DWORD PTR _S_var$[ebp], ebx
	mov	ebx, 8
	jmp	SHORT $non_cdp_complete_fill_lsbs$40
$non_cdp_temp_le8F$39:
	add	edx, ecx
	add	ebx, 1
	mov	DWORD PTR _store_var$[ebp], ebx
	mov	ebx, 7
	jmp	SHORT $non_cdp_complete_fill_lsbs$40
$non_cdp_no_ff$38:
	mov	ebx, DWORD PTR _store_var$[ebp]
	movzx	ecx, BYTE PTR [ebx]
	add	ebx, 1
	mov	DWORD PTR _store_var$[ebp], ebx
	mov	ebx, 8
$non_cdp_complete_fill_lsbs$40:
	add	edx, ecx
	mov	DWORD PTR _temp_var$[ebp], ecx
$non_cdp_have_more_bits$37:
	add	esi, esi
	add	edx, edx
	sub	ebx, 1
	test	esi, 8388608				; 00800000H
	je	SHORT $non_cdp_renorm_once$36
	mov	DWORD PTR _t_var$[ebp], ebx
	mov	ebx, esi
	sub	ebx, 8388608				; 00800000H
	cmp	edx, ebx
	cmovl	ebx, edx
	sub	esi, ebx
	sub	edx, ebx
	mov	DWORD PTR _C_var$[ebp], edx
	mov	edx, ebx

; 764  :     ret // Return from fast function call

	ret	0
$finished$31:

; 765  : finished:
; 766  :     MOV D_var,EDX // Save the D register ready for `coder.check_in'

	mov	DWORD PTR _D_var$[ebp], edx

; 767  :     MOV A_var,ESI // Save the A register ready for `coder.check_in'

	mov	DWORD PTR _A_var$[ebp], esi

; 768  :     EMMS // Restore the FPU registers from any MMX calls which we may have used

	emms

; 769  :   }
; 770  : 
; 771  :   coder.check_in(A_var,C_var,D_var,t_var,temp_var,store_var,S_var);

	mov	ecx, DWORD PTR _S_var$[ebp]
	push	ecx
	mov	edx, DWORD PTR _store_var$[ebp]
	push	edx
	mov	eax, DWORD PTR _temp_var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t_var$[ebp]
	push	ecx
	mov	edx, DWORD PTR _D_var$[ebp]
	push	edx
	mov	eax, DWORD PTR _C_var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _A_var$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _coder$[ebp]
	call	?check_in@mq_decoder@@QAEXHHHHHPAEH@Z	; mq_decoder::check_in
$LN1@asm_decode:

; 772  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?asm_decode_sig_prop_pass@@YAXAAVmq_decoder@@QAUmqd_state@@H_NHPAH3HHH@Z ENDP ; asm_decode_sig_prop_pass
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
;	COMDAT ?check_in@mq_decoder@@QAEXHHPAE@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
_temp$ = 12						; size = 4
_store$ = 16						; size = 4
?check_in@mq_decoder@@QAEXHHPAE@Z PROC			; mq_decoder::check_in, COMDAT
; _this$ = ecx

; 165  :       { // Use this form for raw codeword segments.

	push	ebp
	mov	ebp, esp

; 166  :         assert(active && checked_out && !MQ_segment); checked_out = false;
; 167  :         this->t = t; this->temp = temp; this->buf_next = store;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _store$[ebp]
	mov	BYTE PTR [ecx+28], 0
	mov	DWORD PTR [ecx+20], eax

; 168  :       }

	pop	ebp
	ret	12					; 0000000cH
?check_in@mq_decoder@@QAEXHHPAE@Z ENDP			; mq_decoder::check_in
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
;	COMDAT ?check_in@mq_decoder@@QAEXHHHHHPAEH@Z
_TEXT	SEGMENT
_A$ = 8							; size = 4
_C$ = 12						; size = 4
_D$ = 16						; size = 4
_t$ = 20						; size = 4
_temp$ = 24						; size = 4
_store$ = 28						; size = 4
_S$ = 32						; size = 4
?check_in@mq_decoder@@QAEXHHHHHPAEH@Z PROC		; mq_decoder::check_in, COMDAT
; _this$ = ecx

; 159  :       { // Use this form for MQ codeword segments.

	push	ebp
	mov	ebp, esp

; 160  :         assert(active && checked_out && MQ_segment); checked_out = false;
; 161  :         this->A = A+D; this->C = C+D;

	mov	eax, DWORD PTR _A$[ebp]
	add	eax, DWORD PTR _D$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _C$[ebp]
	add	eax, DWORD PTR _D$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 162  :         this->t = t; this->temp = temp; this->buf_next = store; this->S = S;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _store$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _S$[ebp]
	mov	BYTE PTR [ecx+28], 0
	mov	DWORD PTR [ecx+24], eax

; 163  :       }

	pop	ebp
	ret	28					; 0000001cH
?check_in@mq_decoder@@QAEXHHHHHPAEH@Z ENDP		; mq_decoder::check_in
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
;	COMDAT ?check_out@mq_decoder@@QAEXAAH0AAPAE@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
_temp$ = 12						; size = 4
_store$ = 16						; size = 4
?check_out@mq_decoder@@QAEXAAH0AAPAE@Z PROC		; mq_decoder::check_out, COMDAT
; _this$ = ecx

; 153  :       { // Use this form for raw codeword segments.

	push	ebp
	mov	ebp, esp

; 154  :         assert(active && (!checked_out) && !MQ_segment); checked_out = true;
; 155  :         t = this->t; temp = this->temp; store = this->buf_next;

	mov	eax, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+28], 1
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _temp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _store$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax], ecx

; 156  :       }

	pop	ebp
	ret	12					; 0000000cH
?check_out@mq_decoder@@QAEXAAH0AAPAE@Z ENDP		; mq_decoder::check_out
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
;	COMDAT ?check_out@mq_decoder@@QAEXAAH0000AAPAE0@Z
_TEXT	SEGMENT
_A$ = 8							; size = 4
_C$ = 12						; size = 4
_D$ = 16						; size = 4
_t$ = 20						; size = 4
_temp$ = 24						; size = 4
_store$ = 28						; size = 4
_S$ = 32						; size = 4
?check_out@mq_decoder@@QAEXAAH0000AAPAE0@Z PROC		; mq_decoder::check_out, COMDAT
; _this$ = ecx

; 146  :       { // Use this form for MQ codeword segments.

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, ecx

; 147  :         assert(active && (!checked_out) && MQ_segment); checked_out = true;
; 148  :         A = this->A; C = this->C;
; 149  :         D = A-MQD_A_MIN; D = (C<D)?C:D; A -= D; C -= D;

	mov	ecx, DWORD PTR _D$[ebp]
	push	esi
	mov	esi, DWORD PTR _C$[ebp]
	push	edi
	mov	eax, DWORD PTR [ebx]
	mov	edi, DWORD PTR _A$[ebp]
	mov	BYTE PTR [ebx+28], 1
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi], eax
	mov	edx, DWORD PTR [edi]
	add	edx, -8388608				; ff800000H
	mov	DWORD PTR [ecx], edx
	cmp	DWORD PTR [esi], edx
	cmovl	edx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], edx
	sub	DWORD PTR [edi], edx
	mov	eax, DWORD PTR [ecx]
	sub	DWORD PTR [esi], eax

; 150  :         t = this->t; temp = this->temp; store = this->buf_next; S = this->S;

	mov	ecx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR _t$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _temp$[ebp]
	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _store$[ebp]
	mov	ecx, DWORD PTR [ebx+20]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _S$[ebp]
	mov	ecx, DWORD PTR [ebx+24]
	pop	ebx
	mov	DWORD PTR [eax], ecx

; 151  :       }

	pop	ebp
	ret	28					; 0000001cH
?check_out@mq_decoder@@QAEXAAH0000AAPAE0@Z ENDP		; mq_decoder::check_out
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
;	COMDAT ??0mq_decoder@@QAE@XZ
_TEXT	SEGMENT
??0mq_decoder@@QAE@XZ PROC				; mq_decoder::mq_decoder, COMDAT
; _this$ = ecx

; 124  :       { active = false; buf_start = buf_next = NULL; }

	mov	BYTE PTR [ecx+30], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+16], 0
	ret	0
??0mq_decoder@@QAE@XZ ENDP				; mq_decoder::mq_decoder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\mq_decoder.h
;	COMDAT ?init@mqd_state@@QAEXHH@Z
_TEXT	SEGMENT
_Sigma$ = 8						; size = 4
_s$ = 12						; size = 4
?init@mqd_state@@QAEXHH@Z PROC				; mqd_state::init, COMDAT
; _this$ = ecx

; 199  : {

	push	ebp
	mov	ebp, esp

; 200  :   assert((Sigma >= 0) && (Sigma <= 46) && (s == (s&1)));
; 201  :   p_bar_mps = (mq_decoder::p_bar_table[Sigma] << 8) + s;

	mov	eax, DWORD PTR _s$[ebp]
	push	esi
	mov	esi, DWORD PTR _Sigma$[ebp]
	mov	edx, DWORD PTR ?p_bar_table@mq_decoder@@2PAHA[esi*4]
	shl	edx, 8
	add	edx, eax

; 202  :   transition = mq_decoder::transition_table + ((Sigma<<1) + s);

	lea	eax, DWORD PTR [eax+esi*2]
	shl	eax, 4
	add	eax, OFFSET ?transition_table@mq_decoder@@2PAUmqd_transition@@A ; mq_decoder::transition_table
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	pop	esi

; 203  : }

	pop	ebp
	ret	8
?init@mqd_state@@QAEXHH@Z ENDP				; mqd_state::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
;	COMDAT ??0kdu_block_decoder@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??0kdu_block_decoder@@QAE@XZ PROC			; kdu_block_decoder::kdu_block_decoder, COMDAT
; _this$ = ecx

; 830  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 831  :   state = new kd_block_decoder;

	push	8
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN3@kdu_block_

; 125  :       {

	mov	DWORD PTR [eax], OFFSET ??_7kd_block_decoder@@6B@

; 126  :         use_pentium_speedups = false;

	mov	BYTE PTR [eax+4], 0

; 127  :         use_pentium_speedups = (kdu_mmx_level > 0) && kdu_pentium_cmov_exists;

	cmp	DWORD PTR ?kdu_mmx_level@@3HA, 0	; kdu_mmx_level
	jle	SHORT $LN8@kdu_block_
	cmp	BYTE PTR ?kdu_pentium_cmov_exists@@3_NA, 0 ; kdu_pentium_cmov_exists
	je	SHORT $LN8@kdu_block_
	mov	ecx, 1
	mov	BYTE PTR [eax+4], cl

; 831  :   state = new kd_block_decoder;

	mov	DWORD PTR [esi], eax

; 832  : }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@kdu_block_:

; 127  :         use_pentium_speedups = (kdu_mmx_level > 0) && kdu_pentium_cmov_exists;

	xor	ecx, ecx
	mov	BYTE PTR [eax+4], cl

; 831  :   state = new kd_block_decoder;

	mov	DWORD PTR [esi], eax

; 832  : }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@kdu_block_:

; 831  :   state = new kd_block_decoder;

	mov	DWORD PTR [esi], 0

; 832  : }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0kdu_block_decoder@@QAE@XZ ENDP			; kdu_block_decoder::kdu_block_decoder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
;	COMDAT ??_Gkdu_block_decoder_base@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkdu_block_decoder_base@@MAEPAXI@Z PROC		; kdu_block_decoder_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 161  :       { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_block_decoder_base@@6B@
	je	SHORT $LN7@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkdu_block_decoder_base@@MAEPAXI@Z ENDP		; kdu_block_decoder_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0kdu_block_decoder_base@@QAE@XZ
_TEXT	SEGMENT
??0kdu_block_decoder_base@@QAE@XZ PROC			; kdu_block_decoder_base::kdu_block_decoder_base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kdu_block_decoder_base@@6B@
	mov	eax, ecx
	ret	0
??0kdu_block_decoder_base@@QAE@XZ ENDP			; kdu_block_decoder_base::kdu_block_decoder_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_block_coding.h
;	COMDAT ??1kdu_block_decoder_base@@MAE@XZ
_TEXT	SEGMENT
??1kdu_block_decoder_base@@MAE@XZ PROC			; kdu_block_decoder_base::~kdu_block_decoder_base, COMDAT
; _this$ = ecx

; 161  :       { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_block_decoder_base@@6B@
	ret	0
??1kdu_block_decoder_base@@MAE@XZ ENDP			; kdu_block_decoder_base::~kdu_block_decoder_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?finish_timing@kdu_block@@QAEXXZ
_TEXT	SEGMENT
?finish_timing@kdu_block@@QAEXXZ PROC			; kdu_block::finish_timing, COMDAT
; _this$ = ecx

; 6344 :       { /* [SYNOPSIS] See `start_timing'. */

	push	esi
	mov	esi, ecx

; 6345 :         if (cpu_iterations == 0) return;

	cmp	DWORD PTR [esi+132], 0
	je	SHORT $LN1@finish_tim

; 6346 :         cpu_time += clock() - cpu_start;

	call	DWORD PTR __imp__clock
	sub	eax, DWORD PTR [esi+144]
	add	DWORD PTR [esi+148], eax

; 6347 :         cpu_unique_samples += size.x*size.y;

	mov	eax, DWORD PTR [esi+4]
	imul	eax, DWORD PTR [esi]
	cdq
	add	DWORD PTR [esi+136], eax
	adc	DWORD PTR [esi+140], edx
$LN1@finish_tim:
	pop	esi

; 6348 :       }

	ret	0
?finish_timing@kdu_block@@QAEXXZ ENDP			; kdu_block::finish_timing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?start_timing@kdu_block@@QAEHXZ
_TEXT	SEGMENT
?start_timing@kdu_block@@QAEHXZ PROC			; kdu_block::start_timing, COMDAT
; _this$ = ecx

; 6332 :       {

	push	esi
	mov	esi, ecx

; 6333 :       /* [SYNOPSIS]
; 6334 :            If the block encoder or decoder supports the gathering of timing
; 6335 :            statistics, it should do so by calling this function at the start
; 6336 :            of a timing loop and `finish_timing' at the end of the loop; the
; 6337 :            number of times to execute the loop is the return value from the
; 6338 :            function.
; 6339 :       */
; 6340 :         if (cpu_iterations == 0) return 1;

	cmp	DWORD PTR [esi+132], 0
	jne	SHORT $LN2@start_timi
	mov	eax, 1
	pop	esi

; 6342 :       }

	ret	0
$LN2@start_timi:

; 6341 :         cpu_start = clock(); return cpu_iterations;

	call	DWORD PTR __imp__clock
	mov	DWORD PTR [esi+144], eax
	mov	eax, DWORD PTR [esi+132]
	pop	esi

; 6342 :       }

	ret	0
?start_timing@kdu_block@@QAEHXZ ENDP			; kdu_block::start_timing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
??6kdu_message@@QAEAAV0@PBD@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 257  :       { put_text(string); return *this; }

	push	ebp
	mov	ebp, esp
	push	esi
	push	DWORD PTR _string$[ebp]
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@PBD@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\coding\block_decoder.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
