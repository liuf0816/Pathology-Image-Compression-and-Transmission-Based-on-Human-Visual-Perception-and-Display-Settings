; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\common\kdu_arch.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?kdu_sparcvis_exists@@3_NA			; kdu_sparcvis_exists
PUBLIC	?kdu_altivec_exists@@3_NA			; kdu_altivec_exists
_BSS	SEGMENT
?kdu_sparcvis_exists@@3_NA DB 01H DUP (?)		; kdu_sparcvis_exists
?kdu_altivec_exists@@3_NA DB 01H DUP (?)		; kdu_altivec_exists
_BSS	ENDS
PUBLIC	?kdu_get_num_processors@@YAHXZ			; kdu_get_num_processors
PUBLIC	?kdu_mmx_level@@3HA				; kdu_mmx_level
PUBLIC	?kdu_pentium_cmov_exists@@3_NA			; kdu_pentium_cmov_exists
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__GetProcessAffinityMask@12:PROC
EXTRN	__except_handler4:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
	ALIGN	4

?kdu_mmx_level@@3HA DD 01H DUP (?)			; kdu_mmx_level
?kdu_pentium_cmov_exists@@3_NA DB 01H DUP (?)		; kdu_pentium_cmov_exists
_BSS	ENDS
CRT$XCU	SEGMENT
?kdu_mmx_level$initializer$@@3P6AXXZA DD FLAT:??__Ekdu_mmx_level@@YAXXZ ; kdu_mmx_level$initializer$
CRT$XCU	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?get_cmov_exists@@YA_NXZ DD 0fffffffeH
	DD	00H
	DD	0ffffffd4H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN10@get_cmov_e
	DD	FLAT:$LN6@get_cmov_e
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?get_mmx_level@@YAHXZ DD 0fffffffeH
	DD	00H
	DD	0ffffffd0H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN22@get_mmx_le
	DD	FLAT:$LN11@get_mmx_le
	DD	0fffffffeH
	DD	FLAT:$LN21@get_mmx_le
	DD	FLAT:$LN15@get_mmx_le
xdata$x	ENDS
CRT$XCU	SEGMENT
?kdu_pentium_cmov_exists$initializer$@@3P6AXXZA DD FLAT:??__Ekdu_pentium_cmov_exists@@YAXXZ ; kdu_pentium_cmov_exists$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_arch.cpp
;	COMDAT ??__Ekdu_pentium_cmov_exists@@YAXXZ
text$di	SEGMENT
??__Ekdu_pentium_cmov_exists@@YAXXZ PROC		; `dynamic initializer for 'kdu_pentium_cmov_exists'', COMDAT

; 92   :   bool kdu_pentium_cmov_exists = get_cmov_exists();

	call	?get_cmov_exists@@YA_NXZ		; get_cmov_exists
	mov	BYTE PTR ?kdu_pentium_cmov_exists@@3_NA, al ; kdu_pentium_cmov_exists
	ret	0
??__Ekdu_pentium_cmov_exists@@YAXXZ ENDP		; `dynamic initializer for 'kdu_pentium_cmov_exists''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_arch.cpp
;	COMDAT ??__Ekdu_mmx_level@@YAXXZ
text$di	SEGMENT
??__Ekdu_mmx_level@@YAXXZ PROC				; `dynamic initializer for 'kdu_mmx_level'', COMDAT

; 91   :   int kdu_mmx_level = get_mmx_level();

	call	?get_mmx_level@@YAHXZ			; get_mmx_level
	mov	DWORD PTR ?kdu_mmx_level@@3HA, eax	; kdu_mmx_level
	ret	0
??__Ekdu_mmx_level@@YAXXZ ENDP				; `dynamic initializer for 'kdu_mmx_level''
text$di	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_arch.cpp
;	COMDAT ?get_cmov_exists@@YA_NXZ
_TEXT	SEGMENT
_edx_val$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
?get_cmov_exists@@YA_NXZ PROC				; get_cmov_exists, COMDAT

; 97   :     {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?get_cmov_exists@@YA_NXZ
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 98   :       int edx_val=0;

	mov	DWORD PTR _edx_val$[ebp], 0

; 99   :       __try {

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 100  :           __asm {
; 101  :               MOV eax,1

	mov	eax, 1

; 102  :               CPUID

	cpuid

; 103  :               MOV edx_val,EDX

	mov	DWORD PTR _edx_val$[ebp], edx

; 104  :             }
; 105  :         }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH

; 107  :       return ((edx_val & 0x00008000) != 0);

	mov	eax, DWORD PTR _edx_val$[ebp]
	shr	eax, 15					; 0000000fH
	and	eax, 1

; 108  :     }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@get_cmov_e:
$LN10@get_cmov_e:

; 106  :       __except (EXCEPTION_EXECUTE_HANDLER) { return false; }

	mov	eax, 1
$LN9@get_cmov_e:
$LN7@get_cmov_e:
	ret	0
$LN6@get_cmov_e:
	mov	esp, DWORD PTR __$SEHRec$[ebp]
	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	xor	al, al

; 108  :     }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?get_cmov_exists@@YA_NXZ ENDP				; get_cmov_exists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_arch.cpp
;	COMDAT ?get_mmx_level@@YAHXZ
_TEXT	SEGMENT
_ecx_val$ = -32						; size = 4
_edx_val$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
?get_mmx_level@@YAHXZ PROC				; get_mmx_level, COMDAT

; 111  :     {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?get_mmx_level@@YAHXZ
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 112  :       int edx_val=0, ecx_val=0;

	mov	DWORD PTR _edx_val$[ebp], 0
	mov	DWORD PTR _ecx_val$[ebp], 0

; 113  :       __try {

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 114  :           __asm {
; 115  :               MOV eax,1

	mov	eax, 1

; 116  :               CPUID

	cpuid

; 117  :               MOV edx_val,edx

	mov	DWORD PTR _edx_val$[ebp], edx

; 118  :               MOV ecx_val,ecx

	mov	DWORD PTR _ecx_val$[ebp], ecx

; 119  :             }
; 120  :         }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH

; 122  :       int result = 0;

	xor	eax, eax

; 123  :       if (edx_val & 0x00800000)

	mov	ecx, DWORD PTR _edx_val$[ebp]
	test	ecx, 8388608				; 00800000H
	je	SHORT $LN17@get_mmx_le

; 124  :         {
; 125  :           result = 1; // Basic MMX features exist

	mov	eax, 1

; 126  : #ifndef KDU_NO_SSE
; 127  :           if ((edx_val & 0x06000000) == 0x06000000)

	and	ecx, 100663296				; 06000000H
	cmp	ecx, 100663296				; 06000000H
	jne	SHORT $LN17@get_mmx_le

; 128  :             {
; 129  :               result = 2; // SSE and SSE2 features exist

	mov	eax, 2

; 130  :               __try { // Just to be quite certainm, try an SSE2 instruction

	mov	DWORD PTR __$SEHRec$[ebp+20], 1

; 131  :                   __asm xorpd xmm0,xmm0

	xorpd	xmm0, xmm0

; 132  :                 }

	jmp	SHORT $LN20@get_mmx_le
$LN14@get_mmx_le:
$LN21@get_mmx_le:

; 133  :               __except (EXCEPTION_EXECUTE_HANDLER) { result = 1; }

	mov	eax, 1
$LN18@get_mmx_le:
$LN16@get_mmx_le:
	ret	0
$LN15@get_mmx_le:
	mov	esp, DWORD PTR __$SEHRec$[ebp]
	mov	eax, 1
$LN20@get_mmx_le:

; 132  :                 }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN17@get_mmx_le:

; 134  :             }
; 135  : #endif // !KDU_NO_SSE
; 136  :         }
; 137  :       if ((result == 2) && (ecx_val & 1))

	cmp	eax, 2
	jne	SHORT $LN1@get_mmx_le
	mov	ecx, DWORD PTR _ecx_val$[ebp]
	test	cl, 1
	je	SHORT $LN1@get_mmx_le

; 138  :         {
; 139  :           result = 3; // SSE3 support exists

	mov	eax, 3

; 140  :           if (ecx_val & 0x00000200)

	test	ecx, 512				; 00000200H
	mov	ecx, 4
	cmovne	eax, ecx

; 141  :             result = 4; // SSSE3 support exists
; 142  :         }
; 143  :       return result;
; 144  :     }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@get_mmx_le:
$LN22@get_mmx_le:

; 121  :       __except (EXCEPTION_EXECUTE_HANDLER) { return 0; }

	mov	eax, 1
$LN19@get_mmx_le:
$LN12@get_mmx_le:
	ret	0
$LN11@get_mmx_le:
	mov	esp, DWORD PTR __$SEHRec$[ebp]
	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	xor	eax, eax
$LN1@get_mmx_le:

; 141  :             result = 4; // SSSE3 support exists
; 142  :         }
; 143  :       return result;
; 144  :     }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?get_mmx_level@@YAHXZ ENDP				; get_mmx_level
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_arch.cpp
;	COMDAT ?kdu_get_num_processors@@YAHXZ
_TEXT	SEGMENT
_sys_mask$ = -8						; size = 4
_proc_mask$ = -4					; size = 4
?kdu_get_num_processors@@YAHXZ PROC			; kdu_get_num_processors, COMDAT

; 399  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 400  : #if (defined _WIN64)
; 401  :   ULONG_PTR proc_mask=0, sys_mask=0;
; 402  :   if (!GetProcessAffinityMask(GetCurrentProcess(),&proc_mask,&sys_mask))
; 403  :     return 1;
; 404  :   int b, result=0;
; 405  :   for (b=0; b < 64; b++, proc_mask>>=1)
; 406  :     result += (int)(proc_mask & 1);
; 407  :   return (result > 1)?result:1;
; 408  : #elif (defined _WIN32) || (defined WIN32)
; 409  :   DWORD proc_mask=0, sys_mask=0;
; 410  :   if (!GetProcessAffinityMask(GetCurrentProcess(),&proc_mask,&sys_mask))

	lea	eax, DWORD PTR _sys_mask$[ebp]
	mov	DWORD PTR _proc_mask$[ebp], 0
	push	eax
	lea	eax, DWORD PTR _proc_mask$[ebp]
	mov	DWORD PTR _sys_mask$[ebp], 0
	push	eax
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__GetProcessAffinityMask@12
	test	eax, eax
	jne	SHORT $LN5@kdu_get_nu

; 411  :     return 1;

	mov	eax, 1

; 416  : #elif defined _SC_NPROCESSORS_ONLN
; 417  :   return (int) sysconf(_SC_NPROCESSORS_ONLN);
; 418  : #elif defined _SC_NPROCESSORS_CONF
; 419  :   return (int) sysconf(_SC_NPROCESSORS_CONF);
; 420  : #elif (defined __APPLE__)
; 421  :   int result = 0;
; 422  :   size_t result_size = sizeof(result);
; 423  :   if (sysctlbyname("hw.ncpu",&result,&result_size,NULL,0) != 0)
; 424  :     result = 0;
; 425  :   return result;
; 426  : #else
; 427  :   return 0;
; 428  : #endif
; 429  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@kdu_get_nu:

; 412  :   int b, result=0;

	mov	ecx, DWORD PTR _proc_mask$[ebp]
	xor	edx, edx
	push	esi
	push	edi
	xor	esi, esi
	lea	edi, DWORD PTR [edx+16]
$LL4@kdu_get_nu:

; 413  :   for (b=0; b < 32; b++, proc_mask>>=1)
; 414  :     result += (int)(proc_mask & 1);

	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	add	edx, eax
	mov	eax, ecx
	and	eax, 1
	shr	ecx, 1
	add	esi, eax
	sub	edi, 1
	jne	SHORT $LL4@kdu_get_nu

; 415  :   return (result > 1)?result:1;

	add	edx, esi
	mov	eax, 1
	cmp	edx, eax
	pop	edi
	cmovg	eax, edx
	pop	esi

; 416  : #elif defined _SC_NPROCESSORS_ONLN
; 417  :   return (int) sysconf(_SC_NPROCESSORS_ONLN);
; 418  : #elif defined _SC_NPROCESSORS_CONF
; 419  :   return (int) sysconf(_SC_NPROCESSORS_CONF);
; 420  : #elif (defined __APPLE__)
; 421  :   int result = 0;
; 422  :   size_t result_size = sizeof(result);
; 423  :   if (sysctlbyname("hw.ncpu",&result,&result_size,NULL,0) != 0)
; 424  :     result = 0;
; 425  :   return result;
; 426  : #else
; 427  :   return 0;
; 428  : #endif
; 429  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?kdu_get_num_processors@@YAHXZ ENDP			; kdu_get_num_processors
_TEXT	ENDS
END
