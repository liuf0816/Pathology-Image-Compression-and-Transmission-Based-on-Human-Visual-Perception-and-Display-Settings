; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\compressed\codestream.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	??6kdu_message@@QAEAAV0@H@Z			; kdu_message::operator<<
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	??1kdu_output@@UAE@XZ				; kdu_output::~kdu_output
PUBLIC	?put@kdu_output@@QAEHG@Z			; kdu_output::put
PUBLIC	?put@kdu_output@@QAEHI@Z			; kdu_output::put
PUBLIC	?write@kdu_output@@QAEXPAEH@Z			; kdu_output::write
PUBLIC	??_Gkdu_output@@UAEPAXI@Z			; kdu_output::`scalar deleting destructor'
PUBLIC	??1siz_params@@UAE@XZ				; siz_params::~siz_params
PUBLIC	??0kdu_kernel_step_info@@QAE@XZ			; kdu_kernel_step_info::kdu_kernel_step_info
PUBLIC	??1kdu_kernels@@QAE@XZ				; kdu_kernels::~kdu_kernels
PUBLIC	??1kdu_thread_entity@@UAE@XZ			; kdu_thread_entity::~kdu_thread_entity
PUBLIC	?new_instance@kdu_thread_entity@@UAEPAV1@XZ	; kdu_thread_entity::new_instance
PUBLIC	?get_num_locks@kdu_thread_entity@@UAEHXZ	; kdu_thread_entity::get_num_locks
PUBLIC	?do_sync@kdu_thread_entity@@MAEX_N@Z		; kdu_thread_entity::do_sync
PUBLIC	?need_sync@kdu_thread_entity@@MAE_NXZ		; kdu_thread_entity::need_sync
PUBLIC	?on_finished@kdu_thread_entity@@MAEX_N@Z	; kdu_thread_entity::on_finished
PUBLIC	??_Gkdu_thread_entity@@UAEPAXI@Z		; kdu_thread_entity::`scalar deleting destructor'
PUBLIC	?kdu_get_core_version@@YAPBDXZ			; kdu_get_core_version
PUBLIC	?to_apparent@kdu_coords@@QAEX_N00@Z		; kdu_coords::to_apparent
PUBLIC	??_4kdu_dims@@QAE?AU0@AAU0@@Z			; kdu_dims::operator&=
PUBLIC	?intersects@kdu_dims@@QAE_NAAU1@@Z		; kdu_dims::intersects
PUBLIC	?get_text@kdu_codestream_comment@@QAEPBDXZ	; kdu_codestream_comment::get_text
PUBLIC	?check_readonly@kdu_codestream_comment@@QAE_NXZ	; kdu_codestream_comment::check_readonly
PUBLIC	?put_text@kdu_codestream_comment@@QAE_NPBD@Z	; kdu_codestream_comment::put_text
PUBLIC	?create@kdu_codestream@@QAEXPAVsiz_params@@PAVkdu_compressed_target@@PAUkdu_dims@@H_J@Z ; kdu_codestream::create
PUBLIC	?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z ; kdu_codestream::create
PUBLIC	?create@kdu_codestream@@QAEXPAVsiz_params@@@Z	; kdu_codestream::create
PUBLIC	?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z ; kdu_codestream::restart
PUBLIC	?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z ; kdu_codestream::restart
PUBLIC	?share_buffering@kdu_codestream@@QAEXV1@@Z	; kdu_codestream::share_buffering
PUBLIC	?destroy@kdu_codestream@@QAEXXZ			; kdu_codestream::destroy
PUBLIC	?enable_restart@kdu_codestream@@QAEXXZ		; kdu_codestream::enable_restart
PUBLIC	?set_persistent@kdu_codestream@@QAEXXZ		; kdu_codestream::set_persistent
PUBLIC	?augment_cache_threshold@kdu_codestream@@QAE_JH@Z ; kdu_codestream::augment_cache_threshold
PUBLIC	?set_tile_unloading_threshold@kdu_codestream@@QAEHH@Z ; kdu_codestream::set_tile_unloading_threshold
PUBLIC	?is_last_fragment@kdu_codestream@@QAE_NXZ	; kdu_codestream::is_last_fragment
PUBLIC	?access_siz@kdu_codestream@@QAEPAVsiz_params@@XZ ; kdu_codestream::access_siz
PUBLIC	?get_num_components@kdu_codestream@@QAEH_N@Z	; kdu_codestream::get_num_components
PUBLIC	?get_bit_depth@kdu_codestream@@QAEHH_N@Z	; kdu_codestream::get_bit_depth
PUBLIC	?get_signed@kdu_codestream@@QAE_NH_N@Z		; kdu_codestream::get_signed
PUBLIC	?get_subsampling@kdu_codestream@@QAEXHAAUkdu_coords@@_N@Z ; kdu_codestream::get_subsampling
PUBLIC	?get_registration@kdu_codestream@@QAEXHUkdu_coords@@AAU2@_N@Z ; kdu_codestream::get_registration
PUBLIC	?get_dims@kdu_codestream@@QAEXHAAUkdu_dims@@_N@Z ; kdu_codestream::get_dims
PUBLIC	?get_tile_partition@kdu_codestream@@QAEXAAUkdu_dims@@@Z ; kdu_codestream::get_tile_partition
PUBLIC	?get_valid_tiles@kdu_codestream@@QAEXAAUkdu_dims@@@Z ; kdu_codestream::get_valid_tiles
PUBLIC	?find_tile@kdu_codestream@@QAE_NHUkdu_coords@@AAU2@_N@Z ; kdu_codestream::find_tile
PUBLIC	?get_tile_dims@kdu_codestream@@QAEXUkdu_coords@@HAAUkdu_dims@@_N@Z ; kdu_codestream::get_tile_dims
PUBLIC	?get_max_tile_layers@kdu_codestream@@QAEHXZ	; kdu_codestream::get_max_tile_layers
PUBLIC	?get_min_dwt_levels@kdu_codestream@@QAEHXZ	; kdu_codestream::get_min_dwt_levels
PUBLIC	?can_flip@kdu_codestream@@QAE_N_N@Z		; kdu_codestream::can_flip
PUBLIC	?map_region@kdu_codestream@@QAEXHUkdu_dims@@AAU2@_N@Z ; kdu_codestream::map_region
PUBLIC	?set_textualization@kdu_codestream@@QAEXPAVkdu_message@@@Z ; kdu_codestream::set_textualization
PUBLIC	?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z	; kdu_codestream::set_max_bytes
PUBLIC	?set_min_slope_threshold@kdu_codestream@@QAEXG@Z ; kdu_codestream::set_min_slope_threshold
PUBLIC	?set_resilient@kdu_codestream@@QAEX_N@Z		; kdu_codestream::set_resilient
PUBLIC	?set_fussy@kdu_codestream@@QAEXXZ		; kdu_codestream::set_fussy
PUBLIC	?set_fast@kdu_codestream@@QAEXXZ		; kdu_codestream::set_fast
PUBLIC	?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z ; kdu_codestream::apply_input_restrictions
PUBLIC	?apply_input_restrictions@kdu_codestream@@QAEXHPAHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z ; kdu_codestream::apply_input_restrictions
PUBLIC	?change_appearance@kdu_codestream@@QAEX_N00@Z	; kdu_codestream::change_appearance
PUBLIC	?set_block_truncation@kdu_codestream@@QAEXH@Z	; kdu_codestream::set_block_truncation
PUBLIC	?open_tile@kdu_codestream@@QAE?AVkdu_tile@@Ukdu_coords@@PAVkdu_thread_env@@@Z ; kdu_codestream::open_tile
PUBLIC	?get_comment@kdu_codestream@@QAE?AVkdu_codestream_comment@@V2@@Z ; kdu_codestream::get_comment
PUBLIC	?add_comment@kdu_codestream@@QAE?AVkdu_codestream_comment@@XZ ; kdu_codestream::add_comment
PUBLIC	?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z ; kdu_codestream::flush
PUBLIC	?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z ; kdu_codestream::trans_out
PUBLIC	?ready_for_flush@kdu_codestream@@QAE_NPAVkdu_thread_env@@@Z ; kdu_codestream::ready_for_flush
PUBLIC	?get_total_bytes@kdu_codestream@@QAE_J_N@Z	; kdu_codestream::get_total_bytes
PUBLIC	?get_num_tparts@kdu_codestream@@QAEHXZ		; kdu_codestream::get_num_tparts
PUBLIC	?collect_timing_stats@kdu_codestream@@QAEXH@Z	; kdu_codestream::collect_timing_stats
PUBLIC	?get_timing_stats@kdu_codestream@@QAENPA_J_N@Z	; kdu_codestream::get_timing_stats
PUBLIC	?get_compressed_data_memory@kdu_codestream@@QAE_J_N@Z ; kdu_codestream::get_compressed_data_memory
PUBLIC	?get_compressed_state_memory@kdu_codestream@@QAE_J_N@Z ; kdu_codestream::get_compressed_state_memory
PUBLIC	??0kdu_thread_env@@QAE@XZ			; kdu_thread_env::kdu_thread_env
PUBLIC	??1kdu_thread_env@@UAE@XZ			; kdu_thread_env::~kdu_thread_env
PUBLIC	?new_instance@kdu_thread_env@@UAEPAVkdu_thread_entity@@XZ ; kdu_thread_env::new_instance
PUBLIC	?get_num_locks@kdu_thread_env@@UAEHXZ		; kdu_thread_env::get_num_locks
PUBLIC	?need_sync@kdu_thread_env@@MAE_NXZ		; kdu_thread_env::need_sync
PUBLIC	?do_sync@kdu_thread_env@@MAEX_N@Z		; kdu_thread_env::do_sync
PUBLIC	?on_finished@kdu_thread_env@@MAEX_N@Z		; kdu_thread_env::on_finished
PUBLIC	??_Ekdu_thread_env@@UAEPAXI@Z			; kdu_thread_env::`vector deleting destructor'
PUBLIC	?print_marker_code@@YAXGAAVkdu_message@@@Z	; print_marker_code
PUBLIC	??1kd_buf_server@@QAE@XZ			; kd_buf_server::~kd_buf_server
PUBLIC	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ	; kd_buf_server::get
PUBLIC	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
PUBLIC	?get_page_block@kd_buf_server@@QAEPAUkd_code_buffer@@HAAPAU2@@Z ; kd_buf_server::get_page_block
PUBLIC	?attach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z ; kd_buf_server::attach_thread_buf_server
PUBLIC	?detach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z ; kd_buf_server::detach_thread_buf_server
PUBLIC	?alloc_pages@kd_buf_server@@AAEXXZ		; kd_buf_server::alloc_pages
PUBLIC	?set_codestream_buf_server@kd_thread_buf_server@@QAEXPAVkd_buf_server@@@Z ; kd_thread_buf_server::set_codestream_buf_server
PUBLIC	?adjust_peak_buffers@kd_thread_buf_server@@QAEXXZ ; kd_thread_buf_server::adjust_peak_buffers
PUBLIC	?augment_local_store@kd_thread_buf_server@@QAEX_N@Z ; kd_thread_buf_server::augment_local_store
PUBLIC	??1kd_compressed_output@@UAE@XZ			; kd_compressed_output::~kd_compressed_output
PUBLIC	?flush_buf@kd_compressed_output@@MAEXXZ		; kd_compressed_output::flush_buf
PUBLIC	??_Gkd_compressed_output@@UAEPAXI@Z		; kd_compressed_output::`scalar deleting destructor'
PUBLIC	??1kd_input@@UAE@XZ				; kd_input::~kd_input
PUBLIC	?get@kd_input@@QAE_NAAE@Z			; kd_input::get
PUBLIC	?read@kd_input@@QAEHPAEH@Z			; kd_input::read
PUBLIC	?read@kd_input@@QAEHAAPAUkd_code_buffer@@AAEPAVkd_buf_server@@H@Z ; kd_input::read
PUBLIC	?ignore@kd_input@@UAE_J_J@Z			; kd_input::ignore
PUBLIC	?process_unexpected_marker@kd_input@@AAEXE@Z	; kd_input::process_unexpected_marker
PUBLIC	??_Gkd_input@@UAEPAXI@Z				; kd_input::`scalar deleting destructor'
PUBLIC	??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z ; kd_compressed_input::kd_compressed_input
PUBLIC	?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z ; kd_compressed_input::set_tileheader_scope
PUBLIC	?seek@kd_compressed_input@@QAEX_J@Z		; kd_compressed_input::seek
PUBLIC	?ignore@kd_compressed_input@@UAE_J_J@Z		; kd_compressed_input::ignore
PUBLIC	?set_max_bytes@kd_compressed_input@@QAEX_J@Z	; kd_compressed_input::set_max_bytes
PUBLIC	?get_bytes_read@kd_compressed_input@@QAE_JXZ	; kd_compressed_input::get_bytes_read
PUBLIC	?get_suspended_bytes@kd_compressed_input@@QAE_JXZ ; kd_compressed_input::get_suspended_bytes
PUBLIC	?load_buf@kd_compressed_input@@MAE_NXZ		; kd_compressed_input::load_buf
PUBLIC	??_Gkd_compressed_input@@UAEPAXI@Z		; kd_compressed_input::`scalar deleting destructor'
PUBLIC	??1kd_pph_input@@UAE@XZ				; kd_pph_input::~kd_pph_input
PUBLIC	?add_bytes@kd_pph_input@@QAEXPAEH@Z		; kd_pph_input::add_bytes
PUBLIC	?load_buf@kd_pph_input@@MAE_NXZ			; kd_pph_input::load_buf
PUBLIC	??_Gkd_pph_input@@UAEPAXI@Z			; kd_pph_input::`scalar deleting destructor'
PUBLIC	??0kd_marker@@QAE@ABV0@@Z			; kd_marker::kd_marker
PUBLIC	?read@kd_marker@@QAE_N_N0@Z			; kd_marker::read
PUBLIC	??1kd_pp_markers@@QAE@XZ			; kd_pp_markers::~kd_pp_markers
PUBLIC	?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z	; kd_pp_markers::add_marker
PUBLIC	?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z ; kd_pp_markers::transfer_tpart
PUBLIC	?ignore_tpart@kd_pp_markers@@QAEXXZ		; kd_pp_markers::ignore_tpart
PUBLIC	?advance_list@kd_pp_markers@@AAEXXZ		; kd_pp_markers::advance_list
PUBLIC	?init@kd_tlm_generator@@QAE_NHH@Z		; kd_tlm_generator::init
PUBLIC	?write_dummy_tlms@kd_tlm_generator@@QAEXPAVkd_compressed_output@@@Z ; kd_tlm_generator::write_dummy_tlms
PUBLIC	?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z	; kd_tlm_generator::add_tpart_length
PUBLIC	?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z ; kd_tlm_generator::write_tlms
PUBLIC	??1kd_tpart_pointer_server@@QAE@XZ		; kd_tpart_pointer_server::~kd_tpart_pointer_server
PUBLIC	?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z ; kd_tpart_pointer_server::add_tlm_marker
PUBLIC	?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z ; kd_tpart_pointer_server::translate_markers
PUBLIC	?add_tpart@kd_tpart_pointer_server@@QAEXPAUkd_tile_ref@@_J@Z ; kd_tpart_pointer_server::add_tpart
PUBLIC	?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z ; kd_precinct_pointer_server::add_plt_marker
PUBLIC	?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z ; kd_precinct_pointer_server::start_tpart_body
PUBLIC	?pop_address@kd_precinct_pointer_server@@AAE_JXZ ; kd_precinct_pointer_server::pop_address
PUBLIC	?disable@kd_precinct_pointer_server@@AAEXXZ	; kd_precinct_pointer_server::disable
PUBLIC	??0kd_compressed_stats@@QAE@_J0_N@Z		; kd_compressed_stats::kd_compressed_stats
PUBLIC	?init@kd_compressed_stats@@QAEXXZ		; kd_compressed_stats::init
PUBLIC	?update_stats@kd_compressed_stats@@QAE_NAAV1@@Z	; kd_compressed_stats::update_stats
PUBLIC	?update_quant_slope_thresholds@kd_compressed_stats@@QAEXXZ ; kd_compressed_stats::update_quant_slope_thresholds
PUBLIC	??0kd_codestream_comment@@QAE@XZ		; kd_codestream_comment::kd_codestream_comment
PUBLIC	?set_text@kd_codestream_comment@@QAEXHPAE@Z	; kd_codestream_comment::set_text
PUBLIC	?write_marker@kd_codestream_comment@@QAEHPAVkdu_output@@H@Z ; kd_codestream_comment::write_marker
PUBLIC	?init@kd_packet_sequencer@@QAEXXZ		; kd_packet_sequencer::init
PUBLIC	?save_state@kd_packet_sequencer@@QAEXXZ		; kd_packet_sequencer::save_state
PUBLIC	?restore_state@kd_packet_sequencer@@QAEXXZ	; kd_packet_sequencer::restore_state
PUBLIC	?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_sequence
PUBLIC	?next_progression@kd_packet_sequencer@@AAE_NXZ	; kd_packet_sequencer::next_progression
PUBLIC	?next_in_lrcp@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_lrcp
PUBLIC	?next_in_rlcp@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_rlcp
PUBLIC	?next_in_rpcl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_rpcl
PUBLIC	?next_in_pcrl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_pcrl
PUBLIC	?next_in_cprl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_cprl
PUBLIC	??0kd_reslength_checker@@QAE@XZ			; kd_reslength_checker::kd_reslength_checker
PUBLIC	??1kd_reslength_checker@@QAE@XZ			; kd_reslength_checker::~kd_reslength_checker
PUBLIC	?init@kd_reslength_checker@@QAE_NPAVcod_params@@@Z ; kd_reslength_checker::init
PUBLIC	?set_layer@kd_reslength_checker@@QAEXH@Z	; kd_reslength_checker::set_layer
PUBLIC	?check_packet@kd_reslength_checker@@QAE_N_JH@Z	; kd_reslength_checker::check_packet
PUBLIC	??_Ekd_reslength_checker@@QAEPAXI@Z		; kd_reslength_checker::`vector deleting destructor'
PUBLIC	??0kd_global_rescomp@@QAE@XZ			; kd_global_rescomp::kd_global_rescomp
PUBLIC	??1kd_global_rescomp@@QAE@XZ			; kd_global_rescomp::~kd_global_rescomp
PUBLIC	?close_all@kd_global_rescomp@@QAEXXZ		; kd_global_rescomp::close_all
PUBLIC	?initialize@kd_global_rescomp@@QAEXPAUkd_codestream@@HH@Z ; kd_global_rescomp::initialize
PUBLIC	?notify_tile_status@kd_global_rescomp@@QAEXUkdu_dims@@_N@Z ; kd_global_rescomp::notify_tile_status
PUBLIC	?add_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z ; kd_global_rescomp::add_ready_precinct
PUBLIC	?close_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z ; kd_global_rescomp::close_ready_precinct
PUBLIC	??_Ekd_global_rescomp@@QAEPAXI@Z		; kd_global_rescomp::`vector deleting destructor'
PUBLIC	??0kd_comp_info@@QAE@XZ				; kd_comp_info::kd_comp_info
PUBLIC	??0kd_output_comp_info@@QAE@XZ			; kd_output_comp_info::kd_output_comp_info
PUBLIC	??0kd_mct_ss_model@@QAE@XZ			; kd_mct_ss_model::kd_mct_ss_model
PUBLIC	??1kd_mct_ss_model@@QAE@XZ			; kd_mct_ss_model::~kd_mct_ss_model
PUBLIC	??_Ekd_mct_ss_model@@QAEPAXI@Z			; kd_mct_ss_model::`vector deleting destructor'
PUBLIC	??0kd_mct_block@@QAE@XZ				; kd_mct_block::kd_mct_block
PUBLIC	??1kd_mct_block@@QAE@XZ				; kd_mct_block::~kd_mct_block
PUBLIC	?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z ; kd_mct_block::analyze_sensitivity
PUBLIC	?create_matrix_ss_model@kd_mct_block@@AAEXXZ	; kd_mct_block::create_matrix_ss_model
PUBLIC	?create_rxform_ss_model@kd_mct_block@@AAEXXZ	; kd_mct_block::create_rxform_ss_model
PUBLIC	?create_old_rxform_ss_model@kd_mct_block@@AAEXXZ ; kd_mct_block::create_old_rxform_ss_model
PUBLIC	?create_dependency_ss_model@kd_mct_block@@AAEXXZ ; kd_mct_block::create_dependency_ss_model
PUBLIC	?create_dwt_ss_model@kd_mct_block@@AAEXXZ	; kd_mct_block::create_dwt_ss_model
PUBLIC	??_Ekd_mct_block@@QAEPAXI@Z			; kd_mct_block::`vector deleting destructor'
PUBLIC	?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z ; kd_mct_stage::create_stages
PUBLIC	?apply_output_restrictions@kd_mct_stage@@QAEXPAUkd_output_comp_info@@HPBH@Z ; kd_mct_stage::apply_output_restrictions
PUBLIC	??0kd_codestream@@QAE@XZ			; kd_codestream::kd_codestream
PUBLIC	??1kd_codestream@@QAE@XZ			; kd_codestream::~kd_codestream
PUBLIC	?construct_common@kd_codestream@@QAEXXZ		; kd_codestream::construct_common
PUBLIC	?construct_output_comp_info@kd_codestream@@QAEXXZ ; kd_codestream::construct_output_comp_info
PUBLIC	?finalize_construction@kd_codestream@@QAEXXZ	; kd_codestream::finalize_construction
PUBLIC	?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z ; kd_codestream::restrict_to_fragment
PUBLIC	?restart@kd_codestream@@QAEXXZ			; kd_codestream::restart
PUBLIC	?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z ; kd_codestream::create_tile
PUBLIC	?trim_compressed_data@kd_codestream@@QAEXXZ	; kd_codestream::trim_compressed_data
PUBLIC	?calculate_min_header_cost@kd_codestream@@QAEXXZ ; kd_codestream::calculate_min_header_cost
PUBLIC	?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z ; kd_codestream::simulate_output
PUBLIC	?pcrd_opt@kd_codestream@@QAEX_NN@Z		; kd_codestream::pcrd_opt
PUBLIC	?generate_codestream@kd_codestream@@QAE_NH@Z	; kd_codestream::generate_codestream
PUBLIC	?set_reserved_layer_info_bytes@kd_codestream@@QAEXH@Z ; kd_codestream::set_reserved_layer_info_bytes
PUBLIC	?gen_layer_info_comment@kd_codestream@@QAEXHPA_JPAG@Z ; kd_codestream::gen_layer_info_comment
PUBLIC	?unload_tiles_to_cache_threshold@kd_codestream@@QAEXXZ ; kd_codestream::unload_tiles_to_cache_threshold
PUBLIC	?read_main_header@kd_codestream@@AAEXXZ		; kd_codestream::read_main_header
PUBLIC	?freeze_comments@kd_codestream@@AAEXXZ		; kd_codestream::freeze_comments
PUBLIC	?release@kd_precinct@@QAEXXZ			; kd_precinct::release
PUBLIC	??1kd_precinct_server@@QAE@XZ			; kd_precinct_server::~kd_precinct_server
PUBLIC	??0kd_thread_env@@QAE@PAVkdu_thread_env@@@Z	; kd_thread_env::kd_thread_env
PUBLIC	?reconcile_stats@kd_thread_env@@QAEXXZ		; kd_thread_env::reconcile_stats
PUBLIC	?flush@kd_thread_env@@QAEX_N@Z			; kd_thread_env::flush
PUBLIC	?discard_all@kd_thread_env@@QAEXXZ		; kd_thread_env::discard_all
PUBLIC	?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z ; kd_create_dwt_description
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu?$AA@			; `string'
PUBLIC	??_7kdu_output@@6B@				; kdu_output::`vftable'
PUBLIC	??_7kdu_thread_entity@@6B@			; kdu_thread_entity::`vftable'
PUBLIC	__TI1H
PUBLIC	__CTA1H
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
PUBLIC	__CT??_R0H@84
PUBLIC	??_7kdu_thread_env@@6B@				; kdu_thread_env::`vftable'
PUBLIC	??_7kd_compressed_output@@6B@			; kd_compressed_output::`vftable'
PUBLIC	??_7kd_input@@6B@				; kd_input::`vftable'
PUBLIC	??_7kd_compressed_input@@6B@			; kd_compressed_input::`vftable'
PUBLIC	??_7kd_pph_input@@6B@				; kd_pph_input::`vftable'
PUBLIC	??_C@_04GOIBNGKI@v6?41?$AA@			; `string'
PUBLIC	??_C@_03IFCLAPBJ@ATK?$AA@			; `string'
PUBLIC	??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@	; `string'
PUBLIC	??_C@_0FL@HPBHAILG@Unable?5to?5find?5ATK?5marker?5segmen@ ; `string'
PUBLIC	??_C@_0L@BNGLHLNI@Ksymmetric?$AA@		; `string'
PUBLIC	??_C@_0L@JOGHAEOB@Kextension?$AA@		; `string'
PUBLIC	??_C@_0M@OFOCCDJH@Kreversible?$AA@		; `string'
PUBLIC	??_C@_06PJGAHNDG@Ksteps?$AA@			; `string'
PUBLIC	??_C@_0GE@PPANCHNM@Custom?5DWT?5kernel?5found?5in?5ATK?5m@ ; `string'
PUBLIC	??_C@_07KKABNIJP@Kcoeffs?$AA@			; `string'
PUBLIC	??_C@_03KHJBFGJE@SOC?$AA@			; `string'
PUBLIC	??_C@_03KCBCNCAC@SOT?$AA@			; `string'
PUBLIC	??_C@_03OINAMAFD@SOD?$AA@			; `string'
PUBLIC	??_C@_03MGHOBHAG@SOP?$AA@			; `string'
PUBLIC	??_C@_03CGGNGDFB@EPH?$AA@			; `string'
PUBLIC	??_C@_03NCODFONH@EOC?$AA@			; `string'
PUBLIC	??_C@_03DIBMIDDO@SIZ?$AA@			; `string'
PUBLIC	??_C@_03LABBAEJP@CBD?$AA@			; `string'
PUBLIC	??_C@_03BLMOALMK@MCT?$AA@			; `string'
PUBLIC	??_C@_03BOENIPFM@MCC?$AA@			; `string'
PUBLIC	??_C@_03LCPIMAFA@MCO?$AA@			; `string'
PUBLIC	??_C@_03LIMJJHMM@COD?$AA@			; `string'
PUBLIC	??_C@_03PHIIABAL@COC?$AA@			; `string'
PUBLIC	??_C@_03BLBGDEDA@ADS?$AA@			; `string'
PUBLIC	??_C@_03CPEMBAGM@DFS?$AA@			; `string'
PUBLIC	??_C@_03ELMDPBLM@QCD?$AA@			; `string'
PUBLIC	??_C@_03EICGHHL@QCC?$AA@			; `string'
PUBLIC	??_C@_03KEJABOAE@RGN?$AA@			; `string'
PUBLIC	??_C@_03LFCEPJHK@POC?$AA@			; `string'
PUBLIC	??_C@_03IHBKPECM@CRG?$AA@			; `string'
PUBLIC	??_C@_03GJALCMIF@COM?$AA@			; `string'
PUBLIC	??_C@_03KGIDPNPK@TLM?$AA@			; `string'
PUBLIC	??_C@_03CJOBGKKN@PLM?$AA@			; `string'
PUBLIC	??_C@_03LCOBMDLF@PLT?$AA@			; `string'
PUBLIC	??_C@_03DMNNDALJ@PPM?$AA@			; `string'
PUBLIC	??_C@_03KHNNJJKB@PPT?$AA@			; `string'
PUBLIC	??_C@_02MDDDDAID@0x?$AA@			; `string'
PUBLIC	??_C@_01MNNFJEPP@?$DM?$AA@			; `string'
PUBLIC	??_C@_01PPODPGHN@?$DO?$AA@			; `string'
PUBLIC	__TI1G
PUBLIC	__CTA1G
PUBLIC	??_R0G@8					; unsigned short `RTTI Type Descriptor'
PUBLIC	__CT??_R0G@82
PUBLIC	??_C@_0LF@DMBAEAHP@Attempting?5to?5load?5cached?5tile?5h@ ; `string'
PUBLIC	??_C@_0LF@EOEFHEHA@Attempting?5to?5load?5cached?5precin@ ; `string'
PUBLIC	??_C@_0JA@OOKKCCPN@Attempting?5to?5seek?5inside?5a?5comp@ ; `string'
PUBLIC	??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@FKDCCKNG@Skipping?5over?5corrupt?5SOP?5marker@ ; `string'
PUBLIC	??_C@_0CH@NAEOEPLF@Skipping?5over?5corrupt?5SOT?5marker@ ; `string'
PUBLIC	??_C@_0CG@FBIDHMHH@Disregarding?5non?9terminal?5EOC?5ma@ ; `string'
PUBLIC	??_C@_0FO@JCNPOBGN@Encountered?5one?5or?5more?5marker?5c@ ; `string'
PUBLIC	??_C@_0CJ@GCHDIIBC@Unrecognized?1unimplemented?5marke@ ; `string'
PUBLIC	??_C@_0BI@PDKABIHP@?0?5found?5in?5code?9stream?4?$AA@ ; `string'
PUBLIC	??_C@_0DH@CINALLDE@PPM?1PPT?5marker?5segments?5must?5be?5@ ; `string'
PUBLIC	??_C@_0IB@IHNJIGBG@Found?5multiple?5PPM?1PPT?5marker?5se@ ; `string'
PUBLIC	??_C@_0DI@CKEFAKFB@Insufficient?5packet?5header?5data?5@ ; `string'
PUBLIC	??_C@_0KG@EMHBDNCD@Encountered?5malformed?5PPM?5marker@ ; `string'
PUBLIC	??_C@_0FP@BOACKPIA@Insufficient?5packet?5header?5data?5@ ; `string'
PUBLIC	??_C@_0IA@FPINHJNP@Attempting?5to?5write?5TLM?5?$CItile?9pa@ ; `string'
PUBLIC	??_C@_0HO@CCHNKHBP@Attempting?5to?5invoke?5?$GAkd_tlm_gen@ ; `string'
PUBLIC	??_C@_0DD@NPPLBJLB@TLM?5marker?5segments?5must?5be?5at?5l@ ; `string'
PUBLIC	??_C@_0FH@FGOHBFDA@Found?5multiple?5TLM?5marker?5segmen@ ; `string'
PUBLIC	??_C@_0DG@MNLOLHMH@Illegal?5Stlm?5field?5encountered?5i@ ; `string'
PUBLIC	??_C@_0KF@DLMNKMGF@Malformed?5TLM?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0BAC@JCJFPLLE@Illegal?5TLM?5marker?5segment?5data?5@ ; `string'
PUBLIC	??_C@_0IA@MHJOOLGJ@TLM?5marker?5segments?5contain?5one?5@ ; `string'
PUBLIC	??_C@_0BDH@HFCLMIKM@PLT?5marker?5segments?5appear?5out?5o@ ; `string'
PUBLIC	??_C@_0BFL@CANGKIAI@There?5appears?5to?5be?5a?5problem?5wi@ ; `string'
PUBLIC	??_C@_07BJCMAMHC@Clayers?$AA@			; `string'
PUBLIC	??_C@_06IKJBDDKO@Corder?$AA@			; `string'
PUBLIC	??_C@_06NMKHLFPN@Porder?$AA@			; `string'
PUBLIC	??_C@_0BAD@EAIFLCLN@Unexpected?5change?5in?5coding?5para@ ; `string'
PUBLIC	??_C@_0JE@NAFKBLL@Malformed?5PLT?5marker?5segment?5enc@ ; `string'
PUBLIC	??_C@_0BAD@MAAGNDO@Unexpected?5change?5in?5coding?5para@ ; `string'
PUBLIC	??_C@_0BBI@KLDFJIGH@Unexpectedly?5ran?5out?5of?5packet?5l@ ; `string'
PUBLIC	??_C@_0CCA@PJBKNCFI@Tile?9part?5holds?5some?5but?5not?5all@ ; `string'
PUBLIC	??_C@_0CFK@EADCMAPD@You?5have?5invoked?5?$GAkdu_codestream@ ; `string'
PUBLIC	??_C@_0LL@CAMCHDPO@The?5compressed?5data?5buffer?5serve@ ; `string'
PUBLIC	??_C@_0OO@EOPDAIEN@The?5compressed?5data?5buffer?5serve@ ; `string'
PUBLIC	??_C@_0DA@BOBLKNCL@Supplied?5progression?5order?5attri@ ; `string'
PUBLIC	??_C@_0DD@EDBDEPHJ@?5are?5insuffient?5to?5cover?5all?5pac@ ; `string'
PUBLIC	??_C@_0BCG@LKLOKBKN@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0LN@NLKIMLNE@Attempting?5to?5use?5a?5spatially?5pr@ ; `string'
PUBLIC	??_C@_0M@HKNEBDCB@Creslengths?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0OO@PCLKLFBK@Call?5to?5?$GAkdu_codestream_comment?3@ ; `string'
PUBLIC	??_C@_0M@BMJAMMCN@Mnum_stages?$AA@		; `string'
PUBLIC	??_C@_04OOAAMMCO@Cmct?$AA@			; `string'
PUBLIC	??_C@_07CNNLMAHC@Mstages?$AA@			; `string'
PUBLIC	??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@	; `string'
PUBLIC	??_C@_0CL@PILHNAFH@Unable?5to?5access?5the?5description@ ; `string'
PUBLIC	??_C@_0PF@HDJMLNFB@?5?$CIstarting?5from?50?$CJ?5in?5the?5multi?9@ ; `string'
PUBLIC	??_C@_0JM@EMODBKHC@Multi?9component?5transform?5blocks@ ; `string'
PUBLIC	??_C@_0KO@EOEMFLGL@Multi?9component?5transform?5block?5@ ; `string'
PUBLIC	??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@		; `string'
PUBLIC	??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@		; `string'
PUBLIC	??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@		; `string'
PUBLIC	??_C@_0N@EBBFOCKJ@Mvector_size?$AA@		; `string'
PUBLIC	??_C@_0KO@HEFENJF@Unable?5to?5access?5the?5offset?5para@ ; `string'
PUBLIC	??_C@_0M@KNDNPDMI@?5and?5value?5?$AA@		; `string'
PUBLIC	??_C@_0HA@CPLCDADH@?0?5corresponding?5to?5the?5number?5of@ ; `string'
PUBLIC	??_C@_0PM@HMICKPCP@Except?5for?5irreversible?5matrix?9b@ ; `string'
PUBLIC	??_C@_0N@FIDBGNAL@Mmatrix_size?$AA@		; `string'
PUBLIC	??_C@_0KO@JDHHKMLN@Unable?5to?5access?5the?5matrix?5para@ ; `string'
PUBLIC	??_C@_0BBM@IKPPNJIM@?0?5corresponding?5to?5the?5total?5num@ ; `string'
PUBLIC	??_C@_0N@CCNKIJHO@Mtriang_size?$AA@		; `string'
PUBLIC	??_C@_0KO@HBMKDEMJ@Unable?5to?5access?5the?5matrix?5para@ ; `string'
PUBLIC	??_C@_0BIH@NMGBAOPH@?0?5corresponding?5to?5the?5total?5num@ ; `string'
PUBLIC	??_C@_0JG@ECJLCCBG@Multi?9component?5transform?5stage?5@ ; `string'
PUBLIC	??_C@_0IM@HJCMNLOE@Multi?9component?5transform?5stage?5@ ; `string'
PUBLIC	??_C@_0BBI@DKKKDOEN@Multi?9component?5transform?5does?5n@ ; `string'
PUBLIC	??_C@_0KL@GPKLLFMI@The?5last?5stage?5of?5the?5multi?9comp@ ; `string'
PUBLIC	??_C@_0BHN@CGGDHAAL@Although?5not?5strictly?5illegal?0?5t@ ; `string'
PUBLIC	??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@		; `string'
PUBLIC	??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@		; `string'
PUBLIC	??_C@_08HFDHOMDN@Sprofile?$AA@			; `string'
PUBLIC	??_C@_0M@LFKICJFJ@Scomponents?$AA@		; `string'
PUBLIC	??_C@_05HNJHHEPH@Ssize?$AA@			; `string'
PUBLIC	??_C@_07PEMLCIHF@Sorigin?$AA@			; `string'
PUBLIC	??_C@_06EPMBOCAF@Stiles?$AA@			; `string'
PUBLIC	??_C@_0N@KMIIMNEN@Stile_origin?$AA@		; `string'
PUBLIC	??_C@_0IE@HJOAKJGP@Illegal?5canvas?5coordinates?3?5the?5@ ; `string'
PUBLIC	??_C@_0II@BGDHKLNP@Trying?5to?5create?5a?5?$GAkdu_codestre@ ; `string'
PUBLIC	??_C@_0L@BADPNFGK@Sprecision?$AA@		; `string'
PUBLIC	??_C@_0FK@PBAGHHBG@No?5information?5available?5concern@ ; `string'
PUBLIC	??_C@_07MGJMMJC@Ssigned?$AA@			; `string'
PUBLIC	??_C@_0EO@LBIEHJAI@No?5information?5available?5regardi@ ; `string'
PUBLIC	??_C@_09IGDOMJM@Ssampling?$AA@			; `string'
PUBLIC	??_C@_0EE@ECOMFEJN@No?5information?5available?5concern@ ; `string'
PUBLIC	??_C@_0HD@LMPODLJE@Maximum?5number?5of?5allowable?5tile@ ; `string'
PUBLIC	??_C@_0NN@GLDINDPL@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0LM@OKEOLEGN@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0MI@KDNKFEHF@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0BBI@OCAIKCLE@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0BBL@KLDBMFIF@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0M@NJJFAENN@Sextensions?$AA@		; `string'
PUBLIC	??_C@_0M@FAIBBHLL@Mcomponents?$AA@		; `string'
PUBLIC	??_C@_0JB@BCDJMPPA@The?5?$GAMcomponents?8?5parameter?5attr@ ; `string'
PUBLIC	??_C@_0IA@FCOMNLBF@Number?5of?5multi?9component?5transf@ ; `string'
PUBLIC	??_C@_0L@OMLPDKKH@Mprecision?$AA@		; `string'
PUBLIC	??_C@_07GFFIOPIL@Msigned?$AA@			; `string'
PUBLIC	??_C@_09NPOAGBMD@CRGoffset?$AA@			; `string'
PUBLIC	??_C@_07MIOINIMK@Cdecomp?$AA@			; `string'
PUBLIC	??_C@_0MJ@FDIMAMPF@The?5fragment?5region?5supplied?5to?5@ ; `string'
PUBLIC	??_C@_0ED@OJAJOCED@The?5fragment?5region?5supplied?5to?5@ ; `string'
PUBLIC	??_C@_0KD@BEOENLDH@The?5fragment?5region?5supplied?5to?5@ ; `string'
PUBLIC	??_C@_0FC@DHCIJBNO@You?5must?5close?5all?5open?5tile?5int@ ; `string'
PUBLIC	??_C@_0BB@MMIMJKHF@Kdu?9Layer?9Info?3?5?$AA@	; `string'
PUBLIC	??_C@_0EF@DAJKGEFP@Kdu?9Layer?9Info?3?5log_2?$HLDelta?9D?$CIMS@ ; `string'
PUBLIC	??_C@_0O@GOIICFII@?$CF6?41f?0?5?$CF8?41e?6?$AA@	; `string'
PUBLIC	??_C@_0CJ@KOLIFCGA@Main?5code?9stream?5header?5appears?5@ ; `string'
PUBLIC	??_C@_0GH@CBFAGHCH@You?5cannot?5use?5PPM?5or?5PPT?5marker@ ; `string'
PUBLIC	??_C@_0KL@JPMPCIAA@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0MM@CDEHNDAJ@Dynamic?5indexing?5of?5tile?9parts?0?5@ ; `string'
PUBLIC	??_C@_0M@DAABJAJJ@Kakadu?9v6?41?$AA@		; `string'
PUBLIC	??_C@_0BBD@JFFMFNED@Attempting?5to?5run?5rate?9control?5s@ ; `string'
PUBLIC	??_C@_0BBE@DMFGKAON@Using?5the?5?$GAkdu_codestream?3?3gener@ ; `string'
PUBLIC	??_C@_03MNMMELJE@ORG?$AA@			; `string'
PUBLIC	??_C@_0L@CIAEHHDE@ORGgen_tlm?$AA@		; `string'
PUBLIC	??_C@_0BGA@CEHDEKMG@Unable?5to?5generate?5the?5TLM?5marke@ ; `string'
PUBLIC	??_C@_0BHK@LFLLGIPF@Unable?5to?5generate?5the?5TLM?5marke@ ; `string'
PUBLIC	??_C@_0CL@KMFCLNLD@Code?9stream?5must?5start?5with?5an?5S@ ; `string'
PUBLIC	??_C@_0FH@CKLGEIAA@Code?9stream?5must?5contain?5a?5valid@ ; `string'
PUBLIC	??_C@_0KI@GFLIIJEF@You?5may?5not?5use?5the?5?$GAkdu_codestr@ ; `string'
PUBLIC	??_C@_0MD@MOKJCILO@You?5may?5not?5use?5the?5output?5form?5@ ; `string'
PUBLIC	??_C@_0MB@GNICMEAH@You?5may?5not?5use?5the?5input?5form?5o@ ; `string'
PUBLIC	??_C@_0LL@KPFADBNA@You?5cannot?5use?5the?5?$GAkdu_codestre@ ; `string'
PUBLIC	??_C@_0FA@JIHDPBJH@You?5may?5not?5call?5?$GAkdu_codestream@ ; `string'
PUBLIC	??_C@_0GD@FICOODEH@You?5may?5only?5set?5the?5codestream?5@ ; `string'
PUBLIC	??_C@_0EM@OGOFBDKF@Attempting?5to?5impose?5too?5small?5a@ ; `string'
PUBLIC	??_C@_0DL@OBAGKPCA@?5bytes?5is?5insufficient?5to?5accomo@ ; `string'
PUBLIC	??_C@_0EC@IHLMBNEM@?$CCkdu_codestream?3?3set_max_bytes?$CC?5@ ; `string'
PUBLIC	??_C@_0IL@NFJOEHBJ@The?5?$GAkdu_codestream?3?3apply_input@ ; `string'
PUBLIC	??_C@_0GO@DAONBPDM@You?5may?5apply?5restrictions?5to?5th@ ; `string'
PUBLIC	??_C@_0KF@HPOIMBFL@You?5may?5not?5apply?5restrictions?5t@ ; `string'
PUBLIC	??_C@_0HD@FCIAAPLI@The?5range?5of?5apparent?5image?5comp@ ; `string'
PUBLIC	??_C@_0HK@LCIPMOP@The?5range?5of?5apparent?5output?5ima@ ; `string'
PUBLIC	??_C@_0FL@KCCGCDMA@You?5may?5change?5the?5apparent?5geom@ ; `string'
PUBLIC	??_C@_0JC@LBCJLKIB@You?5may?5not?5change?5the?5apparent?5@ ; `string'
PUBLIC	??_C@_07BGFFFHMP@Clevels?$AA@			; `string'
PUBLIC	??_C@_0EI@FINBMEOC@Attempting?5to?5access?5a?5tile?5whic@ ; `string'
PUBLIC	??_C@_0JF@GPFDNPBI@When?5generating?5code?9stream?5outp@ ; `string'
PUBLIC	??_C@_0KC@BHKKEAHA@You?5cannot?5currently?5use?5the?5?$GACr@ ; `string'
PUBLIC	??_C@_0KM@DJNDCKID@Unable?5to?5find?5modified?5distorti@ ; `string'
PUBLIC	??_C@_0BAM@PBALKCJD@You?5cannot?5currently?5use?5the?5?$GACr@ ; `string'
PUBLIC	??_C@_0IB@LAIBJLIH@You?5have?5set?5the?5byte?5limit?5too?5@ ; `string'
PUBLIC	??_R4kdu_output@@6B@				; kdu_output::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_output@@@8				; kdu_output `RTTI Type Descriptor'
PUBLIC	??_R3kdu_output@@8				; kdu_output::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_output@@8				; kdu_output::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_output@@8			; kdu_output::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kdu_thread_entity@@6B@			; kdu_thread_entity::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_thread_entity@@@8			; kdu_thread_entity `RTTI Type Descriptor'
PUBLIC	??_R3kdu_thread_entity@@8			; kdu_thread_entity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_thread_entity@@8			; kdu_thread_entity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_thread_entity@@8		; kdu_thread_entity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kdu_thread_env@@6B@			; kdu_thread_env::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_thread_env@@@8			; kdu_thread_env `RTTI Type Descriptor'
PUBLIC	??_R3kdu_thread_env@@8				; kdu_thread_env::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_thread_env@@8				; kdu_thread_env::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_thread_env@@8			; kdu_thread_env::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_compressed_output@@6B@			; kd_compressed_output::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_compressed_output@@@8		; kd_compressed_output `RTTI Type Descriptor'
PUBLIC	??_R3kd_compressed_output@@8			; kd_compressed_output::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_compressed_output@@8			; kd_compressed_output::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_compressed_output@@8		; kd_compressed_output::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_input@@6B@				; kd_input::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_input@@@8				; kd_input `RTTI Type Descriptor'
PUBLIC	??_R3kd_input@@8				; kd_input::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_input@@8				; kd_input::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_input@@8			; kd_input::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_compressed_input@@6B@			; kd_compressed_input::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_compressed_input@@@8			; kd_compressed_input `RTTI Type Descriptor'
PUBLIC	??_R3kd_compressed_input@@8			; kd_compressed_input::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_compressed_input@@8			; kd_compressed_input::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_compressed_input@@8		; kd_compressed_input::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_pph_input@@6B@				; kd_pph_input::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_pph_input@@@8			; kd_pph_input `RTTI Type Descriptor'
PUBLIC	??_R3kd_pph_input@@8				; kd_pph_input::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_pph_input@@8				; kd_pph_input::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_pph_input@@8			; kd_pph_input::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f000000
PUBLIC	__real@3f70000000000000
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40f0000000000000
PUBLIC	__real@bf800000
PUBLIC	__xmm@3ff00000000000003ff0000000000000
PUBLIC	__xmm@80000000800000008000000080000000
PUBLIC	__xmm@bff0000000000000bff0000000000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	___std_terminate:PROC
EXTRN	__imp__strncat:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	??0kdu_error@@QAE@PBD@Z:PROC			; kdu_error::kdu_error
EXTRN	??1kdu_error@@UAE@XZ:PROC			; kdu_error::~kdu_error
EXTRN	??0kdu_warning@@QAE@PBD@Z:PROC			; kdu_warning::kdu_warning
EXTRN	??1kdu_warning@@UAE@XZ:PROC			; kdu_warning::~kdu_warning
EXTRN	??_Ekdu_output@@UAEPAXI@Z:PROC			; kdu_output::`vector deleting destructor'
EXTRN	??1kdu_params@@UAE@XZ:PROC			; kdu_params::~kdu_params
EXTRN	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z:PROC	; kdu_params::link
EXTRN	?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z:PROC ; kdu_params::copy_from
EXTRN	?access_cluster@kdu_params@@QAEPAV1@PBD@Z:PROC	; kdu_params::access_cluster
EXTRN	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z:PROC ; kdu_params::access_relation
EXTRN	?access_unique@kdu_params@@QAEPAV1@HHH@Z:PROC	; kdu_params::access_unique
EXTRN	?clear_marks@kdu_params@@QAEXXZ:PROC		; kdu_params::clear_marks
EXTRN	?any_changes@kdu_params@@QAE_NXZ:PROC		; kdu_params::any_changes
EXTRN	?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z:PROC ; kdu_params::translate_marker_segment
EXTRN	?generate_marker_segments@kdu_params@@QAEHPAVkdu_output@@HH@Z:PROC ; kdu_params::generate_marker_segments
EXTRN	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z:PROC	; kdu_params::get
EXTRN	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z:PROC	; kdu_params::get
EXTRN	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z:PROC	; kdu_params::get
EXTRN	?set@kdu_params@@QAEXPBDHHH@Z:PROC		; kdu_params::set
EXTRN	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@HH_N@Z:PROC ; kdu_params::textualize_attributes
EXTRN	?finalize_all@kdu_params@@QAEXH_N@Z:PROC	; kdu_params::finalize_all
EXTRN	??0siz_params@@QAE@XZ:PROC			; siz_params::siz_params
EXTRN	??0mct_params@@QAE@XZ:PROC			; mct_params::mct_params
EXTRN	??0mcc_params@@QAE@XZ:PROC			; mcc_params::mcc_params
EXTRN	??0mco_params@@QAE@XZ:PROC			; mco_params::mco_params
EXTRN	??0atk_params@@QAE@XZ:PROC			; atk_params::atk_params
EXTRN	??0cod_params@@QAE@XZ:PROC			; cod_params::cod_params
EXTRN	??0ads_params@@QAE@XZ:PROC			; ads_params::ads_params
EXTRN	??0dfs_params@@QAE@XZ:PROC			; dfs_params::dfs_params
EXTRN	??0qcd_params@@QAE@XZ:PROC			; qcd_params::qcd_params
EXTRN	??0rgn_params@@QAE@XZ:PROC			; rgn_params::rgn_params
EXTRN	??0poc_params@@QAE@XZ:PROC			; poc_params::poc_params
EXTRN	??0crg_params@@QAE@XZ:PROC			; crg_params::crg_params
EXTRN	??0org_params@@QAE@XZ:PROC			; org_params::org_params
EXTRN	?init@kdu_kernels@@QAEXHPBUkdu_kernel_step_info@@PBM_N22@Z:PROC ; kdu_kernels::init
EXTRN	?get_impulse_response@kdu_kernels@@QAEPAMW4kdu_kernel_type@@AAHPAH2@Z:PROC ; kdu_kernels::get_impulse_response
EXTRN	?clear@kdu_kernels@@AAEXXZ:PROC			; kdu_kernels::clear
EXTRN	?reset@kdu_kernels@@AAEXXZ:PROC			; kdu_kernels::reset
EXTRN	__imp__clock:PROC
EXTRN	??0kdu_thread_entity@@QAE@XZ:PROC		; kdu_thread_entity::kdu_thread_entity
EXTRN	??2kdu_thread_entity@@SAPAXI@Z:PROC		; kdu_thread_entity::operator new
EXTRN	??3kdu_thread_entity@@SAXPAX@Z:PROC		; kdu_thread_entity::operator delete
EXTRN	?get_current_thread_entity@kdu_thread_entity@@QAEPAV1@XZ:PROC ; kdu_thread_entity::get_current_thread_entity
EXTRN	?destroy@kdu_thread_entity@@QAE_NXZ:PROC	; kdu_thread_entity::destroy
EXTRN	?handle_exception@kdu_thread_entity@@UAEXH@Z:PROC ; kdu_thread_entity::handle_exception
EXTRN	??_Ekdu_thread_entity@@UAEPAXI@Z:PROC		; kdu_thread_entity::`vector deleting destructor'
EXTRN	??0kdu_block@@AAE@XZ:PROC			; kdu_block::kdu_block
EXTRN	??1kdu_block@@AAE@XZ:PROC			; kdu_block::~kdu_block
EXTRN	??_Ekd_compressed_output@@UAEPAXI@Z:PROC	; kd_compressed_output::`vector deleting destructor'
EXTRN	??_Ekd_input@@UAEPAXI@Z:PROC			; kd_input::`vector deleting destructor'
EXTRN	??_Ekd_compressed_input@@UAEPAXI@Z:PROC		; kd_compressed_input::`vector deleting destructor'
EXTRN	??_Ekd_pph_input@@UAEPAXI@Z:PROC		; kd_pph_input::`vector deleting destructor'
EXTRN	??0kd_tile@@QAE@PAUkd_codestream@@PAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z:PROC ; kd_tile::kd_tile
EXTRN	??1kd_tile@@QAE@XZ:PROC				; kd_tile::~kd_tile
EXTRN	?release@kd_tile@@QAEXXZ:PROC			; kd_tile::release
EXTRN	?initialize@kd_tile@@QAEXXZ:PROC		; kd_tile::initialize
EXTRN	?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z:PROC ; kd_tile::recycle
EXTRN	?restart@kd_tile@@QAEXXZ:PROC			; kd_tile::restart
EXTRN	?reinitialize@kd_tile@@QAEXXZ:PROC		; kd_tile::reinitialize
EXTRN	?open@kd_tile@@QAEXXZ:PROC			; kd_tile::open
EXTRN	?generate_tile_part@kd_tile@@QAE_JHQAG@Z:PROC	; kd_tile::generate_tile_part
EXTRN	?close@kd_precinct_ref@@QAEXXZ:PROC		; kd_precinct_ref::close
EXTRN	?set_address@kd_precinct_ref@@QAE_NPAUkd_resolution@@Ukdu_coords@@_J@Z:PROC ; kd_precinct_ref::set_address
EXTRN	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z:PROC ; kd_precinct_ref::instantiate_precinct
EXTRN	?trim_data@kd_block@@QAE_NGPAVkd_buf_server@@@Z:PROC ; kd_block::trim_data
EXTRN	?activate@kd_precinct@@QAEXXZ:PROC		; kd_precinct::activate
EXTRN	?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z:PROC ; kd_precinct::simulate_packet
EXTRN	?move_to_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z:PROC ; kd_precinct_size_class::move_to_inactive_list
EXTRN	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z:PROC ; kd_precinct_size_class::withdraw_from_inactive_list
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__allmul:PROC
EXTRN	__allshr:PROC
EXTRN	__dtol3:PROC
EXTRN	__libm_sse2_exp_precise:PROC
EXTRN	__libm_sse2_log_precise:PROC
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	__ltod3:PROC
EXTRN	_floor:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT __xmm@bff0000000000000bff0000000000000
CONST	SEGMENT
__xmm@bff0000000000000bff0000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 0f0H
	DB	0bfH, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 0bfH
CONST	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@3ff00000000000003ff0000000000000
CONST	SEGMENT
__xmm@3ff00000000000003ff0000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 0f0H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, '?'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@40f0000000000000
CONST	SEGMENT
__real@40f0000000000000 DQ 040f0000000000000r	; 65536
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f70000000000000
CONST	SEGMENT
__real@3f70000000000000 DQ 03f70000000000000r	; 0.00390625
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_pph_input@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_pph_input@@8 DD FLAT:??_R0?AVkd_pph_input@@@8 ; kd_pph_input::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_pph_input@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_pph_input@@8
rdata$r	SEGMENT
??_R2kd_pph_input@@8 DD FLAT:??_R1A@?0A@EA@kd_pph_input@@8 ; kd_pph_input::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kd_input@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_pph_input@@8
rdata$r	SEGMENT
??_R3kd_pph_input@@8 DD 00H				; kd_pph_input::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_pph_input@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_pph_input@@@8
data$r	SEGMENT
??_R0?AVkd_pph_input@@@8 DD FLAT:??_7type_info@@6B@	; kd_pph_input `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_pph_input@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_pph_input@@6B@
rdata$r	SEGMENT
??_R4kd_pph_input@@6B@ DD 00H				; kd_pph_input::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_pph_input@@@8
	DD	FLAT:??_R3kd_pph_input@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_compressed_input@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_compressed_input@@8 DD FLAT:??_R0?AVkd_compressed_input@@@8 ; kd_compressed_input::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_compressed_input@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_compressed_input@@8
rdata$r	SEGMENT
??_R2kd_compressed_input@@8 DD FLAT:??_R1A@?0A@EA@kd_compressed_input@@8 ; kd_compressed_input::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kd_input@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_compressed_input@@8
rdata$r	SEGMENT
??_R3kd_compressed_input@@8 DD 00H			; kd_compressed_input::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_compressed_input@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_compressed_input@@@8
data$r	SEGMENT
??_R0?AVkd_compressed_input@@@8 DD FLAT:??_7type_info@@6B@ ; kd_compressed_input `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_compressed_input@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_compressed_input@@6B@
rdata$r	SEGMENT
??_R4kd_compressed_input@@6B@ DD 00H			; kd_compressed_input::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_compressed_input@@@8
	DD	FLAT:??_R3kd_compressed_input@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_input@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_input@@8 DD FLAT:??_R0?AVkd_input@@@8	; kd_input::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_input@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_input@@8
rdata$r	SEGMENT
??_R2kd_input@@8 DD FLAT:??_R1A@?0A@EA@kd_input@@8	; kd_input::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kd_input@@8
rdata$r	SEGMENT
??_R3kd_input@@8 DD 00H					; kd_input::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kd_input@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_input@@@8
data$r	SEGMENT
??_R0?AVkd_input@@@8 DD FLAT:??_7type_info@@6B@		; kd_input `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_input@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_input@@6B@
rdata$r	SEGMENT
??_R4kd_input@@6B@ DD 00H				; kd_input::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_input@@@8
	DD	FLAT:??_R3kd_input@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_compressed_output@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_compressed_output@@8 DD FLAT:??_R0?AVkd_compressed_output@@@8 ; kd_compressed_output::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_compressed_output@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_compressed_output@@8
rdata$r	SEGMENT
??_R2kd_compressed_output@@8 DD FLAT:??_R1A@?0A@EA@kd_compressed_output@@8 ; kd_compressed_output::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_output@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_compressed_output@@8
rdata$r	SEGMENT
??_R3kd_compressed_output@@8 DD 00H			; kd_compressed_output::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_compressed_output@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_compressed_output@@@8
data$r	SEGMENT
??_R0?AVkd_compressed_output@@@8 DD FLAT:??_7type_info@@6B@ ; kd_compressed_output `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_compressed_output@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_compressed_output@@6B@
rdata$r	SEGMENT
??_R4kd_compressed_output@@6B@ DD 00H			; kd_compressed_output::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_compressed_output@@@8
	DD	FLAT:??_R3kd_compressed_output@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_thread_env@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_thread_env@@8 DD FLAT:??_R0?AVkdu_thread_env@@@8 ; kdu_thread_env::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_thread_env@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_thread_env@@8
rdata$r	SEGMENT
??_R2kdu_thread_env@@8 DD FLAT:??_R1A@?0A@EA@kdu_thread_env@@8 ; kdu_thread_env::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_thread_entity@@8
rdata$r	ENDS
;	COMDAT ??_R3kdu_thread_env@@8
rdata$r	SEGMENT
??_R3kdu_thread_env@@8 DD 00H				; kdu_thread_env::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kdu_thread_env@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_thread_env@@@8
data$r	SEGMENT
??_R0?AVkdu_thread_env@@@8 DD FLAT:??_7type_info@@6B@	; kdu_thread_env `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_thread_env@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_thread_env@@6B@
rdata$r	SEGMENT
??_R4kdu_thread_env@@6B@ DD 00H				; kdu_thread_env::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_thread_env@@@8
	DD	FLAT:??_R3kdu_thread_env@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_thread_entity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_thread_entity@@8 DD FLAT:??_R0?AVkdu_thread_entity@@@8 ; kdu_thread_entity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_thread_entity@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_thread_entity@@8
rdata$r	SEGMENT
??_R2kdu_thread_entity@@8 DD FLAT:??_R1A@?0A@EA@kdu_thread_entity@@8 ; kdu_thread_entity::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_thread_entity@@8
rdata$r	SEGMENT
??_R3kdu_thread_entity@@8 DD 00H			; kdu_thread_entity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_thread_entity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_thread_entity@@@8
data$r	SEGMENT
??_R0?AVkdu_thread_entity@@@8 DD FLAT:??_7type_info@@6B@ ; kdu_thread_entity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_thread_entity@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_thread_entity@@6B@
rdata$r	SEGMENT
??_R4kdu_thread_entity@@6B@ DD 00H			; kdu_thread_entity::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_thread_entity@@@8
	DD	FLAT:??_R3kdu_thread_entity@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_output@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_output@@8 DD FLAT:??_R0?AVkdu_output@@@8 ; kdu_output::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_output@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_output@@8
rdata$r	SEGMENT
??_R2kdu_output@@8 DD FLAT:??_R1A@?0A@EA@kdu_output@@8	; kdu_output::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_output@@8
rdata$r	SEGMENT
??_R3kdu_output@@8 DD 00H				; kdu_output::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_output@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_output@@@8
data$r	SEGMENT
??_R0?AVkdu_output@@@8 DD FLAT:??_7type_info@@6B@	; kdu_output `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_output@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_output@@6B@
rdata$r	SEGMENT
??_R4kdu_output@@6B@ DD 00H				; kdu_output::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_output@@@8
	DD	FLAT:??_R3kdu_output@@8
rdata$r	ENDS
;	COMDAT ??_C@_0IB@LAIBJLIH@You?5have?5set?5the?5byte?5limit?5too?5@
CONST	SEGMENT
??_C@_0IB@LAIBJLIH@You?5have?5set?5the?5byte?5limit?5too?5@ DB 'You have '
	DB	'set the byte limit too low.  All compressed data would have t'
	DB	'o be discarded in the call to `kdu_codestream::trans_out''!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAM@PBALKCJD@You?5cannot?5currently?5use?5the?5?$GACr@
CONST	SEGMENT
??_C@_0BAM@PBALKCJD@You?5cannot?5currently?5use?5the?5?$GACr@ DB 'You can'
	DB	'not currently use the `Creslength'' parameter attribute in co'
	DB	'njunction with `kdu_codestream::trans_out'' (i.e., you cannot'
	DB	' use this parameter to control the compressed lengths of indi'
	DB	'vidual resolutions during transcoding).  Ignoring the `Cresle'
	DB	'ngth'' constraints.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0KM@DJNDCKID@Unable?5to?5find?5modified?5distorti@
CONST	SEGMENT
??_C@_0KM@DJNDCKID@Unable?5to?5find?5modified?5distorti@ DB 'Unable to fi'
	DB	'nd modified distortion-length slope thresholds which can sati'
	DB	'sfy the compressed length constraints imposed by the supplied'
	DB	' `Creslength'' parameter attribute(s).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0KC@BHKKEAHA@You?5cannot?5currently?5use?5the?5?$GACr@
CONST	SEGMENT
??_C@_0KC@BHKKEAHA@You?5cannot?5currently?5use?5the?5?$GACr@ DB 'You cann'
	DB	'ot currently use the `Creslength'' parameter attribute in con'
	DB	'junction with incremental flushing of the codestream.  Ignori'
	DB	'ng the `Creslength'' constraints.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0JF@GPFDNPBI@When?5generating?5code?9stream?5outp@
CONST	SEGMENT
??_C@_0JF@GPFDNPBI@When?5generating?5code?9stream?5outp@ DB 'When generat'
	DB	'ing code-stream output incrementally, each call to `kdu_codes'
	DB	'tream::flush'' must provide the same number of quality layer '
	DB	'specifications.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@FINBMEOC@Attempting?5to?5access?5a?5tile?5whic@
CONST	SEGMENT
??_C@_0EI@FINBMEOC@Attempting?5to?5access?5a?5tile?5whic@ DB 'Attempting '
	DB	'to access a tile which has already been discarded or closed!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BGFFFHMP@Clevels?$AA@
CONST	SEGMENT
??_C@_07BGFFFHMP@Clevels?$AA@ DB 'Clevels', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0JC@LBCJLKIB@You?5may?5not?5change?5the?5apparent?5@
CONST	SEGMENT
??_C@_0JC@LBCJLKIB@You?5may?5not?5change?5the?5apparent?5@ DB 'You may no'
	DB	't change the apparent geometry of the code-stream after the f'
	DB	'irst tile access, unless the codestream object is set up to b'
	DB	'e persistent.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@KCCGCDMA@You?5may?5change?5the?5apparent?5geom@
CONST	SEGMENT
??_C@_0FL@KCCGCDMA@You?5may?5change?5the?5apparent?5geom@ DB 'You may cha'
	DB	'nge the apparent geometry of the code-stream only after closi'
	DB	'ng all open tiles.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0HK@LCIPMOP@The?5range?5of?5apparent?5output?5ima@
CONST	SEGMENT
??_C@_0HK@LCIPMOP@The?5range?5of?5apparent?5output?5ima@ DB 'The range of'
	DB	' apparent output image components supplied to `kdu_codestream'
	DB	'::apply_input_restrictions'' is empty or illegal!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HD@FCIAAPLI@The?5range?5of?5apparent?5image?5comp@
CONST	SEGMENT
??_C@_0HD@FCIAAPLI@The?5range?5of?5apparent?5image?5comp@ DB 'The range o'
	DB	'f apparent image components supplied to `kdu_codestream::appl'
	DB	'y_input_restrictions'' is empty or illegal!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0KF@HPOIMBFL@You?5may?5not?5apply?5restrictions?5t@
CONST	SEGMENT
??_C@_0KF@HPOIMBFL@You?5may?5not?5apply?5restrictions?5t@ DB 'You may not'
	DB	' apply restrictions to the resolution or number of image comp'
	DB	'onents after the first tile access, unless the codestream obj'
	DB	'ect is set up to be persistent.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GO@DAONBPDM@You?5may?5apply?5restrictions?5to?5th@
CONST	SEGMENT
??_C@_0GO@DAONBPDM@You?5may?5apply?5restrictions?5to?5th@ DB 'You may app'
	DB	'ly restrictions to the resolution or number of image componen'
	DB	'ts only after closing all open tiles.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0IL@NFJOEHBJ@The?5?$GAkdu_codestream?3?3apply_input@
CONST	SEGMENT
??_C@_0IL@NFJOEHBJ@The?5?$GAkdu_codestream?3?3apply_input@ DB 'The `kdu_c'
	DB	'odestream::apply_input_restrictions'' function may not be inv'
	DB	'oked on codestream objects opened for output (i.e. for compre'
	DB	'ssion).', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@IHLMBNEM@?$CCkdu_codestream?3?3set_max_bytes?$CC?5@
CONST	SEGMENT
??_C@_0EC@IHLMBNEM@?$CCkdu_codestream?3?3set_max_bytes?$CC?5@ DB '"kdu_co'
	DB	'destream::set_max_bytes" may not be called multiple times.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@OBAGKPCA@?5bytes?5is?5insufficient?5to?5accomo@
CONST	SEGMENT
??_C@_0DL@OBAGKPCA@?5bytes?5is?5insufficient?5to?5accomo@ DB ' bytes is i'
	DB	'nsufficient to accomodate even the main header!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@OGOFBDKF@Attempting?5to?5impose?5too?5small?5a@
CONST	SEGMENT
??_C@_0EM@OGOFBDKF@Attempting?5to?5impose?5too?5small?5a@ DB 'Attempting '
	DB	'to impose too small a limit on the number of code-stream byte'
	DB	's. ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@FICOODEH@You?5may?5only?5set?5the?5codestream?5@
CONST	SEGMENT
??_C@_0GD@FICOODEH@You?5may?5only?5set?5the?5codestream?5@ DB 'You may on'
	DB	'ly set the codestream object into its "persistent" mode prior'
	DB	' to opening the first tile.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@JIHDPBJH@You?5may?5not?5call?5?$GAkdu_codestream@
CONST	SEGMENT
??_C@_0FA@JIHDPBJH@You?5may?5not?5call?5?$GAkdu_codestream@ DB 'You may n'
	DB	'ot call `kdu_codestream::enable_restart'' after opening the f'
	DB	'irst tile.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0LL@KPFADBNA@You?5cannot?5use?5the?5?$GAkdu_codestre@
CONST	SEGMENT
??_C@_0LL@KPFADBNA@You?5cannot?5use?5the?5?$GAkdu_codestre@ DB 'You canno'
	DB	't use the `kdu_codestream::share_buffering'' function if the '
	DB	'codestream object which will be sharing another codestream''s'
	DB	' buffering has already allocated some internal resources.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0MB@GNICMEAH@You?5may?5not?5use?5the?5input?5form?5o@
CONST	SEGMENT
??_C@_0MB@GNICMEAH@You?5may?5not?5use?5the?5input?5form?5o@ DB 'You may n'
	DB	'ot use the input form of `kdu_codestream::restart'' if the co'
	DB	'de-stream management machinery was originally created using a'
	DB	'nything other than the input form of `kdu_codestream::create'''
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0MD@MOKJCILO@You?5may?5not?5use?5the?5output?5form?5@
CONST	SEGMENT
??_C@_0MD@MOKJCILO@You?5may?5not?5use?5the?5output?5form?5@ DB 'You may n'
	DB	'ot use the output form of `kdu_codestream::restart'' if the c'
	DB	'ode-stream management machinery was originally created using '
	DB	'anything other than the output form of `kdu_codestream::creat'
	DB	'e''.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0KI@GFLIIJEF@You?5may?5not?5use?5the?5?$GAkdu_codestr@
CONST	SEGMENT
??_C@_0KI@GFLIIJEF@You?5may?5not?5use?5the?5?$GAkdu_codestr@ DB 'You may '
	DB	'not use the `kdu_codestream::restart'' function unless `kdu_c'
	DB	'odestream::enable_restart'' was called after the code-stream '
	DB	'management machinery was first created.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@CKLGEIAA@Code?9stream?5must?5contain?5a?5valid@
CONST	SEGMENT
??_C@_0FH@CKLGEIAA@Code?9stream?5must?5contain?5a?5valid@ DB 'Code-stream'
	DB	' must contain a valid SIZ marker segment, immediately after t'
	DB	'he SOC marker!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KMFCLNLD@Code?9stream?5must?5start?5with?5an?5S@
CONST	SEGMENT
??_C@_0CL@KMFCLNLD@Code?9stream?5must?5start?5with?5an?5S@ DB 'Code-strea'
	DB	'm must start with an SOC marker!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BHK@LFLLGIPF@Unable?5to?5generate?5the?5TLM?5marke@
CONST	SEGMENT
??_C@_0BHK@LFLLGIPF@Unable?5to?5generate?5the?5TLM?5marke@ DB 'Unable to '
	DB	'generate the TLM marker segments requested via the `ORGgen_tl'
	DB	'm'' parameter attribute.  The reason for this is that the log'
	DB	'ical compressed data target supplied by the application does '
	DB	'not appear to support rewriting (i.e., seeking).  We need thi'
	DB	's to reserve space for the TLM marker segments up front and l'
	DB	'ater overwrite the reserved space with valid tile-part length'
	DB	's.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BGA@CEHDEKMG@Unable?5to?5generate?5the?5TLM?5marke@
CONST	SEGMENT
??_C@_0BGA@CEHDEKMG@Unable?5to?5generate?5the?5TLM?5marke@ DB 'Unable to '
	DB	'generate the TLM marker segments requested via the `ORGgen_tl'
	DB	'm'' parameter attribute.  The reason for this is that the tot'
	DB	'al number of tile-parts whose lengths would need to be repres'
	DB	'ented exceeds the amount of data which can legally be stored '
	DB	'in the maximum allowable 256 TLM marker segments, allowing fo'
	DB	'r 6 bytes per tile-part length value.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CIAEHHDE@ORGgen_tlm?$AA@
CONST	SEGMENT
??_C@_0L@CIAEHHDE@ORGgen_tlm?$AA@ DB 'ORGgen_tlm', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MNMMELJE@ORG?$AA@
CONST	SEGMENT
??_C@_03MNMMELJE@ORG?$AA@ DB 'ORG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBE@DMFGKAON@Using?5the?5?$GAkdu_codestream?3?3gener@
CONST	SEGMENT
??_C@_0BBE@DMFGKAON@Using?5the?5?$GAkdu_codestream?3?3gener@ DB 'Using th'
	DB	'e `kdu_codestream::generate_codestream'' function in an illeg'
	DB	'al manner.  The `max_layers'' argument may not exceed the max'
	DB	'imum number of layers which are being sized.  The problem may'
	DB	' have arisen from an incorrect use of the incremental code-st'
	DB	'ream flushing capability.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBD@JFFMFNED@Attempting?5to?5run?5rate?9control?5s@
CONST	SEGMENT
??_C@_0BBD@JFFMFNED@Attempting?5to?5run?5rate?9control?5s@ DB 'Attempting'
	DB	' to run rate-control simulation on a precinct for which one o'
	DB	'r more packets have already been written to the code-stream. '
	DB	' Problem is most likely caused by trying to use the increment'
	DB	'al code-stream flushing feature with one of the progression o'
	DB	'rders, LRCP or RLCP.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DAABJAJJ@Kakadu?9v6?41?$AA@
CONST	SEGMENT
??_C@_0M@DAABJAJJ@Kakadu?9v6?41?$AA@ DB 'Kakadu-v6.1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0MM@CDEHNDAJ@Dynamic?5indexing?5of?5tile?9parts?0?5@
CONST	SEGMENT
??_C@_0MM@CDEHNDAJ@Dynamic?5indexing?5of?5tile?9parts?0?5@ DB 'Dynamic in'
	DB	'dexing of tile-parts, whether by TLM (tile-part length) marke'
	DB	'r segments or otherwise, cannot be used by the current implem'
	DB	'entation when PPM (packed packet header) marker segments are '
	DB	'also used.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0KL@JPMPCIAA@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0KL@JPMPCIAA@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vi'
	DB	'olation detected (code-stream is technically illegal).  PPM m'
	DB	'arker segments may not appear within a Profile-0 code-stream.'
	DB	'  You should set "Sprofile" to 1 or 2.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@CBFAGHCH@You?5cannot?5use?5PPM?5or?5PPT?5marker@
CONST	SEGMENT
??_C@_0GH@CBFAGHCH@You?5cannot?5use?5PPM?5or?5PPT?5marker@ DB 'You cannot'
	DB	' use PPM or PPT marker segments (packed packet headers) with '
	DB	'cached compressed data sources.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KOLIFCGA@Main?5code?9stream?5header?5appears?5@
CONST	SEGMENT
??_C@_0CJ@KOLIFCGA@Main?5code?9stream?5header?5appears?5@ DB 'Main code-s'
	DB	'tream header appears corrupt!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GOIICFII@?$CF6?41f?0?5?$CF8?41e?6?$AA@
CONST	SEGMENT
??_C@_0O@GOIICFII@?$CF6?41f?0?5?$CF8?41e?6?$AA@ DB '%6.1f, %8.1e', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@DAJKGEFP@Kdu?9Layer?9Info?3?5log_2?$HLDelta?9D?$CIMS@
CONST	SEGMENT
??_C@_0EF@DAJKGEFP@Kdu?9Layer?9Info?3?5log_2?$HLDelta?9D?$CIMS@ DB 'Kdu-L'
	DB	'ayer-Info: log_2{Delta-D(MSE)/[2^16*Delta-L(bytes)]}, L(bytes'
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MMIMJKHF@Kdu?9Layer?9Info?3?5?$AA@
CONST	SEGMENT
??_C@_0BB@MMIMJKHF@Kdu?9Layer?9Info?3?5?$AA@ DB 'Kdu-Layer-Info: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@DHCIJBNO@You?5must?5close?5all?5open?5tile?5int@
CONST	SEGMENT
??_C@_0FC@DHCIJBNO@You?5must?5close?5all?5open?5tile?5int@ DB 'You must c'
	DB	'lose all open tile interfaces before calling `kdu_codestream:'
	DB	':restart''.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0KD@BEOENLDH@The?5fragment?5region?5supplied?5to?5@
CONST	SEGMENT
??_C@_0KD@BEOENLDH@The?5fragment?5region?5supplied?5to?5@ DB 'The fragmen'
	DB	't region supplied to `kdu_codestream::create'' represents too'
	DB	' many tiles, allowing for the number of tiles indicated for p'
	DB	'reviously generated fragments.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@OJAJOCED@The?5fragment?5region?5supplied?5to?5@
CONST	SEGMENT
??_C@_0ED@OJAJOCED@The?5fragment?5region?5supplied?5to?5@ DB 'The fragmen'
	DB	't region supplied to `kdu_codestream::create'' is empty.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0MJ@FDIMAMPF@The?5fragment?5region?5supplied?5to?5@
CONST	SEGMENT
??_C@_0MJ@FDIMAMPF@The?5fragment?5region?5supplied?5to?5@ DB 'The fragmen'
	DB	't region supplied to `kdu_codestream::create'' does not corre'
	DB	'spond to a whole number of tiles.  Check your dimensions agai'
	DB	'n, remembering to take account of any non-zero tile or image '
	DB	'origin.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07MIOINIMK@Cdecomp?$AA@
CONST	SEGMENT
??_C@_07MIOINIMK@Cdecomp?$AA@ DB 'Cdecomp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NPOAGBMD@CRGoffset?$AA@
CONST	SEGMENT
??_C@_09NPOAGBMD@CRGoffset?$AA@ DB 'CRGoffset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GFFIOPIL@Msigned?$AA@
CONST	SEGMENT
??_C@_07GFFIOPIL@Msigned?$AA@ DB 'Msigned', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OMLPDKKH@Mprecision?$AA@
CONST	SEGMENT
??_C@_0L@OMLPDKKH@Mprecision?$AA@ DB 'Mprecision', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0IA@FCOMNLBF@Number?5of?5multi?9component?5transf@
CONST	SEGMENT
??_C@_0IA@FCOMNLBF@Number?5of?5multi?9component?5transf@ DB 'Number of mu'
	DB	'lti-component transform output components defined by CBD mark'
	DB	'er segment exceeds the maximum allowed value of 16384.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JB@BCDJMPPA@The?5?$GAMcomponents?8?5parameter?5attr@
CONST	SEGMENT
??_C@_0JB@BCDJMPPA@The?5?$GAMcomponents?8?5parameter?5attr@ DB 'The `Mcom'
	DB	'ponents'' parameter attribute must be assigned a non-zero val'
	DB	'ue if and only if the `MCT'' flag is present in the `Sextensi'
	DB	'ons'' attribute.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FAIBBHLL@Mcomponents?$AA@
CONST	SEGMENT
??_C@_0M@FAIBBHLL@Mcomponents?$AA@ DB 'Mcomponents', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJJFAENN@Sextensions?$AA@
CONST	SEGMENT
??_C@_0M@NJJFAENN@Sextensions?$AA@ DB 'Sextensions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBL@KLDBMFIF@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0BBL@KLDBMFIF@Profile?5violation?5detected?5?$CIcode@ DB 'Profile v'
	DB	'iolation detected (code-stream is technically illegal).  If a'
	DB	' Profile-1 code-stream is tiled (has multiple tiles), the wid'
	DB	'th and height of its tiles, projected onto any given image co'
	DB	'mponent, may not exceed 1024.  You might like to set "Sprofil'
	DB	'e" to 2 or avoid using tiles.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBI@OCAIKCLE@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0BBI@OCAIKCLE@Profile?5violation?5detected?5?$CIcode@ DB 'Profile v'
	DB	'iolation detected (code-stream is technically illegal).  Prof'
	DB	'ile-1 code-streams must either be untiled or else the horizon'
	DB	'tal and vertical tile dimensions must be identical (square ti'
	DB	'les on the hi-res canvas).  You might like to set "Sprofile" '
	DB	'to 2 or avoid using tiles.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0MI@KDNKFEHF@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0MI@KDNKFEHF@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vi'
	DB	'olation detected (code-stream is technically illegal).  Compo'
	DB	'nent sub-sampling factors for Profile-0 code-streams are rest'
	DB	'ricted to the values 1, 2 and 4.  Try setting "Sprofile" to 1'
	DB	' or 2.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0LM@OKEOLEGN@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0LM@OKEOLEGN@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vi'
	DB	'olation detected (code-stream is technically illegal).  Profi'
	DB	'le-0 code-streams must have image and tiling origins (anchor '
	DB	'points) set to zero.  Try setting "Sprofile" to 1 or 2.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0NN@GLDINDPL@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0NN@GLDINDPL@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vi'
	DB	'olation detected (code-stream is technically illegal).  Profi'
	DB	'le-0 code-streams must either be untiled or else the tile dim'
	DB	'ensions must be exactly 128x128.  Try setting "Sprofile" to 1'
	DB	' or 2 or avoid using tiles.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HD@LMPODLJE@Maximum?5number?5of?5allowable?5tile@
CONST	SEGMENT
??_C@_0HD@LMPODLJE@Maximum?5number?5of?5allowable?5tile@ DB 'Maximum numb'
	DB	'er of allowable tiles is 65535 for any JPEG2000 code-stream. '
	DB	' You have managed to exceed this number!!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@ECOMFEJN@No?5information?5available?5concern@
CONST	SEGMENT
??_C@_0EE@ECOMFEJN@No?5information?5available?5concern@ DB 'No informatio'
	DB	'n available concerning component sub-sampling factors.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IGDOMJM@Ssampling?$AA@
CONST	SEGMENT
??_C@_09IGDOMJM@Ssampling?$AA@ DB 'Ssampling', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@LBIEHJAI@No?5information?5available?5regardi@
CONST	SEGMENT
??_C@_0EO@LBIEHJAI@No?5information?5available?5regardi@ DB 'No informatio'
	DB	'n available regarding whether components are signed or unsign'
	DB	'ed.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07MGJMMJC@Ssigned?$AA@
CONST	SEGMENT
??_C@_07MGJMMJC@Ssigned?$AA@ DB 'Ssigned', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@PBAGHHBG@No?5information?5available?5concern@
CONST	SEGMENT
??_C@_0FK@PBAGHHBG@No?5information?5available?5concern@ DB 'No informatio'
	DB	'n available concerning component sample bit-depths (i.e., sam'
	DB	'ple precision).', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BADPNFGK@Sprecision?$AA@
CONST	SEGMENT
??_C@_0L@BADPNFGK@Sprecision?$AA@ DB 'Sprecision', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0II@BGDHKLNP@Trying?5to?5create?5a?5?$GAkdu_codestre@
CONST	SEGMENT
??_C@_0II@BGDHKLNP@Trying?5to?5create?5a?5?$GAkdu_codestre@ DB 'Trying to'
	DB	' create a `kdu_codestream'' object with more than 16384 image'
	DB	' components -- this is the maximum number allowed by the stan'
	DB	'dard.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0IE@HJOAKJGP@Illegal?5canvas?5coordinates?3?5the?5@
CONST	SEGMENT
??_C@_0IE@HJOAKJGP@Illegal?5canvas?5coordinates?3?5the?5@ DB 'Illegal can'
	DB	'vas coordinates: the first tile is required to have a non-emp'
	DB	'ty intersection with the image on the high resolution grid.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
CONST	SEGMENT
??_C@_0N@KMIIMNEN@Stile_origin?$AA@ DB 'Stile_origin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EPMBOCAF@Stiles?$AA@
CONST	SEGMENT
??_C@_06EPMBOCAF@Stiles?$AA@ DB 'Stiles', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PEMLCIHF@Sorigin?$AA@
CONST	SEGMENT
??_C@_07PEMLCIHF@Sorigin?$AA@ DB 'Sorigin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HNJHHEPH@Ssize?$AA@
CONST	SEGMENT
??_C@_05HNJHHEPH@Ssize?$AA@ DB 'Ssize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LFKICJFJ@Scomponents?$AA@
CONST	SEGMENT
??_C@_0M@LFKICJFJ@Scomponents?$AA@ DB 'Scomponents', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HFDHOMDN@Sprofile?$AA@
CONST	SEGMENT
??_C@_08HFDHOMDN@Sprofile?$AA@ DB 'Sprofile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@
CONST	SEGMENT
??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@ DB 'Mtriang_coeffs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
CONST	SEGMENT
??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@ DB 'Mmatrix_coeffs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BHN@CGGDHAAL@Although?5not?5strictly?5illegal?0?5t@
CONST	SEGMENT
??_C@_0BHN@CGGDHAAL@Although?5not?5strictly?5illegal?0?5t@ DB 'Although n'
	DB	'ot strictly illegal, the present Part-2 codestream contains i'
	DB	'nsufficient information to determine the dimensions of all im'
	DB	'age components output by the multi-component transform, based'
	DB	' on main header marker segments.  The fact that this is not i'
	DB	'llegal is almost certainly an oversight in the development of'
	DB	' the Part-2 syntax, but Kakadu cannot work with such codestre'
	DB	'ams.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0KL@GPKLLFMI@The?5last?5stage?5of?5the?5multi?9comp@
CONST	SEGMENT
??_C@_0KL@GPKLLFMI@The?5last?5stage?5of?5the?5multi?9comp@ DB 'The last s'
	DB	'tage of the multi-component transform may not produce more ou'
	DB	'tput components than the number specified in the CBD marker s'
	DB	'egment (i.e. the `Mcomponents'' value).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBI@DKKKDOEN@Multi?9component?5transform?5does?5n@
CONST	SEGMENT
??_C@_0BBI@DKKKDOEN@Multi?9component?5transform?5does?5n@ DB 'Multi-compo'
	DB	'nent transform does not satisfy the constraints imposed by Pa'
	DB	'rt 2 of the JPEG2000 standard.  The first transform stage mus'
	DB	't touch every codestream image component (no more and no less'
	DB	'), while subsequent stages must touch every component produce'
	DB	'd by the previous stage.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IM@HJCMNLOE@Multi?9component?5transform?5stage?5@
CONST	SEGMENT
??_C@_0IM@HJCMNLOE@Multi?9component?5transform?5stage?5@ DB 'Multi-compon'
	DB	'ent transform stage contains multiple transform blocks which '
	DB	'provide different definitions for the same stage output compo'
	DB	'nent.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0JG@ECJLCCBG@Multi?9component?5transform?5stage?5@
CONST	SEGMENT
??_C@_0JG@ECJLCCBG@Multi?9component?5transform?5stage?5@ DB 'Multi-compon'
	DB	'ent transform stage appears to have a ridiculous number of co'
	DB	'mponent inputs or outputs -- greater than 65535!  Treating th'
	DB	'is as an error.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BIH@NMGBAOPH@?0?5corresponding?5to?5the?5total?5num@
CONST	SEGMENT
??_C@_0BIH@NMGBAOPH@?0?5corresponding?5to?5the?5total?5num@ DB ', corresp'
	DB	'onding to the total number of coefficients in the lower trian'
	DB	'gular matrix which describes the dependency transform in ques'
	DB	'tion.  For irreversible dependency transforms, the matrix sho'
	DB	'uld not contain any diagonal entries.  For reversible depende'
	DB	'ncy transforms, however, all but the first diagonal entries s'
	DB	'hould also be included, as normalization factors for the inte'
	DB	'ger predictors.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0KO@HBMKDEMJ@Unable?5to?5access?5the?5matrix?5para@
CONST	SEGMENT
??_C@_0KO@HBMKDEMJ@Unable?5to?5access?5the?5matrix?5para@ DB 'Unable to a'
	DB	'ccess the matrix parameters identified by an `Mstage_xforms'''
	DB	' parameter attribute.  Specifically, there should be an `Mtri'
	DB	'ang_size'' attribute, with instance index ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CCNKIJHO@Mtriang_size?$AA@
CONST	SEGMENT
??_C@_0N@CCNKIJHO@Mtriang_size?$AA@ DB 'Mtriang_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBM@IKPPNJIM@?0?5corresponding?5to?5the?5total?5num@
CONST	SEGMENT
??_C@_0BBM@IKPPNJIM@?0?5corresponding?5to?5the?5total?5num@ DB ', corresp'
	DB	'onding to the total number of coefficients required to descri'
	DB	'be the irreversible decorrelation transform or reversible SER'
	DB	'M transform in question -- note that reversible transforms ar'
	DB	'e described by M*(M+1) coefficients, where M is the number of'
	DB	' input (or output) components.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0KO@JDHHKMLN@Unable?5to?5access?5the?5matrix?5para@
CONST	SEGMENT
??_C@_0KO@JDHHKMLN@Unable?5to?5access?5the?5matrix?5para@ DB 'Unable to a'
	DB	'ccess the matrix parameters identified by an `Mstage_xforms'''
	DB	' parameter attribute.  Specifically, there should be an `Mmat'
	DB	'rix_size'' attribute, with instance index ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FIDBGNAL@Mmatrix_size?$AA@
CONST	SEGMENT
??_C@_0N@FIDBGNAL@Mmatrix_size?$AA@ DB 'Mmatrix_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0PM@HMICKPCP@Except?5for?5irreversible?5matrix?9b@
CONST	SEGMENT
??_C@_0PM@HMICKPCP@Except?5for?5irreversible?5matrix?9b@ DB 'Except for i'
	DB	'rreversible matrix-based decorrelation transforms, all multi-'
	DB	'component transform blocks described by the `Mstage_blocks'' '
	DB	'and `Mstage_xforms'' parameter attributes must produce exactl'
	DB	'y one output component for each of their input components.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HA@CPLCDADH@?0?5corresponding?5to?5the?5number?5of@
CONST	SEGMENT
??_C@_0HA@CPLCDADH@?0?5corresponding?5to?5the?5number?5of@ DB ', correspo'
	DB	'nding to the number of output components produced by the mult'
	DB	'i-component transform block in question.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KNDNPDMI@?5and?5value?5?$AA@
CONST	SEGMENT
??_C@_0M@KNDNPDMI@?5and?5value?5?$AA@ DB ' and value ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0KO@HEFENJF@Unable?5to?5access?5the?5offset?5para@
CONST	SEGMENT
??_C@_0KO@HEFENJF@Unable?5to?5access?5the?5offset?5para@ DB 'Unable to ac'
	DB	'cess the offset parameters identified by an `Mstage_xforms'' '
	DB	'parameter attribute.  Specifically, there should be an `Mvect'
	DB	'or_size'' attribute, with instance index ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EBBFOCKJ@Mvector_size?$AA@
CONST	SEGMENT
??_C@_0N@EBBFOCKJ@Mvector_size?$AA@ DB 'Mvector_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
CONST	SEGMENT
??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@ DB 'Mstage_xforms', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
CONST	SEGMENT
??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@ DB 'Mstage_outputs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
CONST	SEGMENT
??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@ DB 'Mstage_inputs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0KO@EOEMFLGL@Multi?9component?5transform?5block?5@
CONST	SEGMENT
??_C@_0KO@EOEMFLGL@Multi?9component?5transform?5block?5@ DB 'Multi-compon'
	DB	'ent transform block identifies more input components or more '
	DB	'output components than the maximum number of image components'
	DB	' in a codestream.  Seems like an error!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JM@EMODBKHC@Multi?9component?5transform?5blocks@
CONST	SEGMENT
??_C@_0JM@EMODBKHC@Multi?9component?5transform?5blocks@ DB 'Multi-compone'
	DB	'nt transform blocks must each have a strictly positive number'
	DB	' of inputs and outputs, as identified by the `Mstage_blocks'''
	DB	' parameter attribute.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0PF@HDJMLNFB@?5?$CIstarting?5from?50?$CJ?5in?5the?5multi?9@
CONST	SEGMENT
??_C@_0PF@HDJMLNFB@?5?$CIstarting?5from?50?$CJ?5in?5the?5multi?9@ DB ' (s'
	DB	'tarting from 0) in the multi-component transform for some til'
	DB	'e (or in the main header).  Either the `Mstages'' attribute c'
	DB	'ontains insufficient entries, or no `Mstage_blocks'' attribut'
	DB	'e exists with the instance identifier provided by `Mstages''.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PILHNAFH@Unable?5to?5access?5the?5description@
CONST	SEGMENT
??_C@_0CL@PILHNAFH@Unable?5to?5access?5the?5description@ DB 'Unable to ac'
	DB	'cess the description of stage ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
CONST	SEGMENT
??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@ DB 'Mstage_collections', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNNLMAHC@Mstages?$AA@
CONST	SEGMENT
??_C@_07CNNLMAHC@Mstages?$AA@ DB 'Mstages', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OOAAMMCO@Cmct?$AA@
CONST	SEGMENT
??_C@_04OOAAMMCO@Cmct?$AA@ DB 'Cmct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BMJAMMCN@Mnum_stages?$AA@
CONST	SEGMENT
??_C@_0M@BMJAMMCN@Mnum_stages?$AA@ DB 'Mnum_stages', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0OO@PCLKLFBK@Call?5to?5?$GAkdu_codestream_comment?3@
CONST	SEGMENT
??_C@_0OO@PCLKLFBK@Call?5to?5?$GAkdu_codestream_comment?3@ DB 'Call to `k'
	DB	'du_codestream_comment::put_text'' leaves the total length of '
	DB	'the codestream comment greater than 65531, which is the longe'
	DB	'st comment that can be represented in a COM marker segment in'
	DB	' the codestream.  Comment is being truncated.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HKNEBDCB@Creslengths?$AA@
CONST	SEGMENT
??_C@_0M@HKNEBDCB@Creslengths?$AA@ DB 'Creslengths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LN@NLKIMLNE@Attempting?5to?5use?5a?5spatially?5pr@
CONST	SEGMENT
??_C@_0LN@NLKIMLNE@Attempting?5to?5use?5a?5spatially?5pr@ DB 'Attempting '
	DB	'to use a spatially progressive packet sequence where position'
	DB	' order dominates component order. This is illegal when the co'
	DB	'mponent sub-sampling factors are not exact powers of 2!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BCG@LKLOKBKN@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0BCG@LKLOKBKN@Profile?5violation?5detected?5?$CIcode@ DB 'Profile v'
	DB	'iolation detected (code-stream is technically illegal).  In a'
	DB	' Profile-0 code-stream, the first progression specification f'
	DB	'ound in the first POC marker segment of the main or any tile '
	DB	'header may not describe a progression which starts from resol'
	DB	'ution or component indices other than 0.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EDBDEPHJ@?5are?5insuffient?5to?5cover?5all?5pac@
CONST	SEGMENT
??_C@_0DD@EDBDEPHJ@?5are?5insuffient?5to?5cover?5all?5pac@ DB ' are insuf'
	DB	'fient to cover all packets for the tile!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BOBLKNCL@Supplied?5progression?5order?5attri@
CONST	SEGMENT
??_C@_0DA@BOBLKNCL@Supplied?5progression?5order?5attri@ DB 'Supplied prog'
	DB	'ression order attributes for tile ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0OO@EOPDAIEN@The?5compressed?5data?5buffer?5serve@
CONST	SEGMENT
??_C@_0OO@EOPDAIEN@The?5compressed?5data?5buffer?5serve@ DB 'The compress'
	DB	'ed data buffer server is being destroyed before all size acco'
	DB	'unting associated with fixed data structures has been complet'
	DB	'ed.  This is most likely due to a bug in the memory accountin'
	DB	'g logic used for dynamic cache management.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LL@CAMCHDPO@The?5compressed?5data?5buffer?5serve@
CONST	SEGMENT
??_C@_0LL@CAMCHDPO@The?5compressed?5data?5buffer?5serve@ DB 'The compress'
	DB	'ed data buffer server is being destroyed before all allocated'
	DB	' buffers have been returned.  The problem is most likely conn'
	DB	'ected with a bug in the code-block destruction code.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CFK@EADCMAPD@You?5have?5invoked?5?$GAkdu_codestream@
CONST	SEGMENT
??_C@_0CFK@EADCMAPD@You?5have?5invoked?5?$GAkdu_codestream@ DB 'You have '
	DB	'invoked `kdu_codestream::destroy'' from one thread, thread qu'
	DB	'eues remain in which other threads may potentially do work.  '
	DB	'This is OK, so long as the thread from which you invoke `kdu_'
	DB	'codestream::destroy'' is one of the threads participating in '
	DB	'the `kdu_thread_entity'' group to which the above-mentioned t'
	DB	'hread queues belong.  However, this does not appear to be the'
	DB	' case here.  Typically, it is best to destroy codestreams fro'
	DB	'm the same thread which invokes the `kdu_thread_entity::creat'
	DB	'e'' and `kdu_thread_entity::add_thread'' functions which buil'
	DB	'd cooperating multi-threaded processing systems.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CCA@PJBKNCFI@Tile?9part?5holds?5some?5but?5not?5all@
CONST	SEGMENT
??_C@_0CCA@PJBKNCFI@Tile?9part?5holds?5some?5but?5not?5all@ DB 'Tile-part'
	DB	' holds some but not all the packets of a precinct for which P'
	DB	'LT information is being used to extract precinct addresses fo'
	DB	'r random access.  In particular, the current tile has its pac'
	DB	'kets sequenced so that all packets of any given precinct appe'
	DB	'ar consecutively and yet a tile-part boundary has been insert'
	DB	'ed between the packets of a precinct.  While this is not ille'
	DB	'gal, it indicates very poor judgement in the placement of til'
	DB	'e-part boundaries.  To process this code-stream, you will hav'
	DB	'e to open it again with file seeking disabled.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBI@KLDFJIGH@Unexpectedly?5ran?5out?5of?5packet?5l@
CONST	SEGMENT
??_C@_0BBI@KLDFJIGH@Unexpectedly?5ran?5out?5of?5packet?5l@ DB 'Unexpected'
	DB	'ly ran out of packet length information while processing tile'
	DB	'-parts.  Most likely cause is that PLT marker segments are ma'
	DB	'lformed, incomplete, or do not appear until after the packets'
	DB	' whose lengths they describe.  All of these conditions are vi'
	DB	'olations of the standard!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAD@MAAGNDO@Unexpected?5change?5in?5coding?5para@
CONST	SEGMENT
??_C@_0BAD@MAAGNDO@Unexpected?5change?5in?5coding?5para@ DB 'Unexpected c'
	DB	'hange in coding parameters or packet sequencing detected afte'
	DB	'r parsing packet length information in PLT marker segments.  '
	DB	'While this is not illegal, it is highly inadvisable.  To proc'
	DB	'ess this code-stream, open it again with file seeking disable'
	DB	'd!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0JE@NAFKBLL@Malformed?5PLT?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0JE@NAFKBLL@Malformed?5PLT?5marker?5segment?5enc@ DB 'Malformed PLT'
	DB	' marker segment encountered in tile-part header.  Segment ter'
	DB	'minates part of the way through a multi-byte packet length sp'
	DB	'ecification!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAD@EAIFLCLN@Unexpected?5change?5in?5coding?5para@
CONST	SEGMENT
??_C@_0BAD@EAIFLCLN@Unexpected?5change?5in?5coding?5para@ DB 'Unexpected '
	DB	'change in coding parameters or packet sequencing detected whi'
	DB	'le parsing packet length information in PLT marker segments. '
	DB	' While this is not illegal, it is highly inadvisable.  To pro'
	DB	'cess this code-stream, open it again with file seeking disabl'
	DB	'ed!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06NMKHLFPN@Porder?$AA@
CONST	SEGMENT
??_C@_06NMKHLFPN@Porder?$AA@ DB 'Porder', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKJBDDKO@Corder?$AA@
CONST	SEGMENT
??_C@_06IKJBDDKO@Corder?$AA@ DB 'Corder', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BJCMAMHC@Clayers?$AA@
CONST	SEGMENT
??_C@_07BJCMAMHC@Clayers?$AA@ DB 'Clayers', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BFL@CANGKIAI@There?5appears?5to?5be?5a?5problem?5wi@
CONST	SEGMENT
??_C@_0BFL@CANGKIAI@There?5appears?5to?5be?5a?5problem?5wi@ DB 'There app'
	DB	'ears to be a problem with the PLT marker segments included in'
	DB	' the input code-stream.  The PLT marker segments encountered '
	DB	'so far do not have sufficient length information to describe '
	DB	'the lengths of all packets in the tile-parts encountered so f'
	DB	'ar.  To process this code-stream, you will have to open it ag'
	DB	'ain, with file seeking disabled.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BDH@HFCLMIKM@PLT?5marker?5segments?5appear?5out?5o@
CONST	SEGMENT
??_C@_0BDH@HFCLMIKM@PLT?5marker?5segments?5appear?5out?5o@ DB 'PLT marker'
	DB	' segments appear out of order within one or more tile-part he'
	DB	'aders.  While this is not illegal, it is highly inadvisable s'
	DB	'ince it prevents immediate condensation of the pointer inform'
	DB	'ation by efficient parsers.  To process this code-stream, you'
	DB	' will have to open it again, with file seeking disabled.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IA@MHJOOLGJ@TLM?5marker?5segments?5contain?5one?5@
CONST	SEGMENT
??_C@_0IA@MHJOOLGJ@TLM?5marker?5segments?5contain?5one?5@ DB 'TLM marker '
	DB	'segments contain one or more illegal lengths (< 14 bytes).  P'
	DB	'roceeding with incomplete tile-part length information.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAC@JCJFPLLE@Illegal?5TLM?5marker?5segment?5data?5@
CONST	SEGMENT
??_C@_0BAC@JCJFPLLE@Illegal?5TLM?5marker?5segment?5data?5@ DB 'Illegal TL'
	DB	'M marker segment data encountered in main header.  An illegal'
	DB	' tile number has been identified, either explicitly or implic'
	DB	'itly (through the rule that missing tile identifiers are lega'
	DB	'l only when tiles appear in order with only one tile-part eac'
	DB	'h).', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0KF@DLMNKMGF@Malformed?5TLM?5marker?5segment?5enc@
CONST	SEGMENT
??_C@_0KF@DLMNKMGF@Malformed?5TLM?5marker?5segment?5enc@ DB 'Malformed TL'
	DB	'M marker segment encountered in main header.  Segment length '
	DB	'is inconsistent with the number of bytes used to represent po'
	DB	'inter info for each tile-part.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MNLOLHMH@Illegal?5Stlm?5field?5encountered?5i@
CONST	SEGMENT
??_C@_0DG@MNLOLHMH@Illegal?5Stlm?5field?5encountered?5i@ DB 'Illegal Stlm'
	DB	' field encountered in TLM marker segment!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@FGOHBFDA@Found?5multiple?5TLM?5marker?5segmen@
CONST	SEGMENT
??_C@_0FH@FGOHBFDA@Found?5multiple?5TLM?5marker?5segmen@ DB 'Found multip'
	DB	'le TLM marker segments with identical Ztlm indices within the'
	DB	' main header!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@NPPLBJLB@TLM?5marker?5segments?5must?5be?5at?5l@
CONST	SEGMENT
??_C@_0DD@NPPLBJLB@TLM?5marker?5segments?5must?5be?5at?5l@ DB 'TLM marker'
	DB	' segments must be at least 6 bytes long!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HO@CCHNKHBP@Attempting?5to?5invoke?5?$GAkd_tlm_gen@
CONST	SEGMENT
??_C@_0HO@CCHNKHBP@Attempting?5to?5invoke?5?$GAkd_tlm_gen@ DB 'Attempting'
	DB	' to invoke `kd_tlm_generator::write_final_tlms'' with a compr'
	DB	'essed data target which does not support repositioning.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IA@FPINHJNP@Attempting?5to?5write?5TLM?5?$CItile?9pa@
CONST	SEGMENT
??_C@_0IA@FPINHJNP@Attempting?5to?5write?5TLM?5?$CItile?9pa@ DB 'Attempti'
	DB	'ng to write TLM (tile-part length) data where one tile-part'''
	DB	's length cannot be represented as an unsigned 32-bit value.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@BOACKPIA@Insufficient?5packet?5header?5data?5@
CONST	SEGMENT
??_C@_0FP@BOACKPIA@Insufficient?5packet?5header?5data?5@ DB 'Insufficient'
	DB	' packet header data in PPM marker segments, or else Nppm valu'
	DB	'es must be incorrect!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0KG@EMHBDNCD@Encountered?5malformed?5PPM?5marker@
CONST	SEGMENT
??_C@_0KG@EMHBDNCD@Encountered?5malformed?5PPM?5marker@ DB 'Encountered m'
	DB	'alformed PPM marker: 4-byte Nppm values may not straddle mult'
	DB	'iple PPM marker segments.  Problem is most likely due to a pr'
	DB	'eviously incorrect Nppm value.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CKEFAKFB@Insufficient?5packet?5header?5data?5@
CONST	SEGMENT
??_C@_0DI@CKEFAKFB@Insufficient?5packet?5header?5data?5@ DB 'Insufficient'
	DB	' packet header data in PPM marker segments!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IB@IHNJIGBG@Found?5multiple?5PPM?1PPT?5marker?5se@
CONST	SEGMENT
??_C@_0IB@IHNJIGBG@Found?5multiple?5PPM?1PPT?5marker?5se@ DB 'Found multi'
	DB	'ple PPM/PPT marker segments with identical Zppt/Zppm indices '
	DB	'within the same header scope (main or tile-part header)!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@CINALLDE@PPM?1PPT?5marker?5segments?5must?5be?5@
CONST	SEGMENT
??_C@_0DH@CINALLDE@PPM?1PPT?5marker?5segments?5must?5be?5@ DB 'PPM/PPT ma'
	DB	'rker segments must be at least 3 bytes long!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PDKABIHP@?0?5found?5in?5code?9stream?4?$AA@
CONST	SEGMENT
??_C@_0BI@PDKABIHP@?0?5found?5in?5code?9stream?4?$AA@ DB ', found in code'
	DB	'-stream.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GCHDIIBC@Unrecognized?1unimplemented?5marke@
CONST	SEGMENT
??_C@_0CJ@GCHDIIBC@Unrecognized?1unimplemented?5marke@ DB 'Unrecognized/u'
	DB	'nimplemented marker code, ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@JCNPOBGN@Encountered?5one?5or?5more?5marker?5c@
CONST	SEGMENT
??_C@_0FO@JCNPOBGN@Encountered?5one?5or?5more?5marker?5c@ DB 'Encountered'
	DB	' one or more marker codes in the range 0xFF30 to 0xFF3F.  The'
	DB	'se are to be ignored.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FBIDHMHH@Disregarding?5non?9terminal?5EOC?5ma@
CONST	SEGMENT
??_C@_0CG@FBIDHMHH@Disregarding?5non?9terminal?5EOC?5ma@ DB 'Disregarding'
	DB	' non-terminal EOC marker.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NAEOEPLF@Skipping?5over?5corrupt?5SOT?5marker@
CONST	SEGMENT
??_C@_0CH@NAEOEPLF@Skipping?5over?5corrupt?5SOT?5marker@ DB 'Skipping ove'
	DB	'r corrupt SOT marker code!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FKDCCKNG@Skipping?5over?5corrupt?5SOP?5marker@
CONST	SEGMENT
??_C@_0CH@FKDCCKNG@Skipping?5over?5corrupt?5SOP?5marker@ DB 'Skipping ove'
	DB	'r corrupt SOP marker code!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
CONST	SEGMENT
??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@ DB 'Kakadu Core Warning'
	DB	':', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0JA@OOKKCCPN@Attempting?5to?5seek?5inside?5a?5comp@
CONST	SEGMENT
??_C@_0JA@OOKKCCPN@Attempting?5to?5seek?5inside?5a?5comp@ DB 'Attempting '
	DB	'to seek inside a compressed data source which does not appear'
	DB	' to support seeking.  The source may have been implemented in'
	DB	'correctly.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0LF@EOEFHEHA@Attempting?5to?5load?5cached?5precin@
CONST	SEGMENT
??_C@_0LF@EOEFHEHA@Attempting?5to?5load?5cached?5precin@ DB 'Attempting t'
	DB	'o load cached precinct packets from a compressed data source '
	DB	'which does not appear to support caching.  It is possible tha'
	DB	't the source has been incorrectly implemented.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LF@DMBAEAHP@Attempting?5to?5load?5cached?5tile?5h@
CONST	SEGMENT
??_C@_0LF@DMBAEAHP@Attempting?5to?5load?5cached?5tile?5h@ DB 'Attempting '
	DB	'to load cached tile header data from a compressed data source'
	DB	' which does not appear to support caching.  It is possible th'
	DB	'at the source has been incorrectly implemented.', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0G@82
xdata$x	SEGMENT
__CT??_R0G@82 DD 01H
	DD	FLAT:??_R0G@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	02H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0G@8
data$r	SEGMENT
??_R0G@8 DD	FLAT:??_7type_info@@6B@			; unsigned short `RTTI Type Descriptor'
	DD	00H
	DB	'.G', 00H
data$r	ENDS
;	COMDAT __CTA1G
xdata$x	SEGMENT
__CTA1G	DD	01H
	DD	FLAT:__CT??_R0G@82
xdata$x	ENDS
;	COMDAT __TI1G
xdata$x	SEGMENT
__TI1G	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1G
xdata$x	ENDS
;	COMDAT ??_C@_01PPODPGHN@?$DO?$AA@
CONST	SEGMENT
??_C@_01PPODPGHN@?$DO?$AA@ DB '>', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MNNFJEPP@?$DM?$AA@
CONST	SEGMENT
??_C@_01MNNFJEPP@?$DM?$AA@ DB '<', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDDDDAID@0x?$AA@
CONST	SEGMENT
??_C@_02MDDDDAID@0x?$AA@ DB '0x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHNNJJKB@PPT?$AA@
CONST	SEGMENT
??_C@_03KHNNJJKB@PPT?$AA@ DB 'PPT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DMNNDALJ@PPM?$AA@
CONST	SEGMENT
??_C@_03DMNNDALJ@PPM?$AA@ DB 'PPM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LCOBMDLF@PLT?$AA@
CONST	SEGMENT
??_C@_03LCOBMDLF@PLT?$AA@ DB 'PLT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CJOBGKKN@PLM?$AA@
CONST	SEGMENT
??_C@_03CJOBGKKN@PLM?$AA@ DB 'PLM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KGIDPNPK@TLM?$AA@
CONST	SEGMENT
??_C@_03KGIDPNPK@TLM?$AA@ DB 'TLM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJALCMIF@COM?$AA@
CONST	SEGMENT
??_C@_03GJALCMIF@COM?$AA@ DB 'COM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IHBKPECM@CRG?$AA@
CONST	SEGMENT
??_C@_03IHBKPECM@CRG?$AA@ DB 'CRG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LFCEPJHK@POC?$AA@
CONST	SEGMENT
??_C@_03LFCEPJHK@POC?$AA@ DB 'POC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KEJABOAE@RGN?$AA@
CONST	SEGMENT
??_C@_03KEJABOAE@RGN?$AA@ DB 'RGN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EICGHHL@QCC?$AA@
CONST	SEGMENT
??_C@_03EICGHHL@QCC?$AA@ DB 'QCC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMDPBLM@QCD?$AA@
CONST	SEGMENT
??_C@_03ELMDPBLM@QCD?$AA@ DB 'QCD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CPEMBAGM@DFS?$AA@
CONST	SEGMENT
??_C@_03CPEMBAGM@DFS?$AA@ DB 'DFS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLBGDEDA@ADS?$AA@
CONST	SEGMENT
??_C@_03BLBGDEDA@ADS?$AA@ DB 'ADS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PHIIABAL@COC?$AA@
CONST	SEGMENT
??_C@_03PHIIABAL@COC?$AA@ DB 'COC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LIMJJHMM@COD?$AA@
CONST	SEGMENT
??_C@_03LIMJJHMM@COD?$AA@ DB 'COD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LCPIMAFA@MCO?$AA@
CONST	SEGMENT
??_C@_03LCPIMAFA@MCO?$AA@ DB 'MCO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BOENIPFM@MCC?$AA@
CONST	SEGMENT
??_C@_03BOENIPFM@MCC?$AA@ DB 'MCC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLMOALMK@MCT?$AA@
CONST	SEGMENT
??_C@_03BLMOALMK@MCT?$AA@ DB 'MCT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LABBAEJP@CBD?$AA@
CONST	SEGMENT
??_C@_03LABBAEJP@CBD?$AA@ DB 'CBD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DIBMIDDO@SIZ?$AA@
CONST	SEGMENT
??_C@_03DIBMIDDO@SIZ?$AA@ DB 'SIZ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NCODFONH@EOC?$AA@
CONST	SEGMENT
??_C@_03NCODFONH@EOC?$AA@ DB 'EOC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CGGNGDFB@EPH?$AA@
CONST	SEGMENT
??_C@_03CGGNGDFB@EPH?$AA@ DB 'EPH', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGHOBHAG@SOP?$AA@
CONST	SEGMENT
??_C@_03MGHOBHAG@SOP?$AA@ DB 'SOP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OINAMAFD@SOD?$AA@
CONST	SEGMENT
??_C@_03OINAMAFD@SOD?$AA@ DB 'SOD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCBCNCAC@SOT?$AA@
CONST	SEGMENT
??_C@_03KCBCNCAC@SOT?$AA@ DB 'SOT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHJBFGJE@SOC?$AA@
CONST	SEGMENT
??_C@_03KHJBFGJE@SOC?$AA@ DB 'SOC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KKABNIJP@Kcoeffs?$AA@
CONST	SEGMENT
??_C@_07KKABNIJP@Kcoeffs?$AA@ DB 'Kcoeffs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@PPANCHNM@Custom?5DWT?5kernel?5found?5in?5ATK?5m@
CONST	SEGMENT
??_C@_0GE@PPANCHNM@Custom?5DWT?5kernel?5found?5in?5ATK?5m@ DB 'Custom DWT'
	DB	' kernel found in ATK marker segment contains a ridiculously l'
	DB	'arge number of coefficients!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PJGAHNDG@Ksteps?$AA@
CONST	SEGMENT
??_C@_06PJGAHNDG@Ksteps?$AA@ DB 'Ksteps', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OFOCCDJH@Kreversible?$AA@
CONST	SEGMENT
??_C@_0M@OFOCCDJH@Kreversible?$AA@ DB 'Kreversible', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JOGHAEOB@Kextension?$AA@
CONST	SEGMENT
??_C@_0L@JOGHAEOB@Kextension?$AA@ DB 'Kextension', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BNGLHLNI@Ksymmetric?$AA@
CONST	SEGMENT
??_C@_0L@BNGLHLNI@Ksymmetric?$AA@ DB 'Ksymmetric', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@HPBHAILG@Unable?5to?5find?5ATK?5marker?5segmen@
CONST	SEGMENT
??_C@_0FL@HPBHAILG@Unable?5to?5find?5ATK?5marker?5segmen@ DB 'Unable to f'
	DB	'ind ATK marker segment referenced from within an COD/COC or M'
	DB	'CC marker segment.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
CONST	SEGMENT
??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@ DB 'Kakadu Core Error:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03IFCLAPBJ@ATK?$AA@
CONST	SEGMENT
??_C@_03IFCLAPBJ@ATK?$AA@ DB 'ATK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOIBNGKI@v6?41?$AA@
CONST	SEGMENT
??_C@_04GOIBNGKI@v6?41?$AA@ DB 'v6.1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7kd_pph_input@@6B@
CONST	SEGMENT
??_7kd_pph_input@@6B@ DD FLAT:??_R4kd_pph_input@@6B@	; kd_pph_input::`vftable'
	DD	FLAT:??_Ekd_pph_input@@UAEPAXI@Z
	DD	FLAT:?ignore@kd_input@@UAE_J_J@Z
	DD	FLAT:?load_buf@kd_pph_input@@MAE_NXZ
CONST	ENDS
;	COMDAT ??_7kd_compressed_input@@6B@
CONST	SEGMENT
??_7kd_compressed_input@@6B@ DD FLAT:??_R4kd_compressed_input@@6B@ ; kd_compressed_input::`vftable'
	DD	FLAT:??_Ekd_compressed_input@@UAEPAXI@Z
	DD	FLAT:?ignore@kd_compressed_input@@UAE_J_J@Z
	DD	FLAT:?load_buf@kd_compressed_input@@MAE_NXZ
CONST	ENDS
;	COMDAT ??_7kd_input@@6B@
CONST	SEGMENT
??_7kd_input@@6B@ DD FLAT:??_R4kd_input@@6B@		; kd_input::`vftable'
	DD	FLAT:??_Ekd_input@@UAEPAXI@Z
	DD	FLAT:?ignore@kd_input@@UAE_J_J@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7kd_compressed_output@@6B@
CONST	SEGMENT
??_7kd_compressed_output@@6B@ DD FLAT:??_R4kd_compressed_output@@6B@ ; kd_compressed_output::`vftable'
	DD	FLAT:??_Ekd_compressed_output@@UAEPAXI@Z
	DD	FLAT:?flush_buf@kd_compressed_output@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7kdu_thread_env@@6B@
CONST	SEGMENT
??_7kdu_thread_env@@6B@ DD FLAT:??_R4kdu_thread_env@@6B@ ; kdu_thread_env::`vftable'
	DD	FLAT:??_Ekdu_thread_env@@UAEPAXI@Z
	DD	FLAT:?new_instance@kdu_thread_env@@UAEPAVkdu_thread_entity@@XZ
	DD	FLAT:?get_num_locks@kdu_thread_env@@UAEHXZ
	DD	FLAT:?handle_exception@kdu_thread_entity@@UAEXH@Z
	DD	FLAT:?do_sync@kdu_thread_env@@MAEX_N@Z
	DD	FLAT:?need_sync@kdu_thread_env@@MAE_NXZ
	DD	FLAT:?on_finished@kdu_thread_env@@MAEX_N@Z
CONST	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0H@8
data$r	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
data$r	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
;	COMDAT ??_7kdu_thread_entity@@6B@
CONST	SEGMENT
??_7kdu_thread_entity@@6B@ DD FLAT:??_R4kdu_thread_entity@@6B@ ; kdu_thread_entity::`vftable'
	DD	FLAT:??_Ekdu_thread_entity@@UAEPAXI@Z
	DD	FLAT:?new_instance@kdu_thread_entity@@UAEPAV1@XZ
	DD	FLAT:?get_num_locks@kdu_thread_entity@@UAEHXZ
	DD	FLAT:?handle_exception@kdu_thread_entity@@UAEXH@Z
	DD	FLAT:?do_sync@kdu_thread_entity@@MAEX_N@Z
	DD	FLAT:?need_sync@kdu_thread_entity@@MAE_NXZ
	DD	FLAT:?on_finished@kdu_thread_entity@@MAEX_N@Z
CONST	ENDS
;	COMDAT ??_7kdu_output@@6B@
CONST	SEGMENT
??_7kdu_output@@6B@ DD FLAT:??_R4kdu_output@@6B@	; kdu_output::`vftable'
	DD	FLAT:??_Ekdu_output@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu?$AA@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu?$AA@ DB '%u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z$4
__ehfuncinfo$?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?read_main_header@kd_codestream@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read_main_header@kd_codestream@@AAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_main_header@kd_codestream@@AAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_main_header@kd_codestream@@AAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_main_header@kd_codestream@@AAEXXZ$6
__ehfuncinfo$?read_main_header@kd_codestream@@AAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?read_main_header@kd_codestream@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?generate_codestream@kd_codestream@@QAE_NH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?generate_codestream@kd_codestream@@QAE_NH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?generate_codestream@kd_codestream@@QAE_NH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?generate_codestream@kd_codestream@@QAE_NH@Z$2
__ehfuncinfo$?generate_codestream@kd_codestream@@QAE_NH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?generate_codestream@kd_codestream@@QAE_NH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z$0
__ehfuncinfo$?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z$0
__ehfuncinfo$?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?restart@kd_codestream@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?restart@kd_codestream@@QAEXXZ$0
__ehfuncinfo$?restart@kd_codestream@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?restart@kd_codestream@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z$2
__ehfuncinfo$?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?finalize_construction@kd_codestream@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize_construction@kd_codestream@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?finalize_construction@kd_codestream@@QAEXXZ$1
__ehfuncinfo$?finalize_construction@kd_codestream@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?finalize_construction@kd_codestream@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?construct_output_comp_info@kd_codestream@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_output_comp_info@kd_codestream@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_output_comp_info@kd_codestream@@QAEXXZ$1
__ehfuncinfo$?construct_output_comp_info@kd_codestream@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?construct_output_comp_info@kd_codestream@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?construct_common@kd_codestream@@QAEXXZ DD 019930522H
	DD	018H
	DD	FLAT:__unwindtable$?construct_common@kd_codestream@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?construct_common@kd_codestream@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$20
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$21
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$22
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$23
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$26
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kd_codestream@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1kd_codestream@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1kd_codestream@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_codestream@@QAE@XZ$0
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_codestream@@QAE@XZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_codestream@@QAE@XZ$15
	DD	03H
	DD	FLAT:__unwindfunclet$??1kd_codestream@@QAE@XZ$16
	DD	04H
	DD	FLAT:__unwindfunclet$??1kd_codestream@@QAE@XZ$17
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gkd_mct_stage@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gkd_mct_stage@@QAEPAXI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??_Gkd_mct_stage@@QAEPAXI@Z$1
__ehfuncinfo$??_Gkd_mct_stage@@QAEPAXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??_Gkd_mct_stage@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1kd_mct_stage@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_mct_stage@@QAE@XZ$0
__ehfuncinfo$??1kd_mct_stage@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1kd_mct_stage@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Ekd_mct_block@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z$0
__ehfuncinfo$?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1kd_mct_block@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_mct_block@@QAE@XZ$0
__ehfuncinfo$??1kd_mct_block@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1kd_mct_block@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Ekd_mct_ss_model@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Ekd_global_rescomp@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Ekd_global_rescomp@@QAEPAXI@Z$0
__ehfuncinfo$??_Ekd_global_rescomp@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Ekd_global_rescomp@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kd_global_rescomp@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Ekd_reslength_checker@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?next_progression@kd_packet_sequencer@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?next_progression@kd_packet_sequencer@@AAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?next_progression@kd_packet_sequencer@@AAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?next_progression@kd_packet_sequencer@@AAE_NXZ$2
__ehfuncinfo$?next_progression@kd_packet_sequencer@@AAE_NXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?next_progression@kd_packet_sequencer@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?pop_address@kd_precinct_pointer_server@@AAE_JXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?pop_address@kd_precinct_pointer_server@@AAE_JXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?pop_address@kd_precinct_pointer_server@@AAE_JXZ$1
__ehfuncinfo$?pop_address@kd_precinct_pointer_server@@AAE_JXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?pop_address@kd_precinct_pointer_server@@AAE_JXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z$0
__ehfuncinfo$?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z$3
__ehfuncinfo$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z$3
__ehfuncinfo$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z$2
__ehfuncinfo$?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z$2
__ehfuncinfo$?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z$0
__ehfuncinfo$?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ignore_tpart@kd_pp_markers@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ignore_tpart@kd_pp_markers@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ignore_tpart@kd_pp_markers@@QAEXXZ$1
__ehfuncinfo$?ignore_tpart@kd_pp_markers@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ignore_tpart@kd_pp_markers@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z$2
__ehfuncinfo$?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z$2
__ehfuncinfo$?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?read@kd_marker@@QAE_N_N0@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?read@kd_marker@@QAE_N_N0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?read@kd_marker@@QAE_N_N0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read@kd_marker@@QAE_N_N0@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read@kd_marker@@QAE_N_N0@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read@kd_marker@@QAE_N_N0@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read@kd_marker@@QAE_N_N0@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read@kd_marker@@QAE_N_N0@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?seek@kd_compressed_input@@QAEX_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?seek@kd_compressed_input@@QAEX_J@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?seek@kd_compressed_input@@QAEX_J@Z$1
__ehfuncinfo$?seek@kd_compressed_input@@QAEX_J@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?seek@kd_compressed_input@@QAEX_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z$0
__ehfuncinfo$?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z$0
__ehfuncinfo$??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gkd_compressed_output@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gkd_compressed_output@@UAEPAXI@Z$0
__ehfuncinfo$??_Gkd_compressed_output@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Gkd_compressed_output@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kd_compressed_output@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kd_buf_server@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Ekdu_thread_env@@UAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_instance@kdu_thread_env@@UAEPAVkdu_thread_entity@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_instance@kdu_thread_env@@UAEPAVkdu_thread_entity@@XZ$0
__ehfuncinfo$?new_instance@kdu_thread_env@@UAEPAVkdu_thread_entity@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_instance@kdu_thread_env@@UAEPAVkdu_thread_entity@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1kdu_thread_env@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1kdu_thread_env@@UAE@XZ$2
__ehfuncinfo$??1kdu_thread_env@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1kdu_thread_env@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0kdu_thread_env@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0kdu_thread_env@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0kdu_thread_env@@QAE@XZ$1
__ehfuncinfo$??0kdu_thread_env@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0kdu_thread_env@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z$1
__ehfuncinfo$?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z$2
__ehfuncinfo$?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?open_tile@kdu_codestream@@QAE?AVkdu_tile@@Ukdu_coords@@PAVkdu_thread_env@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open_tile@kdu_codestream@@QAE?AVkdu_tile@@Ukdu_coords@@PAVkdu_thread_env@@@Z$0
__ehfuncinfo$?open_tile@kdu_codestream@@QAE?AVkdu_tile@@Ukdu_coords@@PAVkdu_thread_env@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?open_tile@kdu_codestream@@QAE?AVkdu_tile@@Ukdu_coords@@PAVkdu_thread_env@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?change_appearance@kdu_codestream@@QAEX_N00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?change_appearance@kdu_codestream@@QAEX_N00@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?change_appearance@kdu_codestream@@QAEX_N00@Z$1
__ehfuncinfo$?change_appearance@kdu_codestream@@QAEX_N00@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?change_appearance@kdu_codestream@@QAEX_N00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z$1
__ehfuncinfo$?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?set_persistent@kdu_codestream@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?set_persistent@kdu_codestream@@QAEXXZ$0
__ehfuncinfo$?set_persistent@kdu_codestream@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?set_persistent@kdu_codestream@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?enable_restart@kdu_codestream@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?enable_restart@kdu_codestream@@QAEXXZ$0
__ehfuncinfo$?enable_restart@kdu_codestream@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?enable_restart@kdu_codestream@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?share_buffering@kdu_codestream@@QAEXV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?share_buffering@kdu_codestream@@QAEXV1@@Z$0
__ehfuncinfo$?share_buffering@kdu_codestream@@QAEXV1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?share_buffering@kdu_codestream@@QAEXV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z$1
__ehfuncinfo$?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?create@kdu_codestream@@QAEXPAVsiz_params@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?create@kdu_codestream@@QAEXPAVsiz_params@@@Z$1
__ehfuncinfo$?create@kdu_codestream@@QAEXPAVsiz_params@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?create@kdu_codestream@@QAEXPAVsiz_params@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$5
__ehfuncinfo$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?create@kdu_codestream@@QAEXPAVsiz_params@@PAVkdu_compressed_target@@PAUkdu_dims@@H_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?create@kdu_codestream@@QAEXPAVsiz_params@@PAVkdu_compressed_target@@PAUkdu_dims@@H_J@Z$2
__ehfuncinfo$?create@kdu_codestream@@QAEXPAVsiz_params@@PAVkdu_compressed_target@@PAUkdu_dims@@H_J@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?create@kdu_codestream@@QAEXPAVsiz_params@@PAVkdu_compressed_target@@PAUkdu_dims@@H_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?put_text@kdu_codestream_comment@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?put_text@kdu_codestream_comment@@QAE_NPBD@Z$0
__ehfuncinfo$?put_text@kdu_codestream_comment@@QAE_NPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?put_text@kdu_codestream_comment@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gkdu_thread_entity@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gkdu_thread_entity@@UAEPAXI@Z$1
__ehfuncinfo$??_Gkdu_thread_entity@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Gkdu_thread_entity@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?new_instance@kdu_thread_entity@@UAEPAV1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?new_instance@kdu_thread_entity@@UAEPAV1@XZ$0
__ehfuncinfo$?new_instance@kdu_thread_entity@@UAEPAV1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?new_instance@kdu_thread_entity@@UAEPAV1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kdu_thread_entity@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kdu_kernels@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?is_power_2@@YA_NH@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
?is_power_2@@YA_NH@Z PROC				; is_power_2, COMDAT

; 220  : {

	push	ebp
	mov	ebp, esp

; 221  :   for (; val > 1; val >>= 1)

	mov	eax, DWORD PTR _val$[ebp]
	cmp	eax, 1
	jle	SHORT $LN3@is_power_2
	npad	5
$LL4@is_power_2:

; 222  :     if (val & 1)

	test	al, 1
	jne	SHORT $LN8@is_power_2

; 221  :   for (; val > 1; val >>= 1)

	sar	eax, 1
	cmp	eax, 1
	jg	SHORT $LL4@is_power_2
$LN3@is_power_2:

; 224  :     return (val==1);

	xor	ecx, ecx
	cmp	eax, 1
	sete	al

; 225  : }

	pop	ebp
	ret	0
$LN8@is_power_2:

; 223  :       return false;

	xor	al, al

; 225  : }

	pop	ebp
	ret	0
?is_power_2@@YA_NH@Z ENDP				; is_power_2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z
_TEXT	SEGMENT
_e$2 = -68						; size = 20
_e$3 = -48						; size = 20
_atk_ext$4 = -28					; size = 4
tv764 = -24						; size = 4
_Ls$5 = -20						; size = 4
_atk$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$2$ = 8						; size = 4
$T6 = 8							; size = 4
$T7 = 8							; size = 4
_kernel_id$ = 8						; size = 4
_atk_idx$ = 12						; size = 4
_root$ = 16						; size = 4
_tnum$ = 20						; size = 4
_reversible$ = 24					; size = 4
_symmetric$ = 28					; size = 4
_symmetric_extension$ = 32				; size = 4
_num_steps$ = 36					; size = 4
_step_info$ = 40					; size = 4
$T8 = 44						; size = 4
$T9 = 44						; size = 4
_coefficients$ = 44					; size = 4
?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z PROC ; kd_create_dwt_description, COMDAT

; 122  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 123  :   step_info = NULL;

	mov	ecx, DWORD PTR _step_info$[ebp]

; 124  :   coefficients = NULL;

	mov	ebx, DWORD PTR _coefficients$[ebp]

; 125  :   num_steps = 0;

	mov	esi, DWORD PTR _num_steps$[ebp]

; 126  : 
; 127  :   if (kernel_id == Ckernels_ATK)

	mov	edx, DWORD PTR _kernel_id$[ebp]
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [esi], 0
	cmp	edx, -1
	jne	$LN14@kd_create_

; 128  :     { // Read kernel parameters from ATK data
; 129  :       kdu_params *atk = root->access_cluster(ATK_params);

	mov	ecx, DWORD PTR _root$[ebp]
	push	OFFSET ??_C@_03IFCLAPBJ@ATK?$AA@
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	ebx, eax
	mov	DWORD PTR _atk$1$[ebp], eax

; 130  :       if ((atk == NULL) ||

	test	ebx, ebx
	je	SHORT $LN17@kd_create_
	push	1
	push	DWORD PTR _atk_idx$[ebp]
	mov	ecx, ebx
	push	-1
	push	DWORD PTR _tnum$[ebp]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	ebx, eax
	mov	DWORD PTR _atk$1$[ebp], ebx
	test	ebx, ebx
	jne	SHORT $LN16@kd_create_
$LN17@kd_create_:

; 132  :         { KDU_ERROR(e,0x22050500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0FL@HPBHAILG@Unable?5to?5find?5ATK?5marker?5segmen@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 132  :         { KDU_ERROR(e,0x22050500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 135  :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN16@kd_create_:

; 136  :       int atk_ext;
; 137  :       if (!(atk->get(Ksymmetric,0,0,symmetric) &&

	push	1
	push	1
	push	1
	push	DWORD PTR _symmetric$[ebp]
	mov	ecx, ebx
	push	0
	push	0
	push	OFFSET ??_C@_0L@BNGLHLNI@Ksymmetric?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN19@kd_create_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _atk_ext$4[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@JOGHAEOB@Kextension?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN19@kd_create_
	push	1
	push	1
	push	1
	push	DWORD PTR _reversible$[ebp]
	mov	ecx, ebx
	push	0
	push	0
	push	OFFSET ??_C@_0M@OFOCCDJH@Kreversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
$LN19@kd_create_:

; 138  :             atk->get(Kextension,0,0,atk_ext) &&
; 139  :             atk->get(Kreversible,0,0,reversible)))
; 140  :         assert(0);
; 141  :       symmetric_extension = (atk_ext == Kextension_SYM);

	cmp	DWORD PTR _atk_ext$4[ebp], 1
	mov	eax, DWORD PTR _symmetric_extension$[ebp]

; 142  : 
; 143  :       int c, n, s, Ls, num_coeffs=0;
; 144  :       for (s=0; atk->get(Ksteps,s,0,Ls); s++)

	push	1
	sete	cl
	xor	edi, edi
	push	1
	push	1
	mov	BYTE PTR [eax], cl
	xor	esi, esi
	lea	eax, DWORD PTR _Ls$5[ebp]
	mov	ecx, ebx
	push	eax
	push	esi
	push	esi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN3@kd_create_
$LL4@kd_create_:

; 145  :         {
; 146  :           num_coeffs += Ls;

	add	edi, DWORD PTR _Ls$5[ebp]

; 147  :           if (num_coeffs > 16384)

	cmp	edi, 16384				; 00004000H
	jle	SHORT $LN2@kd_create_

; 148  :             { KDU_ERROR(e,0x06110800); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0GE@PPANCHNM@Custom?5DWT?5kernel?5found?5in?5ATK?5m@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 148  :             { KDU_ERROR(e,0x06110800); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 152  :             }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@kd_create_:

; 142  : 
; 143  :       int c, n, s, Ls, num_coeffs=0;
; 144  :       for (s=0; atk->get(Ksteps,s,0,Ls); s++)

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _Ls$5[ebp]
	inc	esi
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL4@kd_create_
$LN3@kd_create_:
	mov	eax, DWORD PTR _num_steps$[ebp]

; 155  :       step_info = new kdu_kernel_step_info[num_steps];

	xor	ecx, ecx
	mov	edx, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	eax, esi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T7[ebp], edx
	test	edx, edx
	je	SHORT $LN28@kd_create_
	test	esi, esi
	je	SHORT $LN29@kd_create_
	lea	ecx, DWORD PTR [edx+12]
	npad	6
$LL44@kd_create_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 101  :       { support_length = support_min = 0;  downshift = rounding_offset = 0; }

	mov	DWORD PTR [ecx-8], 0
	lea	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx-28], 0
	mov	DWORD PTR [ecx-16], 0
	mov	DWORD PTR [ecx-20], 0
	sub	esi, 1
	jne	SHORT $LL44@kd_create_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 155  :       step_info = new kdu_kernel_step_info[num_steps];

	jmp	SHORT $LN29@kd_create_
$LN28@kd_create_:
	xor	edx, edx
$LN29@kd_create_:
	mov	eax, DWORD PTR _step_info$[ebp]

; 156  :       coefficients = new float[num_coeffs];

	xor	ecx, ecx
	mov	DWORD PTR [eax], edx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR _coefficients$[ebp]
	add	esp, 4

; 157  :       for (c=s=0; s < num_steps; s++)

	xor	esi, esi
	mov	DWORD PTR [ecx], eax
	xor	eax, eax
	mov	ecx, DWORD PTR _num_steps$[ebp]
	mov	DWORD PTR _s$2$[ebp], eax
	cmp	DWORD PTR [ecx], eax
	jle	$LN12@kd_create_

; 155  :       step_info = new kdu_kernel_step_info[num_steps];

	xor	ecx, ecx
	mov	DWORD PTR tv764[ebp], ecx
$LL7@kd_create_:

; 157  :       for (c=s=0; s < num_steps; s++)

	mov	edx, DWORD PTR _step_info$[ebp]

; 158  :         {
; 159  :           kdu_kernel_step_info *sp = step_info + s;
; 160  :           if (!(atk->get(Ksteps,s,0,sp->support_length) &&

	push	1
	push	1
	push	1
	mov	edi, DWORD PTR [edx]
	add	edi, ecx
	mov	ecx, ebx
	push	edi
	push	0
	push	eax
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN22@kd_create_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR [edi+4]
	mov	ecx, ebx
	push	eax
	push	1
	push	DWORD PTR _s$2$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN22@kd_create_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR [edi+8]
	mov	ecx, ebx
	push	eax
	push	2
	push	DWORD PTR _s$2$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN22@kd_create_
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR [edi+12]
	mov	ecx, ebx
	push	eax
	push	3
	push	DWORD PTR _s$2$[ebp]
	push	OFFSET ??_C@_06PJGAHNDG@Ksteps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN22@kd_create_:

; 161  :                 atk->get(Ksteps,s,1,sp->support_min) &&
; 162  :                 atk->get(Ksteps,s,2,sp->downshift) &&
; 163  :                 atk->get(Ksteps,s,3,sp->rounding_offset)))
; 164  :             assert(0);
; 165  :           for (n=0; n < sp->support_length; n++, c++)

	xor	ebx, ebx
	cmp	DWORD PTR [edi], ebx
	jle	SHORT $LN5@kd_create_
$LL10@kd_create_:
	mov	eax, DWORD PTR _coefficients$[ebp]

; 166  :             atk->get(Kcoeffs,c,0,coefficients[c]);

	mov	ecx, DWORD PTR _atk$1$[ebp]
	push	1
	push	1
	mov	eax, DWORD PTR [eax]
	push	1
	lea	eax, DWORD PTR [eax+esi*4]
	push	eax
	push	0
	push	esi
	push	OFFSET ??_C@_07KKABNIJP@Kcoeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	inc	ebx
	inc	esi
	cmp	ebx, DWORD PTR [edi]
	jl	SHORT $LL10@kd_create_
$LN5@kd_create_:

; 157  :       for (c=s=0; s < num_steps; s++)

	mov	eax, DWORD PTR _s$2$[ebp]
	mov	edx, DWORD PTR _num_steps$[ebp]
	inc	eax
	mov	ecx, DWORD PTR tv764[ebp]
	mov	ebx, DWORD PTR _atk$1$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _s$2$[ebp], eax
	mov	DWORD PTR tv764[ebp], ecx
	cmp	eax, DWORD PTR [edx]
	jl	$LL7@kd_create_

; 204  :             -((step_info[n].support_length + (n & 1) - 1) >> 1);
; 205  :         }
; 206  :     }
; 207  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@kd_create_:

; 167  :         }
; 168  :       assert(c == num_coeffs);
; 169  :     }
; 170  :   else
; 171  :     { // Fill in description for Part-1 standard kernels
; 172  :       symmetric = true;

	mov	eax, DWORD PTR _symmetric$[ebp]
	mov	BYTE PTR [eax], 1

; 173  :       symmetric_extension = true;

	mov	eax, DWORD PTR _symmetric_extension$[ebp]
	mov	BYTE PTR [eax], 1

; 174  :       if (kernel_id == Ckernels_W5X3)

	cmp	edx, 1
	jne	$LN23@kd_create_

; 175  :         {
; 176  :           reversible = true;

	mov	eax, DWORD PTR _reversible$[ebp]

; 178  :           step_info = new kdu_kernel_step_info[num_steps];

	xor	ecx, ecx
	mov	BYTE PTR [eax], dl
	mov	eax, 2
	mov	edx, 16					; 00000010H
	mov	DWORD PTR [esi], 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	test	eax, eax
	je	SHORT $LN30@kd_create_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 101  :       { support_length = support_min = 0;  downshift = rounding_offset = 0; }

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+24], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 178  :           step_info = new kdu_kernel_step_info[num_steps];

	jmp	SHORT $LN31@kd_create_
$LN30@kd_create_:
	xor	eax, eax
$LN31@kd_create_:
	mov	ecx, DWORD PTR _step_info$[ebp]

; 179  :           coefficients = new float[2*num_steps];

	mov	edx, 4
	mov	DWORD PTR [ecx], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR [esi]
	add	eax, eax
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 180  :           coefficients[0] = coefficients[1] = -0.5F;
; 181  :           coefficients[2] = coefficients[3] = 0.25F;
; 182  :           step_info[0].downshift = 1;

	mov	ecx, DWORD PTR _step_info$[ebp]
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [eax+4], -1090519040		; bf000000H
	mov	DWORD PTR [eax], -1090519040		; bf000000H
	mov	DWORD PTR [eax+12], 1048576000		; 3e800000H
	mov	DWORD PTR [eax+8], 1048576000		; 3e800000H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], 1

; 183  :           step_info[1].downshift = 2;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [eax+24], 2

; 184  :           step_info[0].rounding_offset = 1;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], 1

; 185  :           step_info[1].rounding_offset = 2;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [eax+28], 2
	jmp	$LN84@kd_create_
$LN23@kd_create_:

; 186  :         }
; 187  :       else if (kernel_id == Ckernels_W9X7)

	test	edx, edx
	jne	$LN25@kd_create_

; 188  :         {
; 189  :           reversible = false;

	mov	eax, DWORD PTR _reversible$[ebp]

; 190  :           num_steps = 4;
; 191  :           step_info = new kdu_kernel_step_info[num_steps];

	xor	ecx, ecx
	mov	DWORD PTR $T8[ebp], 4
	mov	BYTE PTR [eax], dl
	mov	eax, 4
	mov	edx, 16					; 00000010H
	mov	DWORD PTR [esi], 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T6[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	edi, edi
	je	SHORT $LN32@kd_create_
	push	OFFSET ??0kdu_kernel_step_info@@QAE@XZ	; kdu_kernel_step_info::kdu_kernel_step_info
	push	4
	push	16					; 00000010H
	push	edi
	call	??_H@YGXPAXIIP6EPAX0@Z@Z
	jmp	SHORT $LN33@kd_create_
$LN32@kd_create_:
	xor	edi, edi
$LN33@kd_create_:
	mov	eax, DWORD PTR _step_info$[ebp]

; 192  :           coefficients = new float[2*num_steps];

	xor	ecx, ecx
	mov	edx, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [eax], edi
	mov	eax, DWORD PTR [esi]
	add	eax, eax
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR _step_info$[ebp]
	mov	DWORD PTR [ebx], eax

; 193  :           coefficients[0] = coefficients[1] = (float) -1.586134342;

	mov	DWORD PTR [eax+4], -1077213581		; bfcb0673H
	mov	DWORD PTR [eax], -1077213581		; bfcb0673H

; 194  :           coefficients[2] = coefficients[3] = (float) -0.052980118;

	mov	DWORD PTR [eax+12], -1118240338		; bd5901aeH
	mov	DWORD PTR [eax+8], -1118240338		; bd5901aeH

; 195  :           coefficients[4] = coefficients[5] = (float)  0.882911075;

	mov	DWORD PTR [eax+20], 1063388790		; 3f620676H
	mov	DWORD PTR [eax+16], 1063388790		; 3f620676H

; 196  :           coefficients[6] = coefficients[7] = (float)  0.443506852;

	mov	DWORD PTR [eax+28], 1055069013		; 3ee31355H
	mov	DWORD PTR [eax+24], 1055069013		; 3ee31355H
$LN84@kd_create_:

; 192  :           coefficients = new float[2*num_steps];

	add	esp, 4
$LN25@kd_create_:

; 197  :         }
; 198  :       else
; 199  :         assert(0);
; 200  :       for (int n=0; n < num_steps; n++)

	xor	edi, edi
	cmp	DWORD PTR [esi], edi
	jle	SHORT $LN12@kd_create_
	xor	esi, esi
	npad	7
$LL13@kd_create_:

; 201  :         {
; 202  :           step_info[n].support_length = 2;

	mov	eax, DWORD PTR [ecx]
	lea	esi, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+eax-16], 2

; 203  :           step_info[n].support_min =

	mov	edx, DWORD PTR [ecx]
	mov	ecx, edi
	and	ecx, 1
	inc	edi
	dec	ecx
	mov	eax, DWORD PTR [esi+edx-16]
	add	eax, ecx
	mov	ecx, DWORD PTR _step_info$[ebp]
	sar	eax, 1
	neg	eax
	mov	DWORD PTR [esi+edx-12], eax
	mov	eax, DWORD PTR _num_steps$[ebp]
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL13@kd_create_
$LN12@kd_create_:

; 204  :             -((step_info[n].support_length + (n & 1) - 1) >> 1);
; 205  :         }
; 206  :     }
; 207  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z$4:
	xor	ebx, ebx
	mov	eax, DWORD PTR $T8[ebp]
	mov	ecx, 16					; 00000010H
	mul	ecx
	seto	bl
	neg	ebx
	or	ebx, eax
	push	ebx
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
__ehhandler$?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z ENDP ; kd_create_dwt_description
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_thread_env@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_thread_env@@QAEPAXI@Z PROC			; kd_thread_env::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+136]
	call	??1kdu_block@@AAE@XZ			; kdu_block::~kdu_block
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	33560					; 00008318H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_thread_env@@QAEPAXI@Z ENDP			; kd_thread_env::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1kd_thread_env@@QAE@XZ
_TEXT	SEGMENT
??1kd_thread_env@@QAE@XZ PROC				; kd_thread_env::~kd_thread_env, COMDAT
; _this$ = ecx
	add	ecx, 136				; 00000088H
	jmp	??1kdu_block@@AAE@XZ			; kdu_block::~kdu_block
??1kd_thread_env@@QAE@XZ ENDP				; kd_thread_env::~kd_thread_env
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?discard_all@kd_thread_env@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?discard_all@kd_thread_env@@QAEXXZ PROC			; kd_thread_env::discard_all, COMDAT
; _this$ = ecx

; 2256 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 2257 :   if ((num_outstanding_blocks > 0) || buf_server.is_attached())

	cmp	DWORD PTR [ebx+33168], 0
	jg	SHORT $LN6@discard_al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 353  :     bool is_attached() { return (ultimate_buf_server != NULL); }

	cmp	DWORD PTR [ebx+33156], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2257 :   if ((num_outstanding_blocks > 0) || buf_server.is_attached())

	je	$LN35@discard_al
$LN6@discard_al:
	push	esi

; 2258 :     {
; 2259 :       int n;
; 2260 :       kd_thread_block_state *scan;
; 2261 :       owner->acquire_lock(KD_THREADLOCK_GENERAL,false);

	mov	esi, DWORD PTR [ebx+128]
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1024 :       { kd_thread_lock *lock = locks + lock_id;

	mov	edi, DWORD PTR [esi+28]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN17@discard_al
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN17@discard_al:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+4], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2262 :       for (scan=outstanding_blocks,

	lea	esi, DWORD PTR [ebx+33172]

; 2263 :            n=KD_THREAD_MAX_OUTSTANDING_BLOCKS; n > 0; n--, scan++)

	mov	edi, 8
$LL4@discard_al:

; 2264 :         {
; 2265 :           if (scan->target_precinct == NULL)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN2@discard_al

; 2266 :             continue;
; 2267 :           kd_codestream *cs = scan->target_precinct->resolution->codestream;

	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax]

; 2268 :           scan->target_precinct = NULL;

	mov	DWORD PTR [esi+24], 0

; 2269 :           scan->target_block = NULL;

	mov	DWORD PTR [esi+28], 0

; 2270 :           scan->block.cleanup(cs->buf_server);

	mov	ebx, DWORD PTR [eax+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3609 :         while ((current_buf=first_buf) != NULL)

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	je	SHORT $LN22@discard_al
	npad	3
$LL21@discard_al:

; 3610 :           { first_buf=current_buf->next;  buf_server->release(current_buf); }

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	mov	eax, DWORD PTR [ecx]
	mov	ecx, ebx
	mov	DWORD PTR [esi], eax
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	jne	SHORT $LL21@discard_al
$LN22@discard_al:

; 3611 :         set_discard(); // Discard from any packets parsed in the future
; 3612 :       }
; 3613 :     kd_code_buffer *cleanup()
; 3614 :       { // As above, but returns the linked list of buffers
; 3615 :         kd_code_buffer *result = first_buf;  first_buf = current_buf = NULL;
; 3616 :         set_discard();
; 3617 :         return result;
; 3618 :       }
; 3619 : 
; 3620 :   // --------------------------------------------------------------------------
; 3621 :   public: // Packet manipulation member functions
; 3622 :     int parse_packet_header(kd_header_in &head, kd_buf_server *buf_server,
; 3623 :                             int layer_idx); // Throws (kdu_uint16 code)
; 3624 :       /* Parses bits in the packet header corresponding to the current
; 3625 :          block for the current layer (this must be the next layer for which
; 3626 :          information has not yet been parsed).  The function returns the
; 3627 :          number of new body bytes contributed by the code-block in this layer
; 3628 :          and also stores this value internally to be used in subsequent calls
; 3629 :          to the `read_body_bytes' member function.
; 3630 :             The `kd_header_in' object may throw an exception if the packet
; 3631 :          data terminates unexpectedly.  Moreover, to assist in locating and
; 3632 :          possibly recovering from errors, the present function may throw a
; 3633 :          16-bit unsigned integer exception code, which is either the value of
; 3634 :          an illegal marker code encountered in the packet header, or one of
; 3635 :          the special exception codes, KDU_EXCEPTION_PRECISION or
; 3636 :          KDU_EXCEPTION_ILLEGAL_LAYER. */
; 3637 :     void read_body_bytes(kd_input *source, kd_buf_server *buf_server,
; 3638 :                          bool in_memory_source)
; 3639 :       { /* This function should be called after parsing the header of a
; 3640 :            packet.  It reads the code-bytes contributed by the code-block to
; 3641 :            this packet.  If `in_memory_source' is true, only the address of
; 3642 :            the code-bytes is recorded, and then only if the length of the
; 3643 :            code-byte segment is non-zero. */
; 3644 :         if (this->temp_length > 0)
; 3645 :           {
; 3646 :             if (num_passes == 255)
; 3647 :               { // Read and discard the code-bytes.
; 3648 :                 assert(first_buf == NULL);  source->ignore(this->temp_length);
; 3649 :               }
; 3650 :             else if (in_memory_source)
; 3651 :               {
; 3652 :                 kdu_byte *addr;
; 3653 :                 this->num_bytes += source->pseudo_read(addr,this->temp_length);
; 3654 :                 put_address(addr,buf_server);
; 3655 :               }
; 3656 :             else
; 3657 :               this->num_bytes +=
; 3658 :                 source->read(current_buf,buf_pos,buf_server,this->temp_length);
; 3659 :             this->temp_length = 0;
; 3660 :           }
; 3661 :       }
; 3662 :     void retrieve_data(kdu_block *block, int max_layers, int discard_passes,
; 3663 :                        bool in_memory_source);
; 3664 :       /* Retrieves compressed code-bytes, number of coding passes and codeword
; 3665 :          segment lengths from the current code-block and stores them in the
; 3666 :          `block' object.  All fields which are common for compression and
; 3667 :          decompression have already been filled out by the caller.  The
; 3668 :          byte buffer is allocated so as to be large enough to allow a
; 3669 :          2 byte marker code to be appended to the compressed data,
; 3670 :          if desired -- see declaration of "kdu_subband::open_block".
; 3671 :             The `max_layers' argument identifies the maximum number of
; 3672 :          quality layers for which code-block contributions are to be
; 3673 :          retrieved.
; 3674 :             The `discard_passes' argument indicates the number of additional
; 3675 :          coding passes to be removed, if any.
; 3676 :             If `in_memory_source' is true, the layer code bytes are not
; 3677 :          stored in the `kd_code_buffer' list embedded inside `block'.  Instead,
; 3678 :          the `kd_code_buffer' list stores only the header information for
; 3679 :          each layer, along with the address of the code bytes, which reside
; 3680 :          in the memory block managed by an in-memory compressed data source
; 3681 :          (one which offers the `KDU_SOURCE_CAP_IN_MEMORY') capability.  In
; 3682 :          this case, we retrieve the address and then perform a simple memory
; 3683 :          block copy operation to efficiently retrieve the code bytes for
; 3684 :          each layer. */
; 3685 :     void store_data(kdu_block *block, kd_buf_server *buf_server);
; 3686 :       /* Stores compressed code-bytes, pass length and pass slope information
; 3687 :          from the `block' object into the current code-block.  This function
; 3688 :          is invoked by "kdu_subband::close_block" when the containing
; 3689 :          codestream object was not constructed for input.  Also reflects
; 3690 :          the `msbs_w' value into higher nodes in the tag tree. */
; 3691 :     void store_data(kdu_block *block, kd_thread_buf_server *thread_buf_server);
; 3692 :       /* Same as the above function, but uses `kd_thread_buf_server::get'
; 3693 :          rather than `kd_buf_server::get' to get new code buffers.  This
; 3694 :          version is used to save code-block state in multi-threaded
; 3695 :          environments so as to minimize cache coherency bottlenecks and the
; 3696 :          need to lock shared resources. */
; 3697 :     void transfer_data(kd_block &src)
; 3698 :       { /* Like `store_data', but gets results from another block.  Exploits
; 3699 :            the layout of the object to copy only whole pointers or whole
; 3700 :            32-bit words, even where these represent multiple fields. */
; 3701 :         current_buf = first_buf = src.first_buf;
; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);
; 3703 :         src.current_buf = src.first_buf = NULL;
; 3704 :       }
; 3705 :     bool trim_data(kdu_uint16 slope_threshold, kd_buf_server *buf_server);
; 3706 :       /* This function serves two purposes: it helps reduce the amount of
; 3707 :          compressed data which must be buffered in memory while compressing
; 3708 :          an image; and it allows individual block contributions to be
; 3709 :          discarded during packet construction in order to tightly fit the
; 3710 :          generated bit-rate to the target compressed bit-rate.
; 3711 :             The function sets all coding pass slopes which are less than or
; 3712 :          equal to the supplied slope threshold to 0 and then discards all
; 3713 :          code bytes which could not possibly be included in the final
; 3714 :          code-stream, as a result of this modification.
; 3715 :             If anything was discarded, the function returns true.  Otherwise,
; 3716 :          it returns false. */
; 3717 :     int start_packet(int layer_idx, kdu_uint16 slope_threshold);
; 3718 :       /* Call this function only during rate allocation or packet generation.
; 3719 :          Before the first call to this function, you must reset the tag tree
; 3720 :          (see the "reset_output_tree" member function).  If you are calling
; 3721 :          the function multiple times with the same layer for rate allocation
; 3722 :          purposes, you must use "save_output_tree" and "restore_output_tree"
; 3723 :          as described below.
; 3724 :             The function leaves behind information about the number of new
; 3725 :          coding passes and the number of new code bytes which would be
; 3726 :          contributed by this code-block if the supplied threshold were actually
; 3727 :          used.  The final contributing coding pass must have a non-zero
; 3728 :          distortion-length slope which is strictly greater than the slope
; 3729 :          threshold.  It also updates the tag tree structure to reflect any
; 3730 :          new knowledge about the first layer to which this code-block would
; 3731 :          contribute.  This information is picked up by "write_packet_header".
; 3732 :             The function's return value is the total number of new code-bytes
; 3733 :          contributed by the block.  This allows the PCRD-opt algorithm to
; 3734 :          determine roughly the right slope threshold before committing to the
; 3735 :          work of simulating packet header generation. */
; 3736 :     void write_packet_header(kd_header_out &head, int layer_idx,
; 3737 :                              bool simulate);
; 3738 :       /* Call this function only after a `start_packet' call.  It writes
; 3739 :          (or simulates the writing of) packet header information corresponding
; 3740 :          to the code-block inclusion information set up by `start_packet'.
; 3741 :          If `simulate' is true, some internal state adjustments are delayed
; 3742 :          until the next call to "save_output_tree", so multiple calls to
; 3743 :          "start_packet" and "write_packet_header" may be issued with the same
; 3744 :          layer index to determine an optimal slope threshold.  Otherwise,
; 3745 :          if `simulate' is false, the internal state information is fully
; 3746 :          updated and the "save_output_tree" and "restore_output_tree" functions
; 3747 :          need not and should not be called. */
; 3748 :     void write_body_bytes(kdu_output *dest);
; 3749 :       /* This function should be called after a non-simulated
; 3750 :          "write_packet_header" call to output the newly included body bytes.
; 3751 :          The actual number of bytes to be written was left behind by
; 3752 :          the preceding "start_packet" call in the `temp_length' field. */
; 3753 :   // --------------------------------------------------------------------------
; 3754 :   public: // Static functions used to operate on tag-trees built from kd_block
; 3755 :     static kd_block *build_tree(kdu_coords size, kdu_byte * &mem_block);
; 3756 :       /* Builds a full tag tree returning a pointer to the upper left hand
; 3757 :          corner leaf node.  Apart from the `up_down' navigation pointers,
; 3758 :          all fields are initialized to 0.  This is appropriate for tag tree
; 3759 :          decoding, but encoders will need to call "reset_output_tree" and
; 3760 :          use "start_packet" to install appropriate node values.
; 3761 :             The tag tree is not allocated from the heap.  Instead, it is
; 3762 :          allocated from an existing memory block, identified by the `mem_block'
; 3763 :          argument.  This memory block is assumed to be large enough to hold
; 3764 :          the array of `kd_block' structures.  Upon return, the `mem_block'
; 3765 :          value is advanced by an amount equal to the size of the tag tree
; 3766 :          array. */
; 3767 :     static void reset_output_tree(kd_block *tree, kdu_coords size);
; 3768 :       /* Call this function immediately before simulating or actually
; 3769 :          generating any packet data for the relevant code-blocks.  Once
; 3770 :          the PCRD-opt algorithm has completed, you should call this function
; 3771 :          a second time to prepare for actual packet output.  The function
; 3772 :          initializes the threshold state variables, `layer_w_bar' and
; 3773 :          `msbs_w_bar' to 0, and the value state variables, `layer_w' and
; 3774 :          `msbs_w' to their maximum representable values.  The succession of
; 3775 :          "start_packet" calls will update the value variables `layer_w'
; 3776 :          and `msbs_w' in such a way that the tag tree coding process runs
; 3777 :          correctly in each subsequent call to "write_packet_header". */
; 3778 :     static void save_output_tree(kd_block *tree, kdu_coords size);
; 3779 :       /* Call this only during rate allocation, before moving on to a new
; 3780 :          layer.  The function saves the current state (`msbs_wbar' and
; 3781 :          `layer_wbar') of each node in the tag tree.  For leaf nodes, it also
; 3782 :          commits the number of new coding passes found in the last call to
; 3783 :          "start_packet". */
; 3784 :     static void restore_output_tree(kd_block *tree, kdu_coords size);
; 3785 :       /* Call this during rate allocation before supplying a new slope
; 3786 :          threshold for the same layer index, in a new "start_packet" call.
; 3787 :          The function restores the `msbs_w_bar' and `layer_w_bar' values
; 3788 :          previously saved by "save_output_tree". */
; 3789 :   // --------------------------------------------------------------------------
; 3790 :   public: // State identification functions
; 3791 :     void set_discard()
; 3792 :       { /* Use this function only with input-oriented operations.  It informs
; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;

	mov	BYTE PTR [esi+10], 255			; 000000ffH
$LN2@discard_al:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2263 :            n=KD_THREAD_MAX_OUTSTANDING_BLOCKS; n > 0; n--, scan++)

	dec	edi
	add	esi, 32					; 00000020H
	test	edi, edi
	jg	SHORT $LL4@discard_al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 353  :     bool is_attached() { return (ultimate_buf_server != NULL); }

	mov	ebx, DWORD PTR _this$1$[ebp]
	pop	edi
	pop	esi
	cmp	DWORD PTR [ebx+33156], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2272 :       if (buf_server.is_attached())

	je	SHORT $LN29@discard_al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 359  :         if (ultimate_buf_server != NULL)

	mov	ecx, DWORD PTR [ebx+33156]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2273 :         buf_server.detach_while_holding_general_lock();

	lea	eax, DWORD PTR [ebx+33132]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 359  :         if (ultimate_buf_server != NULL)

	test	ecx, ecx
	je	SHORT $LN29@discard_al

; 360  :           ultimate_buf_server->detach_thread_buf_server(this);

	push	eax
	call	?detach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z ; kd_buf_server::detach_thread_buf_server
$LN29@discard_al:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [ebx+128]
	mov	eax, DWORD PTR [eax+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN35@discard_al
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN35@discard_al:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2277 :   owner->have_outstanding_blocks = false;

	mov	eax, DWORD PTR [ebx+128]
	mov	DWORD PTR [ebx+33168], 0
	pop	ebx
	mov	BYTE PTR [eax+44], 0

; 2278 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?discard_all@kd_thread_env@@QAEXXZ ENDP			; kd_thread_env::discard_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?flush@kd_thread_env@@QAEX_N@Z
_TEXT	SEGMENT
_lock$1$ = -8						; size = 4
_this$1$ = -8						; size = 4
_have_only_input_precincts$1$ = -1			; size = 1
_lock$1$ = 8						; size = 4
_cs$1$ = 8						; size = 4
$T1 = 8							; size = 4
$T2 = 8							; size = 4
$T3 = 8							; size = 4
_force_flush$ = 8					; size = 1
?flush@kd_thread_env@@QAEX_N@Z PROC			; kd_thread_env::flush, COMDAT
; _this$ = ecx

; 2172 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	edi
	mov	edi, ecx

; 2173 :   if (num_outstanding_blocks == 0)

	cmp	DWORD PTR [edi+33168], 0
	je	$LN68@flush

; 2174 :     return;
; 2175 : 
; 2176 :   if (stats_codestream != NULL)

	cmp	DWORD PTR [edi+33128], 0
	je	SHORT $LN9@flush

; 2177 :     reconcile_stats();

	call	?reconcile_stats@kd_thread_env@@QAEXXZ	; kd_thread_env::reconcile_stats
$LN9@flush:

; 2178 :   
; 2179 :   // Now try to flush stored code-blocks
; 2180 :   int n;
; 2181 :   kd_thread_block_state *scan;
; 2182 :   bool have_complete_precincts=false;
; 2183 :   owner->acquire_lock(KD_THREADLOCK_PRECINCT);

	mov	eax, DWORD PTR [edi+128]
	push	ebx
	xor	bl, bl
	mov	DWORD PTR _this$1$[ebp], eax
	push	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	ecx, DWORD PTR [eax+20]
	mov	esi, DWORD PTR [eax+28]
	cmp	BYTE PTR [ecx], bl
	jne	$LN114@flush
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx
	je	SHORT $LN32@flush
	push	-1
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	eax, DWORD PTR _this$1$[ebp]
$LN32@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [esi+20], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2184 :   bool have_only_input_precincts = true;

	mov	bh, 1

; 2185 :   for (scan=outstanding_blocks,
; 2186 :        n=KD_THREAD_MAX_OUTSTANDING_BLOCKS; n > 0; n--, scan++)
; 2187 :     {
; 2188 :       if (scan->target_precinct == NULL)

	mov	eax, DWORD PTR [edi+33196]
	lea	esi, DWORD PTR [edi+33172]
	mov	BYTE PTR _have_only_input_precincts$1$[ebp], bh
	test	eax, eax
	je	SHORT $LN2@flush

; 2191 :       assert(scan->target_precinct->num_outstanding_blocks > 0);
; 2192 :       if (scan->target_precinct->num_outstanding_blocks == 1)

	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN11@flush

; 2193 :         {
; 2194 :           have_complete_precincts=true;

	mov	bl, bh

; 2195 :           continue;

	jmp	SHORT $LN2@flush
$LN11@flush:

; 2189 :         continue;
; 2190 :       kd_codestream *cs = scan->target_precinct->resolution->codestream;

	mov	eax, DWORD PTR [eax]

; 2196 :         }
; 2197 :       if (cs->in == NULL)

	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN12@flush

; 2198 :         {
; 2199 :           scan->target_block->transfer_data(scan->block);

	mov	ecx, DWORD PTR [esi+28]

; 2200 :           have_only_input_precincts = false;

	xor	bh, bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	eax, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2200 :           have_only_input_precincts = false;

	mov	BYTE PTR _have_only_input_precincts$1$[ebp], bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], eax

; 3703 :         src.current_buf = src.first_buf = NULL;

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
$LN12@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2202 :       scan->target_precinct->num_outstanding_blocks--;

	mov	eax, DWORD PTR [esi+24]
	dec	DWORD PTR [eax+24]

; 2203 :       scan->target_precinct = NULL;

	mov	DWORD PTR [esi+24], 0

; 2204 :       scan->target_block = NULL;

	mov	DWORD PTR [esi+28], 0

; 2205 :       num_outstanding_blocks--;

	dec	DWORD PTR [edi+33168]
$LN2@flush:

; 2185 :   for (scan=outstanding_blocks,
; 2186 :        n=KD_THREAD_MAX_OUTSTANDING_BLOCKS; n > 0; n--, scan++)
; 2187 :     {
; 2188 :       if (scan->target_precinct == NULL)

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN84@flush

; 2191 :       assert(scan->target_precinct->num_outstanding_blocks > 0);
; 2192 :       if (scan->target_precinct->num_outstanding_blocks == 1)

	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN82@flush

; 2193 :         {
; 2194 :           have_complete_precincts=true;

	mov	bl, 1

; 2195 :           continue;

	jmp	SHORT $LN84@flush
$LN82@flush:

; 2189 :         continue;
; 2190 :       kd_codestream *cs = scan->target_precinct->resolution->codestream;

	mov	eax, DWORD PTR [eax]

; 2196 :         }
; 2197 :       if (cs->in == NULL)

	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN83@flush

; 2198 :         {
; 2199 :           scan->target_block->transfer_data(scan->block);

	mov	ecx, DWORD PTR [esi+60]

; 2200 :           have_only_input_precincts = false;

	xor	bh, bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	eax, DWORD PTR [esi+32]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2200 :           have_only_input_precincts = false;

	mov	BYTE PTR _have_only_input_precincts$1$[ebp], bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [ecx+8], eax

; 3703 :         src.current_buf = src.first_buf = NULL;

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
$LN83@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2202 :       scan->target_precinct->num_outstanding_blocks--;

	mov	eax, DWORD PTR [esi+56]
	dec	DWORD PTR [eax+24]

; 2203 :       scan->target_precinct = NULL;

	mov	DWORD PTR [esi+56], 0

; 2204 :       scan->target_block = NULL;

	mov	DWORD PTR [esi+60], 0

; 2205 :       num_outstanding_blocks--;

	dec	DWORD PTR [edi+33168]
$LN84@flush:

; 2185 :   for (scan=outstanding_blocks,
; 2186 :        n=KD_THREAD_MAX_OUTSTANDING_BLOCKS; n > 0; n--, scan++)
; 2187 :     {
; 2188 :       if (scan->target_precinct == NULL)

	mov	eax, DWORD PTR [esi+88]
	test	eax, eax
	je	SHORT $LN88@flush

; 2191 :       assert(scan->target_precinct->num_outstanding_blocks > 0);
; 2192 :       if (scan->target_precinct->num_outstanding_blocks == 1)

	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN86@flush

; 2193 :         {
; 2194 :           have_complete_precincts=true;

	mov	bl, 1

; 2195 :           continue;

	jmp	SHORT $LN88@flush
$LN86@flush:

; 2189 :         continue;
; 2190 :       kd_codestream *cs = scan->target_precinct->resolution->codestream;

	mov	eax, DWORD PTR [eax]

; 2196 :         }
; 2197 :       if (cs->in == NULL)

	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN87@flush

; 2198 :         {
; 2199 :           scan->target_block->transfer_data(scan->block);

	mov	ecx, DWORD PTR [esi+92]

; 2200 :           have_only_input_precincts = false;

	xor	bh, bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	eax, DWORD PTR [esi+64]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2200 :           have_only_input_precincts = false;

	mov	BYTE PTR _have_only_input_precincts$1$[ebp], bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);

	mov	eax, DWORD PTR [esi+72]
	mov	DWORD PTR [ecx+8], eax

; 3703 :         src.current_buf = src.first_buf = NULL;

	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0
$LN87@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2202 :       scan->target_precinct->num_outstanding_blocks--;

	mov	eax, DWORD PTR [esi+88]
	dec	DWORD PTR [eax+24]

; 2203 :       scan->target_precinct = NULL;

	mov	DWORD PTR [esi+88], 0

; 2204 :       scan->target_block = NULL;

	mov	DWORD PTR [esi+92], 0

; 2205 :       num_outstanding_blocks--;

	dec	DWORD PTR [edi+33168]
$LN88@flush:

; 2185 :   for (scan=outstanding_blocks,
; 2186 :        n=KD_THREAD_MAX_OUTSTANDING_BLOCKS; n > 0; n--, scan++)
; 2187 :     {
; 2188 :       if (scan->target_precinct == NULL)

	mov	eax, DWORD PTR [esi+120]
	test	eax, eax
	je	SHORT $LN92@flush

; 2191 :       assert(scan->target_precinct->num_outstanding_blocks > 0);
; 2192 :       if (scan->target_precinct->num_outstanding_blocks == 1)

	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN90@flush

; 2193 :         {
; 2194 :           have_complete_precincts=true;

	mov	bl, 1

; 2195 :           continue;

	jmp	SHORT $LN92@flush
$LN90@flush:

; 2189 :         continue;
; 2190 :       kd_codestream *cs = scan->target_precinct->resolution->codestream;

	mov	eax, DWORD PTR [eax]

; 2196 :         }
; 2197 :       if (cs->in == NULL)

	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN91@flush

; 2198 :         {
; 2199 :           scan->target_block->transfer_data(scan->block);

	mov	ecx, DWORD PTR [esi+124]

; 2200 :           have_only_input_precincts = false;

	xor	bh, bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	eax, DWORD PTR [esi+96]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2200 :           have_only_input_precincts = false;

	mov	BYTE PTR _have_only_input_precincts$1$[ebp], bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);

	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR [ecx+8], eax

; 3703 :         src.current_buf = src.first_buf = NULL;

	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+100], 0
$LN91@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2202 :       scan->target_precinct->num_outstanding_blocks--;

	mov	eax, DWORD PTR [esi+120]
	dec	DWORD PTR [eax+24]

; 2203 :       scan->target_precinct = NULL;

	mov	DWORD PTR [esi+120], 0

; 2204 :       scan->target_block = NULL;

	mov	DWORD PTR [esi+124], 0

; 2205 :       num_outstanding_blocks--;

	dec	DWORD PTR [edi+33168]
$LN92@flush:

; 2185 :   for (scan=outstanding_blocks,
; 2186 :        n=KD_THREAD_MAX_OUTSTANDING_BLOCKS; n > 0; n--, scan++)
; 2187 :     {
; 2188 :       if (scan->target_precinct == NULL)

	mov	eax, DWORD PTR [esi+152]
	test	eax, eax
	je	SHORT $LN96@flush

; 2191 :       assert(scan->target_precinct->num_outstanding_blocks > 0);
; 2192 :       if (scan->target_precinct->num_outstanding_blocks == 1)

	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN94@flush

; 2193 :         {
; 2194 :           have_complete_precincts=true;

	mov	bl, 1

; 2195 :           continue;

	jmp	SHORT $LN96@flush
$LN94@flush:

; 2189 :         continue;
; 2190 :       kd_codestream *cs = scan->target_precinct->resolution->codestream;

	mov	eax, DWORD PTR [eax]

; 2196 :         }
; 2197 :       if (cs->in == NULL)

	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN95@flush

; 2198 :         {
; 2199 :           scan->target_block->transfer_data(scan->block);

	mov	ecx, DWORD PTR [esi+156]

; 2200 :           have_only_input_precincts = false;

	xor	bh, bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	eax, DWORD PTR [esi+128]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2200 :           have_only_input_precincts = false;

	mov	BYTE PTR _have_only_input_precincts$1$[ebp], bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);

	mov	eax, DWORD PTR [esi+136]
	mov	DWORD PTR [ecx+8], eax

; 3703 :         src.current_buf = src.first_buf = NULL;

	mov	DWORD PTR [esi+128], 0
	mov	DWORD PTR [esi+132], 0
$LN95@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2202 :       scan->target_precinct->num_outstanding_blocks--;

	mov	eax, DWORD PTR [esi+152]
	dec	DWORD PTR [eax+24]

; 2203 :       scan->target_precinct = NULL;

	mov	DWORD PTR [esi+152], 0

; 2204 :       scan->target_block = NULL;

	mov	DWORD PTR [esi+156], 0

; 2205 :       num_outstanding_blocks--;

	dec	DWORD PTR [edi+33168]
$LN96@flush:

; 2185 :   for (scan=outstanding_blocks,
; 2186 :        n=KD_THREAD_MAX_OUTSTANDING_BLOCKS; n > 0; n--, scan++)
; 2187 :     {
; 2188 :       if (scan->target_precinct == NULL)

	mov	eax, DWORD PTR [esi+184]
	test	eax, eax
	je	SHORT $LN100@flush

; 2191 :       assert(scan->target_precinct->num_outstanding_blocks > 0);
; 2192 :       if (scan->target_precinct->num_outstanding_blocks == 1)

	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN98@flush

; 2193 :         {
; 2194 :           have_complete_precincts=true;

	mov	bl, 1

; 2195 :           continue;

	jmp	SHORT $LN100@flush
$LN98@flush:

; 2189 :         continue;
; 2190 :       kd_codestream *cs = scan->target_precinct->resolution->codestream;

	mov	eax, DWORD PTR [eax]

; 2196 :         }
; 2197 :       if (cs->in == NULL)

	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN99@flush

; 2198 :         {
; 2199 :           scan->target_block->transfer_data(scan->block);

	mov	ecx, DWORD PTR [esi+188]

; 2200 :           have_only_input_precincts = false;

	xor	bh, bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	eax, DWORD PTR [esi+160]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2200 :           have_only_input_precincts = false;

	mov	BYTE PTR _have_only_input_precincts$1$[ebp], bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);

	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [ecx+8], eax

; 3703 :         src.current_buf = src.first_buf = NULL;

	mov	DWORD PTR [esi+160], 0
	mov	DWORD PTR [esi+164], 0
$LN99@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2202 :       scan->target_precinct->num_outstanding_blocks--;

	mov	eax, DWORD PTR [esi+184]
	dec	DWORD PTR [eax+24]

; 2203 :       scan->target_precinct = NULL;

	mov	DWORD PTR [esi+184], 0

; 2204 :       scan->target_block = NULL;

	mov	DWORD PTR [esi+188], 0

; 2205 :       num_outstanding_blocks--;

	dec	DWORD PTR [edi+33168]
$LN100@flush:

; 2185 :   for (scan=outstanding_blocks,
; 2186 :        n=KD_THREAD_MAX_OUTSTANDING_BLOCKS; n > 0; n--, scan++)
; 2187 :     {
; 2188 :       if (scan->target_precinct == NULL)

	mov	eax, DWORD PTR [esi+216]
	test	eax, eax
	je	SHORT $LN104@flush

; 2191 :       assert(scan->target_precinct->num_outstanding_blocks > 0);
; 2192 :       if (scan->target_precinct->num_outstanding_blocks == 1)

	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN102@flush

; 2193 :         {
; 2194 :           have_complete_precincts=true;

	mov	bl, 1

; 2195 :           continue;

	jmp	SHORT $LN104@flush
$LN102@flush:

; 2189 :         continue;
; 2190 :       kd_codestream *cs = scan->target_precinct->resolution->codestream;

	mov	eax, DWORD PTR [eax]

; 2196 :         }
; 2197 :       if (cs->in == NULL)

	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN103@flush

; 2198 :         {
; 2199 :           scan->target_block->transfer_data(scan->block);

	mov	ecx, DWORD PTR [esi+220]

; 2200 :           have_only_input_precincts = false;

	xor	bh, bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	eax, DWORD PTR [esi+192]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2200 :           have_only_input_precincts = false;

	mov	BYTE PTR _have_only_input_precincts$1$[ebp], bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);

	mov	eax, DWORD PTR [esi+200]
	mov	DWORD PTR [ecx+8], eax

; 3703 :         src.current_buf = src.first_buf = NULL;

	mov	DWORD PTR [esi+192], 0
	mov	DWORD PTR [esi+196], 0
$LN103@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2202 :       scan->target_precinct->num_outstanding_blocks--;

	mov	eax, DWORD PTR [esi+216]
	dec	DWORD PTR [eax+24]

; 2203 :       scan->target_precinct = NULL;

	mov	DWORD PTR [esi+216], 0

; 2204 :       scan->target_block = NULL;

	mov	DWORD PTR [esi+220], 0

; 2205 :       num_outstanding_blocks--;

	dec	DWORD PTR [edi+33168]
$LN104@flush:

; 2185 :   for (scan=outstanding_blocks,
; 2186 :        n=KD_THREAD_MAX_OUTSTANDING_BLOCKS; n > 0; n--, scan++)
; 2187 :     {
; 2188 :       if (scan->target_precinct == NULL)

	mov	eax, DWORD PTR [esi+248]
	test	eax, eax
	je	SHORT $LN108@flush

; 2191 :       assert(scan->target_precinct->num_outstanding_blocks > 0);
; 2192 :       if (scan->target_precinct->num_outstanding_blocks == 1)

	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN106@flush

; 2193 :         {
; 2194 :           have_complete_precincts=true;

	mov	bl, 1

; 2195 :           continue;

	jmp	SHORT $LN108@flush
$LN106@flush:

; 2189 :         continue;
; 2190 :       kd_codestream *cs = scan->target_precinct->resolution->codestream;

	mov	eax, DWORD PTR [eax]

; 2196 :         }
; 2197 :       if (cs->in == NULL)

	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN107@flush

; 2198 :         {
; 2199 :           scan->target_block->transfer_data(scan->block);

	mov	ecx, DWORD PTR [esi+252]

; 2200 :           have_only_input_precincts = false;

	xor	bh, bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	eax, DWORD PTR [esi+224]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2200 :           have_only_input_precincts = false;

	mov	BYTE PTR _have_only_input_precincts$1$[ebp], bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);

	mov	eax, DWORD PTR [esi+232]
	mov	DWORD PTR [ecx+8], eax

; 3703 :         src.current_buf = src.first_buf = NULL;

	mov	DWORD PTR [esi+224], 0
	mov	DWORD PTR [esi+228], 0
$LN107@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2202 :       scan->target_precinct->num_outstanding_blocks--;

	mov	eax, DWORD PTR [esi+248]
	dec	DWORD PTR [eax+24]

; 2203 :       scan->target_precinct = NULL;

	mov	DWORD PTR [esi+248], 0

; 2204 :       scan->target_block = NULL;

	mov	DWORD PTR [esi+252], 0

; 2205 :       num_outstanding_blocks--;

	dec	DWORD PTR [edi+33168]
$LN108@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [edi+128]
	mov	eax, DWORD PTR [eax+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+20], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $LN41@flush
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN41@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2209 :   if (num_outstanding_blocks == 0)

	cmp	DWORD PTR [edi+33168], 0
	jne	SHORT $LN13@flush

; 2210 :     owner->have_outstanding_blocks = false;

	mov	eax, DWORD PTR [edi+128]
	mov	BYTE PTR [eax+44], 0
$LN13@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 353  :     bool is_attached() { return (ultimate_buf_server != NULL); }

	cmp	DWORD PTR [edi+33156], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2213 :   if (buf_server.is_attached() && !have_only_input_precincts)

	je	SHORT $LN15@flush
	test	bh, bh
	jne	SHORT $LN15@flush

; 2214 :     buf_server.adjust_peak_buffers();

	lea	ecx, DWORD PTR [edi+33132]
	call	?adjust_peak_buffers@kd_thread_buf_server@@QAEXXZ ; kd_thread_buf_server::adjust_peak_buffers
$LN15@flush:

; 2215 : 
; 2216 :   if (have_complete_precincts)

	test	bl, bl
	je	$LN111@flush

; 2218 :       if (force_flush)

	cmp	BYTE PTR _force_flush$[ebp], 0

; 2219 :         owner->acquire_lock(KD_THREADLOCK_GENERAL);

	mov	ebx, DWORD PTR [edi+128]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1024 :       { kd_thread_lock *lock = locks + lock_id;

	mov	ecx, DWORD PTR [ebx+28]

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2218 :       if (force_flush)

	je	SHORT $LN17@flush
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	cmp	BYTE PTR [eax], 0
	mov	DWORD PTR _lock$1$[ebp], ecx
	jne	$LN116@flush
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN50@flush
	push	-1
	push	eax
	mov	eax, DWORD PTR __imp__WaitForSingleObject@8
	call	eax
	mov	ecx, DWORD PTR _lock$1$[ebp]
$LN50@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [ecx+4], ebx
	jmp	SHORT $LN19@flush
$LN17@flush:

; 1028 :       /* [SYNOPSIS]
; 1029 :            This function is used by the `kdu_codestream' interface and its
; 1030 :            descendants.  You will not normally invoke it directly from an
; 1031 :            application.
; 1032 :            [//]
; 1033 :            The mutexes which are locked by this function are fast,
; 1034 :            non-recursive mutexes.  You must not try to acquire the same
; 1035 :            lock a second time, without first releasing it.
; 1036 :            [//]
; 1037 :            Note that this function may throw an integer-valued exception if
; 1038 :            any other thread in the group terminates unexpectedly, invoking
; 1039 :            its `handle_exception' function.  To avoid this (e.g., when
; 1040 :            performing cleanup operations after an exception has already
; 1041 :            been thrown), set the `allow_exceptions' argument to false.
; 1042 :          [ARG: lock_id]
; 1043 :            Must be in the range 0 to L-1, where L is the value returned by
; 1044 :            `get_num_locks'.
; 1045 :          [ARG: allow_exceptions]
; 1046 :            If true, an exception will be thrown if the thread group is found
; 1047 :            to have failed somewhere.  This behaviour ensures that all
; 1048 :            participating threads in the group will eventually throw
; 1049 :            exceptions.
; 1050 :       */
; 1051 :     bool try_lock(int lock_id, bool allow_exceptions=true)
; 1052 :       { kd_thread_lock *lock = locks + lock_id;
; 1053 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1054 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	cmp	BYTE PTR [eax], 0
	mov	DWORD PTR _lock$1$[ebp], ecx
	jne	$LN117@flush
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 551  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	$LN111@flush
	push	0
	push	eax
	mov	eax, DWORD PTR __imp__WaitForSingleObject@8
	call	eax
	test	eax, eax
	jne	$LN111@flush
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1056 :         lock->holder = this;  return true; }

	mov	eax, DWORD PTR _lock$1$[ebp]
	mov	DWORD PTR [eax+4], ebx
$LN19@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2224 :            n=KD_THREAD_MAX_OUTSTANDING_BLOCKS; n > 0; n--, scan++)

	mov	ebx, 8
	npad	1
$LL7@flush:

; 2225 :         {
; 2226 :           if (scan->target_precinct == NULL)

	mov	edx, DWORD PTR [esi+24]
	test	edx, edx
	je	SHORT $LN5@flush

; 2227 :             continue;
; 2228 :           kd_precinct *precinct = scan->target_precinct;
; 2229 :           kd_codestream *cs = precinct->resolution->codestream;

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _cs$1$[ebp], eax

; 2230 :           if (cs->in == NULL)

	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN21@flush

; 2231 :             scan->target_block->transfer_data(scan->block);

	mov	ecx, DWORD PTR [esi+28]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3701 :         current_buf = first_buf = src.first_buf;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _cs$1$[ebp]

; 3703 :         src.current_buf = src.first_buf = NULL;

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
$LN21@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2233 :           precinct->num_outstanding_blocks = 0;

	mov	DWORD PTR [edx+24], 0

; 2234 :           scan->target_precinct = NULL;

	mov	DWORD PTR [esi+24], 0

; 2235 :           scan->target_block = NULL;

	mov	DWORD PTR [esi+28], 0

; 2236 :           num_outstanding_blocks--;

	dec	DWORD PTR [edi+33168]

; 2237 :           if (cs->in != NULL)

	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN22@flush

; 2238 :             precinct->release();

	mov	ecx, edx
	call	?release@kd_precinct@@QAEXXZ		; kd_precinct::release
	jmp	SHORT $LN5@flush
$LN22@flush:

; 2239 :           else if (cs->out != NULL)

	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN5@flush

; 2240 :             precinct->resolution->rescomp->add_ready_precinct(precinct);

	mov	ecx, DWORD PTR [edx]
	push	edx
	mov	ecx, DWORD PTR [ecx+8]
	call	?add_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z ; kd_global_rescomp::add_ready_precinct
$LN5@flush:

; 2224 :            n=KD_THREAD_MAX_OUTSTANDING_BLOCKS; n > 0; n--, scan++)

	dec	ebx
	add	esi, 32					; 00000020H
	test	ebx, ebx
	jg	SHORT $LL7@flush

; 2241 :         }
; 2242 :       owner->have_outstanding_blocks = false;

	mov	eax, DWORD PTR [edi+128]
	mov	BYTE PTR [eax+44], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 353  :     bool is_attached() { return (ultimate_buf_server != NULL); }

	cmp	DWORD PTR [edi+33156], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2243 :       if (buf_server.is_attached() && !have_only_input_precincts)

	je	SHORT $LN25@flush
	cmp	BYTE PTR _have_only_input_precincts$1$[ebp], 0
	jne	SHORT $LN25@flush

; 2244 :         buf_server.augment_local_store(true);

	push	1
	lea	ecx, DWORD PTR [edi+33132]
	call	?augment_local_store@kd_thread_buf_server@@QAEX_N@Z ; kd_thread_buf_server::augment_local_store
$LN25@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [edi+128]
	mov	eax, DWORD PTR [eax+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN111@flush
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN111@flush:
	pop	esi
	pop	ebx
$LN68@flush:
	pop	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2248 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN114@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T3[ebp], eax
	lea	eax, DWORD PTR $T3[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN118@flush:
$LN116@flush:
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN119@flush:
$LN117@flush:

; 1028 :       /* [SYNOPSIS]
; 1029 :            This function is used by the `kdu_codestream' interface and its
; 1030 :            descendants.  You will not normally invoke it directly from an
; 1031 :            application.
; 1032 :            [//]
; 1033 :            The mutexes which are locked by this function are fast,
; 1034 :            non-recursive mutexes.  You must not try to acquire the same
; 1035 :            lock a second time, without first releasing it.
; 1036 :            [//]
; 1037 :            Note that this function may throw an integer-valued exception if
; 1038 :            any other thread in the group terminates unexpectedly, invoking
; 1039 :            its `handle_exception' function.  To avoid this (e.g., when
; 1040 :            performing cleanup operations after an exception has already
; 1041 :            been thrown), set the `allow_exceptions' argument to false.
; 1042 :          [ARG: lock_id]
; 1043 :            Must be in the range 0 to L-1, where L is the value returned by
; 1044 :            `get_num_locks'.
; 1045 :          [ARG: allow_exceptions]
; 1046 :            If true, an exception will be thrown if the thread group is found
; 1047 :            to have failed somewhere.  This behaviour ensures that all
; 1048 :            participating threads in the group will eventually throw
; 1049 :            exceptions.
; 1050 :       */
; 1051 :     bool try_lock(int lock_id, bool allow_exceptions=true)
; 1052 :       { kd_thread_lock *lock = locks + lock_id;
; 1053 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1054 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN120@flush:
$LN113@flush:
	int	3
?flush@kd_thread_env@@QAEX_N@Z ENDP			; kd_thread_env::flush
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?reconcile_stats@kd_thread_env@@QAEXXZ
_TEXT	SEGMENT
_lock$1$ = -4						; size = 4
$T1 = -4						; size = 4
$T2 = -4						; size = 4
?reconcile_stats@kd_thread_env@@QAEXXZ PROC		; kd_thread_env::reconcile_stats, COMDAT
; _this$ = ecx

; 2145 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 2146 :   if ((stats_codestream != NULL) && (stats_codestream->stats != NULL) &&

	mov	eax, DWORD PTR [esi+33128]
	test	eax, eax
	je	$LN36@reconcile_
	cmp	DWORD PTR [eax+32], 0
	je	$LN36@reconcile_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1325 :     bool is_empty() { return (num_coded_samples == 0); }

	mov	eax, DWORD PTR [esi+328]
	or	eax, DWORD PTR [esi+332]
	je	$LN36@reconcile_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2149 :       owner->acquire_lock(KD_THREADLOCK_STATS);

	push	ebx
	mov	ebx, DWORD PTR [esi+128]
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [ebx+28]
	cmp	BYTE PTR [eax], 0
	jne	$LN41@reconcile_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN16@reconcile_
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN16@reconcile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+12], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2150 :       bool need_trim = stats_codestream->stats->update_stats(stats) &&

	lea	eax, DWORD PTR [esi+296]
	mov	ecx, DWORD PTR [esi+33128]
	push	eax
	mov	ecx, DWORD PTR [ecx+32]
	call	?update_stats@kd_compressed_stats@@QAE_NAAV1@@Z ; kd_compressed_stats::update_stats
	test	al, al
	je	SHORT $LN5@reconcile_
	mov	eax, DWORD PTR [esi+33128]
	cmp	BYTE PTR [eax+343], 0
	jne	SHORT $LN5@reconcile_
	mov	bl, 1
	jmp	SHORT $LN6@reconcile_
$LN5@reconcile_:
	xor	bl, bl
$LN6@reconcile_:

; 2151 :                        !stats_codestream->header_generated;
; 2152 :       stats_codestream->stats->update_quant_slope_thresholds();

	mov	ecx, DWORD PTR [esi+33128]
	mov	ecx, DWORD PTR [ecx+32]
	call	?update_quant_slope_thresholds@kd_compressed_stats@@QAEXXZ ; kd_compressed_stats::update_quant_slope_thresholds

; 2153 :       if (need_trim)

	test	bl, bl
	mov	ebx, DWORD PTR __imp__ReleaseMutex@4
	je	SHORT $LN30@reconcile_

; 2154 :         { // Need both the precinct lock and the general lock for trimming.
; 2155 :           // Trimming is not recommended for multi-processor platforms.
; 2156 :           owner->acquire_lock(KD_THREADLOCK_GENERAL);

	mov	edi, DWORD PTR [esi+128]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR _lock$1$[ebp], ecx
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN43@reconcile_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN24@reconcile_
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	ecx, DWORD PTR _lock$1$[ebp]
$LN24@reconcile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [ecx+4], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2157 :           stats_codestream->trim_compressed_data();

	mov	ecx, DWORD PTR [esi+33128]
	call	?trim_compressed_data@kd_codestream@@QAEXXZ ; kd_codestream::trim_compressed_data
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [esi+128]
	mov	eax, DWORD PTR [eax+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN30@reconcile_
	push	eax
	call	ebx
$LN30@reconcile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [esi+128]
	mov	eax, DWORD PTR [eax+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN39@reconcile_
	push	eax
	call	ebx
$LN39@reconcile_:
	pop	edi
	pop	ebx
$LN36@reconcile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2162 :   stats_codestream = NULL; // So we know that all is reconciled and we are

	mov	DWORD PTR [esi+33128], 0
	pop	esi

; 2164 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@reconcile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN44@reconcile_:
$LN43@reconcile_:
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN45@reconcile_:
$LN40@reconcile_:
	int	3
?reconcile_stats@kd_thread_env@@QAEXXZ ENDP		; kd_thread_env::reconcile_stats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_thread_env@@QAE@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_owner$ = 8						; size = 4
??0kd_thread_env@@QAE@PAVkdu_thread_env@@@Z PROC	; kd_thread_env::kd_thread_env, COMDAT
; _this$ = ecx

; 4553 :     kd_thread_env(kdu_thread_env *owner)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 4554 :       {

	lea	ecx, DWORD PTR [esi+136]
	call	??0kdu_block@@AAE@XZ			; kdu_block::kdu_block
	lea	ecx, DWORD PTR [esi+296]

; 418  :       }
; 419  :   private: // Data
; 420  :     kd_thread_env *env;
; 421  :     int peak_buffers; // See the `adjust_peak_buffers' function.
; 422  :     int num_available_buffers; // Number of buffers on the `head' list.
; 423  :     int ref_available_buffers; // Adjusted so that `ref_available_buffers' -
; 424  :          // `num_available_buffers' is always equal to the number of buffers
; 425  :          // allocated via `get' since the last call to `adjust_peak_buffers'.
; 426  :     kd_code_buffer *head;
; 427  :     kd_code_buffer *tail;
; 428  :     kd_buf_server *ultimate_buf_server; // All buffers are allocated from here
; 429  :     kd_thread_buf_server *next_attached; // Used to build a doubly linked list
; 430  :     kd_thread_buf_server *prev_attached; // of objects which are all attached
; 431  :                      // to the same `ultimate_buf_server'.
; 432  :   };
; 433  : 
; 434  : /*****************************************************************************/
; 435  : /*                             kd_compressed_output                          */
; 436  : /*****************************************************************************/
; 437  : 
; 438  : class kd_compressed_output : public kdu_output {
; 439  :   public: // Member functions
; 440  :     kd_compressed_output(kdu_compressed_target *target)
; 441  :       { this->target=target; flushed_bytes = 0; }
; 442  :     virtual ~kd_compressed_output()
; 443  :       { flush_buf(); }
; 444  :     kdu_compressed_target *access_tgt()
; 445  :       { /* You may call this function to access the underlying `target'
; 446  :            object, but you should never manipulate that object if you
; 447  :            have written anything to the present object, without re-accessing
; 448  :            it. */
; 449  :            flush_buf();  return target;
; 450  :       }
; 451  :     kdu_long get_bytes_written()
; 452  :       { return (flushed_bytes + (next_buf-buffer)); }
; 453  :     void flush()
; 454  :       { flush_buf(); }
; 455  :   protected: // Virtual functions which implement required services.
; 456  :     virtual void flush_buf()
; 457  :       {
; 458  :         if (next_buf > buffer)
; 459  :           target->write(buffer,(int)(next_buf-buffer));
; 460  :         flushed_bytes += next_buf - buffer;
; 461  :         next_buf = buffer;
; 462  :       }
; 463  :   private: // Data
; 464  :     kdu_compressed_target *target;
; 465  :     kdu_long flushed_bytes;
; 466  :   };
; 467  : 
; 468  : /*****************************************************************************/
; 469  : /*                                kd_input                                   */
; 470  : /*****************************************************************************/
; 471  : 
; 472  : #define KD_IBUF_SIZE 512
; 473  : #define KD_IBUF_PUTBACK 6 // Maximum number of bytes you can put back.
; 474  : 
; 475  : class kd_input {
; 476  :   /* This abstract base class must be derived to construct meaningful
; 477  :      input devices.  Currently, we have two derived classes in mind: one
; 478  :      for reading from the code-stream and one for recovering packet
; 479  :      headers from PPM or PPT markers.  Since there may be many low level
; 480  :      byte-oriented transactions, we emphasize efficiency for such
; 481  :      transactions. */
; 482  :   public: // Member functions
; 483  :     kd_input()
; 484  :       { first_unread = first_unwritten = buffer+KD_IBUF_PUTBACK;
; 485  :         exhausted = fully_buffered = throw_markers = false; }
; 486  :     virtual ~kd_input() { return; }
; 487  :     bool is_fully_buffered() { return fully_buffered; }
; 488  :     void enable_marker_throwing(bool reject_all=false)
; 489  :       { /* If `reject_all' is false, subsequent reads will throw an exception
; 490  :            if a bona fide SOP or SOT marker is found. In this case, the
; 491  :            function will check to make sure that the length field is correct,
; 492  :            putting the length field and marker code bytes back to the source
; 493  :            before throwing the exception, so that the catch statement can read
; 494  :            them again.
; 495  :               If `reject_all' is true, subsequent reads will throw an
; 496  :            exception if any marker code in the range FF90 to FFFF is found.
; 497  :            Again, the marker code itself is put back onto the stream before
; 498  :            throwing the exception.
; 499  :               Marker throwing is disabled before throwing an exception for
; 500  :            either of the above reasons.
; 501  :               Note that code-stream reading may be slowed down
; 502  :            when this marker throwing is enabled.  For this reason, the
; 503  :            capability is best used only when error resilience or error
; 504  :            detection capabilities are required. */
; 505  :         this->reject_all = reject_all; throw_markers = true; have_FF = false;
; 506  :       }
; 507  :     bool disable_marker_throwing()
; 508  :       { /* Disable marker exception throwing.  Returns true unless the
; 509  :            last byte which was read was an FF, in which case the function
; 510  :            returns false.  This allows the caller to catch markers which
; 511  :            were partially read.  Any code-stream segment which is not
; 512  :            permitted to contain a marker code in the range FF90 through FFFF
; 513  :            is also not permitted to terminate with an FF. */
; 514  :         if (!throw_markers) return true;
; 515  :         throw_markers = false; // Must not touch `reject_all' here.
; 516  :         if (exhausted) have_FF = false;
; 517  :         return !have_FF;
; 518  :       }
; 519  :     void terminate_prematurely()
; 520  :       { /* This function may be called in non-resilient mode if an EOC marker
; 521  :            is encountered before the stream physically ends. */
; 522  :         exhausted = true;
; 523  :       }
; 524  :     bool failed()
; 525  :       { /* Returns true if any of the input functions, `get', `read' or
; 526  :            `ignore' failed to completely fulfill its objective due to
; 527  :            exhaustion of the relevant source. */
; 528  :         return exhausted;
; 529  :       }
; 530  :     bool get(kdu_byte &byte) // throws (kdu_uint16 code): unexpected marker
; 531  :       { /* Access a single byte, returning false if and only if the source is
; 532  :            exhausted, in which case future calls to `failed' return true. */
; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))
; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.
; 535  :         byte = *(first_unread++);
; 536  :         if (throw_markers)
; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))
; 539  :               process_unexpected_marker(byte);
; 540  :             have_FF = (byte==0xFF);
; 541  :           }
; 542  :         return true;
; 543  :       }
; 544  :     void putback(kdu_byte byte)
; 545  :       { /* You may put back more than 1 byte, but you may not call this
; 546  :            function if a previous read has ever failed.  It is also illegal
; 547  :            to call this function while marker throwing is enabled. */
; 548  :         assert(!exhausted);
; 549  :         assert(!throw_markers);
; 550  :         first_unread--;
; 551  :         if (!fully_buffered)
; 552  :           {
; 553  :             assert(first_unread >= buffer);
; 554  :             *first_unread = byte;
; 555  :           }
; 556  :       }
; 557  :     void putback(kdu_uint16 code)
; 558  :       { /* This function is designed to improve the readability of code
; 559  :            which puts marker codes back to the input object from which they
; 560  :            were read. */
; 561  :         assert(!exhausted);
; 562  :         assert(!throw_markers);
; 563  :         first_unread-=2;
; 564  :         if (!fully_buffered)
; 565  :           {
; 566  :             assert(first_unread >= buffer);
; 567  :             first_unread[0] = (kdu_byte)(code>>8);
; 568  :             first_unread[1] = (kdu_byte) code;
; 569  :           }
; 570  :       }
; 571  :     int pseudo_read(kdu_byte * &addr, int count)
; 572  :       { /* This function should be called only for `fully_buffered' sources.
; 573  :            It behaves like `read', except that it does not actually read
; 574  :            any bytes.  Instead, it puts the address of the block of data
; 575  :            that would have been read into the variable referenced by the
; 576  :            `addr' argument. */
; 577  :         assert(fully_buffered);
; 578  :         addr = first_unread;
; 579  :         if (throw_markers)
; 580  :           return read(addr,count); // Slower path, looks for markers
; 581  :         first_unread += count;
; 582  :         if (first_unread > first_unwritten)
; 583  :           {
; 584  :             count -= (int)(first_unread - first_unwritten);
; 585  :             first_unread = first_unwritten; exhausted = true;
; 586  :           }
; 587  :         return count;
; 588  :       }
; 589  :     int read(kdu_byte *buf, int count);
; 590  :       /* More efficient than `get' when the number of bytes to be read is
; 591  :          more than 2 or 3.  Returns the number of bytes actually read.  If
; 592  :          less than `count', future calls to `failed' will return true.  Note
; 593  :          that this function is less efficient if marker throwing is enabled. */
; 594  :     int read(kd_code_buffer * &cbuf, kdu_byte &buf_pos,
; 595  :              kd_buf_server *buf_server, int length);
; 596  :       /* Same as the above function, except that the requested bytes are
; 597  :          written to a linked list of `kd_code_buffer' buffers, headed by
; 598  :          `cbuf', where the `buf_pos' indicates the next free byte in the
; 599  :          `cbuf' buffer.  The function automatically grows the linked list
; 600  :          of buffers, as required, using `buf_server->get()'.  Upon return,
; 601  :          the `cbuf' and `buf_pos' variables are advanced to refer to the
; 602  :          most recently written `kd_code_buffer' object and the already
; 603  :          written prefix of that object, respectively.  The function
; 604  :          returns the actual number of bytes transferred in this way, which
; 605  :          is equal to `length' unless the ultimate source of data ran dry. */
; 606  :     virtual kdu_long ignore(kdu_long count);
; 607  :       /* Skips over the indicated number of bytes, returning the number of
; 608  :          bytes actually skipped.  If less than `count', future calls to
; 609  :          `failed' will return true.  The function may be overridden by
; 610  :          derived classes which support seeking. */
; 611  :   protected: // Data and functions used for buffer management.
; 612  :     virtual bool load_buf() = 0;
; 613  :       /* Returns false and sets `exhausted' to true if the source is unable
; 614  :          to provide any more data.  Otherwise, augments the internal buffer
; 615  :          and returns true.  Buffer manipulation must conform to the following
; 616  :          conventions.  The `first_unread' pointer should be set to
; 617  :          `buffer'+KD_IBUF_PUTBACK and then bytes should be loaded into the
; 618  :          remaining KD_IBUF_SIZE bytes of the `buffer' array. The
; 619  :          `first_unwritten' pointer should then be set to point just beyond
; 620  :          the last byte actually written into the buffer.  The only exception
; 621  :          to the above conventions is for fully buffered sources, in which
; 622  :          the entire data source lies in a contiguous external memory buffer.
; 623  :          In this case, the internal `buffer' is not used; the first call to
; 624  :          `load_buf' sets `first_unread' to point to the start of the external
; 625  :          memory buffer and `first_unwritten' to point just beyond the external
; 626  :          memory buffer.  In this case, the `fully_buffered' flag should be
; 627  :          set to true, which signals to the `putback' functions that it is
; 628  :          sufficient for them to adjust the `first_unread' pointer, without
; 629  :          actually writing anything. */
; 630  :     kdu_byte buffer[KD_IBUF_SIZE+KD_IBUF_PUTBACK];
; 631  :     kdu_byte *first_unread; // Points to next byte to retrieve from buffer.
; 632  :     kdu_byte *first_unwritten; // Points beyond last available byte in buffer
; 633  :     bool fully_buffered;
; 634  :     bool exhausted;
; 635  :     bool throw_markers; // If true, must look for unexpected markers.
; 636  :   private: // Functions
; 637  :     void process_unexpected_marker(kdu_byte last_byte);
; 638  :       /* This function is called when marker throwing is enabled and a
; 639  :          marker code in the range FF90 through FFFF has been found.  The
; 640  :          least significant byte of the marker code is supplied as the
; 641  :          `last_byte' argument.  The function determines whether to throw
; 642  :          the exception or not.  If not, reading continues unaffected. */
; 643  :   private: // Data
; 644  :     bool have_FF; // Valid only with `throw_markers'. Means last byte was FF.
; 645  :     bool reject_all; // If `false' marker throwing is only for SOP's and SOT's
; 646  :   };
; 647  :   
; 648  : /*****************************************************************************/
; 649  : /*                             kd_compressed_input                           */
; 650  : /*****************************************************************************/
; 651  : 
; 652  : class kd_compressed_input : public kd_input {
; 653  :   public: // Member functions
; 654  :     kd_compressed_input(kdu_compressed_source *source);
; 655  :     int get_capabilities()
; 656  :       { return source->get_capabilities(); }
; 657  :     bool set_tileheader_scope(int tnum, int num_tiles);
; 658  :       /* Generates an error through `kdu_error' if the embedded source does
; 659  :          not support the `KDU_SOURCE_CAP_CACHED' capability.  This function
; 660  :          simply calls the source's own `set_tileheader_scope' function and
; 661  :          clears the internal state variables (especially, the `exhausted'
; 662  :          member) so that subsequent reads will recover bytes from the indicated
; 663  :          tile's header.  For more information, refer to the comments appearing
; 664  :          with `kdu_compressed_source::set_tileheader_scope'. */
; 665  :     kdu_long get_offset()
; 666  :       { /* Returns the address of the next byte which will be returned by the
; 667  :            base object's `get' function.  If seeking is enabled, the source
; 668  :            may be repositioned to this point by supplying this address as the
; 669  :            `unique_address' argument to `seek'.  Even if seeking is not
; 670  :            enabled, `get_offset' will return the correct address and this may
; 671  :            be used to determine appropriate arguments for the `ignore' member
; 672  :            function declared below.  May not be called if the source is in
; 673  :            anything other than code-stream scope. */
; 674  :         assert(!special_scope);
; 675  :         return cur_offset + last_loaded_bytes - (first_unwritten-first_unread);
; 676  :       }
; 677  :     void seek(kdu_long unique_address);
; 678  :       /* If `unique_address' is non-negative, it is treated as a code-stream
; 679  :          offset and the function seeks to a point `unique_address' bytes past
; 680  :          the beginning of the code-stream (SOC marker), using the embedded
; 681  :          `kdu_compressed_source' object's `seek' function.  In this case,
; 682  :          a terminal error is generated if the source does not
; 683  :          offer the KDU_SOURCE_CAP_SEEKABLE capability.
; 684  :             If `unique_address' is negative, the function treats
; 685  :          -(1+`unique_address') as the unique identifier associated with a
; 686  :          cached precinct, supplying this identifier to the embedded
; 687  :          `kdu_compressed_source' object's `set_precinct_scope' function.  In
; 688  :          this case, a terminal error is generated if the source does not
; 689  :          offer the KDU_SOURCE_CAP_CACHEABLE capability.
; 690  :             In either case, the function may clear or set the "exhausted"
; 691  :          state, so that the base object's `failed' member function may return
; 692  :          false, having previously returned true, or vice-versa. */
; 693  :     kdu_long ignore(kdu_long count); // Overrides `kd_input::ignore'.
; 694  :     void set_max_bytes(kdu_long limit);
; 695  :       /* No effect except when reading in code-stream scope. */
; 696  :     kdu_long get_bytes_read();
; 697  :       /* Returns the smallest initial prefix of the source stream which
; 698  :          contains all of the bytes consumed from `kd_input'.  Note that more
; 699  :          bytes may have been read from the compressed data source and
; 700  :          buffered internally, without having been actually used.
; 701  :             For cached sources (those advertising the KDU_SOURCE_CAP_CACHED
; 702  :          capability), the function's return value will be 0, unless we
; 703  :          are still reading the main header. */
; 704  :     kdu_long get_suspended_bytes();
; 705  :       /* Returns the total number of bytes which have been read in the
; 706  :          suspended state.  The returned value may be subtracted from
; 707  :          the value returned by `get_bytes_read' to determine the total
; 708  :          number of bytes which have been read in a non-suspended state.
; 709  :          Byte limits apply only to non-suspended reads. */
; 710  :     void set_suspend(bool state)
; 711  :       {
; 712  :         if (special_scope) return;
; 713  :         if ((suspend_ptr == NULL) && state)
; 714  :           { // Enter suspended mode
; 715  :             suspend_ptr = first_unread;
; 716  :             if (alt_first_unwritten != NULL)
; 717  :               {
; 718  :                 assert(alt_first_unwritten > first_unwritten);
; 719  :                 last_loaded_bytes += alt_first_unwritten - first_unwritten;
; 720  :                 first_unwritten = alt_first_unwritten;
; 721  :                 alt_first_unwritten = NULL;
; 722  :               }
; 723  :           }
; 724  :         else if ((suspend_ptr != NULL) && !state)
; 725  :           { // Leave suspended mode
; 726  :             suspended_bytes += first_unread-suspend_ptr;  suspend_ptr = NULL;
; 727  :             kdu_long limit = suspended_bytes + max_bytes_allowed - cur_offset;
; 728  :             if (limit < last_loaded_bytes)
; 729  :               { // We have already loaded the buffer with too many bytes
; 730  :                 alt_first_unwritten = first_unwritten;
; 731  :                 first_unwritten -= (last_loaded_bytes - limit);
; 732  :                 last_loaded_bytes = limit;
; 733  :                 if (first_unwritten < first_unread)
; 734  :                   { // We have already read past the end.
; 735  :                     exhausted = true;
; 736  :                     suspended_bytes -= (first_unread-first_unwritten);
; 737  :                     first_unwritten = first_unread;
; 738  :                     alt_first_unwritten = NULL;
; 739  :                   }
; 740  :               }
; 741  :           }
; 742  :       }
; 743  :   protected: // Virtual functions which implement required services.
; 744  :     virtual bool load_buf();
; 745  :   private: // Data
; 746  :     kdu_compressed_source *source;
; 747  :     kdu_long cur_offset; // Offset from start of code-stream
; 748  :     kdu_long max_bytes_allowed; // Source may have fewer bytes than this
; 749  :     kdu_long max_address_read; // Address of last byte read from base object.
; 750  :     kdu_long suspended_bytes; // Bytes read while in suspended mode.
; 751  :     kdu_long last_loaded_bytes; // Num bytes added by last call to `load_buf'
; 752  :     kdu_byte *suspend_ptr; // Points into the buffer
; 753  :     kdu_byte *alt_first_unwritten; // See below
; 754  :     bool special_scope; // True for anything other than code-stream scope.
; 755  :   };
; 756  :   /* Notes:
; 757  :         The `cur_offset' member holds the offset from the start of the
; 758  :      code-stream to the first nominal byte in the input buffer; i.e., the
; 759  :      byte at kd_input::buffer + KD_IBUF_PUTBACK.  The actual number of bytes
; 760  :      which have been read from `source' is larger by the amount
; 761  :      `kd_input::first_unwritten' - (`kd_input::buffer'+KD_IBUF_PUTBACK).
; 762  :         The object may be placed in a suspended mode while reading data
; 763  :      which belongs to code-stream packets which lie outside the current
; 764  :      resolution, components or layers of interest.  This allows the
; 765  :      application to set a byte limit which applies only to the relevant
; 766  :      data which would be left if the irrelevant data were first parsed
; 767  :      out of the code-stream.  The object is in suspended mode if and only
; 768  :      if `suspend_ptr' is non-NULL.  In this case, `suspend_ptr' holds the
; 769  :      value of `kd_input::first_unread' immediately prior to the point at
; 770  :      which the object entered the suspended mode.  The total number of
; 771  :      bytes consumed while in the suspended mode is maintained by the
; 772  :      `suspended_bytes' member, but use the function, `get_suspended_bytes'
; 773  :      to evaluate a reliable count of the number of suspended bytes, which
; 774  :      takes into account activity within the `kd_input' object of which
; 775  :      the derived object might not be aware.
; 776  :         The `alt_first_unwritten' member is used to keep track of bytes in
; 777  :      the buffer which may be inaccessible while in the regular (non-suspended)
; 778  :      mode, which may need to be made accessible while the object is in the
; 779  :      suspended mode.  This member holds NULL until exiting the suspended mode
; 780  :      requires `first_unwritten' to be truncated to account for a byte limit.
; 781  :      At that point, it is set to the value of the `first_unwritten' member
; 782  :      prior to truncation.  When the object enters the suspended mode, any
; 783  :      non-NULL `alt_first_unwritten' value is copied to `first_unwritten'. */
; 784  : 
; 785  : /*****************************************************************************/
; 786  : /*                               kd_pph_input                                */
; 787  : /*****************************************************************************/
; 788  : 
; 789  : class kd_pph_input : public kd_input {
; 790  :   /* Alternate input for packet header bytes, which is used in conjunction
; 791  :      with the PPM and PPT marker segments. */
; 792  :   public: // Member functions
; 793  :     kd_pph_input(kd_buf_server *server)
; 794  :       { buf_server = server; first_buf = read_buf = write_buf = NULL; }
; 795  :     virtual ~kd_pph_input();
; 796  :     void add_bytes(kdu_byte *data, int num_bytes);
; 797  :       /* This function is called when unpacking a PPM or PPT marker, to
; 798  :          augment the current object. */
; 799  :   protected: // Virtual functions which implement required services.
; 800  :     virtual bool load_buf();
; 801  :   private: // Data
; 802  :     kd_code_buffer *first_buf;
; 803  :     kd_code_buffer *read_buf, *write_buf;
; 804  :     int read_pos, write_pos;
; 805  :     kd_buf_server *buf_server;
; 806  :   };
; 807  :   /* Notes:
; 808  :         `first_buf' points to the first in a linked list of buffers used to
; 809  :      temporarily store PPM or PPT marker segment bytes.
; 810  :         `read_buf' points to the element in the linked list of code buffers
; 811  :      which is currently being read; `read_pos' points to the next element of
; 812  :      the current buffer which will be read. This may be equal to
; 813  :      KD_CODE_BUFFER_LEN, in which case the next element in the code buffer
; 814  :      list must be accessed when the next read attempt occurs.
; 815  :         `write_buf' points to the last element in the linked list of code
; 816  :      buffers and `write_pos' identifies the first unwritten byte in this
; 817  :      element.  `write_pos' may equal KD_CODE_BUFFER_LEN, in which case a
; 818  :      new element will need to be added before further data can be written.
; 819  :         `buf_server' points to the object which is used to add and release
; 820  :      code buffer elements.  This is a shared resource. */
; 821  : 
; 822  : /*****************************************************************************/
; 823  : /*                                kd_marker                                  */
; 824  : /*****************************************************************************/
; 825  : 
; 826  : class kd_marker {
; 827  :   /* Objects of this class are used to read and store code-stream marker
; 828  :      segments. The most efficient way to use the class is to construct a
; 829  :      single serving object which is used to read the markers one by one and
; 830  :      then copy any markers which need to be preserved into new instances of
; 831  :      the class, using the copy constructor.  This concentrates wasted buffer
; 832  :      space in the one server marker which actually reads from the input
; 833  :      code-stream. */
; 834  :   public: // Member functions
; 835  :     kd_marker(kd_input *input, kd_codestream *cs)
; 836  :       { this->source = input; this->codestream = cs;
; 837  :         code = 0; length = 0; max_length = 0; buf = NULL;
; 838  :         encountered_skip_code = false; }
; 839  :     kd_marker(const kd_marker &orig);
; 840  :       /* Copies any marker segment stored in `orig'. Note that the `source'
; 841  :          pointer is not copied, meaning that the `read' member function may
; 842  :          not be invoked on the copy. */
; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }
; 844  :     kd_marker *move(kd_input *input, kd_codestream *cs)
; 845  :       { this->source = input; this->codestream = cs; return this; }
; 846  :         /* This function is used when a `kd_marker' object must be moved
; 847  :          to a different codestream, or to work with a different source of
; 848  :          data. */
; 849  :     void print_current_code(kdu_message &out)
; 850  :       { /* Prints a text string identifying the current marker code. */
; 851  :         print_marker_code(this->code,out);
; 852  :       }
; 853  :     bool read(bool exclude_stuff_bytes=false, bool skip_to_marker=false);
; 854  :       /* Reads a new marker (or marker segment) from the `kd_input' object
; 855  :          supplied during construction.
; 856  :              Returns true if successful.  Causes of failure may be: 1) the
; 857  :          code-stream source is exhausted; 2) a valid marker code was not found;
; 858  :          or 3) an SOP or SOT marker code was found, but followed by an invalid
; 859  :          length field.  This third cause of failure is important since it
; 860  :          prevents the function from attempting to consume an invalid SOP or
; 861  :          SOT marker segment, in the process of which it might consume any
; 862  :          number of useful packets, having their own SOP markers.
; 863  :               A valid marker code must commence with an FF.  If
; 864  :          `exclude_stuff_bytes' is true then the second byte of a valid marker
; 865  :          code must be strictly greater than 0x8F.  Otherwise, the second byte
; 866  :          is arbitrary.  If `skip_to_marker' is true, the function consumes
; 867  :          bytes indefinitely, until the source is exhausted or a valid marker
; 868  :          code is found.  In this case, the function returns false only if the
; 869  :          source is exhausted. Otherwise, the function expects to find a valid
; 870  :          marker code immediately.
; 871  :              As a convenience feature, the function automatically skips over
; 872  :          any EOC marker it encounters.  This has two advantages: 1) we can
; 873  :          detect the end of the code-stream without having to explicitly check
; 874  :          for an EOC marker; 2) we should not be overly troubled by EOC
; 875  :          markers which arise due to corruption of the code-stream (this has
; 876  :          quite a high likelihood of occurring if the code-stream is subject
; 877  :          to corruption).
; 878  :              In the event that the source is not exhausted but a valid
; 879  :          marker code is not found, the function puts back any bytes it consumed
; 880  :          before returning false.  This allows the caller to continue reading
; 881  :          from the point where the function was first called. */
; 882  :     kdu_uint16 get_code() { return code; }
; 883  :       /* Returns 0 if no actual marker is available yet. */
; 884  :     int get_length() { return length; }
; 885  :       /* Returns length of marker segment (not including the length specifier).
; 886  :          Returns 0 if no actual marker available, or if the marker is a
; 887  :          delimiter (no segment). */
; 888  :     kdu_byte *get_bytes() { return buf; }
; 889  :       /* Returns pointer to marker segment bytes immediately following the
; 890  :          length specifier. */
; 891  :     void clear() { code = 0; length = 0; encountered_skip_code = false; }
; 892  :       /* Erase internal state so that not marker is advertised.  This is
; 893  :          useful if the marker has already been inspected and found to be
; 894  :          not useful. */
; 895  :   private: // Data
; 896  :     kd_input *source; // If NULL, `read' may not be used.
; 897  :     kd_codestream *codestream;
; 898  :     kdu_uint16 code;
; 899  :     int length;
; 900  :     int max_length; // Number of bytes which the buffer can store.
; 901  :     kdu_byte *buf;
; 902  :     bool encountered_skip_code;
; 903  :   };
; 904  : 
; 905  : /*****************************************************************************/
; 906  : /*                                 kd_pp_markers                             */
; 907  : /*****************************************************************************/
; 908  : 
; 909  : class kd_pp_markers {
; 910  :   public: // Member functions
; 911  :     kd_pp_markers()
; 912  :       { list = NULL; }
; 913  :     ~kd_pp_markers();
; 914  :     void add_marker(kd_marker &copy_source); 
; 915  :       /* Copies the `kd_marker' object into a new `kd_pp_marker_list'
; 916  :          element, inserting it into the evolving list on the basis of its
; 917  :          Zppm or Zppt index.  Markers need not be added in order. */
; 918  :     void transfer_tpart(kd_pph_input *pph_input);
; 919  :       /* Transfers an entire tile-part of packed packet header data from
; 920  :          the internal marker list to the `pph_input' object, which may
; 921  :          then be used as a source object for packet header reading.  If the
; 922  :          object is managing a list of PPM markers, the function expects to
; 923  :          find the total number of bytes associated with the next tile-part
; 924  :          embedded in the current marker segment.  Otherwise, all marker
; 925  :          segments are dumped into the `pph_input' object.  Marker segments
; 926  :          whose data have been consumed are deleted automatically. */
; 927  :     void ignore_tpart();
; 928  :       /* Same as `transfer_tpart' except that the data are simply discarded.
; 929  :          This is useful when discarding a tile for which PPM marker information
; 930  :          has been provided. */
; 931  :   private: // Definitions
; 932  : 
; 933  :       class kd_pp_marker_list : public kd_marker {
; 934  :         public: // Member functions
; 935  :           kd_pp_marker_list(kd_marker &copy_source) : kd_marker(copy_source)
; 936  :             { next = NULL; }
; 937  :         public: // Data
; 938  :           kd_pp_marker_list *next;
; 939  :           int znum;
; 940  :           int bytes_read;
; 941  :         };
; 942  : 
; 943  :   private: // Convenience functions
; 944  :     void advance_list();
; 945  :   private: // Data
; 946  :     bool is_ppm; // Otherwise, list contains PPT markers.
; 947  :     kd_pp_marker_list *list;
; 948  :   };
; 949  : 
; 950  : /*****************************************************************************/
; 951  : /*                            kd_tpart_pointer                               */
; 952  : /*****************************************************************************/
; 953  : 
; 954  : struct kd_tpart_pointer {
; 955  :     kdu_long address; // Offset relative to the start of the code-stream.
; 956  :     kd_tpart_pointer *next; // For building linked lists.
; 957  :   };
; 958  : 
; 959  : /*****************************************************************************/
; 960  : /*                               kd_tile_ref                                 */
; 961  : /*****************************************************************************/
; 962  : 
; 963  : struct kd_tile_ref {
; 964  :     kd_tpart_pointer *tpart_head;
; 965  :     kd_tpart_pointer *tpart_tail;
; 966  :     kd_tile *tile;
; 967  :   };
; 968  :   /* Notes:
; 969  :        This structure is used to build an array of references to each tile
; 970  :        in the code-stream.  The array is allocated when the codestream is
; 971  :        constructed, but the actual `kd_tile' objects are only instantiated
; 972  :        when needed and destroyed as soon as possible.
; 973  :           The `tpart_head' and `tpart_tail' members manage a list of
; 974  :        addresses to tile-parts of the tile.  The list may be constructed
; 975  :        by reading TLM marker segments in the main code-stream header, or it
; 976  :        may be constructed dynamically as tile-parts are encountered within
; 977  :        the code-stream, enabling them to be re-opened at a later point if
; 978  :        the compressed data-source supports seeking.  The list should be
; 979  :        empty if the source does not support seeking.
; 980  :           Once we are sure that all tile-part addresses have been found
; 981  :        for the tile, the `tpart_tail' member is set to NULL.
; 982  :           Once a tile has been opened and destroyed in non-persistent mode,
; 983  :        the `tile' pointer value is set to KD_EXPIRED_TILE, marking it
; 984  :        as unusable. */
; 985  : 
; 986  : /*****************************************************************************/
; 987  : /*                              kd_tlm_generator                             */
; 988  : /*****************************************************************************/
; 989  : 
; 990  : class kd_tlm_generator {
; 991  :   public: // Member functions
; 992  :     kd_tlm_generator()
; 993  :       {
; 994  :         num_tiles = max_tparts = num_elts = 0; elts = NULL;
; 995  :         tile_data_bytes=0;
; 996  :       }
; 997  :     ~kd_tlm_generator() { if (elts != NULL) delete[] elts; }
; 998  :     bool init(int num_tiles, int max_tparts);
; 999  :       /* Call this function after construction or `clear' in order to
; 1000 :          initialize the object in preparation for generating TLM marker
; 1001 :          segments.  If the number of tiles or tile-parts identified here
; 1002 :          cannot be accommodated by a legal set of TLM marker segments, the
; 1003 :          function returns false and `exists' will continue to return false.
; 1004 :          Otherwise, the object is initialized and subsequent calls to
; 1005 :          `exists' will return true.  Note that the number of tiles given
; 1006 :          here is the total number in the entire code-stream.  This might
; 1007 :          be more than the number of tiles being compressed in the
; 1008 :          current fragment, in which case the `elts' array will not be
; 1009 :          full by the time `write_tlms' is called. */
; 1010 :     bool exists() { return (num_tiles > 0); }
; 1011 :     bool operator!() { return (num_tiles == 0); }
; 1012 :     void clear()
; 1013 :       {
; 1014 :         num_tiles = max_tparts = num_elts = 0;
; 1015 :         tile_data_bytes = 0;
; 1016 :         if (elts != NULL)
; 1017 :           { delete[] elts; elts = NULL; }
; 1018 :       }
; 1019 :     int get_max_tparts() { return max_tparts; }
; 1020 :       /* Returns the parameter recorded with the `ORGgen_tlm' parameter
; 1021 :          attribute, which triggered the creation of this object.  The
; 1022 :          value returned here is guaranteed to lie in the range 1 to 255. */
; 1023 :     int get_tlm_bytes() { return tlm_bytes; }
; 1024 :       /* Returns the total number of bytes occupied by TLM marker segments.
; 1025 :          This value is computed immediately by the object's constructor; it
; 1026 :          does not depend on the actual tile-part length values added later
; 1027 :          via `add_tpart_length'. */
; 1028 :     void write_dummy_tlms(kd_compressed_output *out);
; 1029 :       /* Writes a properly sized set of TLM marker segments to the `out'
; 1030 :          object, except that all tile-part lengths are set equal to 0.  It
; 1031 :          is most important that the TLM marker segments appear at the very
; 1032 :          end of the main codestream header, since a pointer to the start
; 1033 :          of the TLM data will later be generated on the basis of the
; 1034 :          amount of tile-data which has been written, plus the size of the
; 1035 :          TLM data. */
; 1036 :     void add_tpart_length(int tnum, kdu_long length);
; 1037 :       /* Call this function as the tile-part length information becomes
; 1038 :          available while generating the code-stream.  The actual marker
; 1039 :          TLM marker segments can be written only once all tile-part lengths
; 1040 :          have been added. */
; 1041 :     void write_tlms(kdu_compressed_target *tgt,
; 1042 :                     int prev_tiles_written, kdu_long prev_tile_bytes_written);
; 1043 :       /* This function writes the final TLM marker segments.  The `tgt'
; 1044 :          object's `start_rewrite' and `end_rewrite' functions are used to
; 1045 :          reposition the output stream over the previously written dummy
; 1046 :          TLM marker segments and rewrite them with valid tile-part length
; 1047 :          values.  The `prev_tiles_written' and `prev_tile_bytes_written'
; 1048 :          arguments are identical to the values originally supplied to
; 1049 :          `kdu_codestream::create'.  They are used to determine the
; 1050 :          location of the TLM marker information which must be written,
; 1051 :          since some of it may have previously been written when compressing
; 1052 :          different codestream fragments. */
; 1053 :   private: // Structures
; 1054 :       struct kd_tlm_elt {
; 1055 :           kdu_uint16 tnum;
; 1056 :           kdu_uint32 length;
; 1057 :         };
; 1058 :   private: // Data
; 1059 :     int num_tiles;
; 1060 :     int max_tparts;
; 1061 :     int tlm_bytes; // Total number of bytes occupied by TLM marker segments
; 1062 :     int num_elts; // num_tiles * max_tparts
; 1063 :     int elt_ctr; // Pointer to next unfilled entry in `elts'
; 1064 :     kdu_long tile_data_bytes; // sum of all the tile-part lengths added so far
; 1065 :     kd_tlm_elt *elts; // One element for each tile-part, in sequence.
; 1066 :   };
; 1067 : 
; 1068 : /*****************************************************************************/
; 1069 : /*                         kd_tpart_pointer_server                           */
; 1070 : /*****************************************************************************/
; 1071 : 
; 1072 : class kd_tpart_pointer_server {
; 1073 :   public: // Member functions
; 1074 :     kd_tpart_pointer_server()
; 1075 :       {
; 1076 :         groups = NULL; free_list = NULL; tlm_markers = NULL;
; 1077 :         translated_tlm_markers = false;
; 1078 :       }
; 1079 :     ~kd_tpart_pointer_server();
; 1080 :     bool using_tlm_info() { return translated_tlm_markers; }
; 1081 :       /* Returns true if TLM data was used to construct tile-part
; 1082 :          address lists in the most recent call to `translate_markers'. */
; 1083 :     void add_tlm_marker(kd_marker &marker);
; 1084 :       /* Call this function whenever a TLM marker segment is encountered,
; 1085 :          while parsing the main header. */
; 1086 :     void translate_markers(kdu_long first_sot_address,
; 1087 :                            int num_tiles, kd_tile_ref *tile_refs);
; 1088 :       /* Call this function when the main header has been completely read,
; 1089 :          passing in the seek position associated with the first byte of
; 1090 :          the first SOT marker in the code-stream.  This is the location of
; 1091 :          the SOT marker, relative to the start of the code-stream.  It is
; 1092 :          used to convert tile-part lengths into absolute addresses for
; 1093 :          each tile-part.  If no TLM marker segments have been read, the
; 1094 :          function does nothing.  Otherwise, it fills in the tile-part
; 1095 :          address list in each of the `num_tiles' entries of the
; 1096 :          `tile_refs' array.  If the available TLM information is
; 1097 :          insufficient to fully initialize the addresses of all tile-parts
; 1098 :          of each tile, the function issues a warning (since is is strictly
; 1099 :          illegal to have only partial TLM information). */
; 1100 :     void add_tpart(kd_tile_ref *tile_ref, kdu_long sot_address);
; 1101 :       /* Call this function when a new tile-part is encountered in a
; 1102 :          persistent seekable compressed data source, where the tile-part
; 1103 :          address was not already in the list of known tile-part addresses
; 1104 :          for the tile.  This allows the tile to be loaded or reloaded at
; 1105 :          a later time without reparsing the entire code-stream. */
; 1106 :   private: // Definitions
; 1107 : 
; 1108 : #     define KD_POINTER_GROUP_SIZE 32
; 1109 :       struct kd_pointer_group {
; 1110 :           kd_tpart_pointer elements[KD_POINTER_GROUP_SIZE];
; 1111 :           kd_pointer_group *next;
; 1112 :         };
; 1113 :         /* The purpose of this structure is to avoid an unnecessarily large
; 1114 :            number of calls to `new' and `delete'. */
; 1115 : 
; 1116 :       class kd_tlm_marker_list : public kd_marker {
; 1117 :         public: // Member functions
; 1118 :           kd_tlm_marker_list(kd_marker &copy_source) : kd_marker(copy_source)
; 1119 :             { next = NULL; }
; 1120 :         public: // Data
; 1121 :           kd_tlm_marker_list *next;
; 1122 :           int znum; // TLM sequence number used for concatenating info.
; 1123 :         };
; 1124 :         /* Objects of this class are used to store TLM marker segments in
; 1125 :            a list, so that they can be correctly ordered and their contents
; 1126 :            extracted. */
; 1127 : 
; 1128 :   private: // Data
; 1129 :     kd_tlm_marker_list *tlm_markers; // List of TLM marker segments.
; 1130 :     kd_pointer_group *groups; // List of pointer record groups allocated.
; 1131 :     kd_tpart_pointer *free_list; // List of empty pointer records not yet used
; 1132 :     bool translated_tlm_markers;
; 1133 :   };
; 1134 :   /* Notes:
; 1135 :        This object serves two roles: 1) it collects, resequences and
; 1136 :        translates TLM marker segments from the code-stream's main header;
; 1137 :        and 2) it manages the allocation of tile-part address lists, so as
; 1138 :        to avoid excessive memory fragmentation.  The storage for these
; 1139 :        lists is deallocated only when the present object is destroyed. */
; 1140 : 
; 1141 : /*****************************************************************************/
; 1142 : /*                          kd_precinct_pointer_server                       */
; 1143 : /*****************************************************************************/
; 1144 : 
; 1145 : class kd_precinct_pointer_server {
; 1146 :   public: // Member functions
; 1147 :     kd_precinct_pointer_server()
; 1148 :       { buf_server = NULL; }
; 1149 :     ~kd_precinct_pointer_server()
; 1150 :       { disable(); }
; 1151 :     void restart()
; 1152 :       { disable(); } // Called if the code-stream is restarted.
; 1153 :     bool is_active()
; 1154 :       { return (buf_server != NULL); }
; 1155 :     void initialize(kd_buf_server *buf_server)
; 1156 :       /* Call this function when constructing the tile to which the
; 1157 :          object is attached, unless the code-stream is being read from
; 1158 :          a non-seekable source, in which case you should leave the object
; 1159 :          uninitialized and none of the other functions will have any effect. */
; 1160 :       { assert(this->buf_server == NULL); this->buf_server = buf_server;
; 1161 :         head = tail = NULL; head_pos = tail_pos = available_addresses = 0;
; 1162 :         next_address = 0; tpart_bytes_left = 0; num_layers = 0;
; 1163 :         something_served = final_tpart_with_unknown_length = false;
; 1164 :         next_znum = 0; packets_left_in_precinct=0; }
; 1165 :     void add_plt_marker(kd_marker &marker, kdu_params *cod_params,
; 1166 :                         kdu_params *poc_params);
; 1167 :       /* Call this function whenever a PLT marker segment is encountered,
; 1168 :          while parsing a tile-part header.  The `cod_params' and `poc_params'
; 1169 :          arguments must point to the relevant tile's COD and POC parameter
; 1170 :          objects.  The function uses these to determine whether or not the
; 1171 :          pointer information can be used.  In particular, it is used only
; 1172 :          if the current progression order sequences all packets of any
; 1173 :          given precinct together and if the POC object indicates that there
; 1174 :          will be no progression order changes.  These conditions are checked
; 1175 :          again after each tile-part header has been loaded (see the
; 1176 :          `start_tpart_body' member function).  The reason for the conditions
; 1177 :          is that at most one seek address can be maintained for any given
; 1178 :          precinct. */
; 1179 :     void start_tpart_body(kdu_long start_address, kdu_uint32 tpart_body_length,
; 1180 :                           kdu_params *cod_params, kdu_params *poc_params,
; 1181 :                           bool packed_headers,
; 1182 :                           bool final_tpart_with_unknown_length);
; 1183 :       /* This function must be called before addresses can be recovered for
; 1184 :          precincts whose packets appear in the current tile-part.  The
; 1185 :          `start_address' and `tpart_body_length' arguments identify the
; 1186 :          absolute seeking address of the first byte in the body of the
; 1187 :          tile-part and the total number of body bytes in the tile-part.
; 1188 :          These will be used to determine which packets belong to the
; 1189 :          tile-part.  If this is the last tile-part of the tile and its
; 1190 :          length is unknown, the `final_tpart_with_unknown_length' argument
; 1191 :          should be true, and `tpart_body_length' is ignored.
; 1192 :             This function may determine that precinct address information
; 1193 :          cannot be served up for the current tile, for one of a number of
; 1194 :          This is generally because the packets of each precinct are found
; 1195 :          not to be contiguous within the tile-part, or because the presence
; 1196 :          of POC information renders this a likely problem.  If the
; 1197 :          number of quality layers is found to have changed from the point
; 1198 :          when packet length information was first converted into precinct
; 1199 :          lengths and addresses, we must also conclude that address information
; 1200 :          is not available.  A further reason for discarding packet length
; 1201 :          information is if packet headers have been packed into marker
; 1202 :          segments, since this requires that the packets be processed in order
; 1203 :          and once one by one.  If any such determination is made before any
; 1204 :          precinct addresses have been served up, the object is simply
; 1205 :          disabled so that calls to `get_precinct_address' will return 0.
; 1206 :          Otherwise, a terminal error is generated.  In this event, the
; 1207 :          code-stream might need to be opened again with seeking disabled
; 1208 :          so that the present object will never be initialized. */
; 1209 :     kdu_long get_precinct_address()
; 1210 :       { return ((buf_server==NULL)?((kdu_long) 0):pop_address()); }
; 1211 :       /* Returns the address of the next precinct (in the sequence determined
; 1212 :          by the current progression order) in the tile.  This address may be
; 1213 :          used to seek to the relevant location when reading the precinct's
; 1214 :          packets.
; 1215 :             The function returns 0 if seeking is not possible, if
; 1216 :          packet length information cannot be found in the code-stream,
; 1217 :          or if packet length information is not usable for one of a number
; 1218 :          of reasons.  As explained above, packet length information is usable
; 1219 :          only if the packets of a precinct all appear consecutively so that
; 1220 :          each precinct is characterized by only one seeking address.
; 1221 :             The function returns -1 if seeking is possible, but the first
; 1222 :          packet of the precinct belongs to a tile-part which has not yet been
; 1223 :          opened.  In this event, the `kd_tile::read_tile_part_header' member
; 1224 :          function will have to be called until the information becomes
; 1225 :          available. */
; 1226 :   private: // Helper functions
; 1227 :     kdu_long pop_address();
; 1228 :       /* Does all the work of `get_precinct_address'. */
; 1229 :     void disable()
; 1230 :       { // Call to discard contents and cease recording new PLT info.
; 1231 :         if (buf_server == NULL) return;
; 1232 :         while ((tail=head) != NULL)
; 1233 :           { head = tail->next; buf_server->release(tail); }
; 1234 :         buf_server = NULL;
; 1235 :       }
; 1236 :     void initialize_recording()
; 1237 :       { // Call before parsing the first PLT marker segment.
; 1238 :         assert((buf_server != NULL) && (head == NULL));
; 1239 :         head = tail = buf_server->get();
; 1240 :       }
; 1241 :     void record_byte(kdu_byte val)
; 1242 :       { // Call to record a byte of encoded precinct length info.
; 1243 :         assert(tail != NULL);
; 1244 :         if (tail_pos == KD_CODE_BUFFER_LEN)
; 1245 :           { tail=tail->next=buf_server->get(); tail_pos = 0; }
; 1246 :         tail->buf[tail_pos++] = val;
; 1247 :       }
; 1248 :     kdu_byte retrieve_byte()
; 1249 :       { // Call to retrieve a byte of encoded precinct length info.
; 1250 :         assert((head != tail) || (head_pos < tail_pos));
; 1251 :         if (head_pos == KD_CODE_BUFFER_LEN)
; 1252 :           { kd_code_buffer *tmp = head; head=head->next; head_pos = 0;
; 1253 :             buf_server->release(tmp); }
; 1254 :         return head->buf[head_pos++];
; 1255 :       }
; 1256 :   private: // Data
; 1257 :     kd_buf_server *buf_server;
; 1258 :     kd_code_buffer *head, *tail;
; 1259 :     int head_pos; // First valid byte in the `head' buffer (for retrieving)
; 1260 :     int tail_pos; // First unused byte in the `tail' buffer (for recording)
; 1261 :     int available_addresses; // Precinct addresses recorded, but not retrieved
; 1262 :     kdu_long next_address; // Address of the next precinct in current tile-part
; 1263 :     kdu_uint32 tpart_bytes_left; // Bytes left in the current tile-part
; 1264 :     bool final_tpart_with_unknown_length; // If true, previous member ignored
; 1265 :     int num_layers; // Packets/precinct assumption used to parse PLT info
; 1266 :     bool something_served; // False until the first valid address is served
; 1267 :     kdu_byte next_znum; // PLT markers must appear in sequence
; 1268 :     kdu_long precinct_length; // Accumulator for lengths of packets
; 1269 :     int packets_left_in_precinct;
; 1270 :   };
; 1271 : 
; 1272 : /*****************************************************************************/
; 1273 : /*                             kd_compressed_stats                           */
; 1274 : /*****************************************************************************/
; 1275 : 
; 1276 : class kd_compressed_stats {
; 1277 :   /* An object of this class is used to monitor statistics of the compression
; 1278 :      process.  One application of these statistics is the provision of feedback
; 1279 :      to the block encoder concerning a conservative lower bound to the
; 1280 :      distortion-length slope threshold which will be found by the PCRD-opt
; 1281 :      rate allocation algorithm when the image has been fully compressed.  This
; 1282 :      allows the encoder to skip coding passes which are almost certain to be
; 1283 :      discarded.
; 1284 :         The current very simple implementation makes the naive assumption
; 1285 :      that the compressibility of all subband samples is the same, regardless
; 1286 :      of the subband or resolution level.  This is OK if the number of samples
; 1287 :      which have been processed for each subband is proportional to the
; 1288 :      size of the subband, since then the average compressibility is a good
; 1289 :      measure to use in predicting rate control properties.  In practice,
; 1290 :      though, delay through the wavelet transform means that the percentage
; 1291 :      of samples seen for higher resolution subbands is generally higher than
; 1292 :      that seen for lower frequency subbands, until everything has been
; 1293 :      compressed. Since the higher frequency subbands are almost invariably
; 1294 :      more compressible, the predicted compressibility of the source is
; 1295 :      estimated too high and so the predicted rate-distortion slope threshold
; 1296 :      passes considerably more bits than the final rate allocation will.  This
; 1297 :      renders the prediction excessively conservative for most images.  A
; 1298 :      good fix for this would be to keep track of the percentage of subband
; 1299 :      samples which have been compressed in each resolution level and use this
; 1300 :      information to form a more reliable predictor.  This improvement might
; 1301 :      be included in a future version. */
; 1302 :   public: // Member functions
; 1303 :     kd_compressed_stats() { init(); }

	call	?init@kd_compressed_stats@@QAEXXZ	; kd_compressed_stats::init

; 4555 :         this->owner=owner;  buf_server.init(this);

	mov	eax, DWORD PTR _owner$[ebp]
	mov	DWORD PTR [esi+128], eax

; 4556 :         num_outstanding_blocks=0;  stats_codestream = NULL;
; 4557 :         memset(outstanding_blocks,0,

	lea	eax, DWORD PTR [esi+33172]
	push	256					; 00000100H

; 340  :     void init(kd_thread_env *env) { this->env=env; reset(); }

	mov	DWORD PTR [esi+33132], esi

; 341  :     void set_codestream_buf_server(kd_buf_server *buf_server);
; 342  :       /* This function is used to nominate a particular codestream's
; 343  :          `kd_buf_server' object as the ultimate source of all future
; 344  :          buffers served by the present object.  If we are already
; 345  :          attached to a different codestream `buf_server', we must
; 346  :          first detach, releasing any buffers in our local store to
; 347  :          the codestream `buf_server' from which they came.  These
; 348  :          operations are all guarded by the KD_THREADLOCK_GENERAL mutex,
; 349  :          but the present function is always invoked from a context in
; 350  :          which the mutex is not locked.  If `buf_server' is NULL, the
; 351  :          function simply detaches us from any codestream `buf_server'
; 352  :          to which we might presently be attached. */
; 353  :     bool is_attached() { return (ultimate_buf_server != NULL); }
; 354  :       /* Returns true if the last call to `set_codestream_buf_server'
; 355  :          specified a non-NULL codestream `buf_server'. */
; 356  :     void detach_while_holding_general_lock()
; 357  :       { /* Called by `discard_all', so we don't have to unlock and then
; 358  :            relock the `KD_THREADLOCK_GENERAL' mutex. */
; 359  :         if (ultimate_buf_server != NULL)
; 360  :           ultimate_buf_server->detach_thread_buf_server(this);
; 361  :       }
; 362  :     kd_code_buffer *get()
; 363  :       { /* Behaves like `kd_buf_server::get', but allocates initially
; 364  :            from the thread's local buffer store, getting extra data from the
; 365  :            codestream specified in the most recent call to
; 366  :            `set_codestream_buf_server' where required.  This function must
; 367  :            not be called while holding any lock, since it may need to
; 368  :            temporarily instantiate a lock to get extra storage from the
; 369  :            underlying codestream. */
; 370  :         if (head == NULL) augment_local_store(false);
; 371  :         kd_code_buffer *result = head;
; 372  :         if ((head = result->next) == NULL)
; 373  :           tail = NULL;
; 374  :         result->next = NULL;
; 375  :         num_available_buffers--;
; 376  :         return result;
; 377  :       }
; 378  :     void adjust_peak_buffers();
; 379  :       /* This function is called from within `kd_thread_env::flush' to
; 380  :          adjust the value of `peak_buffers', which records the maximum
; 381  :          number of buffers we would like to make available locally
; 382  :          in this thread buffer server.  The calculation uses the fact that
; 383  :          `ref_available_buffers'-`num_available_buffers' equals the number
; 384  :          of buffers which have been obtained via `get', since the last call
; 385  :          to this function.  This quantity is multiplied by a factor
; 386  :          `KD_THREAD_PEAK_STORE_FAC' to obtain a reasonable value for
; 387  :          `peak_buffer', the value of which is adjusted only ever upwards. */
; 388  :     void augment_local_store(bool general_lock_held);
; 389  :       /* This function is used to allocate new buffers from the underlying
; 390  :          codestream, specified in the last call to `set_codestream'.
; 391  :          If `adjust_peak_buffers' has never been called, the
; 392  :          function allocates `KD_THREAD_PEAK_STORE_FAC' times the number of
; 393  :          buffers which have already been served via `get'.  Otherwise, it
; 394  :          allocates exactly `peak_buffers' new buffers.
; 395  :             If `general_lock_held' is false, the `KD_THREADLOCK_GENERAL'
; 396  :          lock is not currently held and must be acquired prior to actually
; 397  :          allocating any new buffers (and released again before returning,
; 398  :          of course).  The function is called in this way only when a call
; 399  :          to `get' finds that the local store of buffers has been
; 400  :          completely exhausted.
; 401  :             The function is called with `general_lock_held' equal to true
; 402  :          from within `kd_thread_env::flush' to take advantage of the fact
; 403  :          that the general lock is already held for other reasons -- i.e.,
; 404  :          to piggy-back the activity of refilling the local buffer store
; 405  :          onto other activities which required the lock. */
; 406  :   private: // Helper functions
; 407  :     friend class kd_buf_server;
; 408  :     void reset()
; 409  :       { // Called by `kd_buf_server::detach_thread_buf_server' after removing
; 410  :         // us from its attached thread buffer list.  This function is also
; 411  :         // used to do most of the work of our own constructor.
; 412  :         ultimate_buf_server = NULL;

	mov	DWORD PTR [esi+33156], 0

; 413  :         next_attached = prev_attached = NULL;

	mov	DWORD PTR [esi+33164], 0
	mov	DWORD PTR [esi+33160], 0

; 414  :         ref_available_buffers = 0;

	mov	DWORD PTR [esi+33144], 0

; 415  :         peak_buffers = 0;

	mov	DWORD PTR [esi+33136], 0

; 416  :         num_available_buffers = 0;

	mov	DWORD PTR [esi+33140], 0

; 417  :         head = tail = NULL;

	mov	DWORD PTR [esi+33152], 0
	mov	DWORD PTR [esi+33148], 0

; 4556 :         num_outstanding_blocks=0;  stats_codestream = NULL;
; 4557 :         memset(outstanding_blocks,0,

	push	0
	push	eax
	mov	DWORD PTR [esi+33168], 0
	mov	DWORD PTR [esi+33128], 0
	call	_memset
	add	esp, 12					; 0000000cH

; 4558 :                sizeof(kd_thread_block_state)*KD_THREAD_MAX_OUTSTANDING_BLOCKS);
; 4559 :       }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0kd_thread_env@@QAE@PAVkdu_thread_env@@@Z ENDP	; kd_thread_env::kd_thread_env
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_precinct_server@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_precinct_server@@QAEPAXI@Z PROC			; kd_precinct_server::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_precinct_server@@QAE@XZ		; kd_precinct_server::~kd_precinct_server
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	32					; 00000020H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_precinct_server@@QAEPAXI@Z ENDP			; kd_precinct_server::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_precinct_server@@QAE@XZ
_TEXT	SEGMENT
??1kd_precinct_server@@QAE@XZ PROC			; kd_precinct_server::~kd_precinct_server, COMDAT
; _this$ = ecx

; 4473 :       {

	push	ebx
	mov	ebx, ecx
	push	esi

; 4474 :         kd_precinct_size_class *tmp;
; 4475 :         while ((tmp=size_classes) != NULL)

	mov	esi, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN3@kd_precinc
	push	edi
	mov	edi, DWORD PTR __imp__free
$LL2@kd_precinc:

; 4476 :           { size_classes = tmp->next; delete tmp; }

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [ebx], eax

; 4423 :         while ((tmp=free_list) != NULL)

	mov	ecx, DWORD PTR [esi+32]
	test	ecx, ecx
	je	SHORT $LN13@kd_precinc
	npad	3
$LL12@kd_precinc:

; 4424 :           { free_list = tmp->next; free(tmp); total_precincts--; }

	mov	eax, DWORD PTR [ecx+44]
	push	ecx
	mov	DWORD PTR [esi+32], eax
	call	edi
	add	esp, 4
	add	DWORD PTR [esi+24], -1
	adc	DWORD PTR [esi+28], -1
	mov	ecx, DWORD PTR [esi+32]
	test	ecx, ecx
	jne	SHORT $LL12@kd_precinc
$LN13@kd_precinc:
	push	40					; 00000028H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete

; 4474 :         kd_precinct_size_class *tmp;
; 4475 :         while ((tmp=size_classes) != NULL)

	mov	esi, DWORD PTR [ebx]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL2@kd_precinc
	pop	edi
$LN3@kd_precinc:
	pop	esi
	pop	ebx

; 4477 :       }

	ret	0
??1kd_precinct_server@@QAE@XZ ENDP			; kd_precinct_server::~kd_precinct_server
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_precinct_server@@QAE@PAVkd_buf_server@@@Z
_TEXT	SEGMENT
_buf_server$ = 8					; size = 4
??0kd_precinct_server@@QAE@PAVkd_buf_server@@@Z PROC	; kd_precinct_server::kd_precinct_server, COMDAT
; _this$ = ecx

; 4469 :     kd_precinct_server(kd_buf_server *buf_server)

	push	ebp
	mov	ebp, esp

; 4470 :       { size_classes = NULL; total_allocated_bytes = 0;
; 4471 :         inactive_head = inactive_tail = NULL; this->buf_server = buf_server; }

	mov	eax, DWORD PTR _buf_server$[ebp]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+16], 0
	pop	ebp
	ret	4
??0kd_precinct_server@@QAE@PAVkd_buf_server@@@Z ENDP	; kd_precinct_server::kd_precinct_server
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Gkd_precinct_size_class@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_precinct_size_class@@QAEPAXI@Z PROC		; kd_precinct_size_class::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 4423 :         while ((tmp=free_list) != NULL)

	mov	ecx, DWORD PTR [esi+32]
	test	ecx, ecx
	je	SHORT $LN6@scalar
	push	edi
	mov	edi, DWORD PTR __imp__free
$LL5@scalar:

; 4424 :           { free_list = tmp->next; free(tmp); total_precincts--; }

	mov	eax, DWORD PTR [ecx+44]
	push	ecx
	mov	DWORD PTR [esi+32], eax
	call	edi
	add	esp, 4
	add	DWORD PTR [esi+24], -1
	adc	DWORD PTR [esi+28], -1
	mov	ecx, DWORD PTR [esi+32]
	test	ecx, ecx
	jne	SHORT $LL5@scalar
	pop	edi
$LN6@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN13@scalar
	push	40					; 00000028H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_precinct_size_class@@QAEPAXI@Z ENDP		; kd_precinct_size_class::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_precinct_size_class@@QAE@XZ
_TEXT	SEGMENT
??1kd_precinct_size_class@@QAE@XZ PROC			; kd_precinct_size_class::~kd_precinct_size_class, COMDAT
; _this$ = ecx

; 4422 :       { kd_precinct *tmp;

	push	esi
	mov	esi, ecx

; 4423 :         while ((tmp=free_list) != NULL)

	mov	ecx, DWORD PTR [esi+32]
	test	ecx, ecx
	je	SHORT $LN3@kd_precinc
	push	edi
	mov	edi, DWORD PTR __imp__free
$LL2@kd_precinc:

; 4424 :           { free_list = tmp->next; free(tmp); total_precincts--; }

	mov	eax, DWORD PTR [ecx+44]
	push	ecx
	mov	DWORD PTR [esi+32], eax
	call	edi
	add	esp, 4
	add	DWORD PTR [esi+24], -1
	adc	DWORD PTR [esi+28], -1
	mov	ecx, DWORD PTR [esi+32]
	test	ecx, ecx
	jne	SHORT $LL2@kd_precinc
	pop	edi
$LN3@kd_precinc:
	pop	esi

; 4425 :         assert(total_precincts == 0);
; 4426 :       }

	ret	0
??1kd_precinct_size_class@@QAE@XZ ENDP			; kd_precinct_size_class::~kd_precinct_size_class
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?release@kd_precinct@@QAEXXZ
_TEXT	SEGMENT
?release@kd_precinct@@QAEXXZ PROC			; kd_precinct::release, COMDAT
; _this$ = ecx

; 4149 :         assert(resolution->codestream->in != NULL);
; 4150 :         num_outstanding_blocks = 0;
; 4151 :         flags |= KD_PFLAG_RELEASED;

	or	DWORD PTR [ecx+8], 16			; 00000010H
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+24], 0

; 4152 :           // released = true;
; 4153 :         if ((flags & KD_PFLAG_ADDRESSABLE) ||

	test	al, 8
	jne	SHORT $LN3@release
	test	al, 4
	je	SHORT $LN8@release
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	cmp	BYTE PTR [eax+337], 0
	jne	SHORT $LN8@release
$LN3@release:

; 4154 :             ((flags & KD_PFLAG_DESEQUENCED) &&
; 4155 :                 // if (addressable ||
; 4156 :                 //     (desequenced &&
; 4157 :              !resolution->codestream->persistent))
; 4158 :           ref->release(); // May unload us from memory!

	mov	edx, DWORD PTR [ecx+4]

; 4160 :     void finished_desequencing()
; 4161 :       /* Called once we can be sure that no more packets will be available
; 4162 :          for this precinct.  In practice, the function is called when the
; 4163 :          last packet has been desequenced or when the containing tile has
; 4164 :          been completely read.  If no packets at all have been desequenced for
; 4165 :          the precinct when this function is called (must have been invoked
; 4166 :          from within `kd_tile::finished_reading'), the precinct is marked
; 4167 :          as addressable, with an address of 0.  This is because it is safe
; 4168 :          to unload such a precinct and then reload it again regardless of
; 4169 :          the services offered by the compressed data source -- there is no
; 4170 :          data actually available from the compressed source for the
; 4171 :          precinct anyway, so reloading is a no-op.
; 4172 :             It should be noted that this function may unload the precinct
; 4173 :          from memory if it is determined that all code-blocks in the
; 4174 :          region of interest (there may be none) have already been consumed. */
; 4175 :       {
; 4176 :         if (flags & KD_PFLAG_DESEQUENCED)
; 4177 :           return;
; 4178 :         flags |= KD_PFLAG_DESEQUENCED;
; 4179 :           // desequenced = true;
; 4180 :         if (next_layer_idx == 0)
; 4181 :           {
; 4182 :             flags |= KD_PFLAG_ADDRESSABLE;
; 4183 :               // addressable = true;
; 4184 :             unique_address = 0;
; 4185 :           }
; 4186 :         if (num_outstanding_blocks == 0)
; 4187 :           release();
; 4188 :       }
; 4189 :     bool desequence_packet()
; 4190 :       /* This function should be called when a non-NULL `kd_precinct_ref'
; 4191 :          pointer is returned by `kd_packet_sequencer::next_in_sequence' and
; 4192 :          its `kd_precinct_ref::is_sequenced' function returns false.
; 4193 :          The function invokes `read_packet' and, if successful, increments
; 4194 :          the precinct's `next_layer_idx' field and the containing tile's
; 4195 :          `num_sequenced_packets' field.
; 4196 :             The function returns false if `read_packet' returns false,
; 4197 :          in which case, more tile-parts must be read (if there are any) to
; 4198 :          recover the information required to desequence the packet.
; 4199 :             Before returning true, the function checks to see whether all
; 4200 :          packets for the tile have been sequenced.  If so, the tile's
; 4201 :          `finished_reading' function is called. */
; 4202 :       {
; 4203 :         kd_tile *tile = resolution->tile_comp->tile;
; 4204 :         assert(!(flags & (KD_PFLAG_DESEQUENCED | KD_PFLAG_ADDRESSABLE)));
; 4205 :         if (!read_packet()) return false;
; 4206 :         next_layer_idx++;
; 4207 :         if (next_layer_idx == tile->num_layers)
; 4208 :           finished_desequencing();
; 4209 :         tile->next_input_packet_num++;
; 4210 :         if ((flags & KD_PFLAG_RELEVANT) &&
; 4211 :             (next_layer_idx <= tile->max_relevant_layers))
; 4212 :           {
; 4213 :             tile->sequenced_relevant_packets++;
; 4214 :             if (tile->sequenced_relevant_packets==tile->max_relevant_packets)
; 4215 :               tile->finished_reading();
; 4216 :           }
; 4217 :         return true;
; 4218 :       }
; 4219 :     void load_required_packets()
; 4220 :       /* If the precinct is addressable, this function uses its
; 4221 :          `unique_address' to position the compressed data source at the
; 4222 :          beginning of the precinct's first packet; it then loads all required
; 4223 :          packets from the compressed source.  Otherwise, the function does
; 4224 :          nothing at all -- reading is presumed to have occurred during packet
; 4225 :          desequencing. */
; 4226 :       {
; 4227 :         if ((!(flags & KD_PFLAG_ADDRESSABLE)) ||
; 4228 :             (unique_address == 0) || (num_packets_read != 0))
; 4229 :           return;
; 4230 :         assert((flags & KD_PFLAG_DESEQUENCED) &&
; 4231 :                (next_layer_idx >= required_layers));
; 4232 :         resolution->codestream->in->seek(unique_address);
; 4233 :         while (num_packets_read < required_layers)
; 4234 :           if (!read_packet())
; 4235 :             break;
; 4236 :       }
; 4237 :     kdu_long simulate_packet(kdu_long &header_bytes,
; 4238 :                              int layer_idx, kdu_uint16 slope_threshold,
; 4239 :                              bool finalize_layer, bool last_layer,
; 4240 :                              kdu_long max_bytes=KDU_LONG_HUGE,
; 4241 :                              bool trim_to_limit=false);
; 4242 :       /* Implements the functionality of `kd_codestream::simulate_output'
; 4243 :          for a single precinct.  Note that the total number of packet bytes
; 4244 :          is left behind in the internal `layer_bytes' array.  This allows the
; 4245 :          determination of tile-part length fields later on when we come to
; 4246 :          construct the code-stream.  The function returns this total number
; 4247 :          of bytes.  It also returns the number of packet header bytes via
; 4248 :          `header_bytes' (the function return value includes the cost of these
; 4249 :          header bytes).
; 4250 :             If the `max_bytes' limit is exceeded, the function may return
; 4251 :          prematurely, without having completed the simulation.  This is
; 4252 :          unacceptable when finalizing a layer, so you must be sure that
; 4253 :          `max_bytes' is sufficient in that case.
; 4254 :             If `trim_to_limit' is true, `finalize_layer' and `last_layer'
; 4255 :          must also both be true.  The function then trims away all coding
; 4256 :          passes from the precinct's code-blocks which are associated with
; 4257 :          slope values of `slope_threshold'+1 or less, until the limit
; 4258 :          associated with `max_bytes' is satisfied.  This functionality is
; 4259 :          used to implement the `sloppy_bytes' capabilities advertised by the
; 4260 :          `kd_codestream::simulate_output' function. */
; 4261 :     kdu_long write_packet(kdu_uint16 slope_threshold, bool empty_packet=false);
; 4262 :       /* Writes out the next packet for this precinct, using the supplied
; 4263 :          distortion-length slope threshold.  Increments the `next_layer_idx'
; 4264 :          field as well as the containing tile's `num_sequenced_packets'
; 4265 :          field when done.  If `empty_packet' is true, an empty packet should
; 4266 :          be issued, having a length of 1 byte, plus the length of any required
; 4267 :          EPH marker (no SOP marker will be attached to empty packets).  The
; 4268 :          function returns the total number of bytes output for the packet. */
; 4269 :   private: // Member functions
; 4270 :     bool read_packet();
; 4271 :       /* Reads a new layer of this precinct sequentially from the
; 4272 :          compressed data source, incrementing the `num_packets_read' member.
; 4273 :          Note that packet reading may be interleaved with acesses to the
; 4274 :          precinct's code-blocks for various reasons.  For example, we
; 4275 :          may initially open a tile with only a limited number of required
; 4276 :          layers, using its code-block data to decompress an approximate
; 4277 :          representation of the image.  We may then find that the additional
; 4278 :          packets need to be loaded in order to advance to other precincts
; 4279 :          in the code-stream.
; 4280 :             The function returns false if an SOT marker (or an EOC marker) is
; 4281 :          encountered.  Note that when an SOT marker is encountered, its
; 4282 :          segment is fully read into the codestream marker service and the
; 4283 :          precinct's tile must be active (otherwise an error message will be
; 4284 :          generated).  Before returning false in this way, the function sets
; 4285 :          the `active_tile' pointer in the codestream object to NULL.  The
; 4286 :          caller may determine the cause of failure by invoking the codestream
; 4287 :          marker service's `get_code' function, which will return one of SOT,
; 4288 :          EOC or 0, where 0 occurs only if the code-stream has been
; 4289 :          exhausted. */
; 4290 :     bool handle_corrupt_packet();
; 4291 :       /* This function implements alternate processing for the `read_packet'
; 4292 :          function in the event that a packet is found to be corrupt.  It is
; 4293 :          called whenever packet corruption is detected, including when the
; 4294 :          precinct is known to have had previously corrupt packets. The function
; 4295 :          manipulates the containing tile's `skipping_to_sop' and
; 4296 :          `next_sop_sequence_num' fields, advancing to the next SOP or SOT
; 4297 :          marker if necessary (the function may be called after detecting an
; 4298 :          SOP marker already, whose sequence number is not as expected).  If
; 4299 :          an SOT marker is encountered, the function renders the current tile
; 4300 :          inactive and returns false (this is the behaviour expected of
; 4301 :          `read_packet').  Otherwise, it updates the precinct and tile state to
; 4302 :          identify the packet as having been read. */
; 4303 :   public: // Public Links and Identification
; 4304 :     kd_resolution *resolution;
; 4305 :     kd_precinct_ref *ref; // Element of `resolution->precinct_refs' array
; 4306 : 
; 4307 :   public: // Mode flags used for decompression and/or interchange
; 4308 :     int flags; // The following flags are defined.
; 4309 :        // KD_PFLAG_GENERATING -- after 1'st call to `kd_precinct::get_packets'
; 4310 :        // KD_PFLAG_CORRUPTED -- if error occurred during packet reading
; 4311 :        // KD_PFLAG_DESEQUENCED -- if all packets have been desequenced
; 4312 :        // KD_PFLAG_ADDRESSABLE -- if seekable, cached or used for interchange
; 4313 :        // KD_PFLAG_RELEASED -- if `activate' must be called to revive state
; 4314 :        // KD_PFLAG_INACTIVE -- if resides on `kd_precict_server's inactive list
; 4315 :        // KD_PFLAG_RELEVANT -- always true if codestream is for non-persistent
; 4316 :        //     input; otherwise, true only if precinct belongs to the relevant
; 4317 :        //     set of precincts of a relevant tile-component-resolution
; 4318 :        // KD_PFLAG_SIGNIFICANT -- if any code-block bytes have been generated
; 4319 :        //     by `kdu_precinct::size_packets' or `kdu_precinct::get_packets'
; 4320 :        // KD_PFLAG_PARSED -- if the precinct was parsed previously and then
; 4321 :        //     unloaded; prevents multiple accumulation of packet length stats
; 4322 :   public: // State variables
; 4323 :     int required_layers; /* Actual number of layers for output codestream;
; 4324 :                 max apparent layers for input or interchange codestream. */
; 4325 :     int next_layer_idx; // Next layer to be sequenced or generated.
; 4326 :     union { // First field used for input; second interchange; third for output
; 4327 :         int num_packets_read; // Incremented when packets read or interchanged
; 4328 :         int cumulative_bytes; // Size of all packets generated so far.
; 4329 :         int saved_next_layer_idx; // Used by "kd_packet_sequencer::save_state"
; 4330 :       };
; 4331 : 
; 4332 :   public: // Activation state variables
; 4333 :     int num_outstanding_blocks; // See notes below.
; 4334 :     union { // First field used only in reading; second only in writing.
; 4335 :         kdu_long unique_address; // See below
; 4336 :         kdu_long *packet_bytes; // Lengths generated during simulated output
; 4337 :       };
; 4338 :   public: // code-block containers
; 4339 :     kd_precinct_band *subbands; // In practice, this member points into the
; 4340 :        // same block of memory which is allocated to hold the precinct so
; 4341 :        // as to encourage memory locality and allow for manipulation of all
; 4342 :        // aspects of a precinct, including all of its code-blocks, via a
; 4343 :        // single heap block.  Note that the number of entries in this array
; 4344 :        // is given by `resolution->num_subbands'.
; 4345 : 
; 4346 :   public: // See below for an explanation of these links
; 4347 :     kd_precinct *next; // Next in free, inactive or generated list
; 4348 :     kd_precinct *prev; // Previous in inactive or generated list
; 4349 :     kd_precinct_size_class *size_class; // For correctly releasing storage
; 4350 :   };
; 4351 :   /* Notes:
; 4352 :         `unique_address' is valid if and only if the precinct is marked as
; 4353 :      addressable, meaning that the precinct has a unique address from which it
; 4354 :      may be loaded (for input codestream objects) or identified (for
; 4355 :      interchange codestream objects).  If addressable, the `unique_address'
; 4356 :      will be 0 if and only if the precinct is known to be empty, meaning that
; 4357 :      reloading the precinct does not require any actual data transfers from a
; 4358 :      compressed data source.
; 4359 :         Except as described above, when used with seekable compressed data
; 4360 :      sources, the `unique_address' member holds a positive quantity which
; 4361 :      identifies an offset into the code-stream at which the precinct's
; 4362 :      packets may be found.  In the case of cached sources (those advertising
; 4363 :      the KDU_SOURCE_CAP_CACHED capability) or codestream objects created for
; 4364 :      interchange (no compressed data source or target), the `unique_address'
; 4365 :      will be negative and -(1+`unique_address') is the precinct's unique
; 4366 :      identifier, as passed to the `kdu_compressed_source::set_precinct_scope'
; 4367 :      function, or returned by the `kdu_precinct::get_unique_id' function.
; 4368 :         The `num_outstanding_blocks' member is used to monitor the number of
; 4369 :      code-blocks from the application's region of interest which have still
; 4370 :      to be consumed (input codestreams) or the number of code-blocks which
; 4371 :      have still to be written in order to complete the precinct (output
; 4372 :      and interchange codestreams).
; 4373 :         The `next' and `prev' links may be used to manage the precinct's
; 4374 :      location in one of three different lists.  The first list is the
; 4375 :      singly-linked free list maintained by `kd_precinct_size_class', from
; 4376 :      which the `kd_precinct_server' object re-issues previously released
; 4377 :      resources.
; 4378 :         The second list on which this structure may find itself is the
; 4379 :      doubly-linked list of currently inactive precincts, which is managed by
; 4380 :      the `kd_precinct_server' object.  Precincts which find themselves on this
; 4381 :      list have been released, but their resources have not yet been recycled.
; 4382 :      They may be successfully re-activated, if their resources have not been
; 4383 :      re-issued to another precinct.  Precincts on this list may be identified
; 4384 :      by the `inactive' flag.  Every inactive precinct necessarily also has
; 4385 :      its `released' member set to true, but the converse is not necessarily
; 4386 :      true.  This is because precincts which have been partially parsed
; 4387 :      in a context for which they were not directly relevant, will be marked
; 4388 :      as released, even though they are not inactive.
; 4389 :         The third list on which this structure may find itself is the
; 4390 :      doubly-linked list of generated precincts managed by the
; 4391 :      `kd_global_rescomp' structure.  This list contains all precincts
; 4392 :      from a given resolution of a given image component, across all tiles,
; 4393 :      which have been fully generated, but not yet flushed out to the
; 4394 :      code-stream.   The list is used to manage incremental rate allocation
; 4395 :      when processing large images.  Elements on this list have not yet
; 4396 :      been closed. */
; 4397 : 
; 4398 : /*****************************************************************************/
; 4399 : /*                         kd_precinct_size_class                            */
; 4400 : /*****************************************************************************/
; 4401 : 
; 4402 :   /* For an explanation of the role played by precinct size classes, see
; 4403 :      the discussion appearing below the declaration of `kd_precinct_server'. */
; 4404 : 
; 4405 : class kd_precinct_size_class {
; 4406 :   public: // Member functions
; 4407 :     kd_precinct_size_class(int max_blocks, int num_subbands,
; 4408 :                            kd_precinct_server *server,
; 4409 :                            kd_buf_server *buf_server)
; 4410 :       {
; 4411 :         this->max_blocks = max_blocks;
; 4412 :         this->num_subbands = num_subbands;
; 4413 :         this->server = server;  this->buf_server = buf_server;
; 4414 :         total_precincts = 0; free_list = NULL; next = NULL;
; 4415 :         alloc_bytes = (int) sizeof(kd_precinct);
; 4416 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4417 :         alloc_bytes += num_subbands * (int) sizeof(kd_precinct_band);
; 4418 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4419 :         alloc_bytes += 4 + max_blocks * (int) sizeof(kd_block);
; 4420 :       }
; 4421 :     ~kd_precinct_size_class()
; 4422 :       { kd_precinct *tmp;
; 4423 :         while ((tmp=free_list) != NULL)
; 4424 :           { free_list = tmp->next; free(tmp); total_precincts--; }
; 4425 :         assert(total_precincts == 0);
; 4426 :       }
; 4427 :     kd_precinct *get()
; 4428 :       {
; 4429 :         if (free_list == NULL)
; 4430 :           augment_free_list();
; 4431 :         kd_precinct *result = free_list; free_list = free_list->next;
; 4432 :         result->next = result->prev = NULL;
; 4433 :         buf_server->augment_structure_bytes(alloc_bytes);
; 4434 :         return result;
; 4435 :       }
; 4436 :     void release(kd_precinct *precinct)
; 4437 :       {
; 4438 :         if (precinct->flags & KD_PFLAG_INACTIVE)
; 4439 :           withdraw_from_inactive_list(precinct);
; 4440 :         precinct->next = free_list;
; 4441 :         free_list = precinct;
; 4442 :         buf_server->augment_structure_bytes(-alloc_bytes);
; 4443 :       }
; 4444 :     void move_to_inactive_list(kd_precinct *precinct);
; 4445 :     void withdraw_from_inactive_list(kd_precinct *precinct);
; 4446 :       /* Used to move precincts onto or off the inactive list maintained
; 4447 :          by the `kd_precinct_server' object to which the present object
; 4448 :          belongs. */
; 4449 :   private: // Helper function
; 4450 :     void augment_free_list();
; 4451 :   private: // Data
; 4452 :     friend class kd_precinct_server;
; 4453 :     kd_precinct_server *server;
; 4454 :     kd_buf_server *buf_server;
; 4455 :     int max_blocks;
; 4456 :     int num_subbands;
; 4457 :     int alloc_bytes; // Num bytes to allocate per precinct.
; 4458 :     kdu_long total_precincts; // Number of precincts allocated with this size
; 4459 :     kd_precinct *free_list; // List of precincts which have been released
; 4460 :     kd_precinct_size_class *next; // Next size class
; 4461 :   };
; 4462 : 
; 4463 : /*****************************************************************************/
; 4464 : /*                           kd_precinct_server                              */
; 4465 : /*****************************************************************************/
; 4466 : 
; 4467 : class kd_precinct_server {
; 4468 :   public: // Member functions
; 4469 :     kd_precinct_server(kd_buf_server *buf_server)
; 4470 :       { size_classes = NULL; total_allocated_bytes = 0;
; 4471 :         inactive_head = inactive_tail = NULL; this->buf_server = buf_server; }
; 4472 :     ~kd_precinct_server()
; 4473 :       {
; 4474 :         kd_precinct_size_class *tmp;
; 4475 :         while ((tmp=size_classes) != NULL)
; 4476 :           { size_classes = tmp->next; delete tmp; }
; 4477 :       }
; 4478 :     kd_precinct *get(int max_blocks, int num_subbands);
; 4479 :     kdu_long get_total_allocated_bytes()
; 4480 :       { return total_allocated_bytes; }
; 4481 :   private: // Data
; 4482 :     friend class kd_precinct_size_class;
; 4483 :     kd_precinct_size_class *size_classes; // List of different size classes.
; 4484 :     kdu_long total_allocated_bytes;
; 4485 :     kd_precinct *inactive_head, *inactive_tail;
; 4486 :     kd_buf_server *buf_server; // Used to manage cacheing, as described below
; 4487 :   };
; 4488 :   /* Notes:
; 4489 :         This object is used to serve up empty precincts and to recycle their
; 4490 :      storage when they are no longer required.  Precinct memory blocks are
; 4491 :      organized into size classes, based on the maximum number of code-blocks
; 4492 :      and precinct-bands in the precinct, where these quantities are consistent
; 4493 :      for all precincts associated with any given `kd_resolution' object.  In
; 4494 :      many cases, it can happen that all precincts from the entire image have
; 4495 :      exactly the same size class.  This maximizes the potential for recycling
; 4496 :      precinct storage, since precincts may only be allocated from and
; 4497 :      recycled back to their own size class.  The reason for this dependence on
; 4498 :      size classes is that the block of memory associated with each precinct
; 4499 :      is large enough to accommodate all `max_blocks' code-blocks which might
; 4500 :      be required to populate the `kd_precinct_band::blocks' arrays and all
; 4501 :      precinct-bands which are required to populate the `kd_precinct::subbands'
; 4502 :      array.  This gets us out of having to maintain separate mechanisms
; 4503 :      to serve up code-block storage as a recyclable resource.  It also helps
; 4504 :      with memory localization.
; 4505 :         The object also manages a cacheing service for precincts and their
; 4506 :      data.  When precincts are released using `kd_precinct_ref::release',
; 4507 :      they are appended to a list of inactive precincts headed by
; 4508 :      `inactive_head' and concluded by `inactive_tail'.  The list is doubly
; 4509 :      linked via the `kd_precinct::next' and `kd_precinct::prev' members.  When
; 4510 :      a previously released precinct is opened using `kd_precinct_ref::open',
; 4511 :      it is removed from this list and its `kd_precinct::activate' function is
; 4512 :      called.  Note that the KD_PFLAG_RELEASED flag is not a reliable
; 4513 :      indicator of whether or not a precinct is on the inactive list, since
; 4514 :      precincts which have been released using `kd_precinct::release', but
; 4515 :      have not yet been completely desequenced (all packets have not yet been
; 4516 :      parsed from or located in the code-stream), will also have this flag
; 4517 :      set, but will not be on an inactive list.  The KD_PFLAG_INACTIVE
; 4518 :      flag should be used to determine whether or not a precinct is on the
; 4519 :      inactive list.
; 4520 :         When `kd_precinct_server::get' function is called, it queries the
; 4521 :      codestream object's `kd_buf_server' service to determine whether or not
; 4522 :      a cache threshold has been exceeded.  If so, it closes down precincts
; 4523 :      on the inactive list until the `kd_buf_server' object reports that
; 4524 :      sufficient resources are in hand. */
; 4525 : 
; 4526 : /*****************************************************************************/
; 4527 : /*                          kd_thread_block_state                            */
; 4528 : /*****************************************************************************/
; 4529 : 
; 4530 : struct kd_thread_block_state {
; 4531 :     kd_block block;
; 4532 :     kd_precinct *target_precinct;
; 4533 :     kd_block *target_block; // see below
; 4534 :   };
; 4535 :   /* An array of these structures is used to maintain information about
; 4536 :      processed code-blocks in thread-local storage, reflecting this information
; 4537 :      only every so often to the `kdu_codestream' machinery, so as to minimize
; 4538 :      thread blocking and cache coherency management overhead.  Each object of
; 4539 :      this class represents a single code-block, identified via the
; 4540 :      `target_precinct' and `target_block' members.
; 4541 :         If `target_precinct' is NULL, the record is empty.  Non-empty records
; 4542 :      may appear anywhere within the `outstanding_blocks' array in
; 4543 :      `kd_thread_env'. */
; 4544 : 
; 4545 : /*****************************************************************************/
; 4546 : /*                              kd_thread_env                                */
; 4547 : /*****************************************************************************/
; 4548 : 
; 4549 : #define KD_THREAD_MAX_OUTSTANDING_BLOCKS 8
; 4550 : 
; 4551 : class kd_thread_env {
; 4552 :   public: // Member functions
; 4553 :     kd_thread_env(kdu_thread_env *owner)
; 4554 :       {
; 4555 :         this->owner=owner;  buf_server.init(this);
; 4556 :         num_outstanding_blocks=0;  stats_codestream = NULL;
; 4557 :         memset(outstanding_blocks,0,
; 4558 :                sizeof(kd_thread_block_state)*KD_THREAD_MAX_OUTSTANDING_BLOCKS);
; 4559 :       }
; 4560 :     kd_thread_block_state *get_block_state(kd_codestream *cs,
; 4561 :                                            kd_precinct *precinct,
; 4562 :                                            kd_block *block)
; 4563 :       {
; 4564 :         if (num_outstanding_blocks == KD_THREAD_MAX_OUTSTANDING_BLOCKS)
; 4565 :           flush(true);
; 4566 :         kd_thread_block_state *scan=outstanding_blocks;
; 4567 :         for (int n=0; n < KD_THREAD_MAX_OUTSTANDING_BLOCKS; n++, scan++)
; 4568 :           if (scan->target_precinct == NULL)
; 4569 :             {
; 4570 :               num_outstanding_blocks++;
; 4571 :               scan->target_precinct=precinct;  scan->target_block=block;
; 4572 :               owner->have_outstanding_blocks = true;
; 4573 :               return scan;
; 4574 :             }
; 4575 :         return NULL; // Should not be possible!!
; 4576 :       }
; 4577 :     void update_stats(kdu_block *blk, kd_codestream *cs)
; 4578 :       { /* Called during encoding after each code-block of data has been
; 4579 :            generated, whenever coding statistics are being kept by the
; 4580 :            relevant codestream.  This function updates the internal coding
; 4581 :            statistics record managed by the `stats' member, which is
; 4582 :            reconciled against the underlying codestream only at appropriate
; 4583 :            intervals, so as to minimize thread blocking conditions. */
; 4584 :         if ((stats_codestream != cs) && (stats_codestream != NULL))
; 4585 :           {
; 4586 :             reconcile_stats();
; 4587 :             stats_codestream = cs;
; 4588 :           }
; 4589 :         stats.update_stats(blk);
; 4590 :       }
; 4591 :     void reconcile_stats();
; 4592 :       /* This function is used to reconcile the temporary information in
; 4593 :          the `stats' member with the coding statistics manager in the
; 4594 :          `kd_codestream' object referenced by the `stats_codestream' member.
; 4595 :          After reconciliation, the `stats' member will be empty and the
; 4596 :          `stats_codestream' member is reset to NULL so that we are free to
; 4597 :          accumulate statistics for a different codestream in the future.
; 4598 :          This function is invoked from `flush' and also if a call to
; 4599 :          `update_stats' specifies a different codestream to that for which
; 4600 :          coding statistics are currently being recorded in the `stats'
; 4601 :          member. */
; 4602 :     void flush(bool force_flush);
; 4603 :       /* Clears the `outstanding_blocks' queue and reconciles any outstanding
; 4604 :          `stats' information.  This function should not be called while
; 4605 :          holding any lock, since it typically needs to acquire its own lock or
; 4606 :          locks.
; 4607 :             If `force_flush' is false, the function may return without
; 4608 :          flushing anything, if it finds that the necessary mutex is already
; 4609 :          held by another thread.  This helps to keep threads alive for as long
; 4610 :          as possible.  A thread will typically try to flush its block queue
; 4611 :          each time it is augmented, once it starts getting close to full.
; 4612 :          A forced flush is required only once the queue becomes completely
; 4613 :          full -- this is performed automatically from within
; 4614 :          `get_block_state'. */
; 4615 :     void discard_all();
; 4616 :       /* This function is called from `kdu_thread_env::do_sync' or
; 4617 :          `kdu_thread_env::on_finished' if an exception has been handled
; 4618 :          by any thread in the working group.  It discards all processed
; 4619 :          code-blocks, returning any associated storage to the internal
; 4620 :          queue, being careful to do so in such a way as to avoid throwing
; 4621 :          further exceptions while acquiring locks. */
; 4622 :   private: // Padding
; 4623 :     kdu_byte _leadin[KDU_MAX_L2_CACHE_LINE];
; 4624 :   public: // Links
; 4625 :     kdu_thread_env *owner;
; 4626 :   public: // Public resources
; 4627 :     kdu_block block; // Thread-local code-block storage
; 4628 :     kd_compressed_stats stats; // Used to temporarily record statistics
; 4629 :     kd_codestream *stats_codestream; // Codestream to which statistics belong
; 4630 :     kd_thread_buf_server buf_server;
; 4631 :     int num_outstanding_blocks;
; 4632 :   private: // Private resources
; 4633 :     kd_thread_block_state outstanding_blocks[KD_THREAD_MAX_OUTSTANDING_BLOCKS];
; 4634 :   private: // Padding
; 4635 :     kdu_byte _trailer[KDU_MAX_L2_CACHE_LINE];
; 4636 :   };
; 4637 : 
; 4638 : 
; 4639 : /* ========================================================================= */
; 4640 : /*         Inlined Member Functions Delayed to Satisfy Dependencies          */
; 4641 : /* ========================================================================= */
; 4642 : 
; 4643 : inline void
; 4644 :   kd_thread_buf_server::set_codestream_buf_server(kd_buf_server *buf_server)
; 4645 : {
; 4646 :   if (buf_server != this->ultimate_buf_server)
; 4647 :     {
; 4648 :       env->owner->acquire_lock(KD_THREADLOCK_GENERAL);
; 4649 :       if (ultimate_buf_server != NULL)
; 4650 :         ultimate_buf_server->detach_thread_buf_server(this);
; 4651 :       if (buf_server != NULL)
; 4652 :         buf_server->attach_thread_buf_server(this);
; 4653 :       assert(buf_server == ultimate_buf_server);
; 4654 :       env->owner->release_lock(KD_THREADLOCK_GENERAL);
; 4655 :     }
; 4656 : }
; 4657 : 
; 4658 : inline bool
; 4659 :   kd_precinct_ref::is_desequenced()
; 4660 : {
; 4661 :   register kdu_long state_val = state;
; 4662 :   return ((state_val != 0) &&
; 4663 :           ((state_val & 1) ||
; 4664 :            (((kd_precinct *) _kdu_long_to_addr(state_val))->flags &
; 4665 :             KD_PFLAG_DESEQUENCED)));
; 4666 : }
; 4667 : 
; 4668 : inline void
; 4669 :   kd_precinct_ref::clear()
; 4670 : {
; 4671 :   if (state && !(state & 1))
; 4672 :     {
; 4673 :       kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);
; 4674 :       precinct->ref = NULL; // Satisfy the test in `kd_precinct::closing'
; 4675 :       precinct->closing();
; 4676 :       precinct->size_class->release(precinct);
; 4677 :     }
; 4678 :   state = 0;
; 4679 : }
; 4680 : 
; 4681 : inline void
; 4682 :   kd_precinct_ref::close_and_reset()
; 4683 : {
; 4684 :   if (state & 1)
; 4685 :     {
; 4686 :       if (state != 3)
; 4687 :         state &= ~((kdu_long) 2);
; 4688 :     }
; 4689 :   else if (state != 0)
; 4690 :     {
; 4691 :       kd_precinct *prec = (kd_precinct *) _kdu_long_to_addr(state);
; 4692 :       if ((prec->flags & KD_PFLAG_PARSED)||(prec->num_packets_read > 0))
; 4693 :         {
; 4694 :           close();
; 4695 :           state &= ~((kdu_long) 2);
; 4696 :         }
; 4697 :     }
; 4698 : }
; 4699 : 
; 4700 : inline void
; 4701 :   kd_precinct_ref::release()
; 4702 : {
; 4703 :   kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);

	mov	ecx, DWORD PTR [edx]

; 4704 :   assert((state != 0) && !(state & 1));
; 4705 :   if (precinct->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [ecx+8]
	test	al, 32					; 00000020H
	jne	SHORT $LN8@release

; 4706 :     return; // Already on the inactive list.
; 4707 :   precinct->flags |= KD_PFLAG_RELEASED;

	or	eax, 16					; 00000010H
	mov	DWORD PTR [ecx+8], eax

; 4708 :     // precinct->released = true; // In case not already set.
; 4709 :   if ((precinct->flags & KD_PFLAG_ADDRESSABLE) &&
; 4710 :       (!precinct->resolution->codestream->cached) &&

	test	al, 8
	je	SHORT $LN7@release
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	cmp	BYTE PTR [eax+338], 0
	jne	SHORT $LN7@release
	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN9@release
	cmp	eax, DWORD PTR [ecx+16]
	jne	SHORT $LN7@release
$LN9@release:

; 4711 :       ((precinct->num_packets_read == 0) ||
; 4712 :        (precinct->num_packets_read == precinct->next_layer_idx)))
; 4713 :     precinct->size_class->move_to_inactive_list(precinct);

	push	ecx
	mov	ecx, DWORD PTR [ecx+52]
	call	?move_to_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::move_to_inactive_list
$LN8@release:

; 4159 :       }

	ret	0
$LN7@release:

; 4714 :   else
; 4715 :     close();

	mov	ecx, edx
	jmp	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close
?release@kd_precinct@@QAEXXZ ENDP			; kd_precinct::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?set_discard@kd_block@@QAEXXZ
_TEXT	SEGMENT
?set_discard@kd_block@@QAEXXZ PROC			; kd_block::set_discard, COMDAT
; _this$ = ecx

; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;

	mov	BYTE PTR [ecx+10], 255			; 000000ffH

; 3798 :       }

	ret	0
?set_discard@kd_block@@QAEXXZ ENDP			; kd_block::set_discard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?transfer_data@kd_block@@QAEXAAV1@@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
?transfer_data@kd_block@@QAEXAAV1@@Z PROC		; kd_block::transfer_data, COMDAT
; _this$ = ecx

; 3698 :       { /* Like `store_data', but gets results from another block.  Exploits

	push	ebp
	mov	ebp, esp

; 3699 :            the layout of the object to copy only whole pointers or whole
; 3700 :            32-bit words, even where these represent multiple fields. */
; 3701 :         current_buf = first_buf = src.first_buf;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 3703 :         src.current_buf = src.first_buf = NULL;

	mov	DWORD PTR [edx], 0
	mov	DWORD PTR [edx+4], 0

; 3704 :       }

	pop	ebp
	ret	4
?transfer_data@kd_block@@QAEXAAV1@@Z ENDP		; kd_block::transfer_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?cleanup@kd_block@@QAEXPAVkd_buf_server@@@Z
_TEXT	SEGMENT
_buf_server$ = 8					; size = 4
?cleanup@kd_block@@QAEXPAVkd_buf_server@@@Z PROC	; kd_block::cleanup, COMDAT
; _this$ = ecx

; 3608 :       {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 3609 :         while ((current_buf=first_buf) != NULL)

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	je	SHORT $LN11@cleanup
	push	edi
	mov	edi, DWORD PTR _buf_server$[ebp]
$LL2@cleanup:

; 3610 :           { first_buf=current_buf->next;  buf_server->release(current_buf); }

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, edi
	push	DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	jne	SHORT $LL2@cleanup
	pop	edi
$LN11@cleanup:

; 3613 :     kd_code_buffer *cleanup()
; 3614 :       { // As above, but returns the linked list of buffers
; 3615 :         kd_code_buffer *result = first_buf;  first_buf = current_buf = NULL;
; 3616 :         set_discard();
; 3617 :         return result;
; 3618 :       }
; 3619 : 
; 3620 :   // --------------------------------------------------------------------------
; 3621 :   public: // Packet manipulation member functions
; 3622 :     int parse_packet_header(kd_header_in &head, kd_buf_server *buf_server,
; 3623 :                             int layer_idx); // Throws (kdu_uint16 code)
; 3624 :       /* Parses bits in the packet header corresponding to the current
; 3625 :          block for the current layer (this must be the next layer for which
; 3626 :          information has not yet been parsed).  The function returns the
; 3627 :          number of new body bytes contributed by the code-block in this layer
; 3628 :          and also stores this value internally to be used in subsequent calls
; 3629 :          to the `read_body_bytes' member function.
; 3630 :             The `kd_header_in' object may throw an exception if the packet
; 3631 :          data terminates unexpectedly.  Moreover, to assist in locating and
; 3632 :          possibly recovering from errors, the present function may throw a
; 3633 :          16-bit unsigned integer exception code, which is either the value of
; 3634 :          an illegal marker code encountered in the packet header, or one of
; 3635 :          the special exception codes, KDU_EXCEPTION_PRECISION or
; 3636 :          KDU_EXCEPTION_ILLEGAL_LAYER. */
; 3637 :     void read_body_bytes(kd_input *source, kd_buf_server *buf_server,
; 3638 :                          bool in_memory_source)
; 3639 :       { /* This function should be called after parsing the header of a
; 3640 :            packet.  It reads the code-bytes contributed by the code-block to
; 3641 :            this packet.  If `in_memory_source' is true, only the address of
; 3642 :            the code-bytes is recorded, and then only if the length of the
; 3643 :            code-byte segment is non-zero. */
; 3644 :         if (this->temp_length > 0)
; 3645 :           {
; 3646 :             if (num_passes == 255)
; 3647 :               { // Read and discard the code-bytes.
; 3648 :                 assert(first_buf == NULL);  source->ignore(this->temp_length);
; 3649 :               }
; 3650 :             else if (in_memory_source)
; 3651 :               {
; 3652 :                 kdu_byte *addr;
; 3653 :                 this->num_bytes += source->pseudo_read(addr,this->temp_length);
; 3654 :                 put_address(addr,buf_server);
; 3655 :               }
; 3656 :             else
; 3657 :               this->num_bytes +=
; 3658 :                 source->read(current_buf,buf_pos,buf_server,this->temp_length);
; 3659 :             this->temp_length = 0;
; 3660 :           }
; 3661 :       }
; 3662 :     void retrieve_data(kdu_block *block, int max_layers, int discard_passes,
; 3663 :                        bool in_memory_source);
; 3664 :       /* Retrieves compressed code-bytes, number of coding passes and codeword
; 3665 :          segment lengths from the current code-block and stores them in the
; 3666 :          `block' object.  All fields which are common for compression and
; 3667 :          decompression have already been filled out by the caller.  The
; 3668 :          byte buffer is allocated so as to be large enough to allow a
; 3669 :          2 byte marker code to be appended to the compressed data,
; 3670 :          if desired -- see declaration of "kdu_subband::open_block".
; 3671 :             The `max_layers' argument identifies the maximum number of
; 3672 :          quality layers for which code-block contributions are to be
; 3673 :          retrieved.
; 3674 :             The `discard_passes' argument indicates the number of additional
; 3675 :          coding passes to be removed, if any.
; 3676 :             If `in_memory_source' is true, the layer code bytes are not
; 3677 :          stored in the `kd_code_buffer' list embedded inside `block'.  Instead,
; 3678 :          the `kd_code_buffer' list stores only the header information for
; 3679 :          each layer, along with the address of the code bytes, which reside
; 3680 :          in the memory block managed by an in-memory compressed data source
; 3681 :          (one which offers the `KDU_SOURCE_CAP_IN_MEMORY') capability.  In
; 3682 :          this case, we retrieve the address and then perform a simple memory
; 3683 :          block copy operation to efficiently retrieve the code bytes for
; 3684 :          each layer. */
; 3685 :     void store_data(kdu_block *block, kd_buf_server *buf_server);
; 3686 :       /* Stores compressed code-bytes, pass length and pass slope information
; 3687 :          from the `block' object into the current code-block.  This function
; 3688 :          is invoked by "kdu_subband::close_block" when the containing
; 3689 :          codestream object was not constructed for input.  Also reflects
; 3690 :          the `msbs_w' value into higher nodes in the tag tree. */
; 3691 :     void store_data(kdu_block *block, kd_thread_buf_server *thread_buf_server);
; 3692 :       /* Same as the above function, but uses `kd_thread_buf_server::get'
; 3693 :          rather than `kd_buf_server::get' to get new code buffers.  This
; 3694 :          version is used to save code-block state in multi-threaded
; 3695 :          environments so as to minimize cache coherency bottlenecks and the
; 3696 :          need to lock shared resources. */
; 3697 :     void transfer_data(kd_block &src)
; 3698 :       { /* Like `store_data', but gets results from another block.  Exploits
; 3699 :            the layout of the object to copy only whole pointers or whole
; 3700 :            32-bit words, even where these represent multiple fields. */
; 3701 :         current_buf = first_buf = src.first_buf;
; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);
; 3703 :         src.current_buf = src.first_buf = NULL;
; 3704 :       }
; 3705 :     bool trim_data(kdu_uint16 slope_threshold, kd_buf_server *buf_server);
; 3706 :       /* This function serves two purposes: it helps reduce the amount of
; 3707 :          compressed data which must be buffered in memory while compressing
; 3708 :          an image; and it allows individual block contributions to be
; 3709 :          discarded during packet construction in order to tightly fit the
; 3710 :          generated bit-rate to the target compressed bit-rate.
; 3711 :             The function sets all coding pass slopes which are less than or
; 3712 :          equal to the supplied slope threshold to 0 and then discards all
; 3713 :          code bytes which could not possibly be included in the final
; 3714 :          code-stream, as a result of this modification.
; 3715 :             If anything was discarded, the function returns true.  Otherwise,
; 3716 :          it returns false. */
; 3717 :     int start_packet(int layer_idx, kdu_uint16 slope_threshold);
; 3718 :       /* Call this function only during rate allocation or packet generation.
; 3719 :          Before the first call to this function, you must reset the tag tree
; 3720 :          (see the "reset_output_tree" member function).  If you are calling
; 3721 :          the function multiple times with the same layer for rate allocation
; 3722 :          purposes, you must use "save_output_tree" and "restore_output_tree"
; 3723 :          as described below.
; 3724 :             The function leaves behind information about the number of new
; 3725 :          coding passes and the number of new code bytes which would be
; 3726 :          contributed by this code-block if the supplied threshold were actually
; 3727 :          used.  The final contributing coding pass must have a non-zero
; 3728 :          distortion-length slope which is strictly greater than the slope
; 3729 :          threshold.  It also updates the tag tree structure to reflect any
; 3730 :          new knowledge about the first layer to which this code-block would
; 3731 :          contribute.  This information is picked up by "write_packet_header".
; 3732 :             The function's return value is the total number of new code-bytes
; 3733 :          contributed by the block.  This allows the PCRD-opt algorithm to
; 3734 :          determine roughly the right slope threshold before committing to the
; 3735 :          work of simulating packet header generation. */
; 3736 :     void write_packet_header(kd_header_out &head, int layer_idx,
; 3737 :                              bool simulate);
; 3738 :       /* Call this function only after a `start_packet' call.  It writes
; 3739 :          (or simulates the writing of) packet header information corresponding
; 3740 :          to the code-block inclusion information set up by `start_packet'.
; 3741 :          If `simulate' is true, some internal state adjustments are delayed
; 3742 :          until the next call to "save_output_tree", so multiple calls to
; 3743 :          "start_packet" and "write_packet_header" may be issued with the same
; 3744 :          layer index to determine an optimal slope threshold.  Otherwise,
; 3745 :          if `simulate' is false, the internal state information is fully
; 3746 :          updated and the "save_output_tree" and "restore_output_tree" functions
; 3747 :          need not and should not be called. */
; 3748 :     void write_body_bytes(kdu_output *dest);
; 3749 :       /* This function should be called after a non-simulated
; 3750 :          "write_packet_header" call to output the newly included body bytes.
; 3751 :          The actual number of bytes to be written was left behind by
; 3752 :          the preceding "start_packet" call in the `temp_length' field. */
; 3753 :   // --------------------------------------------------------------------------
; 3754 :   public: // Static functions used to operate on tag-trees built from kd_block
; 3755 :     static kd_block *build_tree(kdu_coords size, kdu_byte * &mem_block);
; 3756 :       /* Builds a full tag tree returning a pointer to the upper left hand
; 3757 :          corner leaf node.  Apart from the `up_down' navigation pointers,
; 3758 :          all fields are initialized to 0.  This is appropriate for tag tree
; 3759 :          decoding, but encoders will need to call "reset_output_tree" and
; 3760 :          use "start_packet" to install appropriate node values.
; 3761 :             The tag tree is not allocated from the heap.  Instead, it is
; 3762 :          allocated from an existing memory block, identified by the `mem_block'
; 3763 :          argument.  This memory block is assumed to be large enough to hold
; 3764 :          the array of `kd_block' structures.  Upon return, the `mem_block'
; 3765 :          value is advanced by an amount equal to the size of the tag tree
; 3766 :          array. */
; 3767 :     static void reset_output_tree(kd_block *tree, kdu_coords size);
; 3768 :       /* Call this function immediately before simulating or actually
; 3769 :          generating any packet data for the relevant code-blocks.  Once
; 3770 :          the PCRD-opt algorithm has completed, you should call this function
; 3771 :          a second time to prepare for actual packet output.  The function
; 3772 :          initializes the threshold state variables, `layer_w_bar' and
; 3773 :          `msbs_w_bar' to 0, and the value state variables, `layer_w' and
; 3774 :          `msbs_w' to their maximum representable values.  The succession of
; 3775 :          "start_packet" calls will update the value variables `layer_w'
; 3776 :          and `msbs_w' in such a way that the tag tree coding process runs
; 3777 :          correctly in each subsequent call to "write_packet_header". */
; 3778 :     static void save_output_tree(kd_block *tree, kdu_coords size);
; 3779 :       /* Call this only during rate allocation, before moving on to a new
; 3780 :          layer.  The function saves the current state (`msbs_wbar' and
; 3781 :          `layer_wbar') of each node in the tag tree.  For leaf nodes, it also
; 3782 :          commits the number of new coding passes found in the last call to
; 3783 :          "start_packet". */
; 3784 :     static void restore_output_tree(kd_block *tree, kdu_coords size);
; 3785 :       /* Call this during rate allocation before supplying a new slope
; 3786 :          threshold for the same layer index, in a new "start_packet" call.
; 3787 :          The function restores the `msbs_w_bar' and `layer_w_bar' values
; 3788 :          previously saved by "save_output_tree". */
; 3789 :   // --------------------------------------------------------------------------
; 3790 :   public: // State identification functions
; 3791 :     void set_discard()
; 3792 :       { /* Use this function only with input-oriented operations.  It informs
; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;

	mov	BYTE PTR [esi+10], 255			; 000000ffH
	pop	esi

; 3611 :         set_discard(); // Discard from any packets parsed in the future
; 3612 :       }

	pop	ebp
	ret	4
?cleanup@kd_block@@QAEXPAVkd_buf_server@@@Z ENDP	; kd_block::cleanup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?is_desequenced@kd_precinct_ref@@QAE_NXZ
_TEXT	SEGMENT
?is_desequenced@kd_precinct_ref@@QAE_NXZ PROC		; kd_precinct_ref::is_desequenced, COMDAT
; _this$ = ecx

; 4661 :   register kdu_long state_val = state;

	mov	edx, DWORD PTR [ecx]

; 4662 :   return ((state_val != 0) &&

	mov	eax, edx
	or	eax, DWORD PTR [ecx+4]
	je	SHORT $LN4@is_deseque
	mov	eax, edx
	and	eax, 1
	or	eax, 0
	jne	SHORT $LN3@is_deseque
	test	BYTE PTR [edx+8], 4
	je	SHORT $LN4@is_deseque
$LN3@is_deseque:
	mov	al, 1

; 4663 :           ((state_val & 1) ||
; 4664 :            (((kd_precinct *) _kdu_long_to_addr(state_val))->flags &
; 4665 :             KD_PFLAG_DESEQUENCED)));
; 4666 : }

	ret	0
$LN4@is_deseque:

; 4662 :   return ((state_val != 0) &&

	xor	al, al

; 4663 :           ((state_val & 1) ||
; 4664 :            (((kd_precinct *) _kdu_long_to_addr(state_val))->flags &
; 4665 :             KD_PFLAG_DESEQUENCED)));
; 4666 : }

	ret	0
?is_desequenced@kd_precinct_ref@@QAE_NXZ ENDP		; kd_precinct_ref::is_desequenced
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?release@kd_precinct_ref@@QAEXXZ
_TEXT	SEGMENT
?release@kd_precinct_ref@@QAEXXZ PROC			; kd_precinct_ref::release, COMDAT
; _this$ = ecx

; 4702 : {

	mov	edx, ecx

; 4703 :   kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);

	mov	ecx, DWORD PTR [edx]

; 4704 :   assert((state != 0) && !(state & 1));
; 4705 :   if (precinct->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [ecx+8]
	test	al, 32					; 00000020H
	jne	SHORT $LN4@release

; 4706 :     return; // Already on the inactive list.
; 4707 :   precinct->flags |= KD_PFLAG_RELEASED;

	or	eax, 16					; 00000010H
	mov	DWORD PTR [ecx+8], eax

; 4708 :     // precinct->released = true; // In case not already set.
; 4709 :   if ((precinct->flags & KD_PFLAG_ADDRESSABLE) &&
; 4710 :       (!precinct->resolution->codestream->cached) &&

	test	al, 8
	je	SHORT $LN3@release
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	cmp	BYTE PTR [eax+338], 0
	jne	SHORT $LN3@release
	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN5@release
	cmp	eax, DWORD PTR [ecx+16]
	jne	SHORT $LN3@release
$LN5@release:

; 4711 :       ((precinct->num_packets_read == 0) ||
; 4712 :        (precinct->num_packets_read == precinct->next_layer_idx)))
; 4713 :     precinct->size_class->move_to_inactive_list(precinct);

	push	ecx
	mov	ecx, DWORD PTR [ecx+52]
	call	?move_to_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::move_to_inactive_list
$LN4@release:

; 4716 : }

	ret	0
$LN3@release:

; 4714 :   else
; 4715 :     close();

	mov	ecx, edx
	jmp	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close
?release@kd_precinct_ref@@QAEXXZ ENDP			; kd_precinct_ref::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?open@kd_precinct_ref@@QAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@_N@Z
_TEXT	SEGMENT
_res$ = 8						; size = 4
_pos_idx$ = 12						; size = 8
_need_activate$ = 20					; size = 1
?open@kd_precinct_ref@@QAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@_N@Z PROC ; kd_precinct_ref::open, COMDAT
; _this$ = ecx

; 4721 : {

	push	ebp
	mov	ebp, esp

; 4722 :   if (state == 3)

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	edx, 3
	jne	SHORT $LN2@open
	test	esi, esi
	jne	SHORT $LN2@open

; 4723 :     return NULL; // Precinct is not currently loaded

	xor	eax, eax
	pop	esi

; 4735 : }

	pop	ebp
	ret	16					; 00000010H
$LN2@open:

; 4724 :   if ((state == 0) || (state & 1))

	mov	eax, edx
	or	eax, esi
	je	SHORT $LN4@open
	and	edx, 1
	or	edx, 0
	jne	SHORT $LN4@open

; 4726 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state);

	mov	esi, DWORD PTR [ecx]

; 4727 :   if (result->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [esi+8]
	test	al, 32					; 00000020H
	je	SHORT $LN5@open

; 4728 :     { // Must be on the inactive list
; 4729 :       result->size_class->withdraw_from_inactive_list(result);

	mov	ecx, DWORD PTR [esi+52]
	push	esi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list

; 4733 :     result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate

; 4734 :   return result;

	mov	eax, esi
	pop	esi

; 4735 : }

	pop	ebp
	ret	16					; 00000010H
$LN5@open:

; 4730 :       result->activate();
; 4731 :     }
; 4732 :   else if (need_activate && (result->flags & KD_PFLAG_RELEASED))

	cmp	BYTE PTR _need_activate$[ebp], 0
	je	SHORT $LN7@open
	test	al, 16					; 00000010H
	je	SHORT $LN7@open

; 4733 :     result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate
$LN7@open:

; 4734 :   return result;

	mov	eax, esi
	pop	esi

; 4735 : }

	pop	ebp
	ret	16					; 00000010H
$LN4@open:

; 4725 :     return instantiate_precinct(res,pos_idx);

	push	DWORD PTR _pos_idx$[ebp+4]
	push	DWORD PTR _pos_idx$[ebp]
	push	DWORD PTR _res$[ebp]
	call	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
	pop	esi

; 4735 : }

	pop	ebp
	ret	16					; 00000010H
?open@kd_precinct_ref@@QAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@_N@Z ENDP ; kd_precinct_ref::open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?deref@kd_precinct_ref@@QAEPAUkd_precinct@@XZ
_TEXT	SEGMENT
?deref@kd_precinct_ref@@QAEPAUkd_precinct@@XZ PROC	; kd_precinct_ref::deref, COMDAT
; _this$ = ecx

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	mov	eax, DWORD PTR [ecx]
	and	eax, 1
	or	eax, 0
	je	SHORT $LN3@deref
	xor	eax, eax
	ret	0
$LN3@deref:
	mov	eax, DWORD PTR [ecx]
	ret	0
?deref@kd_precinct_ref@@QAEPAUkd_precinct@@XZ ENDP	; kd_precinct_ref::deref
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_tile@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_tile@@QAEPAXI@Z PROC				; kd_tile::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_tile@@QAE@XZ			; kd_tile::~kd_tile
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	272					; 00000110H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_tile@@QAEPAXI@Z ENDP				; kd_tile::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_codestream@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_codestream@@QAEPAXI@Z PROC			; kd_codestream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_codestream@@QAE@XZ		; kd_codestream::~kd_codestream
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	416					; 000001a0H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_codestream@@QAEPAXI@Z ENDP			; kd_codestream::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?freeze_comments@kd_codestream@@AAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
_com$2 = -4						; size = 4
?freeze_comments@kd_codestream@@AAEXXZ PROC		; kd_codestream::freeze_comments, COMDAT
; _this$ = ecx

; 5044 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx

; 5045 :   if (comments_frozen)

	cmp	BYTE PTR [ebx+342], 0
	jne	$LN1@freeze_com

; 5046 :     return;
; 5047 : #ifdef KDU_IDENTIFIER
; 5048 :   kd_codestream_comment *comscan;
; 5049 :   for (comscan=comhead; comscan != NULL; comscan=comscan->next)

	push	esi
	push	edi
	mov	edi, DWORD PTR [ebx+44]
	test	edi, edi
	je	SHORT $LN23@freeze_com
	npad	3
$LL4@freeze_com:

; 5052 :       if (strcmp(com.get_text(),KDU_IDENTIFIER) == 0)

	lea	ecx, DWORD PTR _com$2[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 471  :     kdu_codestream_comment(kd_codestream_comment *state) { this->state=state; }

	mov	DWORD PTR _com$2[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5052 :       if (strcmp(com.get_text(),KDU_IDENTIFIER) == 0)

	mov	esi, OFFSET ??_C@_0M@DAABJAJJ@Kakadu?9v6?41?$AA@
	call	?get_text@kdu_codestream_comment@@QAEPBDXZ ; kdu_codestream_comment::get_text
$LL24@freeze_com:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN25@freeze_com
	test	cl, cl
	je	SHORT $LN26@freeze_com
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN25@freeze_com
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL24@freeze_com
$LN26@freeze_com:
	xor	eax, eax
	jmp	SHORT $LN27@freeze_com
$LN25@freeze_com:
	sbb	eax, eax
	or	eax, 1
$LN27@freeze_com:
	test	eax, eax
	je	SHORT $LN19@freeze_com

; 5046 :     return;
; 5047 : #ifdef KDU_IDENTIFIER
; 5048 :   kd_codestream_comment *comscan;
; 5049 :   for (comscan=comhead; comscan != NULL; comscan=comscan->next)

	mov	edi, DWORD PTR [edi+16]
	test	edi, edi
	jne	SHORT $LL4@freeze_com

; 5053 :         break;
; 5054 :     }
; 5055 :   if (comscan == NULL)

	jmp	SHORT $LN23@freeze_com
$LN19@freeze_com:
	test	edi, edi
	jne	SHORT $LN9@freeze_com
$LN23@freeze_com:

; 5057 :       comscan = new kd_codestream_comment;

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], esi
	test	esi, esi
	je	SHORT $LN11@freeze_com
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1467 :       { readonly=false; max_chars=num_chars=0; text_buf=NULL; next=NULL; }

	mov	BYTE PTR [esi], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5057 :       comscan = new kd_codestream_comment;

	jmp	SHORT $LN12@freeze_com
$LN11@freeze_com:
	xor	esi, esi
$LN12@freeze_com:

; 5058 :       comscan->set_text((int) strlen(KDU_IDENTIFIER),

	push	OFFSET ??_C@_0M@DAABJAJJ@Kakadu?9v6?41?$AA@
	push	11					; 0000000bH
	mov	ecx, esi
	call	?set_text@kd_codestream_comment@@QAEXHPAE@Z ; kd_codestream_comment::set_text

; 5059 :                         (kdu_byte *) KDU_IDENTIFIER);
; 5060 :       if (comtail == NULL)

	mov	eax, DWORD PTR [ebx+48]
	test	eax, eax
	jne	SHORT $LN8@freeze_com

; 5061 :         comhead = comtail = comscan;

	pop	edi
	mov	DWORD PTR [ebx+44], esi

; 5062 :       else
; 5063 :         comtail = comtail->next = comscan;

	mov	DWORD PTR [ebx+48], esi
	pop	esi

; 5064 :     }
; 5065 : #endif // KDU_IDENTIFIER
; 5066 :   comments_frozen = true;

	mov	BYTE PTR [ebx+342], 1
	pop	ebx

; 5067 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@freeze_com:

; 5062 :       else
; 5063 :         comtail = comtail->next = comscan;

	mov	DWORD PTR [eax+16], esi
	mov	DWORD PTR [ebx+48], esi
$LN9@freeze_com:

; 5064 :     }
; 5065 : #endif // KDU_IDENTIFIER
; 5066 :   comments_frozen = true;

	pop	edi
	mov	BYTE PTR [ebx+342], 1
	pop	esi
$LN1@freeze_com:
	pop	ebx

; 5067 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?freeze_comments@kd_codestream@@AAEXXZ ENDP		; kd_codestream::freeze_comments
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?read_main_header@kd_codestream@@AAEXXZ
_TEXT	SEGMENT
_w$2 = -60						; size = 20
_w$3 = -40						; size = 20
_e$4 = -40						; size = 20
_e$5 = -40						; size = 20
$T6 = -20						; size = 4
$T7 = -20						; size = 4
$T8 = -20						; size = 4
_have_tlm$1$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
?read_main_header@kd_codestream@@AAEXXZ PROC		; kd_codestream::read_main_header, COMDAT
; _this$ = ecx

; 4953 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_main_header@kd_codestream@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 4954 :   if (in == NULL)

	cmp	DWORD PTR [esi+4], 0
	je	$LN1@read_main_

; 4955 :     return;
; 4956 :   bool have_tlm = false;

	mov	BYTE PTR _have_tlm$1$[ebp], 0
	mov	edi, 65365				; 0000ff55H
	npad	3
$LL83@read_main_:

; 4957 :   do {
; 4958 :       if (!marker->read())

	mov	ecx, DWORD PTR [esi+16]
	mov	ebx, 65376				; 0000ff60H
	push	0
	push	0
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
	test	al, al
	jne	SHORT $LN6@read_main_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 528  :         return exhausted;

	mov	eax, DWORD PTR [esi+4]
	mov	al, BYTE PTR [eax+533]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4960 :           if (in->failed())

	test	al, al
	jne	$LN79@read_main_

; 4962 :           KDU_ERROR(e,35); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0CJ@KOLIFCGA@Main?5code?9stream?5header?5appears?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4962 :           KDU_ERROR(e,35); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4964 :         }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN6@read_main_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	ecx, DWORD PTR [esi+16]
	movzx	edx, WORD PTR [ecx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4965 :       if (marker->get_code() == KDU_PPM)

	cmp	dx, bx
	jne	$LN8@read_main_

; 4966 :         {
; 4967 :           if (cached)

	cmp	BYTE PTR [esi+338], 0
	je	SHORT $LN10@read_main_

; 4968 :             { KDU_ERROR_DEV(e,36); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0GH@CBFAGHCH@You?5cannot?5use?5PPM?5or?5PPT?5marker@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4968 :             { KDU_ERROR_DEV(e,36); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4972 :             }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN10@read_main_:

; 4973 :           if (profile == 0)

	cmp	DWORD PTR [esi+104], 0
	jne	SHORT $LN11@read_main_

; 4974 :             { KDU_WARNING(w,14);  w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$3[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$3[ebp]
	lea	ecx, DWORD PTR _w$3[ebp]
	push	OFFSET ??_C@_0KL@JPMPCIAA@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4974 :             { KDU_WARNING(w,14);  w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4980 :             }

	lea	ecx, DWORD PTR _w$3[ebp]
	mov	DWORD PTR [esi+104], 2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN11@read_main_:

; 4981 :           if (ppm_markers == NULL)

	cmp	DWORD PTR [esi+20], 0
	jne	SHORT $LN12@read_main_

; 4982 :             ppm_markers = new kd_pp_markers;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	test	eax, eax
	je	SHORT $LN26@read_main_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 912  :       { list = NULL; }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4983 :           ppm_markers->add_marker(*marker);

	mov	ecx, eax
	push	DWORD PTR [esi+16]
	mov	DWORD PTR [esi+20], eax
	call	?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z ; kd_pp_markers::add_marker
	jmp	$LN85@read_main_
$LN26@read_main_:

; 4982 :             ppm_markers = new kd_pp_markers;

	xor	eax, eax
	mov	DWORD PTR [esi+20], eax
$LN12@read_main_:

; 4983 :           ppm_markers->add_marker(*marker);

	push	DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+20]
	call	?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z ; kd_pp_markers::add_marker
	jmp	$LN85@read_main_
$LN8@read_main_:

; 4984 :         }
; 4985 :       else if (marker->get_code() == KDU_TLM)

	cmp	dx, di
	jne	SHORT $LN13@read_main_

; 4986 :         {
; 4987 :           if (tpart_ptr_server != NULL)

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN15@read_main_

; 4988 :             tpart_ptr_server->add_tlm_marker(*marker);

	push	ecx
	mov	ecx, eax
	call	?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z ; kd_tpart_pointer_server::add_tlm_marker
$LN15@read_main_:

; 4989 :           have_tlm = true;

	mov	bl, 1
	mov	BYTE PTR _have_tlm$1$[ebp], bl
	jmp	$LN2@read_main_
$LN13@read_main_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4991 :       else if (marker->get_code() == KDU_COM)

	mov	ebx, 65380				; 0000ff64H
	cmp	ax, bx
	jne	$LN16@read_main_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 884  :     int get_length() { return length; }

	mov	ebx, DWORD PTR [ecx+12]

; 885  :       /* Returns length of marker segment (not including the length specifier).
; 886  :          Returns 0 if no actual marker available, or if the marker is a
; 887  :          delimiter (no segment). */
; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	edi, DWORD PTR [ecx+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4995 :           if ((len > 2) && (dat[0] == 0) && (dat[1] == 1))

	cmp	ebx, 2
	jle	SHORT $LN82@read_main_
	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN82@read_main_
	cmp	BYTE PTR [edi+1], 1
	jne	SHORT $LN82@read_main_

; 4996 :             {
; 4997 :               if (comtail == NULL)

	cmp	DWORD PTR [esi+48], 0

; 4998 :                 comhead = comtail = new kd_codestream_comment;

	push	20					; 00000014H
	jne	SHORT $LN19@read_main_
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	test	eax, eax
	je	SHORT $LN28@read_main_
	mov	ecx, eax
	call	??0kd_codestream_comment@@QAE@XZ	; kd_codestream_comment::kd_codestream_comment
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi+44], eax

; 4999 :               else

	jmp	SHORT $LN20@read_main_
$LN28@read_main_:

; 4998 :                 comhead = comtail = new kd_codestream_comment;

	xor	eax, eax
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi+44], eax

; 4999 :               else

	jmp	SHORT $LN20@read_main_
$LN19@read_main_:

; 5000 :                 comtail = comtail->next = new kd_codestream_comment;

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	test	eax, eax
	je	SHORT $LN30@read_main_
	mov	ecx, eax
	call	??0kd_codestream_comment@@QAE@XZ	; kd_codestream_comment::kd_codestream_comment
	mov	ecx, eax
	jmp	SHORT $LN31@read_main_
$LN30@read_main_:
	xor	ecx, ecx
$LN31@read_main_:
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [esi+48], ecx
$LN20@read_main_:

; 5001 :               comtail->set_text(len-2,dat+2);

	mov	ecx, DWORD PTR [esi+48]
	lea	eax, DWORD PTR [edi+2]
	push	eax
	lea	eax, DWORD PTR [ebx-2]
	push	eax
	call	?set_text@kd_codestream_comment@@QAEXHPAE@Z ; kd_codestream_comment::set_text
$LN82@read_main_:
	mov	edi, 65365				; 0000ff55H
$LN85@read_main_:
	mov	bl, BYTE PTR _have_tlm$1$[ebp]
$LN2@read_main_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5008 :     } while (marker->get_code() != KDU_SOT);

	mov	ecx, 65424				; 0000ff90H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	movzx	eax, WORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5008 :     } while (marker->get_code() != KDU_SOT);

	cmp	ax, cx
	jne	$LL83@read_main_
	jmp	SHORT $LN3@read_main_
$LN16@read_main_:

; 5002 :             }
; 5003 :         }
; 5004 :       else
; 5005 :         siz->translate_marker_segment(marker->get_code(),

	push	0
	push	-1
	push	DWORD PTR [ecx+20]
	push	DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [esi+12]
	push	eax
	call	?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z ; kdu_params::translate_marker_segment
	jmp	SHORT $LN85@read_main_
$LN79@read_main_:
	mov	bl, BYTE PTR _have_tlm$1$[ebp]
$LN3@read_main_:

; 5009 : 
; 5010 :   siz->finalize_all(-1,true); // Finalize all main header parameter objects

	mov	ecx, DWORD PTR [esi+12]
	push	1
	push	-1
	call	?finalize_all@kdu_params@@QAEXH_N@Z	; kdu_params::finalize_all

; 5011 : 
; 5012 :   if (tpart_ptr_server != NULL)

	mov	edi, DWORD PTR [esi+36]
	test	edi, edi
	je	$LN23@read_main_

; 5013 :     {
; 5014 :       if (ppm_markers != NULL)

	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN22@read_main_

; 5015 :         {
; 5016 :           delete tpart_ptr_server;
; 5017 :           tpart_ptr_server = NULL;

	mov	ecx, edi
	call	??1kd_tpart_pointer_server@@QAE@XZ	; kd_tpart_pointer_server::~kd_tpart_pointer_server
	push	16					; 00000010H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	mov	DWORD PTR [esi+36], 0

; 5018 :           if (have_tlm)

	test	bl, bl
	je	SHORT $LN23@read_main_

; 5019 :             { KDU_WARNING_DEV(w,15); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$2[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$2[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	OFFSET ??_C@_0MM@CDEHNDAJ@Dynamic?5indexing?5of?5tile?9parts?0?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5019 :             { KDU_WARNING_DEV(w,15); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5024 :             }

	lea	ecx, DWORD PTR _w$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning

; 5025 :         }
; 5026 :       else

	jmp	SHORT $LN23@read_main_
$LN22@read_main_:

; 5027 :         {
; 5028 :           assert(tile_span == tile_indices.size);
; 5029 :           tpart_ptr_server->translate_markers(in->get_bytes_read()-12,

	mov	eax, DWORD PTR [esi+168]
	imul	eax, DWORD PTR [esi+164]
	push	DWORD PTR [esi+264]
	mov	ecx, DWORD PTR [esi+4]
	push	eax
	call	?get_bytes_read@kd_compressed_input@@QAE_JXZ ; kd_compressed_input::get_bytes_read
	sub	eax, 12					; 0000000cH
	mov	ecx, edi
	sbb	edx, 0
	push	edx
	push	eax
	call	?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z ; kd_tpart_pointer_server::translate_markers
$LN23@read_main_:

; 5030 :                                               tile_span.x*tile_span.y,
; 5031 :                                               tile_refs);
; 5032 :         }
; 5033 :     }
; 5034 :   
; 5035 :   finalize_construction();

	mov	ecx, esi
	call	?finalize_construction@kd_codestream@@QAEXXZ ; kd_codestream::finalize_construction
$LN1@read_main_:

; 5036 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_main_header@kd_codestream@@AAEXXZ$0:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_main_header@kd_codestream@@AAEXXZ$1:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_main_header@kd_codestream@@AAEXXZ$2:
	lea	ecx, DWORD PTR _w$3[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?read_main_header@kd_codestream@@AAEXXZ$6:
	lea	ecx, DWORD PTR _w$2[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__ehhandler$?read_main_header@kd_codestream@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_main_header@kd_codestream@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_main_header@kd_codestream@@AAEXXZ ENDP		; kd_codestream::read_main_header
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?unload_tiles_to_cache_threshold@kd_codestream@@QAEXXZ
_TEXT	SEGMENT
?unload_tiles_to_cache_threshold@kd_codestream@@QAEXXZ PROC ; kd_codestream::unload_tiles_to_cache_threshold, COMDAT
; _this$ = ecx

; 5801 : {

	push	esi
	mov	esi, ecx

; 5802 :   while ((num_unloadable_tiles > 0) &&

	cmp	DWORD PTR [esi+404], 0
	jle	$LN36@unload_til
	push	ebx
	push	edi
$LL2@unload_til:
	mov	eax, DWORD PTR [esi+404]
	cmp	eax, DWORD PTR [esi+408]
	jg	SHORT $LN34@unload_til
	mov	edi, DWORD PTR [esi+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 289  :       { return (cache_threshold_bytes <

	push	0
	push	232					; 000000e8H
	push	DWORD PTR [edi+20]
	push	DWORD PTR [edi+16]
	call	__allmul
	add	eax, DWORD PTR [edi+32]
	adc	edx, DWORD PTR [edi+36]
	cmp	DWORD PTR [edi+52], edx
	jg	$LN37@unload_til
	jl	SHORT $LN34@unload_til
	cmp	DWORD PTR [edi+48], eax
	jae	$LN37@unload_til
$LN34@unload_til:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5806 :       while ((unloadable_tile_scan != NULL) &&

	cmp	DWORD PTR [esi+400], 0
	je	$LN35@unload_til
	npad	4
$LL4@unload_til:
	mov	ecx, DWORD PTR [esi+400]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 370  :         if ((pos.x+size.x) <= rhs.pos.x) return false;

	mov	ebx, DWORD PTR [esi+212]
	mov	eax, DWORD PTR [ecx+172]
	mov	edx, DWORD PTR [ecx+164]
	add	eax, edx
	cmp	eax, ebx
	jle	SHORT $LN35@unload_til

; 371  :         if ((pos.y+size.y) <= rhs.pos.y) return false;

	mov	eax, DWORD PTR [ecx+168]
	add	eax, DWORD PTR [ecx+160]
	mov	edi, DWORD PTR [ecx+172]
	cmp	eax, DWORD PTR [esi+208]
	jle	SHORT $LN35@unload_til

; 372  :         if (pos.x >= (rhs.pos.x+rhs.size.x)) return false;

	mov	eax, DWORD PTR [esi+220]
	add	eax, ebx
	cmp	edx, eax
	jge	SHORT $LN35@unload_til

; 373  :         if (pos.y >= (rhs.pos.y+rhs.size.y)) return false;

	mov	eax, DWORD PTR [esi+208]
	mov	edx, DWORD PTR [esi+216]
	add	eax, edx
	cmp	DWORD PTR [ecx+160], eax
	jge	SHORT $LN35@unload_til

; 374  :         if ((size.x <= 0) || (size.y <= 0) ||
; 375  :             (rhs.size.x <= 0) || (rhs.size.y <= 0))

	test	edi, edi
	jle	SHORT $LN35@unload_til
	cmp	DWORD PTR [ecx+168], 0
	jle	SHORT $LN35@unload_til
	cmp	DWORD PTR [esi+220], 0
	jle	SHORT $LN35@unload_til
	test	edx, edx
	jle	SHORT $LN35@unload_til
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5808 :         unloadable_tile_scan = unloadable_tile_scan->unloadable_next;

	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [esi+400], eax
	test	eax, eax
	jne	$LL4@unload_til
$LN35@unload_til:

; 5809 :       if (unloadable_tile_scan != NULL)

	mov	ecx, DWORD PTR [esi+400]
	test	ecx, ecx
	jne	SHORT $LN39@unload_til

; 5810 :         {
; 5811 :           assert(unloadable_tile_scan->is_unloadable);
; 5812 :           unloadable_tile_scan->release(); // Automatically updates pointers
; 5813 :         }
; 5814 :       else
; 5815 :         unloadable_tiles_head->release(); // Automatically updates pointers

	mov	ecx, DWORD PTR [esi+392]
$LN39@unload_til:
	call	?release@kd_tile@@QAEXXZ		; kd_tile::release
	cmp	DWORD PTR [esi+404], 0
	jg	$LL2@unload_til
$LN37@unload_til:
	pop	edi
	pop	ebx
$LN36@unload_til:
	pop	esi

; 5816 :     }
; 5817 : }

	ret	0
?unload_tiles_to_cache_threshold@kd_codestream@@QAEXXZ ENDP ; kd_codestream::unload_tiles_to_cache_threshold
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?gen_layer_info_comment@kd_codestream@@QAEXHPA_JPAG@Z
_TEXT	SEGMENT
_size_factor$1$ = -52					; size = 8
_this$GSCopy$1$ = -44					; size = 4
_thresholds$GSCopy$1$ = -40				; size = 4
_layer_bytes$GSCopy$1$ = -36				; size = 4
$T1 = -32						; size = 4
_com$ = -28						; size = 4
_line$ = -24						; size = 18
__$ArrayPad$ = -4					; size = 4
_num_layers$ = 8					; size = 4
_layer_bytes$ = 12					; size = 4
_thresholds$ = 16					; size = 4
?gen_layer_info_comment@kd_codestream@@QAEXHPA_JPAG@Z PROC ; kd_codestream::gen_layer_info_comment, COMDAT
; _this$ = ecx

; 4919 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _layer_bytes$[ebp]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _layer_bytes$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _thresholds$[ebp]
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi
	mov	DWORD PTR _thresholds$GSCopy$1$[ebp], eax

; 4920 :   if (reserved_layer_info_bytes == 0)

	cmp	DWORD PTR [edi+360], 0
	je	$LN1@gen_layer_

; 4923 :   kd_codestream_comment *elt = new kd_codestream_comment;

	push	ebx
	push	esi
	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	mov	DWORD PTR $T1[ebp], eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN9@gen_layer_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1467 :       { readonly=false; max_chars=num_chars=0; text_buf=NULL; next=NULL; }

	mov	BYTE PTR [esi], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4923 :   kd_codestream_comment *elt = new kd_codestream_comment;

	jmp	SHORT $LN10@gen_layer_
$LN9@gen_layer_:
	xor	esi, esi
	mov	DWORD PTR $T1[ebp], esi
$LN10@gen_layer_:

; 4924 :   if (comhead == NULL)

	cmp	DWORD PTR [edi+44], 0
	jne	SHORT $LN6@gen_layer_

; 4925 :     comhead = comtail = elt;

	mov	DWORD PTR [edi+44], esi

; 4926 :   else

	jmp	SHORT $LN24@gen_layer_
$LN6@gen_layer_:

; 4927 :     comtail = comtail->next = elt;

	mov	eax, DWORD PTR [edi+48]
	mov	DWORD PTR [eax+16], esi
$LN24@gen_layer_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 500  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0EF@DAJKGEFP@Kdu?9Layer?9Info?3?5log_2?$HLDelta?9D?$CIMS@
	lea	ecx, DWORD PTR _com$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4927 :     comtail = comtail->next = elt;

	mov	DWORD PTR [edi+48], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 471  :     kdu_codestream_comment(kd_codestream_comment *state) { this->state=state; }

	mov	DWORD PTR _com$[ebp], esi

; 500  :       { put_text(string); return *this; }

	call	?put_text@kdu_codestream_comment@@QAE_NPBD@Z ; kdu_codestream_comment::put_text
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4931 :   double size_factor = 1.0 / fragment_area_fraction;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000

; 4933 :   for (int n=0; n < num_layers; n++)

	xor	ebx, ebx
	divsd	xmm0, QWORD PTR [edi+232]
	movsd	QWORD PTR _size_factor$1$[ebp], xmm0
	cmp	DWORD PTR _num_layers$[ebp], ebx
	jle	SHORT $LN3@gen_layer_
	mov	edi, DWORD PTR _layer_bytes$GSCopy$1$[ebp]
	mov	esi, DWORD PTR _thresholds$GSCopy$1$[ebp]
$LL4@gen_layer_:

; 4934 :     {
; 4935 :       double log_lambda = thresholds[n];
; 4936 :       log_lambda -= (double)(1<<16);
; 4937 :       log_lambda *= 1.0/256.0;
; 4938 :       sprintf(line,"%6.1f, %8.1e\n",log_lambda,

	mov	edx, DWORD PTR [edi+ebx*8+4]
	mov	ecx, DWORD PTR [edi+ebx*8]
	call	__ltod3
	mulsd	xmm0, QWORD PTR _size_factor$1$[ebp]
	sub	esp, 16					; 00000010H
	movzx	eax, WORD PTR [esi+ebx*2]
	movsd	QWORD PTR [esp+8], xmm0
	movd	xmm0, eax
	lea	eax, DWORD PTR _line$[ebp]
	cvtdq2pd xmm0, xmm0
	subsd	xmm0, QWORD PTR __real@40f0000000000000
	mulsd	xmm0, QWORD PTR __real@3f70000000000000
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0O@GOIICFII@?$CF6?41f?0?5?$CF8?41e?6?$AA@
	push	eax
	call	_sprintf
	add	esp, 24					; 00000018H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 500  :       { put_text(string); return *this; }

	lea	eax, DWORD PTR _line$[ebp]
	lea	ecx, DWORD PTR _com$[ebp]
	push	eax
	call	?put_text@kdu_codestream_comment@@QAE_NPBD@Z ; kdu_codestream_comment::put_text
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4933 :   for (int n=0; n < num_layers; n++)

	inc	ebx
	cmp	ebx, DWORD PTR _num_layers$[ebp]
	jl	SHORT $LL4@gen_layer_
	mov	esi, DWORD PTR $T1[ebp]
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN3@gen_layer_:

; 4939 :               size_factor * ((double) layer_bytes[n]));
; 4940 :       com << line;
; 4941 :     }
; 4942 :   elt->write_marker(NULL,reserved_layer_info_bytes);

	push	DWORD PTR [edi+360]
	mov	ecx, esi
	push	0
	call	?write_marker@kd_codestream_comment@@QAEHPAVkdu_output@@H@Z ; kd_codestream_comment::write_marker
	pop	esi
	pop	ebx
$LN1@gen_layer_:

; 4943 :       // Truncates or pads the comment marker if length is wrong and sets it
; 4944 :       // to read-only mode.
; 4945 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?gen_layer_info_comment@kd_codestream@@QAEXHPA_JPAG@Z ENDP ; kd_codestream::gen_layer_info_comment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_reserved_layer_info_bytes@kd_codestream@@QAEXH@Z
_TEXT	SEGMENT
_com$1 = -4						; size = 4
_num_layers$ = 8					; size = 4
?set_reserved_layer_info_bytes@kd_codestream@@QAEXH@Z PROC ; kd_codestream::set_reserved_layer_info_bytes, COMDAT
; _this$ = ecx

; 4885 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 4886 :   // First remove any existing layer info comment
; 4887 :   kd_codestream_comment *prev, *scan;
; 4888 :   for (prev=NULL, scan=comhead; scan != NULL; prev=scan, scan=scan->next)

	xor	edi, edi
	mov	esi, DWORD PTR [ebx+44]
	test	esi, esi
	je	SHORT $LN9@set_reserv
$LL4@set_reserv:

; 4892 :                   strlen("Kdu-Layer-Info: ")) == 0)

	push	16					; 00000010H
	push	OFFSET ??_C@_0BB@MMIMJKHF@Kdu?9Layer?9Info?3?5?$AA@
	lea	ecx, DWORD PTR _com$1[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 471  :     kdu_codestream_comment(kd_codestream_comment *state) { this->state=state; }

	mov	DWORD PTR _com$1[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4892 :                   strlen("Kdu-Layer-Info: ")) == 0)

	call	?get_text@kdu_codestream_comment@@QAEPBDXZ ; kdu_codestream_comment::get_text
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN24@set_reserv

; 4886 :   // First remove any existing layer info comment
; 4887 :   kd_codestream_comment *prev, *scan;
; 4888 :   for (prev=NULL, scan=comhead; scan != NULL; prev=scan, scan=scan->next)

	mov	edi, esi
	mov	esi, DWORD PTR [esi+16]
	test	esi, esi
	jne	SHORT $LL4@set_reserv

; 4893 :         break;
; 4894 :     }
; 4895 :   if (scan != NULL)

	jmp	SHORT $LN9@set_reserv
$LN24@set_reserv:
	test	esi, esi
	je	SHORT $LN9@set_reserv

; 4896 :     {
; 4897 :       if (prev == NULL)
; 4898 :         comhead = scan->next;

	mov	eax, DWORD PTR [esi+16]
	test	edi, edi
	jne	SHORT $LN7@set_reserv
	mov	DWORD PTR [ebx+44], eax

; 4899 :       else

	jmp	SHORT $LN8@set_reserv
$LN7@set_reserv:

; 4900 :         prev->next = scan->next;

	mov	DWORD PTR [edi+16], eax
$LN8@set_reserv:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1469 :       { if (text_buf != NULL) delete[] text_buf; }

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN20@set_reserv
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@set_reserv:
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4902 :       if (scan == comtail)

	cmp	esi, DWORD PTR [ebx+48]
	jne	SHORT $LN9@set_reserv

; 4903 :         comtail = prev;

	mov	DWORD PTR [ebx+48], edi
$LN9@set_reserv:

; 4904 :     }
; 4905 : 
; 4906 :   // Now set aside a sufficient number of bytes
; 4907 :   reserved_layer_info_bytes = 6 + num_layers*17 + (int) strlen(

	mov	eax, DWORD PTR _num_layers$[ebp]
	shl	eax, 4
	add	eax, 74					; 0000004aH
	add	eax, DWORD PTR _num_layers$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+360], eax
	pop	ebx

; 4908 :     "Kdu-Layer-Info: log_2{Delta-D(MSE)/[2^16*Delta-L(bytes)]}, L(bytes)\n"
; 4909 :     );
; 4910 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?set_reserved_layer_info_bytes@kd_codestream@@QAEXH@Z ENDP ; kd_codestream::set_reserved_layer_info_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?generate_codestream@kd_codestream@@QAE_NH@Z
_TEXT	SEGMENT
_w$2 = -60						; size = 20
_w$3 = -40						; size = 20
_e$4 = -40						; size = 20
_max_tlm_tparts$5 = -20					; size = 4
_done$1$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
_max_layers$ = 8					; size = 4
?generate_codestream@kd_codestream@@QAE_NH@Z PROC	; kd_codestream::generate_codestream, COMDAT
; _this$ = ecx

; 5686 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?generate_codestream@kd_codestream@@QAE_NH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 5687 :   assert(out != NULL);
; 5688 : 
; 5689 :   // Create the `layer_sizes' array if necessary
; 5690 :   assert((layer_sizes != NULL) && (layer_thresholds != NULL));
; 5691 :   if (max_layers > num_sized_layers)

	mov	eax, DWORD PTR _max_layers$[ebp]
	cmp	eax, DWORD PTR [edi+284]
	jle	SHORT $LN11@generate_c

; 5692 :     { KDU_ERROR_DEV(e,38); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0BBE@DMFGKAON@Using?5the?5?$GAkdu_codestream?3?3gener@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5692 :     { KDU_ERROR_DEV(e,38); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5698 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN11@generate_c:

; 5699 : 
; 5700 :   // Write the main header, if necessary
; 5701 :   if (!header_generated)

	cmp	BYTE PTR [edi+343], 0
	jne	$LL7@generate_c

; 5702 :     {
; 5703 :       header_generated = true;
; 5704 :       if (initial_fragment)

	cmp	BYTE PTR [edi+225], 0
	mov	BYTE PTR [edi+343], 1
	je	SHORT $LN3@generate_c

; 5705 :         {
; 5706 :           layer_sizes[0] += out->put(KDU_SOC);

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+288]
	push	65359					; 0000ff4fH
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put
	cdq
	add	DWORD PTR [esi], eax

; 5707 :           layer_sizes[0] += siz->generate_marker_segments(out,-1,0);

	push	0
	adc	DWORD PTR [esi+4], edx
	mov	ecx, DWORD PTR [edi+12]
	mov	esi, DWORD PTR [edi+288]
	push	-1
	push	DWORD PTR [edi+8]
	call	?generate_marker_segments@kdu_params@@QAEHPAVkdu_output@@HH@Z ; kdu_params::generate_marker_segments
	cdq
	add	DWORD PTR [esi], eax
	adc	DWORD PTR [esi+4], edx

; 5708 : 
; 5709 :           // Write out comment marker segments
; 5710 :           if (!comments_frozen)

	cmp	BYTE PTR [edi+342], 0
	jne	SHORT $LN14@generate_c

; 5711 :             freeze_comments();

	mov	ecx, edi
	call	?freeze_comments@kd_codestream@@AAEXXZ	; kd_codestream::freeze_comments
$LN14@generate_c:

; 5712 :           kd_codestream_comment *comscan;
; 5713 :           for (comscan=comhead; comscan != NULL; comscan=comscan->next)

	mov	ebx, DWORD PTR [edi+44]
	test	ebx, ebx
	je	SHORT $LN3@generate_c
	npad	2
$LL4@generate_c:

; 5714 :             layer_sizes[0] += comscan->write_marker(out);

	mov	esi, DWORD PTR [edi+288]
	mov	ecx, ebx
	push	0
	push	DWORD PTR [edi+8]
	call	?write_marker@kd_codestream_comment@@QAEHPAVkdu_output@@H@Z ; kd_codestream_comment::write_marker
	cdq
	add	DWORD PTR [esi], eax
	adc	DWORD PTR [esi+4], edx
	mov	ebx, DWORD PTR [ebx+16]
	test	ebx, ebx
	jne	SHORT $LL4@generate_c
$LN3@generate_c:

; 5715 : 
; 5716 :           // See if we need to write TLM marker segments
; 5717 :         }
; 5718 :       assert(!tlm_generator);
; 5719 :       kdu_params *org = siz->access_cluster(ORG_params); assert(org != NULL);

	mov	ecx, DWORD PTR [edi+12]
	push	OFFSET ??_C@_03MNMMELJE@ORG?$AA@
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 5720 :       int max_tlm_tparts;
; 5721 :       if (org->get(ORGgen_tlm,0,0,max_tlm_tparts) && (max_tlm_tparts > 0))

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _max_tlm_tparts$5[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0L@CIAEHHDE@ORGgen_tlm?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN18@generate_c
	mov	eax, DWORD PTR _max_tlm_tparts$5[ebp]
	test	eax, eax
	jle	$LN18@generate_c

; 5724 :             max_tlm_tparts = 255;
; 5725 :           kdu_compressed_target *tgt = out->access_tgt();

	mov	esi, DWORD PTR [edi+8]
	mov	ecx, 255				; 000000ffH
	cmp	eax, ecx
	cmovg	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 449  :            flush_buf();  return target;

	mov	ecx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5723 :           if (max_tlm_tparts > 255)

	mov	DWORD PTR _max_tlm_tparts$5[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 449  :            flush_buf();  return target;

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
	mov	esi, DWORD PTR [esi+524]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5726 :           if (tgt->start_rewrite(0))

	mov	ecx, esi
	push	0
	push	0
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	SHORT $LN17@generate_c

; 5727 :             {
; 5728 :               tgt->end_rewrite();

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+12]

; 5729 :               if (tlm_generator.init(tile_span.x*tile_span.y,max_tlm_tparts))

	mov	eax, DWORD PTR [edi+168]
	lea	ecx, DWORD PTR [edi+56]
	imul	eax, DWORD PTR [edi+164]
	push	DWORD PTR _max_tlm_tparts$5[ebp]
	push	eax
	call	?init@kd_tlm_generator@@QAE_NHH@Z	; kd_tlm_generator::init
	test	al, al
	je	SHORT $LN19@generate_c

; 5730 :                 {
; 5731 :                   if (initial_fragment)

	cmp	BYTE PTR [edi+225], 0
	je	SHORT $LN18@generate_c

; 5732 :                     tlm_generator.write_dummy_tlms(out);

	push	DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [edi+56]
	call	?write_dummy_tlms@kd_tlm_generator@@QAEXPAVkd_compressed_output@@@Z ; kd_tlm_generator::write_dummy_tlms

; 5733 :                 }
; 5734 :               else

	jmp	SHORT $LN18@generate_c
$LN19@generate_c:

; 5735 :                 { KDU_WARNING(w,16); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$3[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$3[ebp]
	lea	ecx, DWORD PTR _w$3[ebp]
	push	OFFSET ??_C@_0BGA@CEHDEKMG@Unable?5to?5generate?5the?5TLM?5marke@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5735 :                 { KDU_WARNING(w,16); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5744 :                 }

	lea	ecx, DWORD PTR _w$3[ebp]

; 5745 :             }
; 5746 :           else

	jmp	SHORT $LN78@generate_c
$LN17@generate_c:

; 5747 :             { KDU_WARNING(w,17); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$2[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$2[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	OFFSET ??_C@_0BHK@LFLLGIPF@Unable?5to?5generate?5the?5TLM?5marke@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5747 :             { KDU_WARNING(w,17); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5755 :             }

	lea	ecx, DWORD PTR _w$2[ebp]
$LN78@generate_c:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN18@generate_c:

; 5758 :       header_length = out->get_bytes_written();

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [ecx+516]
	sub	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 452  :       { return (flushed_bytes + (next_buf-buffer)); }

	sub	eax, 4
	cdq
	add	eax, DWORD PTR [ecx+528]
	adc	edx, DWORD PTR [ecx+532]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5758 :       header_length = out->get_bytes_written();

	mov	DWORD PTR [edi+352], eax
	mov	DWORD PTR [edi+356], edx
$LL7@generate_c:

; 5759 :       if (!initial_fragment)
; 5760 :         assert(header_length == 0);
; 5761 :     }
; 5762 : 
; 5763 :   // Now cycle through the tiles, interleaving their tile-parts.
; 5764 :   bool done;
; 5765 :   do {
; 5766 :       done = true;
; 5767 :       kd_tile *tnext = NULL;
; 5768 :       for (kd_tile *tile=tiles_in_progress_head; tile != NULL; tile=tnext)

	mov	ecx, DWORD PTR [edi+268]
	mov	BYTE PTR _done$1$[ebp], 1
	test	ecx, ecx
	je	SHORT $LN70@generate_c
	npad	2
$LL10@generate_c:

; 5769 :         {
; 5770 :           tnext = tile->in_progress_next;
; 5771 :           kd_tile_ref *tref = tile->tile_ref;
; 5772 :           kdu_long tpart_bytes =
; 5773 :             tile->generate_tile_part(max_layers,layer_thresholds);

	push	DWORD PTR [edi+296]
	mov	ebx, DWORD PTR [ecx+24]
	push	DWORD PTR _max_layers$[ebp]
	mov	esi, DWORD PTR [ecx+16]
	call	?generate_tile_part@kd_tile@@QAE_JHQAG@Z ; kd_tile::generate_tile_part

; 5774 :           if (((tile = tref->tile) != KD_EXPIRED_TILE) && (tpart_bytes > 0))

	cmp	DWORD PTR [esi+8], -1
	je	SHORT $LN76@generate_c
	test	edx, edx
	jl	SHORT $LN76@generate_c
	jg	SHORT $LN73@generate_c
	test	eax, eax
	je	SHORT $LN76@generate_c
$LN73@generate_c:

; 5775 :             done = false;

	xor	al, al
	mov	BYTE PTR _done$1$[ebp], al
	jmp	SHORT $LN8@generate_c
$LN76@generate_c:
	mov	al, BYTE PTR _done$1$[ebp]
$LN8@generate_c:

; 5759 :       if (!initial_fragment)
; 5760 :         assert(header_length == 0);
; 5761 :     }
; 5762 : 
; 5763 :   // Now cycle through the tiles, interleaving their tile-parts.
; 5764 :   bool done;
; 5765 :   do {
; 5766 :       done = true;
; 5767 :       kd_tile *tnext = NULL;
; 5768 :       for (kd_tile *tile=tiles_in_progress_head; tile != NULL; tile=tnext)

	mov	ecx, ebx
	test	ebx, ebx
	jne	SHORT $LL10@generate_c

; 5776 :         }
; 5777 :     } while (!done);

	test	al, al
	je	SHORT $LL7@generate_c
$LN70@generate_c:

; 5778 : 
; 5779 :   // Finish up with the EOC marker, once all data has been generated
; 5780 :   if (num_incomplete_tiles == 0)

	cmp	DWORD PTR [edi+280], 0
	jne	$LN24@generate_c
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1010 :     bool exists() { return (num_tiles > 0); }

	cmp	DWORD PTR [edi+56], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5782 :       if (tlm_generator.exists())

	jle	SHORT $LN25@generate_c

; 5783 :         {
; 5784 :           kdu_compressed_target *tgt = out->access_tgt();

	mov	esi, DWORD PTR [edi+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 449  :            flush_buf();  return target;

	mov	ecx, esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5785 :           tlm_generator.write_tlms(tgt,prev_tiles_written,

	push	DWORD PTR [edi+252]
	lea	ecx, DWORD PTR [edi+56]
	push	DWORD PTR [edi+248]
	push	DWORD PTR [edi+240]
	push	DWORD PTR [esi+524]
	call	?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z ; kd_tlm_generator::write_tlms
$LN25@generate_c:

; 5786 :                                    prev_tile_bytes_written);
; 5787 :         }
; 5788 :       if (final_fragment)

	cmp	BYTE PTR [edi+226], 0
	je	SHORT $LN26@generate_c

; 5789 :         layer_sizes[0] += out->put(KDU_EOC);

	mov	esi, DWORD PTR [edi+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN48@generate_c

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN48@generate_c:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN51@generate_c

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN51@generate_c:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 217			; 000000d9H
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5789 :         layer_sizes[0] += out->put(KDU_EOC);

	mov	eax, DWORD PTR [edi+288]
	add	DWORD PTR [eax], 2
	adc	DWORD PTR [eax+4], 0
$LN26@generate_c:

; 5790 :       out->flush();

	mov	ecx, DWORD PTR [edi+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 454  :       { flush_buf(); }

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN24@generate_c:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5792 :   return (num_incomplete_tiles == 0);

	xor	eax, eax
	cmp	DWORD PTR [edi+280], eax
	sete	al

; 5793 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?generate_codestream@kd_codestream@@QAE_NH@Z$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?generate_codestream@kd_codestream@@QAE_NH@Z$1:
	lea	ecx, DWORD PTR _w$3[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?generate_codestream@kd_codestream@@QAE_NH@Z$2:
	lea	ecx, DWORD PTR _w$2[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__ehhandler$?generate_codestream@kd_codestream@@QAE_NH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?generate_codestream@kd_codestream@@QAE_NH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?generate_codestream@kd_codestream@@QAE_NH@Z ENDP	; kd_codestream::generate_codestream
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?pcrd_opt@kd_codestream@@QAEX_NN@Z
_TEXT	SEGMENT
_adjusted_last_target$2$ = -76				; size = 8
_remaining_bytes$1 = -76				; size = 8
_header_bytes$ = -68					; size = 8
_min_cost$1$ = -60					; size = 8
_adjusted_next_target$1$ = -60				; size = 8
_last_layer_bytes$ = -60				; size = 8
_last_target$2 = -60					; size = 8
_rough_upper_bound$ = -60				; size = 8
_new_layer_bytes$2$ = -56				; size = 4
_threshold$2$ = -56					; size = 4
tv395 = -56						; size = 4
tv399 = -52						; size = 8
tv274 = -52						; size = 8
_generated_bytes$ = -52					; size = 8
_min_threshold$1$ = -48					; size = 4
_last_layer_bytes$2$ = -44				; size = 4
_rough_upper_bound$2$ = -44				; size = 4
_remaining_bytes$1$ = -40				; size = 4
_target_min$1$ = -40					; size = 4
_rough_upper_bound$1$ = -40				; size = 4
_adjusted_next_target$2$ = -36				; size = 8
_target_min$2$ = -32					; size = 4
_next_target$2$ = -32					; size = 4
_generated_bytes$2$ = -28				; size = 4
_last_idx$1$ = -28					; size = 4
_last_layer_bytes$1$ = -24				; size = 4
_next_idx$1$ = -24					; size = 4
_last_layer$3 = -20					; size = 1
_generated_bytes$1$ = -16				; size = 4
_last_target$1$ = -16					; size = 4
_remaining_bytes$2$ = -12				; size = 4
_target_max$1$ = -12					; size = 4
_layer_idx$2$ = -12					; size = 4
_last_target$2$ = -8					; size = 4
_layer_idx$3$ = -8					; size = 4
_target_max$2$ = -4					; size = 4
tv396 = -4						; size = 4
_trim_to_rate$ = 8					; size = 1
_tolerance$ = 12					; size = 8
?pcrd_opt@kd_codestream@@QAEX_NN@Z PROC			; kd_codestream::pcrd_opt, COMDAT
; _this$ = ecx

; 5495 : {

	push	ebp
	mov	ebp, esp

; 5496 :   if (tolerance > 0.5)

	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	sub	esp, 76					; 0000004cH
	movsd	xmm1, QWORD PTR _tolerance$[ebp]
	comisd	xmm1, xmm0
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx
	jbe	SHORT $LN21@pcrd_opt

; 5497 :     tolerance = 0.5;

	movsd	QWORD PTR _tolerance$[ebp], xmm0
$LN21@pcrd_opt:

; 5498 :   if (min_fixed_header_size == 0)

	mov	eax, DWORD PTR [ebx+304]
	or	eax, DWORD PTR [ebx+308]
	jne	SHORT $LN22@pcrd_opt

; 5499 :     calculate_min_header_cost();

	call	?calculate_min_header_cost@kd_codestream@@QAEXXZ ; kd_codestream::calculate_min_header_cost
$LN22@pcrd_opt:

; 5500 :   kdu_long header_bytes = 0;
; 5501 :   kdu_long rough_upper_bound = 0;
; 5502 :   if (layer_targets[num_sized_layers-1] == 0)

	mov	edx, DWORD PTR [ebx+284]
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR [ebx+292]
	movlpd	QWORD PTR _header_bytes$[ebp], xmm0
	movlpd	QWORD PTR _rough_upper_bound$[ebp], xmm0
	mov	eax, DWORD PTR [ecx+edx*8-8]
	or	eax, DWORD PTR [ecx+edx*8-4]
	jne	SHORT $LN85@pcrd_opt

; 5503 :     { // Find rough upper bound for the purpose of spacing intermediate layers
; 5504 :       rough_upper_bound = simulate_output(header_bytes,0,0,false,false);

	push	eax
	push	1048576					; 00100000H
	push	eax
	push	eax
	push	eax
	push	eax
	push	eax
	lea	eax, DWORD PTR _header_bytes$[ebp]
	mov	ecx, ebx
	push	eax
	call	?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z ; kd_codestream::simulate_output
	mov	DWORD PTR _rough_upper_bound$1$[ebp], edx
	jmp	SHORT $LN98@pcrd_opt
$LN85@pcrd_opt:
	mov	eax, DWORD PTR _rough_upper_bound$[ebp+4]
	mov	DWORD PTR _rough_upper_bound$1$[ebp], eax
	mov	eax, DWORD PTR _rough_upper_bound$[ebp]
$LN98@pcrd_opt:

; 5505 :     }
; 5506 : 
; 5507 :   // Fill in unknown target rates
; 5508 :   int layer_idx;
; 5509 :   for (layer_idx=0; layer_idx < num_sized_layers; layer_idx++)

	mov	esi, DWORD PTR [ebx+284]
	xor	edx, edx
	mov	DWORD PTR _rough_upper_bound$2$[ebp], eax
	test	esi, esi
	jle	SHORT $LN87@pcrd_opt

; 5510 :     if (layer_targets[layer_idx] == 0)

	mov	ecx, DWORD PTR [ebx+292]
$LL4@pcrd_opt:
	mov	eax, DWORD PTR [ecx]
	or	eax, DWORD PTR [ecx+4]
	je	SHORT $LN87@pcrd_opt

; 5505 :     }
; 5506 : 
; 5507 :   // Fill in unknown target rates
; 5508 :   int layer_idx;
; 5509 :   for (layer_idx=0; layer_idx < num_sized_layers; layer_idx++)

	inc	edx
	add	ecx, 8
	cmp	edx, esi
	jl	SHORT $LL4@pcrd_opt
$LN87@pcrd_opt:

; 5511 :       break;
; 5512 :   if (layer_idx < (num_sized_layers-1))

	lea	eax, DWORD PTR [esi-1]
	cmp	edx, eax
	jge	$LN9@pcrd_opt

; 5513 :     { // At least one layer needs to have a target size assigned to it
; 5514 :       kdu_long next_target, last_target = 0;
; 5515 :       for (layer_idx=0; layer_targets[layer_idx] != 0; layer_idx++)

	mov	esi, DWORD PTR [ebx+292]
	xor	ecx, ecx
	xorps	xmm0, xmm0
	mov	DWORD PTR _layer_idx$2$[ebp], ecx
	movlpd	QWORD PTR _last_target$2[ebp], xmm0
	mov	eax, DWORD PTR [esi]
	or	eax, DWORD PTR [esi+4]
	je	SHORT $LN86@pcrd_opt
	xor	edi, edi
	npad	8
$LL7@pcrd_opt:

; 5516 :         { // Add the minimum header cost to each initial non-zero layer
; 5517 :           layer_targets[layer_idx] += min_fixed_header_size +

	push	DWORD PTR [ebx+316]
	inc	ecx
	push	DWORD PTR [ebx+312]
	mov	eax, ecx
	mov	DWORD PTR _layer_idx$2$[ebp], ecx
	cdq
	push	edx
	push	eax
	call	__allmul
	add	eax, DWORD PTR [ebx+304]
	mov	ecx, DWORD PTR _layer_idx$2$[ebp]
	adc	edx, DWORD PTR [ebx+308]
	add	DWORD PTR [esi], eax
	adc	DWORD PTR [esi+4], edx

; 5518 :             (layer_idx+1)*min_layer_header_size;
; 5519 :           last_target = layer_targets[layer_idx];

	mov	eax, DWORD PTR [ebx+292]
	mov	edx, DWORD PTR [edi+eax]
	mov	DWORD PTR _last_target$1$[ebp], edx
	mov	edx, DWORD PTR [edi+eax+4]
	lea	edi, DWORD PTR [ecx*8]
	lea	esi, DWORD PTR [edi+eax]
	mov	DWORD PTR _last_target$2$[ebp], edx
	mov	eax, DWORD PTR [esi]
	or	eax, DWORD PTR [esi+4]
	jne	SHORT $LL7@pcrd_opt
	jmp	SHORT $LN53@pcrd_opt
$LN86@pcrd_opt:

; 5513 :     { // At least one layer needs to have a target size assigned to it
; 5514 :       kdu_long next_target, last_target = 0;
; 5515 :       for (layer_idx=0; layer_targets[layer_idx] != 0; layer_idx++)

	mov	eax, DWORD PTR _last_target$2[ebp+4]
	mov	DWORD PTR _last_target$2$[ebp], eax
	mov	eax, DWORD PTR _last_target$2[ebp]
	mov	DWORD PTR _last_target$1$[ebp], eax
$LN53@pcrd_opt:

; 5520 :         }
; 5521 :       while (layer_idx < (num_sized_layers-1))

	mov	eax, DWORD PTR [ebx+284]
	dec	eax
	cmp	ecx, eax
	jge	$LN9@pcrd_opt
	npad	1
$LL8@pcrd_opt:

; 5522 :         {
; 5523 :           if (layer_targets[layer_idx] != 0)

	mov	edx, DWORD PTR [ebx+292]
	mov	esi, DWORD PTR [edx+ecx*8]
	mov	eax, esi
	mov	edi, DWORD PTR [edx+ecx*8+4]
	or	eax, edi
	je	SHORT $LN26@pcrd_opt

; 5524 :             {
; 5525 :               last_target = layer_targets[layer_idx];
; 5526 :               layer_idx++;

	inc	ecx
	mov	DWORD PTR _last_target$1$[ebp], esi
	mov	DWORD PTR _last_target$2$[ebp], edi
	mov	DWORD PTR _layer_idx$2$[ebp], ecx

; 5527 :               continue;

	jmp	$LN13@pcrd_opt
$LN26@pcrd_opt:

; 5528 :             }
; 5529 :           int last_idx=layer_idx-1; // Could be negative

	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR _last_idx$1$[ebp], eax

; 5530 :           int next_idx=layer_idx+1;

	lea	eax, DWORD PTR [ecx+1]
	mov	esi, eax
	mov	DWORD PTR tv396[ebp], eax
	mov	DWORD PTR _next_idx$1$[ebp], eax

; 5531 :           while ((layer_targets[next_idx] == 0) &&

	mov	eax, DWORD PTR [edx+esi*8]
	or	eax, DWORD PTR [edx+esi*8+4]
	lea	ecx, DWORD PTR [edx+esi*8]
	jne	SHORT $LN11@pcrd_opt
	mov	edi, DWORD PTR [ebx+284]
	dec	edi
$LL10@pcrd_opt:
	cmp	esi, edi
	jge	SHORT $LN88@pcrd_opt
	mov	eax, DWORD PTR [ecx+8]

; 5532 :                  (next_idx < (num_sized_layers-1)))
; 5533 :             next_idx++;

	add	ecx, 8
	inc	esi
	or	eax, DWORD PTR [ecx+4]
	je	SHORT $LL10@pcrd_opt
$LN88@pcrd_opt:
	mov	DWORD PTR _next_idx$1$[ebp], esi
$LN11@pcrd_opt:

; 5534 :           next_target = layer_targets[next_idx];

	mov	edi, DWORD PTR [edx+esi*8]

; 5535 :           if (next_target == 0)

	mov	eax, edi
	mov	ecx, DWORD PTR [edx+esi*8+4]
	or	eax, ecx
	mov	DWORD PTR _next_target$2$[ebp], ecx
	jne	SHORT $LN27@pcrd_opt

; 5536 :             {
; 5537 :               assert(next_idx == (num_sized_layers-1));
; 5538 :               next_target = rough_upper_bound;

	mov	ecx, DWORD PTR _rough_upper_bound$1$[ebp]
	mov	edi, DWORD PTR _rough_upper_bound$2$[ebp]
	mov	DWORD PTR _next_target$2$[ebp], ecx
$LN27@pcrd_opt:

; 5539 :             }
; 5540 :           double adjusted_next_target = (double)
; 5541 :             (next_target - min_fixed_header_size -

	push	DWORD PTR [ebx+316]
	lea	eax, DWORD PTR [esi+1]
	push	DWORD PTR [ebx+312]
	cdq
	push	edx
	push	eax
	call	__allmul
	sub	edi, eax
	mov	eax, DWORD PTR _next_target$2$[ebp]
	sbb	eax, edx
	sub	edi, DWORD PTR [ebx+304]
	mov	ecx, edi
	sbb	eax, DWORD PTR [ebx+308]
	mov	edx, eax
	call	__ltod3

; 5542 :              (next_idx+1)*min_layer_header_size);
; 5543 :           if (adjusted_next_target < 1.0)

	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	comisd	xmm1, xmm0
	movsd	QWORD PTR _adjusted_next_target$1$[ebp], xmm0
	jbe	SHORT $LN28@pcrd_opt

; 5544 :             adjusted_next_target = 1.0;

	movsd	QWORD PTR _adjusted_next_target$1$[ebp], xmm1
$LN28@pcrd_opt:

; 5545 :           double adjusted_last_target;
; 5546 :           if (last_target == 0)

	mov	eax, DWORD PTR _last_target$1$[ebp]
	or	eax, DWORD PTR _last_target$2$[ebp]

; 5547 :             {
; 5548 :               assert(last_idx == -1);
; 5549 :               adjusted_last_target =

	mov	edi, DWORD PTR _last_idx$1$[ebp]
	jne	SHORT $LN29@pcrd_opt
	movsd	xmm2, QWORD PTR __real@3fe0000000000000
	mov	eax, esi
	sub	eax, edi
	movaps	xmm0, xmm2
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	mulsd	xmm1, xmm2
	call	__libm_sse2_pow_precise
	mulsd	xmm0, QWORD PTR _adjusted_next_target$1$[ebp]

; 5550 :                 (adjusted_next_target*pow(0.5,0.5*(next_idx-last_idx)));
; 5551 :             }
; 5552 :           else

	jmp	SHORT $LN30@pcrd_opt
$LN29@pcrd_opt:

; 5553 :             adjusted_last_target = (double)

	push	DWORD PTR [ebx+316]
	lea	eax, DWORD PTR [edi+1]
	push	DWORD PTR [ebx+312]
	cdq
	push	edx
	push	eax
	call	__allmul
	mov	ecx, DWORD PTR _last_target$1$[ebp]
	sub	ecx, eax
	mov	eax, DWORD PTR _last_target$2$[ebp]
	sbb	eax, edx
	sub	ecx, DWORD PTR [ebx+304]
	sbb	eax, DWORD PTR [ebx+308]
	mov	edx, eax
	call	__ltod3
$LN30@pcrd_opt:

; 5554 :               (last_target - min_fixed_header_size -
; 5555 :                (last_idx+1)*min_layer_header_size);
; 5556 :           assert(adjusted_last_target > 0.0);
; 5557 :           adjusted_last_target = log(adjusted_last_target);

	call	__libm_sse2_log_precise
	movsd	QWORD PTR _adjusted_last_target$2$[ebp], xmm0

; 5558 :           adjusted_next_target = log(adjusted_next_target);

	movsd	xmm0, QWORD PTR _adjusted_next_target$1$[ebp]
	call	__libm_sse2_log_precise

; 5559 :           for (; layer_idx < next_idx; layer_idx++)

	mov	ecx, DWORD PTR _layer_idx$2$[ebp]
	movaps	xmm2, xmm0
	movsd	QWORD PTR _adjusted_next_target$2$[ebp], xmm2
	cmp	ecx, esi
	jge	$LN13@pcrd_opt
	mov	eax, esi
	or	edx, -1
	sub	eax, edi
	sub	edx, edi
	mov	DWORD PTR tv395[ebp], edx
	movd	xmm0, eax
	mov	eax, DWORD PTR tv396[ebp]
	cvtdq2pd xmm0, xmm0
	movsd	QWORD PTR tv399[ebp], xmm0
$LL14@pcrd_opt:

; 5560 :             {
; 5561 :               double w1 = ((double)(layer_idx-last_idx)) /

	add	eax, edx
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	divsd	xmm1, xmm0

; 5562 :                 ((double)(next_idx-last_idx));
; 5563 :               double val = (1.0-w1)*adjusted_last_target +

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, xmm1
	mulsd	xmm1, xmm2
	mulsd	xmm0, QWORD PTR _adjusted_last_target$2$[ebp]
	addsd	xmm0, xmm1

; 5564 :                 w1*adjusted_next_target;
; 5565 :               val = exp(val);

	call	__libm_sse2_exp_precise

; 5566 :               layer_targets[layer_idx] = ((kdu_long) val) +

	call	__dtol3
	push	DWORD PTR [ebx+316]
	mov	esi, eax
	mov	edi, edx
	push	DWORD PTR [ebx+312]
	mov	eax, DWORD PTR tv396[ebp]
	cdq
	push	edx
	push	eax
	call	__allmul
	mov	ecx, DWORD PTR _layer_idx$2$[ebp]
	add	esi, eax
	mov	eax, DWORD PTR [ebx+292]
	movsd	xmm0, QWORD PTR tv399[ebp]
	adc	edi, edx
	add	esi, DWORD PTR [ebx+304]
	movsd	xmm2, QWORD PTR _adjusted_next_target$2$[ebp]
	adc	edi, DWORD PTR [ebx+308]
	mov	edx, DWORD PTR tv395[ebp]
	mov	DWORD PTR [eax+ecx*8], esi
	mov	DWORD PTR [eax+ecx*8+4], edi
	inc	ecx
	mov	eax, DWORD PTR tv396[ebp]
	inc	eax
	mov	DWORD PTR _layer_idx$2$[ebp], ecx
	mov	DWORD PTR tv396[ebp], eax
	cmp	ecx, DWORD PTR _next_idx$1$[ebp]
	jl	$LL14@pcrd_opt
$LN13@pcrd_opt:

; 5520 :         }
; 5521 :       while (layer_idx < (num_sized_layers-1))

	mov	eax, DWORD PTR [ebx+284]
	dec	eax
	cmp	ecx, eax
	jl	$LL8@pcrd_opt
$LN9@pcrd_opt:

; 5567 :                 min_fixed_header_size + (layer_idx+1)*min_layer_header_size;
; 5568 :             }
; 5569 :         }
; 5570 :     }
; 5571 : 
; 5572 :   // Now we are ready to run the rate control loop
; 5573 :   kdu_long last_layer_bytes=0, generated_bytes=0, new_layer_bytes;
; 5574 :   int threshold;
; 5575 :   int min_threshold = 0;
; 5576 :   int lim_threshold = (1<<16);
; 5577 :   for (layer_idx=0; layer_idx < num_sized_layers; layer_idx++)

	xor	edx, edx
	xorps	xmm0, xmm0
	mov	edi, 65536				; 00010000H
	movlpd	QWORD PTR _last_layer_bytes$[ebp], xmm0
	movlpd	QWORD PTR _generated_bytes$[ebp], xmm0
	mov	DWORD PTR _layer_idx$3$[ebp], edx
	cmp	DWORD PTR [ebx+284], edx
	jle	$LN16@pcrd_opt
	mov	eax, DWORD PTR _last_layer_bytes$[ebp+4]
	mov	ecx, DWORD PTR _generated_bytes$[ebp+4]
	mov	esi, DWORD PTR _generated_bytes$[ebp]
	mov	DWORD PTR _last_layer_bytes$2$[ebp], eax
	mov	eax, DWORD PTR _last_layer_bytes$[ebp]
	mov	DWORD PTR _last_layer_bytes$1$[ebp], eax
$LL17@pcrd_opt:

; 5578 :     {
; 5579 :       bool last_layer = (layer_idx == (num_sized_layers-1));

	mov	eax, DWORD PTR [ebx+284]
	dec	eax
	cmp	edx, eax

; 5580 : 
; 5581 :       // Establish target bounds on the size of this layer
; 5582 :       generated_bytes += layer_sizes[layer_idx];

	mov	eax, DWORD PTR [ebx+288]
	sete	BYTE PTR _last_layer$3[ebp]
	add	esi, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _generated_bytes$1$[ebp], esi
	adc	ecx, DWORD PTR [eax+edx*8+4]

; 5583 :       kdu_long target_max = layer_targets[layer_idx];

	mov	eax, DWORD PTR [ebx+292]
	mov	DWORD PTR _generated_bytes$2$[ebp], ecx
	mov	ecx, DWORD PTR [eax+edx*8+4]
	mov	esi, DWORD PTR [eax+edx*8]

; 5584 :       kdu_long target_min = target_max;
; 5585 :       if (target_max == 0)

	mov	eax, esi
	or	eax, ecx
	mov	DWORD PTR _target_max$2$[ebp], ecx
	jne	SHORT $LN31@pcrd_opt

; 5586 :         {
; 5587 :           assert(last_layer);
; 5588 :           target_min = target_max = KDU_LONG_HUGE;

	mov	DWORD PTR _target_max$1$[ebp], eax
	mov	DWORD PTR _target_max$2$[ebp], 1048576	; 00100000H
	mov	DWORD PTR _target_min$1$[ebp], eax
	mov	DWORD PTR _target_min$2$[ebp], 1048576	; 00100000H

; 5589 :           if ((!reslength_constraints_used) || reslength_warning_issued)

	cmp	BYTE PTR [ebx+320], al
	je	SHORT $LN34@pcrd_opt
	cmp	BYTE PTR [ebx+322], al
	je	$LN39@pcrd_opt
$LN34@pcrd_opt:

; 5590 :             lim_threshold = 1;

	mov	edi, 1

; 5591 :         }
; 5592 :       else

	jmp	$LN40@pcrd_opt
$LN31@pcrd_opt:

; 5593 :         {
; 5594 :           // Adjust to compensate for simulation not including the EOC cost
; 5595 :           if (final_fragment)

	cmp	BYTE PTR [ebx+226], 0
	je	SHORT $LN35@pcrd_opt

; 5596 :             target_max -= 2;

	add	esi, -2					; fffffffeH
	adc	ecx, -1
	mov	DWORD PTR _target_max$2$[ebp], ecx
$LN35@pcrd_opt:

; 5597 : 
; 5598 :           // Find normalized minimum header cost
; 5599 :           double min_cost = (double) min_layer_header_size;

	mov	edx, DWORD PTR [ebx+316]
	mov	ecx, DWORD PTR [ebx+312]
	call	__ltod3

; 5600 :           if (layer_idx == 0)

	mov	ecx, DWORD PTR _layer_idx$3$[ebp]
	movaps	xmm1, xmm0
	movsd	QWORD PTR _min_cost$1$[ebp], xmm1
	test	ecx, ecx
	jne	SHORT $LN36@pcrd_opt

; 5601 :             min_cost += (double) min_fixed_header_size;

	mov	edx, DWORD PTR [ebx+308]
	mov	ecx, DWORD PTR [ebx+304]
	call	__ltod3
	movsd	xmm1, QWORD PTR _min_cost$1$[ebp]
	addsd	xmm1, xmm0
	movsd	QWORD PTR _min_cost$1$[ebp], xmm1
$LN36@pcrd_opt:

; 5602 :           if ((generated_bytes > 0) && (generated_bytes < target_max) &&

	mov	eax, DWORD PTR _generated_bytes$2$[ebp]
	test	eax, eax
	jl	SHORT $LN92@pcrd_opt
	mov	ecx, DWORD PTR _generated_bytes$1$[ebp]
	jg	SHORT $LN79@pcrd_opt
	test	ecx, ecx
	je	SHORT $LN92@pcrd_opt
$LN79@pcrd_opt:
	cmp	eax, DWORD PTR _target_max$2$[ebp]
	jg	SHORT $LN92@pcrd_opt
	jl	SHORT $LN80@pcrd_opt
	cmp	ecx, esi
	jae	SHORT $LN92@pcrd_opt
$LN80@pcrd_opt:
	movsd	xmm2, QWORD PTR _tolerance$[ebp]
	xorps	xmm0, xmm0
	comisd	xmm2, xmm0
	jbe	SHORT $LN37@pcrd_opt

; 5603 :               (tolerance > 0.0))
; 5604 :             min_cost -= (kdu_long)(min_cost *

	mov	edx, eax
	call	__ltod3
	mov	edx, DWORD PTR _target_max$2$[ebp]
	mov	ecx, esi
	movsd	QWORD PTR tv274[ebp], xmm0
	call	__ltod3
	movsd	xmm1, QWORD PTR tv274[ebp]
	divsd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR _min_cost$1$[ebp]
	movaps	xmm0, xmm1
	call	__dtol3
	mov	ecx, eax
	call	__ltod3
	movsd	xmm1, QWORD PTR _min_cost$1$[ebp]
	mov	eax, DWORD PTR _generated_bytes$2$[ebp]
	subsd	xmm1, xmm0
	movsd	QWORD PTR _min_cost$1$[ebp], xmm1
$LN92@pcrd_opt:
	movsd	xmm2, QWORD PTR _tolerance$[ebp]
	xorps	xmm0, xmm0
$LN37@pcrd_opt:

; 5605 :                                    (((double) generated_bytes)/target_max));
; 5606 : 
; 5607 :           // Adjust maximum size to find limit on remaining bytes
; 5608 :           target_max -= generated_bytes;
; 5609 : 
; 5610 :           // Adjust maximum size to reflect bytes for this layer alone
; 5611 :           target_max -= last_layer_bytes;

	mov	ecx, DWORD PTR _generated_bytes$1$[ebp]
	add	ecx, DWORD PTR _last_layer_bytes$1$[ebp]
	adc	eax, DWORD PTR _last_layer_bytes$2$[ebp]
	sub	esi, ecx
	mov	ecx, DWORD PTR _target_max$2$[ebp]
	sbb	ecx, eax
	mov	DWORD PTR _target_max$1$[ebp], esi

; 5612 : 
; 5613 :           // Find preferred minimum size bound using tolerances
; 5614 :           target_min = target_max;
; 5615 :           if (tolerance > 0.0)

	comisd	xmm2, xmm0
	mov	DWORD PTR _target_max$2$[ebp], ecx
	mov	DWORD PTR _target_min$1$[ebp], esi
	mov	DWORD PTR _target_min$2$[ebp], ecx
	jbe	SHORT $LN95@pcrd_opt

; 5616 :             {
; 5617 :               if (target_max > (kdu_long) min_cost)

	movaps	xmm0, xmm1
	call	__dtol3
	mov	ecx, DWORD PTR _target_max$2$[ebp]
	cmp	ecx, edx
	jl	SHORT $LN95@pcrd_opt
	jg	SHORT $LN81@pcrd_opt
	cmp	esi, eax
	jbe	SHORT $LN95@pcrd_opt
$LN81@pcrd_opt:

; 5618 :                 target_min -= (kdu_long)((target_max-min_cost) * tolerance);

	mov	edx, ecx
	mov	ecx, esi
	call	__ltod3
	subsd	xmm0, QWORD PTR _min_cost$1$[ebp]
	mulsd	xmm0, QWORD PTR _tolerance$[ebp]
	call	__dtol3
	mov	ecx, esi
	sub	ecx, eax
	mov	DWORD PTR _target_min$1$[ebp], ecx
	mov	ecx, DWORD PTR _target_max$2$[ebp]
	sbb	ecx, edx
	mov	DWORD PTR _target_min$2$[ebp], ecx
$LN95@pcrd_opt:
	mov	edx, DWORD PTR _layer_idx$3$[ebp]
	mov	eax, DWORD PTR _target_max$1$[ebp]
$LN39@pcrd_opt:

; 5619 :             }
; 5620 :         }
; 5621 : 
; 5622 :       if (lim_threshold < 1)

	cmp	edi, 1
	mov	ecx, 1
	cmovl	edi, ecx
$LN40@pcrd_opt:

; 5623 :         lim_threshold = 1;
; 5624 :       int best_threshold = lim_threshold-1;

	lea	ecx, DWORD PTR [edi-1]

; 5625 :       min_threshold = 0;

	xor	esi, esi
	mov	DWORD PTR _threshold$2$[ebp], ecx
	mov	ecx, DWORD PTR _target_max$2$[ebp]
	mov	DWORD PTR _min_threshold$1$[ebp], esi
$LL20@pcrd_opt:

; 5626 : 
; 5627 :       // Use a simple bisection search for the slope threshold
; 5628 :       do {
; 5629 :           threshold = (min_threshold+lim_threshold)>>1;
; 5630 :           assert(threshold < (1<<16));
; 5631 :           reslength_constraints_violated = false;
; 5632 :           new_layer_bytes =

	push	0
	push	ecx
	push	eax
	push	DWORD PTR _last_layer$3[ebp]
	add	esi, edi
	mov	BYTE PTR [ebx+321], 0
	push	0
	sar	esi, 1
	lea	eax, DWORD PTR _header_bytes$[ebp]
	push	esi
	push	edx
	push	eax
	mov	ecx, ebx
	call	?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z ; kd_codestream::simulate_output

; 5633 :             simulate_output(header_bytes,layer_idx,(kdu_uint16) threshold,
; 5634 :                             false,last_layer,target_max);
; 5635 :           if ((new_layer_bytes > target_max) || reslength_constraints_violated)

	mov	ecx, DWORD PTR _target_max$2$[ebp]
	cmp	edx, ecx
	jg	SHORT $LN43@pcrd_opt
	jl	SHORT $LN82@pcrd_opt
	cmp	eax, DWORD PTR _target_max$1$[ebp]
	ja	SHORT $LN43@pcrd_opt
$LN82@pcrd_opt:
	cmp	BYTE PTR [ebx+321], 0
	jne	SHORT $LN43@pcrd_opt

; 5638 :             }
; 5639 :           else if (new_layer_bytes >= target_min)

	cmp	edx, DWORD PTR _target_min$2$[ebp]
	jg	SHORT $LN19@pcrd_opt
	jl	SHORT $LN83@pcrd_opt
	cmp	eax, DWORD PTR _target_min$1$[ebp]
	jae	SHORT $LN19@pcrd_opt
$LN83@pcrd_opt:

; 5640 :             {
; 5641 :               best_threshold = threshold;
; 5642 :               break; // Found a suitable slope threshold satisfying bounds
; 5643 :             }
; 5644 :           else
; 5645 :             {
; 5646 :               best_threshold = threshold; // Best so far

	mov	ecx, esi

; 5647 :               lim_threshold = threshold;

	mov	edi, esi
	mov	esi, DWORD PTR _min_threshold$1$[ebp]
	mov	DWORD PTR _threshold$2$[ebp], ecx
	mov	ecx, DWORD PTR _target_max$2$[ebp]
	jmp	SHORT $LN18@pcrd_opt
$LN43@pcrd_opt:

; 5636 :             { // Must not exceed the threshold
; 5637 :               min_threshold = threshold+1;

	inc	esi
	mov	DWORD PTR _min_threshold$1$[ebp], esi
$LN18@pcrd_opt:

; 5648 :             }
; 5649 :         } while (lim_threshold > min_threshold);

	cmp	edi, esi
	jle	SHORT $LN96@pcrd_opt
	mov	eax, DWORD PTR _target_max$1$[ebp]
	mov	edx, DWORD PTR _layer_idx$3$[ebp]
	jmp	SHORT $LL20@pcrd_opt
$LN96@pcrd_opt:
	mov	esi, DWORD PTR _threshold$2$[ebp]
$LN19@pcrd_opt:

; 5650 : 
; 5651 :       // Finalize the allocation for this layer
; 5652 :       threshold = best_threshold;
; 5653 :       new_layer_bytes =  // Don't finalize yet

	mov	edi, DWORD PTR _layer_idx$3$[ebp]
	lea	eax, DWORD PTR _header_bytes$[ebp]
	push	0
	push	1048576					; 00100000H
	push	0
	push	DWORD PTR _last_layer$3[ebp]
	mov	ecx, ebx
	push	0
	push	esi
	push	edi
	push	eax
	call	?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z ; kd_codestream::simulate_output

; 5654 :         simulate_output(header_bytes,layer_idx,(kdu_uint16) threshold,
; 5655 :                         false,last_layer);
; 5656 :       kdu_long remaining_bytes = target_max - new_layer_bytes;

	mov	ecx, DWORD PTR _target_max$1$[ebp]
	mov	DWORD PTR _remaining_bytes$2$[ebp], ecx
	sub	DWORD PTR _remaining_bytes$2$[ebp], eax
	mov	eax, DWORD PTR _target_max$2$[ebp]
	mov	DWORD PTR _remaining_bytes$1$[ebp], eax
	sbb	DWORD PTR _remaining_bytes$1$[ebp], edx

; 5657 :       if (last_layer && (remaining_bytes>0) && (threshold>0) && trim_to_rate)

	cmp	BYTE PTR _last_layer$3[ebp], 0
	mov	edx, DWORD PTR _remaining_bytes$2$[ebp]
	mov	DWORD PTR _remaining_bytes$1[ebp], edx
	mov	edx, DWORD PTR _remaining_bytes$1$[ebp]
	mov	DWORD PTR _remaining_bytes$1[ebp+4], edx
	je	SHORT $LN46@pcrd_opt
	test	edx, edx
	jl	SHORT $LN46@pcrd_opt
	jg	SHORT $LN84@pcrd_opt
	cmp	DWORD PTR _remaining_bytes$2$[ebp], 0
	jbe	SHORT $LN46@pcrd_opt
$LN84@pcrd_opt:
	test	esi, esi
	jle	SHORT $LN46@pcrd_opt
	cmp	BYTE PTR _trim_to_rate$[ebp], 0
	je	SHORT $LN46@pcrd_opt

; 5658 :         {
; 5659 :           threshold--;
; 5660 :           new_layer_bytes = // Finalize with sloppy fill in.

	lea	edx, DWORD PTR _remaining_bytes$1[ebp]
	dec	esi
	push	edx
	push	eax
	push	ecx
	push	1

; 5661 :             simulate_output(header_bytes,layer_idx,(kdu_uint16) threshold,
; 5662 :                             true,true,target_max,&remaining_bytes);
; 5663 :         }
; 5664 :       else

	jmp	SHORT $LN99@pcrd_opt
$LN46@pcrd_opt:

; 5665 :         new_layer_bytes = // Finalize without sloppy fill in.

	push	0
	push	1048576					; 00100000H
	push	0
	push	DWORD PTR _last_layer$3[ebp]
$LN99@pcrd_opt:
	push	1
	push	esi
	push	edi
	lea	eax, DWORD PTR _header_bytes$[ebp]
	mov	ecx, ebx
	push	eax
	call	?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z ; kd_codestream::simulate_output
	mov	ecx, eax
	mov	DWORD PTR _new_layer_bytes$2$[ebp], edx

; 5666 :           simulate_output(header_bytes,layer_idx,(kdu_uint16) threshold,
; 5667 :                           true,last_layer);
; 5668 :       layer_thresholds[layer_idx] = (kdu_uint16) threshold;

	mov	edx, DWORD PTR _layer_idx$3$[ebp]

; 5669 :       lim_threshold = threshold+1; // We are allowed to repeat the threshold.

	lea	edi, DWORD PTR [esi+1]
	mov	eax, DWORD PTR [ebx+296]

; 5670 :       last_layer_bytes += new_layer_bytes;

	add	DWORD PTR _last_layer_bytes$1$[ebp], ecx
	mov	ecx, DWORD PTR _last_layer_bytes$2$[ebp]
	adc	ecx, DWORD PTR _new_layer_bytes$2$[ebp]
	mov	WORD PTR [eax+edx*2], si

; 5671 :       if (layer_targets[layer_idx] == 0)

	mov	esi, DWORD PTR [ebx+292]
	mov	DWORD PTR _last_layer_bytes$2$[ebp], ecx
	mov	eax, DWORD PTR [esi+edx*8]
	or	eax, DWORD PTR [esi+edx*8+4]
	jne	SHORT $LN15@pcrd_opt

; 5672 :         {
; 5673 :           assert(last_layer);
; 5674 :           layer_targets[layer_idx] = generated_bytes + last_layer_bytes

	cmp	BYTE PTR [ebx+226], al
	mov	edx, 2
	cmovne	eax, edx
	cdq
	add	eax, DWORD PTR _generated_bytes$1$[ebp]
	adc	edx, DWORD PTR _generated_bytes$2$[ebp]
	add	eax, DWORD PTR _last_layer_bytes$1$[ebp]
	adc	edx, ecx
	mov	ecx, DWORD PTR _layer_idx$3$[ebp]
	mov	DWORD PTR [esi+ecx*8], eax
	mov	DWORD PTR [esi+ecx*8+4], edx
	mov	edx, ecx
$LN15@pcrd_opt:

; 5567 :                 min_fixed_header_size + (layer_idx+1)*min_layer_header_size;
; 5568 :             }
; 5569 :         }
; 5570 :     }
; 5571 : 
; 5572 :   // Now we are ready to run the rate control loop
; 5573 :   kdu_long last_layer_bytes=0, generated_bytes=0, new_layer_bytes;
; 5574 :   int threshold;
; 5575 :   int min_threshold = 0;
; 5576 :   int lim_threshold = (1<<16);
; 5577 :   for (layer_idx=0; layer_idx < num_sized_layers; layer_idx++)

	mov	ecx, DWORD PTR _generated_bytes$2$[ebp]
	inc	edx
	mov	esi, DWORD PTR _generated_bytes$1$[ebp]
	mov	DWORD PTR _layer_idx$3$[ebp], edx
	cmp	edx, DWORD PTR [ebx+284]
	jl	$LL17@pcrd_opt
$LN16@pcrd_opt:
	pop	edi
	pop	esi
	pop	ebx

; 5675 :             + ((final_fragment)?2:0); // Put EOC back.
; 5676 :         }
; 5677 :     }
; 5678 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?pcrd_opt@kd_codestream@@QAEX_NN@Z ENDP			; kd_codestream::pcrd_opt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z
_TEXT	SEGMENT
_e$2 = -132						; size = 20
_packet_header_bytes$3 = -112				; size = 8
_tile_header_bytes$4 = -112				; size = 8
_A$1$ = -104						; size = 8
_local_sloppy$5 = -104					; size = 8
_initial_local_sloppy$2$ = -100				; size = 4
_initial_local_sloppy$1$ = -96				; size = 4
_tile_header_bytes$2$ = -92				; size = 4
tv863 = -92						; size = 4
_d$1$ = -88						; size = 4
_tile$1$ = -88						; size = 4
_c$1$ = -84						; size = 4
_local_header_bytes$6 = -80				; size = 8
_local_header_bytes$1$ = -76				; size = 4
_T$1$ = -76						; size = 4
_local_header_bytes$2$ = -72				; size = 4
tv754 = -72						; size = 4
_precinct$1$ = -68					; size = 4
_local_max_bytes$1$ = -64				; size = 4
_local_total_bytes$7 = -60				; size = 8
_packet_bytes$2$ = -56					; size = 4
_local_max_bytes$2$ = -52				; size = 4
_packet_bytes$1$ = -48					; size = 4
_local_total_bytes$2$ = -44				; size = 4
_local_total_bytes$1$ = -40				; size = 4
_local_sloppy$1$ = -36					; size = 4
_total_bytes$2$ = -32					; size = 4
_local_sloppy$2$ = -28					; size = 4
_rc$1$ = -24						; size = 4
_total_bytes$1$ = -20					; size = 4
_all_ready$1$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_header_bytes$ = 8					; size = 4
_layer_idx$ = 12					; size = 4
_slope_threshold$ = 16					; size = 2
_finalize_layer$ = 20					; size = 1
_last_layer$ = 24					; size = 1
_max_bytes$ = 28					; size = 8
_sloppy_bytes$ = 36					; size = 4
?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z PROC ; kd_codestream::simulate_output, COMDAT
; _this$ = ecx

; 5240 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 5241 :   header_bytes = 0;

	mov	eax, DWORD PTR _header_bytes$[ebp]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 5242 :   if (reslength_constraints_used && !reslength_warning_issued)

	cmp	BYTE PTR [ebx+320], 0
	je	$LN6@simulate_o
	cmp	BYTE PTR [ebx+322], 0
	jne	SHORT $LN6@simulate_o

; 5243 :     {
; 5244 :       int c;
; 5245 :       if (reslength_checkers != NULL)

	cmp	DWORD PTR [ebx+324], 0
	je	SHORT $LN3@simulate_o

; 5246 :         for (c=0; c <= num_components; c++)

	xor	esi, esi
	cmp	DWORD PTR [ebx+112], esi
	jl	SHORT $LN3@simulate_o
	xor	edi, edi
$LL4@simulate_o:

; 5247 :           reslength_checkers[c].set_layer(layer_idx);

	mov	ecx, DWORD PTR [ebx+324]
	push	DWORD PTR _layer_idx$[ebp]
	add	ecx, edi
	call	?set_layer@kd_reslength_checker@@QAEXH@Z ; kd_reslength_checker::set_layer
	inc	esi
	add	edi, 808				; 00000328H
	cmp	esi, DWORD PTR [ebx+112]
	jle	SHORT $LL4@simulate_o
$LN3@simulate_o:

; 5248 :       for (kd_tile *tile=tiles_in_progress_head;

	mov	eax, DWORD PTR [ebx+268]
	mov	DWORD PTR _tile$1$[ebp], eax

; 5249 :            tile != NULL; tile=tile->in_progress_next)

	test	eax, eax
	je	SHORT $LN6@simulate_o
	npad	5
$LL7@simulate_o:

; 5250 :         if (tile->reslength_checkers != NULL)

	cmp	DWORD PTR [eax+120], 0
	je	SHORT $LN5@simulate_o

; 5251 :           for (c=0; c <= num_components; c++)

	xor	edi, edi
	cmp	DWORD PTR [ebx+112], edi
	jl	SHORT $LN5@simulate_o
	xor	esi, esi
	npad	1
$LL10@simulate_o:

; 5252 :             tile->reslength_checkers[c].set_layer(layer_idx);

	mov	ecx, DWORD PTR [eax+120]
	push	DWORD PTR _layer_idx$[ebp]
	add	ecx, esi
	call	?set_layer@kd_reslength_checker@@QAEXH@Z ; kd_reslength_checker::set_layer
	mov	eax, DWORD PTR _tile$1$[ebp]
	inc	edi
	add	esi, 808				; 00000328H
	cmp	edi, DWORD PTR [ebx+112]
	jle	SHORT $LL10@simulate_o
$LN5@simulate_o:

; 5249 :            tile != NULL; tile=tile->in_progress_next)

	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _tile$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LL7@simulate_o
$LN6@simulate_o:

; 5253 :     }
; 5254 :   
; 5255 :   if ((layer_idx == 0) && initial_fragment && !header_generated)

	mov	eax, DWORD PTR _layer_idx$[ebp]
	test	eax, eax
	jne	SHORT $LN128@simulate_o
	cmp	BYTE PTR [ebx+225], al
	je	SHORT $LN128@simulate_o
	cmp	BYTE PTR [ebx+343], al
	jne	SHORT $LN128@simulate_o

; 5256 :     {
; 5257 :       header_bytes = 2 + siz->generate_marker_segments(NULL,-1,0);

	mov	ecx, DWORD PTR [ebx+12]
	push	eax
	push	-1
	push	eax
	call	?generate_marker_segments@kdu_params@@QAEHPAVkdu_output@@HH@Z ; kdu_params::generate_marker_segments
	mov	edi, DWORD PTR _header_bytes$[ebp]
	add	eax, 2
	cdq
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], edx

; 5258 :       if (!comments_frozen)

	cmp	BYTE PTR [ebx+342], 0
	jne	SHORT $LN33@simulate_o

; 5259 :         freeze_comments();

	mov	ecx, ebx
	call	?freeze_comments@kd_codestream@@AAEXXZ	; kd_codestream::freeze_comments
$LN33@simulate_o:

; 5260 :       kd_codestream_comment *comscan;
; 5261 :       for (comscan=comhead; comscan != NULL; comscan=comscan->next)

	mov	esi, DWORD PTR [ebx+44]
	test	esi, esi
	je	SHORT $LN12@simulate_o
	npad	4
$LL13@simulate_o:

; 5262 :         header_bytes += comscan->write_marker(NULL);

	push	0
	push	0
	mov	ecx, esi
	call	?write_marker@kd_codestream_comment@@QAEHPAVkdu_output@@H@Z ; kd_codestream_comment::write_marker
	cdq
	add	DWORD PTR [edi], eax
	adc	DWORD PTR [edi+4], edx
	mov	esi, DWORD PTR [esi+16]
	test	esi, esi
	jne	SHORT $LL13@simulate_o
$LN12@simulate_o:

; 5263 :       header_bytes += reserved_layer_info_bytes;

	mov	eax, DWORD PTR [ebx+360]
	cdq
	add	DWORD PTR [edi], eax
	mov	eax, DWORD PTR _layer_idx$[ebp]
	adc	DWORD PTR [edi+4], edx
	jmp	SHORT $LN32@simulate_o
$LN128@simulate_o:
	mov	edi, DWORD PTR _header_bytes$[ebp]
$LN32@simulate_o:

; 5264 :     }
; 5265 : 
; 5266 :   kdu_long total_bytes = header_bytes;

	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR _total_bytes$1$[ebp], edx
	mov	DWORD PTR _total_bytes$2$[ebp], ecx

; 5267 : 
; 5268 :   // Calculate the cost of including tile-part headers.  This calculation
; 5269 :   // may be off by a bit if the `ORGtparts' attribute has been used to request
; 5270 :   // extra tile-parts, or if `ORGgen_plt' has been used to request the
; 5271 :   // generation of PLT marker segments.  Also calculate the cost of adding in
; 5272 :   // empty packets for tiles which have too many layers.
; 5273 :   if ((layer_idx == 0) || last_layer)

	test	eax, eax
	je	SHORT $LN35@simulate_o
	cmp	BYTE PTR _last_layer$[ebp], 0
	je	$LN15@simulate_o
$LN35@simulate_o:

; 5274 :     {
; 5275 :       for (kd_tile *tile=tiles_in_progress_head;

	mov	esi, DWORD PTR [ebx+268]

; 5276 :            tile != NULL; tile=tile->in_progress_next)

	test	esi, esi
	je	$LN15@simulate_o
$LL16@simulate_o:
	xorps	xmm0, xmm0

; 5277 :         {
; 5278 :           kdu_long tile_header_bytes = 0;

	movlpd	QWORD PTR _tile_header_bytes$4[ebp], xmm0

; 5279 :           if (layer_idx == 0)

	test	eax, eax
	jne	SHORT $LN120@simulate_o

; 5280 :             tile_header_bytes += 12 + 2 +

	push	DWORD PTR [esi+244]
	mov	ecx, DWORD PTR [ebx+12]
	push	DWORD PTR [esi+4]
	push	eax
	call	?generate_marker_segments@kdu_params@@QAEHPAVkdu_output@@HH@Z ; kdu_params::generate_marker_segments
	add	eax, 14					; 0000000eH
	cdq
	mov	edi, eax
	mov	DWORD PTR _tile_header_bytes$2$[ebp], edx
	mov	eax, DWORD PTR _layer_idx$[ebp]
	mov	ecx, edx
	mov	edx, DWORD PTR _total_bytes$1$[ebp]
	jmp	SHORT $LN36@simulate_o
$LN120@simulate_o:
	mov	ecx, DWORD PTR _tile_header_bytes$4[ebp+4]
	mov	edi, DWORD PTR _tile_header_bytes$4[ebp]
	mov	DWORD PTR _tile_header_bytes$2$[ebp], ecx
$LN36@simulate_o:

; 5281 :               siz->generate_marker_segments(NULL,tile->t_num,
; 5282 :                                             tile->next_tpart);
; 5283 :             if (last_layer && (tile->num_layers > (layer_idx+1)))

	cmp	BYTE PTR _last_layer$[ebp], 0
	je	SHORT $LN37@simulate_o
	mov	edx, DWORD PTR [esi+132]
	inc	eax
	cmp	edx, eax
	jle	SHORT $LN129@simulate_o

; 5284 :               tile_header_bytes += (tile->num_layers-1-layer_idx) *

	sub	edx, DWORD PTR _layer_idx$[ebp]
	xor	ecx, ecx
	cmp	BYTE PTR [esi+225], cl
	push	DWORD PTR [esi+148]
	setne	cl
	push	DWORD PTR [esi+144]
	lea	eax, DWORD PTR [edx-1]
	lea	ecx, DWORD PTR [ecx*2+1]
	imul	ecx
	push	edx
	push	eax
	call	__allmul
	mov	ecx, DWORD PTR _tile_header_bytes$2$[ebp]
	add	edi, eax
	adc	ecx, edx
$LN129@simulate_o:
	mov	edx, DWORD PTR _total_bytes$1$[ebp]
$LN37@simulate_o:

; 5285 :               tile->total_precincts * ((tile->use_eph)?3:1);
; 5286 :             header_bytes += tile_header_bytes;

	mov	eax, DWORD PTR _header_bytes$[ebp]
	add	DWORD PTR [eax], edi
	adc	DWORD PTR [eax+4], ecx

; 5287 :             total_bytes += tile_header_bytes;

	add	edx, edi
	mov	esi, DWORD PTR [esi+24]
	adc	DWORD PTR _total_bytes$2$[ebp], ecx
	mov	eax, DWORD PTR _layer_idx$[ebp]
	mov	DWORD PTR _total_bytes$1$[ebp], edx
	test	esi, esi
	jne	$LL16@simulate_o
	mov	ecx, DWORD PTR _total_bytes$2$[ebp]
$LN15@simulate_o:

; 5288 :           }
; 5289 :     }
; 5290 :   if (total_bytes > max_bytes)

	cmp	ecx, DWORD PTR _max_bytes$[ebp+4]
	jl	SHORT $LN38@simulate_o
	jg	SHORT $LN113@simulate_o
	cmp	edx, DWORD PTR _max_bytes$[ebp]
	jbe	SHORT $LN38@simulate_o
$LN113@simulate_o:

; 5291 :     {
; 5292 :       assert(!finalize_layer);
; 5293 :       return total_bytes;

	mov	eax, edx
	mov	edx, ecx

; 5436 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN38@simulate_o:

; 5294 :     }
; 5295 : 
; 5296 :   // Now work through all the ready precincts
; 5297 :   kd_global_rescomp *rc = global_rescomps + 32*num_components;

	mov	ecx, DWORD PTR [ebx+112]

; 5298 :   for (int d=32; d >= 0; d--, rc-=(num_components<<1))

	mov	edx, 32					; 00000020H
	imul	esi, ecx, 2560
	mov	DWORD PTR _d$1$[ebp], edx
	add	esi, DWORD PTR [ebx+276]
	mov	DWORD PTR _rc$1$[ebp], esi
	npad	12
$LL19@simulate_o:

; 5299 :     for (int c=0; c < num_components; c++, rc++)

	mov	DWORD PTR _c$1$[ebp], 0
	test	ecx, ecx
	jle	$LN17@simulate_o
	mov	edx, DWORD PTR _rc$1$[ebp]
	mov	ecx, DWORD PTR _c$1$[ebp]
	mov	DWORD PTR tv863[ebp], 808		; 00000328H
	npad	4
$LL22@simulate_o:

; 5300 :       {
; 5301 :         kd_precinct *precinct = rc->first_ready;

	mov	esi, DWORD PTR [edx+48]
	mov	DWORD PTR _precinct$1$[ebp], esi

; 5302 :         if (precinct == NULL)

	test	esi, esi
	je	$LN20@simulate_o

; 5303 :           continue;
; 5304 : 
; 5305 :         // Scale sizes to properly handle incremental flushing.
; 5306 :         bool all_ready = (rc->remaining_area==rc->ready_area);

	mov	ecx, DWORD PTR [edx+40]
	mov	edi, DWORD PTR [edx+44]
	mov	DWORD PTR tv754[ebp], ecx
	cmp	ecx, DWORD PTR [edx+56]
	jne	SHORT $LN65@simulate_o
	cmp	edi, DWORD PTR [edx+60]
	jne	SHORT $LN65@simulate_o
	mov	al, 1
	jmp	SHORT $LN134@simulate_o
$LN65@simulate_o:
	xor	al, al
$LN134@simulate_o:
	xorps	xmm0, xmm0
	mov	BYTE PTR _all_ready$1$[ebp], al

; 5307 :         if (rc->ready_fraction < 0.0)

	comisd	xmm0, QWORD PTR [edx+64]
	jbe	$LN42@simulate_o

; 5308 :           { // The `ready_fraction' value needs to be estimated
; 5309 :             assert((rc->remaining_area > 0) &&
; 5310 :                    (rc->remaining_area >= rc->ready_area));
; 5311 :             if (all_ready)

	test	al, al
	je	SHORT $LN41@simulate_o

; 5312 :               rc->ready_fraction = rc->reciprocal_fraction = 1.0;

	movaps	xmm1, XMMWORD PTR __xmm@3ff00000000000003ff0000000000000
	movups	XMMWORD PTR [edx+64], xmm1

; 5313 :             else

	jmp	$LN42@simulate_o
$LN41@simulate_o:

; 5314 :               {
; 5315 :                 double A;
; 5316 :                 kdu_long T = rc->total_area - rc->area_covered_by_tiles;

	mov	esi, DWORD PTR [edx+16]
	sub	esi, DWORD PTR [edx+32]
	mov	eax, DWORD PTR [edx+20]
	sbb	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _T$1$[ebp], eax

; 5317 :                 if (T > 0)

	js	SHORT $LN43@simulate_o
	jg	SHORT $LN114@simulate_o
	test	esi, esi
	je	SHORT $LN43@simulate_o
$LN114@simulate_o:

; 5318 :                   {
; 5319 :                     assert(T <= (rc->remaining_area + rc->ready_area));
; 5320 :                     A = ((double)(rc->remaining_area - T))

	mov	eax, DWORD PTR _rc$1$[ebp]
	mov	edx, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax+24]
	call	__ltod3
	mov	edx, DWORD PTR _T$1$[ebp]
	mov	ecx, esi
	movsd	QWORD PTR _A$1$[ebp], xmm0
	call	__ltod3
	movsd	xmm1, QWORD PTR _A$1$[ebp]
	mov	eax, DWORD PTR _rc$1$[ebp]
	mulsd	xmm1, xmm0
	mov	edx, DWORD PTR [eax+36]
	mov	ecx, DWORD PTR [eax+32]
	movsd	QWORD PTR _A$1$[ebp], xmm1
	call	__ltod3
	movsd	xmm1, QWORD PTR _A$1$[ebp]
	divsd	xmm1, xmm0
	mov	ecx, DWORD PTR tv754[ebp]
	sub	ecx, esi
	sbb	edi, DWORD PTR _T$1$[ebp]
	mov	edx, edi
	movsd	QWORD PTR _A$1$[ebp], xmm1
	call	__ltod3
	movsd	xmm1, QWORD PTR _A$1$[ebp]
	addsd	xmm1, xmm0
	movsd	QWORD PTR _A$1$[ebp], xmm1

; 5321 :                       + ((double) T) * ((double) rc->area_used_by_tiles) /
; 5322 :                                    ((double) rc->area_covered_by_tiles);
; 5323 :                   }
; 5324 :                 else

	jmp	SHORT $LN44@simulate_o
$LN43@simulate_o:

; 5325 :                   A = (double)(rc->remaining_area);

	mov	edx, edi
	call	__ltod3
	movsd	QWORD PTR _A$1$[ebp], xmm0
$LN44@simulate_o:

; 5326 :                 rc->ready_fraction = ((double)(rc->ready_area)) / A;

	mov	eax, DWORD PTR _rc$1$[ebp]
	mov	edx, DWORD PTR [eax+60]
	mov	ecx, DWORD PTR [eax+56]
	call	__ltod3
	divsd	xmm0, QWORD PTR _A$1$[ebp]
	mov	edx, DWORD PTR _rc$1$[ebp]

; 5327 :                 if (rc->ready_fraction > 1.0)

	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	comisd	xmm0, xmm1
	movsd	QWORD PTR [edx+64], xmm0
	jbe	SHORT $LN45@simulate_o

; 5328 :                   rc->ready_fraction = 1.0; // In case of rounding problems.

	movsd	QWORD PTR [edx+64], xmm1
$LN45@simulate_o:

; 5329 :                 rc->reciprocal_fraction = 1.0 / rc->ready_fraction;

	movaps	xmm0, xmm1
	mov	esi, DWORD PTR _precinct$1$[ebp]
	divsd	xmm0, QWORD PTR [edx+64]
	movsd	QWORD PTR [edx+72], xmm0
$LN42@simulate_o:

; 5330 :               }
; 5331 :           }
; 5332 : 
; 5333 :         kdu_long local_max_bytes = max_bytes-total_bytes;

	mov	ecx, DWORD PTR _max_bytes$[ebp]
	sub	ecx, DWORD PTR _total_bytes$1$[ebp]
	mov	eax, DWORD PTR _max_bytes$[ebp+4]
	sbb	eax, DWORD PTR _total_bytes$2$[ebp]
	mov	DWORD PTR _local_max_bytes$2$[ebp], eax

; 5334 :         kdu_long local_sloppy = (sloppy_bytes!=NULL)?(*sloppy_bytes):0;

	mov	eax, DWORD PTR _sloppy_bytes$[ebp]
	mov	DWORD PTR _local_max_bytes$1$[ebp], ecx
	test	eax, eax
	je	SHORT $LN67@simulate_o
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $LN135@simulate_o
$LN67@simulate_o:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR _local_sloppy$5[ebp], xmm0
	mov	eax, DWORD PTR _local_sloppy$5[ebp+4]
	mov	edi, DWORD PTR _local_sloppy$5[ebp]
$LN135@simulate_o:

; 5335 :         if (!all_ready)

	cmp	BYTE PTR _all_ready$1$[ebp], 0
	mov	DWORD PTR _local_sloppy$1$[ebp], edi
	mov	DWORD PTR _local_sloppy$2$[ebp], eax
	jne	SHORT $LN123@simulate_o

; 5336 :           {
; 5337 :             local_max_bytes = (kdu_long)(local_max_bytes*rc->ready_fraction);

	mov	edx, DWORD PTR _local_max_bytes$2$[ebp]
	call	__ltod3
	mov	eax, DWORD PTR _rc$1$[ebp]
	mulsd	xmm0, QWORD PTR [eax+64]
	call	__dtol3
	mov	DWORD PTR _local_max_bytes$2$[ebp], edx

; 5338 :             local_sloppy = ((kdu_long)(local_sloppy*rc->ready_fraction)) - 1;

	mov	ecx, edi
	mov	edx, DWORD PTR _local_sloppy$2$[ebp]
	mov	DWORD PTR _local_max_bytes$1$[ebp], eax
	call	__ltod3
	mov	eax, DWORD PTR _rc$1$[ebp]
	mulsd	xmm0, QWORD PTR [eax+64]
	call	__dtol3
	mov	edi, eax
	mov	eax, edx
	sub	edi, 1
	mov	DWORD PTR _local_sloppy$1$[ebp], edi
	sbb	eax, 0
	mov	DWORD PTR _local_sloppy$2$[ebp], eax

; 5339 :             if (local_sloppy < 0)

	test	eax, eax
	jg	SHORT $LN47@simulate_o
	jl	SHORT $LN115@simulate_o
	test	edi, edi
	jae	SHORT $LN47@simulate_o
$LN115@simulate_o:
	xorps	xmm0, xmm0

; 5340 :               local_sloppy = 0;

	movlpd	QWORD PTR _local_sloppy$5[ebp], xmm0
	mov	eax, DWORD PTR _local_sloppy$5[ebp+4]
	mov	edi, DWORD PTR _local_sloppy$5[ebp]
	mov	DWORD PTR _local_sloppy$2$[ebp], eax
	mov	DWORD PTR _local_sloppy$1$[ebp], edi
	jmp	SHORT $LN47@simulate_o
$LN123@simulate_o:
	mov	edi, DWORD PTR _local_sloppy$1$[ebp]
	mov	eax, DWORD PTR _local_sloppy$2$[ebp]
$LN47@simulate_o:
	xorps	xmm0, xmm0

; 5341 :           }
; 5342 :         kdu_long initial_local_sloppy = local_sloppy;

	mov	DWORD PTR _initial_local_sloppy$2$[ebp], eax

; 5343 :         kdu_long local_header_bytes=0, local_total_bytes=0;

	movlpd	QWORD PTR _local_header_bytes$6[ebp], xmm0
	mov	eax, DWORD PTR _local_header_bytes$6[ebp+4]
	mov	ecx, DWORD PTR _local_header_bytes$6[ebp]
	movlpd	QWORD PTR _local_total_bytes$7[ebp], xmm0
	mov	edx, DWORD PTR _local_total_bytes$7[ebp+4]
	mov	DWORD PTR _local_header_bytes$2$[ebp], eax
	mov	eax, DWORD PTR _local_total_bytes$7[ebp]
	mov	DWORD PTR _initial_local_sloppy$1$[ebp], edi
	mov	DWORD PTR _local_header_bytes$1$[ebp], ecx
	mov	DWORD PTR _local_total_bytes$2$[ebp], edx
	mov	DWORD PTR _local_total_bytes$1$[ebp], eax
$LL25@simulate_o:

; 5348 :           {
; 5349 :             if (precinct->next_layer_idx != 0)

	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN48@simulate_o

; 5350 :               { KDU_ERROR_DEV(e,37); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BBD@JFFMFNED@Attempting?5to?5run?5rate?9control?5s@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5350 :               { KDU_ERROR_DEV(e,37); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5357 :               }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	edx, DWORD PTR _local_total_bytes$2$[ebp]
$LN48@simulate_o:

; 5358 :             if (layer_idx >= precinct->resolution->tile_comp->tile->num_layers)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _layer_idx$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [eax+132]
	jge	$LN23@simulate_o

; 5359 :               continue;
; 5360 :             packet_bytes = packet_header_bytes = 0;
; 5361 :             if (sloppy_bytes != NULL)

	cmp	DWORD PTR _sloppy_bytes$[ebp], 0
	xorps	xmm0, xmm0
	movlpd	QWORD PTR _packet_header_bytes$3[ebp], xmm0

; 5362 :               {
; 5363 :                 assert(finalize_layer && last_layer && (local_sloppy >= 0));
; 5364 :                 assert(slope_threshold < 0xFFFF);
; 5365 :                 packet_bytes =

	push	0
	je	SHORT $LN50@simulate_o
	mov	eax, DWORD PTR _slope_threshold$[ebp]
	push	1048576					; 00100000H
	push	0
	push	1
	push	0
	inc	eax
	push	eax
	push	ecx
	lea	eax, DWORD PTR _packet_header_bytes$3[ebp]
	mov	ecx, esi
	push	eax
	call	?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z ; kd_precinct::simulate_packet

; 5366 :                   precinct->simulate_packet(packet_header_bytes,layer_idx,
; 5367 :                                             slope_threshold+1,false,true);
; 5368 :                 kdu_long packet_max_bytes = packet_bytes + local_sloppy;
; 5369 :                 if (packet_max_bytes > (local_max_bytes-local_total_bytes))

	mov	ecx, DWORD PTR _local_max_bytes$2$[ebp]
	add	edi, eax
	mov	eax, DWORD PTR _local_max_bytes$1$[ebp]
	adc	edx, DWORD PTR _local_sloppy$2$[ebp]
	sub	eax, DWORD PTR _local_total_bytes$1$[ebp]
	mov	DWORD PTR _local_sloppy$2$[ebp], edx
	sbb	ecx, DWORD PTR _local_total_bytes$2$[ebp]
	cmp	edx, ecx
	jl	SHORT $LN52@simulate_o
	jg	SHORT $LN116@simulate_o
	cmp	edi, eax
	jbe	SHORT $LN52@simulate_o
$LN116@simulate_o:

; 5370 :                   packet_max_bytes = local_max_bytes-local_total_bytes;

	mov	edi, eax
	mov	DWORD PTR _local_sloppy$2$[ebp], ecx
	mov	edx, ecx
$LN52@simulate_o:

; 5371 :                 assert(packet_max_bytes >= packet_bytes);
; 5372 :                 packet_bytes =

	push	1
	push	edx
	push	edi
	push	1
	push	1
	push	DWORD PTR _slope_threshold$[ebp]
	lea	eax, DWORD PTR _packet_header_bytes$3[ebp]
	mov	ecx, esi
	push	DWORD PTR _layer_idx$[ebp]
	push	eax
	call	?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z ; kd_precinct::simulate_packet

; 5373 :                   precinct->simulate_packet(packet_header_bytes,layer_idx,
; 5374 :                                             slope_threshold,true,true,
; 5375 :                                             packet_max_bytes,true);
; 5376 :                 assert(packet_bytes <= packet_max_bytes);
; 5377 :                 local_sloppy = packet_max_bytes - packet_bytes;

	sub	edi, eax
	mov	ecx, edx
	mov	DWORD PTR _local_sloppy$1$[ebp], edi
	sbb	DWORD PTR _local_sloppy$2$[ebp], ecx

; 5378 :               }
; 5379 :             else

	mov	edi, DWORD PTR _local_total_bytes$1$[ebp]
	mov	DWORD PTR _packet_bytes$1$[ebp], ecx
	jmp	SHORT $LN136@simulate_o
$LN50@simulate_o:

; 5380 :               packet_bytes =

	mov	ecx, DWORD PTR _local_max_bytes$1$[ebp]
	mov	edi, DWORD PTR _local_total_bytes$1$[ebp]
	sub	ecx, edi
	mov	eax, DWORD PTR _local_max_bytes$2$[ebp]
	sbb	eax, edx
	push	eax
	push	ecx
	push	DWORD PTR _last_layer$[ebp]
	lea	eax, DWORD PTR _packet_header_bytes$3[ebp]
	mov	ecx, esi
	push	DWORD PTR _finalize_layer$[ebp]
	push	DWORD PTR _slope_threshold$[ebp]
	push	DWORD PTR _layer_idx$[ebp]
	push	eax
	call	?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z ; kd_precinct::simulate_packet
	mov	ecx, edx
	mov	DWORD PTR _packet_bytes$1$[ebp], edx
$LN136@simulate_o:

; 5381 :                 precinct->simulate_packet(packet_header_bytes,layer_idx,
; 5382 :                              slope_threshold,finalize_layer,last_layer,
; 5383 :                              local_max_bytes-local_total_bytes);
; 5384 :             local_total_bytes += packet_bytes;

	mov	edx, DWORD PTR _local_total_bytes$2$[ebp]
	add	edi, eax
	mov	DWORD PTR _packet_bytes$2$[ebp], eax
	adc	edx, ecx
	mov	DWORD PTR _local_total_bytes$1$[ebp], edi

; 5385 :             local_header_bytes += packet_header_bytes;

	mov	ecx, DWORD PTR _local_header_bytes$1$[ebp]
	add	ecx, DWORD PTR _packet_header_bytes$3[ebp]
	mov	DWORD PTR _local_header_bytes$1$[ebp], ecx
	mov	ecx, DWORD PTR _local_header_bytes$2$[ebp]
	adc	ecx, DWORD PTR _packet_header_bytes$3[ebp+4]

; 5386 :             if (reslength_constraints_used && !reslength_warning_issued)

	cmp	BYTE PTR [ebx+320], 0
	mov	DWORD PTR _local_header_bytes$2$[ebp], ecx
	mov	ecx, DWORD PTR _packet_bytes$1$[ebp]
	mov	DWORD PTR _local_total_bytes$2$[ebp], edx
	je	$LN27@simulate_o
	cmp	BYTE PTR [ebx+322], 0
	jne	$LN27@simulate_o

; 5387 :               for (int glob=0; glob < 2; glob++)

	xor	edi, edi
$LL28@simulate_o:

; 5388 :                 {
; 5389 :                   kd_tile *tile = precinct->resolution->tile_comp->tile;
; 5390 :                   kd_reslength_checker *checkers =
; 5391 :                     (glob)?this->reslength_checkers:tile->reslength_checkers;

	test	edi, edi
	je	SHORT $LN69@simulate_o
	mov	esi, DWORD PTR [ebx+324]
	jmp	SHORT $LN70@simulate_o
$LN69@simulate_o:
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax+120]
	mov	eax, DWORD PTR _packet_bytes$2$[ebp]
$LN70@simulate_o:

; 5392 :                   if (checkers != NULL)

	test	esi, esi
	je	SHORT $LN26@simulate_o

; 5393 :                     {
; 5394 :                       if (!checkers[0].check_packet(packet_bytes,d))

	push	DWORD PTR _d$1$[ebp]
	push	ecx
	push	eax
	mov	ecx, esi
	call	?check_packet@kd_reslength_checker@@QAE_N_JH@Z ; kd_reslength_checker::check_packet
	test	al, al
	jne	SHORT $LN55@simulate_o

; 5395 :                         reslength_constraints_violated = true;

	mov	BYTE PTR [ebx+321], 1
$LN55@simulate_o:

; 5396 :                       if (!checkers[c+1].check_packet(packet_bytes,d))

	push	DWORD PTR _d$1$[ebp]
	mov	ecx, DWORD PTR tv863[ebp]
	push	DWORD PTR _packet_bytes$1$[ebp]
	push	DWORD PTR _packet_bytes$2$[ebp]
	lea	ecx, DWORD PTR [esi+ecx]
	call	?check_packet@kd_reslength_checker@@QAE_N_JH@Z ; kd_reslength_checker::check_packet
	mov	ecx, DWORD PTR _packet_bytes$1$[ebp]
	test	al, al
	jne	SHORT $LN26@simulate_o

; 5397 :                         reslength_constraints_violated = true;

	mov	BYTE PTR [ebx+321], 1
$LN26@simulate_o:

; 5387 :               for (int glob=0; glob < 2; glob++)

	mov	eax, DWORD PTR _packet_bytes$2$[ebp]
	inc	edi
	mov	esi, DWORD PTR _precinct$1$[ebp]
	cmp	edi, 2
	jl	SHORT $LL28@simulate_o
	mov	edx, DWORD PTR _local_total_bytes$2$[ebp]
	mov	edi, DWORD PTR _local_total_bytes$1$[ebp]
$LN27@simulate_o:

; 5398 :                     }
; 5399 :                 }
; 5400 :             if (local_total_bytes > local_max_bytes)

	cmp	edx, DWORD PTR _local_max_bytes$2$[ebp]
	jg	SHORT $LN83@simulate_o
	jl	SHORT $LN122@simulate_o
	cmp	edi, DWORD PTR _local_max_bytes$1$[ebp]
	ja	SHORT $LN83@simulate_o
$LN122@simulate_o:
	mov	edi, DWORD PTR _local_sloppy$1$[ebp]
$LN23@simulate_o:

; 5344 : 
; 5345 :         // Now size the packets using scaled sizes
; 5346 :         kdu_long packet_header_bytes, packet_bytes;
; 5347 :         for (; precinct != NULL; precinct=precinct->next)

	mov	esi, DWORD PTR [esi+44]
	mov	DWORD PTR _precinct$1$[ebp], esi
	test	esi, esi
	jne	$LL25@simulate_o
$LN83@simulate_o:

; 5401 :               {
; 5402 :                 assert(!finalize_layer);
; 5403 :                   // Otherwise, you are not driving this function correctly
; 5404 :                 break;
; 5405 :               }
; 5406 :           }
; 5407 : 
; 5408 :         // Now scale the packet sizes back up again
; 5409 :         if (all_ready)

	cmp	BYTE PTR _all_ready$1$[ebp], 0

; 5410 :           {
; 5411 :             header_bytes += local_header_bytes;

	mov	ecx, DWORD PTR _local_header_bytes$1$[ebp]
	je	SHORT $LN58@simulate_o
	mov	edi, DWORD PTR _header_bytes$[ebp]
	mov	eax, DWORD PTR _local_header_bytes$2$[ebp]
	add	DWORD PTR [edi], ecx

; 5412 :             total_bytes += local_total_bytes;

	mov	ecx, DWORD PTR _total_bytes$1$[ebp]
	adc	DWORD PTR [edi+4], eax
	add	ecx, DWORD PTR _local_total_bytes$1$[ebp]
	mov	DWORD PTR _total_bytes$1$[ebp], ecx
	adc	DWORD PTR _total_bytes$2$[ebp], edx

; 5413 :             if (sloppy_bytes != NULL)

	mov	edx, DWORD PTR _sloppy_bytes$[ebp]
	test	edx, edx
	je	$LN62@simulate_o

; 5414 :               *sloppy_bytes = local_sloppy;

	mov	edi, DWORD PTR _local_sloppy$1$[ebp]
	mov	ecx, DWORD PTR _local_sloppy$2$[ebp]
	mov	DWORD PTR [edx], edi
	mov	DWORD PTR [edx+4], ecx

; 5415 :           }
; 5416 :         else

	jmp	$LN131@simulate_o
$LN58@simulate_o:

; 5417 :           {
; 5418 :             header_bytes +=

	mov	edx, DWORD PTR _local_header_bytes$2$[ebp]
	call	__ltod3
	mov	esi, DWORD PTR _rc$1$[ebp]
	mulsd	xmm0, QWORD PTR [esi+72]
	call	__dtol3
	mov	ecx, DWORD PTR _header_bytes$[ebp]
	add	eax, 1
	adc	edx, 0
	add	DWORD PTR [ecx], eax
	adc	DWORD PTR [ecx+4], edx

; 5419 :               1 + (kdu_long)(local_header_bytes*rc->reciprocal_fraction);
; 5420 :             total_bytes +=

	mov	edx, DWORD PTR _local_total_bytes$2$[ebp]
	mov	ecx, DWORD PTR _local_total_bytes$1$[ebp]
	call	__ltod3
	mulsd	xmm0, QWORD PTR [esi+72]
	call	__dtol3
	mov	ecx, DWORD PTR _total_bytes$1$[ebp]
	add	eax, 1
	adc	edx, 0
	add	ecx, eax
	mov	DWORD PTR _total_bytes$1$[ebp], ecx
	adc	DWORD PTR _total_bytes$2$[ebp], edx

; 5421 :               1 + (kdu_long)(local_total_bytes*rc->reciprocal_fraction);
; 5422 :             if (sloppy_bytes != NULL)

	cmp	DWORD PTR _sloppy_bytes$[ebp], 0
	je	SHORT $LN62@simulate_o

; 5423 :               {
; 5424 :                 kdu_long delta_sloppy = initial_local_sloppy - local_sloppy;

	mov	ecx, DWORD PTR _initial_local_sloppy$1$[ebp]
	sub	ecx, DWORD PTR _local_sloppy$1$[ebp]
	mov	edx, DWORD PTR _initial_local_sloppy$2$[ebp]
	sbb	edx, DWORD PTR _local_sloppy$2$[ebp]

; 5425 :                 delta_sloppy =

	call	__ltod3
	mulsd	xmm0, QWORD PTR [esi+72]
	call	__dtol3

; 5426 :                   1 + (kdu_long)(delta_sloppy * rc->reciprocal_fraction);
; 5427 :                 *sloppy_bytes -= delta_sloppy;

	or	ecx, -1
	sub	ecx, eax
	mov	eax, -1
	sbb	eax, edx
	mov	edx, DWORD PTR _sloppy_bytes$[ebp]
	add	DWORD PTR [edx], ecx
	adc	DWORD PTR [edx+4], eax

; 5428 :                 if (*sloppy_bytes < 0)

	cmp	DWORD PTR [edx+4], 0
	jg	SHORT $LN131@simulate_o
	jl	SHORT $LN118@simulate_o
	cmp	DWORD PTR [edx], 0
	jae	SHORT $LN131@simulate_o
$LN118@simulate_o:

; 5429 :                   *sloppy_bytes = 0;

	mov	DWORD PTR [edx], 0
	mov	DWORD PTR [edx+4], 0
$LN131@simulate_o:
	mov	ecx, DWORD PTR _total_bytes$1$[ebp]
$LN62@simulate_o:

; 5430 :               }
; 5431 :           }
; 5432 :         if (total_bytes > max_bytes)

	mov	edx, DWORD PTR _total_bytes$2$[ebp]
	cmp	edx, DWORD PTR _max_bytes$[ebp+4]
	jg	SHORT $LN84@simulate_o
	jl	SHORT $LN125@simulate_o
	cmp	ecx, DWORD PTR _max_bytes$[ebp]
	ja	SHORT $LN84@simulate_o
$LN125@simulate_o:
	mov	ecx, DWORD PTR _c$1$[ebp]
	mov	edx, DWORD PTR _rc$1$[ebp]
$LN20@simulate_o:

; 5299 :     for (int c=0; c < num_components; c++, rc++)

	add	DWORD PTR tv863[ebp], 808		; 00000328H
	inc	ecx
	add	edx, 80					; 00000050H
	mov	DWORD PTR _c$1$[ebp], ecx
	mov	DWORD PTR _rc$1$[ebp], edx
	cmp	ecx, DWORD PTR [ebx+112]
	jl	$LL22@simulate_o
	mov	edx, DWORD PTR _d$1$[ebp]
	mov	esi, DWORD PTR _rc$1$[ebp]
$LN17@simulate_o:

; 5298 :   for (int d=32; d >= 0; d--, rc-=(num_components<<1))

	mov	ecx, DWORD PTR [ebx+112]
	dec	edx
	imul	eax, ecx, -160
	mov	DWORD PTR _d$1$[ebp], edx
	add	esi, eax
	mov	DWORD PTR _rc$1$[ebp], esi
	test	edx, edx
	jns	$LL19@simulate_o

; 5434 :       }
; 5435 :   return total_bytes;

	mov	eax, DWORD PTR _total_bytes$1$[ebp]
	mov	edx, DWORD PTR _total_bytes$2$[ebp]

; 5436 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN84@simulate_o:

; 5433 :           return total_bytes;

	mov	eax, ecx

; 5436 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-136]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z ENDP ; kd_codestream::simulate_output
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?calculate_min_header_cost@kd_codestream@@QAEXXZ
_TEXT	SEGMENT
tv334 = -36						; size = 8
_tile_area$ = -36					; size = 8
_idx$2$ = -32						; size = 4
_idx$1$ = -28						; size = 4
_tref$1$ = -24						; size = 4
_tile_area$1$ = -20					; size = 4
_tile_area$2$ = -16					; size = 4
_tile_layer_cost$ = -12					; size = 8
_tile_layer_cost$1$ = -8				; size = 4
_tile_layer_cost$2$ = -4				; size = 4
?calculate_min_header_cost@kd_codestream@@QAEXXZ PROC	; kd_codestream::calculate_min_header_cost, COMDAT
; _this$ = ecx

; 5444 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 5445 :   assert(min_fixed_header_size == 0);
; 5446 :   min_fixed_header_size = min_layer_header_size = 0;
; 5447 :   if (initial_fragment)

	cmp	BYTE PTR [esi+225], 0
	mov	DWORD PTR [esi+312], 0
	mov	DWORD PTR [esi+316], 0
	mov	DWORD PTR [esi+304], 0
	mov	DWORD PTR [esi+308], 0
	je	SHORT $LN11@calculate_

; 5448 :     min_fixed_header_size += 2 + siz->generate_marker_segments(NULL,-1,0);

	mov	ecx, DWORD PTR [esi+12]
	push	0
	push	-1
	push	0
	call	?generate_marker_segments@kdu_params@@QAEHPAVkdu_output@@HH@Z ; kdu_params::generate_marker_segments
	add	eax, 2
	cdq
	add	DWORD PTR [esi+304], eax
	adc	DWORD PTR [esi+308], edx
$LN11@calculate_:

; 5449 :   if (!comments_frozen)

	cmp	BYTE PTR [esi+342], 0
	jne	SHORT $LN12@calculate_

; 5450 :     freeze_comments();

	mov	ecx, esi
	call	?freeze_comments@kd_codestream@@AAEXXZ	; kd_codestream::freeze_comments
$LN12@calculate_:

; 5451 :   if (initial_fragment)

	cmp	BYTE PTR [esi+225], 0
	je	SHORT $LN13@calculate_

; 5452 :     {
; 5453 :       kd_codestream_comment *comscan;
; 5454 :       for (comscan=comhead; comscan != NULL; comscan=comscan->next)

	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $LN3@calculate_
	npad	6
$LL4@calculate_:

; 5455 :         min_fixed_header_size += comscan->write_marker(NULL);

	push	0
	push	0
	mov	ecx, edi
	call	?write_marker@kd_codestream_comment@@QAEHPAVkdu_output@@H@Z ; kd_codestream_comment::write_marker
	cdq
	add	DWORD PTR [esi+304], eax
	adc	DWORD PTR [esi+308], edx
	mov	edi, DWORD PTR [edi+16]
	test	edi, edi
	jne	SHORT $LL4@calculate_
$LN3@calculate_:

; 5456 :       min_fixed_header_size += reserved_layer_info_bytes;

	mov	eax, DWORD PTR [esi+360]
	cdq
	add	DWORD PTR [esi+304], eax
	adc	DWORD PTR [esi+308], edx
$LN13@calculate_:

; 5457 :     }
; 5458 :   kdu_long tile_area=0, tile_layer_cost=0;
; 5459 :   kd_tile_ref *tref = tile_refs;

	mov	eax, DWORD PTR [esi+264]
	xorps	xmm0, xmm0
	mov	DWORD PTR _tref$1$[ebp], eax

; 5460 :   kdu_coords idx, abs_idx;
; 5461 :   for (idx.y=0; idx.y < tile_indices.size.y; idx.y++)

	xor	eax, eax
	movlpd	QWORD PTR _tile_layer_cost$[ebp], xmm0
	mov	ebx, DWORD PTR _tile_layer_cost$[ebp+4]
	mov	edi, DWORD PTR _tile_layer_cost$[ebp]
	movlpd	QWORD PTR _tile_area$[ebp], xmm0
	mov	DWORD PTR _idx$1$[ebp], eax
	cmp	DWORD PTR [esi+180], eax
	jle	$LN45@calculate_
	mov	ecx, DWORD PTR _tile_area$[ebp+4]
	mov	DWORD PTR _tile_area$2$[ebp], ecx
	mov	ecx, DWORD PTR _tile_area$[ebp]
	mov	DWORD PTR _tile_area$1$[ebp], ecx
	mov	DWORD PTR _tile_layer_cost$2$[ebp], ebx
	mov	DWORD PTR _tile_layer_cost$1$[ebp], edi
$LL7@calculate_:

; 5462 :     for (idx.x=0; idx.x < tile_indices.size.x; idx.x++, tref++)

	xor	ecx, ecx
	mov	DWORD PTR _idx$2$[ebp], ecx
	cmp	DWORD PTR [esi+184], ecx
	jle	$LN5@calculate_
$LL10@calculate_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	edx, DWORD PTR [esi+172]
	add	edx, eax
	mov	eax, DWORD PTR [esi+176]
	add	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5466 :         int t_num = abs_idx.x + abs_idx.y*tile_span.x;

	mov	ecx, DWORD PTR [esi+168]
	imul	ecx, edx

; 5467 :         min_fixed_header_size += 12 + 2 +

	push	0
	add	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR [esi+12]
	push	0
	call	?generate_marker_segments@kdu_params@@QAEHPAVkdu_output@@HH@Z ; kdu_params::generate_marker_segments
	add	eax, 14					; 0000000eH
	cdq
	add	DWORD PTR [esi+304], eax

; 5468 :           siz->generate_marker_segments(NULL,t_num,0);
; 5469 :         kd_tile *tile = tref->tile;

	mov	eax, DWORD PTR _tref$1$[ebp]
	adc	DWORD PTR [esi+308], edx
	mov	ebx, DWORD PTR [eax+8]

; 5470 :         if ((tile == NULL) || (tile == KD_EXPIRED_TILE))

	test	ebx, ebx
	je	SHORT $LN48@calculate_
	cmp	ebx, -1
	je	SHORT $LN48@calculate_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [ebx+172]
	imul	DWORD PTR [ebx+168]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5473 :         tile_layer_cost += tile->total_precincts;

	mov	edi, DWORD PTR [ebx+148]
	add	DWORD PTR _tile_area$1$[ebp], eax
	adc	DWORD PTR _tile_area$2$[ebp], edx
	mov	edx, DWORD PTR [ebx+144]
	add	DWORD PTR _tile_layer_cost$1$[ebp], edx
	adc	DWORD PTR _tile_layer_cost$2$[ebp], edi

; 5474 :         if (tile->use_eph)

	cmp	BYTE PTR [ebx+225], 0
	je	SHORT $LN16@calculate_

; 5475 :           tile_layer_cost += tile->total_precincts*2;

	mov	eax, edx
	mov	ecx, edi
	shld	ecx, eax, 1
	add	eax, eax
	add	DWORD PTR _tile_layer_cost$1$[ebp], eax
	adc	DWORD PTR _tile_layer_cost$2$[ebp], ecx
$LN16@calculate_:

; 5476 :         if (tile->use_sop)

	cmp	BYTE PTR [ebx+224], 0

; 5477 :           tile_layer_cost += tile->total_precincts*6;

	mov	ebx, DWORD PTR _tile_layer_cost$2$[ebp]
	je	SHORT $LN46@calculate_
	mov	eax, edx
	mov	ecx, edi
	shld	ecx, eax, 1
	add	eax, eax
	add	edx, eax
	adc	edi, ecx
	shld	edi, edx, 1
	add	edx, edx
	add	DWORD PTR _tile_layer_cost$1$[ebp], edx
	adc	ebx, edi
	mov	DWORD PTR _tile_layer_cost$2$[ebp], ebx
$LN46@calculate_:
	mov	eax, DWORD PTR _tref$1$[ebp]
	jmp	SHORT $LN8@calculate_
$LN48@calculate_:
	mov	ebx, DWORD PTR _tile_layer_cost$2$[ebp]
$LN8@calculate_:

; 5462 :     for (idx.x=0; idx.x < tile_indices.size.x; idx.x++, tref++)

	mov	ecx, DWORD PTR _idx$2$[ebp]
	add	eax, 12					; 0000000cH
	inc	ecx
	mov	DWORD PTR _tref$1$[ebp], eax
	mov	eax, DWORD PTR _idx$1$[ebp]
	mov	DWORD PTR _idx$2$[ebp], ecx
	cmp	ecx, DWORD PTR [esi+184]
	jl	$LL10@calculate_
$LN5@calculate_:

; 5460 :   kdu_coords idx, abs_idx;
; 5461 :   for (idx.y=0; idx.y < tile_indices.size.y; idx.y++)

	inc	eax
	mov	DWORD PTR _idx$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+180]
	jl	$LL7@calculate_
	mov	edi, DWORD PTR _tile_layer_cost$1$[ebp]
	mov	eax, DWORD PTR _tile_area$1$[ebp]
	jmp	SHORT $LN6@calculate_
$LN45@calculate_:
	mov	eax, DWORD PTR _tile_area$[ebp+4]
	mov	DWORD PTR _tile_area$2$[ebp], eax
	mov	eax, DWORD PTR _tile_area$[ebp]
	mov	DWORD PTR _tile_area$1$[ebp], eax
$LN6@calculate_:

; 5478 :       }
; 5479 : 
; 5480 :   kdu_long total_area=canvas.area();
; 5481 :   assert(total_area >= tile_area);
; 5482 :   if (tile_area > 0)

	cmp	DWORD PTR _tile_area$2$[ebp], 0
	jl	SHORT $LN18@calculate_
	jg	SHORT $LN44@calculate_
	test	eax, eax
	je	SHORT $LN18@calculate_
$LN44@calculate_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [esi+144]
	imul	DWORD PTR [esi+140]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5484 :       double scale = ((double) total_area) / ((double) tile_area);

	mov	ecx, eax
	call	__ltod3
	mov	edx, DWORD PTR _tile_area$2$[ebp]
	mov	ecx, DWORD PTR _tile_area$1$[ebp]
	movsd	QWORD PTR tv334[ebp], xmm0
	call	__ltod3
	movsd	xmm1, QWORD PTR tv334[ebp]

; 5485 :       min_layer_header_size = (kdu_long)(tile_layer_cost * scale);

	mov	edx, ebx
	divsd	xmm1, xmm0
	mov	ecx, edi
	movsd	QWORD PTR tv334[ebp], xmm1
	call	__ltod3
	mulsd	xmm0, QWORD PTR tv334[ebp]
	call	__dtol3
	mov	DWORD PTR [esi+312], eax
	mov	DWORD PTR [esi+316], edx
$LN18@calculate_:
	pop	edi
	pop	esi
	pop	ebx

; 5486 :     }
; 5487 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?calculate_min_header_cost@kd_codestream@@QAEXXZ ENDP	; kd_codestream::calculate_min_header_cost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?trim_compressed_data@kd_codestream@@QAEXXZ
_TEXT	SEGMENT
_threshold$1$ = -32					; size = 4
_d$1$ = -28						; size = 4
_c$1$ = -24						; size = 4
_this$1$ = -20						; size = 4
_precinct$1$ = -16					; size = 4
tv301 = -12						; size = 4
_b$1$ = -8						; size = 4
_rc$1$ = -4						; size = 4
?trim_compressed_data@kd_codestream@@QAEXXZ PROC	; kd_codestream::trim_compressed_data, COMDAT
; _this$ = ecx

; 5206 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 5207 :   if (stats == NULL)

	mov	edx, DWORD PTR [ebx+32]
	test	edx, edx
	je	$LN3@trim_compr
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1410 :           (assume_all_coded)?remaining_slope_threshold:block_slope_threshold;

	mov	edx, DWORD PTR [edx+32820]

; 1411 :         val = (val<<4)-1;
; 1412 :         return (kdu_uint16)((val>0)?val:1);

	mov	ecx, 1
	shl	edx, 4
	dec	edx
	test	edx, edx
	movzx	eax, dx
	cmovg	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5209 :   kdu_uint16 threshold = stats->get_conservative_slope_threshold(true);

	movzx	eax, cx
	mov	DWORD PTR _threshold$1$[ebp], eax

; 5210 :   if (threshold <= 1)

	cmp	eax, 1
	jbe	$LN3@trim_compr

; 5211 :     return;
; 5212 : 
; 5213 :   // Work through all the ready precincts
; 5214 :   kd_global_rescomp *rc = global_rescomps + 32*num_components;

	mov	ecx, DWORD PTR [ebx+112]
	imul	edx, ecx, 2560
	push	esi

; 5215 :   kd_precinct *precinct;
; 5216 :   for (int d=32; d >= 0; d--, rc-=(num_components<<1))

	mov	esi, 32					; 00000020H
	push	edi
	mov	DWORD PTR _d$1$[ebp], esi
	add	edx, DWORD PTR [ebx+276]
	mov	DWORD PTR _rc$1$[ebp], edx
	npad	7
$LL4@trim_compr:

; 5217 :     for (int c=0; c < num_components; c++, rc++)

	xor	eax, eax
	mov	DWORD PTR _c$1$[ebp], eax
	test	ecx, ecx
	jle	$LN2@trim_compr
	npad	3
$LL7@trim_compr:

; 5218 :       for (precinct=rc->first_ready; precinct!=NULL; precinct=precinct->next)

	mov	ecx, DWORD PTR [edx+48]
	mov	DWORD PTR _precinct$1$[ebp], ecx
	test	ecx, ecx
	je	$LN5@trim_compr
	npad	2
$LL10@trim_compr:

; 5219 :         for (int b=0; b < precinct->resolution->num_subbands; b++)

	mov	eax, DWORD PTR [ecx]
	xor	edx, edx
	mov	DWORD PTR _b$1$[ebp], edx
	cmp	BYTE PTR [eax+174], dl
	jbe	SHORT $LN8@trim_compr
	xor	ebx, ebx
	mov	DWORD PTR tv301[ebp], ebx
$LL13@trim_compr:

; 5220 :           {
; 5221 :             kd_precinct_band *pb = precinct->subbands + b;

	mov	esi, DWORD PTR [ecx+40]

; 5222 :             for (int n=0; n < (int) pb->block_indices.area(); n++)

	xor	edi, edi
	add	esi, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [esi+16]
	imul	eax, DWORD PTR [esi+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5222 :             for (int n=0; n < (int) pb->block_indices.area(); n++)

	test	eax, eax
	jle	SHORT $LN11@trim_compr

; 5220 :           {
; 5221 :             kd_precinct_band *pb = precinct->subbands + b;

	xor	ebx, ebx
$LL16@trim_compr:

; 5223 :               {
; 5224 :                 kd_block *block = pb->blocks + n;
; 5225 :                 block->trim_data(threshold,buf_server);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [esi+20]
	add	ecx, ebx
	push	DWORD PTR [eax+24]
	push	DWORD PTR _threshold$1$[ebp]
	call	?trim_data@kd_block@@QAE_NGPAVkd_buf_server@@@Z ; kd_block::trim_data
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [esi+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5222 :             for (int n=0; n < (int) pb->block_indices.area(); n++)

	inc	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	imul	eax, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5222 :             for (int n=0; n < (int) pb->block_indices.area(); n++)

	add	ebx, 24					; 00000018H
	cmp	edi, eax
	jl	SHORT $LL16@trim_compr
	mov	ecx, DWORD PTR _precinct$1$[ebp]
	mov	edx, DWORD PTR _b$1$[ebp]
	mov	ebx, DWORD PTR tv301[ebp]
$LN11@trim_compr:

; 5219 :         for (int b=0; b < precinct->resolution->num_subbands; b++)

	mov	eax, DWORD PTR [ecx]
	inc	edx
	add	ebx, 24					; 00000018H
	mov	DWORD PTR _b$1$[ebp], edx
	mov	DWORD PTR tv301[ebp], ebx
	movzx	eax, BYTE PTR [eax+174]
	cmp	edx, eax
	jl	SHORT $LL13@trim_compr
$LN8@trim_compr:

; 5218 :       for (precinct=rc->first_ready; precinct!=NULL; precinct=precinct->next)

	mov	ecx, DWORD PTR [ecx+44]
	mov	DWORD PTR _precinct$1$[ebp], ecx
	test	ecx, ecx
	jne	SHORT $LL10@trim_compr
	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	edx, DWORD PTR _rc$1$[ebp]
	mov	eax, DWORD PTR _c$1$[ebp]
$LN5@trim_compr:

; 5217 :     for (int c=0; c < num_components; c++, rc++)

	inc	eax
	add	edx, 80					; 00000050H
	mov	DWORD PTR _c$1$[ebp], eax
	mov	DWORD PTR _rc$1$[ebp], edx
	cmp	eax, DWORD PTR [ebx+112]
	jl	$LL7@trim_compr
	mov	esi, DWORD PTR _d$1$[ebp]
$LN2@trim_compr:

; 5215 :   kd_precinct *precinct;
; 5216 :   for (int d=32; d >= 0; d--, rc-=(num_components<<1))

	mov	ecx, DWORD PTR [ebx+112]
	dec	esi
	imul	eax, ecx, -160
	mov	DWORD PTR _d$1$[ebp], esi
	add	edx, eax
	mov	DWORD PTR _rc$1$[ebp], edx
	test	esi, esi
	jns	$LL4@trim_compr
	pop	edi
	pop	esi
$LN3@trim_compr:
	pop	ebx

; 5226 :               }
; 5227 :           }
; 5228 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?trim_compressed_data@kd_codestream@@QAEXXZ ENDP	; kd_codestream::trim_compressed_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z
_TEXT	SEGMENT
$T2 = -52						; size = 16
_tile_dims$ = -36					; size = 16
$T3 = -20						; size = 4
_tref$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_idx$ = 8						; size = 8
?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z PROC ; kd_codestream::create_tile, COMDAT
; _this$ = ecx

; 5162 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	eax, DWORD PTR _idx$[ebp]
	sub	eax, DWORD PTR [ebx+172]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5166 :   kd_tile_ref *tref = tile_refs + rel_idx.x + rel_idx.y*tile_indices.size.x;

	mov	ecx, DWORD PTR [ebx+184]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	edx, DWORD PTR _idx$[ebp+4]
	sub	edx, DWORD PTR [ebx+176]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5170 :   kdu_dims tile_dims = tile_partition; // `tile_partition' is not affected by

	movups	xmm1, XMMWORD PTR [ebx+148]
	imul	ecx, eax
	mov	eax, DWORD PTR [ebx+264]

; 5171 :                                        // fragment regions
; 5172 :   tile_dims.pos.x += idx.x*tile_dims.size.x;

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	movups	XMMWORD PTR _tile_dims$[ebp], xmm1
	add	ecx, edx
	psrldq	xmm1, 4
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [eax+ecx*4]
	movd	ecx, xmm0
	mov	DWORD PTR _tref$1$[ebp], eax
	movd	eax, xmm1
	imul	ecx, DWORD PTR _idx$[ebp+4]
	add	eax, ecx

; 5173 :   tile_dims.pos.y += idx.y*tile_dims.size.y;
; 5174 : 
; 5175 :   tile_dims &= canvas;

	lea	ecx, DWORD PTR _tile_dims$[ebp]
	mov	DWORD PTR _tile_dims$[ebp+4], eax
	mov	eax, DWORD PTR _tile_dims$[ebp+8]
	imul	eax, DWORD PTR _idx$[ebp]
	add	DWORD PTR _tile_dims$[ebp], eax
	lea	eax, DWORD PTR [ebx+132]
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=

; 5176 :   assert(!tile_dims.is_empty());
; 5177 :   if ((in != NULL) && (!persistent) && (!allow_restart) &&

	cmp	DWORD PTR [ebx+4], 0
	je	SHORT $LN2@create_til
	cmp	BYTE PTR [ebx+337], 0
	jne	SHORT $LN2@create_til
	cmp	BYTE PTR [ebx+328], 0
	jne	SHORT $LN2@create_til
	lea	eax, DWORD PTR [ebx+208]
	push	eax
	lea	ecx, DWORD PTR _tile_dims$[ebp]
	call	?intersects@kdu_dims@@QAE_NAAU1@@Z	; kdu_dims::intersects
	test	al, al
	jne	SHORT $LN2@create_til

; 5178 :       !tile_dims.intersects(region))
; 5179 :     { // Don't even bother creating the tile; it will never be accessed.  Just
; 5180 :       // mark it as expired and return.
; 5181 :       return (tref->tile = KD_EXPIRED_TILE);

	mov	esi, DWORD PTR _tref$1$[ebp]
	or	eax, -1
	mov	DWORD PTR [esi+8], -1

; 5198 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@create_til:

; 5182 :     }
; 5183 : 
; 5184 :   if (typical_tile_cache != NULL)

	mov	ecx, DWORD PTR [ebx+412]
	test	ecx, ecx
	je	SHORT $LN3@create_til

; 5185 :     { // Try re-using an element from the typical tile cache
; 5186 :       tp = tref->tile = typical_tile_cache;
; 5187 :       typical_tile_cache = tp->typical_next;
; 5188 :       tp->recycle(tref,idx,tile_dims);

	mov	esi, DWORD PTR _tref$1$[ebp]
	sub	esp, 16					; 00000010H
	movups	xmm0, XMMWORD PTR _tile_dims$[ebp]
	mov	DWORD PTR [esi+8], ecx
	mov	eax, DWORD PTR [ecx+40]
	mov	DWORD PTR [ebx+412], eax
	mov	eax, esp
	push	DWORD PTR _idx$[ebp+4]
	push	DWORD PTR _idx$[ebp]
	movups	XMMWORD PTR [eax], xmm0
	push	esi
	call	?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z ; kd_tile::recycle

; 5189 :                     // Similar to `kd_tile::initialize', but tries to
; 5190 :                     // reuse the tile's data structures
; 5191 :     }
; 5192 :   else

	jmp	SHORT $LN4@create_til
$LN3@create_til:

; 5193 :     {
; 5194 :       tp = tref->tile = new kd_tile(this,tref,idx,tile_dims);

	push	272					; 00000110H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	esi, DWORD PTR _tref$1$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN6@create_til
	movups	xmm0, XMMWORD PTR _tile_dims$[ebp]
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	push	DWORD PTR _idx$[ebp+4]
	movups	XMMWORD PTR [ecx], xmm0
	mov	ecx, eax
	push	DWORD PTR _idx$[ebp]
	push	esi
	push	ebx
	call	??0kd_tile@@QAE@PAUkd_codestream@@PAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z ; kd_tile::kd_tile
	jmp	SHORT $LN7@create_til
$LN6@create_til:
	xor	eax, eax
$LN7@create_til:

; 5195 :       tp->initialize();

	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+8], eax
	call	?initialize@kd_tile@@QAEXXZ		; kd_tile::initialize
$LN4@create_til:

; 5196 :     }
; 5197 :   return tref->tile;

	mov	eax, DWORD PTR [esi+8]

; 5198 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z$0:
	push	272					; 00000110H
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z ENDP ; kd_codestream::create_tile
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?restart@kd_codestream@@QAEXXZ
_TEXT	SEGMENT
_e$2 = -36						; size = 20
_idx$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?restart@kd_codestream@@QAEXXZ PROC			; kd_codestream::restart, COMDAT
; _this$ = ecx

; 4795 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?restart@kd_codestream@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 4796 :   // Remove some uncommon services; this may cost us nothing in efficiency
; 4797 :   if (ppm_markers != NULL)

	mov	edi, DWORD PTR [esi+20]
	test	edi, edi
	je	SHORT $LN34@restart
	mov	ecx, edi
	call	??1kd_pp_markers@@QAE@XZ		; kd_pp_markers::~kd_pp_markers
	push	8
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN34@restart:

; 4798 :     delete ppm_markers;
; 4799 :   ppm_markers = NULL;
; 4800 :   if (tpart_ptr_server != NULL)

	mov	edi, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+20], 0
	test	edi, edi
	je	SHORT $LN38@restart
	mov	ecx, edi
	call	??1kd_tpart_pointer_server@@QAE@XZ	; kd_tpart_pointer_server::~kd_tpart_pointer_server
	push	16					; 00000010H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN38@restart:

; 4801 :     delete tpart_ptr_server;
; 4802 :   tpart_ptr_server = NULL;
; 4803 :   if (stats != NULL)

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+36], 0
	test	eax, eax
	je	SHORT $LN14@restart

; 4804 :     delete stats;

	push	32832					; 00008040H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN14@restart:

; 4805 :   stats = NULL;

	mov	DWORD PTR [esi+32], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1016 :         if (elts != NULL)

	mov	eax, DWORD PTR [esi+88]
	mov	DWORD PTR [esi+68], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+80], 0
	mov	DWORD PTR [esi+84], 0
	test	eax, eax
	je	SHORT $LN42@restart

; 1017 :           { delete[] elts; elts = NULL; }

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+88], 0
$LN42@restart:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4811 :   if (layer_sizes != NULL)

	mov	eax, DWORD PTR [esi+288]
	mov	BYTE PTR [esi+341], 0
	mov	DWORD PTR [esi+312], 0
	mov	DWORD PTR [esi+316], 0
	mov	DWORD PTR [esi+304], 0
	mov	DWORD PTR [esi+308], 0
	test	eax, eax
	je	SHORT $LN15@restart

; 4812 :     delete[] layer_sizes;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN15@restart:

; 4813 :   if (layer_targets != NULL)

	mov	eax, DWORD PTR [esi+292]
	test	eax, eax
	je	SHORT $LN16@restart

; 4814 :     delete[] layer_targets;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN16@restart:

; 4815 :   if (layer_thresholds != NULL)

	mov	eax, DWORD PTR [esi+296]
	test	eax, eax
	je	SHORT $LN17@restart

; 4816 :     delete[] layer_thresholds;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN17@restart:

; 4817 :   layer_sizes = layer_targets = NULL;
; 4818 :   layer_thresholds = NULL;
; 4819 :   num_sized_layers = 0;
; 4820 : 
; 4821 :   // Delete the output component info array
; 4822 :   if (output_comp_info != NULL)

	mov	eax, DWORD PTR [esi+260]
	mov	DWORD PTR [esi+292], 0
	mov	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+296], 0
	mov	DWORD PTR [esi+284], 0
	test	eax, eax
	je	SHORT $LN18@restart

; 4823 :     delete[] output_comp_info;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN18@restart:

; 4824 :   output_comp_info = NULL;
; 4825 :   num_output_components = num_apparent_output_components = 0;
; 4826 : 
; 4827 :   // Restart all existing tiles.
; 4828 :   assert(tile_refs != NULL);
; 4829 :   kdu_coords idx;
; 4830 :   kd_tile_ref *tref = tile_refs;

	mov	edi, DWORD PTR [esi+264]

; 4831 :   for (idx.y=0; idx.y < tile_indices.size.y; idx.y++)

	xor	eax, eax
	mov	DWORD PTR [esi+260], 0
	mov	DWORD PTR [esi+124], 0
	mov	DWORD PTR [esi+120], 0
	mov	DWORD PTR _idx$1$[ebp], eax
	cmp	DWORD PTR [esi+180], eax
	jle	$LN62@restart
$LL4@restart:

; 4832 :     for (idx.x=0; idx.x < tile_indices.size.x; idx.x++, tref++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+184], ebx
	jle	SHORT $LN2@restart
	npad	4
$LL7@restart:

; 4833 :       {
; 4834 :         tref->tpart_head = tref->tpart_tail = NULL;
; 4835 :         if (tref->tile == NULL)

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi], 0
	test	eax, eax
	je	SHORT $LN5@restart

; 4836 :           continue;
; 4837 :         assert(tref->tile != KD_EXPIRED_TILE);
; 4838 :           // In restart mode, no tiles should be allowed to expire
; 4839 :         if (tref->tile->is_open)

	cmp	BYTE PTR [eax+229], 0
	je	SHORT $LN20@restart

; 4840 :           { KDU_ERROR_DEV(e,34); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0FC@DHCIJBNO@You?5must?5close?5all?5open?5tile?5int@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4840 :           { KDU_ERROR_DEV(e,34); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4843 :           }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN20@restart:

; 4844 :         tref->tile->restart();

	mov	ecx, DWORD PTR [edi+8]
	call	?restart@kd_tile@@QAEXXZ		; kd_tile::restart
$LN5@restart:

; 4832 :     for (idx.x=0; idx.x < tile_indices.size.x; idx.x++, tref++)

	inc	ebx
	add	edi, 12					; 0000000cH
	cmp	ebx, DWORD PTR [esi+184]
	jl	SHORT $LL7@restart
	mov	eax, DWORD PTR _idx$1$[ebp]
$LN2@restart:

; 4831 :   for (idx.y=0; idx.y < tile_indices.size.y; idx.y++)

	inc	eax
	mov	DWORD PTR _idx$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+180]
	jl	SHORT $LL4@restart
$LN62@restart:

; 4845 :       }
; 4846 : 
; 4847 :   // Delete all previously released typical tiles
; 4848 :   kd_tile *typ;
; 4849 :   while ((typ=typical_tile_cache) != NULL)

	mov	edi, DWORD PTR [esi+412]
	test	edi, edi
	je	SHORT $LN63@restart
	npad	5
$LL8@restart:

; 4850 :     {
; 4851 :       typical_tile_cache = typ->typical_next;

	mov	eax, DWORD PTR [edi+40]
	mov	ecx, edi
	mov	DWORD PTR [esi+412], eax
	call	??1kd_tile@@QAE@XZ			; kd_tile::~kd_tile
	push	272					; 00000110H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	mov	edi, DWORD PTR [esi+412]
	add	esp, 8
	test	edi, edi
	jne	SHORT $LL8@restart
$LN63@restart:

; 4857 :   while ((comtail=comhead) != NULL)

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+48], eax
	test	eax, eax
	je	SHORT $LN11@restart
$LL10@restart:

; 4858 :     {
; 4859 :       comhead = comtail->next;

	mov	edi, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+44], eax

; 4860 :       delete comtail;

	test	edi, edi
	je	SHORT $LN53@restart
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1469 :       { if (text_buf != NULL) delete[] text_buf; }

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN57@restart
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN57@restart:
	push	20					; 00000014H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN53@restart:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4857 :   while ((comtail=comhead) != NULL)

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+48], eax
	test	eax, eax
	jne	SHORT $LL10@restart
$LN11@restart:

; 4861 :     }
; 4862 :   comments_frozen = false;
; 4863 :   header_generated = false;
; 4864 :   header_length = 0;
; 4865 :   siz->clear_marks();

	mov	ecx, DWORD PTR [esi+12]
	mov	WORD PTR [esi+342], 0
	mov	DWORD PTR [esi+352], 0
	mov	DWORD PTR [esi+356], 0
	call	?clear_marks@kdu_params@@QAEXXZ		; kdu_params::clear_marks

; 4866 :   if (in != NULL)

	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN21@restart

; 4867 :     read_main_header();

	mov	ecx, esi
	call	?read_main_header@kd_codestream@@AAEXXZ	; kd_codestream::read_main_header
$LN21@restart:

; 4868 :   if (output_comp_info == NULL)

	cmp	DWORD PTR [esi+260], 0
	jne	SHORT $LN22@restart

; 4869 :     construct_output_comp_info();

	mov	ecx, esi
	call	?construct_output_comp_info@kd_codestream@@QAEXXZ ; kd_codestream::construct_output_comp_info
$LN22@restart:

; 4870 :   tiles_accessed = false;

	mov	BYTE PTR [esi+340], 0

; 4871 :   active_tile = NULL;

	mov	DWORD PTR [esi+364], 0

; 4872 :   next_sot_address = 0;

	mov	DWORD PTR [esi+368], 0
	mov	DWORD PTR [esi+372], 0

; 4873 :   next_tnum = 0;

	mov	DWORD PTR [esi+376], 0

; 4874 :   num_completed_tparts = 0;

	mov	DWORD PTR [esi+380], 0

; 4875 :   num_open_tiles = 0;

	mov	DWORD PTR [esi+204], 0

; 4876 :   textualize_out = NULL;

	mov	DWORD PTR [esi], 0

; 4877 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?restart@kd_codestream@@QAEXXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?restart@kd_codestream@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?restart@kd_codestream@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?restart@kd_codestream@@QAEXXZ ENDP			; kd_codestream::restart
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z
_TEXT	SEGMENT
_e$2 = -76						; size = 20
_this$1$ = -56						; size = 4
_e$3 = -52						; size = 20
_e$4 = -52						; size = 20
$T5 = -48						; size = 16
tv326 = -40						; size = 8
_current_fragment_tiles$1$ = -36			; size = 4
_lim$2$ = -36						; size = 4
_lim$1$ = -32						; size = 4
_min$2$ = -28						; size = 4
_tsize$2$ = -24						; size = 4
_idx_min$1$ = -20					; size = 4
_idx_min$2$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fragment_region$ = 8					; size = 16
_fragment_tiles_generated$ = 24				; size = 4
_fragment_tile_bytes_generated$ = 28			; size = 8
_num_indices$1$ = 32					; size = 4
_tsize$1$ = 32						; size = 4
?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z PROC ; kd_codestream::restrict_to_fragment, COMDAT
; _this$ = ecx

; 4728 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi

; 4729 :   assert(out != NULL);
; 4730 :   fragment_region &= canvas;

	lea	eax, DWORD PTR [esi+132]
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	ecx, DWORD PTR _fragment_region$[ebp]
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	edi, DWORD PTR _fragment_region$[ebp+12]
	mov	eax, edi
	mov	ebx, DWORD PTR _fragment_region$[ebp+8]
	imul	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4731 :   fragment_area_fraction =

	mov	ecx, eax
	call	__ltod3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [esi+144]
	imul	DWORD PTR [esi+140]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4731 :   fragment_area_fraction =

	movsd	QWORD PTR tv326[ebp], xmm0
	mov	ecx, eax
	call	__ltod3
	movsd	xmm1, QWORD PTR tv326[ebp]
	divsd	xmm1, xmm0

; 4732 :     ((double) fragment_region.area()) / ((double) canvas.area());
; 4733 :   this->prev_tiles_written = fragment_tiles_generated;

	mov	eax, DWORD PTR _fragment_tiles_generated$[ebp]
	mov	DWORD PTR [esi+240], eax

; 4734 :   this->prev_tile_bytes_written = fragment_tile_bytes_generated;

	mov	eax, DWORD PTR _fragment_tile_bytes_generated$[ebp]
	mov	DWORD PTR [esi+248], eax
	mov	eax, DWORD PTR _fragment_tile_bytes_generated$[ebp+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	ecx, DWORD PTR _fragment_region$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4734 :   this->prev_tile_bytes_written = fragment_tile_bytes_generated;

	mov	DWORD PTR [esi+252], eax

; 4735 : 
; 4736 :   kdu_coords tsize = tile_partition.size;

	mov	eax, DWORD PTR [esi+156]
	mov	DWORD PTR _tsize$2$[ebp], eax
	mov	eax, DWORD PTR [esi+160]
	mov	DWORD PTR _tsize$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	eax, DWORD PTR _this$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4731 :   fragment_area_fraction =

	movsd	QWORD PTR [esi+232], xmm1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ecx, DWORD PTR [eax+148]
	mov	esi, DWORD PTR _fragment_region$[ebp+4]
	sub	esi, DWORD PTR [eax+152]
	mov	DWORD PTR _min$2$[ebp], ecx

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR _lim$1$[ebp], eax
	lea	eax, DWORD PTR [ebx+ecx]
	mov	DWORD PTR _lim$2$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4740 :   idx_min.x = min.x / tsize.x;

	mov	eax, esi
	cdq
	idiv	DWORD PTR _tsize$1$[ebp]
	mov	ecx, eax

; 4741 :   idx_min.y = min.y / tsize.y;

	mov	eax, DWORD PTR _min$2$[ebp]
	cdq
	idiv	DWORD PTR _tsize$2$[ebp]
	mov	DWORD PTR _idx_min$1$[ebp], ecx
	mov	DWORD PTR _idx_min$2$[ebp], eax

; 4742 :   idx_lim.x = lim.x / tsize.x;

	mov	eax, DWORD PTR _lim$1$[ebp]
	cdq
	idiv	DWORD PTR _tsize$1$[ebp]

; 4743 :   idx_lim.y = lim.y / tsize.y;
; 4744 :   if ((min.x != idx_min.x*tsize.x) || (min.y != idx_min.y*tsize.y) ||
; 4745 :       (lim.x != idx_lim.x*tsize.x) || (lim.y != idx_lim.y*tsize.y))

	imul	ecx, DWORD PTR _tsize$1$[ebp]
	mov	ebx, eax
	mov	eax, DWORD PTR _lim$2$[ebp]
	cdq
	idiv	DWORD PTR _tsize$2$[ebp]
	cmp	esi, ecx
	mov	esi, DWORD PTR _idx_min$2$[ebp]
	mov	edi, eax
	jne	SHORT $LN3@restrict_t
	mov	edx, DWORD PTR _tsize$2$[ebp]
	mov	ecx, esi
	imul	ecx, edx
	cmp	DWORD PTR _min$2$[ebp], ecx
	jne	SHORT $LN3@restrict_t
	mov	eax, ebx
	imul	eax, DWORD PTR _tsize$1$[ebp]
	cmp	DWORD PTR _lim$1$[ebp], eax
	jne	SHORT $LN3@restrict_t
	mov	eax, edi
	imul	eax, edx
	cmp	DWORD PTR _lim$2$[ebp], eax
	je	SHORT $LN2@restrict_t
$LN3@restrict_t:

; 4746 :     { KDU_ERROR_DEV(e,31); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0MJ@FDIMAMPF@The?5fragment?5region?5supplied?5to?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4746 :     { KDU_ERROR_DEV(e,31); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4751 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@restrict_t:

; 4752 :   if ((idx_lim.x <= idx_min.x) || (idx_lim.y <= idx_min.y))

	mov	eax, DWORD PTR _idx_min$1$[ebp]
	cmp	ebx, eax
	jle	SHORT $LN5@restrict_t
	cmp	edi, esi
	jg	SHORT $LN4@restrict_t
$LN5@restrict_t:

; 4753 :     { KDU_ERROR_DEV(e,32); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0ED@OJAJOCED@The?5fragment?5region?5supplied?5to?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4753 :     { KDU_ERROR_DEV(e,32); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4756 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _idx_min$1$[ebp]
$LN4@restrict_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ebx, eax
	sub	edi, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4759 :   int current_fragment_tiles = num_indices.x*num_indices.y;

	mov	eax, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	DWORD PTR _num_indices$1$[ebp], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4759 :   int current_fragment_tiles = num_indices.x*num_indices.y;

	imul	eax, ebx

; 4760 :   assert(current_fragment_tiles > 0);
; 4761 :   int future_fragment_tiles = tile_span.x*tile_span.y -

	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	esi, DWORD PTR [ebx+168]
	imul	esi, DWORD PTR [ebx+164]
	mov	DWORD PTR _current_fragment_tiles$1$[ebp], eax
	sub	esi, eax
	mov	eax, DWORD PTR _fragment_tiles_generated$[ebp]
	sub	esi, eax

; 4762 :     (current_fragment_tiles + fragment_tiles_generated);
; 4763 :   if (future_fragment_tiles < 0)

	jns	SHORT $LN6@restrict_t

; 4764 :     { KDU_ERROR_DEV(e,33); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0KD@BEOENLDH@The?5fragment?5region?5supplied?5to?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4764 :     { KDU_ERROR_DEV(e,33); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4768 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	eax, DWORD PTR _fragment_tiles_generated$[ebp]
$LN6@restrict_t:

; 4770 :   initial_fragment = (fragment_tiles_generated == 0);

	test	eax, eax
	sete	al

; 4771 :   final_fragment = (future_fragment_tiles == 0);

	test	esi, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 251  :       { return (x==rhs.x) && (y==rhs.y); }

	mov	esi, DWORD PTR _num_indices$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4770 :   initial_fragment = (fragment_tiles_generated == 0);

	mov	BYTE PTR [ebx+225], al

; 4771 :   final_fragment = (future_fragment_tiles == 0);

	sete	al
	mov	BYTE PTR [ebx+226], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 251  :       { return (x==rhs.x) && (y==rhs.y); }

	cmp	esi, DWORD PTR [ebx+184]
	jne	SHORT $LN41@restrict_t
	cmp	edi, DWORD PTR [ebx+180]
	je	SHORT $LN8@restrict_t
$LN41@restrict_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4778 :       delete[] tile_refs;

	push	DWORD PTR [ebx+264]
	call	??_V@YAXPAX@Z				; operator delete[]

; 4779 :       tile_refs = NULL;
; 4780 :       tile_indices.pos = idx_min;

	mov	eax, DWORD PTR _idx_min$2$[ebp]

; 4781 :       tile_indices.size = num_indices;
; 4782 :       canvas = fragment_region;
; 4783 :       region = canvas;
; 4784 :       tile_refs = new kd_tile_ref[current_fragment_tiles];

	xor	ecx, ecx
	movups	xmm0, XMMWORD PTR _fragment_region$[ebp]
	mov	DWORD PTR [ebx+172], eax
	mov	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _idx_min$1$[ebp]
	mov	DWORD PTR [ebx+176], eax
	mov	DWORD PTR [ebx+184], esi
	mov	esi, DWORD PTR _current_fragment_tiles$1$[ebp]
	mov	eax, esi
	mul	edx
	movups	XMMWORD PTR [ebx+132], xmm0
	movups	XMMWORD PTR [ebx+208], xmm0
	mov	DWORD PTR [ebx+264], 0
	mov	DWORD PTR [ebx+180], edi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 4785 :       memset(tile_refs,0,(size_t) current_fragment_tiles*sizeof(kd_tile_ref));

	lea	ecx, DWORD PTR [esi+esi*2]
	mov	DWORD PTR [ebx+264], eax
	shl	ecx, 2
	push	ecx
	push	0
	push	eax
	call	_memset
	add	esp, 20					; 00000014H
$LN8@restrict_t:

; 4786 :     }
; 4787 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z$1:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z ENDP ; kd_codestream::restrict_to_fragment
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?finalize_construction@kd_codestream@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -36						; size = 4
$T2 = -36						; size = 4
$T3 = -36						; size = 4
_coc$1$ = -32						; size = 4
$T4 = -32						; size = 4
$T5 = -32						; size = 4
_cod$1$ = -28						; size = 4
tv664 = -24						; size = 4
_crg$1$ = -20						; size = 4
_decomp$6 = -20						; size = 4
tv669 = -16						; size = 4
_d$1$ = -16						; size = 4
_n$2$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?finalize_construction@kd_codestream@@QAEXXZ PROC	; kd_codestream::finalize_construction, COMDAT
; _this$ = ecx

; 4641 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?finalize_construction@kd_codestream@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 4642 :   if (output_comp_info == NULL)

	cmp	DWORD PTR [edi+260], 0
	jne	SHORT $LN23@finalize_c

; 4643 :     construct_output_comp_info();

	call	?construct_output_comp_info@kd_codestream@@QAEXXZ ; kd_codestream::construct_output_comp_info
$LN23@finalize_c:

; 4644 :   if (construction_finalized)

	cmp	BYTE PTR [edi+341], 0
	jne	$LN21@finalize_c

; 4647 : 
; 4648 :   int n, c, d;
; 4649 : 
; 4650 :   // Obtain codestream registration information, if any
; 4651 :   kdu_params *crg = siz->access_cluster(CRG_params);

	mov	ecx, DWORD PTR [edi+12]
	push	OFFSET ??_C@_03IHBKPECM@CRG?$AA@
	mov	BYTE PTR [edi+341], 1
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 4652 :   for (n=0; n < num_components; n++)

	xor	ebx, ebx
	mov	ecx, eax
	mov	DWORD PTR _crg$1$[ebp], ecx
	cmp	DWORD PTR [edi+112], ebx
	jle	SHORT $LN3@finalize_c

; 4645 :     return;
; 4646 :   construction_finalized = true;

	xor	eax, eax
	mov	DWORD PTR tv669[ebp], eax
	npad	3
$LL4@finalize_c:

; 4653 :     {
; 4654 :       kd_comp_info *ci = comp_info + n;

	mov	esi, DWORD PTR [edi+256]
	add	esi, eax

; 4655 :       if ((crg == NULL) ||
; 4656 :           (!crg->get(CRGoffset,n,0,ci->crg_y)) ||

	test	ecx, ecx
	je	SHORT $LN26@finalize_c
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR [esi+12]
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN70@finalize_c
	mov	ecx, DWORD PTR _crg$1$[ebp]
	lea	eax, DWORD PTR [esi+8]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	ebx
	push	OFFSET ??_C@_09NPOAGBMD@CRGoffset?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	mov	eax, DWORD PTR tv669[ebp]
	jne	SHORT $LN2@finalize_c
	jmp	SHORT $LN26@finalize_c
$LN70@finalize_c:
	mov	eax, DWORD PTR tv669[ebp]
$LN26@finalize_c:

; 4657 :           (!crg->get(CRGoffset,n,1,ci->crg_x)))
; 4658 :         ci->crg_x = ci->crg_y = 0.0F;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+8], 0
$LN2@finalize_c:

; 4652 :   for (n=0; n < num_components; n++)

	mov	ecx, DWORD PTR _crg$1$[ebp]
	inc	ebx
	add	eax, 96					; 00000060H
	mov	DWORD PTR tv669[ebp], eax
	cmp	ebx, DWORD PTR [edi+112]
	jl	SHORT $LL4@finalize_c
$LN3@finalize_c:

; 4659 :     }
; 4660 : 
; 4661 :   // Obtain the downsampling factor structure
; 4662 :   kdu_params *cod = siz->access_cluster(COD_params);

	mov	ecx, DWORD PTR [edi+12]
	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	mov	edx, eax

; 4663 :   for (n=0; n < num_components; n++)

	xor	eax, eax
	mov	DWORD PTR _cod$1$[ebp], edx
	mov	DWORD PTR _n$2$[ebp], eax
	cmp	DWORD PTR [edi+112], eax
	jle	$LN6@finalize_c

; 4659 :     }
; 4660 : 
; 4661 :   // Obtain the downsampling factor structure
; 4662 :   kdu_params *cod = siz->access_cluster(COD_params);

	xor	ecx, ecx
	mov	DWORD PTR tv664[ebp], ecx
	npad	1
$LL7@finalize_c:

; 4664 :     {
; 4665 :       kd_comp_info *ci = comp_info + n;

	mov	esi, DWORD PTR [edi+256]

; 4666 :       kdu_params *coc = cod->access_relation(-1,n,0,true);

	push	1
	push	0
	push	eax
	add	esi, ecx
	mov	ecx, edx
	push	-1
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	edi, -21				; ffffffebH
	lea	ebx, DWORD PTR [esi+21]
	mov	ecx, eax
	sub	edi, esi
	mov	DWORD PTR _coc$1$[ebp], ecx
	mov	esi, 32					; 00000020H
	npad	6
$LL10@finalize_c:

; 4667 :       for (d=1; d < 33; d++)
; 4668 :         {
; 4669 :           int decomp=3;
; 4670 :           coc->get(Cdecomp,d-1,0,decomp);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _decomp$6[ebp]
	mov	DWORD PTR _decomp$6[ebp], 3
	push	eax
	push	0
	lea	eax, DWORD PTR [edi+ebx]
	push	eax
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 4671 :           ci->hor_depth[d] = ci->hor_depth[d-1] + (decomp & 1);

	mov	ecx, DWORD PTR _decomp$6[ebp]
	lea	ebx, DWORD PTR [ebx+1]
	mov	al, cl

; 4672 :           ci->vert_depth[d] = ci->vert_depth[d-1] + ((decomp >> 1) & 1);

	sar	ecx, 1
	and	cl, 1
	and	al, 1
	add	cl, BYTE PTR [ebx+32]
	add	al, BYTE PTR [ebx-1]
	mov	BYTE PTR [ebx+33], cl
	mov	ecx, DWORD PTR _coc$1$[ebp]
	mov	BYTE PTR [ebx], al
	sub	esi, 1
	jne	SHORT $LL10@finalize_c

; 4663 :   for (n=0; n < num_components; n++)

	mov	eax, DWORD PTR _n$2$[ebp]
	mov	edi, DWORD PTR _this$1$[ebp]
	inc	eax
	mov	ecx, DWORD PTR tv664[ebp]
	mov	edx, DWORD PTR _cod$1$[ebp]
	add	ecx, 96					; 00000060H
	mov	DWORD PTR _n$2$[ebp], eax
	mov	DWORD PTR tv664[ebp], ecx
	cmp	eax, DWORD PTR [edi+112]
	jl	$LL7@finalize_c
$LN6@finalize_c:

; 4673 :         }
; 4674 :     }
; 4675 :   
; 4676 :   // Configure the resolution-component progress status management system
; 4677 :   if (out != NULL)

	cmp	DWORD PTR [edi+8], 0
	je	$LN18@finalize_c

; 4678 :     {
; 4679 :       kd_global_rescomp *rc = global_rescomps;

	mov	ebx, DWORD PTR [edi+276]

; 4680 :       if (rc == NULL)

	test	ebx, ebx
	jne	SHORT $LN28@finalize_c

; 4681 :         rc = global_rescomps =

	mov	esi, DWORD PTR [edi+112]
	xor	ecx, ecx
	shl	esi, 5
	mov	edx, 80					; 00000050H
	add	esi, DWORD PTR [edi+112]
	mov	eax, esi
	mov	DWORD PTR $T3[ebp], esi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	test	eax, eax
	je	SHORT $LN35@finalize_c
	push	OFFSET ??1kd_global_rescomp@@QAE@XZ	; kd_global_rescomp::~kd_global_rescomp
	push	OFFSET ??0kd_global_rescomp@@QAE@XZ	; kd_global_rescomp::kd_global_rescomp
	push	esi
	lea	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], esi
	push	80					; 00000050H
	push	ebx
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	jmp	SHORT $LN36@finalize_c
$LN35@finalize_c:
	xor	ebx, ebx
$LN36@finalize_c:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [edi+276], ebx
$LN28@finalize_c:

; 4682 :           new kd_global_rescomp[33*num_components];
; 4683 :       for (d=0; d < 33; d++)

	xor	eax, eax
	mov	DWORD PTR _d$1$[ebp], eax
$LL13@finalize_c:

; 4684 :         for (c=0; c < num_components; c++, rc++)

	xor	esi, esi
	cmp	DWORD PTR [edi+112], esi
	jle	SHORT $LN11@finalize_c
$LL16@finalize_c:

; 4685 :           rc->initialize(this,d,c);

	push	esi
	push	eax
	push	edi
	mov	ecx, ebx
	call	?initialize@kd_global_rescomp@@QAEXPAUkd_codestream@@HH@Z ; kd_global_rescomp::initialize
	mov	eax, DWORD PTR _d$1$[ebp]
	inc	esi
	add	ebx, 80					; 00000050H
	cmp	esi, DWORD PTR [edi+112]
	jl	SHORT $LL16@finalize_c
$LN11@finalize_c:

; 4682 :           new kd_global_rescomp[33*num_components];
; 4683 :       for (d=0; d < 33; d++)

	inc	eax
	mov	DWORD PTR _d$1$[ebp], eax
	cmp	eax, 33					; 00000021H
	jl	SHORT $LL13@finalize_c

; 4686 :     }
; 4687 :   
; 4688 :   // Configure the codestream-level reslength information
; 4689 :   if (out != NULL)

	cmp	DWORD PTR [edi+8], 0
	je	$LN18@finalize_c

; 4690 :     {
; 4691 :       reslength_constraints_used = reslength_constraints_violated = false;
; 4692 :       if (reslength_checkers == NULL)

	cmp	DWORD PTR [edi+324], 0
	mov	WORD PTR [edi+320], 0
	jne	SHORT $LN30@finalize_c

; 4693 :         reslength_checkers = new kd_reslength_checker[1+num_components];

	mov	esi, DWORD PTR [edi+112]
	xor	ecx, ecx
	inc	esi
	mov	edx, 808				; 00000328H
	mov	eax, esi
	mov	DWORD PTR $T2[ebp], esi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN37@finalize_c
	push	OFFSET ??1kd_reslength_checker@@QAE@XZ	; kd_reslength_checker::~kd_reslength_checker
	push	OFFSET ??0kd_reslength_checker@@QAE@XZ	; kd_reslength_checker::kd_reslength_checker
	push	esi
	lea	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], esi
	push	808					; 00000328H
	push	ebx
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	jmp	SHORT $LN38@finalize_c
$LN37@finalize_c:
	xor	ebx, ebx
$LN38@finalize_c:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [edi+324], ebx
$LN30@finalize_c:

; 4694 :       for (c=-1; c < num_components; c++)

	or	esi, -1
	cmp	DWORD PTR [edi+112], esi
	jle	SHORT $LN18@finalize_c
	mov	ebx, -808				; fffffcd8H
$LL19@finalize_c:

; 4695 :         {
; 4696 :           cod_params *coc = (cod_params *) cod->access_unique(-1,c);

	mov	ecx, DWORD PTR _cod$1$[ebp]
	push	0
	push	esi
	push	-1
	call	?access_unique@kdu_params@@QAEPAV1@HHH@Z ; kdu_params::access_unique

; 4697 :           if (reslength_checkers[c+1].init(coc))

	mov	ecx, DWORD PTR [edi+324]
	add	ecx, 808				; 00000328H
	push	eax
	add	ecx, ebx
	call	?init@kd_reslength_checker@@QAE_NPAVcod_params@@@Z ; kd_reslength_checker::init
	test	al, al
	je	SHORT $LN17@finalize_c

; 4698 :             reslength_constraints_used = true;

	mov	BYTE PTR [edi+320], 1
$LN17@finalize_c:

; 4694 :       for (c=-1; c < num_components; c++)

	inc	esi
	add	ebx, 808				; 00000328H
	cmp	esi, DWORD PTR [edi+112]
	jl	SHORT $LL19@finalize_c
$LN18@finalize_c:

; 4699 :         }
; 4700 :     }
; 4701 : 
; 4702 :   if (uses_mct)

	cmp	BYTE PTR [edi+108], 0
	je	SHORT $LN21@finalize_c

; 4703 :     { // Now we have only to build an association between each MCT output
; 4704 :       // component and a corresponding codestream component, so that
; 4705 :       // applications can determine the dimensions of each output component,
; 4706 :       // right from the beginning.  We will base this on an analysis of the
; 4707 :       // main header MCC and MCO marker segments which are available -- if
; 4708 :       // there are none, our assumptions might be wrong, but the error can
; 4709 :       // be caught later on when we come to actually process each tile.
; 4710 :       kd_mct_stage::create_stages(global_mct_head,global_mct_tail,siz,-1,

	push	DWORD PTR [edi+260]
	lea	ebx, DWORD PTR [edi+100]
	push	DWORD PTR [edi+120]
	lea	eax, DWORD PTR [edi+96]
	push	DWORD PTR [edi+256]
	push	DWORD PTR [edi+112]
	push	-1
	push	DWORD PTR [edi+12]
	push	ebx
	push	eax
	call	?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z ; kd_mct_stage::create_stages
	add	esp, 32					; 00000020H

; 4711 :                                   num_components,comp_info,
; 4712 :                                   num_output_components,output_comp_info);
; 4713 :       if (global_mct_tail != NULL)

	cmp	DWORD PTR [ebx], 0
	je	SHORT $LN21@finalize_c

; 4714 :         for (n=0; n < num_output_components; n++)

	xor	esi, esi
	cmp	DWORD PTR [edi+120], esi
	jle	SHORT $LN21@finalize_c
	xor	edx, edx
	npad	5
$LL22@finalize_c:

; 4715 :           output_comp_info[n].subsampling_ref =

	mov	eax, DWORD PTR [ebx]
	lea	edx, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [edi+260]
	inc	esi
	mov	eax, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [eax+edx-32]
	mov	DWORD PTR [edx+ecx-32], eax
	cmp	esi, DWORD PTR [edi+120]
	jl	SHORT $LL22@finalize_c
$LN21@finalize_c:

; 4716 :             global_mct_tail->output_comp_info[n].subsampling_ref;
; 4717 :     }
; 4718 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?finalize_construction@kd_codestream@@QAEXXZ$0:
	xor	ebx, ebx
	mov	eax, DWORD PTR $T3[ebp]
	mov	ecx, 80					; 00000050H
	mul	ecx
	seto	bl
	neg	ebx
	or	ebx, eax
	xor	eax, eax
	add	ebx, 4
	setb	al
	neg	eax
	or	eax, ebx
	push	eax
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
__unwindfunclet$?finalize_construction@kd_codestream@@QAEXXZ$1:
	xor	ebx, ebx
	mov	eax, DWORD PTR $T2[ebp]
	mov	ecx, 808				; 00000328H
	mul	ecx
	seto	bl
	neg	ebx
	or	ebx, eax
	xor	eax, eax
	add	ebx, 4
	setb	al
	neg	eax
	or	eax, ebx
	push	eax
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
__ehhandler$?finalize_construction@kd_codestream@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?finalize_construction@kd_codestream@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?finalize_construction@kd_codestream@@QAEXXZ ENDP	; kd_codestream::finalize_construction
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?construct_output_comp_info@kd_codestream@@QAEXXZ
_TEXT	SEGMENT
_e$2 = -68						; size = 20
_e$3 = -48						; size = 20
tv559 = -28						; size = 4
$T4 = -28						; size = 4
$T5 = -28						; size = 4
_extension_flags$ = -24					; size = 4
tv560 = -20						; size = 4
_have_cbd$1$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
?construct_output_comp_info@kd_codestream@@QAEXXZ PROC	; kd_codestream::construct_output_comp_info, COMDAT
; _this$ = ecx

; 4588 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?construct_output_comp_info@kd_codestream@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 4589 :   assert(output_comp_info == NULL);
; 4590 : 
; 4591 :   int n, extension_flags = 0;
; 4592 :   siz->get(Sextensions,0,0,extension_flags);

	mov	ecx, DWORD PTR [edi+12]
	lea	eax, DWORD PTR _extension_flags$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@NJJFAENN@Sextensions?$AA@
	mov	DWORD PTR _extension_flags$[ebp], 0
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 4593 :   uses_mct = ((extension_flags & Sextensions_MCT) != 0);

	mov	eax, DWORD PTR _extension_flags$[ebp]

; 4594 :   bool have_cbd =
; 4595 :     (siz->get(Mcomponents,0,0,num_output_components) &&

	lea	ebx, DWORD PTR [edi+120]
	mov	ecx, DWORD PTR [edi+12]
	push	1
	push	1
	push	1
	push	ebx
	push	0
	shr	eax, 8
	push	0
	and	al, 1
	push	OFFSET ??_C@_0M@FAIBBHLL@Mcomponents?$AA@
	mov	BYTE PTR [edi+108], al
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN14@construct_
	cmp	DWORD PTR [ebx], 0
	jle	SHORT $LN14@construct_
	mov	al, 1
	jmp	SHORT $LN43@construct_
$LN14@construct_:
	xor	al, al
$LN43@construct_:
	mov	BYTE PTR _have_cbd$1$[ebp], al

; 4596 :      (num_output_components > 0));
; 4597 :   if (have_cbd != uses_mct)

	cmp	al, BYTE PTR [edi+108]
	je	SHORT $LN5@construct_

; 4598 :     { KDU_ERROR(e,0x04080500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0JB@BCDJMPPA@The?5?$GAMcomponents?8?5parameter?5attr@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4598 :     { KDU_ERROR(e,0x04080500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4602 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	al, BYTE PTR _have_cbd$1$[ebp]
$LN5@construct_:

; 4603 :   if (!have_cbd)

	test	al, al
	jne	SHORT $LN6@construct_

; 4604 :     num_output_components = num_components;

	mov	eax, DWORD PTR [edi+112]
	mov	DWORD PTR [ebx], eax
	jmp	SHORT $LN8@construct_
$LN6@construct_:

; 4605 :   else if (num_output_components > 16384)

	cmp	DWORD PTR [ebx], 16384			; 00004000H
	jle	SHORT $LN8@construct_

; 4606 :     { KDU_ERROR(e,0x07110800); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0IA@FCOMNLBF@Number?5of?5multi?9component?5transf@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4606 :     { KDU_ERROR(e,0x07110800); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4610 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN8@construct_:

; 4611 :   num_apparent_output_components = num_output_components;

	mov	esi, DWORD PTR [ebx]

; 4612 :   output_comp_info = new kd_output_comp_info[num_output_components];

	xor	ecx, ecx
	mov	eax, esi
	mov	DWORD PTR [edi+124], esi
	mov	edx, 40					; 00000028H
	mov	DWORD PTR $T5[ebp], esi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	test	eax, eax
	je	SHORT $LN16@construct_
	test	esi, esi
	je	SHORT $LN17@construct_
	lea	ecx, DWORD PTR [eax+8]
$LL26@construct_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1826 :         precision=0; is_signed=false; subsampling_ref = NULL;

	mov	DWORD PTR [ecx-8], 0
	lea	ecx, DWORD PTR [ecx+40]
	mov	BYTE PTR [ecx-44], 0
	mov	DWORD PTR [ecx-40], 0

; 1827 :         apparent_idx=-1; from_apparent=0;

	mov	DWORD PTR [ecx-36], -1
	mov	DWORD PTR [ecx-32], 0

; 1828 :         block=NULL; block_comp_idx=0; apparent_block_comp_idx=0;

	mov	DWORD PTR [ecx-28], 0
	mov	DWORD PTR [ecx-24], 0
	mov	DWORD PTR [ecx-20], 0

; 1829 :         is_of_interest=false; ss_tmp=0.0F;

	mov	BYTE PTR [ecx-16], 0
	mov	DWORD PTR [ecx-12], 0
	sub	esi, 1
	jne	SHORT $LL26@construct_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4612 :   output_comp_info = new kd_output_comp_info[num_output_components];

	jmp	SHORT $LN17@construct_
$LN16@construct_:
	xor	eax, eax
$LN17@construct_:

; 4613 :   for (n=0; n < num_output_components; n++)

	xor	ebx, ebx
	mov	DWORD PTR [edi+260], eax
	cmp	DWORD PTR [edi+120], ebx
	jle	$LN40@construct_

; 4612 :   output_comp_info = new kd_output_comp_info[num_output_components];

	xor	ecx, ecx
	xor	eax, eax
	mov	DWORD PTR tv560[ebp], ecx
	mov	DWORD PTR tv559[ebp], eax
	npad	7
$LL4@construct_:

; 4614 :     {
; 4615 :       kd_output_comp_info *oci = output_comp_info + n;

	mov	esi, DWORD PTR [edi+260]
	add	esi, eax

; 4616 :       if (!have_cbd)

	cmp	BYTE PTR _have_cbd$1$[ebp], 0
	jne	SHORT $LN9@construct_

; 4617 :         {
; 4618 :           oci->precision = comp_info[n].precision;

	mov	eax, DWORD PTR [edi+256]
	mov	eax, DWORD PTR [ecx+eax+16]
	mov	DWORD PTR [esi], eax

; 4619 :           oci->is_signed = comp_info[n].is_signed;

	mov	eax, DWORD PTR [edi+256]
	mov	al, BYTE PTR [ecx+eax+20]
	mov	BYTE PTR [esi+4], al
	jmp	SHORT $LN12@construct_
$LN9@construct_:

; 4620 :         }
; 4621 :       else if (!(siz->get(Mprecision,n,0,oci->precision) &&

	mov	ecx, DWORD PTR [edi+12]
	push	1
	push	1
	push	1
	push	esi
	push	0
	push	ebx
	push	OFFSET ??_C@_0L@OMLPDKKH@Mprecision?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN41@construct_
	mov	ecx, DWORD PTR [edi+12]
	lea	eax, DWORD PTR [esi+4]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_07GFFIOPIL@Msigned?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
$LN41@construct_:
	mov	ecx, DWORD PTR tv560[ebp]
$LN12@construct_:

; 4622 :                  siz->get(Msigned,n,0,oci->is_signed)))
; 4623 :         assert(0); // Should have been configured during finalization.
; 4624 :       oci->subsampling_ref = comp_info + n; // May change based on MCT info

	mov	eax, DWORD PTR [edi+256]
	add	eax, ecx

; 4625 :       oci->apparent_idx = n;

	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+8], eax
	add	ecx, 96					; 00000060H
	mov	eax, DWORD PTR tv559[ebp]

; 4626 :       oci->from_apparent = n;

	mov	DWORD PTR [esi+16], ebx
	add	eax, 40					; 00000028H
	inc	ebx

; 4627 :       oci->block = NULL;

	mov	DWORD PTR [esi+20], 0

; 4628 :       oci->block_comp_idx = 0;

	mov	DWORD PTR [esi+24], 0

; 4629 :       oci->apparent_block_comp_idx = 0;

	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR tv559[ebp], eax
	mov	DWORD PTR tv560[ebp], ecx
	cmp	ebx, DWORD PTR [edi+120]
	jl	$LL4@construct_

; 4630 :     }
; 4631 : 
; 4632 :   component_access_mode = KDU_WANT_OUTPUT_COMPONENTS; // Default access mode

	mov	DWORD PTR [edi+128], 0

; 4633 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@construct_:

; 4630 :     }
; 4631 : 
; 4632 :   component_access_mode = KDU_WANT_OUTPUT_COMPONENTS; // Default access mode

	mov	DWORD PTR [edi+128], ebx

; 4633 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct_output_comp_info@kd_codestream@@QAEXXZ$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?construct_output_comp_info@kd_codestream@@QAEXXZ$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?construct_output_comp_info@kd_codestream@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?construct_output_comp_info@kd_codestream@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct_output_comp_info@kd_codestream@@QAEXXZ ENDP	; kd_codestream::construct_output_comp_info
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?construct_common@kd_codestream@@QAEXXZ
_TEXT	SEGMENT
_w$2 = -56						; size = 20
_w$3 = -36						; size = 20
_w$4 = -36						; size = 20
_w$5 = -36						; size = 20
_w$6 = -36						; size = 20
_e$7 = -36						; size = 20
_e$8 = -36						; size = 20
_e$9 = -36						; size = 20
_e$10 = -36						; size = 20
_e$11 = -36						; size = 20
_e$12 = -36						; size = 20
tv1975 = -16						; size = 4
$T13 = -16						; size = 4
$T14 = -16						; size = 4
$T15 = -16						; size = 4
$T16 = -16						; size = 4
$T17 = -16						; size = 4
$T18 = -16						; size = 4
$T19 = -16						; size = 4
$T20 = -16						; size = 4
$T21 = -16						; size = 4
$T22 = -16						; size = 4
$T23 = -16						; size = 4
$T24 = -16						; size = 4
$T25 = -16						; size = 4
$T26 = -16						; size = 4
$T27 = -16						; size = 4
$T28 = -16						; size = 4
$T29 = -16						; size = 4
$T30 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?construct_common@kd_codestream@@QAEXXZ PROC		; kd_codestream::construct_common, COMDAT
; _this$ = ecx

; 4345 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?construct_common@kd_codestream@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 4346 :   initial_fragment = final_fragment = true;
; 4347 :   construction_finalized = false;
; 4348 :   fragment_area_fraction = 1.0;
; 4349 : 
; 4350 :   // Get summary parameters from SIZ object.
; 4351 :   ((kdu_params *) siz)->finalize(out==NULL);

	mov	ecx, DWORD PTR [esi+12]
	cmp	DWORD PTR [esi+8], 0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	mov	WORD PTR [esi+225], 257			; 00000101H
	sete	al
	mov	BYTE PTR [esi+341], 0
	movsd	QWORD PTR [esi+232], xmm0
	mov	edx, DWORD PTR [ecx]
	movzx	eax, al
	push	eax
	call	DWORD PTR [edx+32]

; 4352 :   if (!(siz->get(Sprofile,0,0,profile) &&

	mov	ecx, DWORD PTR [esi+12]
	lea	ebx, DWORD PTR [esi+104]
	push	1
	push	1
	push	1
	push	ebx
	push	0
	push	0
	push	OFFSET ??_C@_08HFDHOMDN@Sprofile?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN15@construct_
	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [esi+112]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@LFKICJFJ@Scomponents?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN15@construct_
	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [esi+140]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN15@construct_
	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [esi+144]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_05HNJHHEPH@Ssize?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN15@construct_
	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [esi+132]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN15@construct_
	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [esi+136]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_07PEMLCIHF@Sorigin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN15@construct_
	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [esi+156]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN15@construct_
	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [esi+160]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_06EPMBOCAF@Stiles?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN15@construct_
	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [esi+148]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN15@construct_
	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [esi+152]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_0N@KMIIMNEN@Stile_origin?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN15@construct_:

; 4353 :         siz->get(Scomponents,0,0,num_components) &&
; 4354 :         siz->get(Ssize,0,0,canvas.size.y) && // Subtract y_pos later
; 4355 :         siz->get(Ssize,0,1,canvas.size.x) && // Subtract x_pos later
; 4356 :         siz->get(Sorigin,0,0,canvas.pos.y) &&
; 4357 :         siz->get(Sorigin,0,1,canvas.pos.x) &&
; 4358 :         siz->get(Stiles,0,0,tile_partition.size.y) &&
; 4359 :         siz->get(Stiles,0,1,tile_partition.size.x) &&
; 4360 :         siz->get(Stile_origin,0,0,tile_partition.pos.y) &&
; 4361 :         siz->get(Stile_origin,0,1,tile_partition.pos.x)))
; 4362 :     assert(0);
; 4363 :   if  (profile == 0)

	mov	eax, DWORD PTR [ebx]
	neg	eax
	sbb	eax, eax
	mov	DWORD PTR [esi+376], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	mov	eax, DWORD PTR [esi+136]
	sub	DWORD PTR [esi+144], eax
	mov	eax, DWORD PTR [esi+132]
	sub	DWORD PTR [esi+140], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4371 :       ((tile_partition.pos.x+tile_partition.size.x) <= canvas.pos.x) ||

	cmp	DWORD PTR [esi+140], 0
	jle	SHORT $LN19@construct_
	cmp	DWORD PTR [esi+144], 0
	jle	SHORT $LN19@construct_
	mov	ecx, DWORD PTR [esi+152]
	mov	edx, DWORD PTR [esi+136]
	cmp	ecx, edx
	jg	SHORT $LN19@construct_
	mov	edi, DWORD PTR [esi+148]
	mov	ebx, DWORD PTR [esi+132]
	cmp	edi, ebx
	jg	SHORT $LN19@construct_
	mov	eax, DWORD PTR [esi+160]
	add	eax, ecx
	cmp	eax, edx
	jle	SHORT $LN19@construct_
	mov	eax, DWORD PTR [esi+156]
	add	eax, edi
	cmp	eax, ebx
	jg	SHORT $LN18@construct_
$LN19@construct_:

; 4373 :     { KDU_ERROR(e,26); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$12[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_0IE@HJOAKJGP@Illegal?5canvas?5coordinates?3?5the?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4373 :     { KDU_ERROR(e,26); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4377 :     }

	lea	ecx, DWORD PTR _e$12[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN18@construct_:

; 4378 : 
; 4379 :   // Configure the codestream component structure
; 4380 :   int n;
; 4381 : 
; 4382 :   if (num_components > 16384)

	cmp	DWORD PTR [esi+112], 16384		; 00004000H
	jle	SHORT $LN20@construct_

; 4383 :     { KDU_ERROR(e,0x06110804); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$11[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_0II@BGDHKLNP@Trying?5to?5create?5a?5?$GAkdu_codestre@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4383 :     { KDU_ERROR(e,0x06110804); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4387 :     }

	lea	ecx, DWORD PTR _e$11[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN20@construct_:

; 4389 :   comp_info = new kd_comp_info[num_components];

	mov	edi, DWORD PTR [esi+112]
	xor	ecx, ecx
	mov	eax, edi
	mov	DWORD PTR $T30[ebp], edi
	mov	edx, 96					; 00000060H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T29[ebp], eax
	test	eax, eax
	je	SHORT $LN50@construct_
	mov	ecx, eax
	test	edi, edi
	je	SHORT $LN51@construct_
	npad	10
$LL119@construct_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0
	lea	ecx, DWORD PTR [ecx+96]
	mov	DWORD PTR [ecx-92], 0
	sub	edi, 1
	jne	SHORT $LL119@construct_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4389 :   comp_info = new kd_comp_info[num_components];

	jmp	SHORT $LN51@construct_
$LN50@construct_:
	xor	eax, eax
$LN51@construct_:

; 4390 :   for (n=0; n < num_components; n++)

	xor	ebx, ebx
	mov	DWORD PTR [esi+256], eax
	cmp	DWORD PTR [esi+112], ebx
	jle	$LN3@construct_

; 4389 :   comp_info = new kd_comp_info[num_components];

	xor	eax, eax
	mov	DWORD PTR tv1975[ebp], eax
	npad	1
$LL4@construct_:

; 4391 :     {
; 4392 :       kd_comp_info *ci = comp_info + n;

	mov	edi, DWORD PTR [esi+256]

; 4393 :       if (!siz->get(Sprecision,n,0,ci->precision))

	mov	ecx, DWORD PTR [esi+12]
	add	edi, eax
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR [edi+16]
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0L@BADPNFGK@Sprecision?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN21@construct_

; 4394 :         { KDU_ERROR(e,27); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$10[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0FK@PBAGHHBG@No?5information?5available?5concern@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4394 :         { KDU_ERROR(e,27); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4397 :         }

	lea	ecx, DWORD PTR _e$10[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN21@construct_:

; 4398 :       if (!siz->get(Ssigned,n,0,ci->is_signed))

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [edi+20]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_07MGJMMJC@Ssigned?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN22@construct_

; 4399 :         { KDU_ERROR(e,28); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$9[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0EO@LBIEHJAI@No?5information?5available?5regardi@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4399 :         { KDU_ERROR(e,28); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4402 :         }

	lea	ecx, DWORD PTR _e$9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN22@construct_:

; 4403 :       if (!(siz->get(Ssampling,n,0,ci->sub_sampling.y) &&

	mov	ecx, DWORD PTR [esi+12]
	push	1
	push	1
	push	1
	push	edi
	push	0
	push	ebx
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN24@construct_
	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [edi+4]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	ebx
	push	OFFSET ??_C@_09IGDOMJM@Ssampling?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN23@construct_
$LN24@construct_:

; 4405 :         { KDU_ERROR(e,29); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0EE@ECOMFEJN@No?5information?5available?5concern@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4405 :         { KDU_ERROR(e,29); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4408 :         }

	lea	ecx, DWORD PTR _e$8[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN23@construct_:

; 4409 :       ci->apparent_idx = n;

	lea	edx, DWORD PTR [edi+21]
	mov	DWORD PTR [edi+88], ebx

; 4410 :       ci->from_apparent = ci;

	mov	DWORD PTR [edi+92], edi

; 4411 :       ci->crg_x = ci->crg_y = 0.0F;
; 4412 :       for (int d=0; d <= 32; d++)

	xor	ecx, ecx
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+8], 0
	sub	edi, edx
	npad	5
$LL7@construct_:

; 4413 :         ci->hor_depth[d] = ci->vert_depth[d] = (kdu_byte) d;

	lea	eax, DWORD PTR [edx+ecx]
	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [edi+eax+54], cl
	inc	ecx
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LL7@construct_

; 4390 :   for (n=0; n < num_components; n++)

	mov	eax, DWORD PTR tv1975[ebp]
	inc	ebx
	add	eax, 96					; 00000060H
	mov	DWORD PTR tv1975[ebp], eax
	cmp	ebx, DWORD PTR [esi+112]
	jl	$LL4@construct_
$LN3@construct_:

; 4414 :            // This default initialization of the depth values may be
; 4415 :            // changed in `finalize_construction'.
; 4416 :     }
; 4417 : 
; 4418 :   // Configure tiles
; 4419 :   tiles_in_progress_head = tiles_in_progress_tail = NULL;
; 4420 :   tile_span.y = ceil_ratio(canvas.size.y+canvas.pos.y-tile_partition.pos.y,

	mov	eax, DWORD PTR [esi+140]
	sub	eax, DWORD PTR [esi+148]
	add	eax, DWORD PTR [esi+132]
	mov	ecx, DWORD PTR [esi+156]
	mov	DWORD PTR [esi+272], 0
	mov	DWORD PTR [esi+268], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN133@construct_

; 180  :     return -((-num)/den);

	cdq
	idiv	ecx
	mov	ecx, eax
	jmp	SHORT $LN134@construct_
$LN133@construct_:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ecx
	lea	ecx, DWORD PTR [eax+1]
$LN134@construct_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4422 :   tile_span.x = ceil_ratio(canvas.size.x+canvas.pos.x-tile_partition.pos.x,

	mov	eax, DWORD PTR [esi+144]
	sub	eax, DWORD PTR [esi+152]
	add	eax, DWORD PTR [esi+136]
	mov	edi, DWORD PTR [esi+160]
	mov	DWORD PTR [esi+164], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN137@construct_

; 180  :     return -((-num)/den);

	cdq
	idiv	edi
	mov	edi, eax
	jmp	SHORT $LN138@construct_
$LN137@construct_:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	edi
	lea	edi, DWORD PTR [eax+1]
$LN138@construct_:
	mov	DWORD PTR [esi+168], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4424 :   int total_tiles = tile_span.x*tile_span.y;

	imul	edi, ecx

; 4425 :   if ((total_tiles > 65535) || (total_tiles < 0))

	cmp	edi, 65535				; 0000ffffH
	jg	SHORT $LN26@construct_
	test	edi, edi
	jns	SHORT $LN25@construct_
$LN26@construct_:

; 4426 :     { KDU_ERROR(e,30); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$7[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_0HD@LMPODLJE@Maximum?5number?5of?5allowable?5tile@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4426 :     { KDU_ERROR(e,30); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4429 :     }

	lea	ecx, DWORD PTR _e$7[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN25@construct_:

; 4430 :   tile_indices.pos = kdu_coords(0,0);
; 4431 :   tile_indices.size = tile_span;

	mov	eax, DWORD PTR [esi+164]

; 4432 :   tile_refs = new kd_tile_ref[total_tiles];

	xor	ecx, ecx
	mov	DWORD PTR [esi+180], eax
	mov	edx, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+168]
	mov	DWORD PTR [esi+184], eax
	mov	eax, edi
	mul	edx
	mov	DWORD PTR [esi+172], 0
	mov	DWORD PTR [esi+176], 0
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 4433 :   memset(tile_refs,0,((size_t) total_tiles) * sizeof(kd_tile_ref));

	lea	ecx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+264], eax
	shl	ecx, 2
	push	ecx
	push	0
	push	eax
	call	_memset

; 4434 : 
; 4435 :   // Check for profile violations
; 4436 :   if (profile == 0)

	mov	eax, DWORD PTR [esi+104]
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN27@construct_

; 4437 :     {
; 4438 :       if (((tile_partition.size.x != 128) ||
; 4439 :            (tile_partition.size.y != 128)) && (total_tiles > 1))

	cmp	DWORD PTR [esi+160], 128		; 00000080H
	jne	SHORT $LN31@construct_
	cmp	DWORD PTR [esi+156], 128		; 00000080H
	je	SHORT $LN29@construct_
$LN31@construct_:
	cmp	edi, 1
	jle	SHORT $LN29@construct_

; 4440 :         { KDU_WARNING(w,9); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$6[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$6[ebp]
	lea	ecx, DWORD PTR _w$6[ebp]
	push	OFFSET ??_C@_0NN@GLDINDPL@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4440 :         { KDU_WARNING(w,9); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4446 :         }

	lea	ecx, DWORD PTR _w$6[ebp]

; 4447 :       else if (tile_partition.pos.x || tile_partition.pos.y ||

	jmp	$LN189@construct_
$LN29@construct_:

; 4448 :                canvas.pos.x || canvas.pos.y)

	cmp	DWORD PTR [esi+152], 0
	jne	$LN34@construct_
	cmp	DWORD PTR [esi+148], 0
	jne	$LN34@construct_
	cmp	DWORD PTR [esi+136], 0
	jne	SHORT $LN34@construct_
	cmp	DWORD PTR [esi+132], 0
	jne	SHORT $LN34@construct_

; 4456 :        else
; 4457 :          {
; 4458 :            for (n=0; n < num_components; n++)

	mov	ebx, DWORD PTR [esi+112]
	xor	edx, edx
	test	ebx, ebx
	jle	SHORT $LN186@construct_

; 4459 :              {
; 4460 :                kd_comp_info *ci = comp_info + n;

	mov	eax, DWORD PTR [esi+256]
	npad	1
$LL10@construct_:

; 4461 :                if (((ci->sub_sampling.x != 1) && (ci->sub_sampling.x != 2) &&
; 4462 :                     (ci->sub_sampling.x != 4)) ||

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 1
	je	SHORT $LN37@construct_
	cmp	ecx, 2
	je	SHORT $LN37@construct_
	cmp	ecx, 4
	jne	SHORT $LN186@construct_
$LN37@construct_:
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 1
	je	SHORT $LN8@construct_
	cmp	ecx, 2
	je	SHORT $LN8@construct_
	cmp	ecx, 4
	jne	SHORT $LN186@construct_
$LN8@construct_:

; 4456 :        else
; 4457 :          {
; 4458 :            for (n=0; n < num_components; n++)

	inc	edx
	add	eax, 96					; 00000060H
	cmp	edx, ebx
	jl	SHORT $LL10@construct_
$LN186@construct_:

; 4463 :                    ((ci->sub_sampling.y != 1) && (ci->sub_sampling.y != 2) &&
; 4464 :                     (ci->sub_sampling.y != 4)))
; 4465 :                  break;
; 4466 :              }
; 4467 :            if (n < num_components)

	cmp	edx, ebx
	jge	$LN45@construct_

; 4468 :              { KDU_WARNING(w,11); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$4[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$4[ebp]
	lea	ecx, DWORD PTR _w$4[ebp]
	push	OFFSET ??_C@_0MI@KDNKFEHF@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4468 :              { KDU_WARNING(w,11); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4474 :              }

	lea	ecx, DWORD PTR _w$4[ebp]
	jmp	$LN189@construct_
$LN34@construct_:

; 4449 :          { KDU_WARNING(w,10); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$5[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$5[ebp]
	lea	ecx, DWORD PTR _w$5[ebp]
	push	OFFSET ??_C@_0LM@OKEOLEGN@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4449 :          { KDU_WARNING(w,10); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4455 :          }

	lea	ecx, DWORD PTR _w$5[ebp]

; 4475 :          }

	jmp	$LN189@construct_
$LN27@construct_:

; 4476 :     }
; 4477 :   else if (profile == 1)

	cmp	eax, 1
	jne	$LN45@construct_

; 4478 :     { // Check for violations
; 4479 :       if (total_tiles > 1)

	cmp	edi, eax
	jle	$LN45@construct_

; 4480 :         { // The image is tiled
; 4481 :           if (tile_partition.size.x != tile_partition.size.y)

	mov	eax, DWORD PTR [esi+160]
	cmp	eax, DWORD PTR [esi+156]
	je	SHORT $LN41@construct_

; 4482 :             { KDU_WARNING(w,12); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$3[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$3[ebp]
	lea	ecx, DWORD PTR _w$3[ebp]
	push	OFFSET ??_C@_0BBI@OCAIKCLE@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4482 :             { KDU_WARNING(w,12); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 9
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4490 :             }

	lea	ecx, DWORD PTR _w$3[ebp]

; 4491 :           else

	jmp	SHORT $LN189@construct_
$LN41@construct_:

; 4492 :             {
; 4493 :               for (n=0; n < num_components; n++)

	mov	ebx, DWORD PTR [esi+112]
	xor	edx, edx
	test	ebx, ebx
	jle	SHORT $LN187@construct_

; 4494 :                 {
; 4495 :                   kd_comp_info *ci = comp_info + n;

	mov	ecx, DWORD PTR [esi+256]
	npad	4
$LL13@construct_:

; 4496 :                   if ((tile_partition.size.x > (ci->sub_sampling.x<<10)) ||

	mov	eax, DWORD PTR [ecx+4]
	shl	eax, 10					; 0000000aH
	cmp	DWORD PTR [esi+160], eax
	jg	SHORT $LN187@construct_
	mov	eax, DWORD PTR [ecx]
	shl	eax, 10					; 0000000aH
	cmp	DWORD PTR [esi+156], eax
	jg	SHORT $LN187@construct_

; 4492 :             {
; 4493 :               for (n=0; n < num_components; n++)

	inc	edx
	add	ecx, 96					; 00000060H
	cmp	edx, ebx
	jl	SHORT $LL13@construct_
$LN187@construct_:

; 4497 :                       (tile_partition.size.y > (ci->sub_sampling.y<<10)))
; 4498 :                     break;
; 4499 :                 }
; 4500 :               if (n < num_components)

	cmp	edx, ebx
	jge	SHORT $LN45@construct_

; 4501 :                 { KDU_WARNING(w,13); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$2[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$2[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	OFFSET ??_C@_0BBL@KLDBMFIF@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4501 :                 { KDU_WARNING(w,13); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4509 :                 }

	lea	ecx, DWORD PTR _w$2[ebp]
$LN189@construct_:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+104], 2
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN45@construct_:

; 4510 :             }
; 4511 :         }
; 4512 :     }
; 4513 : 
; 4514 :   // Build the parameter structure.
; 4515 :   kdu_params *element;
; 4516 : 
; 4517 :   element = new mct_params;

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T28[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	test	eax, eax
	je	SHORT $LN52@construct_
	mov	ecx, eax
	call	??0mct_params@@QAE@XZ			; mct_params::mct_params
	jmp	SHORT $LN53@construct_
$LN52@construct_:
	xor	eax, eax
$LN53@construct_:

; 4518 :   element->link(siz,-1,-1,total_tiles,0);

	push	0
	push	edi
	push	-1
	push	-1
	push	DWORD PTR [esi+12]
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z	; kdu_params::link

; 4519 : 
; 4520 :   element = new mcc_params;

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T27[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	eax, eax
	je	SHORT $LN54@construct_
	mov	ecx, eax
	call	??0mcc_params@@QAE@XZ			; mcc_params::mcc_params
	jmp	SHORT $LN55@construct_
$LN54@construct_:
	xor	eax, eax
$LN55@construct_:

; 4521 :   element->link(siz,-1,-1,total_tiles,0);

	push	0
	push	edi
	push	-1
	push	-1
	push	DWORD PTR [esi+12]
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z	; kdu_params::link

; 4522 : 
; 4523 :   element = new mco_params;

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T26[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	test	eax, eax
	je	SHORT $LN56@construct_
	mov	ecx, eax
	call	??0mco_params@@QAE@XZ			; mco_params::mco_params
	jmp	SHORT $LN57@construct_
$LN56@construct_:
	xor	eax, eax
$LN57@construct_:

; 4524 :   element->link(siz,-1,-1,total_tiles,0);

	push	0
	push	edi
	push	-1
	push	-1
	push	DWORD PTR [esi+12]
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z	; kdu_params::link

; 4525 : 
; 4526 :   element = new atk_params; // Must link this before `cod_params', if at all

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T25[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	test	eax, eax
	je	SHORT $LN58@construct_
	mov	ecx, eax
	call	??0atk_params@@QAE@XZ			; atk_params::atk_params
	jmp	SHORT $LN59@construct_
$LN58@construct_:
	xor	eax, eax
$LN59@construct_:

; 4527 :   element->link(siz,-1,-1,total_tiles,0);

	push	0
	push	edi
	push	-1
	push	-1
	push	DWORD PTR [esi+12]
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z	; kdu_params::link

; 4528 : 
; 4529 :   element = new cod_params;

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T24[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
	test	eax, eax
	je	SHORT $LN60@construct_
	mov	ecx, eax
	call	??0cod_params@@QAE@XZ			; cod_params::cod_params
	jmp	SHORT $LN61@construct_
$LN60@construct_:
	xor	eax, eax
$LN61@construct_:

; 4530 :   element->link(siz,-1,-1,total_tiles,num_components);

	push	DWORD PTR [esi+112]
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	edi
	push	-1
	push	-1
	push	DWORD PTR [esi+12]
	call	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z	; kdu_params::link

; 4531 : 
; 4532 :   element = new dfs_params; // Must link this one after `cod_params'

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T23[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 16		; 00000010H
	test	eax, eax
	je	SHORT $LN62@construct_
	mov	ecx, eax
	call	??0dfs_params@@QAE@XZ			; dfs_params::dfs_params
	jmp	SHORT $LN63@construct_
$LN62@construct_:
	xor	eax, eax
$LN63@construct_:

; 4533 :   element->link(siz,-1,-1,0,0);

	push	0
	push	0
	push	-1
	push	-1
	push	DWORD PTR [esi+12]
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z	; kdu_params::link

; 4534 : 
; 4535 :   element = new ads_params; // Must link this one after `cod_params'

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T22[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
	test	eax, eax
	je	SHORT $LN64@construct_
	mov	ecx, eax
	call	??0ads_params@@QAE@XZ			; ads_params::ads_params
	jmp	SHORT $LN65@construct_
$LN64@construct_:
	xor	eax, eax
$LN65@construct_:

; 4536 :   element->link(siz,-1,-1,total_tiles,0);

	push	0
	push	edi
	push	-1
	push	-1
	push	DWORD PTR [esi+12]
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z	; kdu_params::link

; 4537 : 
; 4538 :   element = new qcd_params; // Must link this one after `cod_params'

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T21[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
	test	eax, eax
	je	SHORT $LN66@construct_
	mov	ecx, eax
	call	??0qcd_params@@QAE@XZ			; qcd_params::qcd_params
	jmp	SHORT $LN67@construct_
$LN66@construct_:
	xor	eax, eax
$LN67@construct_:

; 4539 :   element->link(siz,-1,-1,total_tiles,num_components);

	push	DWORD PTR [esi+112]
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	edi
	push	-1
	push	-1
	push	DWORD PTR [esi+12]
	call	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z	; kdu_params::link

; 4540 : 
; 4541 :   element = new rgn_params;

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T20[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 19		; 00000013H
	test	eax, eax
	je	SHORT $LN68@construct_
	mov	ecx, eax
	call	??0rgn_params@@QAE@XZ			; rgn_params::rgn_params
	jmp	SHORT $LN69@construct_
$LN68@construct_:
	xor	eax, eax
$LN69@construct_:

; 4542 :   element->link(siz,-1,-1,total_tiles,num_components);

	push	DWORD PTR [esi+112]
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	edi
	push	-1
	push	-1
	push	DWORD PTR [esi+12]
	call	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z	; kdu_params::link

; 4543 : 
; 4544 :   element = new poc_params;

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T19[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 20		; 00000014H
	test	eax, eax
	je	SHORT $LN70@construct_
	mov	ecx, eax
	call	??0poc_params@@QAE@XZ			; poc_params::poc_params
	jmp	SHORT $LN71@construct_
$LN70@construct_:
	xor	eax, eax
$LN71@construct_:

; 4545 :   element->link(siz,-1,-1,total_tiles,0);

	push	0
	push	edi
	push	-1
	push	-1
	push	DWORD PTR [esi+12]
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z	; kdu_params::link

; 4546 : 
; 4547 :   element = new org_params;

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T18[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 21		; 00000015H
	test	eax, eax
	je	SHORT $LN72@construct_
	mov	ecx, eax
	call	??0org_params@@QAE@XZ			; org_params::org_params
	jmp	SHORT $LN73@construct_
$LN72@construct_:
	xor	eax, eax
$LN73@construct_:

; 4548 :   element->link(siz,-1,-1,total_tiles,0);

	push	0
	push	edi
	push	-1
	push	-1
	push	DWORD PTR [esi+12]
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z	; kdu_params::link

; 4549 : 
; 4550 :   element = new crg_params;

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T17[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 22		; 00000016H
	test	eax, eax
	je	SHORT $LN74@construct_
	mov	ecx, eax
	call	??0crg_params@@QAE@XZ			; crg_params::crg_params
	jmp	SHORT $LN75@construct_
$LN74@construct_:
	xor	eax, eax
$LN75@construct_:

; 4551 :   element->link(siz,-1,-1,0,0);

	push	0
	push	0
	push	-1
	push	-1
	push	DWORD PTR [esi+12]
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	?link@kdu_params@@QAEPAV1@PAV1@HHHH@Z	; kdu_params::link

; 4554 :   buf_server = new kd_buf_server;

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T16[ebp], eax
	test	eax, eax
	je	SHORT $LN76@construct_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 229  :         alloc = NULL; free_head = NULL;

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 230  :         total_pages = num_allocated_pages = peak_allocated_pages = 0;

	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0

; 231  :         structure_bytes = peak_structure_bytes = 0;

	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0

; 232  :         cache_threshold_bytes = 0; num_users=0;

	mov	DWORD PTR [eax+48], 0
	mov	DWORD PTR [eax+52], 0
	mov	DWORD PTR [eax+56], 0

; 233  :         attached_thread_buf_servers = NULL;

	mov	DWORD PTR [eax+60], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4554 :   buf_server = new kd_buf_server;

	jmp	SHORT $LN77@construct_
$LN76@construct_:
	xor	eax, eax
$LN77@construct_:

; 4555 :   precinct_server = new kd_precinct_server(buf_server);

	push	32					; 00000020H
	mov	DWORD PTR [esi+24], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T15[ebp], eax
	test	eax, eax
	je	SHORT $LN78@construct_
	mov	ecx, DWORD PTR [esi+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4470 :       { size_classes = NULL; total_allocated_bytes = 0;

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0

; 4471 :         inactive_head = inactive_tail = NULL; this->buf_server = buf_server; }

	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+24], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4555 :   precinct_server = new kd_precinct_server(buf_server);

	jmp	SHORT $LN79@construct_
$LN78@construct_:
	xor	eax, eax
$LN79@construct_:
	mov	DWORD PTR [esi+40], eax

; 4556 :   buf_server->attach();

	mov	eax, DWORD PTR [esi+24]

; 4557 :   block = new kdu_block();

	push	160					; 000000a0H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 241  :       { num_users++; }

	inc	DWORD PTR [eax+56]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4557 :   block = new kdu_block();

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T14[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 23		; 00000017H
	test	eax, eax
	je	SHORT $LN80@construct_
	mov	ecx, eax
	call	??0kdu_block@@AAE@XZ			; kdu_block::kdu_block
	jmp	SHORT $LN81@construct_
$LN80@construct_:
	xor	eax, eax
$LN81@construct_:

; 4558 : 
; 4559 :   // Now some final initialization steps.
; 4560 :   if (in != NULL)

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+28], eax
	test	ecx, ecx
	je	SHORT $LN46@construct_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 656  :       { return source->get_capabilities(); }

	mov	ecx, DWORD PTR [ecx+540]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4562 :       if (in->get_capabilities() & KDU_SOURCE_CAP_SEEKABLE)

	test	al, 2
	je	SHORT $LN47@construct_

; 4563 :         tpart_ptr_server = new kd_tpart_pointer_server;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	test	eax, eax
	je	SHORT $LN82@construct_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1076 :         groups = NULL; free_list = NULL; tlm_markers = NULL;

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax], 0

; 1077 :         translated_tlm_markers = false;

	mov	BYTE PTR [eax+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 4563 :         tpart_ptr_server = new kd_tpart_pointer_server;

	jmp	SHORT $LN83@construct_
$LN82@construct_:
	xor	eax, eax
$LN83@construct_:
	mov	DWORD PTR [esi+36], eax
$LN47@construct_:

; 4564 :       read_main_header();

	mov	ecx, esi
	call	?read_main_header@kd_codestream@@AAEXXZ	; kd_codestream::read_main_header
$LN46@construct_:

; 4565 :     }
; 4566 :   if (output_comp_info == NULL)

	cmp	DWORD PTR [esi+260], 0
	jne	SHORT $LN48@construct_

; 4567 :     construct_output_comp_info();

	mov	ecx, esi
	call	?construct_output_comp_info@kd_codestream@@QAEXXZ ; kd_codestream::construct_output_comp_info
$LN48@construct_:

; 4568 : 
; 4569 :   region = canvas;

	movups	xmm0, XMMWORD PTR [esi+132]

; 4570 :   discard_levels = 0;
; 4571 :   min_dwt_levels = 100; // Ridiculous value
; 4572 :   max_apparent_layers = 0xFFFF;
; 4573 :   num_apparent_components = num_components;

	mov	eax, DWORD PTR [esi+112]
	mov	DWORD PTR [esi+188], 0
	movups	XMMWORD PTR [esi+208], xmm0
	mov	DWORD PTR [esi+192], 100		; 00000064H
	mov	DWORD PTR [esi+196], 65535		; 0000ffffH
	mov	DWORD PTR [esi+116], eax

; 4574 :   max_tile_layers = 1;

	mov	DWORD PTR [esi+200], 1

; 4575 :   tiles_accessed = false;

	mov	BYTE PTR [esi+340], 0

; 4576 :   stats = NULL;

	mov	DWORD PTR [esi+32], 0

; 4577 :   start_time = clock();

	call	DWORD PTR __imp__clock
	mov	DWORD PTR [esi+388], eax

; 4578 : 
; 4579 :   cannot_flip = false; // Until proven otherwise

	mov	BYTE PTR [esi+224], 0

; 4580 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$0:
	lea	ecx, DWORD PTR _e$12[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$1:
	lea	ecx, DWORD PTR _e$11[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$3:
	lea	ecx, DWORD PTR _e$10[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$4:
	lea	ecx, DWORD PTR _e$9[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$5:
	lea	ecx, DWORD PTR _e$8[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$6:
	lea	ecx, DWORD PTR _e$7[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$7:
	lea	ecx, DWORD PTR _w$6[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$9:
	lea	ecx, DWORD PTR _w$4[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$8:
	lea	ecx, DWORD PTR _w$5[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$10:
	lea	ecx, DWORD PTR _w$3[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$11:
	lea	ecx, DWORD PTR _w$2[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$12:
	push	112					; 00000070H
	mov	eax, DWORD PTR $T28[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$13:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T27[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$14:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T26[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$15:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T25[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$16:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T24[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$17:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T23[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$18:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T22[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$19:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T21[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$20:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T20[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$21:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T19[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$22:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T18[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$23:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T17[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?construct_common@kd_codestream@@QAEXXZ$26:
	push	160					; 000000a0H
	mov	eax, DWORD PTR $T14[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct_common@kd_codestream@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?construct_common@kd_codestream@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct_common@kd_codestream@@QAEXXZ ENDP		; kd_codestream::construct_common
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ??1kd_codestream@@QAE@XZ
_TEXT	SEGMENT
_idx$1$ = -20						; size = 4
_tref$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1kd_codestream@@QAE@XZ PROC				; kd_codestream::~kd_codestream, COMDAT
; _this$ = ecx

; 5074 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_codestream@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 5075 :   // Delete arrays
; 5076 :   if (comp_info != NULL)

	mov	eax, DWORD PTR [edi+256]
	test	eax, eax
	je	SHORT $LN14@kd_codestr

; 5077 :     { delete[] comp_info; comp_info = NULL; }

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [edi+256], 0
$LN14@kd_codestr:

; 5078 :   if (output_comp_info != NULL)

	mov	eax, DWORD PTR [edi+260]
	test	eax, eax
	je	SHORT $LN15@kd_codestr

; 5079 :     { delete[] output_comp_info; output_comp_info = NULL; }

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [edi+260], 0
$LN15@kd_codestr:

; 5080 :   if (global_rescomps != NULL)

	mov	eax, DWORD PTR [edi+276]
	test	eax, eax
	je	SHORT $LN16@kd_codestr

; 5081 :     { delete[] global_rescomps; global_rescomps = NULL; }

	push	OFFSET ??1kd_global_rescomp@@QAE@XZ	; kd_global_rescomp::~kd_global_rescomp
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	80					; 00000050H
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 4
	add	eax, 4
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [edi+276], 0
$LN16@kd_codestr:

; 5082 :   if (reslength_checkers != NULL)

	mov	eax, DWORD PTR [edi+324]
	test	eax, eax
	je	SHORT $LN17@kd_codestr

; 5083 :     { delete[] reslength_checkers; reslength_checkers = NULL; }

	push	OFFSET ??1kd_reslength_checker@@QAE@XZ	; kd_reslength_checker::~kd_reslength_checker
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	push	808					; 00000328H
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [esi], 808
	add	eax, 4
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [edi+324], 0
$LN17@kd_codestr:

; 5084 : 
; 5085 :   active_tile = NULL;
; 5086 :   if (tile_refs != NULL)

	mov	eax, DWORD PTR [edi+264]
	mov	DWORD PTR [edi+364], 0
	mov	DWORD PTR _tref$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN164@kd_codestr

; 5087 :     {
; 5088 :       kdu_coords idx, abs_idx;
; 5089 :       kd_tile_ref *tref = tile_refs;
; 5090 :       for (idx.y=0; idx.y < tile_indices.size.y; idx.y++)

	xor	ecx, ecx
	mov	DWORD PTR _idx$1$[ebp], ecx
	cmp	DWORD PTR [edi+180], ecx
	jle	SHORT $LN3@kd_codestr
	npad	3
$LL4@kd_codestr:

; 5091 :         for (idx.x=0; idx.x < tile_indices.size.x; idx.x++, tref++)

	xor	ebx, ebx
	cmp	DWORD PTR [edi+184], ebx
	jle	SHORT $LN2@kd_codestr
	npad	6
$LL7@kd_codestr:

; 5092 :           {
; 5093 :             if ((tref->tile != NULL) && (tref->tile != KD_EXPIRED_TILE))

	mov	esi, DWORD PTR [eax+8]
	test	esi, esi
	je	SHORT $LN5@kd_codestr
	cmp	esi, -1
	je	SHORT $LN5@kd_codestr
	mov	ecx, esi
	call	??1kd_tile@@QAE@XZ			; kd_tile::~kd_tile
	push	272					; 00000110H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	mov	eax, DWORD PTR _tref$1$[ebp]
	add	esp, 8
$LN5@kd_codestr:

; 5091 :         for (idx.x=0; idx.x < tile_indices.size.x; idx.x++, tref++)

	inc	ebx
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _tref$1$[ebp], eax
	cmp	ebx, DWORD PTR [edi+184]
	jl	SHORT $LL7@kd_codestr
	mov	ecx, DWORD PTR _idx$1$[ebp]
$LN2@kd_codestr:

; 5087 :     {
; 5088 :       kdu_coords idx, abs_idx;
; 5089 :       kd_tile_ref *tref = tile_refs;
; 5090 :       for (idx.y=0; idx.y < tile_indices.size.y; idx.y++)

	inc	ecx
	mov	DWORD PTR _idx$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+180]
	jl	SHORT $LL4@kd_codestr
$LN3@kd_codestr:

; 5094 :               {
; 5095 :                 abs_idx = idx + tile_indices.pos;
; 5096 :                 assert(abs_idx == tref->tile->t_idx);
; 5097 :                 delete tref->tile; // Invokes tile destructor.
; 5098 :                 assert((tref->tile == NULL) ||
; 5099 :                        (tref->tile == KD_EXPIRED_TILE));
; 5100 :               }
; 5101 :         }
; 5102 :       delete[] tile_refs;

	push	DWORD PTR [edi+264]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN164@kd_codestr:

; 5103 :     }
; 5104 : 
; 5105 :   kd_tile *typ;
; 5106 :   while ((typ=typical_tile_cache) != NULL)

	mov	esi, DWORD PTR [edi+412]
	test	esi, esi
	je	SHORT $LN9@kd_codestr
	npad	6
$LL8@kd_codestr:

; 5107 :     {
; 5108 :       typical_tile_cache = typ->typical_next;

	mov	eax, DWORD PTR [esi+40]
	mov	ecx, esi
	mov	DWORD PTR [edi+412], eax
	call	??1kd_tile@@QAE@XZ			; kd_tile::~kd_tile
	push	272					; 00000110H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	mov	esi, DWORD PTR [edi+412]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL8@kd_codestr
$LN9@kd_codestr:

; 5109 :       assert(typ->tile_ref == NULL);
; 5110 :       delete typ;
; 5111 :     }
; 5112 : 
; 5113 :   // Delete other owned resources
; 5114 :   if (in != NULL)

	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	je	SHORT $LN20@kd_codestr

; 5115 :     { delete in; in = NULL; }

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
	mov	DWORD PTR [edi+4], 0
$LN20@kd_codestr:

; 5116 :   if (out != NULL)

	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	je	SHORT $LN21@kd_codestr

; 5117 :     { delete out; out = NULL; }

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
	mov	DWORD PTR [edi+8], 0
$LN21@kd_codestr:

; 5118 :   if (siz != NULL)

	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	je	SHORT $LN47@kd_codestr

; 5119 :     delete siz;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax+4]
$LN47@kd_codestr:

; 5120 :   if (marker != NULL)

	mov	esi, DWORD PTR [edi+16]
	test	esi, esi
	je	SHORT $LN101@kd_codestr
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN105@kd_codestr
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN105@kd_codestr:
	push	28					; 0000001cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN101@kd_codestr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5122 :   if (ppm_markers != NULL)

	mov	esi, DWORD PTR [edi+20]
	test	esi, esi
	je	SHORT $LN109@kd_codestr
	mov	ecx, esi
	call	??1kd_pp_markers@@QAE@XZ		; kd_pp_markers::~kd_pp_markers
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN109@kd_codestr:

; 5123 :     delete ppm_markers;
; 5124 :   if (precinct_server != NULL)

	mov	esi, DWORD PTR [edi+40]
	test	esi, esi
	je	SHORT $LN113@kd_codestr
	mov	ecx, esi
	call	??1kd_precinct_server@@QAE@XZ		; kd_precinct_server::~kd_precinct_server
	push	32					; 00000020H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN113@kd_codestr:

; 5125 :     delete precinct_server;
; 5126 :   if (block != NULL)

	mov	esi, DWORD PTR [edi+28]
	test	esi, esi
	je	SHORT $LN117@kd_codestr
	mov	ecx, esi
	call	??1kdu_block@@AAE@XZ			; kdu_block::~kdu_block
	push	160					; 000000a0H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN117@kd_codestr:

; 5127 :     delete block;
; 5128 :   if (stats != NULL)

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN27@kd_codestr

; 5129 :     delete stats;

	push	32832					; 00008040H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN27@kd_codestr:

; 5130 :   if (tpart_ptr_server != NULL)

	mov	esi, DWORD PTR [edi+36]
	test	esi, esi
	je	SHORT $LN121@kd_codestr
	mov	ecx, esi
	call	??1kd_tpart_pointer_server@@QAE@XZ	; kd_tpart_pointer_server::~kd_tpart_pointer_server
	push	16					; 00000010H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN121@kd_codestr:

; 5132 :   while ((comtail=comhead) != NULL)

	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [edi+48], eax
	test	eax, eax
	je	SHORT $LN11@kd_codestr
$LL10@kd_codestr:

; 5133 :     {
; 5134 :       comhead = comtail->next;

	mov	eax, DWORD PTR [edi+48]

; 5135 :       delete comtail;

	mov	esi, DWORD PTR [edi+48]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [edi+44], eax
	test	esi, esi
	je	SHORT $LN125@kd_codestr
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1469 :       { if (text_buf != NULL) delete[] text_buf; }

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN129@kd_codestr
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN129@kd_codestr:
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN125@kd_codestr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5132 :   while ((comtail=comhead) != NULL)

	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [edi+48], eax
	test	eax, eax
	jne	SHORT $LL10@kd_codestr
$LN11@kd_codestr:

; 5136 :     }
; 5137 :   if (layer_sizes != NULL)

	mov	eax, DWORD PTR [edi+288]
	test	eax, eax
	je	SHORT $LN29@kd_codestr

; 5138 :     delete[] layer_sizes;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN29@kd_codestr:

; 5139 :   if (layer_targets != NULL)

	mov	eax, DWORD PTR [edi+292]
	test	eax, eax
	je	SHORT $LN30@kd_codestr

; 5140 :     delete[] layer_targets;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN30@kd_codestr:

; 5141 :   if (layer_thresholds != NULL)

	mov	eax, DWORD PTR [edi+296]
	test	eax, eax
	je	SHORT $LN31@kd_codestr

; 5142 :     delete[] layer_thresholds;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN31@kd_codestr:

; 5143 :   if (buf_server != NULL)

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN137@kd_codestr
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 243  :       { assert(num_users > 0); num_users--; }

	dec	DWORD PTR [eax+56]

; 239  :       { return (num_users == 0); }

	mov	esi, DWORD PTR [edi+24]
	cmp	DWORD PTR [esi+56], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5146 :       if (buf_server->can_destroy())

	jne	SHORT $LN137@kd_codestr

; 5147 :         delete buf_server;

	test	esi, esi
	je	SHORT $LN137@kd_codestr
	mov	ecx, esi
	call	??1kd_buf_server@@QAE@XZ		; kd_buf_server::~kd_buf_server
	push	64					; 00000040H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN137@kd_codestr:

; 5149 :   while ((global_mct_tail=global_mct_head) != NULL)

	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [edi+100], eax
	test	eax, eax
	je	$LN13@kd_codestr
	npad	5
$LL12@kd_codestr:

; 5150 :     {
; 5151 :       global_mct_head = global_mct_tail->next_stage;

	mov	eax, DWORD PTR [edi+100]

; 5152 :       delete global_mct_tail;

	mov	ebx, DWORD PTR [edi+100]
	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR [edi+96], eax
	test	ebx, ebx
	je	SHORT $LN63@kd_codestr
	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2136 :         if (input_required_indices != NULL)

	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN145@kd_codestr

; 2137 :           delete[] input_required_indices;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN145@kd_codestr:

; 2138 :         if (output_comp_info != NULL) delete[] output_comp_info;

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	SHORT $LN146@kd_codestr
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN146@kd_codestr:

; 2139 :         if (blocks != NULL) delete[] blocks;

	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
	je	SHORT $LN155@kd_codestr
	push	OFFSET ??1kd_mct_block@@QAE@XZ		; kd_mct_block::~kd_mct_block
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	108					; 0000006cH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [esi], 108
	add	eax, 4
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN155@kd_codestr:
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN63@kd_codestr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5149 :   while ((global_mct_tail=global_mct_head) != NULL)

	mov	eax, DWORD PTR [edi+96]
	mov	DWORD PTR [edi+100], eax
	test	eax, eax
	jne	$LL12@kd_codestr
$LN13@kd_codestr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 997  :     ~kd_tlm_generator() { if (elts != NULL) delete[] elts; }

	mov	eax, DWORD PTR [edi+88]
	test	eax, eax
	je	SHORT $LN159@kd_codestr
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN159@kd_codestr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5154 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1kd_codestream@@QAE@XZ$0:
	call	___std_terminate
	ret	0
__unwindfunclet$??1kd_codestream@@QAE@XZ$2:
	call	___std_terminate
	ret	0
__unwindfunclet$??1kd_codestream@@QAE@XZ$15:
	call	___std_terminate
	ret	0
__unwindfunclet$??1kd_codestream@@QAE@XZ$16:
	call	___std_terminate
	ret	0
__unwindfunclet$??1kd_codestream@@QAE@XZ$17:
	call	___std_terminate
	ret	0
__ehhandler$??1kd_codestream@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_codestream@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_codestream@@QAE@XZ ENDP				; kd_codestream::~kd_codestream
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_codestream@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0kd_codestream@@QAE@XZ PROC				; kd_codestream::kd_codestream, COMDAT
; _this$ = ecx

; 2229 :     kd_codestream()

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 2231 :         memset(this,0,sizeof(*this));

	push	416					; 000001a0H
	push	0
	push	esi

; 994  :         num_tiles = max_tparts = num_elts = 0; elts = NULL;

	mov	DWORD PTR [esi+68], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+88], 0

; 995  :         tile_data_bytes=0;

	mov	DWORD PTR [esi+80], 0
	mov	DWORD PTR [esi+84], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [esi+132], 0
	mov	DWORD PTR [esi+136], 0
	mov	DWORD PTR [esi+140], 0
	mov	DWORD PTR [esi+144], 0
	mov	DWORD PTR [esi+148], 0
	mov	DWORD PTR [esi+152], 0
	mov	DWORD PTR [esi+156], 0
	mov	DWORD PTR [esi+160], 0
	mov	DWORD PTR [esi+164], 0
	mov	DWORD PTR [esi+168], 0
	mov	DWORD PTR [esi+172], 0
	mov	DWORD PTR [esi+176], 0
	mov	DWORD PTR [esi+180], 0
	mov	DWORD PTR [esi+184], 0
	mov	DWORD PTR [esi+208], 0
	mov	DWORD PTR [esi+212], 0
	mov	DWORD PTR [esi+216], 0
	mov	DWORD PTR [esi+220], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2231 :         memset(this,0,sizeof(*this));

	call	_memset
	add	esp, 12					; 0000000cH

; 2232 :         max_unloadable_tiles = 64; // A reasonable default value

	mov	DWORD PTR [esi+408], 64			; 00000040H

; 2233 :       }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0kd_codestream@@QAE@XZ ENDP				; kd_codestream::kd_codestream
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Gkd_mct_stage@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gkd_mct_stage@@QAEPAXI@Z PROC			; kd_mct_stage::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Gkd_mct_stage@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 2136 :         if (input_required_indices != NULL)

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN5@scalar

; 2137 :           delete[] input_required_indices;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@scalar:

; 2138 :         if (output_comp_info != NULL) delete[] output_comp_info;

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN6@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@scalar:

; 2139 :         if (blocks != NULL) delete[] blocks;

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN15@scalar
	push	OFFSET ??1kd_mct_block@@QAE@XZ		; kd_mct_block::~kd_mct_block
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	108					; 0000006cH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [esi], 108
	add	eax, 4
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN15@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN18@scalar
	push	40					; 00000028H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN18@scalar:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gkd_mct_stage@@QAEPAXI@Z$0:
	call	___std_terminate
	ret	0
__unwindfunclet$??_Gkd_mct_stage@@QAEPAXI@Z$1:
	call	___std_terminate
	ret	0
__ehhandler$??_Gkd_mct_stage@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Gkd_mct_stage@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Gkd_mct_stage@@QAEPAXI@Z ENDP			; kd_mct_stage::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?apply_output_restrictions@kd_mct_stage@@QAEXPAUkd_output_comp_info@@HPBH@Z
_TEXT	SEGMENT
_b$1$ = -36						; size = 4
_expanded_scratch$1$ = -32				; size = 4
_lev$1$ = -28						; size = 4
_lev_lim$1$ = -24					; size = 4
_lev_min$1$ = -20					; size = 4
_band_max$3$ = -16					; size = 4
_band_max$1$ = -16					; size = 4
_block$1$ = -12						; size = 4
_expanded$1$ = -8					; size = 4
_this$1$ = -4						; size = 4
_band_min$3$ = 8					; size = 4
_n$11$ = 8						; size = 4
_global_comp_info$ = 8					; size = 4
_unset_inputs$1$ = 12					; size = 4
_num_comps_of_interest$ = 12				; size = 4
_used$1$ = 16						; size = 4
tv1335 = 16						; size = 4
_comps_of_interest$ = 16				; size = 4
?apply_output_restrictions@kd_mct_stage@@QAEXPAUkd_output_comp_info@@HPBH@Z PROC ; kd_mct_stage::apply_output_restrictions, COMDAT
; _this$ = ecx

; 3671 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	mov	ebx, DWORD PTR _comps_of_interest$[ebp]
	mov	eax, ecx
	mov	ecx, DWORD PTR _global_comp_info$[ebp]
	push	esi
	mov	esi, DWORD PTR _num_comps_of_interest$[ebp]
	push	edi
	mov	DWORD PTR _this$1$[ebp], eax
	npad	9
$LL109@apply_outp:

; 3672 :   int n, b;
; 3673 : 
; 3674 :   // Start by identifying the number and order of apparent output components
; 3675 :   num_apparent_outputs = 0;
; 3676 :   if (next_stage == NULL)

	cmp	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+16], 0
	jne	$LN74@apply_outp

; 3677 :     {
; 3678 :       assert(global_comp_info != NULL);
; 3679 :       for (n=0; n < num_outputs; n++)

	xor	edi, edi
	cmp	DWORD PTR [eax+12], edi
	jle	SHORT $LN222@apply_outp
	mov	eax, -16				; fffffff0H
	lea	edx, DWORD PTR [ecx+16]
	sub	eax, ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR tv1335[ebp], eax
$LL4@apply_outp:

; 3680 :         {
; 3681 :           kd_output_comp_info *oci = output_comp_info + n;

	mov	ecx, DWORD PTR [ecx+20]
	add	ecx, eax

; 3682 :           oci->apparent_idx = global_comp_info[n].apparent_idx;

	mov	eax, DWORD PTR [edx-4]
	add	ecx, edx
	mov	DWORD PTR [ecx+12], eax

; 3683 :           oci->from_apparent = global_comp_info[n].from_apparent;
; 3684 :           oci->is_of_interest = false;
; 3685 :           if (oci->apparent_idx >= 0)

	cmp	DWORD PTR [ecx+12], 0
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+16], eax
	mov	BYTE PTR [ecx+32], 0
	jl	SHORT $LN2@apply_outp

; 3686 :             {
; 3687 :               num_apparent_outputs++;

	mov	eax, DWORD PTR _this$1$[ebp]
	inc	DWORD PTR [eax+16]

; 3688 :               if (num_comps_of_interest == 0)

	test	esi, esi
	jne	SHORT $LN77@apply_outp

; 3689 :                 oci->is_of_interest = true;

	mov	BYTE PTR [ecx+32], 1
	jmp	SHORT $LN2@apply_outp
$LN77@apply_outp:

; 3690 :               else if (comps_of_interest == NULL)

	test	ebx, ebx
	jne	SHORT $LN2@apply_outp

; 3691 :                 oci->is_of_interest =

	cmp	DWORD PTR [ecx+12], esi
	setl	al
	mov	BYTE PTR [ecx+32], al
$LN2@apply_outp:

; 3677 :     {
; 3678 :       assert(global_comp_info != NULL);
; 3679 :       for (n=0; n < num_outputs; n++)

	mov	ecx, DWORD PTR _this$1$[ebp]
	inc	edi
	mov	eax, DWORD PTR tv1335[ebp]
	add	edx, 40					; 00000028H
	cmp	edi, DWORD PTR [ecx+12]
	jl	SHORT $LL4@apply_outp
	jmp	SHORT $LN3@apply_outp
$LN222@apply_outp:
	mov	ecx, DWORD PTR _this$1$[ebp]
$LN3@apply_outp:

; 3692 :                   (oci->apparent_idx < num_comps_of_interest);
; 3693 :             }
; 3694 :         }
; 3695 :       if (comps_of_interest != NULL)

	test	ebx, ebx
	je	$LN9@apply_outp

; 3696 :         for (n=0; n < num_comps_of_interest; n++)

	xor	edx, edx
	test	esi, esi
	jle	$LN9@apply_outp
$LL7@apply_outp:

; 3697 :           {
; 3698 :             int idx = comps_of_interest[n];

	mov	eax, DWORD PTR [ebx+edx*4]

; 3699 :             if ((idx < 0) || (idx >= num_apparent_outputs))

	test	eax, eax
	js	SHORT $LN5@apply_outp
	cmp	eax, DWORD PTR [ecx+16]
	jge	SHORT $LN5@apply_outp

; 3700 :               continue;
; 3701 :             idx = output_comp_info[idx].from_apparent;

	mov	ecx, DWORD PTR [ecx+20]
	lea	eax, DWORD PTR [eax+eax*4]

; 3702 :             kd_output_comp_info *oci = output_comp_info + idx;

	mov	eax, DWORD PTR [ecx+eax*8+16]
	lea	eax, DWORD PTR [eax+eax*4]

; 3703 :             assert(oci->apparent_idx == comps_of_interest[n]);
; 3704 :             oci->is_of_interest = true;

	mov	BYTE PTR [ecx+eax*8+32], 1
$LN5@apply_outp:

; 3696 :         for (n=0; n < num_comps_of_interest; n++)

	mov	ecx, DWORD PTR _this$1$[ebp]
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL7@apply_outp

; 3705 :           }
; 3706 :     }
; 3707 :   else

	jmp	SHORT $LN9@apply_outp
$LN74@apply_outp:

; 3708 :     {
; 3709 :       assert((global_comp_info == NULL) &&
; 3710 :              (num_outputs == next_stage->num_inputs));
; 3711 :       for (n=0; n < num_outputs; n++)

	mov	ebx, DWORD PTR _this$1$[ebp]
	xor	esi, esi
	cmp	DWORD PTR [ebx+12], esi
	jle	SHORT $LN9@apply_outp
	xor	edi, edi
	npad	5
$LL10@apply_outp:

; 3712 :         {
; 3713 :           kd_output_comp_info *oci = output_comp_info + n;

	mov	edx, DWORD PTR [ebx+20]
	add	edx, edi

; 3714 :           oci->from_apparent = 0; // So everything at least gets initialized

	mov	DWORD PTR [edx+16], 0

; 3715 :           if (next_stage->input_required_indices[n] >= 0)

	mov	eax, DWORD PTR [ebx+36]
	mov	eax, DWORD PTR [eax+8]
	cmp	DWORD PTR [eax+esi*4], 0
	jl	SHORT $LN83@apply_outp

; 3716 :             {
; 3717 :               output_comp_info[num_apparent_outputs].from_apparent = n;

	mov	eax, DWORD PTR [ebx+16]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ebx+20]
	mov	DWORD PTR [eax+ecx*8+16], esi

; 3718 :               oci->apparent_idx = num_apparent_outputs;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [edx+12], eax

; 3719 :               num_apparent_outputs++;

	inc	DWORD PTR [ebx+16]

; 3720 :               oci->is_of_interest = true;

	mov	BYTE PTR [edx+32], 1

; 3721 :               assert(next_stage->input_required_indices[n]==oci->apparent_idx);
; 3722 :             }
; 3723 :           else

	jmp	SHORT $LN8@apply_outp
$LN83@apply_outp:

; 3724 :             {
; 3725 :               oci->apparent_idx = -1; // This one is not apparent

	mov	DWORD PTR [edx+12], -1

; 3726 :               oci->is_of_interest = false;

	mov	BYTE PTR [edx+32], 0
$LN8@apply_outp:

; 3708 :     {
; 3709 :       assert((global_comp_info == NULL) &&
; 3710 :              (num_outputs == next_stage->num_inputs));
; 3711 :       for (n=0; n < num_outputs; n++)

	inc	esi
	add	edi, 40					; 00000028H
	cmp	esi, DWORD PTR [ebx+12]
	jl	SHORT $LL10@apply_outp
$LN9@apply_outp:

; 3727 :             }
; 3728 :         }
; 3729 :       assert(num_apparent_outputs == next_stage->num_required_inputs);
; 3730 :     }
; 3731 : 
; 3732 :   // Next, scan through the blocks, identifying the required input components
; 3733 :   // and setting the appearance parameters for each block's outputs
; 3734 :   num_required_inputs = 0;

	mov	esi, DWORD PTR _this$1$[ebp]

; 3735 :   for (n=0; n < num_inputs; n++)

	xor	ecx, ecx
	mov	DWORD PTR [esi+4], 0
	cmp	DWORD PTR [esi], ecx
	jle	SHORT $LN12@apply_outp
	npad	8
$LL13@apply_outp:

; 3736 :     input_required_indices[n] = -1; // Initially mark everything not required

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*4], -1
	inc	ecx
	cmp	ecx, DWORD PTR [esi]
	jl	SHORT $LL13@apply_outp
$LN12@apply_outp:

; 3737 :   for (b=0; b < num_blocks; b++)

	xor	eax, eax
	mov	DWORD PTR _b$1$[ebp], eax
	cmp	DWORD PTR [esi+24], eax
	jle	$LN15@apply_outp
	npad	3
$LL16@apply_outp:

; 3738 :     {
; 3739 :       kd_mct_block *block = blocks + b;

	imul	edi, eax, 108

; 3740 : 
; 3741 :       block->num_required_inputs = 0;
; 3742 :       for (n=0; n < block->num_inputs; n++)

	xor	ecx, ecx
	add	edi, DWORD PTR [esi+28]
	mov	DWORD PTR _block$1$[ebp], edi
	mov	DWORD PTR [edi+8], 0
	cmp	DWORD PTR [edi+4], ecx
	jle	SHORT $LN18@apply_outp
$LL19@apply_outp:

; 3743 :         block->inputs_required[n] = false;

	mov	eax, DWORD PTR [edi+16]
	mov	BYTE PTR [ecx+eax], 0
	inc	ecx
	cmp	ecx, DWORD PTR [edi+4]
	jl	SHORT $LL19@apply_outp
$LN18@apply_outp:

; 3744 :       block->num_apparent_outputs = 0;
; 3745 :       for (n=0; n < block->num_outputs; n++)

	xor	edx, edx
	mov	DWORD PTR [edi+24], 0
	cmp	DWORD PTR [edi+20], edx
	jle	SHORT $LN21@apply_outp
$LL22@apply_outp:

; 3746 :         {
; 3747 :           kd_output_comp_info *oci = output_comp_info+block->output_indices[n];

	mov	eax, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [eax+edx*4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+20]

; 3748 :           if (!oci->is_of_interest)

	cmp	BYTE PTR [eax+ecx*8+32], 0
	lea	ecx, DWORD PTR [eax+ecx*8]
	je	SHORT $LN20@apply_outp

; 3749 :             continue; // This output is not required
; 3750 :           assert((oci->apparent_idx >= 0) && (oci->block == block));
; 3751 :           oci->apparent_block_comp_idx = block->num_apparent_outputs;

	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [ecx+28], eax

; 3752 :           block->num_apparent_outputs++;

	inc	DWORD PTR [edi+24]
$LN20@apply_outp:

; 3744 :       block->num_apparent_outputs = 0;
; 3745 :       for (n=0; n < block->num_outputs; n++)

	inc	edx
	cmp	edx, DWORD PTR [edi+20]
	jl	SHORT $LL22@apply_outp
$LN21@apply_outp:

; 3753 :         }
; 3754 :       if (block->num_apparent_outputs == 0)

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	$LN14@apply_outp

; 3755 :         continue; // This entire transform block is not required.
; 3756 :       if ((block->num_apparent_outputs == block->num_inputs) ||

	mov	ebx, DWORD PTR [edi+4]
	mov	DWORD PTR _unset_inputs$1$[ebp], ebx
	cmp	eax, ebx
	je	$LN90@apply_outp
	cmp	DWORD PTR [edi+44], 0
	jne	$LN90@apply_outp
	cmp	DWORD PTR [edi+48], 0
	jne	$LN90@apply_outp

; 3763 :             }
; 3764 :         }
; 3765 :       else if (block->triang_params != NULL)

	cmp	DWORD PTR [edi+52], 0
	je	SHORT $LN91@apply_outp

; 3766 :         { // Require a leading set of the inputs
; 3767 :           for (n=0; n < block->num_outputs; n++)

	mov	ebx, DWORD PTR [edi+20]
	xor	edx, edx
	test	ebx, ebx
	jle	SHORT $LN27@apply_outp

; 3768 :             if (output_comp_info[block->output_indices[n]].is_of_interest)

	mov	esi, DWORD PTR [edi+28]
$LL28@apply_outp:
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+20]
	cmp	BYTE PTR [eax+ecx*8+32], 0
	je	SHORT $LN26@apply_outp

; 3769 :               block->num_required_inputs = n+1;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [edi+8], eax
$LN26@apply_outp:

; 3766 :         { // Require a leading set of the inputs
; 3767 :           for (n=0; n < block->num_outputs; n++)

	inc	edx
	add	esi, 4
	cmp	edx, ebx
	jl	SHORT $LL28@apply_outp
$LN27@apply_outp:

; 3770 :           for (n=0; n < block->num_required_inputs; n++)

	xor	ecx, ecx
	cmp	DWORD PTR [edi+8], ecx
	jle	$LN24@apply_outp
$LL31@apply_outp:

; 3771 :             block->inputs_required[n] = true;

	mov	eax, DWORD PTR [edi+16]
	mov	BYTE PTR [ecx+eax], 1
	inc	ecx
	cmp	ecx, DWORD PTR [edi+8]
	jl	SHORT $LL31@apply_outp

; 3772 :         }
; 3773 :       else if (block->is_null_transform)

	jmp	$LN24@apply_outp
$LN91@apply_outp:
	cmp	BYTE PTR [edi+37], 0
	je	SHORT $LN94@apply_outp

; 3774 :         { // Require only those inputs which correspond to required outputs
; 3775 :           for (n=0; n < block->num_outputs; n++)

	xor	edx, edx
	cmp	DWORD PTR [edi+20], edx
	jle	$LN24@apply_outp
$LL34@apply_outp:

; 3776 :             if ((n < block->num_inputs) &&

	cmp	edx, DWORD PTR [edi+4]
	jge	SHORT $LN32@apply_outp
	mov	eax, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [eax+edx*4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax+ecx*8+32], 0
	je	SHORT $LN32@apply_outp

; 3777 :                 output_comp_info[block->output_indices[n]].is_of_interest)
; 3778 :               {
; 3779 :                 block->inputs_required[n] = true;                

	mov	eax, DWORD PTR [edi+16]
	mov	BYTE PTR [edx+eax], 1

; 3780 :                 block->num_required_inputs++;

	inc	DWORD PTR [edi+8]
$LN32@apply_outp:

; 3774 :         { // Require only those inputs which correspond to required outputs
; 3775 :           for (n=0; n < block->num_outputs; n++)

	inc	edx
	cmp	edx, DWORD PTR [edi+20]
	jl	SHORT $LL34@apply_outp

; 3781 :               }
; 3782 :         }
; 3783 :       else

	jmp	$LN24@apply_outp
$LN94@apply_outp:

; 3784 :         { // We have a DWT transform block, at least some of whose outputs
; 3785 :           // are not required.  Deducing the required set of inputs
; 3786 :           // in this case is a bit more difficult.
; 3787 :           int length = block->num_inputs;
; 3788 :           if (block->scratch == NULL)

	cmp	DWORD PTR [edi+104], 0
	jne	SHORT $LN97@apply_outp

; 3789 :             block->scratch = new float[length];

	xor	ecx, ecx
	mov	eax, ebx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [edi+104], eax
$LN97@apply_outp:

; 3790 :           bool *used = (bool *)(block->scratch);

	mov	ecx, DWORD PTR [edi+104]

; 3791 :           bool *expanded_scratch = used + length;
; 3792 :           for (n=0; n < length; n++)

	xor	edx, edx
	mov	DWORD PTR _used$1$[ebp], ecx
	lea	eax, DWORD PTR [ecx+ebx]
	mov	DWORD PTR _expanded_scratch$1$[ebp], eax
	test	ebx, ebx
	jle	SHORT $LN36@apply_outp
$LL37@apply_outp:

; 3793 :             used[n]=output_comp_info[block->output_indices[n]].is_of_interest;

	mov	eax, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [eax+edx*4]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+20]
	mov	al, BYTE PTR [eax+ecx*8+32]
	mov	ecx, DWORD PTR _used$1$[ebp]
	mov	BYTE PTR [ecx+edx], al
	inc	edx
	cmp	edx, ebx
	jl	SHORT $LL37@apply_outp
	mov	eax, DWORD PTR _expanded_scratch$1$[ebp]
$LN36@apply_outp:

; 3794 :           int c_min=block->dwt_canvas_origin;
; 3795 :           int lev_min=c_min, lev_lim=c_min+length;
; 3796 :           int unset_inputs=length; // Decreases as we process levels
; 3797 :           for (int lev=0; lev < block->dwt_num_levels; lev++)

	cmp	DWORD PTR [edi+60], 0
	mov	ebx, DWORD PTR [edi+64]
	mov	edx, DWORD PTR _unset_inputs$1$[ebp]
	mov	DWORD PTR _lev_min$1$[ebp], ebx
	mov	DWORD PTR _lev$1$[ebp], 0
	lea	esi, DWORD PTR [ebx+edx]
	mov	DWORD PTR _lev_lim$1$[ebp], esi
	jle	$LN39@apply_outp
	jmp	SHORT $LN40@apply_outp
$LL225@apply_outp:
	mov	ecx, DWORD PTR _used$1$[ebp]
$LN40@apply_outp:

; 3798 :             {
; 3799 :               used -= lev_min; // So we can use absolute indices
; 3800 :               bool *expanded = expanded_scratch - lev_min;

	mov	edx, eax
	sub	ecx, ebx
	sub	edx, ebx
	mov	DWORD PTR _used$1$[ebp], ecx
	mov	DWORD PTR _expanded$1$[ebp], edx

; 3801 : 
; 3802 :               int band_min, band_max, k, c;
; 3803 :               // Map the components used at this level from `used' into the
; 3804 :               // set of components which are required in each of the subbands,
; 3805 :               // storing the result in `expanded'.
; 3806 :               for (n=lev_min; n < lev_lim; n++)

	cmp	ebx, esi
	jge	SHORT $LN42@apply_outp
	mov	ecx, esi

; 3807 :                 expanded[n] = false;

	lea	edi, DWORD PTR [edx+ebx]
	sub	ecx, ebx
	xor	eax, eax
	mov	edx, ecx
	shr	ecx, 2
	rep stosd
	mov	ecx, edx
	and	ecx, 3
	rep stosb
	mov	edi, DWORD PTR _block$1$[ebp]
	mov	ecx, DWORD PTR _used$1$[ebp]
$LN42@apply_outp:

; 3808 :               for (n=lev_min; n < lev_lim; n++)

	mov	DWORD PTR _n$11$[ebp], ebx
	mov	eax, ebx
	cmp	ebx, esi
	jge	$LN45@apply_outp
$LL46@apply_outp:

; 3809 :                 if (used[n])

	cmp	BYTE PTR [ecx+eax], 0
	je	$LN44@apply_outp

; 3810 :                   { // Expand this one into its required subbands
; 3811 :                     // Start with low-pass subband
; 3812 :                     band_min = n - block->dwt_low_synth_max;
; 3813 :                     band_max = n - block->dwt_low_synth_min;

	mov	edx, eax
	mov	ecx, eax
	sub	edx, DWORD PTR [edi+80]
	sub	ecx, DWORD PTR [edi+84]

; 3814 :                     band_min += (band_min & 1);  band_max -= (band_max & 1);

	mov	eax, edx
	and	eax, 1
	sub	edx, eax
	mov	DWORD PTR _band_max$1$[ebp], edx
	mov	edx, ecx
	and	edx, 1
	add	edx, ecx

; 3815 :                     for (k=band_min; k <= band_max; k+=2)

	cmp	edx, DWORD PTR _band_max$1$[ebp]
	jg	SHORT $LN48@apply_outp
	npad	2
$LL49@apply_outp:

; 3816 :                       {
; 3817 :                         for (c=k; (c < lev_min) || (c >= lev_lim); )

	mov	ecx, edx
$LL50@apply_outp:
	cmp	ecx, ebx
	jl	SHORT $LN208@apply_outp
	cmp	ecx, esi
	jl	SHORT $LN51@apply_outp

; 3821 :                             c = 2*(lev_lim-1) - c;

	lea	eax, DWORD PTR [esi+esi]
	sub	eax, ecx
	lea	ecx, DWORD PTR [eax-2]
	jmp	SHORT $LL50@apply_outp
$LN208@apply_outp:

; 3818 :                           if (c < lev_min)
; 3819 :                             c = 2*lev_min - c;

	lea	eax, DWORD PTR [ebx+ebx]
	sub	eax, ecx
	mov	ecx, eax

; 3820 :                           else

	jmp	SHORT $LL50@apply_outp
$LN51@apply_outp:

; 3822 :                         expanded[c] = true;

	mov	eax, DWORD PTR _expanded$1$[ebp]
	add	edx, 2
	mov	BYTE PTR [ecx+eax], 1
	cmp	edx, DWORD PTR _band_max$1$[ebp]
	jle	SHORT $LL49@apply_outp
$LN48@apply_outp:

; 3823 :                       }
; 3824 : 
; 3825 :                     // Now for the high-pass subband
; 3826 :                     band_min = n - block->dwt_high_synth_max;

	mov	ecx, DWORD PTR _n$11$[ebp]
	mov	edx, ecx

; 3827 :                     band_max = n - block->dwt_high_synth_min;

	sub	ecx, DWORD PTR [edi+88]
	sub	edx, DWORD PTR [edi+92]

; 3828 :                     band_min += 1-(band_min & 1);  band_max -= 1-(band_max&1);

	mov	eax, ecx
	and	eax, 1
	dec	eax
	add	ecx, eax
	mov	eax, edx
	and	eax, 1
	mov	DWORD PTR _band_max$3$[ebp], ecx

; 3829 :                     for (k=band_min; k <= band_max; k+=2)

	sub	edx, eax
	inc	edx
	cmp	edx, ecx
	jg	SHORT $LN221@apply_outp
	mov	edi, ecx
$LL55@apply_outp:

; 3830 :                       {
; 3831 :                         for (c=k; (c < lev_min) || (c >= lev_lim); )

	mov	eax, edx
$LL56@apply_outp:
	cmp	eax, ebx
	jl	SHORT $LN207@apply_outp
	cmp	eax, esi
	jl	SHORT $LN57@apply_outp

; 3835 :                             c = 2*(lev_lim-1) - c;

	lea	ecx, DWORD PTR [esi+esi]
	sub	ecx, eax
	lea	eax, DWORD PTR [ecx-2]
	jmp	SHORT $LL56@apply_outp
$LN207@apply_outp:

; 3832 :                           if (c < lev_min)
; 3833 :                             c = 2*lev_min - c;

	lea	ecx, DWORD PTR [ebx+ebx]
	sub	ecx, eax
	mov	eax, ecx

; 3834 :                           else

	jmp	SHORT $LL56@apply_outp
$LN57@apply_outp:

; 3836 :                         expanded[c] = true;

	mov	ecx, DWORD PTR _expanded$1$[ebp]
	add	edx, 2
	mov	BYTE PTR [eax+ecx], 1
	cmp	edx, edi
	jle	SHORT $LL55@apply_outp
	mov	edi, DWORD PTR _block$1$[ebp]
$LN221@apply_outp:
	mov	ecx, DWORD PTR _used$1$[ebp]
	mov	eax, DWORD PTR _n$11$[ebp]
$LN44@apply_outp:

; 3808 :               for (n=lev_min; n < lev_lim; n++)

	inc	eax
	mov	DWORD PTR _n$11$[ebp], eax
	cmp	eax, esi
	jl	$LL46@apply_outp
$LN45@apply_outp:

; 3837 :                       }
; 3838 :                   }
; 3839 : 
; 3840 :               // Transfer high-pass subband entries to the end of the
; 3841 :               // `inputs_required' array.
; 3842 :               band_min = lev_min + 1-(lev_min & 1);

	mov	eax, ebx
	mov	ecx, ebx
	and	eax, 1

; 3843 :               band_max = (lev_lim-1) - (lev_lim & 1);
; 3844 :               for (n=band_max; n >= band_min; n-=2)

	mov	edx, esi
	sub	ecx, eax
	mov	eax, esi
	and	eax, 1
	inc	ecx
	sub	edx, eax
	mov	DWORD PTR _band_min$3$[ebp], ecx
	dec	edx
	cmp	edx, ecx
	jl	SHORT $LN60@apply_outp
	mov	esi, DWORD PTR _expanded$1$[ebp]
	npad	2
$LL61@apply_outp:

; 3845 :                 {
; 3846 :                   assert(unset_inputs > 0);
; 3847 :                   block->inputs_required[--unset_inputs] = expanded[n];

	dec	DWORD PTR _unset_inputs$1$[ebp]
	mov	ecx, DWORD PTR [edi+16]
	mov	al, BYTE PTR [esi+edx]
	mov	ebx, DWORD PTR _unset_inputs$1$[ebp]
	mov	BYTE PTR [ebx+ecx], al

; 3848 :                   block->num_required_inputs += (expanded[n])?1:0;

	xor	eax, eax
	cmp	BYTE PTR [esi+edx], al
	setne	al
	sub	edx, 2
	add	DWORD PTR [edi+8], eax
	cmp	edx, DWORD PTR _band_min$3$[ebp]
	jge	SHORT $LL61@apply_outp
	mov	esi, DWORD PTR _lev_lim$1$[ebp]
	mov	ebx, DWORD PTR _lev_min$1$[ebp]
$LN60@apply_outp:

; 3849 :                 }
; 3850 : 
; 3851 :               // Transfer low-pass subband entries from `expanded' to `used'
; 3852 :               used += lev_min;     // Restore to true array base

	mov	eax, DWORD PTR _used$1$[ebp]

; 3853 :               lev_min = (lev_min+1)>>1;
; 3854 :               lev_lim = (lev_lim+1)>>1;

	inc	esi
	add	eax, ebx
	sar	esi, 1
	inc	ebx
	mov	DWORD PTR _used$1$[ebp], eax
	sar	ebx, 1
	mov	DWORD PTR _lev_min$1$[ebp], ebx

; 3855 :               for (n=lev_min; n < lev_lim; n++)

	mov	ecx, ebx
	mov	DWORD PTR _lev_lim$1$[ebp], esi
	cmp	ebx, esi
	jge	SHORT $LN38@apply_outp
	mov	edi, DWORD PTR _expanded$1$[ebp]
	mov	edx, eax
	sub	edx, ebx
	npad	7
$LL64@apply_outp:

; 3856 :                 used[n-lev_min] = expanded[2*n];

	mov	al, BYTE PTR [edi+ecx*2]
	mov	BYTE PTR [edx+ecx], al
	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LL64@apply_outp
	mov	edi, DWORD PTR _block$1$[ebp]
$LN38@apply_outp:

; 3794 :           int c_min=block->dwt_canvas_origin;
; 3795 :           int lev_min=c_min, lev_lim=c_min+length;
; 3796 :           int unset_inputs=length; // Decreases as we process levels
; 3797 :           for (int lev=0; lev < block->dwt_num_levels; lev++)

	mov	eax, DWORD PTR _lev$1$[ebp]
	inc	eax
	cmp	eax, DWORD PTR [edi+60]
	mov	DWORD PTR _lev$1$[ebp], eax
	mov	eax, DWORD PTR _expanded_scratch$1$[ebp]
	jl	$LL225@apply_outp
	mov	edx, DWORD PTR _unset_inputs$1$[ebp]
$LN39@apply_outp:

; 3857 :             }
; 3858 : 
; 3859 :           // At this point we have only to write the low-pass subband flags out
; 3860 :           // to the remaining inputs
; 3861 :           used -= lev_min;

	mov	eax, DWORD PTR _used$1$[ebp]

; 3862 :           for (n=lev_lim-1; n >= lev_min; n--)

	dec	esi
	sub	eax, ebx
	mov	DWORD PTR _used$1$[ebp], eax
	cmp	esi, ebx
	jl	SHORT $LN24@apply_outp
$LL67@apply_outp:

; 3863 :             {
; 3864 :               assert(unset_inputs > 0);
; 3865 :               block->inputs_required[--unset_inputs] = used[n];

	mov	al, BYTE PTR [eax+esi]
	lea	edx, DWORD PTR [edx-1]
	mov	ecx, DWORD PTR [edi+16]
	mov	BYTE PTR [edx+ecx], al

; 3866 :               block->num_required_inputs += (used[n])?1:0;

	xor	eax, eax
	mov	ecx, DWORD PTR _used$1$[ebp]
	cmp	BYTE PTR [ecx+esi], al
	setne	al
	dec	esi
	add	DWORD PTR [edi+8], eax
	mov	eax, ecx
	cmp	esi, ebx
	jge	SHORT $LL67@apply_outp

; 3677 :     {
; 3678 :       assert(global_comp_info != NULL);
; 3679 :       for (n=0; n < num_outputs; n++)

	jmp	SHORT $LN24@apply_outp
$LN90@apply_outp:

; 3757 :           ((block->matrix_params != NULL) || (block->old_mat_params != NULL)))
; 3758 :         { // Require all inputs
; 3759 :           for (n=0; n < block->num_inputs; n++)

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN24@apply_outp
	npad	6
$LL25@apply_outp:

; 3760 :             {
; 3761 :               block->inputs_required[n] = true;

	mov	eax, DWORD PTR [edi+16]
	mov	BYTE PTR [ecx+eax], 1
	inc	ecx

; 3762 :               block->num_required_inputs++;

	inc	DWORD PTR [edi+8]
	cmp	ecx, DWORD PTR [edi+4]
	jl	SHORT $LL25@apply_outp
$LN24@apply_outp:

; 3867 :             }
; 3868 :           assert(unset_inputs == 0);
; 3869 :         }
; 3870 : 
; 3871 :       // Now transfer the required input flags from `block' to the stage
; 3872 :       for (n=0; n < block->num_inputs; n++)

	xor	edx, edx
	cmp	DWORD PTR [edi+4], edx
	jle	SHORT $LN223@apply_outp
	npad	9
$LL70@apply_outp:

; 3873 :         if (block->inputs_required[n])

	mov	eax, DWORD PTR [edi+16]

; 3874 :           input_required_indices[block->input_indices[n]] = 0;

	mov	esi, DWORD PTR _this$1$[ebp]
	cmp	BYTE PTR [edx+eax], 0
	je	SHORT $LN68@apply_outp
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*4], 0
$LN68@apply_outp:

; 3867 :             }
; 3868 :           assert(unset_inputs == 0);
; 3869 :         }
; 3870 : 
; 3871 :       // Now transfer the required input flags from `block' to the stage
; 3872 :       for (n=0; n < block->num_inputs; n++)

	inc	edx
	cmp	edx, DWORD PTR [edi+4]
	jl	SHORT $LL70@apply_outp
	jmp	SHORT $LN14@apply_outp
$LN223@apply_outp:
	mov	esi, DWORD PTR _this$1$[ebp]
$LN14@apply_outp:

; 3737 :   for (b=0; b < num_blocks; b++)

	mov	eax, DWORD PTR _b$1$[ebp]
	inc	eax
	mov	DWORD PTR _b$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+24]
	jl	$LL16@apply_outp
$LN15@apply_outp:

; 3875 :                      // We use 0 to temporarily mark the component as required
; 3876 :     }
; 3877 : 
; 3878 :   // Now enter the correct ordinal values in all non-negative entries of the
; 3879 :   // `input_required_indices' array.
; 3880 :   assert(num_required_inputs == 0);
; 3881 :   for (n=0; n < num_inputs; n++)

	xor	ecx, ecx
	cmp	DWORD PTR [esi], ecx
	jle	SHORT $LN72@apply_outp
	npad	3
$LL73@apply_outp:
	mov	eax, DWORD PTR [esi+8]

; 3882 :     if (input_required_indices[n] >= 0)

	cmp	DWORD PTR [eax+ecx*4], 0
	lea	edx, DWORD PTR [eax+ecx*4]
	jl	SHORT $LN71@apply_outp

; 3883 :       input_required_indices[n] = num_required_inputs++;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx], eax
	inc	DWORD PTR [esi+4]
$LN71@apply_outp:

; 3875 :                      // We use 0 to temporarily mark the component as required
; 3876 :     }
; 3877 : 
; 3878 :   // Now enter the correct ordinal values in all non-negative entries of the
; 3879 :   // `input_required_indices' array.
; 3880 :   assert(num_required_inputs == 0);
; 3881 :   for (n=0; n < num_inputs; n++)

	inc	ecx
	cmp	ecx, DWORD PTR [esi]
	jl	SHORT $LL73@apply_outp
$LN72@apply_outp:

; 3884 : 
; 3885 :   // Recursively invoke the function on the previous stage, if any
; 3886 :   if (prev_stage != NULL)

	mov	esi, DWORD PTR [esi+32]
	mov	DWORD PTR _this$1$[ebp], esi
	test	esi, esi
	je	SHORT $LN107@apply_outp

; 3887 :     prev_stage->apply_output_restrictions(NULL);

	mov	eax, DWORD PTR _this$1$[ebp]
	xor	ebx, ebx
	xor	esi, esi
	xor	ecx, ecx
	jmp	$LL109@apply_outp
$LN107@apply_outp:
	pop	edi
	pop	esi
	pop	ebx

; 3888 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?apply_output_restrictions@kd_mct_stage@@QAEXPAUkd_output_comp_info@@HPBH@Z ENDP ; kd_mct_stage::apply_output_restrictions
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_mct_stage@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_mct_stage@@QAE@XZ PROC				; kd_mct_stage::~kd_mct_stage, COMDAT
; _this$ = ecx

; 2135 :       {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_mct_stage@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 2136 :         if (input_required_indices != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@kd_mct_sta

; 2137 :           delete[] input_required_indices;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_mct_sta:

; 2138 :         if (output_comp_info != NULL) delete[] output_comp_info;

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN3@kd_mct_sta
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@kd_mct_sta:

; 2139 :         if (blocks != NULL) delete[] blocks;

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN11@kd_mct_sta
	push	OFFSET ??1kd_mct_block@@QAE@XZ		; kd_mct_block::~kd_mct_block
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	108					; 0000006cH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [esi], 108
	add	eax, 4
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN11@kd_mct_sta:

; 2140 :       }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1kd_mct_stage@@QAE@XZ$0:
	call	___std_terminate
	ret	0
__ehhandler$??1kd_mct_stage@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_mct_stage@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_mct_stage@@QAE@XZ ENDP				; kd_mct_stage::~kd_mct_stage
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_mct_stage@@QAE@XZ
_TEXT	SEGMENT
??0kd_mct_stage@@QAE@XZ PROC				; kd_mct_stage::kd_mct_stage, COMDAT
; _this$ = ecx

; 2133 :     kd_mct_stage() { memset(this,0,sizeof(*this)); }

	xorps	xmm0, xmm0
	mov	eax, ecx
	movups	XMMWORD PTR [ecx], xmm0
	movups	XMMWORD PTR [ecx+16], xmm0
	movq	QWORD PTR [ecx+32], xmm0
	ret	0
??0kd_mct_stage@@QAE@XZ ENDP				; kd_mct_stage::kd_mct_stage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z
_TEXT	SEGMENT
_e$2 = -952						; size = 20
_high_hlen$3 = -932					; size = 4
_low_hlen$4 = -928					; size = 4
$T5 = -924						; size = 4
_aux2$6 = -920						; size = 4
_head$GSCopy$1$ = -916					; size = 4
_mcc_idx$7 = -912					; size = 4
_mcc_root$1$ = -908					; size = 4
_mco$1$ = -904						; size = 4
_in_to$8 = -900						; size = 4
_off_idx$9 = -896					; size = 4
_mct_flags$ = -892					; size = 4
_out_to$10 = -888					; size = 4
_mct_root$1$ = -884					; size = 4
_output_comp_info$GSCopy$1$ = -880			; size = 4
_tail$GSCopy$1$ = -876					; size = 4
_stage_num$1$ = -872					; size = 4
_root$GSCopy$1$ = -868					; size = 4
_in_range_idx$1$ = -864					; size = 4
_num_stages$ = -860					; size = 4
_xform_idx$11 = -856					; size = 4
_aux1$12 = -852						; size = 4
_out_from$13 = -848					; size = 4
_in_from$14 = -844					; size = 4
tv2315 = -840						; size = 4
$T15 = -840						; size = 4
$T16 = -840						; size = 4
$T17 = -840						; size = 4
$T18 = -840						; size = 4
$T19 = -840						; size = 4
$T20 = -840						; size = 4
_out_range_idx$1$ = -836				; size = 4
tv2269 = -836						; size = 4
_tnum$GSCopy$1$ = -832					; size = 4
_block_type$21 = -828					; size = 4
_m$1$ = -824						; size = 4
_n$1$ = -824						; size = 4
_b$3$ = -824						; size = 4
$T22 = -820						; size = 4
$T23 = -816						; size = 4
$T24 = -816						; size = 4
tv2275 = -816						; size = 4
tv2230 = -816						; size = 4
_i_val$25 = -812					; size = 4
_e$26 = -808						; size = 20
_e$27 = -808						; size = 20
_e$28 = -808						; size = 20
_e$29 = -808						; size = 20
_e$30 = -808						; size = 20
_e$31 = -808						; size = 20
_e$32 = -808						; size = 20
_e$33 = -808						; size = 20
_e$34 = -808						; size = 20
_e$35 = -808						; size = 20
_e$36 = -808						; size = 20
_mcc$ = -788						; size = 4
_tri_coeffs$1$ = -784					; size = 4
_mat_coeffs$1$ = -784					; size = 4
_block$1$ = -784					; size = 4
tv2229 = -784						; size = 4
_n$5$ = -780						; size = 4
_b$2$ = -780						; size = 4
_kernels$37 = -776					; size = 600
_text$38 = -176						; size = 80
_text$39 = -176						; size = 80
_text$40 = -176						; size = 80
_text$41 = -96						; size = 80
_text$42 = -96						; size = 80
_text$43 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_head$ = 8						; size = 4
_tail$ = 12						; size = 4
_root$ = 16						; size = 4
_tnum$ = 20						; size = 4
_num_input_components$ = 24				; size = 4
_input_comp_info$ = 28					; size = 4
_num_output_components$ = 32				; size = 4
_output_comp_info$ = 36					; size = 4
?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z PROC ; kd_mct_stage::create_stages, COMDAT

; 3290 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 940				; 000003acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edx, DWORD PTR _head$[ebp]
	mov	edi, DWORD PTR _tail$[ebp]
	mov	ecx, DWORD PTR _root$[ebp]
	mov	eax, DWORD PTR _output_comp_info$[ebp]
	mov	esi, DWORD PTR _tnum$[ebp]

; 3291 :   head = tail = NULL;

	mov	DWORD PTR [edi], 0

; 3292 : 
; 3293 :   // Start by accessing the MCO object which describes the transform stages
; 3294 :   kdu_params *cod, *mco, *mco_root = root->access_cluster(MCO_params);

	push	OFFSET ??_C@_03LCPIMAFA@MCO?$AA@
	mov	DWORD PTR _head$GSCopy$1$[ebp], edx
	mov	DWORD PTR _tail$GSCopy$1$[ebp], edi
	mov	DWORD PTR _root$GSCopy$1$[ebp], ecx
	mov	DWORD PTR _tnum$GSCopy$1$[ebp], esi
	mov	DWORD PTR _output_comp_info$GSCopy$1$[ebp], eax
	mov	DWORD PTR [edx], 0
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 3295 :   int num_stages = 0;

	mov	DWORD PTR _num_stages$[ebp], 0

; 3296 :   if ((mco_root == NULL) ||
; 3297 :       ((mco = mco_root->access_relation(tnum,-1,0,true)) == NULL) ||
; 3298 :       (!mco->get(Mnum_stages,0,0,num_stages)) || (num_stages == 0) ||
; 3299 :       ((cod = root->access_cluster(COD_params)) == NULL) ||

	test	eax, eax
	je	$LN42@create_sta
	push	1
	push	0
	push	-1
	push	esi
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	DWORD PTR _mco$1$[ebp], eax
	test	eax, eax
	je	$LN42@create_sta
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _num_stages$[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0M@BMJAMMCN@Mnum_stages?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN42@create_sta
	cmp	DWORD PTR _num_stages$[ebp], 0
	je	$LN42@create_sta
	mov	ecx, DWORD PTR _root$GSCopy$1$[ebp]
	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster
	test	eax, eax
	je	$LN42@create_sta
	push	1
	push	0
	push	-1
	push	esi
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	test	eax, eax
	je	$LN42@create_sta

; 3300 :       ((cod = cod->access_relation(tnum,-1,0,true)) == NULL))
; 3301 :     return;
; 3302 :   int mct_flags = 0;  cod->get(Cmct,0,0,mct_flags);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _mct_flags$[ebp]
	mov	DWORD PTR _mct_flags$[ebp], 0
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_04OOAAMMCO@Cmct?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 3303 : 
; 3304 :   // Now walk through the stages
; 3305 :   int stage_num, b, n, m;
; 3306 :   kdu_params *mcc, *mcc_root = root->access_cluster(MCC_params);

	mov	ecx, DWORD PTR _root$GSCopy$1$[ebp]
	push	OFFSET ??_C@_03BOENIPFM@MCC?$AA@
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 3307 :   kdu_params *mct_root = root->access_cluster(MCT_params);

	mov	ecx, DWORD PTR _root$GSCopy$1$[ebp]
	push	OFFSET ??_C@_03BLMOALMK@MCT?$AA@
	mov	DWORD PTR _mcc_root$1$[ebp], eax
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 3308 :   for (stage_num=0; stage_num < num_stages; stage_num++)

	xor	ecx, ecx
	mov	DWORD PTR _mct_root$1$[ebp], eax
	mov	DWORD PTR _stage_num$1$[ebp], ecx
	cmp	DWORD PTR _num_stages$[ebp], ecx
	jle	$LN3@create_sta
	jmp	SHORT $LN4@create_sta
	npad	8
$LL271@create_sta:
	mov	esi, DWORD PTR _tnum$GSCopy$1$[ebp]
$LN4@create_sta:

; 3309 :     {
; 3310 :       int mcc_idx, i_val;
; 3311 :       if ((!mco->get(Mstages,stage_num,0,mcc_idx)) || (mcc_root == NULL) ||
; 3312 :           ((mcc = mcc_root->access_relation(tnum,-1,mcc_idx,true)) == NULL) ||

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _mcc_idx$7[ebp]
	push	eax
	push	0
	push	ecx
	mov	ecx, DWORD PTR _mco$1$[ebp]
	push	OFFSET ??_C@_07CNNLMAHC@Mstages?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN45@create_sta
	mov	eax, DWORD PTR _mcc_root$1$[ebp]
	test	eax, eax
	je	SHORT $LN45@create_sta
	push	1
	push	DWORD PTR _mcc_idx$7[ebp]
	mov	ecx, eax
	push	-1
	push	esi
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	esi, eax
	mov	DWORD PTR _mcc$[ebp], esi
	test	esi, esi
	je	SHORT $LN45@create_sta
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _i_val$25[ebp]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN45@create_sta
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _i_val$25[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN43@create_sta
$LN45@create_sta:

; 3315 :         { KDU_ERROR(e,0x08080502); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$36[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$36[ebp]
	lea	ecx, DWORD PTR _e$36[ebp]
	push	OFFSET ??_C@_0CL@PILHNAFH@Unable?5to?5access?5the?5description@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3315 :         { KDU_ERROR(e,0x08080502); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3317 :             << stage_num <<

	push	DWORD PTR _stage_num$1$[ebp]
	lea	ecx, DWORD PTR _e$36[ebp]
	call	??6kdu_message@@QAEAAV0@H@Z		; kdu_message::operator<<
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0PF@HDJMLNFB@?5?$CIstarting?5from?50?$CJ?5in?5the?5multi?9@
	mov	ecx, eax
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3323 :         }

	lea	ecx, DWORD PTR _e$36[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN43@create_sta:

; 3324 :       kd_mct_stage *stage = new kd_mct_stage;

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	mov	DWORD PTR $T22[ebp], eax
	add	esp, 4
	mov	DWORD PTR $T20[ebp], esi
	test	esi, esi
	je	SHORT $LN104@create_sta
	xorps	xmm0, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2133 :     kd_mct_stage() { memset(this,0,sizeof(*this)); }

	movups	XMMWORD PTR [esi], xmm0
	movups	XMMWORD PTR [esi+16], xmm0
	movq	QWORD PTR [esi+32], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3324 :       kd_mct_stage *stage = new kd_mct_stage;

	jmp	SHORT $LN105@create_sta
$LN104@create_sta:
	xor	esi, esi
	mov	DWORD PTR $T22[ebp], esi
$LN105@create_sta:

; 3325 :       stage->prev_stage = tail;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+32], eax

; 3326 :       if (tail == NULL)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN46@create_sta

; 3327 :         head = tail = stage;

	mov	eax, DWORD PTR _head$GSCopy$1$[ebp]
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [eax], esi

; 3328 :       else

	jmp	SHORT $LN47@create_sta
$LN46@create_sta:

; 3329 :         tail = tail->next_stage = stage;

	mov	DWORD PTR [eax+36], esi
	mov	DWORD PTR [edi], esi
$LN47@create_sta:

; 3330 : 
; 3331 :       for (b=1; mcc->get(Mstage_blocks,b,0,i_val) &&

	mov	ecx, DWORD PTR _mcc$[ebp]
	lea	eax, DWORD PTR _i_val$25[ebp]
	mov	edi, 1
	push	edi
	push	edi
	push	edi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN6@create_sta
	mov	esi, DWORD PTR _mcc$[ebp]
	npad	5
$LL7@create_sta:
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _i_val$25[ebp]
	mov	ecx, esi
	push	eax
	push	1
	push	edi
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN266@create_sta
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _i_val$25[ebp]

; 3332 :                 mcc->get(Mstage_blocks,b,1,i_val); b++);

	inc	edi
	push	eax
	push	0
	push	edi
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	mov	ecx, esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LL7@create_sta
$LN266@create_sta:
	mov	esi, DWORD PTR $T22[ebp]
$LN6@create_sta:

; 3333 :       stage->num_blocks = b;
; 3334 :       stage->blocks = new kd_mct_block[stage->num_blocks];

	xor	ecx, ecx
	mov	DWORD PTR [esi+24], edi
	mov	eax, edi
	mov	DWORD PTR $T19[ebp], edi
	mov	edx, 108				; 0000006cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN106@create_sta
	push	OFFSET ??1kd_mct_block@@QAE@XZ		; kd_mct_block::~kd_mct_block
	push	OFFSET ??0kd_mct_block@@QAE@XZ		; kd_mct_block::kd_mct_block
	push	edi
	mov	DWORD PTR [eax], edi
	add	eax, 4
	push	108					; 0000006cH
	push	eax
	mov	DWORD PTR $T24[ebp], eax
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	mov	eax, DWORD PTR $T24[ebp]
	jmp	SHORT $LN107@create_sta
$LN106@create_sta:
	xor	eax, eax
$LN107@create_sta:
	mov	DWORD PTR [esi+28], eax

; 3335 :       
; 3336 :       int in_from=0, in_to=-1, in_range_idx=0;
; 3337 :       int out_from=0, out_to=-1, out_range_idx=0;
; 3338 :       for (b=0; b < stage->num_blocks; b++)

	xor	ecx, ecx
	mov	DWORD PTR _in_from$14[ebp], 0
	mov	DWORD PTR _in_to$8[ebp], -1
	mov	DWORD PTR _out_from$13[ebp], 0
	mov	DWORD PTR _out_to$10[ebp], -1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR _in_range_idx$1$[ebp], 0
	mov	DWORD PTR _out_range_idx$1$[ebp], 0
	mov	DWORD PTR _b$2$[ebp], ecx
	cmp	DWORD PTR [esi+24], ecx
	jle	$LN9@create_sta

; 3333 :       stage->num_blocks = b;
; 3334 :       stage->blocks = new kd_mct_block[stage->num_blocks];

	xor	eax, eax
	mov	DWORD PTR tv2275[ebp], eax
	npad	1
$LL10@create_sta:

; 3339 :         {
; 3340 :           kd_mct_block *block = stage->blocks + b;

	mov	edi, DWORD PTR [esi+28]

; 3341 :           block->stage = stage;
; 3342 :           mcc->get(Mstage_blocks,b,0,block->num_inputs);

	push	1
	add	edi, eax
	push	1
	push	1
	mov	DWORD PTR _block$1$[ebp], edi
	lea	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi], esi
	push	eax
	push	0
	push	ecx
	mov	ecx, DWORD PTR _mcc$[ebp]
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 3343 :           mcc->get(Mstage_blocks,b,1,block->num_outputs);

	mov	ecx, DWORD PTR _mcc$[ebp]
	lea	eax, DWORD PTR [edi+20]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	DWORD PTR _b$2$[ebp]
	mov	DWORD PTR tv2315[ebp], eax
	push	OFFSET ??_C@_0BD@ONKCHMLA@Mstage_collections?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 3344 :           if ((block->num_inputs < 1) || (block->num_outputs < 1))

	cmp	DWORD PTR [edi+4], 1
	jl	SHORT $LN49@create_sta
	cmp	DWORD PTR [edi+20], 1
	lea	eax, DWORD PTR [edi+20]
	jge	SHORT $LN48@create_sta
$LN49@create_sta:

; 3345 :             { KDU_ERROR(e,0x08080503); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$35[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$35[ebp]
	lea	ecx, DWORD PTR _e$35[ebp]
	push	OFFSET ??_C@_0JM@EMODBKHC@Multi?9component?5transform?5blocks@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3345 :             { KDU_ERROR(e,0x08080503); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3349 :             }

	lea	ecx, DWORD PTR _e$35[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	lea	eax, DWORD PTR [edi+20]
$LN48@create_sta:

; 3350 :           if ((block->num_inputs > 16384) || (block->num_outputs > 16384))

	cmp	DWORD PTR [edi+4], 16384		; 00004000H
	jg	SHORT $LN51@create_sta
	cmp	DWORD PTR [eax], 16384			; 00004000H
	jle	SHORT $LN50@create_sta
$LN51@create_sta:

; 3351 :             { KDU_ERROR(e,0x06110802); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$34[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$34[ebp]
	lea	ecx, DWORD PTR _e$34[ebp]
	push	OFFSET ??_C@_0KO@EOEMFLGL@Multi?9component?5transform?5block?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3351 :             { KDU_ERROR(e,0x06110802); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3356 :             }

	lea	ecx, DWORD PTR _e$34[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN50@create_sta:

; 3357 :           block->input_indices = new int[block->num_inputs];

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+12], eax

; 3358 :           block->output_indices = new int[block->num_outputs];

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi+20]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 3359 :           for (n=0; n < block->num_inputs; n++)

	xor	edx, edx
	mov	DWORD PTR [edi+28], eax
	add	esp, 8
	mov	DWORD PTR _n$1$[ebp], edx
	cmp	DWORD PTR [edi+4], edx
	jle	$LN12@create_sta
	mov	ecx, DWORD PTR _in_from$14[ebp]
$LL13@create_sta:

; 3360 :             {
; 3361 :               if (in_to < in_from)

	cmp	DWORD PTR _in_to$8[ebp], ecx
	jge	SHORT $LN52@create_sta

; 3362 :                 {
; 3363 :                   if (!(mcc->get(Mstage_inputs,in_range_idx,0,in_from) &&

	mov	ecx, DWORD PTR _mcc$[ebp]
	lea	eax, DWORD PTR _in_from$14[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	DWORD PTR _in_range_idx$1$[ebp]
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN54@create_sta
	mov	ecx, DWORD PTR _mcc$[ebp]
	lea	eax, DWORD PTR _in_to$8[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	DWORD PTR _in_range_idx$1$[ebp]
	push	OFFSET ??_C@_0O@BOOPOFOH@Mstage_inputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN54@create_sta:

; 3364 :                         mcc->get(Mstage_inputs,in_range_idx,1,in_to) &&
; 3365 :                         (in_to >= in_from) && (in_from >= 0)))
; 3366 :                     assert(0); // Should be caught by `mcc_params::finalize'
; 3367 :                   in_range_idx++;

	inc	DWORD PTR _in_range_idx$1$[ebp]
	mov	ecx, DWORD PTR _in_from$14[ebp]
	mov	edx, DWORD PTR _n$1$[ebp]
$LN52@create_sta:

; 3368 :                 }
; 3369 :               block->input_indices[n] = in_from;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+edx*4], ecx

; 3370 :               if (in_from >= stage->num_inputs)

	mov	ecx, DWORD PTR _in_from$14[ebp]
	cmp	ecx, DWORD PTR [esi]
	jl	SHORT $LN55@create_sta

; 3371 :                 stage->num_inputs = in_from+1;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR _in_from$14[ebp]
$LN55@create_sta:

; 3372 :               in_from++;

	inc	ecx
	inc	edx
	mov	DWORD PTR _in_from$14[ebp], ecx
	mov	DWORD PTR _n$1$[ebp], edx
	cmp	edx, DWORD PTR [edi+4]
	jl	$LL13@create_sta
$LN12@create_sta:

; 3373 :             }
; 3374 :           for (m=0; m < block->num_outputs; m++)

	xor	edx, edx
	mov	DWORD PTR _m$1$[ebp], edx
	cmp	DWORD PTR [edi+20], edx
	jle	$LN15@create_sta
	mov	ecx, DWORD PTR _out_from$13[ebp]
$LL16@create_sta:

; 3375 :             {
; 3376 :               if (out_to < out_from)

	cmp	DWORD PTR _out_to$10[ebp], ecx
	jge	SHORT $LN56@create_sta

; 3377 :                 {
; 3378 :                   if (!(mcc->get(Mstage_outputs,out_range_idx,0,out_from) &&

	mov	ecx, DWORD PTR _mcc$[ebp]
	lea	eax, DWORD PTR _out_from$13[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	DWORD PTR _out_range_idx$1$[ebp]
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN58@create_sta
	mov	ecx, DWORD PTR _mcc$[ebp]
	lea	eax, DWORD PTR _out_to$10[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	DWORD PTR _out_range_idx$1$[ebp]
	push	OFFSET ??_C@_0P@HHFGMPDO@Mstage_outputs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN58@create_sta:

; 3379 :                         mcc->get(Mstage_outputs,out_range_idx,1,out_to) &&
; 3380 :                         (out_to >= out_from) && (out_from >= 0)))
; 3381 :                     assert(0); // Should be caught by `mcc_params::finalize'
; 3382 :                   out_range_idx++;

	inc	DWORD PTR _out_range_idx$1$[ebp]
	mov	ecx, DWORD PTR _out_from$13[ebp]
	mov	edx, DWORD PTR _m$1$[ebp]
$LN56@create_sta:

; 3383 :                 }
; 3384 :               block->output_indices[m] = out_from;

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [eax+edx*4], ecx

; 3385 :               if (out_from >= stage->num_outputs)

	mov	ecx, DWORD PTR _out_from$13[ebp]
	cmp	ecx, DWORD PTR [esi+12]
	jl	SHORT $LN59@create_sta

; 3386 :                 stage->num_outputs = out_from+1;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR _out_from$13[ebp]
$LN59@create_sta:

; 3387 :               out_from++;

	inc	ecx
	inc	edx
	mov	DWORD PTR _out_from$13[ebp], ecx
	mov	DWORD PTR _m$1$[ebp], edx
	cmp	edx, DWORD PTR [edi+20]
	jl	$LL16@create_sta
$LN15@create_sta:

; 3388 :             }
; 3389 : 
; 3390 :           block->is_null_transform = true; // Until proven otherwise
; 3391 : 
; 3392 :           if (tnum < 0)

	cmp	DWORD PTR _tnum$GSCopy$1$[ebp], 0
	mov	BYTE PTR [edi+37], 1
	jl	$LN8@create_sta

; 3393 :             continue; // No need to access the transform coefficients or even
; 3394 :                       // the transform type unless we are in a tile.
; 3395 : 
; 3396 :           int block_type, xform_idx, off_idx, aux1, aux2;
; 3397 :           if (!(mcc->get(Mstage_xforms,b,0,block_type) &&

	mov	ecx, DWORD PTR _mcc$[ebp]
	lea	eax, DWORD PTR _block_type$21[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	DWORD PTR _b$2$[ebp]
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN62@create_sta
	mov	ecx, DWORD PTR _mcc$[ebp]
	lea	eax, DWORD PTR _xform_idx$11[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	DWORD PTR _b$2$[ebp]
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN62@create_sta
	mov	ecx, DWORD PTR _mcc$[ebp]
	lea	eax, DWORD PTR _off_idx$9[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	2
	push	DWORD PTR _b$2$[ebp]
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN62@create_sta
	mov	ecx, DWORD PTR _mcc$[ebp]
	lea	eax, DWORD PTR _aux1$12[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	3
	push	DWORD PTR _b$2$[ebp]
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN62@create_sta
	mov	ecx, DWORD PTR _mcc$[ebp]
	lea	eax, DWORD PTR _aux2$6[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	4
	push	DWORD PTR _b$2$[ebp]
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN62@create_sta:

; 3398 :                 mcc->get(Mstage_xforms,b,1,xform_idx) &&
; 3399 :                 mcc->get(Mstage_xforms,b,2,off_idx) &&
; 3400 :                 mcc->get(Mstage_xforms,b,3,aux1) &&
; 3401 :                 mcc->get(Mstage_xforms,b,4,aux2)))
; 3402 :             assert(0); // Should have been caught by `mcc_params::finalize'
; 3403 : 
; 3404 :           if ((block_type == Mxform_MATRIX) && (mct_flags == 0) && (aux1 != 0))

	mov	ecx, DWORD PTR _block_type$21[ebp]
	cmp	ecx, 9
	jne	SHORT $LN264@create_sta
	cmp	DWORD PTR _mct_flags$[ebp], 0
	jne	SHORT $LN264@create_sta
	cmp	DWORD PTR _aux1$12[ebp], 0
	je	SHORT $LN264@create_sta

; 3405 :             mcc->set(Mstage_xforms,b,0,block_type=Mxform_MAT);

	mov	ecx, DWORD PTR _mcc$[ebp]
	push	1000					; 000003e8H
	push	0
	push	DWORD PTR _b$2$[ebp]
	mov	DWORD PTR _block_type$21[ebp], 1000	; 000003e8H
	push	OFFSET ??_C@_0O@FPIFFAOF@Mstage_xforms?$AA@
	call	?set@kdu_params@@QAEXPBDHHH@Z		; kdu_params::set
	mov	ecx, DWORD PTR _block_type$21[ebp]
$LN264@create_sta:

; 3406 : 
; 3407 :           if ((off_idx != 0) &&

	mov	eax, DWORD PTR _off_idx$9[ebp]
	test	eax, eax
	je	$LN270@create_sta
	mov	ecx, DWORD PTR _mct_root$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN65@create_sta
	push	1
	push	eax
	push	-1
	push	DWORD PTR _tnum$GSCopy$1$[ebp]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	DWORD PTR [edi+40], eax
	test	eax, eax
	je	SHORT $LN65@create_sta
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _i_val$25[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0N@EBBFOCKJ@Mvector_size?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN65@create_sta
	mov	eax, DWORD PTR _i_val$25[ebp]
	lea	edx, DWORD PTR [edi+20]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN65@create_sta

; 3424 :             }

	mov	ecx, DWORD PTR _block_type$21[ebp]
	jmp	$LN64@create_sta
$LN65@create_sta:

; 3413 :             { KDU_ERROR(e,0x08080504); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$33[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$33[ebp]
	lea	ecx, DWORD PTR _e$33[ebp]
	push	OFFSET ??_C@_0KO@HEFENJF@Unable?5to?5access?5the?5offset?5para@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3413 :             { KDU_ERROR(e,0x08080504); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$33[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _off_idx$9[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$40[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$40[ebp]
	lea	ecx, DWORD PTR _e$33[ebp]
	push	eax
	mov	eax, DWORD PTR _e$33[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$33[ebp]
	lea	ecx, DWORD PTR _e$33[ebp]
	push	OFFSET ??_C@_0M@KNDNPDMI@?5and?5value?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$33[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR [edi+20]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$43[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$43[ebp]
	lea	ecx, DWORD PTR _e$33[ebp]
	push	eax
	mov	eax, DWORD PTR _e$33[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$33[ebp]
	lea	ecx, DWORD PTR _e$33[ebp]
	push	OFFSET ??_C@_0HA@CPLCDADH@?0?5corresponding?5to?5the?5number?5of@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3424 :             }

	lea	ecx, DWORD PTR _e$33[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _block_type$21[ebp]
$LN270@create_sta:
	lea	edx, DWORD PTR [edi+20]
$LN64@create_sta:

; 3425 : 
; 3426 :           if ((block->num_inputs != block->num_outputs) &&

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN66@create_sta
	cmp	ecx, 9
	je	SHORT $LN68@create_sta
	cmp	ecx, 1000				; 000003e8H
	jne	SHORT $LN67@create_sta
$LN68@create_sta:
	cmp	DWORD PTR _aux1$12[ebp], 0
	je	SHORT $LN66@create_sta
$LN67@create_sta:

; 3429 :             { KDU_ERROR(e,0x08080505); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$32[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$32[ebp]
	lea	ecx, DWORD PTR _e$32[ebp]
	push	OFFSET ??_C@_0PM@HMICKPCP@Except?5for?5irreversible?5matrix?9b@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3429 :             { KDU_ERROR(e,0x08080505); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3435 :             }

	lea	ecx, DWORD PTR _e$32[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _block_type$21[ebp]
$LN66@create_sta:

; 3436 : 
; 3437 :           if ((block_type == Mxform_MATRIX) || (block_type == Mxform_MAT))

	cmp	ecx, 9
	je	$LN71@create_sta
	cmp	ecx, 1000				; 000003e8H
	je	$LN71@create_sta

; 3471 :                 }
; 3472 :             }
; 3473 :           else if (block_type == Mxform_DEP)

	test	ecx, ecx
	jne	$LN77@create_sta

; 3474 :             {
; 3475 :               block->is_reversible = (aux1 != 0);
; 3476 :               int tri_coeffs = (block->num_outputs*(block->num_outputs-1)) / 2;

	mov	eax, DWORD PTR tv2315[ebp]
	cmp	DWORD PTR _aux1$12[ebp], ecx
	setne	cl
	mov	edx, DWORD PTR [eax]
	mov	BYTE PTR [edi+36], cl
	lea	eax, DWORD PTR [edx-1]
	imul	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _tri_coeffs$1$[ebp], eax

; 3477 :               if (block->is_reversible)

	test	cl, cl
	je	SHORT $LN79@create_sta

; 3478 :                 tri_coeffs += block->num_outputs-1;

	dec	eax
	add	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _tri_coeffs$1$[ebp], eax
$LN79@create_sta:

; 3479 :               if ((xform_idx != 0) &&

	mov	eax, DWORD PTR _xform_idx$11[ebp]
	test	eax, eax
	je	$LN80@create_sta
	mov	ecx, DWORD PTR _mct_root$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN81@create_sta
	push	1
	push	eax
	push	-1
	push	DWORD PTR _tnum$GSCopy$1$[ebp]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	DWORD PTR [edi+52], eax
	test	eax, eax
	je	SHORT $LN81@create_sta
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _i_val$25[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0N@CCNKIJHO@Mtriang_size?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN81@create_sta
	mov	eax, DWORD PTR _tri_coeffs$1$[ebp]
	cmp	DWORD PTR _i_val$25[ebp], eax
	je	$LN80@create_sta
$LN81@create_sta:

; 3486 :                 { KDU_ERROR(e,0x08080507); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$30[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$30[ebp]
	lea	ecx, DWORD PTR _e$30[ebp]
	push	OFFSET ??_C@_0KO@HBMKDEMJ@Unable?5to?5access?5the?5matrix?5para@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3486 :                 { KDU_ERROR(e,0x08080507); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$30[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _xform_idx$11[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$41[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$41[ebp]
	lea	ecx, DWORD PTR _e$30[ebp]
	push	eax
	mov	eax, DWORD PTR _e$30[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$30[ebp]
	lea	ecx, DWORD PTR _e$30[ebp]
	push	OFFSET ??_C@_0M@KNDNPDMI@?5and?5value?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$30[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _tri_coeffs$1$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$38[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$38[ebp]
	lea	ecx, DWORD PTR _e$30[ebp]
	push	eax
	mov	eax, DWORD PTR _e$30[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$30[ebp]
	lea	ecx, DWORD PTR _e$30[ebp]
	push	OFFSET ??_C@_0BIH@NMGBAOPH@?0?5corresponding?5to?5the?5total?5num@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3502 :                 }

	lea	ecx, DWORD PTR _e$30[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN80@create_sta:

; 3503 :               if (block->triang_params != NULL)

	cmp	DWORD PTR [edi+52], 0
	je	$LN8@create_sta

; 3504 :                 block->is_null_transform = false;

	mov	BYTE PTR [edi+37], 0

; 3505 :             }

	jmp	$LN8@create_sta
$LN77@create_sta:

; 3506 :           else if ((block_type == Mxform_DWT) && (aux1 > 0))

	cmp	ecx, 3
	jne	$LN8@create_sta
	cmp	DWORD PTR _aux1$12[ebp], 0
	jle	$LN8@create_sta

; 3507 :             {
; 3508 :               block->is_null_transform = false;

	mov	BYTE PTR [edi+37], 0

; 3509 :               block->dwt_num_levels = aux1;
; 3510 :               block->dwt_canvas_origin = aux2;
; 3511 :               int kernel_id = (xform_idx < 2)?xform_idx:Ckernels_ATK;
; 3512 :               kd_create_dwt_description(kernel_id,xform_idx,root,tnum,

	lea	edx, DWORD PTR [edi+76]
	mov	eax, DWORD PTR _aux1$12[ebp]
	lea	esi, DWORD PTR [edi+69]
	mov	DWORD PTR [edi+60], eax
	or	ecx, -1
	mov	eax, DWORD PTR _aux2$6[ebp]
	push	edx
	mov	DWORD PTR [edi+64], eax
	mov	eax, DWORD PTR _block$1$[ebp]
	cmp	DWORD PTR _xform_idx$11[ebp], 2
	cmovl	ecx, DWORD PTR _xform_idx$11[ebp]
	add	edi, 68					; 00000044H
	lea	edx, DWORD PTR [eax+72]
	push	edx
	lea	edx, DWORD PTR [eax+56]
	push	edx
	push	esi
	push	edi
	lea	edx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR _xform_idx$11[ebp]
	push	edx
	push	DWORD PTR _tnum$GSCopy$1$[ebp]
	push	DWORD PTR _root$GSCopy$1$[ebp]
	push	eax
	push	ecx
	call	?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z ; kd_create_dwt_description
	add	esp, 40					; 00000028H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 135  :     kdu_kernels() { clear(); }

	lea	ecx, DWORD PTR _kernels$37[ebp]
	call	?clear@kdu_kernels@@AAEXXZ		; kdu_kernels::clear
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3517 :               kernels.init(block->dwt_num_steps,block->dwt_step_info,

	mov	ecx, DWORD PTR _block$1$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	movzx	eax, BYTE PTR [ecx+36]
	push	eax
	movzx	eax, BYTE PTR [esi]
	mov	esi, ecx
	push	eax
	movzx	eax, BYTE PTR [edi]
	lea	ecx, DWORD PTR _kernels$37[ebp]
	push	eax
	push	DWORD PTR [esi+76]
	push	DWORD PTR [esi+72]
	push	DWORD PTR [esi+56]
	call	?init@kdu_kernels@@QAEXHPBUkdu_kernel_step_info@@PBM_N22@Z ; kdu_kernels::init

; 3518 :                            block->dwt_coefficients,block->dwt_symmetric,
; 3519 :                            block->dwt_symmetric_extension,
; 3520 :                            block->is_reversible);
; 3521 :               int low_hlen, high_hlen, nstps;
; 3522 :               kernels.get_impulse_response(KDU_SYNTHESIS_LOW,low_hlen,

	lea	eax, DWORD PTR [esi+84]
	push	eax
	lea	eax, DWORD PTR [esi+80]
	push	eax
	lea	eax, DWORD PTR _low_hlen$4[ebp]
	push	eax
	push	2
	lea	ecx, DWORD PTR _kernels$37[ebp]
	call	?get_impulse_response@kdu_kernels@@QAEPAMW4kdu_kernel_type@@AAHPAH2@Z ; kdu_kernels::get_impulse_response

; 3523 :                                            &(block->dwt_low_synth_min),
; 3524 :                                            &(block->dwt_low_synth_max));
; 3525 :               kernels.get_impulse_response(KDU_SYNTHESIS_HIGH,high_hlen,

	lea	eax, DWORD PTR [esi+92]
	push	eax
	lea	eax, DWORD PTR [esi+88]
	push	eax
	lea	eax, DWORD PTR _high_hlen$3[ebp]
	push	eax
	push	3
	lea	ecx, DWORD PTR _kernels$37[ebp]
	call	?get_impulse_response@kdu_kernels@@QAEPAMW4kdu_kernel_type@@AAHPAH2@Z ; kdu_kernels::get_impulse_response

; 3526 :                                            &(block->dwt_high_synth_min),
; 3527 :                                            &(block->dwt_high_synth_max));
; 3528 :               if (block->is_reversible)

	cmp	BYTE PTR [esi+36], 0
	je	SHORT $LN84@create_sta

; 3529 :                 block->dwt_synth_gains[0] = block->dwt_synth_gains[1] = 1.0F;

	mov	DWORD PTR [esi+100], 1065353216		; 3f800000H
	mov	DWORD PTR [esi+96], 1065353216		; 3f800000H

; 3530 :               else

	jmp	SHORT $LN85@create_sta
$LN84@create_sta:

; 3531 :                 {
; 3532 :                   kernels.get_lifting_factors(nstps,block->dwt_synth_gains[0],
; 3533 :                                               block->dwt_synth_gains[1]);
; 3534 :                   assert(nstps == block->dwt_num_steps);
; 3535 :                   block->dwt_synth_gains[0] = 1.0F / block->dwt_synth_gains[0];

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _kernels$37[ebp+24]
	movss	DWORD PTR [esi+96], xmm0

; 3536 :                   block->dwt_synth_gains[1] = 0.5F / block->dwt_synth_gains[1];

	movss	xmm0, DWORD PTR __real@3f000000
	divss	xmm0, DWORD PTR _kernels$37[ebp+28]
	movss	DWORD PTR [esi+100], xmm0
$LN85@create_sta:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 147  :     ~kdu_kernels() { reset(); }

	lea	ecx, DWORD PTR _kernels$37[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	call	?reset@kdu_kernels@@AAEXXZ		; kdu_kernels::reset
	mov	esi, DWORD PTR $T22[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	$LN8@create_sta
$LN71@create_sta:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3439 :               block->is_reversible = (aux1 != 0);

	cmp	DWORD PTR _aux1$12[ebp], 0

; 3440 :               int mat_coeffs = block->num_inputs * block->num_outputs;

	mov	ecx, DWORD PTR [edi+20]
	mov	edx, DWORD PTR [edi+4]
	setne	al
	imul	ecx, edx
	mov	BYTE PTR [edi+36], al
	mov	DWORD PTR _mat_coeffs$1$[ebp], ecx

; 3441 :               if (block->is_reversible)

	test	al, al
	je	SHORT $LN72@create_sta

; 3442 :                 mat_coeffs += block->num_inputs;

	add	ecx, edx
	mov	DWORD PTR _mat_coeffs$1$[ebp], ecx
$LN72@create_sta:

; 3443 :               if ((xform_idx != 0) &&

	mov	eax, DWORD PTR _xform_idx$11[ebp]
	test	eax, eax
	je	$LN73@create_sta
	mov	ecx, DWORD PTR _mct_root$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN74@create_sta
	push	1
	push	eax
	push	-1
	push	DWORD PTR _tnum$GSCopy$1$[ebp]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	DWORD PTR [edi+44], eax
	test	eax, eax
	je	SHORT $LN74@create_sta
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _i_val$25[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0N@FIDBGNAL@Mmatrix_size?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN74@create_sta
	mov	eax, DWORD PTR _mat_coeffs$1$[ebp]
	cmp	DWORD PTR _i_val$25[ebp], eax
	je	$LN73@create_sta
$LN74@create_sta:

; 3450 :                 { KDU_ERROR(e,0x08080506); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$31[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$31[ebp]
	lea	ecx, DWORD PTR _e$31[ebp]
	push	OFFSET ??_C@_0KO@JDHHKMLN@Unable?5to?5access?5the?5matrix?5para@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3450 :                 { KDU_ERROR(e,0x08080506); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$31[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _xform_idx$11[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$42[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$42[ebp]
	lea	ecx, DWORD PTR _e$31[ebp]
	push	eax
	mov	eax, DWORD PTR _e$31[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$31[ebp]
	lea	ecx, DWORD PTR _e$31[ebp]
	push	OFFSET ??_C@_0M@KNDNPDMI@?5and?5value?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$31[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR _mat_coeffs$1$[ebp]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$39[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$39[ebp]
	lea	ecx, DWORD PTR _e$31[ebp]
	push	eax
	mov	eax, DWORD PTR _e$31[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$31[ebp]
	lea	ecx, DWORD PTR _e$31[ebp]
	push	OFFSET ??_C@_0BBM@IKPPNJIM@?0?5corresponding?5to?5the?5total?5num@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3464 :                 }

	lea	ecx, DWORD PTR _e$31[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN73@create_sta:

; 3465 :               if (block->matrix_params != NULL)

	mov	eax, DWORD PTR [edi+44]
	test	eax, eax
	je	SHORT $LN75@create_sta

; 3466 :                 block->is_null_transform = false;

	mov	BYTE PTR [edi+37], 0
$LN75@create_sta:

; 3467 :               if ((block_type == Mxform_MAT) && block->is_reversible)

	cmp	DWORD PTR _block_type$21[ebp], 1000	; 000003e8H
	jne	SHORT $LN8@create_sta
	cmp	BYTE PTR [edi+36], 0
	je	SHORT $LN8@create_sta

; 3468 :                 {
; 3469 :                   block->old_mat_params = block->matrix_params;

	mov	DWORD PTR [edi+48], eax

; 3470 :                   block->matrix_params = NULL;

	mov	DWORD PTR [edi+44], 0
$LN8@create_sta:

; 3335 :       
; 3336 :       int in_from=0, in_to=-1, in_range_idx=0;
; 3337 :       int out_from=0, out_to=-1, out_range_idx=0;
; 3338 :       for (b=0; b < stage->num_blocks; b++)

	mov	ecx, DWORD PTR _b$2$[ebp]
	mov	eax, DWORD PTR tv2275[ebp]
	inc	ecx
	add	eax, 108				; 0000006cH
	mov	DWORD PTR _b$2$[ebp], ecx
	mov	DWORD PTR tv2275[ebp], eax
	cmp	ecx, DWORD PTR [esi+24]
	jl	$LL10@create_sta
$LN9@create_sta:

; 3537 :                 }
; 3538 :             }
; 3539 :         }
; 3540 : 
; 3541 :       // Once we get here, all the transform blocks have been parsed and
; 3542 :       // we know the value of `stage->num_inputs' and
; 3543 :       // `stage->num_outputs'.  Now we can allocate the input and
; 3544 :       // output information arrays and fill in their contents.
; 3545 :       if ((stage->num_inputs > 65535) || (stage->num_outputs > 65535))

	cmp	DWORD PTR [esi], 65535			; 0000ffffH
	jg	SHORT $LN87@create_sta
	cmp	DWORD PTR [esi+12], 65535		; 0000ffffH
	jle	SHORT $LN86@create_sta
$LN87@create_sta:

; 3546 :         { KDU_ERROR(e,0x06110803); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$29[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$29[ebp]
	lea	ecx, DWORD PTR _e$29[ebp]
	push	OFFSET ??_C@_0JG@ECJLCCBG@Multi?9component?5transform?5stage?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3546 :         { KDU_ERROR(e,0x06110803); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3550 :         }

	lea	ecx, DWORD PTR _e$29[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN86@create_sta:

; 3551 :       if ((stage->prev_stage != NULL) &&

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	$LN88@create_sta
	mov	edi, DWORD PTR [esi]
	cmp	edi, DWORD PTR [eax+12]
	jle	$LN88@create_sta

; 3557 :             new kd_output_comp_info[stage->num_inputs];

	xor	ecx, ecx
	mov	DWORD PTR $T18[ebp], edi
	mov	eax, edi
	mov	edx, 40					; 00000028H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T23[ebp], edx
	mov	DWORD PTR $T17[ebp], edx
	test	edx, edx
	je	SHORT $LN108@create_sta
	test	edi, edi
	je	SHORT $LN109@create_sta
	lea	ecx, DWORD PTR [edx+8]
	npad	4
$LL181@create_sta:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1826 :         precision=0; is_signed=false; subsampling_ref = NULL;

	mov	DWORD PTR [ecx-8], 0
	lea	ecx, DWORD PTR [ecx+40]
	mov	BYTE PTR [ecx-44], 0
	mov	DWORD PTR [ecx-40], 0

; 1827 :         apparent_idx=-1; from_apparent=0;

	mov	DWORD PTR [ecx-36], -1
	mov	DWORD PTR [ecx-32], 0

; 1828 :         block=NULL; block_comp_idx=0; apparent_block_comp_idx=0;

	mov	DWORD PTR [ecx-28], 0
	mov	DWORD PTR [ecx-24], 0
	mov	DWORD PTR [ecx-20], 0

; 1829 :         is_of_interest=false; ss_tmp=0.0F;

	mov	BYTE PTR [ecx-16], 0
	mov	DWORD PTR [ecx-12], 0
	sub	edi, 1
	jne	SHORT $LL181@create_sta
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3557 :             new kd_output_comp_info[stage->num_inputs];

	jmp	SHORT $LN109@create_sta
$LN108@create_sta:
	xor	edx, edx
	mov	DWORD PTR $T23[ebp], edx
$LN109@create_sta:

; 3558 :           for (n=0; n < stage->prev_stage->num_outputs; n++)

	mov	eax, DWORD PTR [esi+32]
	xor	edi, edi
	cmp	DWORD PTR [eax+12], edi
	jle	SHORT $LN18@create_sta
	xor	ecx, ecx
	npad	2
$LL19@create_sta:

; 3559 :             new_outputs[n] = stage->prev_stage->output_comp_info[n];

	mov	eax, DWORD PTR [esi+32]
	lea	ecx, DWORD PTR [ecx+40]
	inc	edi
	mov	eax, DWORD PTR [eax+20]
	movups	xmm0, XMMWORD PTR [eax+ecx-40]
	movups	XMMWORD PTR [ecx+edx-40], xmm0
	movups	xmm0, XMMWORD PTR [eax+ecx-24]
	movups	XMMWORD PTR [ecx+edx-24], xmm0
	movq	xmm0, QWORD PTR [eax+ecx-8]
	movq	QWORD PTR [ecx+edx-8], xmm0
	mov	eax, DWORD PTR [esi+32]
	cmp	edi, DWORD PTR [eax+12]
	jl	SHORT $LL19@create_sta
$LN18@create_sta:

; 3560 :           stage->prev_stage->num_outputs = stage->num_inputs;

	mov	ecx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx+12], eax

; 3561 :           delete[] stage->prev_stage->output_comp_info;

	mov	eax, DWORD PTR [esi+32]
	push	DWORD PTR [eax+20]
	call	??_V@YAXPAX@Z				; operator delete[]

; 3562 :           stage->prev_stage->output_comp_info = new_outputs;

	mov	eax, DWORD PTR [esi+32]
	add	esp, 4
	mov	ecx, DWORD PTR $T23[ebp]
	mov	DWORD PTR [eax+20], ecx
$LN88@create_sta:

; 3563 :         }
; 3564 : 
; 3565 :       stage->input_required_indices = new int[stage->num_inputs];

	mov	eax, DWORD PTR [esi]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 3566 :       for (n=0; n < stage->num_inputs; n++)

	xor	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	add	esp, 4
	cmp	DWORD PTR [esi], ecx
	jle	SHORT $LN21@create_sta
	npad	8
$LL22@create_sta:

; 3567 :         stage->input_required_indices[n] = -1; // Change this later

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*4], -1
	inc	ecx
	cmp	ecx, DWORD PTR [esi]
	jl	SHORT $LL22@create_sta
$LN21@create_sta:

; 3568 :       if ((stage_num == (num_stages-1)) &&

	mov	eax, DWORD PTR _num_stages$[ebp]
	dec	eax
	cmp	DWORD PTR _stage_num$1$[ebp], eax
	jne	SHORT $LN89@create_sta
	mov	eax, DWORD PTR _num_output_components$[ebp]
	cmp	DWORD PTR [esi+12], eax
	jge	SHORT $LN89@create_sta

; 3569 :           (stage->num_outputs < num_output_components))
; 3570 :         stage->num_outputs = num_output_components;

	mov	DWORD PTR [esi+12], eax
$LN89@create_sta:

; 3571 :       stage->output_comp_info =

	mov	edi, DWORD PTR [esi+12]
	xor	ecx, ecx
	mov	eax, edi
	mov	DWORD PTR $T16[ebp], edi
	mov	edx, 40					; 00000028H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T15[ebp], eax
	test	eax, eax
	je	SHORT $LN110@create_sta
	test	edi, edi
	je	SHORT $LN111@create_sta
	lea	ecx, DWORD PTR [eax+8]
	npad	2
$LL187@create_sta:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1826 :         precision=0; is_signed=false; subsampling_ref = NULL;

	mov	DWORD PTR [ecx-8], 0
	lea	ecx, DWORD PTR [ecx+40]
	mov	BYTE PTR [ecx-44], 0
	mov	DWORD PTR [ecx-40], 0

; 1827 :         apparent_idx=-1; from_apparent=0;

	mov	DWORD PTR [ecx-36], -1
	mov	DWORD PTR [ecx-32], 0

; 1828 :         block=NULL; block_comp_idx=0; apparent_block_comp_idx=0;

	mov	DWORD PTR [ecx-28], 0
	mov	DWORD PTR [ecx-24], 0
	mov	DWORD PTR [ecx-20], 0

; 1829 :         is_of_interest=false; ss_tmp=0.0F;

	mov	BYTE PTR [ecx-16], 0
	mov	DWORD PTR [ecx-12], 0
	sub	edi, 1
	jne	SHORT $LL187@create_sta
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3571 :       stage->output_comp_info =

	jmp	SHORT $LN111@create_sta
$LN110@create_sta:
	xor	eax, eax
$LN111@create_sta:

; 3572 :         new kd_output_comp_info[stage->num_outputs];
; 3573 :       for (b=0; b < stage->num_blocks; b++)

	cmp	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR _b$3$[ebp], 0
	jle	$LN24@create_sta

; 3571 :       stage->output_comp_info =

	xor	ecx, ecx
	mov	DWORD PTR tv2269[ebp], ecx
	npad	5
$LL25@create_sta:

; 3574 :         {
; 3575 :           kd_mct_block *block = stage->blocks + b;

	mov	edi, DWORD PTR [esi+28]
	add	edi, ecx

; 3576 :           block->inputs_required = new bool[block->num_inputs];

	push	DWORD PTR [edi+4]
	call	??_U@YAPAXI@Z				; operator new[]

; 3577 :           for (n=0; n < block->num_inputs; n++)

	xor	edx, edx
	mov	DWORD PTR [edi+16], eax
	add	esp, 4
	cmp	DWORD PTR [edi+4], edx
	jle	SHORT $LN27@create_sta
	npad	6
$LL28@create_sta:

; 3578 :             {
; 3579 :               block->inputs_required[n] = false; // Change this later

	mov	eax, DWORD PTR [edi+16]
	mov	BYTE PTR [edx+eax], 0

; 3580 :               stage->input_required_indices[block->input_indices[n]] =

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [eax+edx*4]
	inc	edx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+ecx*4], ecx
	cmp	edx, DWORD PTR [edi+4]
	jl	SHORT $LL28@create_sta
$LN27@create_sta:

; 3581 :                 block->input_indices[n];
; 3582 :                 // Above statement lets us check that all inputs are "touched",
; 3583 :                 // as required by the standard.
; 3584 :             }
; 3585 :           kd_comp_info *last_ref = NULL;
; 3586 :              // Use this to provide a `subsampling_ref' value for output
; 3587 :              // components whose input component is not available.
; 3588 :           for (n=0; n < block->num_outputs; n++)

	xor	ecx, ecx
	xor	esi, esi
	mov	DWORD PTR _n$5$[ebp], ecx
	cmp	DWORD PTR [edi+20], ecx
	jle	$LN23@create_sta
	npad	4
$LL31@create_sta:

; 3589 :             {
; 3590 :               kd_output_comp_info *oci =
; 3591 :                 stage->output_comp_info + block->output_indices[n];

	mov	eax, DWORD PTR [edi+28]
	mov	edx, DWORD PTR $T22[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR tv2230[ebp], ecx
	lea	eax, DWORD PTR [eax+eax*4]

; 3592 :               if (oci->block != NULL)

	cmp	DWORD PTR [ecx+eax*8+20], 0
	mov	ecx, DWORD PTR _n$5$[ebp]
	mov	DWORD PTR tv2229[ebp], eax
	je	SHORT $LN90@create_sta

; 3593 :                 { KDU_ERROR(e,0x09080500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$28[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$28[ebp]
	lea	ecx, DWORD PTR _e$28[ebp]
	push	OFFSET ??_C@_0IM@HJCMNLOE@Multi?9component?5transform?5stage?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3593 :                 { KDU_ERROR(e,0x09080500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3597 :                 }

	lea	ecx, DWORD PTR _e$28[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _n$5$[ebp]
	mov	eax, DWORD PTR tv2229[ebp]
$LN90@create_sta:

; 3598 :               oci->block = block;

	mov	edx, DWORD PTR tv2230[ebp]
	mov	DWORD PTR [edx+eax*8+20], edi

; 3599 :               oci->block_comp_idx = n;

	mov	DWORD PTR [edx+eax*8+24], ecx

; 3600 :               if (n < block->num_inputs)

	mov	edx, DWORD PTR $T22[ebp]
	cmp	ecx, DWORD PTR [edi+4]
	jge	SHORT $LN94@create_sta

; 3601 :                 {
; 3602 :                   kd_mct_stage *ps = stage->prev_stage;
; 3603 :                   m = block->input_indices[n];
; 3604 :                   if (ps == NULL)

	cmp	DWORD PTR [edx+32], 0
	mov	eax, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [eax+ecx*4]
	jne	SHORT $LN92@create_sta

; 3605 :                     last_ref = input_comp_info + m;

	lea	esi, DWORD PTR [eax+eax*2]
	shl	esi, 5
	add	esi, DWORD PTR _input_comp_info$[ebp]
	jmp	SHORT $LN273@create_sta
$LN92@create_sta:

; 3606 :                   else if (ps->output_comp_info[m].subsampling_ref != NULL)

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+32]
	mov	eax, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [eax+ecx*8+8]
	test	eax, eax
	mov	ecx, DWORD PTR _n$5$[ebp]
	cmovne	esi, eax
$LN273@create_sta:
	mov	eax, DWORD PTR tv2229[ebp]
$LN94@create_sta:

; 3607 :                     last_ref = ps->output_comp_info[m].subsampling_ref;
; 3608 :                 }
; 3609 :               oci->subsampling_ref = last_ref;

	mov	edx, DWORD PTR tv2230[ebp]
	mov	DWORD PTR [edx+eax*8+8], esi

; 3610 :               if (last_ref != NULL)

	mov	edx, DWORD PTR $T22[ebp]
	test	esi, esi
	je	SHORT $LN29@create_sta

; 3611 :                 for (m=n-1; m >= 0; m--)

	add	ecx, -1
	js	SHORT $LN269@create_sta
	npad	5
$LL34@create_sta:

; 3612 :                   {
; 3613 :                     oci = stage->output_comp_info + block->output_indices[m];

	mov	eax, DWORD PTR [edi+28]
	mov	edx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+eax*4]

; 3614 :                     if (oci->subsampling_ref != NULL)

	cmp	DWORD PTR [edx+eax*8+8], 0
	jne	SHORT $LN269@create_sta

; 3615 :                       break;
; 3616 :                     oci->subsampling_ref = last_ref;

	sub	ecx, 1
	mov	DWORD PTR [edx+eax*8+8], esi
	mov	edx, DWORD PTR $T22[ebp]
	jns	SHORT $LL34@create_sta
$LN269@create_sta:
	mov	ecx, DWORD PTR _n$5$[ebp]
$LN29@create_sta:

; 3581 :                 block->input_indices[n];
; 3582 :                 // Above statement lets us check that all inputs are "touched",
; 3583 :                 // as required by the standard.
; 3584 :             }
; 3585 :           kd_comp_info *last_ref = NULL;
; 3586 :              // Use this to provide a `subsampling_ref' value for output
; 3587 :              // components whose input component is not available.
; 3588 :           for (n=0; n < block->num_outputs; n++)

	inc	ecx
	mov	DWORD PTR _n$5$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+20]
	jl	$LL31@create_sta
$LN23@create_sta:

; 3572 :         new kd_output_comp_info[stage->num_outputs];
; 3573 :       for (b=0; b < stage->num_blocks; b++)

	mov	eax, DWORD PTR _b$3$[ebp]
	mov	esi, DWORD PTR $T22[ebp]
	inc	eax
	mov	ecx, DWORD PTR tv2269[ebp]
	add	ecx, 108				; 0000006cH
	mov	DWORD PTR _b$3$[ebp], eax
	mov	DWORD PTR tv2269[ebp], ecx
	cmp	eax, DWORD PTR [esi+24]
	jl	$LL25@create_sta
$LN24@create_sta:

; 3617 :                   }
; 3618 :             }
; 3619 :         }
; 3620 :       for (n=0; n < stage->num_inputs; n++)

	mov	edx, DWORD PTR [esi]
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN268@create_sta

; 3621 :         if (stage->input_required_indices[n] < 0)

	mov	ecx, DWORD PTR [esi+8]
	npad	2
$LL37@create_sta:
	cmp	DWORD PTR [ecx], 0
	jl	SHORT $LN268@create_sta

; 3617 :                   }
; 3618 :             }
; 3619 :         }
; 3620 :       for (n=0; n < stage->num_inputs; n++)

	inc	eax
	add	ecx, 4
	cmp	eax, edx
	jl	SHORT $LL37@create_sta
$LN268@create_sta:

; 3622 :           break;
; 3623 :       if ((n < stage->num_inputs) ||
; 3624 :           ((stage->prev_stage == NULL) &&
; 3625 :            (stage->num_inputs != num_input_components)) ||

	cmp	eax, edx
	jl	SHORT $LN99@create_sta
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	jne	SHORT $LN275@create_sta
	cmp	edx, DWORD PTR _num_input_components$[ebp]
	jne	SHORT $LN99@create_sta
	test	eax, eax
	je	SHORT $LN2@create_sta
$LN275@create_sta:
	cmp	edx, DWORD PTR [eax+12]
	jge	SHORT $LN2@create_sta
$LN99@create_sta:

; 3628 :         { KDU_ERROR(e,0x09080501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$27[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$27[ebp]
	lea	ecx, DWORD PTR _e$27[ebp]
	push	OFFSET ??_C@_0BBI@DKKKDOEN@Multi?9component?5transform?5does?5n@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3628 :         { KDU_ERROR(e,0x09080501); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3634 :         }

	lea	ecx, DWORD PTR _e$27[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@create_sta:

; 3308 :   for (stage_num=0; stage_num < num_stages; stage_num++)

	mov	ecx, DWORD PTR _stage_num$1$[ebp]
	mov	edi, DWORD PTR _tail$GSCopy$1$[ebp]
	inc	ecx
	mov	DWORD PTR _stage_num$1$[ebp], ecx
	cmp	ecx, DWORD PTR _num_stages$[ebp]
	jl	$LL271@create_sta
$LN3@create_sta:

; 3635 :     }
; 3636 :   if (tail->num_outputs > num_output_components)

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _num_output_components$[ebp]
	cmp	DWORD PTR [eax+12], ecx
	jle	SHORT $LN101@create_sta

; 3637 :     { KDU_ERROR(e,0x09080502); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$26[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$26[ebp]
	lea	ecx, DWORD PTR _e$26[ebp]
	push	OFFSET ??_C@_0KL@GPKLLFMI@The?5last?5stage?5of?5the?5multi?9comp@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3637 :     { KDU_ERROR(e,0x09080502); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3641 :     }

	lea	ecx, DWORD PTR _e$26[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN101@create_sta:

; 3642 :   for (n=0; n < tail->num_outputs; n++)

	mov	edx, DWORD PTR _tail$GSCopy$1$[ebp]
	xor	edi, edi
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+12], edi
	jle	$LN39@create_sta
	xor	esi, esi
	npad	2
$LL40@create_sta:

; 3643 :     {
; 3644 :       tail->output_comp_info[n].is_signed = output_comp_info[n].is_signed;
; 3645 :       tail->output_comp_info[n].precision = output_comp_info[n].precision;
; 3646 :       if ((tnum < 0) &&

	cmp	DWORD PTR _tnum$GSCopy$1$[ebp], 0
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _output_comp_info$GSCopy$1$[ebp]
	mov	al, BYTE PTR [eax+esi+4]
	mov	BYTE PTR [ecx+esi+4], al
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _output_comp_info$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+esi]
	mov	DWORD PTR [esi+ecx], eax
	jge	SHORT $LN38@create_sta
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+20]
	cmp	DWORD PTR [eax+esi+8], 0
	jne	SHORT $LN38@create_sta

; 3648 :         { KDU_ERROR(e,0x09080503); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BHN@CGGDHAAL@Although?5not?5strictly?5illegal?0?5t@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3648 :         { KDU_ERROR(e,0x09080503); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3656 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	edx, DWORD PTR _tail$GSCopy$1$[ebp]
$LN38@create_sta:

; 3642 :   for (n=0; n < tail->num_outputs; n++)

	mov	eax, DWORD PTR [edx]
	inc	edi
	add	esi, 40					; 00000028H
	cmp	edi, DWORD PTR [eax+12]
	jl	$LL40@create_sta
$LN39@create_sta:

; 3657 :     }
; 3658 : 
; 3659 :   tail->apply_output_restrictions(output_comp_info);

	mov	ecx, DWORD PTR [edx]
	push	0
	push	0
	push	DWORD PTR _output_comp_info$GSCopy$1$[ebp]
	call	?apply_output_restrictions@kd_mct_stage@@QAEXPAUkd_output_comp_info@@HPBH@Z ; kd_mct_stage::apply_output_restrictions
$LN42@create_sta:

; 3660 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$0:
	lea	ecx, DWORD PTR _e$36[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$2:
	xor	ebx, ebx
	mov	eax, DWORD PTR $T19[ebp]
	mov	ecx, 108				; 0000006cH
	mul	ecx
	seto	bl
	neg	ebx
	or	ebx, eax
	xor	eax, eax
	add	ebx, 4
	setb	al
	neg	eax
	or	eax, ebx
	push	eax
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$3:
	lea	ecx, DWORD PTR _e$35[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$4:
	lea	ecx, DWORD PTR _e$34[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$5:
	lea	ecx, DWORD PTR _e$33[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$6:
	lea	ecx, DWORD PTR _e$32[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$8:
	lea	ecx, DWORD PTR _e$30[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$9:
	lea	ecx, DWORD PTR _kernels$37[ebp]
	jmp	??1kdu_kernels@@QAE@XZ			; kdu_kernels::~kdu_kernels
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$17:
	call	___std_terminate
	ret	0
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$7:
	lea	ecx, DWORD PTR _e$31[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$10:
	lea	ecx, DWORD PTR _e$29[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$13:
	lea	ecx, DWORD PTR _e$28[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$14:
	lea	ecx, DWORD PTR _e$27[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$15:
	lea	ecx, DWORD PTR _e$26[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z$16:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-956]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z ENDP ; kd_mct_stage::create_stages
; Function compile flags: /Ogtp
;	COMDAT ??_Ekd_mct_block@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekd_mct_block@@QAEPAXI@Z PROC			; kd_mct_block::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekd_mct_block@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kd_mct_block@@QAE@XZ		; kd_mct_block::~kd_mct_block
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	108					; 0000006cH
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	imul	ecx, DWORD PTR [edi], 108
	add	ecx, 4
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:
	call	??1kd_mct_block@@QAE@XZ			; kd_mct_block::~kd_mct_block
	test	bl, 1
	je	SHORT $LN4@vector
	push	108					; 0000006cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Ekd_mct_block@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekd_mct_block@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekd_mct_block@@QAEPAXI@Z ENDP			; kd_mct_block::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?create_dwt_ss_model@kd_mct_block@@AAEXXZ
_TEXT	SEGMENT
_bound_max$1 = -144					; size = 8
_bound_min$2 = -136					; size = 8
tv1745 = -128						; size = 4
_band_lim$1$ = -124					; size = 4
_rg_max$3 = -120					; size = 8
_rg_min$4 = -112					; size = 8
_band_start_idx$1$ = -104				; size = 4
_N$1$ = -100						; size = 4
_src_max$1$ = -96					; size = 4
tv1744 = -92						; size = 4
_src_min$1$ = -88					; size = 4
tv1708 = -88						; size = 4
_Ps$1$ = -84						; size = 4
_Ns$1$ = -80						; size = 4
_step_idx$1$ = -76					; size = 4
_n$4$ = -76						; size = 4
_lev_idx$1$ = -72					; size = 4
$T5 = -68						; size = 4
_b$1$ = -64						; size = 4
_band_pos$1$ = -60					; size = 4
_update_max$1$ = -56					; size = 4
_step_coeffs$1$ = -52					; size = 4
_synth_max$1$ = -48					; size = 4
_synth_rdx$1$ = -44					; size = 4
_edge_max$1$ = -40					; size = 4
tv1719 = -36						; size = 4
tv1713 = -36						; size = 4
tv1711 = -36						; size = 4
_band_min$1$ = -32					; size = 4
_range_min$1$ = -28					; size = 4
$T6 = -24						; size = 4
_range_max$1$ = -20					; size = 4
_this$1$ = -16						; size = 4
_buf$1$ = -12						; size = 4
_synth_min$1$ = -8					; size = 4
_sym_ext$1$ = -1					; size = 1
?create_dwt_ss_model@kd_mct_block@@AAEXXZ PROC		; kd_mct_block::create_dwt_ss_model, COMDAT
; _this$ = ecx

; 4166 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	mov	ebx, ecx

; 4167 :   int N=num_inputs;  assert(N==num_outputs);
; 4168 :   if (scratch == NULL)

	mov	edx, 4
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[ebp], ebx
	cmp	DWORD PTR [ebx+104], 0
	mov	esi, DWORD PTR [ebx+4]
	mov	DWORD PTR _N$1$[ebp], esi
	jne	SHORT $LN43@create_dwt

; 4169 :     scratch = new float[N];

	xor	ecx, ecx
	mov	eax, esi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [ebx+104], eax
$LN43@create_dwt:

; 4170 :   float *buf = scratch - dwt_canvas_origin; // So we can use absolute addresses

	mov	eax, DWORD PTR [ebx+64]
	mov	edi, DWORD PTR [ebx+104]

; 4171 : 
; 4172 :   int band_start_idx = 0;
; 4173 :   for (int lev_idx=dwt_num_levels; lev_idx > 0; lev_idx--)

	mov	ecx, DWORD PTR [ebx+60]
	shl	eax, 2
	sub	edi, eax
	mov	DWORD PTR _band_start_idx$1$[ebp], 0
	mov	DWORD PTR _buf$1$[ebp], edi
	mov	DWORD PTR _lev_idx$1$[ebp], ecx
	test	ecx, ecx
	jle	$LN3@create_dwt
	npad	2
$LL4@create_dwt:

; 4174 :     {
; 4175 :       int b = (lev_idx==dwt_num_levels)?0:1;

	xor	eax, eax
	cmp	ecx, DWORD PTR [ebx+60]
	setne	al
	mov	DWORD PTR _b$1$[ebp], eax

; 4176 :       for (; b < 2; b++)

	cmp	eax, 2
	jge	$LN2@create_dwt

; 4181 :             {
; 4182 :               int n, synth_rdx, range_min, range_max;
; 4183 :               range_min = range_max = (band_pos<<lev_idx) + (b<<(lev_idx-1));

	dec	ecx
	mov	DWORD PTR $T5[ebp], ecx
$LL7@create_dwt:

; 4177 :         {
; 4178 :           int band_min = 1+((dwt_canvas_origin-1-(b<<(lev_idx-1)))>>lev_idx);

	mov	edx, DWORD PTR [ebx+64]
	shl	eax, cl
	mov	ecx, DWORD PTR _lev_idx$1$[ebp]
	sub	edx, eax
	lea	eax, DWORD PTR [edx-1]

; 4179 :           int band_lim = 1+((dwt_canvas_origin+N-1-(b<<(lev_idx-1)))>>lev_idx);

	dec	edx
	mov	DWORD PTR _band_min$1$[ebp], eax
	add	edx, esi
	sar	DWORD PTR _band_min$1$[ebp], cl
	inc	DWORD PTR _band_min$1$[ebp]
	sar	edx, cl

; 4180 :           for (int band_pos=band_min; band_pos < band_lim; band_pos++)

	mov	ecx, DWORD PTR _band_min$1$[ebp]
	inc	edx
	mov	DWORD PTR _band_lim$1$[ebp], edx
	mov	eax, ecx
	mov	DWORD PTR _band_pos$1$[ebp], eax
	cmp	ecx, edx
	jge	$LN9@create_dwt
	mov	ebx, DWORD PTR $T5[ebp]
	mov	ecx, ebx
	mov	edx, DWORD PTR _b$1$[ebp]
	shl	edx, cl
	mov	DWORD PTR tv1745[ebp], edx
	jmp	SHORT $LN10@create_dwt
$LL147@create_dwt:
	mov	ebx, DWORD PTR $T5[ebp]
	mov	edx, DWORD PTR tv1745[ebp]
$LN10@create_dwt:

; 4181 :             {
; 4182 :               int n, synth_rdx, range_min, range_max;
; 4183 :               range_min = range_max = (band_pos<<lev_idx) + (b<<(lev_idx-1));

	mov	ecx, DWORD PTR _lev_idx$1$[ebp]
	mov	esi, eax
	shl	esi, cl
	add	esi, edx
	mov	edx, esi
	mov	DWORD PTR _range_max$1$[ebp], esi
	mov	DWORD PTR _range_min$1$[ebp], edx

; 4184 :               buf[range_min] = 1.0F;

	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR tv1744[ebp], eax
	mov	DWORD PTR [eax+edi], 1065353216		; 3f800000H

; 4185 :               for (synth_rdx=lev_idx-1; synth_rdx >= 0; synth_rdx--)

	mov	eax, ebx
	mov	DWORD PTR _synth_rdx$1$[ebp], eax
	test	eax, eax
	js	$LN12@create_dwt
	mov	ebx, 1
	mov	ecx, eax
	rol	ebx, cl
	mov	DWORD PTR $T6[ebp], ebx
$LL13@create_dwt:

; 4186 :                 { // Walk up through the synthesis levels
; 4187 :                   int synth_gap=1<<synth_rdx;// Between synthesized samples
; 4188 :                   int synth_min = 1+((dwt_canvas_origin-1) >> synth_rdx);

	mov	eax, DWORD PTR _this$1$[ebp]

; 4189 :                   int synth_max = ((dwt_canvas_origin+N-1) >> synth_rdx);
; 4190 :                   synth_min <<= synth_rdx;  synth_max <<= synth_rdx;

	mov	esi, DWORD PTR _N$1$[ebp]
	dec	esi
	mov	eax, DWORD PTR [eax+64]
	lea	ecx, DWORD PTR [eax-1]
	add	eax, esi

; 4191 :                   assert((range_min >= synth_min) && (range_max <= synth_max));
; 4192 : 
; 4193 :                   if (synth_min == synth_max)

	mov	esi, DWORD PTR _range_max$1$[ebp]
	mov	DWORD PTR _synth_min$1$[ebp], ecx
	mov	ecx, DWORD PTR _synth_rdx$1$[ebp]
	sar	DWORD PTR _synth_min$1$[ebp], cl
	inc	DWORD PTR _synth_min$1$[ebp]
	shl	DWORD PTR _synth_min$1$[ebp], cl
	sar	eax, cl
	shl	eax, cl
	mov	DWORD PTR _synth_max$1$[ebp], eax
	mov	eax, DWORD PTR _synth_min$1$[ebp]
	cmp	eax, DWORD PTR _synth_max$1$[ebp]
	jne	SHORT $LN44@create_dwt

; 4194 :                     { // Unit length sequence synthesized differently
; 4195 :                       assert(range_min == range_max);
; 4196 :                       if ((b == 1) && (synth_rdx == (lev_idx-1)))

	cmp	DWORD PTR _b$1$[ebp], 1
	jne	$LN11@create_dwt
	cmp	ecx, DWORD PTR $T5[ebp]
	jne	$LN11@create_dwt

; 4197 :                         buf[range_min] *= 0.5F; // Hi-pass subband divided by 2

	mov	eax, DWORD PTR tv1744[ebp]
	movss	xmm0, DWORD PTR [eax+edi]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [eax+edi], xmm0

; 4198 :                       continue;

	jmp	$LN11@create_dwt
$LN44@create_dwt:

; 4199 :                     }
; 4200 : 
; 4201 :                   // Find even and odd coset bounds for current synth level
; 4202 :                   int bound_min[2], bound_max[2];
; 4203 :                   bound_min[0] = synth_min + (synth_min&synth_gap);

	mov	ecx, ebx
	and	ecx, eax
	add	eax, ecx
	mov	DWORD PTR _bound_min$2[ebp], eax

; 4204 :                   bound_min[1] = synth_min + synth_gap - (synth_min&synth_gap);

	mov	eax, ebx
	sub	eax, ecx

; 4205 :                   bound_max[0] = synth_max - (synth_max&synth_gap);

	mov	ecx, ebx
	add	eax, DWORD PTR _synth_min$1$[ebp]
	mov	DWORD PTR _bound_min$2[ebp+4], eax
	mov	eax, DWORD PTR _synth_max$1$[ebp]
	and	ecx, eax
	sub	eax, ecx

; 4206 :                   bound_max[1] = synth_max - synth_gap + (synth_max&synth_gap);

	sub	ecx, ebx
	add	ecx, DWORD PTR _synth_max$1$[ebp]
	mov	DWORD PTR _bound_max$1[ebp], eax

; 4207 : 
; 4208 :                   // Apply pre-lifting scaling of subband samples, initialize
; 4209 :                   // new subband samples in the range and find initial ranges
; 4210 :                   // for the even and odd cosets
; 4211 :                   int rg_min[2], rg_max[2];
; 4212 :                   if (synth_rdx == (lev_idx-1))

	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR _bound_max$1[ebp+4], ecx
	cmp	DWORD PTR _synth_rdx$1$[ebp], eax
	jne	SHORT $LN46@create_dwt

; 4213 :                     {
; 4214 :                       assert(range_min == range_max);
; 4215 :                       buf[range_min] *= dwt_synth_gains[b];

	mov	esi, DWORD PTR _b$1$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR tv1744[ebp]
	movss	xmm0, DWORD PTR [ecx+esi*4+96]
	mulss	xmm0, DWORD PTR [eax+edi]
	movss	DWORD PTR [eax+edi], xmm0

; 4216 :                       rg_min[b] = rg_max[b] = range_min;

	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR _rg_max$3[ebp+eax], edx
	mov	DWORD PTR _rg_min$4[ebp+eax], edx

; 4217 :                       rg_min[1-b] = 0;  rg_max[1-b] = -1; // Empty range

	neg	eax
	mov	DWORD PTR _rg_min$4[ebp+eax+4], 0
	mov	DWORD PTR _rg_max$3[ebp+eax+4], -1

; 4218 :                     }
; 4219 :                   else

	jmp	SHORT $LN47@create_dwt
$LN46@create_dwt:

; 4220 :                     {
; 4221 :                       assert(!((range_min|range_max) & synth_gap));
; 4222 :                       for (n=range_min; n <= range_max; n+=2*synth_gap)

	mov	eax, edx
	cmp	edx, esi
	jg	SHORT $LN15@create_dwt
	mov	edx, DWORD PTR _this$1$[ebp]
	lea	ecx, DWORD PTR [ebx+ebx]
	npad	9
$LL16@create_dwt:

; 4223 :                         buf[n] *= dwt_synth_gains[0];

	movss	xmm0, DWORD PTR [edi+eax*4]
	mulss	xmm0, DWORD PTR [edx+96]
	movss	DWORD PTR [edi+eax*4], xmm0
	add	eax, ecx
	cmp	eax, esi
	jle	SHORT $LL16@create_dwt
	mov	edx, DWORD PTR _range_min$1$[ebp]
$LN15@create_dwt:

; 4224 :                       for (n=range_min+synth_gap; n<range_max; n+=2*synth_gap)

	lea	eax, DWORD PTR [ebx+edx]
	cmp	eax, esi
	jge	SHORT $LN18@create_dwt
	lea	ecx, DWORD PTR [ebx+ebx]
$LL19@create_dwt:

; 4225 :                         buf[n] = 0.0F;

	mov	DWORD PTR [edi+eax*4], 0
	add	eax, ecx
	cmp	eax, esi
	jl	SHORT $LL19@create_dwt
$LN18@create_dwt:
	mov	ecx, DWORD PTR _this$1$[ebp]

; 4226 :                       rg_min[0] = range_min;  rg_max[0] = range_max;

	mov	DWORD PTR _rg_min$4[ebp], edx
	mov	DWORD PTR _rg_max$3[ebp], esi

; 4227 :                       rg_min[1] = 0;  rg_max[1] = -1; // Range starts empty

	mov	DWORD PTR _rg_min$4[ebp+4], 0
	mov	DWORD PTR _rg_max$3[ebp+4], -1
$LN47@create_dwt:

; 4228 :                     }
; 4229 : 
; 4230 :                   // Now work through the lifting steps
; 4231 :                   int step_idx;
; 4232 :                   float *step_coeffs = dwt_coefficients;
; 4233 :                   for (step_idx=0; step_idx < dwt_num_steps; step_idx++)

	mov	esi, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [ecx+76]
	mov	DWORD PTR _step_coeffs$1$[ebp], eax
	test	esi, esi
	jle	SHORT $LN21@create_dwt

; 4234 :                     step_coeffs += dwt_step_info[step_idx].support_length;

	mov	ecx, DWORD PTR [ecx+72]
	mov	edx, esi
	mov	edi, eax
	npad	6
$LL22@create_dwt:
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+16]
	lea	edi, DWORD PTR [edi+eax*4]
	sub	edx, 1
	jne	SHORT $LL22@create_dwt
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _step_coeffs$1$[ebp], edi
	mov	edi, DWORD PTR _buf$1$[ebp]
$LN21@create_dwt:

; 4235 :                   for (step_idx=dwt_num_steps-1; step_idx >= 0; step_idx--)

	add	esi, -1
	mov	DWORD PTR _step_idx$1$[ebp], esi
	js	$LN145@create_dwt

; 4241 :                       Ns <<= (synth_rdx+1);  Ps <<= (synth_rdx+1);

	mov	edi, esi
	mov	eax, edi
	shl	eax, 4
	mov	DWORD PTR tv1711[ebp], eax
	jmp	SHORT $LN25@create_dwt
	npad	2
$LL146@create_dwt:
	mov	ecx, DWORD PTR _this$1$[ebp]
$LN25@create_dwt:

; 4235 :                   for (step_idx=dwt_num_steps-1; step_idx >= 0; step_idx--)

	mov	edx, DWORD PTR [ecx+72]

; 4236 :                     {
; 4237 :                       kdu_kernel_step_info *step = dwt_step_info+step_idx;
; 4238 :                       step_coeffs -= step->support_length;

	mov	ecx, DWORD PTR [edx+eax]
	add	edx, eax
	mov	esi, DWORD PTR _step_coeffs$1$[ebp]
	mov	eax, ecx
	neg	eax
	lea	esi, DWORD PTR [esi+eax*4]

; 4239 :                       int Ns=step->support_min;

	mov	eax, DWORD PTR [edx+4]

; 4240 :                       int Ps=(Ns+step->support_length)-1;

	lea	edx, DWORD PTR [ecx-1]
	mov	DWORD PTR _step_coeffs$1$[ebp], esi

; 4241 :                       Ns <<= (synth_rdx+1);  Ps <<= (synth_rdx+1);

	mov	ecx, DWORD PTR _synth_rdx$1$[ebp]
	add	edx, eax
	inc	ecx
	shl	eax, cl
	shl	edx, cl

; 4242 :                       if (step_idx & 1)

	and	edi, 1
	je	SHORT $LN48@create_dwt

; 4243 :                         { Ns += synth_gap;  Ps += synth_gap; }

	add	eax, ebx
	add	edx, ebx

; 4244 :                       else

	jmp	SHORT $LN148@create_dwt
$LN48@create_dwt:

; 4245 :                         { Ns -= synth_gap;  Ps -= synth_gap; }

	sub	eax, ebx
	sub	edx, ebx
$LN148@create_dwt:

; 4246 :                       bool sym_ext = dwt_symmetric_extension;

	mov	ecx, DWORD PTR _this$1$[ebp]

; 4247 :                       int update_parity = 1-(step_idx&1);
; 4248 :                       int src_min = rg_min[step_idx&1];
; 4249 :                       int src_max = rg_max[step_idx&1];

	mov	ebx, DWORD PTR _rg_max$3[ebp+edi*4]
	mov	esi, DWORD PTR _rg_min$4[ebp+edi*4]
	mov	DWORD PTR _src_max$1$[ebp], ebx
	mov	cl, BYTE PTR [ecx+69]
	mov	BYTE PTR _sym_ext$1$[ebp], cl
	mov	ecx, 1
	sub	ecx, edi
	mov	DWORD PTR _Ps$1$[ebp], edx

; 4250 :                       if (src_min > src_max)

	cmp	esi, ebx
	mov	DWORD PTR _Ns$1$[ebp], eax
	mov	ebx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _src_min$1$[ebp], esi
	jg	$LN23@create_dwt

; 4251 :                         continue; // Nothing to do here; source coset is empty
; 4252 : 
; 4253 :                       int update_min = src_min - Ps;
; 4254 :                       int update_max = src_max - Ns;

	mov	ebx, DWORD PTR _src_max$1$[ebp]
	sub	esi, edx

; 4255 :                       if ((update_min < bound_min[update_parity]) ||

	mov	edx, DWORD PTR _bound_min$2[ebp+ecx*4]
	sub	ebx, eax
	mov	DWORD PTR _update_max$1$[ebp], ebx
	cmp	esi, edx
	jl	SHORT $LN52@create_dwt
	mov	eax, DWORD PTR _synth_min$1$[ebp]
	add	eax, eax
	sub	eax, edx
	sub	eax, DWORD PTR _Ns$1$[ebp]
	cmp	eax, DWORD PTR _src_min$1$[ebp]
	jl	SHORT $LN51@create_dwt
$LN52@create_dwt:

; 4256 :                           ((2*synth_min -
; 4257 :                             (bound_min[update_parity] + Ns)) >= src_min))
; 4258 :                         update_min = bound_min[update_parity];

	mov	esi, edx
$LN51@create_dwt:

; 4259 :                       if ((update_max > bound_max[update_parity]) ||

	mov	edx, DWORD PTR _bound_max$1[ebp+ecx*4]
	cmp	ebx, edx
	jg	SHORT $LN54@create_dwt
	mov	eax, DWORD PTR _synth_max$1$[ebp]
	mov	ebx, DWORD PTR _update_max$1$[ebp]
	add	eax, eax
	sub	eax, edx
	sub	eax, DWORD PTR _Ps$1$[ebp]
	cmp	eax, DWORD PTR _src_max$1$[ebp]
	jg	SHORT $LN53@create_dwt
$LN54@create_dwt:

; 4260 :                           ((2*synth_max -
; 4261 :                             (bound_max[update_parity]+Ps)) <= src_max))
; 4262 :                         update_max = bound_max[update_parity];

	mov	ebx, edx
	mov	DWORD PTR _update_max$1$[ebp], edx
$LN53@create_dwt:

; 4263 : 
; 4264 :                       if (rg_min[update_parity] > rg_max[update_parity])

	mov	edx, DWORD PTR _rg_max$3[ebp+ecx*4]
	mov	eax, DWORD PTR _rg_min$4[ebp+ecx*4]
	cmp	eax, edx
	jle	SHORT $LN55@create_dwt

; 4265 :                         { // Range of update samples is currently empty
; 4266 :                           rg_min[update_parity] = update_min;

	mov	DWORD PTR _rg_min$4[ebp+ecx*4], esi

; 4267 :                           rg_max[update_parity] = update_max;

	jmp	SHORT $LN149@create_dwt
$LN55@create_dwt:

; 4268 :                         }
; 4269 :                       else if (update_min < rg_min[update_parity])

	cmp	esi, eax
	jge	SHORT $LN57@create_dwt

; 4270 :                         rg_min[update_parity] = update_min;

	mov	DWORD PTR _rg_min$4[ebp+ecx*4], esi
	jmp	SHORT $LN79@create_dwt
$LN57@create_dwt:

; 4271 :                       else if (update_max > rg_max[update_parity])

	cmp	ebx, edx
	jle	SHORT $LN79@create_dwt
$LN149@create_dwt:

; 4272 :                         rg_max[update_parity] = update_max;

	mov	DWORD PTR _rg_max$3[ebp+ecx*4], ebx
$LN79@create_dwt:

; 4273 :                       while (range_min > update_min)

	mov	eax, DWORD PTR _range_min$1$[ebp]
	mov	ecx, DWORD PTR $T6[ebp]
	mov	edx, DWORD PTR _buf$1$[ebp]
	cmp	eax, esi
	jle	SHORT $LN80@create_dwt
	npad	1
$LL26@create_dwt:

; 4274 :                         buf[range_min-=synth_gap] = 0.0F;

	sub	eax, ecx
	mov	DWORD PTR [edx+eax*4], 0
	lea	ebx, DWORD PTR [eax*4]
	mov	DWORD PTR tv1744[ebp], ebx
	cmp	eax, esi
	jg	SHORT $LL26@create_dwt
	mov	ebx, DWORD PTR _update_max$1$[ebp]
	mov	DWORD PTR _range_min$1$[ebp], eax
$LN80@create_dwt:

; 4275 :                       while (range_max < update_max)

	mov	eax, DWORD PTR _range_max$1$[ebp]
	cmp	eax, ebx
	jge	SHORT $LN29@create_dwt
$LL28@create_dwt:

; 4276 :                         buf[range_max+=synth_gap] = 0.0F;

	add	eax, ecx
	mov	DWORD PTR [edx+eax*4], 0
	cmp	eax, ebx
	jl	SHORT $LL28@create_dwt
	mov	DWORD PTR _range_max$1$[ebp], eax
$LN29@create_dwt:

; 4277 : 
; 4278 :                       int edge_min = (sym_ext)?synth_min:bound_min[step_idx&1];

	cmp	BYTE PTR _sym_ext$1$[ebp], 0
	je	SHORT $LN67@create_dwt
	mov	ebx, DWORD PTR _synth_min$1$[ebp]

; 4279 :                       int edge_max = (sym_ext)?synth_max:bound_max[step_idx&1];

	mov	eax, DWORD PTR _synth_max$1$[ebp]
	jmp	SHORT $LN150@create_dwt
$LN67@create_dwt:

; 4277 : 
; 4278 :                       int edge_min = (sym_ext)?synth_min:bound_min[step_idx&1];

	mov	ebx, DWORD PTR _bound_min$2[ebp+edi*4]

; 4279 :                       int edge_max = (sym_ext)?synth_max:bound_max[step_idx&1];

	mov	eax, DWORD PTR _bound_max$1[ebp+edi*4]
$LN150@create_dwt:
	mov	DWORD PTR _edge_max$1$[ebp], eax

; 4280 :                       for (n=update_min; n <= update_max; n+=2*synth_gap)

	cmp	esi, DWORD PTR _update_max$1$[ebp]
	jg	$LN144@create_dwt
	add	ecx, ecx
	npad	2
$LL32@create_dwt:

; 4281 :                         {
; 4282 :                           float *cf = step_coeffs;
; 4283 :                           for (int k=Ns; k <= Ps; k+=2*synth_gap, cf++)

	mov	eax, DWORD PTR _Ps$1$[ebp]
	mov	edx, DWORD PTR _Ns$1$[ebp]
	cmp	edx, eax
	mov	edi, DWORD PTR _step_coeffs$1$[ebp]
	mov	eax, DWORD PTR _edge_max$1$[ebp]
	jg	$LN30@create_dwt
$LL35@create_dwt:

; 4284 :                             {
; 4285 :                               int src_idx = n + k;

	lea	ecx, DWORD PTR [edx+esi]
$LL36@create_dwt:

; 4286 :                               while ((src_idx<edge_min) || (src_idx>edge_max))

	cmp	ecx, ebx
	jl	SHORT $LN60@create_dwt
	cmp	ecx, eax
	jle	SHORT $LN37@create_dwt
$LN60@create_dwt:

; 4287 :                                 if (!sym_ext)

	cmp	BYTE PTR _sym_ext$1$[ebp], 0
	jne	SHORT $LN61@create_dwt

; 4288 :                                   src_idx=(src_idx<edge_min)?edge_min:edge_max;

	cmp	ecx, ebx
	cmovl	eax, ebx
	mov	ecx, eax
	mov	eax, DWORD PTR _edge_max$1$[ebp]
	jmp	SHORT $LL36@create_dwt
$LN61@create_dwt:

; 4289 :                                 else if (src_idx < edge_min)

	cmp	ecx, ebx
	jge	SHORT $LN63@create_dwt

; 4290 :                                   src_idx = 2*edge_min - src_idx;

	lea	eax, DWORD PTR [ebx+ebx]
	sub	eax, ecx
	mov	ecx, eax

; 4291 :                                 else

	mov	eax, DWORD PTR _edge_max$1$[ebp]
	jmp	SHORT $LL36@create_dwt
$LN63@create_dwt:

; 4292 :                                   src_idx = 2*edge_max - src_idx;

	add	eax, eax
	sub	eax, ecx
	mov	ecx, eax
	mov	eax, DWORD PTR _edge_max$1$[ebp]
	jmp	SHORT $LL36@create_dwt
$LN37@create_dwt:

; 4293 :                               if ((src_idx >= src_min) && (src_idx <= src_max))

	cmp	ecx, DWORD PTR _src_min$1$[ebp]
	jl	SHORT $LN33@create_dwt
	cmp	ecx, DWORD PTR _src_max$1$[ebp]
	jg	SHORT $LN33@create_dwt

; 4294 :                                 buf[n] -= buf[src_idx] * *cf;

	mov	eax, DWORD PTR _buf$1$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx*4]
	mov	ecx, eax
	mulss	xmm1, DWORD PTR [edi]
	movss	xmm0, DWORD PTR [ecx+esi*4]
	subss	xmm0, xmm1
	movss	DWORD PTR [ecx+esi*4], xmm0
$LN33@create_dwt:

; 4281 :                         {
; 4282 :                           float *cf = step_coeffs;
; 4283 :                           for (int k=Ns; k <= Ps; k+=2*synth_gap, cf++)

	mov	eax, DWORD PTR $T6[ebp]
	add	edi, 4
	lea	edx, DWORD PTR [edx+eax*2]
	lea	ecx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _edge_max$1$[ebp]
	cmp	edx, DWORD PTR _Ps$1$[ebp]
	jle	SHORT $LL35@create_dwt
$LN30@create_dwt:

; 4280 :                       for (n=update_min; n <= update_max; n+=2*synth_gap)

	add	esi, ecx
	cmp	esi, DWORD PTR _update_max$1$[ebp]
	jle	$LL32@create_dwt
$LN144@create_dwt:
	mov	ebx, DWORD PTR $T6[ebp]
$LN23@create_dwt:

; 4235 :                   for (step_idx=dwt_num_steps-1; step_idx >= 0; step_idx--)

	mov	edi, DWORD PTR _step_idx$1$[ebp]
	mov	eax, DWORD PTR tv1711[ebp]
	dec	edi
	sub	eax, 16					; 00000010H
	mov	DWORD PTR _step_idx$1$[ebp], edi
	mov	DWORD PTR tv1711[ebp], eax
	test	edi, edi
	jns	$LL146@create_dwt
	mov	edi, DWORD PTR _buf$1$[ebp]
$LN145@create_dwt:
	mov	ecx, DWORD PTR _synth_rdx$1$[ebp]
	mov	esi, DWORD PTR _range_max$1$[ebp]
$LN11@create_dwt:

; 4185 :               for (synth_rdx=lev_idx-1; synth_rdx >= 0; synth_rdx--)

	mov	edx, DWORD PTR _range_min$1$[ebp]
	dec	ecx
	ror	ebx, 1
	mov	DWORD PTR _synth_rdx$1$[ebp], ecx
	mov	DWORD PTR $T6[ebp], ebx
	test	ecx, ecx
	jns	$LL13@create_dwt
$LN12@create_dwt:

; 4295 :                             }
; 4296 :                         }
; 4297 :                     }
; 4298 :                   assert(step_coeffs == dwt_coefficients);
; 4299 :                 }
; 4300 : 
; 4301 :               // Finally transfer the data
; 4302 :               kd_mct_ss_model *model =
; 4303 :                 ss_models + band_start_idx + (band_pos-band_min);

	mov	eax, DWORD PTR _band_pos$1$[ebp]
	sub	eax, DWORD PTR _band_min$1$[ebp]
	add	eax, DWORD PTR _band_start_idx$1$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	edi, DWORD PTR [eax+eax*2]

; 4304 :               model->range_min = (kdu_int16)(range_min-dwt_canvas_origin);

	mov	ax, dx
	sub	ax, WORD PTR [ecx+64]
	mov	ebx, DWORD PTR [ecx+32]

; 4305 :               model->range_len = (kdu_int16)(range_max+1-range_min);
; 4306 :               model->ss_handle = model->ss_vals = new float[model->range_len];

	xor	ecx, ecx
	mov	WORD PTR [ebx+edi*4], ax
	mov	eax, esi
	sub	eax, edx
	mov	edx, 4
	inc	eax
	mov	WORD PTR [ebx+edi*4+2], ax
	cwde
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 4307 :               for (n=range_min; n <= range_max; n++)

	mov	ecx, DWORD PTR _range_min$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [ebx+edi*4+4], eax
	mov	edx, ecx
	mov	DWORD PTR [ebx+edi*4+8], eax
	cmp	ecx, esi
	jg	$LN117@create_dwt
	mov	eax, esi
	sub	eax, ecx
	inc	eax
	cmp	eax, 4
	jl	$LC118@create_dwt
	mov	eax, DWORD PTR _buf$1$[ebp]
	xor	esi, esi
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, 8
	mov	DWORD PTR tv1708[ebp], eax
	mov	eax, DWORD PTR _range_max$1$[ebp]
	sub	eax, ecx
	sub	eax, 3
	shr	eax, 2
	inc	eax
	mov	DWORD PTR tv1713[ebp], eax
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _n$4$[ebp], edx
	mov	edx, DWORD PTR tv1708[ebp]
$LL119@create_dwt:

; 4308 :                 model->ss_vals[n-range_min] = buf[n];

	sub	DWORD PTR tv1713[ebp], 1
	lea	edx, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ebx+edi*4+4]
	lea	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [edx-24]
	mov	DWORD PTR [esi+ecx-16], eax
	mov	ecx, DWORD PTR [ebx+edi*4+4]
	mov	eax, DWORD PTR [edx-20]
	mov	DWORD PTR [esi+ecx-12], eax
	mov	ecx, DWORD PTR [ebx+edi*4+4]
	mov	eax, DWORD PTR [edx-16]
	mov	DWORD PTR [esi+ecx-8], eax
	mov	ecx, DWORD PTR [ebx+edi*4+4]
	mov	eax, DWORD PTR [edx-12]
	mov	DWORD PTR [esi+ecx-4], eax
	jne	SHORT $LL119@create_dwt
	mov	edx, DWORD PTR _n$4$[ebp]
	mov	esi, DWORD PTR _range_max$1$[ebp]
	mov	ecx, DWORD PTR _range_min$1$[ebp]
$LC118@create_dwt:

; 4307 :               for (n=range_min; n <= range_max; n++)

	cmp	edx, esi
	jg	SHORT $LN117@create_dwt
	mov	esi, edx
	sub	esi, ecx
	shl	esi, 2
	npad	1
$LC100@create_dwt:

; 4308 :                 model->ss_vals[n-range_min] = buf[n];

	mov	eax, DWORD PTR _buf$1$[ebp]
	lea	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ebx+edi*4+4]
	mov	eax, DWORD PTR [eax+edx*4]
	inc	edx
	mov	DWORD PTR [esi+ecx-4], eax
	cmp	edx, DWORD PTR _range_max$1$[ebp]
	jle	SHORT $LC100@create_dwt
$LN117@create_dwt:

; 4309 : 
; 4310 :               // See if we can just replicate this model into subsequent
; 4311 :               // locations within the same subband -- this should be possible
; 4312 :               // so long as the model and its replica do not intersect the
; 4313 :               // boundaries.
; 4314 :               int left_gap = model->range_min;
; 4315 :               int right_gap = N - model->range_min - model->range_len;

	movsx	eax, WORD PTR [ebx+edi*4+2]
	mov	esi, DWORD PTR _N$1$[ebp]
	movsx	edx, WORD PTR [ebx+edi*4]
	sub	esi, eax
	sub	esi, edx

; 4316 :               while ((left_gap > 0) && (right_gap > (1<<lev_idx)) &&

	test	edx, edx
	jle	SHORT $LN8@create_dwt
	mov	ecx, DWORD PTR _lev_idx$1$[ebp]
	mov	eax, 1
	rol	eax, cl
	add	ebx, 16					; 00000010H
	mov	DWORD PTR tv1719[ebp], eax
	lea	ecx, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR _band_pos$1$[ebp]
	mov	edi, DWORD PTR _band_lim$1$[ebp]
$LL41@create_dwt:
	cmp	esi, eax
	jle	SHORT $LN142@create_dwt
	cmp	ebx, edi
	jge	SHORT $LN142@create_dwt

; 4317 :                      (band_pos < band_lim))
; 4318 :                 {
; 4319 :                   left_gap += 1<<lev_idx;

	add	edx, eax

; 4320 :                   right_gap -= 1<<lev_idx;

	sub	esi, eax

; 4321 :                   model[1].ss_vals = model[0].ss_vals;

	mov	eax, DWORD PTR [ecx-12]

; 4322 :                   model[1].range_min = (kdu_int16) left_gap;
; 4323 :                   model[1].range_len = model[0].range_len;
; 4324 :                   band_pos++;

	inc	ebx
	mov	DWORD PTR [ecx], eax
	mov	ax, WORD PTR [ecx-14]
	mov	WORD PTR [ecx-2], ax
	mov	eax, DWORD PTR tv1719[ebp]
	mov	WORD PTR [ecx-4], dx

; 4325 :                   model++;

	add	ecx, 12					; 0000000cH
	test	edx, edx
	jg	SHORT $LL41@create_dwt
$LN142@create_dwt:
	mov	DWORD PTR _band_pos$1$[ebp], ebx
$LN8@create_dwt:

; 4180 :           for (int band_pos=band_min; band_pos < band_lim; band_pos++)

	mov	eax, DWORD PTR _band_pos$1$[ebp]
	mov	edx, DWORD PTR _band_lim$1$[ebp]
	inc	eax
	mov	edi, DWORD PTR _buf$1$[ebp]
	mov	DWORD PTR _band_pos$1$[ebp], eax
	cmp	eax, edx
	jl	$LL147@create_dwt
	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	esi, DWORD PTR _N$1$[ebp]
	mov	ecx, DWORD PTR _band_min$1$[ebp]
$LN9@create_dwt:

; 4176 :       for (; b < 2; b++)

	mov	eax, DWORD PTR _b$1$[ebp]

; 4326 :                 }
; 4327 :             }
; 4328 :           band_start_idx += band_lim-band_min;

	sub	edx, ecx
	add	DWORD PTR _band_start_idx$1$[ebp], edx
	inc	eax
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _b$1$[ebp], eax
	cmp	eax, 2
	jl	$LL7@create_dwt
	mov	ecx, DWORD PTR _lev_idx$1$[ebp]
$LN2@create_dwt:

; 4171 : 
; 4172 :   int band_start_idx = 0;
; 4173 :   for (int lev_idx=dwt_num_levels; lev_idx > 0; lev_idx--)

	dec	ecx
	mov	DWORD PTR _lev_idx$1$[ebp], ecx
	test	ecx, ecx
	jg	$LL4@create_dwt
$LN3@create_dwt:
	pop	edi
	pop	esi
	pop	ebx

; 4329 :         }
; 4330 :     }
; 4331 :   assert(band_start_idx == num_inputs);
; 4332 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?create_dwt_ss_model@kd_mct_block@@AAEXXZ ENDP		; kd_mct_block::create_dwt_ss_model
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?create_dependency_ss_model@kd_mct_block@@AAEXXZ
_TEXT	SEGMENT
tv511 = -24						; size = 4
_model$1$ = -24						; size = 4
tv522 = -20						; size = 4
_this$1$ = -16						; size = 4
_row_param_start$1$ = -12				; size = 4
_val$1 = -8						; size = 4
_scale$2 = -4						; size = 4
?create_dependency_ss_model@kd_mct_block@@AAEXXZ PROC	; kd_mct_block::create_dependency_ss_model, COMDAT
; _this$ = ecx

; 4114 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 4117 : 
; 4118 :   // Allocate the storage
; 4119 :   int num_coeffs = ((N+1)*N)/2;
; 4120 :   kd_mct_ss_model *model = ss_models;
; 4121 :   model->ss_handle = coeffs = new float[num_coeffs];

	xor	ecx, ecx
	mov	DWORD PTR _this$1$[ebp], edi
	mov	edx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [edi+32]
	mov	DWORD PTR _model$1$[ebp], esi
	lea	eax, DWORD PTR [edx+1]
	imul	eax, edx
	cdq
	sub	eax, edx
	mov	edx, 4
	sar	eax, 1
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR [esi+8], ebx

; 4122 :   for (n=0; n < num_inputs; n++, model++)

	xor	esi, esi
	cmp	DWORD PTR [edi+4], esi
	jle	SHORT $LN3@create_dep

; 4115 :   float *coeffs;
; 4116 :   int n, m, k, N=num_inputs;  assert(N==num_outputs);

	mov	edx, DWORD PTR _model$1$[ebp]
	add	edx, 2
	npad	3
$LL4@create_dep:

; 4123 :     {
; 4124 :       model->range_min = (kdu_int16) n;

	movzx	ecx, si
	lea	edx, DWORD PTR [edx+12]
	mov	WORD PTR [edx-14], cx
	inc	esi

; 4125 :       model->range_len = (kdu_int16)(num_outputs-n);

	mov	ax, WORD PTR [edi+20]
	sub	ax, cx

; 4126 :       model->ss_vals = coeffs;

	mov	DWORD PTR [edx-10], ebx
	mov	WORD PTR [edx-12], ax

; 4127 :       coeffs += model->range_len;

	movsx	eax, ax
	lea	ebx, DWORD PTR [ebx+eax*4]
	cmp	esi, DWORD PTR [edi+4]
	jl	SHORT $LL4@create_dep
$LN3@create_dep:

; 4128 :     }
; 4129 : 
; 4130 :   // Now generate the model coefficients
; 4131 :   int row_param_start = 0; // Idx of first entry for the row in `triang_params'

	xor	ecx, ecx

; 4132 :   for (m=0; m < num_outputs; m++)

	xor	esi, esi
	mov	DWORD PTR _row_param_start$1$[ebp], ecx
	cmp	DWORD PTR [edi+20], ecx
	jle	$LN6@create_dep
$LL7@create_dep:

; 4133 :     {
; 4134 :       for (model=ss_models, n=0; n < m; n++, model++)

	mov	edx, DWORD PTR [edi+32]
	test	esi, esi
	jle	SHORT $LN9@create_dep
	mov	edi, esi
	npad	3
$LL10@create_dep:

; 4135 :         model->ss_vals[m-model->range_min] = 0.0F;

	movsx	eax, WORD PTR [edx]
	mov	ecx, esi
	sub	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR [eax+ecx*4], 0
	sub	edi, 1
	jne	SHORT $LL10@create_dep
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR _row_param_start$1$[ebp]
$LN9@create_dep:

; 4136 :       assert(m == (int) model->range_min);
; 4137 :       model->ss_vals[0] = 1.0F;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 4138 :       if (m == 0)

	test	esi, esi
	je	$LN5@create_dep

; 4139 :         continue;
; 4140 : 
; 4141 :       float scale = 1.0F;
; 4142 :       if (is_reversible)

	cmp	BYTE PTR [edi+36], 0
	mov	DWORD PTR _scale$2[ebp], 1065353216	; 3f800000H
	je	SHORT $LN18@create_dep

; 4143 :         { // Find normalization factor
; 4144 :           triang_params->get(Mtriang_coeffs,row_param_start+m,0,scale);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _scale$2[ebp]
	push	eax
	push	0
	lea	eax, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [edi+52]
	push	eax
	push	OFFSET ??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 4145 :           scale = 1.0F / scale;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _scale$2[ebp]
	movss	DWORD PTR _scale$2[ebp], xmm0
$LN18@create_dep:

; 4146 :         }
; 4147 :       for (k=0; k < m; k++)

	xor	ebx, ebx
	test	esi, esi
	jle	$LN12@create_dep
$LL13@create_dep:

; 4150 :           triang_params->get(Mtriang_coeffs,row_param_start+k,0,val);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _val$1[ebp]
	mov	DWORD PTR _val$1[ebp], 0
	push	ecx
	mov	ecx, DWORD PTR _row_param_start$1$[ebp]
	lea	eax, DWORD PTR [ebx+1]
	dec	ecx
	mov	DWORD PTR tv511[ebp], eax
	push	0
	add	eax, ecx
	mov	ecx, DWORD PTR [edi+52]
	push	eax
	push	OFFSET ??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 4151 :           val *= scale;

	movss	xmm1, DWORD PTR _val$1[ebp]
	mulss	xmm1, DWORD PTR _scale$2[ebp]

; 4152 :           for (model=ss_models, n=0; n <= k; n++, model++)

	mov	edi, DWORD PTR [edi+32]
	movss	DWORD PTR _val$1[ebp], xmm1
	test	ebx, ebx
	js	SHORT $LN11@create_dep

; 4148 :         { // Include contribution from output k to output m
; 4149 :           float val = 0.0F;

	mov	eax, DWORD PTR tv511[ebp]
	mov	DWORD PTR tv522[ebp], eax
	npad	1
$LL16@create_dep:

; 4153 :             model->ss_vals[m-model->range_min] +=

	movsx	eax, WORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	neg	eax
	add	edi, 12					; 0000000cH
	lea	ecx, DWORD PTR [eax+esi]
	add	eax, ebx
	sub	DWORD PTR tv522[ebp], 1
	movss	xmm0, DWORD PTR [edx+eax*4]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [edx+ecx*4]
	movss	DWORD PTR [edx+ecx*4], xmm0
	je	SHORT $LN11@create_dep

; 4148 :         { // Include contribution from output k to output m
; 4149 :           float val = 0.0F;

	movss	xmm1, DWORD PTR _val$1[ebp]
	jmp	SHORT $LL16@create_dep
$LN11@create_dep:

; 4146 :         }
; 4147 :       for (k=0; k < m; k++)

	mov	ebx, DWORD PTR tv511[ebp]
	mov	edi, DWORD PTR _this$1$[ebp]
	cmp	ebx, esi
	jl	$LL13@create_dep
$LN12@create_dep:

; 4154 :               val * model->ss_vals[k-model->range_min];
; 4155 :         }
; 4156 :       row_param_start += (is_reversible)?(m+1):m;

	cmp	BYTE PTR [edi+36], 0
	lea	eax, DWORD PTR [esi+1]
	jne	SHORT $LN21@create_dep
	mov	eax, esi
$LN21@create_dep:
	mov	ecx, DWORD PTR _row_param_start$1$[ebp]
	add	ecx, eax
	mov	DWORD PTR _row_param_start$1$[ebp], ecx
$LN5@create_dep:

; 4132 :   for (m=0; m < num_outputs; m++)

	inc	esi
	cmp	esi, DWORD PTR [edi+20]
	jl	$LL7@create_dep
$LN6@create_dep:
	pop	edi
	pop	esi
	pop	ebx

; 4157 :     }
; 4158 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?create_dependency_ss_model@kd_mct_block@@AAEXXZ ENDP	; kd_mct_block::create_dependency_ss_model
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?create_old_rxform_ss_model@kd_mct_block@@AAEXXZ
_TEXT	SEGMENT
tv653 = -32						; size = 4
tv643 = -32						; size = 4
tv656 = -28						; size = 4
_sign$1$ = -24						; size = 4
_s$1$ = -20						; size = 4
_coeffs$1$ = -16					; size = 4
_val$1 = -16						; size = 4
_scale$2 = -12						; size = 4
_this$1$ = -8						; size = 4
_N$1$ = -4						; size = 4
?create_old_rxform_ss_model@kd_mct_block@@AAEXXZ PROC	; kd_mct_block::create_old_rxform_ss_model, COMDAT
; _this$ = ecx

; 4057 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, ecx

; 4060 :   assert(this->is_reversible);
; 4061 : 
; 4062 :   // Allocate the storage
; 4063 :   int num_coeffs = (N+1)*N;
; 4064 :   kd_mct_ss_model *model = ss_models;
; 4065 :   model->ss_handle = coeffs = new float[num_coeffs];

	mov	edx, 4
	push	esi
	mov	DWORD PTR _this$1$[ebp], eax
	push	edi
	mov	ecx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+32]
	mov	DWORD PTR _N$1$[ebp], ecx
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR tv656[ebp], eax
	imul	eax, ecx
	xor	ecx, ecx
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 4066 :   for (n=0; n < num_inputs; n++, model++, coeffs+=N)

	mov	edx, DWORD PTR _this$1$[ebp]
	xor	esi, esi
	add	esp, 4
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR _coeffs$1$[ebp], eax
	cmp	DWORD PTR [edx+4], esi
	jle	$LN58@create_old

; 4058 :   float *coeffs;
; 4059 :   int n, m, k, N=num_inputs;  assert(N==num_outputs);

	movss	xmm1, DWORD PTR __real@3f800000
	lea	edx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR _N$1$[ebp]
	npad	6
$LL4@create_old:

; 4069 :       model->range_min = 0;

	xor	ecx, ecx
	mov	DWORD PTR [edx], eax
	mov	WORD PTR [edx-4], cx

; 4070 :       model->range_len = (kdu_int16) N;

	mov	WORD PTR [edx-2], di

; 4071 :       for (m=0; m < N; m++)

	cmp	edi, 4
	jl	$LC38@create_old

; 4067 :     {
; 4068 :       model->ss_vals = coeffs;

	add	edi, -3					; fffffffdH
	mov	DWORD PTR tv653[ebp], edi
	lea	edi, DWORD PTR [ecx+2]
	npad	2

; 4071 :       for (m=0; m < N; m++)

$LL47@create_old:

; 4072 :         model->ss_vals[m] =

	movss	xmm1, DWORD PTR __real@3f800000
	xorps	xmm2, xmm2
	cmp	ecx, esi
	jne	SHORT $LN39@create_old
	movaps	xmm0, xmm1
	jmp	SHORT $LN40@create_old
$LN39@create_old:
	movaps	xmm0, xmm2
$LN40@create_old:
	mov	eax, DWORD PTR [edx]
	movss	DWORD PTR [eax+ecx*4], xmm0
	lea	eax, DWORD PTR [edi-1]
	cmp	eax, esi
	jne	SHORT $LN41@create_old
	movaps	xmm0, xmm1
	jmp	SHORT $LN42@create_old
$LN41@create_old:
	movaps	xmm0, xmm2
$LN42@create_old:
	mov	eax, DWORD PTR [edx]
	movss	DWORD PTR [eax+ecx*4+4], xmm0
	cmp	edi, esi
	jne	SHORT $LN43@create_old
	movaps	xmm0, xmm1
	jmp	SHORT $LN44@create_old
$LN43@create_old:
	movaps	xmm0, xmm2
$LN44@create_old:
	mov	eax, DWORD PTR [edx]
	movss	DWORD PTR [eax+ecx*4+8], xmm0
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, esi
	jne	SHORT $LN45@create_old
	movaps	xmm0, xmm1
	jmp	SHORT $LN46@create_old
$LN45@create_old:
	movaps	xmm0, xmm2
$LN46@create_old:
	mov	eax, DWORD PTR [edx]
	add	edi, 4
	movss	DWORD PTR [eax+ecx*4+12], xmm0
	add	ecx, 4
	cmp	ecx, DWORD PTR tv653[ebp]
	jl	SHORT $LL47@create_old
	movss	xmm1, DWORD PTR __real@3f800000
	mov	edi, DWORD PTR _N$1$[ebp]
	mov	eax, DWORD PTR _coeffs$1$[ebp]
$LC38@create_old:

; 4071 :       for (m=0; m < N; m++)

	cmp	ecx, edi
	jge	SHORT $LN2@create_old
	npad	3
$LC7@create_old:

; 4072 :         model->ss_vals[m] =

	cmp	ecx, esi
	jne	SHORT $LN20@create_old
	movaps	xmm0, xmm1
	jmp	SHORT $LN21@create_old
$LN20@create_old:
	xorps	xmm0, xmm0
$LN21@create_old:
	mov	eax, DWORD PTR [edx]
	movss	DWORD PTR [eax+ecx*4], xmm0
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LC7@create_old
	mov	eax, DWORD PTR _coeffs$1$[ebp]
$LN2@create_old:

; 4066 :   for (n=0; n < num_inputs; n++, model++, coeffs+=N)

	lea	ecx, DWORD PTR [edi*4]
	inc	esi
	add	eax, ecx
	add	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _coeffs$1$[ebp], eax
	cmp	esi, DWORD PTR [ecx+4]
	jl	$LL4@create_old
	mov	edx, ecx
	jmp	SHORT $LN3@create_old
$LN58@create_old:
	mov	edi, DWORD PTR _N$1$[ebp]
$LN3@create_old:

; 4073 :           (m==n)?1.0F:0.0F; // Start with inputs mapped to outputs
; 4074 :     }
; 4075 : 
; 4076 :   // Now generate the model coefficients
; 4077 :   int s; // Stands for the "step"
; 4078 :   for (s=0; s <= N; s++)

	xor	ecx, ecx
	mov	DWORD PTR _s$1$[ebp], ecx
	test	edi, edi
	js	$LN9@create_old
	npad	5
$LL10@create_old:

; 4079 :     {
; 4080 :       m = (N-1) - ((s==N)?0:s); // Index of the channel affected by this step
; 4081 :       float scale = 1.0F;
; 4082 :       old_mat_params->get(Mmatrix_coeffs,m*(N+1)+s,0,scale);

	push	1
	xor	esi, esi
	mov	DWORD PTR _scale$2[ebp], 1065353216	; 3f800000H
	cmp	ecx, edi
	mov	eax, ecx
	push	1
	cmove	eax, esi
	sub	edi, eax
	lea	eax, DWORD PTR _scale$2[ebp]
	push	1
	push	eax
	mov	eax, DWORD PTR tv656[ebp]
	dec	edi
	imul	eax, edi
	push	esi
	add	eax, ecx
	mov	ecx, DWORD PTR [edx+48]
	push	eax
	push	OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 4083 :       scale = 1.0F / scale;

	movss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm0, xmm1

; 4084 :       float sign = 1.0F;

	movss	DWORD PTR _sign$1$[ebp], xmm1
	divss	xmm0, DWORD PTR _scale$2[ebp]
	xorps	xmm1, xmm1

; 4085 :       if (scale < 0.0F)

	comiss	xmm1, xmm0
	movss	DWORD PTR _scale$2[ebp], xmm0
	jbe	SHORT $LN17@create_old

; 4086 :         {
; 4087 :           assert(s == N);
; 4088 :           sign = -1.0F;

	movss	xmm1, DWORD PTR __real@bf800000

; 4089 :           scale = -scale;

	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _sign$1$[ebp], xmm1
	movss	DWORD PTR _scale$2[ebp], xmm0
$LN17@create_old:

; 4090 :         }
; 4091 : 
; 4092 :       for (k=0; k < N; k++)

	mov	ecx, DWORD PTR _N$1$[ebp]
	xor	esi, esi
	test	ecx, ecx
	jle	$LN8@create_old
	mov	eax, DWORD PTR _s$1$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR tv643[ebp], eax
$LL13@create_old:

; 4093 :         { // k is the index of the source channel for this step
; 4094 :           if (k == m)

	cmp	esi, edi
	je	$LN11@create_old

; 4097 :           old_mat_params->get(Mmatrix_coeffs,k*(N+1)+s,0,val);

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _val$1[ebp]
	mov	DWORD PTR _val$1[ebp], 0
	push	ecx
	push	0
	push	eax
	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	mov	ecx, DWORD PTR [eax+48]
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 4098 :           val *= scale; // This is the update multiplier

	movss	xmm1, DWORD PTR _val$1[ebp]

; 4099 :           for (model=ss_models, n=0; n < N; n++, model++)

	mov	eax, DWORD PTR _this$1$[ebp]
	mulss	xmm1, DWORD PTR _scale$2[ebp]
	mov	edx, DWORD PTR _N$1$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	movss	DWORD PTR _val$1[ebp], xmm1
	add	ecx, 4
	npad	4
$LL16@create_old:

; 4100 :             { // Find the effect of this step update on each input's model
; 4101 :               model->ss_vals[m] -= val*model->ss_vals[k];

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR [eax+edi*4]
	subss	xmm1, xmm0

; 4102 :               model->ss_vals[m] *= sign;

	mulss	xmm1, DWORD PTR _sign$1$[ebp]
	movss	DWORD PTR [eax+edi*4], xmm1
	sub	edx, 1
	je	SHORT $LN57@create_old

; 4095 :             continue;
; 4096 :           float val = 0.0F;

	movss	xmm1, DWORD PTR _val$1[ebp]
	jmp	SHORT $LL16@create_old
$LN57@create_old:
	mov	eax, DWORD PTR tv643[ebp]
	mov	ecx, DWORD PTR _N$1$[ebp]
	mov	edx, DWORD PTR tv656[ebp]
$LN11@create_old:

; 4090 :         }
; 4091 : 
; 4092 :       for (k=0; k < N; k++)

	inc	esi
	add	eax, edx
	mov	DWORD PTR tv643[ebp], eax
	cmp	esi, ecx
	jl	$LL13@create_old
$LN8@create_old:

; 4073 :           (m==n)?1.0F:0.0F; // Start with inputs mapped to outputs
; 4074 :     }
; 4075 : 
; 4076 :   // Now generate the model coefficients
; 4077 :   int s; // Stands for the "step"
; 4078 :   for (s=0; s <= N; s++)

	mov	ecx, DWORD PTR _s$1$[ebp]
	mov	edi, DWORD PTR _N$1$[ebp]
	inc	ecx
	mov	edx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _s$1$[ebp], ecx
	cmp	ecx, edi
	jle	$LL10@create_old
$LN9@create_old:
	pop	edi
	pop	esi

; 4103 :             }
; 4104 :         }
; 4105 :     }
; 4106 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?create_old_rxform_ss_model@kd_mct_block@@AAEXXZ ENDP	; kd_mct_block::create_old_rxform_ss_model
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?create_rxform_ss_model@kd_mct_block@@AAEXXZ
_TEXT	SEGMENT
tv646 = -28						; size = 4
tv648 = -24						; size = 4
_s$1$ = -24						; size = 4
_model$1$ = -24						; size = 4
_sign$1$ = -20						; size = 4
_coeffs$1$ = -16					; size = 4
_val$1 = -16						; size = 4
_scale$2 = -12						; size = 4
_this$1$ = -8						; size = 4
_N$1$ = -4						; size = 4
?create_rxform_ss_model@kd_mct_block@@AAEXXZ PROC	; kd_mct_block::create_rxform_ss_model, COMDAT
; _this$ = ecx

; 4000 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, ecx

; 4003 :   assert(this->is_reversible);
; 4004 : 
; 4005 :   // Allocate the storage
; 4006 :   int num_coeffs = (N+1)*N;
; 4007 :   kd_mct_ss_model *model = ss_models;
; 4008 :   model->ss_handle = coeffs = new float[num_coeffs];

	mov	edx, 4
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[ebp], eax
	xor	ecx, ecx
	mov	edi, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax+32]
	mov	DWORD PTR _N$1$[ebp], edi
	mov	DWORD PTR _model$1$[ebp], esi
	lea	eax, DWORD PTR [edi+1]
	imul	eax, edi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 4009 :   for (n=0; n < num_inputs; n++, model++, coeffs+=N)

	mov	edx, DWORD PTR _this$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax
	xor	esi, esi
	mov	DWORD PTR _coeffs$1$[ebp], eax
	cmp	DWORD PTR [edx+4], esi
	jle	$LN3@create_rxf

; 4001 :   float *coeffs;
; 4002 :   int n, m, k, N=num_inputs;  assert(N==num_outputs);

	mov	edx, DWORD PTR _model$1$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	add	edx, 4
	npad	6
$LL4@create_rxf:

; 4012 :       model->range_min = 0;

	xor	ecx, ecx
	mov	DWORD PTR [edx], eax
	mov	WORD PTR [edx-4], cx

; 4013 :       model->range_len = (kdu_int16) N;

	mov	WORD PTR [edx-2], di

; 4014 :       for (m=0; m < N; m++)

	cmp	edi, 4
	jl	$LC38@create_rxf

; 4010 :     {
; 4011 :       model->ss_vals = coeffs;

	add	edi, -3					; fffffffdH
	mov	DWORD PTR tv648[ebp], edi
	lea	edi, DWORD PTR [ecx+2]
	npad	2

; 4014 :       for (m=0; m < N; m++)

$LL47@create_rxf:

; 4015 :         model->ss_vals[m] =

	movss	xmm1, DWORD PTR __real@3f800000
	xorps	xmm2, xmm2
	cmp	ecx, esi
	jne	SHORT $LN39@create_rxf
	movaps	xmm0, xmm1
	jmp	SHORT $LN40@create_rxf
$LN39@create_rxf:
	movaps	xmm0, xmm2
$LN40@create_rxf:
	mov	eax, DWORD PTR [edx]
	movss	DWORD PTR [eax+ecx*4], xmm0
	lea	eax, DWORD PTR [edi-1]
	cmp	eax, esi
	jne	SHORT $LN41@create_rxf
	movaps	xmm0, xmm1
	jmp	SHORT $LN42@create_rxf
$LN41@create_rxf:
	movaps	xmm0, xmm2
$LN42@create_rxf:
	mov	eax, DWORD PTR [edx]
	movss	DWORD PTR [eax+ecx*4+4], xmm0
	cmp	edi, esi
	jne	SHORT $LN43@create_rxf
	movaps	xmm0, xmm1
	jmp	SHORT $LN44@create_rxf
$LN43@create_rxf:
	movaps	xmm0, xmm2
$LN44@create_rxf:
	mov	eax, DWORD PTR [edx]
	movss	DWORD PTR [eax+ecx*4+8], xmm0
	lea	eax, DWORD PTR [edi+1]
	cmp	eax, esi
	jne	SHORT $LN45@create_rxf
	movaps	xmm0, xmm1
	jmp	SHORT $LN46@create_rxf
$LN45@create_rxf:
	movaps	xmm0, xmm2
$LN46@create_rxf:
	mov	eax, DWORD PTR [edx]
	add	edi, 4
	movss	DWORD PTR [eax+ecx*4+12], xmm0
	add	ecx, 4
	cmp	ecx, DWORD PTR tv648[ebp]
	jl	SHORT $LL47@create_rxf
	movss	xmm1, DWORD PTR __real@3f800000
	mov	edi, DWORD PTR _N$1$[ebp]
	mov	eax, DWORD PTR _coeffs$1$[ebp]
$LC38@create_rxf:

; 4014 :       for (m=0; m < N; m++)

	cmp	ecx, edi
	jge	SHORT $LN2@create_rxf
	npad	3
$LC7@create_rxf:

; 4015 :         model->ss_vals[m] =

	cmp	ecx, esi
	jne	SHORT $LN20@create_rxf
	movaps	xmm0, xmm1
	jmp	SHORT $LN21@create_rxf
$LN20@create_rxf:
	xorps	xmm0, xmm0
$LN21@create_rxf:
	mov	eax, DWORD PTR [edx]
	movss	DWORD PTR [eax+ecx*4], xmm0
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LC7@create_rxf
	mov	eax, DWORD PTR _coeffs$1$[ebp]
$LN2@create_rxf:

; 4009 :   for (n=0; n < num_inputs; n++, model++, coeffs+=N)

	lea	ecx, DWORD PTR [edi*4]
	inc	esi
	add	eax, ecx
	add	edx, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _coeffs$1$[ebp], eax
	cmp	esi, DWORD PTR [ecx+4]
	jl	$LL4@create_rxf
	mov	edx, ecx
$LN3@create_rxf:

; 4016 :           (m==n)?1.0F:0.0F; // Start with inputs mapped to outputs
; 4017 :     }
; 4018 : 
; 4019 :   // Now generate the model coefficients
; 4020 :   int s; // Stands for the "step"
; 4021 :   for (s=0; s <= N; s++)

	xor	ecx, ecx
	mov	DWORD PTR _s$1$[ebp], ecx
	test	edi, edi
	js	$LN9@create_rxf
	npad	10
$LL10@create_rxf:

; 4022 :     {
; 4023 :       m = (N-1) - ((s==N)?0:s); // Index of the channel affected by this step

	xor	esi, esi

; 4024 :       float scale = 1.0F;

	mov	DWORD PTR _scale$2[ebp], 1065353216	; 3f800000H
	cmp	ecx, edi
	mov	eax, ecx

; 4025 :       matrix_params->get(Mmatrix_coeffs,s*N+m,0,scale);

	push	1
	cmove	eax, esi
	sub	edi, eax
	mov	eax, ecx
	imul	eax, DWORD PTR _N$1$[ebp]
	lea	ecx, DWORD PTR _scale$2[ebp]
	push	1
	push	1
	push	ecx
	mov	ecx, DWORD PTR [edx+44]
	dec	edi
	mov	DWORD PTR tv646[ebp], eax
	add	eax, edi
	push	esi
	push	eax
	push	OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 4026 :       scale = 1.0F / scale;

	movss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm0, xmm1

; 4027 :       float sign = 1.0F;

	movss	DWORD PTR _sign$1$[ebp], xmm1
	divss	xmm0, DWORD PTR _scale$2[ebp]
	xorps	xmm1, xmm1

; 4028 :       if (scale < 0.0F)

	comiss	xmm1, xmm0
	movss	DWORD PTR _scale$2[ebp], xmm0
	jbe	SHORT $LN17@create_rxf

; 4029 :         {
; 4030 :           assert(s == N);
; 4031 :           sign = -1.0F;

	movss	xmm1, DWORD PTR __real@bf800000

; 4032 :           scale = -scale;

	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _sign$1$[ebp], xmm1
	movss	DWORD PTR _scale$2[ebp], xmm0
$LN17@create_rxf:

; 4033 :         }
; 4034 : 
; 4035 :       for (k=0; k < N; k++)

	mov	eax, DWORD PTR _N$1$[ebp]
	xor	esi, esi
	test	eax, eax
	jle	$LN8@create_rxf
	npad	1
$LL13@create_rxf:

; 4036 :         { // k is the index of the source channel for this step
; 4037 :           if (k == m)

	cmp	esi, edi
	je	$LN11@create_rxf

; 4040 :           matrix_params->get(Mmatrix_coeffs,s*N+k,0,val);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _val$1[ebp]
	mov	DWORD PTR _val$1[ebp], 0
	push	eax
	mov	eax, DWORD PTR tv646[ebp]
	push	0
	add	eax, esi
	push	eax
	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	mov	ecx, DWORD PTR [eax+44]
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 4041 :           val *= scale; // This is the update multiplier

	movss	xmm1, DWORD PTR _val$1[ebp]

; 4042 :           for (model=ss_models, n=0; n < N; n++, model++)

	mov	eax, DWORD PTR _this$1$[ebp]
	mulss	xmm1, DWORD PTR _scale$2[ebp]
	mov	edx, DWORD PTR _N$1$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	movss	DWORD PTR _val$1[ebp], xmm1
	add	ecx, 4
	npad	4
$LL16@create_rxf:

; 4043 :             { // Find the effect of this step update on each input's model
; 4044 :               model->ss_vals[m] -= val*model->ss_vals[k];

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	movss	xmm0, DWORD PTR [eax+esi*4]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR [eax+edi*4]
	subss	xmm1, xmm0

; 4045 :               model->ss_vals[m] *= sign;

	mulss	xmm1, DWORD PTR _sign$1$[ebp]
	movss	DWORD PTR [eax+edi*4], xmm1
	sub	edx, 1
	je	SHORT $LN57@create_rxf

; 4038 :             continue;
; 4039 :           float val = 0.0F;

	movss	xmm1, DWORD PTR _val$1[ebp]
	jmp	SHORT $LL16@create_rxf
$LN57@create_rxf:
	mov	eax, DWORD PTR _N$1$[ebp]
$LN11@create_rxf:

; 4033 :         }
; 4034 : 
; 4035 :       for (k=0; k < N; k++)

	inc	esi
	cmp	esi, eax
	jl	$LL13@create_rxf
$LN8@create_rxf:

; 4016 :           (m==n)?1.0F:0.0F; // Start with inputs mapped to outputs
; 4017 :     }
; 4018 : 
; 4019 :   // Now generate the model coefficients
; 4020 :   int s; // Stands for the "step"
; 4021 :   for (s=0; s <= N; s++)

	mov	ecx, DWORD PTR _s$1$[ebp]
	mov	edi, DWORD PTR _N$1$[ebp]
	inc	ecx
	mov	edx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _s$1$[ebp], ecx
	cmp	ecx, edi
	jle	$LL10@create_rxf
$LN9@create_rxf:
	pop	edi
	pop	esi

; 4046 :             }
; 4047 :         }
; 4048 :     }
; 4049 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?create_rxform_ss_model@kd_mct_block@@AAEXXZ ENDP	; kd_mct_block::create_rxform_ss_model
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?create_matrix_ss_model@kd_mct_block@@AAEXXZ
_TEXT	SEGMENT
_coeffs$1$ = -8						; size = 4
_n$1$ = -4						; size = 4
?create_matrix_ss_model@kd_mct_block@@AAEXXZ PROC	; kd_mct_block::create_matrix_ss_model, COMDAT
; _this$ = ecx

; 3974 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx

; 3979 :   model->ss_handle = coeffs = new float[num_coeffs];

	mov	edx, 4
	xor	ecx, ecx
	mov	eax, DWORD PTR [esi+20]
	imul	eax, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [esi+32]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, eax

; 3980 :   for (n=0; n < num_inputs; n++, model++, coeffs+=num_outputs)

	xor	edx, edx
	add	esp, 4
	mov	DWORD PTR [ebx+8], ecx
	mov	DWORD PTR _coeffs$1$[ebp], ecx
	mov	DWORD PTR _n$1$[ebp], edx
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN3@create_mat

; 3975 :   float *coeffs;
; 3976 :   int n, m, num_coeffs = num_inputs * num_outputs;
; 3977 :   assert(!this->is_reversible);
; 3978 :   kd_mct_ss_model *model = ss_models;

	add	ebx, 4
	push	edi
$LL4@create_mat:

; 3981 :     {
; 3982 :       model->ss_vals = coeffs;
; 3983 :       model->range_min = 0;

	xor	eax, eax
	mov	DWORD PTR [ebx], ecx
	mov	WORD PTR [ebx-4], ax

; 3984 :       model->range_len = (kdu_int16) num_outputs;
; 3985 :       for (m=0; m < num_outputs; m++)

	xor	edi, edi
	mov	ax, WORD PTR [esi+20]
	mov	WORD PTR [ebx-2], ax
	cmp	DWORD PTR [esi+20], edi
	jle	SHORT $LN2@create_mat
	npad	6
$LL7@create_mat:

; 3986 :         {
; 3987 :           model->ss_vals[m] = 0.0F; // Avoids any possible failure condition

	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [edi*4]

; 3988 :           matrix_params->get(Mmatrix_coeffs,m*num_inputs+n,0,

	push	1
	push	1
	push	1
	mov	DWORD PTR [ecx+eax], 0
	mov	eax, DWORD PTR [ebx]
	add	eax, ecx
	mov	ecx, DWORD PTR [esi+44]
	push	eax
	mov	eax, DWORD PTR [esi+4]
	imul	eax, edi
	push	0
	add	eax, edx
	push	eax
	push	OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	mov	edx, DWORD PTR _n$1$[ebp]
	inc	edi
	cmp	edi, DWORD PTR [esi+20]
	jl	SHORT $LL7@create_mat
	mov	ecx, DWORD PTR _coeffs$1$[ebp]
$LN2@create_mat:

; 3980 :   for (n=0; n < num_inputs; n++, model++, coeffs+=num_outputs)

	mov	eax, DWORD PTR [esi+20]
	inc	edx
	add	ebx, 12					; 0000000cH
	mov	DWORD PTR _n$1$[ebp], edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _coeffs$1$[ebp], ecx
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL4@create_mat
	pop	edi
$LN3@create_mat:
	pop	esi
	pop	ebx

; 3989 :                              model->ss_vals[m]);
; 3990 :         }
; 3991 :     }
; 3992 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?create_matrix_ss_model@kd_mct_block@@AAEXXZ ENDP	; kd_mct_block::create_matrix_ss_model
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z
_TEXT	SEGMENT
tv378 = -24						; size = 4
tv362 = -24						; size = 4
$T2 = -24						; size = 4
_n$1$ = -20						; size = 4
$T3 = -20						; size = 4
tv377 = -16						; size = 4
__$EHRec$ = -12						; size = 12
tv388 = 8						; size = 4
tv361 = 8						; size = 4
_which_input$ = 8					; size = 4
tv387 = 12						; size = 4
_input_weight$ = 12					; size = 4
_min_output_idx$ = 16					; size = 4
tv403 = 20						; size = 4
_max_output_idx$ = 20					; size = 4
_restrict_to_interest$ = 24				; size = 1
?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z PROC	; kd_mct_block::analyze_sensitivity, COMDAT
; _this$ = ecx

; 3903 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 3904 :   if (is_null_transform)

	cmp	BYTE PTR [esi+37], 0
	je	$LN13@analyze_se

; 3905 :     {
; 3906 :       int out_idx = output_indices[which_input];

	mov	eax, DWORD PTR _which_input$[ebp]
	mov	edx, DWORD PTR [esi+28]
	mov	ebx, DWORD PTR [edx+eax*4]

; 3907 :       kd_output_comp_info *oci = stage->output_comp_info+out_idx;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ebx+ebx*4]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR tv361[ebp], ecx
	mov	DWORD PTR tv362[ebp], eax

; 3908 :       if (oci->is_of_interest || !restrict_to_interest)

	cmp	BYTE PTR [eax+ecx*8+32], 0
	jne	SHORT $LN15@analyze_se
	cmp	BYTE PTR _restrict_to_interest$[ebp], 0
	jne	$LN7@analyze_se
$LN15@analyze_se:

; 3909 :         {
; 3910 :           if (min_output_idx > max_output_idx)

	mov	edi, DWORD PTR _min_output_idx$[ebp]
	mov	edx, DWORD PTR _max_output_idx$[ebp]
	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [edx]
	lea	ecx, DWORD PTR [ebx+ebx*4]
	jle	SHORT $LN37@analyze_se

; 3911 :             {
; 3912 :               min_output_idx = max_output_idx = out_idx;

	mov	DWORD PTR [edx], ebx
	mov	DWORD PTR [edi], ebx

; 3913 :               oci->ss_tmp = 0.0F;

	mov	DWORD PTR [eax+ecx*8+36], 0

; 3914 :             }
; 3915 :           else

	jmp	SHORT $LN5@analyze_se
$LN37@analyze_se:

; 3916 :             {
; 3917 :               while (min_output_idx > out_idx)

	cmp	DWORD PTR [edi], ebx
	jle	SHORT $LN38@analyze_se
	npad	3
$LL2@analyze_se:

; 3918 :                 stage->output_comp_info[--min_output_idx].ss_tmp = 0.0F;

	dec	DWORD PTR [edi]
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [eax+ecx*8+36], 0
	cmp	DWORD PTR [edi], ebx
	jg	SHORT $LL2@analyze_se
$LN38@analyze_se:

; 3919 :               while (max_output_idx < out_idx)

	cmp	DWORD PTR [edx], ebx
	jge	SHORT $LN5@analyze_se
	npad	4
$LL4@analyze_se:

; 3920 :                 stage->output_comp_info[++max_output_idx].ss_tmp = 0.0F;

	inc	DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [eax+ecx*8+36], 0
	cmp	DWORD PTR [edx], ebx
	jl	SHORT $LL4@analyze_se
$LN5@analyze_se:

; 3921 :             }
; 3922 :           oci->ss_tmp += input_weight;

	mov	eax, DWORD PTR tv361[ebp]
	mov	ecx, DWORD PTR tv362[ebp]
	movss	xmm0, DWORD PTR _input_weight$[ebp]
	addss	xmm0, DWORD PTR [ecx+eax*8+36]
	movss	DWORD PTR [ecx+eax*8+36], xmm0

; 3964 :         }
; 3965 :     }
; 3966 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN13@analyze_se:

; 3923 :         }
; 3924 :       return;
; 3925 :     }
; 3926 : 
; 3927 :   if (ss_models == NULL)

	cmp	DWORD PTR [esi+32], 0
	jne	$LN27@analyze_se

; 3928 :     {
; 3929 :       ss_models = new kd_mct_ss_model[num_inputs];

	mov	edi, DWORD PTR [esi+4]
	xor	ecx, ecx
	mov	eax, edi
	mov	DWORD PTR $T2[ebp], edi
	mov	edx, 12					; 0000000cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN34@analyze_se
	push	OFFSET ??1kd_mct_ss_model@@QAE@XZ	; kd_mct_ss_model::~kd_mct_ss_model
	push	OFFSET ??0kd_mct_ss_model@@QAE@XZ	; kd_mct_ss_model::kd_mct_ss_model
	push	edi
	lea	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], edi
	push	12					; 0000000cH
	push	ebx
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	jmp	SHORT $LN35@analyze_se
$LN34@analyze_se:
	xor	ebx, ebx
$LN35@analyze_se:

; 3930 :       if ((matrix_params != NULL) && !is_reversible)

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+32], ebx
	test	eax, eax
	je	SHORT $LN21@analyze_se
	cmp	BYTE PTR [esi+36], 0
	jne	SHORT $LN19@analyze_se

; 3931 :         create_matrix_ss_model();

	mov	ecx, esi
	call	?create_matrix_ss_model@kd_mct_block@@AAEXXZ ; kd_mct_block::create_matrix_ss_model
	jmp	SHORT $LN27@analyze_se
$LN19@analyze_se:

; 3932 :       else if (matrix_params != NULL)

	test	eax, eax
	je	SHORT $LN21@analyze_se

; 3933 :         create_rxform_ss_model();

	mov	ecx, esi
	call	?create_rxform_ss_model@kd_mct_block@@AAEXXZ ; kd_mct_block::create_rxform_ss_model
	jmp	SHORT $LN27@analyze_se
$LN21@analyze_se:

; 3934 :       else if (old_mat_params != NULL)

	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN23@analyze_se

; 3935 :         create_old_rxform_ss_model();

	mov	ecx, esi
	call	?create_old_rxform_ss_model@kd_mct_block@@AAEXXZ ; kd_mct_block::create_old_rxform_ss_model
	jmp	SHORT $LN27@analyze_se
$LN23@analyze_se:

; 3936 :       else if (triang_params != NULL)

	cmp	DWORD PTR [esi+52], 0
	je	SHORT $LN25@analyze_se

; 3937 :         create_dependency_ss_model();

	mov	ecx, esi
	call	?create_dependency_ss_model@kd_mct_block@@AAEXXZ ; kd_mct_block::create_dependency_ss_model
	jmp	SHORT $LN27@analyze_se
$LN25@analyze_se:

; 3938 :       else if (dwt_num_levels > 0)

	cmp	DWORD PTR [esi+60], 0
	jle	SHORT $LN27@analyze_se

; 3939 :         create_dwt_ss_model();

	mov	ecx, esi
	call	?create_dwt_ss_model@kd_mct_block@@AAEXXZ ; kd_mct_block::create_dwt_ss_model
$LN27@analyze_se:

; 3940 :       else
; 3941 :         assert(0);
; 3942 :     }
; 3943 : 
; 3944 :   kd_mct_ss_model *model = ss_models+which_input;

	mov	eax, DWORD PTR _which_input$[ebp]

; 3945 :   for (kdu_int16 n=0; n < model->range_len; n++)

	xor	edx, edx
	mov	ebx, DWORD PTR [esi+32]
	mov	DWORD PTR tv378[ebp], ebx
	lea	ecx, DWORD PTR [eax+eax*2]
	xor	eax, eax
	mov	DWORD PTR tv377[ebp], ecx
	mov	DWORD PTR _n$1$[ebp], eax
	cmp	dx, WORD PTR [ebx+ecx*4+2]
	jge	$LN7@analyze_se
	mov	edx, DWORD PTR _max_output_idx$[ebp]
	mov	edi, DWORD PTR _min_output_idx$[ebp]
	movss	xmm1, DWORD PTR _input_weight$[ebp]
$LL8@analyze_se:

; 3946 :     {
; 3947 :       int out_idx = output_indices[model->range_min + n];

	movsx	ecx, WORD PTR [ebx+ecx*4]
	cwde
	add	ecx, eax
	mov	DWORD PTR tv403[ebp], eax
	mov	eax, DWORD PTR [esi+28]
	mov	ebx, DWORD PTR [eax+ecx*4]

; 3948 :       kd_output_comp_info *oci = stage->output_comp_info+out_idx;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ebx+ebx*4]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR tv387[ebp], ecx
	mov	DWORD PTR tv388[ebp], eax

; 3949 :       if (oci->is_of_interest || !restrict_to_interest)

	cmp	BYTE PTR [eax+ecx*8+32], 0
	jne	SHORT $LN30@analyze_se
	cmp	BYTE PTR _restrict_to_interest$[ebp], 0
	jne	$LN58@analyze_se
$LN30@analyze_se:

; 3950 :         {
; 3951 :           if (min_output_idx > max_output_idx)

	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [edx]
	jle	SHORT $LN40@analyze_se

; 3952 :             {
; 3953 :               min_output_idx = max_output_idx = out_idx;

	mov	DWORD PTR [edx], ebx
	mov	DWORD PTR [edi], ebx

; 3954 :               oci->ss_tmp = 0.0F;

	mov	ebx, DWORD PTR tv388[ebp]
	mov	DWORD PTR [ebx+ecx*8+36], 0

; 3955 :             }
; 3956 :           else

	jmp	SHORT $LN12@analyze_se
$LN40@analyze_se:

; 3957 :             {
; 3958 :               while (min_output_idx > out_idx)

	cmp	eax, ebx
	jle	SHORT $LN41@analyze_se
$LL9@analyze_se:

; 3959 :                 stage->output_comp_info[--min_output_idx].ss_tmp = 0.0F;

	dec	DWORD PTR [edi]
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [eax+ecx*8+36], 0
	cmp	DWORD PTR [edi], ebx
	jg	SHORT $LL9@analyze_se
$LN41@analyze_se:

; 3960 :               while (max_output_idx < out_idx)

	cmp	DWORD PTR [edx], ebx
	jge	SHORT $LN57@analyze_se
	npad	2
$LL11@analyze_se:

; 3961 :                 stage->output_comp_info[++max_output_idx].ss_tmp = 0.0F;

	inc	DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [eax+ecx*8+36], 0
	cmp	DWORD PTR [edx], ebx
	jl	SHORT $LL11@analyze_se
$LN57@analyze_se:
	mov	ebx, DWORD PTR tv388[ebp]
$LN12@analyze_se:

; 3962 :             }
; 3963 :           oci->ss_tmp += input_weight * model->ss_vals[n];

	mov	ecx, DWORD PTR tv377[ebp]
	mov	eax, DWORD PTR tv378[ebp]
	mov	edi, DWORD PTR tv403[ebp]
	mov	eax, DWORD PTR [eax+ecx*4+4]
	movss	xmm0, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR tv387[ebp]
	mov	edi, DWORD PTR _min_output_idx$[ebp]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [ebx+eax*8+36]
	movss	DWORD PTR [ebx+eax*8+36], xmm0
	jmp	SHORT $LN6@analyze_se
$LN58@analyze_se:
	mov	ecx, DWORD PTR tv377[ebp]
$LN6@analyze_se:

; 3945 :   for (kdu_int16 n=0; n < model->range_len; n++)

	mov	eax, DWORD PTR _n$1$[ebp]
	mov	ebx, DWORD PTR tv378[ebp]
	inc	eax
	mov	DWORD PTR _n$1$[ebp], eax
	cmp	ax, WORD PTR [ebx+ecx*4+2]
	jl	$LL8@analyze_se
$LN7@analyze_se:

; 3964 :         }
; 3965 :     }
; 3966 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z$0:
	xor	ebx, ebx
	mov	eax, DWORD PTR $T2[ebp]
	mov	ecx, 12					; 0000000cH
	mul	ecx
	seto	bl
	neg	ebx
	or	ebx, eax
	xor	eax, eax
	add	ebx, 4
	setb	al
	neg	eax
	or	eax, ebx
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
__ehhandler$?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z ENDP	; kd_mct_block::analyze_sensitivity
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_mct_block@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_mct_block@@QAE@XZ PROC				; kd_mct_block::~kd_mct_block, COMDAT
; _this$ = ecx

; 1916 :       {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_mct_block@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1917 :         if (input_indices != NULL) delete[] input_indices;

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN2@kd_mct_blo
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_mct_blo:

; 1918 :         if (inputs_required != NULL) delete[] inputs_required;

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN3@kd_mct_blo
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@kd_mct_blo:

; 1919 :         if (output_indices != NULL) delete[] output_indices;

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN4@kd_mct_blo
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN4@kd_mct_blo:

; 1920 :         if (dwt_step_info != NULL) delete[] dwt_step_info;

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN5@kd_mct_blo
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@kd_mct_blo:

; 1921 :         if (dwt_coefficients != NULL) delete[] dwt_coefficients;

	mov	eax, DWORD PTR [esi+76]
	test	eax, eax
	je	SHORT $LN6@kd_mct_blo
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@kd_mct_blo:

; 1922 :         if (scratch != NULL) delete[] scratch;

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	je	SHORT $LN7@kd_mct_blo
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@kd_mct_blo:

; 1923 :         if (ss_models != NULL) delete[] ss_models;

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN15@kd_mct_blo
	push	OFFSET ??1kd_mct_ss_model@@QAE@XZ	; kd_mct_ss_model::~kd_mct_ss_model
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	12					; 0000000cH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax*4+4]
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN15@kd_mct_blo:

; 1924 :       }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1kd_mct_block@@QAE@XZ$0:
	call	___std_terminate
	ret	0
__ehhandler$??1kd_mct_block@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_mct_block@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_mct_block@@QAE@XZ ENDP				; kd_mct_block::~kd_mct_block
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_mct_block@@QAE@XZ
_TEXT	SEGMENT
??0kd_mct_block@@QAE@XZ PROC				; kd_mct_block::kd_mct_block, COMDAT
; _this$ = ecx

; 1914 :     kd_mct_block() { memset(this,0,sizeof(*this)); }

	push	esi
	push	108					; 0000006cH
	mov	esi, ecx
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi
	ret	0
??0kd_mct_block@@QAE@XZ ENDP				; kd_mct_block::kd_mct_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Ekd_mct_ss_model@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekd_mct_ss_model@@QAEPAXI@Z PROC			; kd_mct_ss_model::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekd_mct_ss_model@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kd_mct_ss_model@@QAE@XZ	; kd_mct_ss_model::~kd_mct_ss_model
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	12					; 0000000cH
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	mov	ecx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [ecx*4+4]
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:

; 1898 :     ~kd_mct_ss_model() { if (ss_handle != NULL) delete[] ss_handle; }

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN7@vector
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@vector:
	test	bl, 1
	je	SHORT $LN4@vector
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Ekd_mct_ss_model@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekd_mct_ss_model@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekd_mct_ss_model@@QAEPAXI@Z ENDP			; kd_mct_ss_model::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_mct_ss_model@@QAE@XZ
_TEXT	SEGMENT
??1kd_mct_ss_model@@QAE@XZ PROC				; kd_mct_ss_model::~kd_mct_ss_model, COMDAT
; _this$ = ecx

; 1898 :     ~kd_mct_ss_model() { if (ss_handle != NULL) delete[] ss_handle; }

	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@kd_mct_ss_
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN2@kd_mct_ss_:
	ret	0
??1kd_mct_ss_model@@QAE@XZ ENDP				; kd_mct_ss_model::~kd_mct_ss_model
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_mct_ss_model@@QAE@XZ
_TEXT	SEGMENT
??0kd_mct_ss_model@@QAE@XZ PROC				; kd_mct_ss_model::kd_mct_ss_model, COMDAT
; _this$ = ecx

; 1897 :     kd_mct_ss_model()  { ss_vals = ss_handle = NULL; }

	mov	DWORD PTR [ecx+8], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kd_mct_ss_model@@QAE@XZ ENDP				; kd_mct_ss_model::kd_mct_ss_model
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_output_comp_info@@QAE@XZ
_TEXT	SEGMENT
??0kd_output_comp_info@@QAE@XZ PROC			; kd_output_comp_info::kd_output_comp_info, COMDAT
; _this$ = ecx

; 1825 :       {
; 1826 :         precision=0; is_signed=false; subsampling_ref = NULL;

	mov	DWORD PTR [ecx], 0

; 1827 :         apparent_idx=-1; from_apparent=0;
; 1828 :         block=NULL; block_comp_idx=0; apparent_block_comp_idx=0;
; 1829 :         is_of_interest=false; ss_tmp=0.0F;
; 1830 :       }

	mov	eax, ecx
	mov	BYTE PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], -1
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	BYTE PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	ret	0
??0kd_output_comp_info@@QAE@XZ ENDP			; kd_output_comp_info::kd_output_comp_info
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kd_comp_info@@QAE@XZ
_TEXT	SEGMENT
??0kd_comp_info@@QAE@XZ PROC				; kd_comp_info::kd_comp_info, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kd_comp_info@@QAE@XZ ENDP				; kd_comp_info::kd_comp_info
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Ekd_global_rescomp@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekd_global_rescomp@@QAEPAXI@Z PROC			; kd_global_rescomp::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekd_global_rescomp@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kd_global_rescomp@@QAE@XZ	; kd_global_rescomp::~kd_global_rescomp
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	80					; 00000050H
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	mov	ecx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 4
	add	ecx, 4
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:

; 1709 :     ~kd_global_rescomp() { close_all(); }

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?close_all@kd_global_rescomp@@QAEXXZ	; kd_global_rescomp::close_all
	test	bl, 1
	je	SHORT $LN4@vector
	push	80					; 00000050H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Ekd_global_rescomp@@QAEPAXI@Z$0:
	call	___std_terminate
	ret	0
__ehhandler$??_Ekd_global_rescomp@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekd_global_rescomp@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekd_global_rescomp@@QAEPAXI@Z ENDP			; kd_global_rescomp::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?close_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 16
_dims$ = -20						; size = 16
_this$1$ = -4						; size = 4
_precinct$ = 8						; size = 4
?close_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z PROC ; kd_global_rescomp::close_ready_precinct, COMDAT
; _this$ = ecx

; 3099 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	edx, ecx

; 3100 :   // Remove from ready list
; 3101 :   if (precinct->prev == NULL)

	mov	ecx, DWORD PTR _precinct$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	esi, DWORD PTR [ecx+48]

; 3102 :     {
; 3103 :       assert(precinct == first_ready);
; 3104 :       first_ready = precinct->next;

	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR _this$1$[ebp], edx
	test	esi, esi
	jne	SHORT $LN2@close_read
	mov	DWORD PTR [edx+48], eax

; 3105 :     }
; 3106 :   else

	jmp	SHORT $LN3@close_read
$LN2@close_read:

; 3107 :     precinct->prev->next = precinct->next;

	mov	DWORD PTR [esi+44], eax
$LN3@close_read:

; 3108 :   if (precinct->next == NULL)

	mov	esi, DWORD PTR [ecx+44]

; 3109 :     {
; 3110 :       assert(precinct == last_ready);
; 3111 :       last_ready = precinct->prev;

	mov	eax, DWORD PTR [ecx+48]
	test	esi, esi
	jne	SHORT $LN4@close_read
	mov	DWORD PTR [edx+52], eax

; 3112 :     }
; 3113 :   else

	jmp	SHORT $LN5@close_read
$LN4@close_read:

; 3114 :     precinct->next->prev = precinct->prev;

	mov	DWORD PTR [esi+48], eax
$LN5@close_read:

; 3115 :   precinct->prev = precinct->next = NULL;
; 3116 :   
; 3117 :   // Calculate area
; 3118 :   kd_resolution *res = precinct->resolution;

	mov	ebx, DWORD PTR [ecx]

; 3119 :   int p_idx = (int)(precinct->ref - res->precinct_refs);

	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	sub	esi, DWORD PTR [ebx+180]

; 3121 :   idx.y = p_idx / res->precinct_indices.size.x;

	mov	ecx, DWORD PTR [ebx+148]
	sar	esi, 3
	mov	eax, esi
	cdq
	idiv	ecx

; 3123 :   idx += res->precinct_indices.pos;
; 3124 :   kdu_dims dims = res->precinct_partition;

	movups	xmm1, XMMWORD PTR [ebx+120]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	mov	edx, DWORD PTR [ebx+140]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3121 :   idx.y = p_idx / res->precinct_indices.size.x;

	mov	edi, eax

; 3122 :   idx.x = p_idx - idx.y*res->precinct_indices.size.x;

	imul	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	add	edi, DWORD PTR [ebx+136]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3125 :   dims.pos.x += dims.size.x*idx.x;

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	movups	XMMWORD PTR _dims$[ebp], xmm1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	sub	edx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3125 :   dims.pos.x += dims.size.x*idx.x;

	psrldq	xmm1, 4
	movd	ecx, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	add	edx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3125 :   dims.pos.x += dims.size.x*idx.x;

	movd	eax, xmm1
	imul	ecx, edx
	add	eax, ecx

; 3126 :   dims.pos.y += dims.size.y*idx.y;
; 3127 :   dims &= res->node.dims;

	lea	ecx, DWORD PTR _dims$[ebp]
	mov	DWORD PTR _dims$[ebp+4], eax
	mov	eax, DWORD PTR _dims$[ebp+8]
	imul	eax, edi
	add	DWORD PTR _dims$[ebp], eax
	lea	eax, DWORD PTR [ebx+24]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR _dims$[ebp+12]
	imul	DWORD PTR _dims$[ebp+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3131 :   ready_fraction = reciprocal_fraction = -1.0;

	movaps	xmm0, XMMWORD PTR __xmm@bff0000000000000bff0000000000000
	mov	ecx, DWORD PTR _this$1$[ebp]
	sub	DWORD PTR [ecx+56], eax
	movups	XMMWORD PTR [ecx+64], xmm0
	sbb	DWORD PTR [ecx+60], edx
	sub	DWORD PTR [ecx+40], eax
	sbb	DWORD PTR [ecx+44], edx

; 3132 : 
; 3133 :   // Close the precinct itself
; 3134 :   precinct->ref->close();

	mov	ecx, DWORD PTR _precinct$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close
	pop	edi
	pop	esi
	pop	ebx

; 3135 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?close_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z ENDP ; kd_global_rescomp::close_ready_precinct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?add_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 16
_dims$ = -20						; size = 16
_this$1$ = -4						; size = 4
_precinct$ = 8						; size = 4
?add_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z PROC ; kd_global_rescomp::add_ready_precinct, COMDAT
; _this$ = ecx

; 3069 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 3070 :   // Add to ready list
; 3071 :   assert((precinct->prev == NULL) && (precinct->next == NULL) &&
; 3072 :          (precinct != first_ready));
; 3073 :   if ((precinct->prev = last_ready) == NULL)

	mov	eax, DWORD PTR [ecx+52]
	mov	DWORD PTR _this$1$[ebp], ecx
	push	ebx
	push	esi
	mov	esi, DWORD PTR _precinct$[ebp]
	push	edi
	mov	DWORD PTR [esi+48], eax
	test	eax, eax
	jne	SHORT $LN2@add_ready_

; 3074 :     first_ready = last_ready = precinct;

	mov	DWORD PTR [ecx+48], esi

; 3075 :   else

	jmp	SHORT $LN11@add_ready_
$LN2@add_ready_:

; 3076 :     last_ready = last_ready->next = precinct;

	mov	eax, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+44], esi
$LN11@add_ready_:
	mov	DWORD PTR [ecx+52], esi

; 3077 :   
; 3078 :   // Calculate area
; 3079 :   kd_resolution *res = precinct->resolution;

	mov	ebx, DWORD PTR [esi]

; 3080 :   int p_idx = (int)(precinct->ref - res->precinct_refs);

	mov	esi, DWORD PTR [esi+4]
	sub	esi, DWORD PTR [ebx+180]

; 3082 :   idx.y = p_idx / res->precinct_indices.size.x;

	mov	ecx, DWORD PTR [ebx+148]
	sar	esi, 3
	mov	eax, esi
	cdq
	idiv	ecx

; 3084 :   idx += res->precinct_indices.pos;
; 3085 :   kdu_dims dims = res->precinct_partition;

	movups	xmm1, XMMWORD PTR [ebx+120]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	mov	edx, DWORD PTR [ebx+140]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3082 :   idx.y = p_idx / res->precinct_indices.size.x;

	mov	edi, eax

; 3083 :   idx.x = p_idx - idx.y*res->precinct_indices.size.x;

	imul	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	add	edi, DWORD PTR [ebx+136]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3086 :   dims.pos.x += dims.size.x*idx.x;

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	movups	XMMWORD PTR _dims$[ebp], xmm1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	sub	edx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3086 :   dims.pos.x += dims.size.x*idx.x;

	psrldq	xmm1, 4
	movd	ecx, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	add	edx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3086 :   dims.pos.x += dims.size.x*idx.x;

	movd	eax, xmm1
	imul	ecx, edx
	add	eax, ecx

; 3087 :   dims.pos.y += dims.size.y*idx.y;
; 3088 :   dims &= res->node.dims;

	lea	ecx, DWORD PTR _dims$[ebp]
	mov	DWORD PTR _dims$[ebp+4], eax
	mov	eax, DWORD PTR _dims$[ebp+8]
	imul	eax, edi
	add	DWORD PTR _dims$[ebp], eax
	lea	eax, DWORD PTR [ebx+24]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR _dims$[ebp+12]
	imul	DWORD PTR _dims$[ebp+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3090 :   ready_fraction = reciprocal_fraction = -1.0;

	movaps	xmm0, XMMWORD PTR __xmm@bff0000000000000bff0000000000000
	mov	ecx, DWORD PTR _this$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	DWORD PTR [ecx+56], eax
	movups	XMMWORD PTR [ecx+64], xmm0
	adc	DWORD PTR [ecx+60], edx

; 3091 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?add_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z ENDP ; kd_global_rescomp::add_ready_precinct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?notify_tile_status@kd_global_rescomp@@QAEXUkdu_dims@@_N@Z
_TEXT	SEGMENT
_this$1$ = -24						; size = 4
_lim$3$ = -20						; size = 4
_min$1$ = -20						; size = 4
$T1 = -16						; size = 4
_lim$1$ = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
$T4 = -4						; size = 4
_tile_dims$ = 8						; size = 16
_uses_this_resolution$ = 24				; size = 1
?notify_tile_status@kd_global_rescomp@@QAEXUkdu_dims@@_N@Z PROC ; kd_global_rescomp::notify_tile_status, COMDAT
; _this$ = ecx

; 3041 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	edx, DWORD PTR _tile_dims$[ebp+4]
	mov	eax, DWORD PTR _tile_dims$[ebp+12]
	add	eax, edx
	push	ebx
	mov	ebx, DWORD PTR _tile_dims$[ebp]
	mov	DWORD PTR _lim$1$[ebp], eax
	mov	eax, DWORD PTR _tile_dims$[ebp+8]
	push	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3041 : {

	mov	esi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	eax, ebx
	mov	DWORD PTR _lim$3$[ebp], eax
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3041 : {

	mov	DWORD PTR _this$1$[ebp], esi

; 3042 :   kdu_coords min = tile_dims.pos;
; 3043 :   kdu_coords lim = min + tile_dims.size;
; 3044 :   kd_comp_info *ci = codestream->comp_info + comp_idx;

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+eax*2]
	shl	edi, 5
	add	edi, DWORD PTR [ecx+256]

; 3045 :   min.x = ceil_ratio(min.x,ci->sub_sampling.x);

	mov	ecx, DWORD PTR [edi+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	edx, edx
	jg	SHORT $LN10@notify_til

; 180  :     return -((-num)/den);

	mov	eax, edx
	cdq
	idiv	ecx
	jmp	SHORT $LN25@notify_til
$LN10@notify_til:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [edx-1]
	cdq
	idiv	ecx
	inc	eax
$LN25@notify_til:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3046 :   min.y = ceil_ratio(min.y,ci->sub_sampling.y);

	mov	ecx, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 182  :     return 1+((num-1)/den);

	mov	DWORD PTR $T4[ebp], eax

; 179  :   if (num <= 0)

	test	ebx, ebx
	jg	SHORT $LN14@notify_til

; 180  :     return -((-num)/den);

	mov	eax, ebx
	cdq
	idiv	ecx
	mov	DWORD PTR $T3[ebp], eax
	jmp	SHORT $LN15@notify_til
$LN14@notify_til:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ebx-1]
	cdq
	idiv	ecx
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR $T3[ebp], edx
$LN15@notify_til:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _lim$1$[ebp]
	test	eax, eax
	jg	SHORT $LN18@notify_til

; 180  :     return -((-num)/den);

	cdq
	idiv	DWORD PTR [edi+4]
	jmp	SHORT $LN26@notify_til
$LN18@notify_til:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	DWORD PTR [edi+4]
	inc	eax
$LN26@notify_til:
	mov	DWORD PTR $T2[ebp], eax

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _lim$3$[ebp]
	test	eax, eax
	jg	SHORT $LN22@notify_til

; 180  :     return -((-num)/den);

	cdq
	idiv	ecx
	jmp	SHORT $LN27@notify_til
$LN22@notify_til:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ecx
	inc	eax
$LN27@notify_til:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3049 :   min.x = 1 + ((min.x-1)>>(ci->hor_depth[depth]));

	mov	edx, DWORD PTR $T4[ebp]

; 3050 :   min.y = 1 + ((min.y-1)>>(ci->vert_depth[depth]));

	mov	ebx, DWORD PTR $T3[ebp]
	dec	edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 182  :     return 1+((num-1)/den);

	mov	DWORD PTR $T1[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3050 :   min.y = 1 + ((min.y-1)>>(ci->vert_depth[depth]));

	dec	ebx
	mov	eax, DWORD PTR [esi+4]
	movzx	esi, BYTE PTR [eax+edi+21]
	mov	ecx, esi
	sar	edx, cl
	inc	edx
	mov	DWORD PTR _min$1$[ebp], edx
	movzx	edx, BYTE PTR [eax+edi+54]

; 3051 :   lim.x = 1 + ((lim.x-1)>>(ci->hor_depth[depth]));

	mov	edi, DWORD PTR $T2[ebp]
	mov	ecx, edx

; 3052 :   lim.y = 1 + ((lim.y-1)>>(ci->vert_depth[depth]));

	mov	eax, DWORD PTR $T1[ebp]
	dec	edi
	sar	ebx, cl
	dec	eax
	mov	ecx, esi
	inc	ebx
	sar	edi, cl
	mov	ecx, edx
	sar	eax, cl
	inc	edi

; 3053 :   kdu_long tile_area = ((kdu_long)(lim.x-min.x)) * ((kdu_long)(lim.y-min.y));

	sub	edi, DWORD PTR _min$1$[ebp]
	inc	eax
	sub	eax, ebx
	imul	edi
	pop	edi
	mov	ecx, eax

; 3054 :   area_covered_by_tiles += tile_area;

	mov	eax, DWORD PTR _this$1$[ebp]
	pop	esi
	pop	ebx
	add	DWORD PTR [eax+32], ecx
	adc	DWORD PTR [eax+36], edx

; 3055 :   if (uses_this_resolution)

	cmp	BYTE PTR _uses_this_resolution$[ebp], 0
	je	SHORT $LN2@notify_til

; 3056 :     area_used_by_tiles += tile_area;

	add	DWORD PTR [eax+24], ecx

; 3059 :   assert((area_covered_by_tiles <= total_area) && (remaining_area >= 0));
; 3060 :   ready_fraction = reciprocal_fraction = -1.0;

	movaps	xmm0, XMMWORD PTR __xmm@bff0000000000000bff0000000000000
	adc	DWORD PTR [eax+28], edx
	movups	XMMWORD PTR [eax+64], xmm0

; 3061 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN2@notify_til:

; 3057 :   else
; 3058 :     remaining_area -= tile_area;

	sub	DWORD PTR [eax+40], ecx

; 3059 :   assert((area_covered_by_tiles <= total_area) && (remaining_area >= 0));
; 3060 :   ready_fraction = reciprocal_fraction = -1.0;

	movaps	xmm0, XMMWORD PTR __xmm@bff0000000000000bff0000000000000
	sbb	DWORD PTR [eax+44], edx
	movups	XMMWORD PTR [eax+64], xmm0

; 3061 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?notify_tile_status@kd_global_rescomp@@QAEXUkdu_dims@@_N@Z ENDP ; kd_global_rescomp::notify_tile_status
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?initialize@kd_global_rescomp@@QAEXPAUkd_codestream@@HH@Z
_TEXT	SEGMENT
_this$1$ = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
$T3 = 8							; size = 4
_codestream$ = 8					; size = 4
_depth$ = 12						; size = 4
$T4 = 16						; size = 4
_min$3$ = 16						; size = 4
_comp_idx$ = 16						; size = 4
?initialize@kd_global_rescomp@@QAEXPAUkd_codestream@@HH@Z PROC ; kd_global_rescomp::initialize, COMDAT
; _this$ = ecx

; 3011 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$1$[ebp], esi

; 3012 :   close_all();

	call	?close_all@kd_global_rescomp@@QAEXXZ	; kd_global_rescomp::close_all

; 3013 :   this->codestream = codestream;

	mov	edx, DWORD PTR _codestream$[ebp]

; 3014 :   this->depth = depth; this->comp_idx = comp_idx;

	mov	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR _comp_idx$[ebp]
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+8], eax

; 3015 :   kdu_coords min = codestream->region.pos;

	mov	ecx, DWORD PTR [edx+208]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	ebx, DWORD PTR [edx+216]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3017 :   kd_comp_info *ci = codestream->comp_info + comp_idx;

	lea	esi, DWORD PTR [eax+eax*2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	ebx, DWORD PTR [edx+208]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR [edx+212]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3017 :   kd_comp_info *ci = codestream->comp_info + comp_idx;

	shl	esi, 5
	add	esi, DWORD PTR [edx+256]
	mov	DWORD PTR _min$3$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	ecx, DWORD PTR [edx+220]
	add	ecx, DWORD PTR [edx+212]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3018 :   min.x = ceil_ratio(min.x,ci->sub_sampling.x);

	mov	edi, DWORD PTR [esi+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN8@initialize

; 180  :     return -((-num)/den);

	cdq
	idiv	edi
	mov	DWORD PTR $T3[ebp], eax
	jmp	SHORT $LN9@initialize
$LN8@initialize:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	edi
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR $T3[ebp], edx
$LN9@initialize:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _min$3$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3019 :   min.y = ceil_ratio(min.y,ci->sub_sampling.y);

	mov	edi, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN12@initialize

; 180  :     return -((-num)/den);

	cdq
	idiv	edi
	jmp	SHORT $LN23@initialize
$LN12@initialize:

; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	edi
	inc	eax
$LN23@initialize:
	mov	DWORD PTR $T4[ebp], eax

; 179  :   if (num <= 0)

	test	ecx, ecx
	jg	SHORT $LN16@initialize

; 180  :     return -((-num)/den);

	mov	eax, ecx
	cdq
	idiv	DWORD PTR [esi+4]
	jmp	SHORT $LN24@initialize
$LN16@initialize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ecx-1]
	cdq
	idiv	DWORD PTR [esi+4]
	inc	eax
$LN24@initialize:
	mov	DWORD PTR $T2[ebp], eax

; 179  :   if (num <= 0)

	test	ebx, ebx
	jg	SHORT $LN20@initialize

; 180  :     return -((-num)/den);

	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN25@initialize
$LN20@initialize:

; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ebx-1]
	cdq
	idiv	edi
	inc	eax
$LN25@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3022 :   min.x = 1 + ((min.x-1)>>(ci->hor_depth[depth]));

	mov	edx, DWORD PTR _depth$[ebp]
	mov	ebx, DWORD PTR $T3[ebp]

; 3023 :   min.y = 1 + ((min.y-1)>>(ci->vert_depth[depth]));

	mov	edi, DWORD PTR $T4[ebp]
	dec	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 182  :     return 1+((num-1)/den);

	mov	DWORD PTR $T1[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3023 :   min.y = 1 + ((min.y-1)>>(ci->vert_depth[depth]));

	dec	edi
	movzx	eax, BYTE PTR [esi+edx+21]
	movzx	edx, BYTE PTR [esi+edx+54]
	mov	ecx, eax

; 3024 :   lim.x = 1 + ((lim.x-1)>>(ci->hor_depth[depth]));

	mov	esi, DWORD PTR $T2[ebp]

; 3025 :   lim.y = 1 + ((lim.y-1)>>(ci->vert_depth[depth]));
; 3026 :   total_area = ((kdu_long)(lim.x-min.x)) * ((kdu_long)(lim.y-min.y));
; 3027 :   area_used_by_tiles = area_covered_by_tiles = 0;
; 3028 :   remaining_area = total_area;
; 3029 :   first_ready = last_ready = NULL;
; 3030 :   ready_area = 0;
; 3031 :   ready_fraction = reciprocal_fraction = -1.0;

	movaps	xmm0, XMMWORD PTR __xmm@bff0000000000000bff0000000000000
	dec	esi
	sar	ebx, cl
	mov	ecx, edx
	sar	edi, cl
	inc	ebx
	mov	ecx, eax
	inc	edi
	mov	eax, DWORD PTR $T1[ebp]
	sar	esi, cl
	dec	eax
	mov	ecx, edx
	inc	esi
	sar	eax, cl
	sub	esi, ebx
	mov	ecx, DWORD PTR _this$1$[ebp]
	inc	eax
	sub	eax, edi
	imul	esi
	movups	XMMWORD PTR [ecx+64], xmm0
	pop	edi
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+40], eax
	mov	eax, edx
	pop	esi
	mov	DWORD PTR [ecx+20], edx
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+44], eax
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 0
	pop	ebx

; 3032 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?initialize@kd_global_rescomp@@QAEXPAUkd_codestream@@HH@Z ENDP ; kd_global_rescomp::initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?close_all@kd_global_rescomp@@QAEXXZ
_TEXT	SEGMENT
?close_all@kd_global_rescomp@@QAEXXZ PROC		; kd_global_rescomp::close_all, COMDAT
; _this$ = ecx

; 2995 : {

	push	esi
	mov	esi, ecx

; 2996 :   while ((last_ready=first_ready) != NULL)

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+52], eax
	test	eax, eax
	je	SHORT $LN3@close_all
	npad	3
$LL2@close_all:

; 2997 :     {
; 2998 :       first_ready = last_ready->next;

	mov	eax, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [eax+44]
	mov	DWORD PTR [esi+48], eax

; 2999 :       last_ready->next = last_ready->prev = NULL;

	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+48], 0
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax+44], 0

; 3000 :       last_ready->ref->close();

	mov	ecx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [ecx+4]
	call	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+52], eax
	test	eax, eax
	jne	SHORT $LL2@close_all
$LN3@close_all:
	pop	esi

; 3001 :     }
; 3002 : }

	ret	0
?close_all@kd_global_rescomp@@QAEXXZ ENDP		; kd_global_rescomp::close_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_global_rescomp@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_global_rescomp@@QAE@XZ PROC			; kd_global_rescomp::~kd_global_rescomp, COMDAT
; _this$ = ecx

; 1709 :     ~kd_global_rescomp() { close_all(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_global_rescomp@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	call	?close_all@kd_global_rescomp@@QAEXXZ	; kd_global_rescomp::close_all
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kd_global_rescomp@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_global_rescomp@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_global_rescomp@@QAE@XZ ENDP			; kd_global_rescomp::~kd_global_rescomp
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_global_rescomp@@QAE@XZ
_TEXT	SEGMENT
??0kd_global_rescomp@@QAE@XZ PROC			; kd_global_rescomp::kd_global_rescomp, COMDAT
; _this$ = ecx

; 1702 :       {
; 1703 :         codestream = NULL; depth = comp_idx = 0;
; 1704 :         total_area = area_used_by_tiles = area_covered_by_tiles = 0;
; 1705 :         remaining_area = ready_area = 0;
; 1706 :         ready_fraction = reciprocal_fraction = -1.0;

	movaps	xmm0, XMMWORD PTR __xmm@bff0000000000000bff0000000000000

; 1707 :         first_ready = last_ready = NULL;
; 1708 :       }

	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	movups	XMMWORD PTR [ecx+64], xmm0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+48], 0
	ret	0
??0kd_global_rescomp@@QAE@XZ ENDP			; kd_global_rescomp::kd_global_rescomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Ekd_reslength_checker@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekd_reslength_checker@@QAEPAXI@Z PROC		; kd_reslength_checker::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekd_reslength_checker@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kd_reslength_checker@@QAE@XZ	; kd_reslength_checker::~kd_reslength_checker
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	808					; 00000328H
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	imul	ecx, DWORD PTR [edi], 808
	add	ecx, 4
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:

; 1631 :     ~kd_reslength_checker() { if (specs != NULL) delete[] specs; }

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN7@vector
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@vector:
	test	bl, 1
	je	SHORT $LN4@vector
	push	808					; 00000328H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Ekd_reslength_checker@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekd_reslength_checker@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekd_reslength_checker@@QAEPAXI@Z ENDP		; kd_reslength_checker::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?check_packet@kd_reslength_checker@@QAE_N_JH@Z
_TEXT	SEGMENT
_packet_bytes$ = 8					; size = 8
_depth$ = 16						; size = 4
?check_packet@kd_reslength_checker@@QAE_N_JH@Z PROC	; kd_reslength_checker::check_packet, COMDAT
; _this$ = ecx

; 1654 :       {

	push	ebp
	mov	ebp, esp

; 1655 :         assert((depth >= 0) && (depth <= 32));
; 1656 :         if ((current_layer_idx < 0) || (specs == NULL)) return true;

	cmp	DWORD PTR [ecx+8], 0
	jl	SHORT $LN6@check_pack
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN6@check_pack

; 1657 :         kdu_long lim;
; 1658 :         for (int d=0; (d <= depth) && ((lim=max_bytes[d]) > 0); d++)

	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _depth$[ebp]
	xor	edx, edx
	test	edi, edi
	js	SHORT $LN3@check_pack
	mov	ebx, DWORD PTR _packet_bytes$[ebp+4]
	lea	eax, DWORD PTR [ecx+280]
	npad	12
$LL4@check_pack:
	mov	esi, DWORD PTR [eax-260]
	mov	ecx, DWORD PTR [eax-264]
	test	esi, esi
	jl	SHORT $LN3@check_pack
	jg	SHORT $LN14@check_pack
	test	ecx, ecx
	je	SHORT $LN3@check_pack
$LN14@check_pack:

; 1659 :           if ((num_bytes[d] += packet_bytes) > lim) return false;

	mov	edi, DWORD PTR _packet_bytes$[ebp]
	add	DWORD PTR [eax], edi
	mov	edi, DWORD PTR _depth$[ebp]
	adc	DWORD PTR [eax+4], ebx
	cmp	DWORD PTR [eax+4], esi
	jg	SHORT $LN10@check_pack
	jl	SHORT $LN15@check_pack
	cmp	DWORD PTR [eax], ecx
	ja	SHORT $LN10@check_pack
$LN15@check_pack:

; 1657 :         kdu_long lim;
; 1658 :         for (int d=0; (d <= depth) && ((lim=max_bytes[d]) > 0); d++)

	inc	edx
	add	eax, 8
	cmp	edx, edi
	jle	SHORT $LL4@check_pack
$LN3@check_pack:
	pop	edi
	pop	esi

; 1660 :         return true;

	mov	al, 1
	pop	ebx

; 1661 :       }

	pop	ebp
	ret	12					; 0000000cH
$LN10@check_pack:
	pop	edi
	pop	esi

; 1659 :           if ((num_bytes[d] += packet_bytes) > lim) return false;

	xor	al, al
	pop	ebx

; 1661 :       }

	pop	ebp
	ret	12					; 0000000cH
$LN6@check_pack:

; 1655 :         assert((depth >= 0) && (depth <= 32));
; 1656 :         if ((current_layer_idx < 0) || (specs == NULL)) return true;

	mov	al, 1

; 1661 :       }

	pop	ebp
	ret	12					; 0000000cH
?check_packet@kd_reslength_checker@@QAE_N_JH@Z ENDP	; kd_reslength_checker::check_packet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_layer@kd_reslength_checker@@QAEXH@Z
_TEXT	SEGMENT
tv228 = -4						; size = 4
_layer_idx$ = 8						; size = 4
?set_layer@kd_reslength_checker@@QAEXH@Z PROC		; kd_reslength_checker::set_layer, COMDAT
; _this$ = ecx

; 2952 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx

; 2953 :   if (specs == NULL)

	cmp	DWORD PTR [ebx+4], 0
	je	$LN1@set_layer

; 2954 :     return;
; 2955 :   if (layer_idx == current_layer_idx)

	mov	ecx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR _layer_idx$[ebp]
	push	esi
	push	edi
	cmp	eax, ecx
	jne	SHORT $LN6@set_layer

; 2956 :     memcpy(num_bytes,prev_layer_bytes,33*sizeof(kdu_long));

	lea	esi, DWORD PTR [ebx+544]
	mov	ecx, 66					; 00000042H
	lea	edi, DWORD PTR [ebx+280]
	rep movsd
	jmp	SHORT $LN10@set_layer
$LN6@set_layer:

; 2957 :   else if (layer_idx == 0)

	test	eax, eax
	jne	SHORT $LN8@set_layer

; 2958 :     {
; 2959 :       memset(num_bytes,0,33*sizeof(kdu_long));
; 2960 :       memset(prev_layer_bytes,0,33*sizeof(kdu_long));

	push	528					; 00000210H
	push	eax
	lea	eax, DWORD PTR [ebx+280]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN28@set_layer
$LN8@set_layer:

; 2961 :     }
; 2962 :   else if (layer_idx == (current_layer_idx+1))

	lea	eax, DWORD PTR [ecx+1]
	cmp	DWORD PTR _layer_idx$[ebp], eax
	jne	SHORT $LN28@set_layer

; 2963 :     memcpy(prev_layer_bytes,num_bytes,33*sizeof(kdu_long));

	lea	esi, DWORD PTR [ebx+280]
	mov	ecx, 66					; 00000042H
	lea	edi, DWORD PTR [ebx+544]
	rep movsd
$LN28@set_layer:
	mov	eax, DWORD PTR _layer_idx$[ebp]
$LN10@set_layer:

; 2964 :   else
; 2965 :     assert(0);
; 2966 :   if (layer_idx != current_layer_idx)

	cmp	eax, DWORD PTR [ebx+8]
	je	$LN3@set_layer

; 2967 :     { // Parse contents of the `specs' array for this layer
; 2968 :       memset(max_bytes,0,33*sizeof(kdu_long));

	push	264					; 00000108H
	lea	eax, DWORD PTR [ebx+16]
	push	0
	push	eax
	call	_memset

; 2969 :       int d, l_idx, n;
; 2970 :       for (l_idx=0, d=0, n=0; n < num_specs; n++, d++)

	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	xor	esi, esi
	xor	edx, edx
	cmp	DWORD PTR [ebx], ecx
	jle	SHORT $LN25@set_layer
$LL4@set_layer:

; 2971 :         {
; 2972 :           if (specs[n] <= 0)

	mov	eax, DWORD PTR [ebx+4]
	mov	edi, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR [eax+edx*8+4]
	mov	DWORD PTR tv228[ebp], eax
	test	eax, eax
	jg	SHORT $LN13@set_layer
	jl	SHORT $LN23@set_layer
	test	edi, edi
	jne	SHORT $LN13@set_layer
$LN23@set_layer:

; 2973 :             { l_idx++; d=-1; continue; }

	inc	esi
	or	ecx, -1
	jmp	SHORT $LN27@set_layer
$LN13@set_layer:

; 2974 :           if (l_idx == layer_idx)

	mov	eax, DWORD PTR _layer_idx$[ebp]
	cmp	esi, eax
	jne	SHORT $LN30@set_layer

; 2975 :             max_bytes[d] = specs[n];

	mov	DWORD PTR [ebx+ecx*8+16], edi
	mov	edi, DWORD PTR tv228[ebp]
	mov	DWORD PTR [ebx+ecx*8+20], edi
	jmp	SHORT $LN2@set_layer
$LN30@set_layer:

; 2976 :           else if ((l_idx > layer_idx) &&

	jle	SHORT $LN2@set_layer
	mov	eax, DWORD PTR [ebx+ecx*8+16]
	or	eax, DWORD PTR [ebx+ecx*8+20]
	mov	eax, DWORD PTR tv228[ebp]
	je	SHORT $LN24@set_layer
	cmp	DWORD PTR [ebx+ecx*8+20], eax
	jl	SHORT $LN27@set_layer
	jg	SHORT $LN24@set_layer
	cmp	DWORD PTR [ebx+ecx*8+16], edi
	jbe	SHORT $LN27@set_layer
$LN24@set_layer:

; 2977 :                    ((max_bytes[d] == 0) || (max_bytes[d] > specs[n])))
; 2978 :             max_bytes[d] = specs[n];

	mov	DWORD PTR [ebx+ecx*8+16], edi
	mov	DWORD PTR [ebx+ecx*8+20], eax
$LN27@set_layer:
	mov	eax, DWORD PTR _layer_idx$[ebp]
$LN2@set_layer:

; 2969 :       int d, l_idx, n;
; 2970 :       for (l_idx=0, d=0, n=0; n < num_specs; n++, d++)

	inc	edx
	inc	ecx
	cmp	edx, DWORD PTR [ebx]
	jl	SHORT $LL4@set_layer

; 2979 :         }
; 2980 :     }
; 2981 :   current_layer_idx = layer_idx;

	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+8], eax
	pop	ebx

; 2982 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN25@set_layer:
	mov	eax, DWORD PTR _layer_idx$[ebp]
$LN3@set_layer:
	pop	edi

; 2979 :         }
; 2980 :     }
; 2981 :   current_layer_idx = layer_idx;

	mov	DWORD PTR [ebx+8], eax
	pop	esi
$LN1@set_layer:
	pop	ebx

; 2982 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?set_layer@kd_reslength_checker@@QAEXH@Z ENDP		; kd_reslength_checker::set_layer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?init@kd_reslength_checker@@QAE_NPAVcod_params@@@Z
_TEXT	SEGMENT
_max_specs$1$ = -8					; size = 4
_val$ = -4						; size = 4
_cod$ = 8						; size = 4
?init@kd_reslength_checker@@QAE_NPAVcod_params@@@Z PROC	; kd_reslength_checker::init, COMDAT
; _this$ = ecx

; 2922 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	edi

; 2923 :   if (specs != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN5@init

; 2924 :     { delete[] specs; specs = NULL; }

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+4], 0
$LN5@init:

; 2925 :   int n, val, max_specs = num_specs = 0;
; 2926 :   current_layer_idx = -1;
; 2927 :   if (cod == NULL)

	mov	eax, DWORD PTR _cod$[ebp]
	xor	edi, edi
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR _max_specs$1$[ebp], edi
	mov	DWORD PTR [esi+8], -1
	test	eax, eax
	jne	SHORT $LN6@init

; 2928 :     return false;

	pop	edi
	xor	al, al
	pop	esi

; 2945 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@init:
	push	ebx

; 2929 :   for (n=0; cod->get(Creslengths,n,0,val,false,false); n++)

	push	1
	xor	ebx, ebx
	lea	ecx, DWORD PTR _val$[ebp]
	push	ebx
	push	ebx
	push	ecx
	push	ebx
	push	ebx
	push	OFFSET ??_C@_0M@HKNEBDCB@Creslengths?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN3@init
	lea	edx, DWORD PTR [ebx+8]
$LL4@init:

; 2930 :     {
; 2931 :       if (max_specs <= n)

	cmp	edi, ebx
	jg	SHORT $LN7@init

; 2932 :         {
; 2933 :           max_specs += max_specs + 8;

	lea	edi, DWORD PTR [edi*2+8]

; 2934 :           kdu_long *new_specs = new kdu_long[max_specs];

	xor	ecx, ecx
	mov	eax, edi
	mov	DWORD PTR _max_specs$1$[ebp], edi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edi, eax
	add	esp, 4

; 2935 :           if (specs != NULL)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN8@init

; 2936 :             {
; 2937 :               memcpy(new_specs,specs,(size_t)(num_specs*sizeof(kdu_long)));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 3
	push	ecx
	push	eax
	push	edi
	call	_memcpy

; 2938 :               delete[] specs;

	push	DWORD PTR [esi+4]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H
$LN8@init:

; 2939 :             }
; 2940 :           specs = new_specs;

	mov	DWORD PTR [esi+4], edi
$LN7@init:

; 2941 :         }
; 2942 :       specs[num_specs++] = val;

	mov	ecx, DWORD PTR [esi]
	inc	ebx
	mov	eax, DWORD PTR _val$[ebp]
	mov	edi, DWORD PTR [esi+4]
	push	1
	push	0
	cdq
	mov	DWORD PTR [edi+ecx*8], eax
	lea	eax, DWORD PTR _val$[ebp]
	push	0
	push	eax
	push	0
	mov	DWORD PTR [edi+ecx*8+4], edx
	mov	ecx, DWORD PTR _cod$[ebp]
	inc	DWORD PTR [esi]
	push	ebx
	push	OFFSET ??_C@_0M@HKNEBDCB@Creslengths?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	edi, DWORD PTR _max_specs$1$[ebp]
	mov	edx, 8
	test	al, al
	jne	$LL4@init
$LN3@init:

; 2943 :     }
; 2944 :   return (num_specs > 0);

	xor	eax, eax
	cmp	DWORD PTR [esi], eax
	pop	ebx
	pop	edi
	setg	al
	pop	esi

; 2945 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?init@kd_reslength_checker@@QAE_NPAVcod_params@@@Z ENDP	; kd_reslength_checker::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_reslength_checker@@QAE@XZ
_TEXT	SEGMENT
??1kd_reslength_checker@@QAE@XZ PROC			; kd_reslength_checker::~kd_reslength_checker, COMDAT
; _this$ = ecx

; 1631 :     ~kd_reslength_checker() { if (specs != NULL) delete[] specs; }

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN2@kd_resleng
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN2@kd_resleng:
	ret	0
??1kd_reslength_checker@@QAE@XZ ENDP			; kd_reslength_checker::~kd_reslength_checker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_reslength_checker@@QAE@XZ
_TEXT	SEGMENT
??0kd_reslength_checker@@QAE@XZ PROC			; kd_reslength_checker::kd_reslength_checker, COMDAT
; _this$ = ecx

; 1630 :     kd_reslength_checker() { memset(this,0,sizeof(*this)); }

	push	esi
	push	808					; 00000328H
	mov	esi, ecx
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi
	ret	0
??0kd_reslength_checker@@QAE@XZ ENDP			; kd_reslength_checker::kd_reslength_checker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?next_in_cprl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z
_TEXT	SEGMENT
_ref$1$ = -8						; size = 4
_tc$1$ = -4						; size = 4
_p_res$ = 8						; size = 4
_p_idx$ = 12						; size = 4
?next_in_cprl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z PROC ; kd_packet_sequencer::next_in_cprl, COMDAT
; _this$ = ecx

; 2843 : {

	push	ebp
	mov	ebp, esp
	mov	eax, ecx
	sub	esp, 8

; 2844 :   if (state.layer_lim <= 0)

	cmp	DWORD PTR [eax+36], 0
	jg	SHORT $LN33@next_in_cp

; 2845 :     return NULL;

	xor	eax, eax

; 2910 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN33@next_in_cp:

; 2846 :   while (state.comp_idx < state.comp_lim)

	mov	ecx, DWORD PTR [eax+52]
	push	ebx
	push	esi
	push	edi
	cmp	ecx, DWORD PTR [eax+44]
	jge	$LN50@next_in_cp
	npad	11
$LL2@next_in_cp:

; 2847 :     {
; 2848 :       kd_tile_comp *tc = tile->comps + state.comp_idx;

	imul	edi, DWORD PTR [eax+52], 188
	mov	ecx, DWORD PTR [eax]
	add	edi, DWORD PTR [ecx+208]

; 2849 : 
; 2850 :       for (; state.grid_loc.y < grid_lim.y;

	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _tc$1$[ebp], edi
	cmp	ecx, DWORD PTR [eax+12]
	jge	$LN5@next_in_cp
	npad	2
$LL6@next_in_cp:

; 2852 :            state.grid_loc.x = state.grid_min.x)
; 2853 :         for (; state.grid_loc.x < grid_lim.x;

	mov	ecx, DWORD PTR [eax+88]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN4@next_in_cp
	npad	4
$LL9@next_in_cp:

; 2855 :           for (; state.res_idx < state.res_lim; state.res_idx++)

	mov	ecx, DWORD PTR [eax+56]
	cmp	ecx, DWORD PTR [eax+40]
	jge	$LN7@next_in_cp
	npad	4
$LL12@next_in_cp:

; 2856 :             {
; 2857 :               if (state.res_idx > tc->dwt_levels)

	mov	ecx, DWORD PTR [eax+56]
	cmp	ecx, DWORD PTR [edi+56]
	jg	$LN7@next_in_cp

; 2858 :                 break; // Advance to next position.
; 2859 :               kd_resolution *res = tc->resolutions + state.res_idx;

	imul	esi, ecx, 604
	add	esi, DWORD PTR [edi+144]

; 2860 :               state.pos = res->current_sequencer_pos;

	mov	ecx, DWORD PTR [esi+588]
	mov	DWORD PTR [eax+60], ecx
	mov	ecx, DWORD PTR [esi+592]

; 2861 :               if ((state.pos.x >= res->precinct_indices.size.x) ||

	mov	ebx, ecx
	mov	DWORD PTR [eax+64], ecx
	mov	ecx, DWORD PTR [esi+148]
	cmp	ebx, ecx
	jge	$LN10@next_in_cp
	mov	edi, DWORD PTR [eax+60]
	cmp	edi, DWORD PTR [esi+144]
	jge	$LN51@next_in_cp

; 2865 :                 state.pos.x + state.pos.y*res->precinct_indices.size.x;

	imul	edi, ecx
	mov	ecx, DWORD PTR [esi+180]
	add	edi, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4661 :   register kdu_long state_val = state;

	mov	edx, DWORD PTR [ecx+edi*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2865 :                 state.pos.x + state.pos.y*res->precinct_indices.size.x;

	lea	ecx, DWORD PTR [ecx+edi*8]
	mov	DWORD PTR _ref$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4662 :   return ((state_val != 0) &&

	mov	ecx, edx
	mov	edi, DWORD PTR _ref$1$[ebp]
	or	ecx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [eax+60]
	je	SHORT $LN27@next_in_cp
	mov	ecx, edx
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN18@next_in_cp
	test	BYTE PTR [edx+8], 4
	jne	SHORT $LN18@next_in_cp
$LN27@next_in_cp:

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	and	edx, 1
	or	edx, 0
	jne	$LN17@next_in_cp
	mov	ecx, DWORD PTR _ref$1$[ebp]
	mov	ecx, DWORD PTR [ecx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2867 :               if (ref->is_desequenced() ||

	test	ecx, ecx
	je	$LN17@next_in_cp
	mov	ecx, DWORD PTR [ecx+16]
	cmp	ecx, DWORD PTR [eax+36]
	jl	$LN17@next_in_cp
$LN18@next_in_cp:

; 2868 :                   (((precinct=ref->deref()) != NULL) &&
; 2869 :                    (precinct->next_layer_idx >= state.layer_lim)))
; 2870 :                 { // Cannot sequence this one any further.
; 2871 :                   state.pos.x++;

	lea	ecx, DWORD PTR [ebx+1]
	mov	DWORD PTR [eax+64], ecx

; 2872 :                   if (state.pos.x >= res->precinct_indices.size.x)

	cmp	ecx, DWORD PTR [esi+148]
	jl	SHORT $LN19@next_in_cp

; 2873 :                     { state.pos.x = 0; state.pos.y++; }

	lea	ecx, DWORD PTR [edi+1]
	mov	DWORD PTR [eax+64], 0
	mov	DWORD PTR [eax+60], ecx
$LN19@next_in_cp:

; 2874 :                   res->current_sequencer_pos = state.pos;

	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [esi+588], ecx
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [esi+592], ecx
$LN51@next_in_cp:
	mov	edi, DWORD PTR _tc$1$[ebp]
$LN10@next_in_cp:

; 2855 :           for (; state.res_idx < state.res_lim; state.res_idx++)

	inc	DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [eax+56]
	cmp	ecx, DWORD PTR [eax+40]
	jl	$LL12@next_in_cp
$LN7@next_in_cp:

; 2854 :              state.grid_loc.x += state.grid_inc.x, state.res_idx=state.res_min)

	mov	ecx, DWORD PTR [eax+80]
	add	DWORD PTR [eax+88], ecx
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [eax+88]
	mov	DWORD PTR [eax+56], ecx
	cmp	edx, DWORD PTR [eax+16]
	jl	$LL9@next_in_cp
$LN4@next_in_cp:

; 2851 :            state.grid_loc.y += state.grid_inc.y,

	mov	ecx, DWORD PTR [eax+76]
	add	DWORD PTR [eax+84], ecx
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [eax+84]
	mov	DWORD PTR [eax+88], ecx
	cmp	edx, DWORD PTR [eax+12]
	jl	$LL6@next_in_cp
$LN5@next_in_cp:

; 2896 :             }
; 2897 : 
; 2898 :       // Advance component index.
; 2899 : 
; 2900 :       state.comp_idx++;

	inc	DWORD PTR [eax+52]
	mov	esi, DWORD PTR [eax+52]

; 2901 :       if (state.comp_idx < state.comp_lim)

	mov	edi, DWORD PTR [eax+44]
	cmp	esi, edi
	jge	SHORT $LN50@next_in_cp

; 2902 :         { // Install spatial progression parameters for new tile-component.
; 2903 :           tc = tile->comps + state.comp_idx;

	mov	ecx, DWORD PTR [eax]
	imul	edx, esi, 188
	add	edx, DWORD PTR [ecx+208]

; 2904 :           state.grid_min = tc->grid_min;

	mov	ecx, DWORD PTR [edx+156]
	mov	DWORD PTR [eax+68], ecx
	mov	ecx, DWORD PTR [edx+160]
	mov	DWORD PTR [eax+72], ecx

; 2905 :           state.grid_inc = tc->grid_inc;

	mov	ecx, DWORD PTR [edx+164]
	mov	DWORD PTR [eax+76], ecx
	mov	ecx, DWORD PTR [edx+168]
	mov	DWORD PTR [eax+80], ecx

; 2906 :           state.grid_loc = state.grid_min;

	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [eax+84], ecx
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR [eax+88], ecx
	cmp	esi, edi
	jl	$LL2@next_in_cp
$LN50@next_in_cp:
	pop	edi
	pop	esi

; 2907 :         }
; 2908 :     }
; 2909 :   return NULL;

	xor	eax, eax
	pop	ebx

; 2910 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN17@next_in_cp:

; 2875 :                   continue; // Move sequencing loops ahead.
; 2876 :                 }
; 2877 : 
; 2878 :               int gpos;
; 2879 :               gpos = res->precinct_indices.pos.y + state.pos.y;

	mov	edx, DWORD PTR [esi+136]

; 2880 :               gpos *= res->precinct_partition.size.y;
; 2881 :               gpos <<= res->vert_depth;

	mov	cl, BYTE PTR [esi+15]
	add	edx, edi
	imul	edx, DWORD PTR [esi+128]

; 2882 :               gpos *= tc->sub_sampling.y;

	mov	edi, DWORD PTR _tc$1$[ebp]

; 2883 :               gpos += tile->coding_origin.y;

	mov	ebx, DWORD PTR [eax]
	shl	edx, cl
	imul	edx, DWORD PTR [edi+16]
	add	edx, DWORD PTR [ebx+192]

; 2884 :               if ((gpos >= state.grid_min.y) && (gpos != state.grid_loc.y))

	cmp	edx, DWORD PTR [eax+68]
	jl	SHORT $LN20@next_in_cp
	cmp	edx, DWORD PTR [eax+84]
	jne	$LN10@next_in_cp
$LN20@next_in_cp:

; 2885 :                 continue;
; 2886 :               gpos = res->precinct_indices.pos.x + state.pos.x;

	mov	edx, DWORD PTR [esi+140]
	add	edx, DWORD PTR [eax+64]

; 2887 :               gpos *= res->precinct_partition.size.x;

	imul	edx, DWORD PTR [esi+132]

; 2888 :               gpos <<= res->hor_depth;

	mov	cl, BYTE PTR [esi+14]
	shl	edx, cl

; 2889 :               gpos *= tc->sub_sampling.x;

	imul	edx, DWORD PTR [edi+20]

; 2890 :               gpos += tile->coding_origin.x;

	add	edx, DWORD PTR [ebx+196]

; 2891 :               if ((gpos >= state.grid_min.x) && (gpos != state.grid_loc.x))

	cmp	edx, DWORD PTR [eax+72]
	jl	SHORT $LN21@next_in_cp
	cmp	edx, DWORD PTR [eax+88]
	jne	$LN10@next_in_cp
$LN21@next_in_cp:

; 2892 :                 continue;
; 2893 : 
; 2894 :               p_res = res; p_idx = state.pos;

	mov	ecx, DWORD PTR _p_res$[ebp]
	mov	edx, DWORD PTR _p_idx$[ebp]
	pop	edi
	mov	DWORD PTR [ecx], esi
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+64]

; 2895 :               return ref;

	mov	eax, DWORD PTR _ref$1$[ebp]
	pop	esi
	mov	DWORD PTR [edx+4], ecx
	pop	ebx

; 2910 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?next_in_cprl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ENDP ; kd_packet_sequencer::next_in_cprl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?next_in_pcrl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z
_TEXT	SEGMENT
_ref$1$ = -4						; size = 4
_p_res$ = 8						; size = 4
_p_idx$ = 12						; size = 4
?next_in_pcrl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z PROC ; kd_packet_sequencer::next_in_pcrl, COMDAT
; _this$ = ecx

; 2781 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	eax, ecx

; 2782 :   if (state.layer_lim <= 0)

	cmp	DWORD PTR [eax+36], 0
	jg	SHORT $LN14@next_in_pc

; 2783 :     return NULL;

	xor	eax, eax

; 2835 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN14@next_in_pc:

; 2784 : 
; 2785 :   for (; state.grid_loc.y < grid_lim.y;

	mov	ecx, DWORD PTR [eax+84]
	push	ebx
	push	esi
	push	edi
	cmp	ecx, DWORD PTR [eax+12]
	jge	$LN51@next_in_pc
$LL4@next_in_pc:

; 2787 :     for (; state.grid_loc.x < grid_lim.x;

	mov	ecx, DWORD PTR [eax+88]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN2@next_in_pc
	npad	1
$LL7@next_in_pc:

; 2789 :       for (; state.comp_idx < state.comp_lim;

	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, DWORD PTR [eax+44]
	jge	$LN5@next_in_pc
	npad	4
$LL10@next_in_pc:

; 2791 :         for (; state.res_idx < state.res_lim; state.res_idx++)

	mov	ecx, DWORD PTR [eax+56]
	cmp	ecx, DWORD PTR [eax+40]
	jge	$LN8@next_in_pc
	npad	4
$LL13@next_in_pc:

; 2792 :           {
; 2793 :             kd_tile_comp *tc = tile->comps + state.comp_idx;

	imul	edi, DWORD PTR [eax+52], 188
	mov	ecx, DWORD PTR [eax]
	add	edi, DWORD PTR [ecx+208]

; 2794 :             if (state.res_idx > tc->dwt_levels)

	mov	ecx, DWORD PTR [eax+56]
	cmp	ecx, DWORD PTR [edi+56]
	jg	$LN8@next_in_pc

; 2795 :               break; // Advance to next component.
; 2796 :             kd_resolution *res = tc->resolutions + state.res_idx;

	imul	esi, ecx, 604
	add	esi, DWORD PTR [edi+144]

; 2797 :             state.pos = res->current_sequencer_pos;

	mov	ecx, DWORD PTR [esi+588]
	mov	DWORD PTR [eax+60], ecx
	mov	ecx, DWORD PTR [esi+592]
	mov	DWORD PTR [eax+64], ecx

; 2798 :             if ((state.pos.x >= res->precinct_indices.size.x) ||

	cmp	ecx, DWORD PTR [esi+148]
	jge	$LN11@next_in_pc
	mov	ebx, DWORD PTR [eax+60]
	cmp	ebx, DWORD PTR [esi+144]
	jge	$LN11@next_in_pc

; 2802 :               state.pos.x + state.pos.y*res->precinct_indices.size.x;

	imul	ebx, DWORD PTR [esi+148]
	add	ebx, ecx
	mov	ecx, DWORD PTR [esi+180]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4661 :   register kdu_long state_val = state;

	mov	edx, DWORD PTR [ecx+ebx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2802 :               state.pos.x + state.pos.y*res->precinct_indices.size.x;

	lea	ecx, DWORD PTR [ecx+ebx*8]
	mov	DWORD PTR _ref$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4662 :   return ((state_val != 0) &&

	mov	ecx, edx
	mov	ebx, DWORD PTR _ref$1$[ebp]
	or	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [eax+60]
	je	SHORT $LN27@next_in_pc
	mov	ecx, edx
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN19@next_in_pc
	test	BYTE PTR [edx+8], 4
	jne	SHORT $LN19@next_in_pc
$LN27@next_in_pc:

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	and	edx, 1
	or	edx, 0
	jne	SHORT $LN18@next_in_pc
	mov	ecx, DWORD PTR _ref$1$[ebp]
	mov	ecx, DWORD PTR [ecx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2804 :             if (ref->is_desequenced() ||

	test	ecx, ecx
	je	SHORT $LN18@next_in_pc
	mov	ecx, DWORD PTR [ecx+16]
	cmp	ecx, DWORD PTR [eax+36]
	jl	SHORT $LN18@next_in_pc
$LN19@next_in_pc:

; 2805 :                 (((precinct=ref->deref()) != NULL) &&
; 2806 :                  (precinct->next_layer_idx >= state.layer_lim)))
; 2807 :               { // Cannot sequence this one any further.
; 2808 :                 state.pos.x++;

	mov	ecx, DWORD PTR [eax+64]
	inc	ecx
	mov	DWORD PTR [eax+64], ecx

; 2809 :                 if (state.pos.x >= res->precinct_indices.size.x)

	cmp	ecx, DWORD PTR [esi+148]
	jl	SHORT $LN20@next_in_pc

; 2810 :                   { state.pos.x = 0; state.pos.y++; }

	lea	ecx, DWORD PTR [ebx+1]
	mov	DWORD PTR [eax+64], 0
	mov	DWORD PTR [eax+60], ecx
$LN20@next_in_pc:

; 2811 :                 res->current_sequencer_pos = state.pos;

	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [esi+588], ecx
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [esi+592], ecx
	jmp	SHORT $LN11@next_in_pc
$LN18@next_in_pc:

; 2812 :                 continue; // Move sequencing loops ahead.
; 2813 :               }
; 2814 : 
; 2815 :             int gpos;
; 2816 :             gpos = res->precinct_indices.pos.y + state.pos.y;

	mov	edx, DWORD PTR [esi+136]

; 2817 :             gpos *= res->precinct_partition.size.y;
; 2818 :             gpos <<= res->vert_depth;

	mov	cl, BYTE PTR [esi+15]
	add	edx, ebx
	imul	edx, DWORD PTR [esi+128]

; 2819 :             gpos *= tc->sub_sampling.y;
; 2820 :             gpos += tile->coding_origin.y;

	mov	ebx, DWORD PTR [eax]
	shl	edx, cl
	imul	edx, DWORD PTR [edi+16]
	add	edx, DWORD PTR [ebx+192]

; 2821 :             if ((gpos >= state.grid_min.y) && (gpos != state.grid_loc.y))

	cmp	edx, DWORD PTR [eax+68]
	jl	SHORT $LN21@next_in_pc
	cmp	edx, DWORD PTR [eax+84]
	jne	SHORT $LN11@next_in_pc
$LN21@next_in_pc:

; 2822 :               continue;
; 2823 :             gpos = res->precinct_indices.pos.x + state.pos.x;

	mov	edx, DWORD PTR [esi+140]
	add	edx, DWORD PTR [eax+64]

; 2824 :             gpos *= res->precinct_partition.size.x;

	imul	edx, DWORD PTR [esi+132]

; 2825 :             gpos <<= res->hor_depth;

	mov	cl, BYTE PTR [esi+14]
	shl	edx, cl

; 2826 :             gpos *= tc->sub_sampling.x;

	imul	edx, DWORD PTR [edi+20]

; 2827 :             gpos += tile->coding_origin.x;

	add	edx, DWORD PTR [ebx+196]

; 2828 :             if ((gpos >= state.grid_min.x) && (gpos != state.grid_loc.x))

	cmp	edx, DWORD PTR [eax+72]
	jl	SHORT $LN22@next_in_pc
	cmp	edx, DWORD PTR [eax+88]
	je	SHORT $LN22@next_in_pc
$LN11@next_in_pc:

; 2791 :         for (; state.res_idx < state.res_lim; state.res_idx++)

	inc	DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [eax+56]
	cmp	ecx, DWORD PTR [eax+40]
	jl	$LL13@next_in_pc
$LN8@next_in_pc:

; 2790 :            state.comp_idx++, state.res_idx=state.res_min)

	inc	DWORD PTR [eax+52]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [eax+52]
	mov	DWORD PTR [eax+56], ecx
	cmp	edx, DWORD PTR [eax+44]
	jl	$LL10@next_in_pc
$LN5@next_in_pc:

; 2788 :          state.grid_loc.x+=state.grid_inc.x, state.comp_idx=state.comp_min)

	mov	ecx, DWORD PTR [eax+80]
	add	DWORD PTR [eax+88], ecx
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [eax+88]
	mov	DWORD PTR [eax+52], ecx
	cmp	edx, DWORD PTR [eax+16]
	jl	$LL7@next_in_pc
$LN2@next_in_pc:

; 2786 :        state.grid_loc.y+=state.grid_inc.y, state.grid_loc.x=state.grid_min.x)

	mov	ecx, DWORD PTR [eax+76]
	add	DWORD PTR [eax+84], ecx
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [eax+84]
	mov	DWORD PTR [eax+88], ecx
	cmp	edx, DWORD PTR [eax+12]
	jl	$LL4@next_in_pc
$LN51@next_in_pc:
	pop	edi
	pop	esi

; 2833 :           }
; 2834 :   return NULL;

	xor	eax, eax
	pop	ebx

; 2835 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN22@next_in_pc:

; 2829 :               continue;
; 2830 : 
; 2831 :             p_res = res; p_idx = state.pos;

	mov	ecx, DWORD PTR _p_res$[ebp]
	mov	edx, DWORD PTR _p_idx$[ebp]
	pop	edi
	mov	DWORD PTR [ecx], esi
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+64]

; 2832 :             return ref;

	mov	eax, DWORD PTR _ref$1$[ebp]
	pop	esi
	mov	DWORD PTR [edx+4], ecx
	pop	ebx

; 2835 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?next_in_pcrl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ENDP ; kd_packet_sequencer::next_in_pcrl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?next_in_rpcl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z
_TEXT	SEGMENT
_ref$1$ = -4						; size = 4
_p_res$ = 8						; size = 4
_p_idx$ = 12						; size = 4
?next_in_rpcl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z PROC ; kd_packet_sequencer::next_in_rpcl, COMDAT
; _this$ = ecx

; 2720 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	eax, ecx

; 2721 :   if (state.layer_lim <= 0)

	cmp	DWORD PTR [eax+36], 0
	jg	SHORT $LN14@next_in_rp

; 2722 :     return NULL;

	xor	eax, eax

; 2773 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN14@next_in_rp:

; 2723 :   for (; state.res_idx < state.res_lim;

	mov	ecx, DWORD PTR [eax+56]
	push	ebx
	push	esi
	push	edi
	cmp	ecx, DWORD PTR [eax+40]
	jge	$LN50@next_in_rp
$LL4@next_in_rp:

; 2725 :     for (; state.grid_loc.y < grid_lim.y;

	mov	ecx, DWORD PTR [eax+84]
	cmp	ecx, DWORD PTR [eax+12]
	jge	$LN2@next_in_rp
	npad	1
$LL7@next_in_rp:

; 2727 :       for (; state.grid_loc.x < grid_lim.x;

	mov	ecx, DWORD PTR [eax+88]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN5@next_in_rp
	npad	4
$LL10@next_in_rp:

; 2729 :         for (; state.comp_idx < state.comp_lim; state.comp_idx++)

	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, DWORD PTR [eax+44]
	jge	$LN8@next_in_rp
	npad	4
$LL13@next_in_rp:

; 2730 :           {
; 2731 :             kd_tile_comp *tc = tile->comps + state.comp_idx;

	imul	edi, DWORD PTR [eax+52], 188
	mov	ecx, DWORD PTR [eax]
	add	edi, DWORD PTR [ecx+208]

; 2732 :             if (state.res_idx > tc->dwt_levels)

	mov	ecx, DWORD PTR [eax+56]
	cmp	ecx, DWORD PTR [edi+56]
	jg	$LN11@next_in_rp

; 2733 :               continue; // Advance to next component.
; 2734 :             kd_resolution *res = tc->resolutions + state.res_idx;

	imul	esi, ecx, 604
	add	esi, DWORD PTR [edi+144]

; 2735 :             state.pos = res->current_sequencer_pos;

	mov	ecx, DWORD PTR [esi+588]
	mov	DWORD PTR [eax+60], ecx
	mov	ecx, DWORD PTR [esi+592]
	mov	DWORD PTR [eax+64], ecx

; 2736 :             if ((state.pos.x >= res->precinct_indices.size.x) ||

	cmp	ecx, DWORD PTR [esi+148]
	jge	$LN11@next_in_rp
	mov	ebx, DWORD PTR [eax+60]
	cmp	ebx, DWORD PTR [esi+144]
	jge	$LN11@next_in_rp

; 2740 :               state.pos.x + state.pos.y*res->precinct_indices.size.x;

	imul	ebx, DWORD PTR [esi+148]
	add	ebx, ecx
	mov	ecx, DWORD PTR [esi+180]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4661 :   register kdu_long state_val = state;

	mov	edx, DWORD PTR [ecx+ebx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2740 :               state.pos.x + state.pos.y*res->precinct_indices.size.x;

	lea	ecx, DWORD PTR [ecx+ebx*8]
	mov	DWORD PTR _ref$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4662 :   return ((state_val != 0) &&

	mov	ecx, edx
	mov	ebx, DWORD PTR _ref$1$[ebp]
	or	ecx, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [eax+60]
	je	SHORT $LN27@next_in_rp
	mov	ecx, edx
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN19@next_in_rp
	test	BYTE PTR [edx+8], 4
	jne	SHORT $LN19@next_in_rp
$LN27@next_in_rp:

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	and	edx, 1
	or	edx, 0
	jne	SHORT $LN18@next_in_rp
	mov	ecx, DWORD PTR _ref$1$[ebp]
	mov	ecx, DWORD PTR [ecx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2742 :             if (ref->is_desequenced() ||

	test	ecx, ecx
	je	SHORT $LN18@next_in_rp
	mov	ecx, DWORD PTR [ecx+16]
	cmp	ecx, DWORD PTR [eax+36]
	jl	SHORT $LN18@next_in_rp
$LN19@next_in_rp:

; 2743 :                 (((precinct=ref->deref()) != NULL) &&
; 2744 :                  (precinct->next_layer_idx >= state.layer_lim)))
; 2745 :               { // Cannnot sequence this one any further.
; 2746 :                 state.pos.x++;

	mov	ecx, DWORD PTR [eax+64]
	inc	ecx
	mov	DWORD PTR [eax+64], ecx

; 2747 :                 if (state.pos.x >= res->precinct_indices.size.x)

	cmp	ecx, DWORD PTR [esi+148]
	jl	SHORT $LN20@next_in_rp

; 2748 :                   { state.pos.x = 0; state.pos.y++; }

	lea	ecx, DWORD PTR [ebx+1]
	mov	DWORD PTR [eax+64], 0
	mov	DWORD PTR [eax+60], ecx
$LN20@next_in_rp:

; 2749 :                 res->current_sequencer_pos = state.pos;

	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [esi+588], ecx
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [esi+592], ecx
	jmp	SHORT $LN11@next_in_rp
$LN18@next_in_rp:

; 2750 :                 continue; // Move sequencing loops ahead.
; 2751 :               }
; 2752 : 
; 2753 :             int gpos;
; 2754 :             gpos = res->precinct_indices.pos.y + state.pos.y;

	mov	edx, DWORD PTR [esi+136]

; 2755 :             gpos *= res->precinct_partition.size.y;
; 2756 :             gpos <<= res->vert_depth;

	mov	cl, BYTE PTR [esi+15]
	add	edx, ebx
	imul	edx, DWORD PTR [esi+128]

; 2757 :             gpos *= tc->sub_sampling.y;
; 2758 :             gpos += tile->coding_origin.y;

	mov	ebx, DWORD PTR [eax]
	shl	edx, cl
	imul	edx, DWORD PTR [edi+16]
	add	edx, DWORD PTR [ebx+192]

; 2759 :             if ((gpos >= state.grid_min.y) && (gpos != state.grid_loc.y))

	cmp	edx, DWORD PTR [eax+68]
	jl	SHORT $LN21@next_in_rp
	cmp	edx, DWORD PTR [eax+84]
	jne	SHORT $LN11@next_in_rp
$LN21@next_in_rp:

; 2760 :               continue;
; 2761 :             gpos = res->precinct_indices.pos.x + state.pos.x;

	mov	edx, DWORD PTR [esi+140]
	add	edx, DWORD PTR [eax+64]

; 2762 :             gpos *= res->precinct_partition.size.x;

	imul	edx, DWORD PTR [esi+132]

; 2763 :             gpos <<= res->hor_depth;

	mov	cl, BYTE PTR [esi+14]
	shl	edx, cl

; 2764 :             gpos *= tc->sub_sampling.x;

	imul	edx, DWORD PTR [edi+20]

; 2765 :             gpos += tile->coding_origin.x;

	add	edx, DWORD PTR [ebx+196]

; 2766 :             if ((gpos >= state.grid_min.x) && (gpos != state.grid_loc.x))

	cmp	edx, DWORD PTR [eax+72]
	jl	SHORT $LN22@next_in_rp
	cmp	edx, DWORD PTR [eax+88]
	je	SHORT $LN22@next_in_rp
$LN11@next_in_rp:

; 2729 :         for (; state.comp_idx < state.comp_lim; state.comp_idx++)

	inc	DWORD PTR [eax+52]
	mov	ecx, DWORD PTR [eax+52]
	cmp	ecx, DWORD PTR [eax+44]
	jl	$LL13@next_in_rp
$LN8@next_in_rp:

; 2728 :            state.grid_loc.x+=state.grid_inc.x, state.comp_idx=state.comp_min)

	mov	ecx, DWORD PTR [eax+80]
	add	DWORD PTR [eax+88], ecx
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [eax+88]
	mov	DWORD PTR [eax+52], ecx
	cmp	edx, DWORD PTR [eax+16]
	jl	$LL10@next_in_rp
$LN5@next_in_rp:

; 2726 :          state.grid_loc.y+=state.grid_inc.y, state.grid_loc.x=state.grid_min.x)

	mov	ecx, DWORD PTR [eax+76]
	add	DWORD PTR [eax+84], ecx
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [eax+84]
	mov	DWORD PTR [eax+88], ecx
	cmp	edx, DWORD PTR [eax+12]
	jl	$LL7@next_in_rp
$LN2@next_in_rp:

; 2724 :        state.res_idx++, state.grid_loc.y=state.grid_min.y)

	inc	DWORD PTR [eax+56]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR [eax+56]
	mov	DWORD PTR [eax+84], ecx
	cmp	edx, DWORD PTR [eax+40]
	jl	$LL4@next_in_rp
$LN50@next_in_rp:
	pop	edi
	pop	esi

; 2771 :           }
; 2772 :   return NULL;

	xor	eax, eax
	pop	ebx

; 2773 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN22@next_in_rp:

; 2767 :               continue;
; 2768 : 
; 2769 :             p_res = res; p_idx = state.pos;

	mov	ecx, DWORD PTR _p_res$[ebp]
	mov	edx, DWORD PTR _p_idx$[ebp]
	pop	edi
	mov	DWORD PTR [ecx], esi
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+64]

; 2770 :             return ref;

	mov	eax, DWORD PTR _ref$1$[ebp]
	pop	esi
	mov	DWORD PTR [edx+4], ecx
	pop	ebx

; 2773 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?next_in_rpcl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ENDP ; kd_packet_sequencer::next_in_rpcl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?next_in_rlcp@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z
_TEXT	SEGMENT
_p_res$ = 8						; size = 4
_p_idx$ = 12						; size = 4
?next_in_rlcp@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z PROC ; kd_packet_sequencer::next_in_rlcp, COMDAT
; _this$ = ecx

; 2680 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 2681 :   for (; state.res_idx < state.res_lim;

	mov	eax, DWORD PTR [esi+40]
	cmp	DWORD PTR [esi+56], eax
	jge	$LN3@next_in_rl
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+40]
	npad	6
$LL4@next_in_rl:

; 2683 :     for (; state.layer_idx < state.layer_lim;

	cmp	DWORD PTR [esi+48], eax
	jge	$LN2@next_in_rl
	mov	eax, DWORD PTR [esi+44]
	npad	4
$LL7@next_in_rl:

; 2685 :       for (; state.comp_idx < state.comp_lim;

	cmp	DWORD PTR [esi+52], eax
	jge	$LN5@next_in_rl

; 2687 :         {
; 2688 :           kd_tile_comp *tc = tile->comps + state.comp_idx;

	mov	edx, DWORD PTR [esi]

; 2689 :           if (state.res_idx > tc->dwt_levels)

	mov	ecx, DWORD PTR [esi+56]
	npad	2
$LL10@next_in_rl:

; 2687 :         {
; 2688 :           kd_tile_comp *tc = tile->comps + state.comp_idx;

	imul	eax, DWORD PTR [esi+52], 188
	add	eax, DWORD PTR [edx+208]

; 2689 :           if (state.res_idx > tc->dwt_levels)

	cmp	ecx, DWORD PTR [eax+56]
	jg	$LN8@next_in_rl

; 2690 :             continue; // Advance to next component.
; 2691 :           kd_resolution *res = tc->resolutions + state.res_idx;

	imul	edi, ecx, 604
	add	edi, DWORD PTR [eax+144]

; 2692 :           for (; state.pos.y < res->precinct_indices.size.y;

	mov	eax, DWORD PTR [esi+60]
	cmp	eax, DWORD PTR [edi+144]
	jge	$LN8@next_in_rl
$LL13@next_in_rl:

; 2694 :             for (; state.pos.x < res->precinct_indices.size.x;

	mov	edx, DWORD PTR [edi+148]
	cmp	DWORD PTR [esi+64], edx
	jge	SHORT $LN11@next_in_rl
	npad	4
$LL16@next_in_rl:

; 2696 :               {
; 2697 :                 kd_precinct_ref *ref = res->precinct_refs +
; 2698 :                   state.pos.y*res->precinct_indices.size.x + state.pos.x;

	mov	ecx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [edi+180]
	imul	ecx, edx
	add	ecx, DWORD PTR [esi+64]
	lea	ebx, DWORD PTR [eax+ecx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4661 :   register kdu_long state_val = state;

	mov	eax, DWORD PTR [ebx]

; 4662 :   return ((state_val != 0) &&

	mov	ecx, eax
	or	ecx, DWORD PTR [ebx+4]
	je	SHORT $LN25@next_in_rl
	mov	ecx, eax
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN14@next_in_rl
	test	BYTE PTR [eax+8], 4
	jne	SHORT $LN14@next_in_rl
$LN25@next_in_rl:

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	and	eax, 1
	or	eax, 0
	jne	$LN20@next_in_rl
	mov	eax, DWORD PTR [ebx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2705 :                     if ((precinct == NULL) ||

	test	eax, eax
	je	$LN20@next_in_rl
	mov	eax, DWORD PTR [eax+16]
	cmp	eax, DWORD PTR [esi+48]
	je	$LN20@next_in_rl
$LN14@next_in_rl:

; 2695 :                  state.pos.x++)

	mov	eax, DWORD PTR [esi+64]
	inc	eax
	mov	DWORD PTR [esi+64], eax
	mov	edx, DWORD PTR [edi+148]
	cmp	eax, edx
	jl	SHORT $LL16@next_in_rl
$LN11@next_in_rl:

; 2693 :                state.pos.y++, state.pos.x=0)

	inc	DWORD PTR [esi+60]
	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [esi+64], 0
	cmp	eax, DWORD PTR [edi+144]
	jl	$LL13@next_in_rl
	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [esi]
$LN8@next_in_rl:

; 2686 :            state.comp_idx++, state.pos.y=0)

	mov	eax, DWORD PTR [esi+52]
	inc	eax
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+52], eax
	cmp	eax, DWORD PTR [esi+44]
	jl	$LL10@next_in_rl
$LN5@next_in_rl:

; 2684 :          state.layer_idx++, state.comp_idx=state.comp_min)

	mov	eax, DWORD PTR [esi+32]
	inc	DWORD PTR [esi+48]
	mov	DWORD PTR [esi+52], eax
	mov	eax, DWORD PTR [esi+36]
	cmp	DWORD PTR [esi+48], eax
	mov	eax, DWORD PTR [esi+44]
	jl	$LL7@next_in_rl
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+40]
$LN2@next_in_rl:

; 2682 :        state.res_idx++, state.layer_idx=0)

	inc	DWORD PTR [esi+56]
	mov	DWORD PTR [esi+48], 0
	cmp	DWORD PTR [esi+56], ecx
	jl	$LL4@next_in_rl
$LN3@next_in_rl:
	pop	edi
	pop	esi

; 2708 :                   }
; 2709 :               }
; 2710 :         }
; 2711 :   return NULL;

	xor	eax, eax
	pop	ebx

; 2712 : }

	pop	ebp
	ret	8
$LN20@next_in_rl:

; 2706 :                         (precinct->next_layer_idx == state.layer_idx))
; 2707 :                       { p_res = res; p_idx = state.pos; return ref; }

	mov	ecx, DWORD PTR _p_res$[ebp]
	mov	eax, ebx
	mov	edx, DWORD PTR _p_idx$[ebp]
	mov	DWORD PTR [ecx], edi
	mov	ecx, DWORD PTR [esi+60]
	pop	edi
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [esi+64]
	pop	esi
	mov	DWORD PTR [edx+4], ecx
	pop	ebx

; 2712 : }

	pop	ebp
	ret	8
?next_in_rlcp@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ENDP ; kd_packet_sequencer::next_in_rlcp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?next_in_lrcp@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z
_TEXT	SEGMENT
_p_res$ = 8						; size = 4
_p_idx$ = 12						; size = 4
?next_in_lrcp@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z PROC ; kd_packet_sequencer::next_in_lrcp, COMDAT
; _this$ = ecx

; 2640 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
$LN55@next_in_lr:

; 2641 :   for (; state.layer_idx < state.layer_lim;

	mov	eax, DWORD PTR [esi+36]
	cmp	DWORD PTR [esi+48], eax
	jge	$LN3@next_in_lr

; 2643 :     for (; state.res_idx < state.res_lim;

	mov	eax, DWORD PTR [esi+40]
	cmp	DWORD PTR [esi+56], eax
	jge	$LN2@next_in_lr
	mov	eax, DWORD PTR [esi+44]
$LL7@next_in_lr:

; 2645 :       for (; state.comp_idx < state.comp_lim;

	cmp	DWORD PTR [esi+52], eax
	jge	$LN5@next_in_lr

; 2647 :         {
; 2648 :           kd_tile_comp *tc = tile->comps + state.comp_idx;

	mov	edx, DWORD PTR [esi]

; 2649 :           if (state.res_idx > tc->dwt_levels)

	mov	ecx, DWORD PTR [esi+56]
	npad	15
$LL10@next_in_lr:

; 2647 :         {
; 2648 :           kd_tile_comp *tc = tile->comps + state.comp_idx;

	imul	eax, DWORD PTR [esi+52], 188
	add	eax, DWORD PTR [edx+208]

; 2649 :           if (state.res_idx > tc->dwt_levels)

	cmp	ecx, DWORD PTR [eax+56]
	jg	$LN8@next_in_lr

; 2650 :             continue; // Advance to next component.
; 2651 :           kd_resolution *res = tc->resolutions + state.res_idx;

	imul	edi, ecx, 604
	add	edi, DWORD PTR [eax+144]

; 2652 :           for (; state.pos.y < res->precinct_indices.size.y;

	mov	eax, DWORD PTR [esi+60]
	cmp	eax, DWORD PTR [edi+144]
	jge	SHORT $LN8@next_in_lr
	npad	3
$LL13@next_in_lr:

; 2654 :             for (; state.pos.x < res->precinct_indices.size.x;

	mov	edx, DWORD PTR [edi+148]
	cmp	DWORD PTR [esi+64], edx
	jge	SHORT $LN11@next_in_lr
	npad	5
$LL16@next_in_lr:

; 2656 :               {
; 2657 :                 kd_precinct_ref *ref = res->precinct_refs +
; 2658 :                   state.pos.y*res->precinct_indices.size.x + state.pos.x;

	mov	ecx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [edi+180]
	imul	ecx, edx
	add	ecx, DWORD PTR [esi+64]
	lea	ebx, DWORD PTR [eax+ecx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4661 :   register kdu_long state_val = state;

	mov	eax, DWORD PTR [ebx]

; 4662 :   return ((state_val != 0) &&

	mov	ecx, eax
	or	ecx, DWORD PTR [ebx+4]
	je	SHORT $LN25@next_in_lr
	mov	ecx, eax
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN14@next_in_lr
	test	BYTE PTR [eax+8], 4
	jne	SHORT $LN14@next_in_lr
$LN25@next_in_lr:

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	and	eax, 1
	or	eax, 0
	jne	SHORT $LN20@next_in_lr
	mov	eax, DWORD PTR [ebx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2665 :                     if ((precinct == NULL) ||

	test	eax, eax
	je	SHORT $LN20@next_in_lr
	mov	eax, DWORD PTR [eax+16]
	cmp	eax, DWORD PTR [esi+48]
	je	SHORT $LN20@next_in_lr
$LN14@next_in_lr:

; 2655 :                  state.pos.x++)

	mov	eax, DWORD PTR [esi+64]
	inc	eax
	mov	DWORD PTR [esi+64], eax
	mov	edx, DWORD PTR [edi+148]
	cmp	eax, edx
	jl	SHORT $LL16@next_in_lr
$LN11@next_in_lr:

; 2653 :                state.pos.y++, state.pos.x=0)

	inc	DWORD PTR [esi+60]
	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [esi+64], 0
	cmp	eax, DWORD PTR [edi+144]
	jl	SHORT $LL13@next_in_lr
	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [esi]
$LN8@next_in_lr:

; 2646 :            state.comp_idx++, state.pos.y=0)

	mov	eax, DWORD PTR [esi+52]
	inc	eax
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+52], eax
	cmp	eax, DWORD PTR [esi+44]
	jl	$LL10@next_in_lr
$LN5@next_in_lr:

; 2644 :          state.res_idx++, state.comp_idx=state.comp_min)

	mov	eax, DWORD PTR [esi+32]
	inc	DWORD PTR [esi+56]
	mov	DWORD PTR [esi+52], eax
	mov	eax, DWORD PTR [esi+40]
	cmp	DWORD PTR [esi+56], eax
	mov	eax, DWORD PTR [esi+44]
	jl	$LL7@next_in_lr
$LN2@next_in_lr:

; 2642 :        state.layer_idx++, state.res_idx=state.res_min)

	mov	eax, DWORD PTR [esi+28]
	inc	DWORD PTR [esi+48]
	mov	DWORD PTR [esi+56], eax
	jmp	$LN55@next_in_lr
$LN20@next_in_lr:

; 2666 :                         (precinct->next_layer_idx == state.layer_idx))
; 2667 :                       { p_res = res; p_idx = state.pos; return ref; }

	mov	ecx, DWORD PTR _p_res$[ebp]
	mov	eax, ebx
	mov	edx, DWORD PTR _p_idx$[ebp]
	mov	DWORD PTR [ecx], edi
	mov	ecx, DWORD PTR [esi+60]
	pop	edi
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [esi+64]
	pop	esi
	mov	DWORD PTR [edx+4], ecx
	pop	ebx

; 2672 : }

	pop	ebp
	ret	8
$LN3@next_in_lr:
	pop	edi
	pop	esi

; 2668 :                   }
; 2669 :               }
; 2670 :         }
; 2671 :   return NULL;

	xor	eax, eax
	pop	ebx

; 2672 : }

	pop	ebp
	ret	8
?next_in_lrcp@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ENDP ; kd_packet_sequencer::next_in_lrcp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?next_progression@kd_packet_sequencer@@AAE_NXZ
_TEXT	SEGMENT
_e$2 = -140						; size = 20
_w$3 = -120						; size = 20
_e$4 = -120						; size = 20
tv883 = -100						; size = 4
tv864 = -100						; size = 4
_tmp_poc$1$ = -100					; size = 4
_text$5 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?next_progression@kd_packet_sequencer@@AAE_NXZ PROC	; kd_packet_sequencer::next_progression, COMDAT
; _this$ = ecx

; 2464 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?next_progression@kd_packet_sequencer@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 2465 :   if (state.poc == NULL) // Must be initial call.

	cmp	DWORD PTR [esi+92], 0
	jne	SHORT $LN12@next_progr

; 2466 :     {
; 2467 :       state.poc = tile->codestream->siz->access_cluster(POC_params);

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_03LFCEPJHK@POC?$AA@
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+12]
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 2468 :       assert(state.poc != NULL);
; 2469 :       state.poc = state.poc->access_relation(tile->t_num,-1,0,true);

	mov	ecx, DWORD PTR [esi]
	push	1
	push	0
	push	-1
	mov	DWORD PTR [esi+92], eax
	push	DWORD PTR [ecx+4]
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 2470 :       assert(state.poc != NULL);
; 2471 :       if (!state.poc->get(Porder,0,0,state.res_min))

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+92], eax
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN12@next_progr

; 2472 :         state.poc = NULL;

	mov	DWORD PTR [esi+92], 0
$LN12@next_progr:

; 2473 :     }
; 2474 :   if (state.poc == NULL)

	mov	ecx, DWORD PTR [esi+92]
	test	ecx, ecx
	jne	SHORT $LN13@next_progr

; 2475 :     { // Get information from COD marker segment
; 2476 :       kdu_params *cod =
; 2477 :         tile->codestream->siz->access_cluster(COD_params);

	mov	eax, DWORD PTR [esi]
	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+12]
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 2478 :       cod = cod->access_relation(tile->t_num,-1,0,true);

	mov	ecx, DWORD PTR [esi]
	push	1
	push	0
	push	-1
	push	DWORD PTR [ecx+4]
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 2479 :       if (!cod->get(Corder,0,0,state.order))

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR [esi+24]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_06IKJBDDKO@Corder?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 2480 :         assert(0);
; 2481 :       state.comp_min = state.res_min = 0;
; 2482 :       state.layer_lim = tile->num_layers;

	mov	ecx, DWORD PTR [esi]
	lea	ebx, DWORD PTR [esi+28]
	mov	DWORD PTR [ebx], 0
	lea	edi, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+32], 0

; 2483 :       state.comp_lim = tile->num_components;

	lea	edx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [ecx+132]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [ecx+128]
	mov	DWORD PTR [edx], eax

; 2484 :       state.res_lim = max_dwt_levels+1;

	mov	eax, DWORD PTR [esi+4]
	inc	eax
	mov	DWORD PTR [esi+40], eax

; 2485 :     }
; 2486 :   else

	jmp	$LN14@next_progr
$LN13@next_progr:

; 2487 :     { // Get information from POC marker segment
; 2488 :       if (!state.poc->get(Porder,state.next_poc_record,0,state.res_min))

	push	1
	push	1
	push	1
	lea	ebx, DWORD PTR [esi+28]
	push	ebx
	push	0
	push	DWORD PTR [esi+96]
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN16@next_progr
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 725  :     int get_instance() { return inst_idx; }

	mov	ecx, DWORD PTR [esi+92]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2493 :             state.poc->access_relation(tile->t_num,-1,inst_idx,true);

	mov	eax, DWORD PTR [esi]
	push	1
	mov	edi, DWORD PTR [ecx+16]
	inc	edi
	push	edi
	push	-1
	push	DWORD PTR [eax+4]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation
	mov	DWORD PTR _tmp_poc$1$[ebp], eax

; 2494 :           if ((tmp_poc == NULL) ||

	test	eax, eax
	je	$LN18@next_progr
	push	1
	push	1
	push	1
	push	ebx
	push	0
	push	0
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN18@next_progr

; 2504 :             }
; 2505 :           if (inst_idx >= tile->next_tpart)

	mov	eax, DWORD PTR [esi]
	cmp	edi, DWORD PTR [eax+244]
	jge	$LN19@next_progr

; 2506 :             return false; // Need to generate a new tile-part first.
; 2507 :           state.poc = tmp_poc;

	mov	eax, DWORD PTR _tmp_poc$1$[ebp]
	mov	DWORD PTR [esi+92], eax

; 2508 :           state.next_poc_record = 0;

	mov	DWORD PTR [esi+96], 0
$LN16@next_progr:

; 2509 :         }
; 2510 :       state.poc->get(Porder,state.next_poc_record,1,state.comp_min);

	mov	ecx, DWORD PTR [esi+92]
	lea	eax, DWORD PTR [esi+32]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	DWORD PTR [esi+96]
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 2511 :       state.poc->get(Porder,state.next_poc_record,2,state.layer_lim);

	mov	ecx, DWORD PTR [esi+92]
	lea	edi, DWORD PTR [esi+36]
	push	1
	push	1
	push	1
	push	edi
	push	2
	push	DWORD PTR [esi+96]
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 2512 :       state.poc->get(Porder,state.next_poc_record,3,state.res_lim);

	mov	ecx, DWORD PTR [esi+92]
	lea	eax, DWORD PTR [esi+40]
	push	1
	push	1
	push	1
	push	eax
	push	3
	push	DWORD PTR [esi+96]
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 2513 :       state.poc->get(Porder,state.next_poc_record,4,state.comp_lim);

	mov	ecx, DWORD PTR [esi+92]
	lea	eax, DWORD PTR [esi+44]
	push	1
	push	1
	push	1
	push	eax
	push	4
	push	DWORD PTR [esi+96]
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 2514 :       state.poc->get(Porder,state.next_poc_record,5,state.order);

	mov	ecx, DWORD PTR [esi+92]
	lea	eax, DWORD PTR [esi+24]
	push	1
	push	1
	push	1
	push	eax
	push	5
	push	DWORD PTR [esi+96]
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 2516 :           (state.next_poc_record == 0) && (state.poc->get_instance() == 0) &&

	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN22@next_progr
	cmp	DWORD PTR [ebx], 0
	je	SHORT $LN21@next_progr
$LN22@next_progr:
	cmp	DWORD PTR [esi+96], 0
	jne	SHORT $LN21@next_progr
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 725  :     int get_instance() { return inst_idx; }

	mov	eax, DWORD PTR [esi+92]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2516 :           (state.next_poc_record == 0) && (state.poc->get_instance() == 0) &&

	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN21@next_progr
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+104], 0
	jne	SHORT $LN21@next_progr

; 2518 :         { KDU_WARNING(w,8); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$3[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$3[ebp]
	lea	ecx, DWORD PTR _w$3[ebp]
	push	OFFSET ??_C@_0BCG@LKLOKBKN@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2518 :         { KDU_WARNING(w,8); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2524 :           tile->codestream->profile = 2;

	mov	eax, DWORD PTR [esi]

; 2525 :         }

	lea	ecx, DWORD PTR _w$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+104], 2
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN21@next_progr:

; 2526 :       state.next_poc_record++;

	inc	DWORD PTR [esi+96]
	lea	edx, DWORD PTR [esi+44]
$LN14@next_progr:

; 2527 :     }
; 2528 :   if (state.layer_lim > tile->num_layers)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+132]
	cmp	DWORD PTR [edi], eax
	jle	SHORT $LN23@next_progr

; 2529 :     state.layer_lim = tile->num_layers;

	mov	DWORD PTR [edi], eax
$LN23@next_progr:

; 2530 :   if (state.comp_lim > tile->num_components)

	mov	eax, DWORD PTR [ecx+128]
	lea	edi, DWORD PTR [ecx+128]
	cmp	DWORD PTR [edx], eax
	jle	SHORT $LN24@next_progr

; 2531 :     state.comp_lim = tile->num_components;

	mov	DWORD PTR [edx], eax
$LN24@next_progr:

; 2532 :   if (state.res_lim > max_dwt_levels)

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [esi+40], eax
	jle	SHORT $LN25@next_progr

; 2533 :     state.res_lim = max_dwt_levels+1;

	inc	eax
	mov	DWORD PTR [esi+40], eax
$LN25@next_progr:

; 2534 :   state.layer_idx=0;
; 2535 :   state.comp_idx = state.comp_min;
; 2536 :   state.res_idx = state.res_min;

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+56], eax

; 2537 :   state.pos.x = state.pos.y=0;
; 2538 : 
; 2539 :   bool spatial = false;
; 2540 :   if ((state.order == Corder_PCRL) || (state.order == Corder_RPCL))

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], edx
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+64], 0
	cmp	eax, 3
	je	$LN28@next_progr
	cmp	eax, 2
	je	$LN28@next_progr

; 2565 :     }
; 2566 :   else if ((state.order == Corder_CPRL) && (state.comp_idx < state.comp_lim))

	cmp	eax, 4
	jne	$LN6@next_progr
	cmp	edx, DWORD PTR [esi+44]
	jge	$LN6@next_progr

; 2567 :     {
; 2568 :       spatial = true;
; 2569 :       state.grid_min = tile->comps[state.comp_idx].grid_min;

	mov	ecx, DWORD PTR [ecx+208]
	imul	edx, edx, 188
	mov	eax, DWORD PTR [edx+ecx+156]
	mov	DWORD PTR [esi+68], eax
	mov	eax, DWORD PTR [edx+ecx+160]

; 2570 :       state.grid_inc = tile->comps[state.comp_idx].grid_inc;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi+72], eax
	mov	ecx, DWORD PTR [ecx+208]
	mov	eax, DWORD PTR [edx+ecx+164]
	mov	DWORD PTR [esi+76], eax
	mov	eax, DWORD PTR [edx+ecx+168]
	mov	DWORD PTR [esi+80], eax

; 2571 :       state.grid_loc = state.grid_min;

	jmp	$LN68@next_progr
$LN18@next_progr:

; 2495 :               !tmp_poc->get(Porder,0,0,state.res_min))
; 2496 :             {
; 2497 :               if (tile->codestream->in == NULL)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN19@next_progr

; 2498 :                 { KDU_ERROR(e,24); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0DA@BOBLKNCL@Supplied?5progression?5order?5attri@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2498 :                 { KDU_ERROR(e,24); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	mov	eax, DWORD PTR [esi]
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	BYTE PTR _e$4[ebp+4], 0
	push	DWORD PTR [eax+4]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$5[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$5[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	eax
	mov	eax, DWORD PTR _e$4[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0DD@EDBDEPHJ@?5are?5insuffient?5to?5cover?5all?5pac@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2502 :                 }

	lea	ecx, DWORD PTR _e$4[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN19@next_progr:

; 2503 :               return false;

	xor	al, al
	jmp	$LN1@next_progr
$LN28@next_progr:

; 2541 :     {
; 2542 :       spatial = true;
; 2543 :       if (!common_grids)

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN29@next_progr

; 2544 :         { KDU_ERROR(e,25); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0LN@NLKIMLNE@Attempting?5to?5use?5a?5spatially?5pr@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2544 :         { KDU_ERROR(e,25); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2549 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN29@next_progr:

; 2550 :       for (int c=0; c < tile->num_components; c++)

	mov	eax, DWORD PTR [esi]
	xor	edx, edx
	cmp	DWORD PTR [eax+128], edx
	lea	ebx, DWORD PTR [eax+128]
	jle	SHORT $LN3@next_progr

; 2551 :         {
; 2552 :           kd_tile_comp *tc = tile->comps + c;

	xor	edi, edi
$LL4@next_progr:
	mov	ecx, DWORD PTR [eax+208]
	add	ecx, edi

; 2553 :           if ((c == 0) || (tc->grid_inc.x < state.grid_inc.x))

	test	edx, edx
	je	SHORT $LN31@next_progr
	mov	eax, DWORD PTR [ecx+168]
	cmp	eax, DWORD PTR [esi+80]
	jge	SHORT $LN30@next_progr
$LN31@next_progr:

; 2554 :             {
; 2555 :               state.grid_inc.x = tc->grid_inc.x;

	mov	eax, DWORD PTR [ecx+168]
	mov	DWORD PTR [esi+80], eax

; 2556 :               state.grid_min.x = tc->grid_min.x;

	mov	eax, DWORD PTR [ecx+160]
	mov	DWORD PTR [esi+72], eax
$LN30@next_progr:

; 2557 :             }
; 2558 :           if ((c == 0) || (tc->grid_inc.y < state.grid_inc.y))

	test	edx, edx
	je	SHORT $LN33@next_progr
	mov	eax, DWORD PTR [ecx+164]
	cmp	eax, DWORD PTR [esi+76]
	jge	SHORT $LN2@next_progr
$LN33@next_progr:

; 2559 :             {
; 2560 :               state.grid_inc.y = tc->grid_inc.y;

	mov	eax, DWORD PTR [ecx+164]
	mov	DWORD PTR [esi+76], eax

; 2561 :               state.grid_min.y = tc->grid_min.y;

	mov	eax, DWORD PTR [ecx+156]
	mov	DWORD PTR [esi+68], eax
$LN2@next_progr:

; 2550 :       for (int c=0; c < tile->num_components; c++)

	mov	eax, DWORD PTR [esi]
	inc	edx
	add	edi, 188				; 000000bcH
	cmp	edx, DWORD PTR [ebx]
	jl	SHORT $LL4@next_progr
$LN3@next_progr:
	mov	edi, ebx
$LN68@next_progr:

; 2562 :             }
; 2563 :         }
; 2564 :       state.grid_loc = state.grid_min;

	mov	eax, DWORD PTR [esi+68]

; 2572 :     }
; 2573 : 
; 2574 :   if (spatial)
; 2575 :     { // Need to reset the precinct position indices in each resolution.
; 2576 :       for (int c=0; c < tile->num_components; c++)

	xor	ebx, ebx
	mov	DWORD PTR [esi+84], eax
	mov	eax, DWORD PTR [esi+72]
	mov	DWORD PTR [esi+88], eax
	cmp	DWORD PTR [edi], ebx
	jle	SHORT $LN6@next_progr
	xor	ecx, ecx
	mov	DWORD PTR tv864[ebp], ecx
$LL7@next_progr:

; 2577 :         {
; 2578 :           kd_tile_comp *tc = tile->comps + c;

	mov	eax, DWORD PTR [esi]

; 2579 :           for (int r=0; r <= tc->dwt_levels; r++)

	xor	edx, edx
	mov	edi, DWORD PTR [eax+208]
	add	edi, ecx
	cmp	DWORD PTR [edi+56], edx
	jl	SHORT $LN5@next_progr

; 2577 :         {
; 2578 :           kd_tile_comp *tc = tile->comps + c;

	xor	ecx, ecx
	npad	10
$LL10@next_progr:

; 2580 :             {
; 2581 :               kd_resolution *res = tc->resolutions + r;

	mov	eax, DWORD PTR [edi+144]
	lea	ecx, DWORD PTR [ecx+604]
	inc	edx

; 2582 :               res->current_sequencer_pos.x = res->current_sequencer_pos.y = 0;

	mov	DWORD PTR [eax+ecx-16], 0
	mov	DWORD PTR [eax+ecx-12], 0
	cmp	edx, DWORD PTR [edi+56]
	jle	SHORT $LL10@next_progr
	mov	ecx, DWORD PTR tv864[ebp]
$LN5@next_progr:

; 2572 :     }
; 2573 : 
; 2574 :   if (spatial)
; 2575 :     { // Need to reset the precinct position indices in each resolution.
; 2576 :       for (int c=0; c < tile->num_components; c++)

	mov	eax, DWORD PTR [esi]
	inc	ebx
	add	ecx, 188				; 000000bcH
	mov	DWORD PTR tv864[ebp], ecx
	cmp	ebx, DWORD PTR [eax+128]
	jl	SHORT $LL7@next_progr
$LN6@next_progr:

; 2583 :             }
; 2584 :         }
; 2585 :     }
; 2586 :   return true;

	mov	al, 1
$LN1@next_progr:

; 2587 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?next_progression@kd_packet_sequencer@@AAE_NXZ$1:
	lea	ecx, DWORD PTR _w$3[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?next_progression@kd_packet_sequencer@@AAE_NXZ$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?next_progression@kd_packet_sequencer@@AAE_NXZ$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?next_progression@kd_packet_sequencer@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?next_progression@kd_packet_sequencer@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?next_progression@kd_packet_sequencer@@AAE_NXZ ENDP	; kd_packet_sequencer::next_progression
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z
_TEXT	SEGMENT
_res$ = 8						; size = 4
_idx$ = 12						; size = 4
?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z PROC ; kd_packet_sequencer::next_in_sequence, COMDAT
; _this$ = ecx

; 2596 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 2597 :   kd_precinct_ref *result = NULL;
; 2598 : 
; 2599 :   if (tile->sequenced_relevant_packets == tile->max_relevant_packets)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+248]
	cdq
	cmp	eax, DWORD PTR [ecx+152]
	jne	SHORT $LN40@next_in_se
	cmp	edx, DWORD PTR [ecx+156]
	jne	SHORT $LN40@next_in_se

; 2600 :     return NULL;

	xor	eax, eax
	pop	esi

; 2632 : }

	pop	ebp
	ret	8
$LN40@next_in_se:
	push	ebx

; 2600 :     return NULL;

	mov	ebx, DWORD PTR _idx$[ebp]
	push	edi
	npad	5
$LL4@next_in_se:

; 2601 :   do {
; 2602 :       if (state.order == Corder_LRCP)

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN6@next_in_se

; 2603 :         result = next_in_lrcp(res,idx);

	push	ebx
	push	DWORD PTR _res$[ebp]
	mov	ecx, esi
	call	?next_in_lrcp@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_lrcp
	jmp	SHORT $LN46@next_in_se
$LN6@next_in_se:

; 2604 :       else if (state.order == Corder_RLCP)

	cmp	eax, 1
	jne	SHORT $LN8@next_in_se

; 2605 :         result = next_in_rlcp(res,idx);

	push	ebx
	push	DWORD PTR _res$[ebp]
	mov	ecx, esi
	call	?next_in_rlcp@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_rlcp
	jmp	SHORT $LN46@next_in_se
$LN8@next_in_se:

; 2606 :       else if (state.order == Corder_RPCL)

	cmp	eax, 2
	jne	SHORT $LN10@next_in_se

; 2607 :         result = next_in_rpcl(res,idx);

	push	ebx
	push	DWORD PTR _res$[ebp]
	mov	ecx, esi
	call	?next_in_rpcl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_rpcl
	jmp	SHORT $LN46@next_in_se
$LN10@next_in_se:

; 2608 :       else if (state.order == Corder_PCRL)

	cmp	eax, 3
	jne	SHORT $LN12@next_in_se

; 2609 :         result = next_in_pcrl(res,idx);

	push	ebx
	push	DWORD PTR _res$[ebp]
	mov	ecx, esi
	call	?next_in_pcrl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_pcrl
	jmp	SHORT $LN46@next_in_se
$LN12@next_in_se:

; 2610 :       else if (state.order == Corder_CPRL)

	cmp	eax, 4
	jne	SHORT $LN38@next_in_se

; 2611 :         result = next_in_cprl(res,idx);

	push	ebx
	push	DWORD PTR _res$[ebp]
	mov	ecx, esi
	call	?next_in_cprl@kd_packet_sequencer@@AAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_cprl
$LN46@next_in_se:
	mov	edi, eax

; 2612 :       else
; 2613 :         assert(0);
; 2614 :     } while ((result == NULL) && next_progression());

	test	edi, edi
	jne	SHORT $LN17@next_in_se
$LN38@next_in_se:
	mov	ecx, esi
	call	?next_progression@kd_packet_sequencer@@AAE_NXZ ; kd_packet_sequencer::next_progression
	test	al, al
	jne	SHORT $LL4@next_in_se
$LN41@next_in_se:
	pop	edi
	pop	ebx

; 2615 :   if (result == NULL)
; 2616 :     return NULL;

	xor	eax, eax
	pop	esi

; 2632 : }

	pop	ebp
	ret	8
$LN17@next_in_se:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	mov	eax, DWORD PTR [edi]
	and	eax, 1
	or	eax, 0
	je	SHORT $LN26@next_in_se
	xor	ecx, ecx
	jmp	SHORT $LN27@next_in_se
$LN26@next_in_se:
	mov	ecx, DWORD PTR [edi]
$LN27@next_in_se:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2618 :   if ((tile->codestream->in != NULL) &&

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN22@next_in_se
	test	ecx, ecx
	je	SHORT $LN19@next_in_se
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN22@next_in_se
$LN19@next_in_se:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1210 :       { return ((buf_server==NULL)?((kdu_long) 0):pop_address()); }

	cmp	DWORD PTR [edx+56], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2622 :         tile->precinct_pointer_server.get_precinct_address();

	lea	ecx, DWORD PTR [edx+56]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1210 :       { return ((buf_server==NULL)?((kdu_long) 0):pop_address()); }

	je	SHORT $LN22@next_in_se
	call	?pop_address@kd_precinct_pointer_server@@AAE_JXZ ; kd_precinct_pointer_server::pop_address
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2623 :       if (seek_address < 0)

	test	edx, edx
	jg	SHORT $LN43@next_in_se
	jl	SHORT $LN41@next_in_se
	test	eax, eax
	jb	SHORT $LN41@next_in_se

; 2624 :         return NULL; // Need a new tile-part.
; 2625 :       if (seek_address > 0)

	test	edx, edx
	jl	SHORT $LN22@next_in_se
	jg	SHORT $LN43@next_in_se
	test	eax, eax
	je	SHORT $LN22@next_in_se
$LN43@next_in_se:

; 2626 :         {
; 2627 :           if (!result->set_address(res,idx,seek_address))

	push	edx
	push	eax
	push	DWORD PTR [ebx+4]
	mov	eax, DWORD PTR _res$[ebp]
	mov	ecx, edi
	push	DWORD PTR [ebx]
	push	DWORD PTR [eax]
	call	?set_address@kd_precinct_ref@@QAE_NPAUkd_resolution@@Ukdu_coords@@_J@Z ; kd_precinct_ref::set_address
	xor	ecx, ecx
	test	al, al
	cmove	edi, ecx
$LN22@next_in_se:

; 2628 :             result = NULL; // Tile has been destroyed
; 2629 :         }
; 2630 :     }
; 2631 :   return result;

	mov	eax, edi
	pop	edi
	pop	ebx
	pop	esi

; 2632 : }

	pop	ebp
	ret	8
?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ENDP ; kd_packet_sequencer::next_in_sequence
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?restore_state@kd_packet_sequencer@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -20						; size = 4
tv301 = -16						; size = 4
_c$1$ = -12						; size = 4
tv304 = -8						; size = 4
_r$1$ = -4						; size = 4
?restore_state@kd_packet_sequencer@@QAEXXZ PROC		; kd_packet_sequencer::restore_state, COMDAT
; _this$ = ecx

; 2434 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, ecx

; 2437 :   tile->sequenced_relevant_packets = tile->saved_num_sequenced_packets;
; 2438 :   for (int c=0; c < tile->num_components; c++)

	xor	edx, edx
	mov	DWORD PTR _this$1$[ebp], ebx
	mov	DWORD PTR _c$1$[ebp], edx
	movups	xmm0, XMMWORD PTR [ebx+100]
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+172]
	movups	XMMWORD PTR [ebx+24], xmm0
	movups	xmm0, XMMWORD PTR [ebx+116]
	movups	XMMWORD PTR [ebx+40], xmm0
	movups	xmm0, XMMWORD PTR [ebx+132]
	movups	XMMWORD PTR [ebx+56], xmm0
	movups	xmm0, XMMWORD PTR [ebx+148]
	movups	XMMWORD PTR [ebx+72], xmm0
	movq	xmm0, QWORD PTR [ebx+164]
	movq	QWORD PTR [ebx+88], xmm0
	mov	DWORD PTR [ebx+96], eax
	mov	eax, DWORD PTR [ecx+264]
	mov	DWORD PTR [ecx+248], eax
	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+128], edx
	jle	$LN3@restore_st

; 2435 :   assert(state_saved);
; 2436 :   state = saved_state;

	xor	ecx, ecx
	push	esi
	mov	DWORD PTR tv301[ebp], ecx
	push	edi
$LL4@restore_st:

; 2439 :     {
; 2440 :       kd_tile_comp *tc = tile->comps + c;

	mov	eax, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [eax+208]

; 2441 :       tc->grid_min = tc->saved_grid_min;

	mov	eax, DWORD PTR [ebx+ecx+172]
	add	ebx, ecx

; 2442 :       tc->grid_inc = tc->saved_grid_inc;
; 2443 :       for (int r=0; r <= tc->dwt_levels; r++)

	xor	ecx, ecx
	mov	DWORD PTR _r$1$[ebp], ecx
	mov	DWORD PTR [ebx+156], eax
	mov	eax, DWORD PTR [ebx+176]
	mov	DWORD PTR [ebx+160], eax
	mov	eax, DWORD PTR [ebx+180]
	mov	DWORD PTR [ebx+164], eax
	mov	eax, DWORD PTR [ebx+184]
	mov	DWORD PTR [ebx+168], eax
	cmp	DWORD PTR [ebx+56], ecx
	jl	$LN2@restore_st

; 2439 :     {
; 2440 :       kd_tile_comp *tc = tile->comps + c;

	xor	eax, eax
	mov	DWORD PTR tv304[ebp], eax
	npad	2
$LL7@restore_st:

; 2444 :         {
; 2445 :           kd_resolution *res = tc->resolutions + r;

	mov	esi, DWORD PTR [ebx+144]

; 2448 :           for (int n=0; n < num_precincts; n++)

	xor	edx, edx
	add	esi, eax
	mov	eax, DWORD PTR [esi+596]
	mov	DWORD PTR [esi+588], eax
	mov	eax, DWORD PTR [esi+600]
	mov	DWORD PTR [esi+592], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	edi, DWORD PTR [esi+148]
	imul	edi, DWORD PTR [esi+144]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2448 :           for (int n=0; n < num_precincts; n++)

	test	edi, edi
	jle	SHORT $LN5@restore_st
$LL10@restore_st:
	mov	eax, DWORD PTR [esi+180]
	lea	ecx, DWORD PTR [eax+edx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	mov	eax, DWORD PTR [ecx]
	and	eax, 1
	or	eax, 0
	jne	SHORT $LN8@restore_st
	mov	eax, DWORD PTR [ecx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2451 :               if (precinct != NULL)

	test	eax, eax
	je	SHORT $LN8@restore_st

; 2452 :                 precinct->next_layer_idx = precinct->saved_next_layer_idx;

	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [eax+16], ecx
$LN8@restore_st:

; 2448 :           for (int n=0; n < num_precincts; n++)

	inc	edx
	cmp	edx, edi
	jl	SHORT $LL10@restore_st
	mov	ecx, DWORD PTR _r$1$[ebp]
$LN5@restore_st:

; 2442 :       tc->grid_inc = tc->saved_grid_inc;
; 2443 :       for (int r=0; r <= tc->dwt_levels; r++)

	mov	eax, DWORD PTR tv304[ebp]
	inc	ecx
	add	eax, 604				; 0000025cH
	mov	DWORD PTR _r$1$[ebp], ecx
	mov	DWORD PTR tv304[ebp], eax
	cmp	ecx, DWORD PTR [ebx+56]
	jle	SHORT $LL7@restore_st
	mov	edx, DWORD PTR _c$1$[ebp]
$LN2@restore_st:

; 2437 :   tile->sequenced_relevant_packets = tile->saved_num_sequenced_packets;
; 2438 :   for (int c=0; c < tile->num_components; c++)

	mov	ebx, DWORD PTR _this$1$[ebp]
	inc	edx
	mov	ecx, DWORD PTR tv301[ebp]
	add	ecx, 188				; 000000bcH
	mov	DWORD PTR _c$1$[ebp], edx
	mov	DWORD PTR tv301[ebp], ecx
	mov	eax, DWORD PTR [ebx]
	cmp	edx, DWORD PTR [eax+128]
	jl	$LL4@restore_st
	pop	edi
	pop	esi
$LN3@restore_st:
	pop	ebx

; 2453 :             }
; 2454 :         }
; 2455 :     }
; 2456 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?restore_state@kd_packet_sequencer@@QAEXXZ ENDP		; kd_packet_sequencer::restore_state
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?save_state@kd_packet_sequencer@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -20						; size = 4
tv304 = -16						; size = 4
_c$1$ = -12						; size = 4
tv307 = -8						; size = 4
_r$1$ = -4						; size = 4
?save_state@kd_packet_sequencer@@QAEXXZ PROC		; kd_packet_sequencer::save_state, COMDAT
; _this$ = ecx

; 2404 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	edx, ecx
	push	esi

; 2406 :   tile->saved_num_sequenced_packets = tile->sequenced_relevant_packets;
; 2407 :   for (int c=0; c < tile->num_components; c++)

	xor	esi, esi
	mov	DWORD PTR _this$1$[ebp], edx
	mov	DWORD PTR _c$1$[ebp], esi
	movups	xmm0, XMMWORD PTR [edx+24]
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+96]
	movups	XMMWORD PTR [edx+100], xmm0
	movups	xmm0, XMMWORD PTR [edx+40]
	movups	XMMWORD PTR [edx+116], xmm0
	movups	xmm0, XMMWORD PTR [edx+56]
	movups	XMMWORD PTR [edx+132], xmm0
	movups	xmm0, XMMWORD PTR [edx+72]
	movups	XMMWORD PTR [edx+148], xmm0
	movq	xmm0, QWORD PTR [edx+88]
	movq	QWORD PTR [edx+164], xmm0
	mov	DWORD PTR [edx+172], eax
	mov	eax, DWORD PTR [ecx+248]
	mov	DWORD PTR [ecx+264], eax
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+128], esi
	jle	$LN31@save_state

; 2405 :   saved_state = state;

	xor	ecx, ecx
	push	ebx
	mov	DWORD PTR tv304[ebp], ecx
	push	edi
$LL4@save_state:

; 2408 :     {
; 2409 :       kd_tile_comp *tc = tile->comps + c;

	mov	eax, DWORD PTR [edx]
	mov	ebx, DWORD PTR [eax+208]

; 2410 :       tc->saved_grid_min = tc->grid_min;

	mov	eax, DWORD PTR [ebx+ecx+156]
	add	ebx, ecx

; 2411 :       tc->saved_grid_inc = tc->grid_inc;
; 2412 :       for (int r=0; r <= tc->dwt_levels; r++)

	xor	ecx, ecx
	mov	DWORD PTR _r$1$[ebp], ecx
	mov	DWORD PTR [ebx+172], eax
	mov	eax, DWORD PTR [ebx+160]
	mov	DWORD PTR [ebx+176], eax
	mov	eax, DWORD PTR [ebx+164]
	mov	DWORD PTR [ebx+180], eax
	mov	eax, DWORD PTR [ebx+168]
	mov	DWORD PTR [ebx+184], eax
	cmp	DWORD PTR [ebx+56], ecx
	jl	$LN2@save_state

; 2408 :     {
; 2409 :       kd_tile_comp *tc = tile->comps + c;

	xor	eax, eax
	mov	DWORD PTR tv307[ebp], eax
	npad	2
$LL7@save_state:

; 2413 :         {
; 2414 :           kd_resolution *res = tc->resolutions + r;

	mov	esi, DWORD PTR [ebx+144]

; 2417 :           for (int n=0; n < num_precincts; n++)

	xor	edx, edx
	add	esi, eax
	mov	eax, DWORD PTR [esi+588]
	mov	DWORD PTR [esi+596], eax
	mov	eax, DWORD PTR [esi+592]
	mov	DWORD PTR [esi+600], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	edi, DWORD PTR [esi+148]
	imul	edi, DWORD PTR [esi+144]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2417 :           for (int n=0; n < num_precincts; n++)

	test	edi, edi
	jle	SHORT $LN5@save_state
$LL10@save_state:
	mov	eax, DWORD PTR [esi+180]
	lea	ecx, DWORD PTR [eax+edx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	mov	eax, DWORD PTR [ecx]
	and	eax, 1
	or	eax, 0
	jne	SHORT $LN8@save_state
	mov	eax, DWORD PTR [ecx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2420 :               if (precinct != NULL)

	test	eax, eax
	je	SHORT $LN8@save_state

; 2421 :                 precinct->saved_next_layer_idx = precinct->next_layer_idx;

	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [eax+20], ecx
$LN8@save_state:

; 2417 :           for (int n=0; n < num_precincts; n++)

	inc	edx
	cmp	edx, edi
	jl	SHORT $LL10@save_state
	mov	ecx, DWORD PTR _r$1$[ebp]
$LN5@save_state:

; 2411 :       tc->saved_grid_inc = tc->grid_inc;
; 2412 :       for (int r=0; r <= tc->dwt_levels; r++)

	mov	eax, DWORD PTR tv307[ebp]
	inc	ecx
	add	eax, 604				; 0000025cH
	mov	DWORD PTR _r$1$[ebp], ecx
	mov	DWORD PTR tv307[ebp], eax
	cmp	ecx, DWORD PTR [ebx+56]
	jle	SHORT $LL7@save_state
	mov	edx, DWORD PTR _this$1$[ebp]
	mov	esi, DWORD PTR _c$1$[ebp]
$LN2@save_state:

; 2406 :   tile->saved_num_sequenced_packets = tile->sequenced_relevant_packets;
; 2407 :   for (int c=0; c < tile->num_components; c++)

	mov	eax, DWORD PTR [edx]
	inc	esi
	mov	ecx, DWORD PTR tv304[ebp]
	add	ecx, 188				; 000000bcH
	mov	DWORD PTR _c$1$[ebp], esi
	mov	DWORD PTR tv304[ebp], ecx
	cmp	esi, DWORD PTR [eax+128]
	jl	$LL4@save_state
	pop	edi
	pop	ebx
$LN31@save_state:

; 2422 :             }
; 2423 :         }
; 2424 :     }
; 2425 :   state_saved = true;

	mov	BYTE PTR [edx+20], 1
	pop	esi

; 2426 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?save_state@kd_packet_sequencer@@QAEXXZ ENDP		; kd_packet_sequencer::save_state
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?init@kd_packet_sequencer@@QAEXXZ
_TEXT	SEGMENT
tv689 = -8						; size = 4
_c$1$ = -4						; size = 4
?init@kd_packet_sequencer@@QAEXXZ PROC			; kd_packet_sequencer::init, COMDAT
; _this$ = ecx

; 2350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx

; 2358 :   for (c=0; c < tile->num_components; c++)

	mov	DWORD PTR _c$1$[ebp], 0
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ebx+4], 0
	mov	BYTE PTR [ebx+8], 1
	cmp	DWORD PTR [eax+128], 0
	jle	$LN3@init

; 2351 :   int c, r;
; 2352 :   kd_tile_comp *tc;
; 2353 :   kd_resolution *res;
; 2354 : 
; 2355 :   assert(tile->initialized);
; 2356 :   max_dwt_levels = 0;

	xor	ecx, ecx
	push	esi
	mov	DWORD PTR tv689[ebp], ecx
	push	edi
$LL4@init:

; 2359 :     {
; 2360 :       tc = tile->comps + c;

	mov	esi, DWORD PTR [ebx]
	mov	esi, DWORD PTR [esi+208]
	add	esi, ecx

; 2361 :       if (tc->dwt_levels > max_dwt_levels)

	mov	eax, DWORD PTR [esi+56]
	cmp	eax, DWORD PTR [ebx+4]
	jle	SHORT $LN8@init

; 2362 :         max_dwt_levels = tc->dwt_levels;

	mov	DWORD PTR [ebx+4], eax
$LN8@init:

; 2363 :       if (!(is_power_2(tc->sub_sampling.x) && is_power_2(tc->sub_sampling.y)))

	push	DWORD PTR [esi+20]
	call	?is_power_2@@YA_NH@Z			; is_power_2
	add	esp, 4
	test	al, al
	je	SHORT $LN10@init
	push	DWORD PTR [esi+16]
	call	?is_power_2@@YA_NH@Z			; is_power_2
	add	esp, 4
	test	al, al
	jne	SHORT $LN9@init
$LN10@init:

; 2364 :         common_grids = false;

	mov	BYTE PTR [ebx+8], 0
$LN9@init:

; 2365 :       for (r=0; r <= tc->dwt_levels; r++)

	xor	edi, edi
	cmp	DWORD PTR [esi+56], edi
	jl	SHORT $LN6@init

; 2366 :         {
; 2367 :           int inc;
; 2368 : 
; 2369 :           res = tc->resolutions + r;

	mov	edx, DWORD PTR [esi+144]
	add	edx, 132				; 00000084H
	npad	5
$LL7@init:

; 2370 :           inc = res->precinct_partition.size.x;
; 2371 : 
; 2372 : 
; 2373 :           inc <<= res->hor_depth;

	mov	eax, DWORD PTR [edx]
	mov	cl, BYTE PTR [edx-118]
	shl	eax, cl

; 2374 :           inc *= tc->sub_sampling.x;

	imul	eax, DWORD PTR [esi+20]

; 2375 :           if ((r == 0) || (inc < tc->grid_inc.x))

	test	edi, edi
	je	SHORT $LN12@init
	cmp	eax, DWORD PTR [esi+168]
	jge	SHORT $LN11@init
$LN12@init:

; 2376 :             tc->grid_inc.x = inc;

	mov	DWORD PTR [esi+168], eax
$LN11@init:

; 2377 : 
; 2378 :           inc = res->precinct_partition.size.y;
; 2379 :           inc <<= res->vert_depth;

	mov	eax, DWORD PTR [edx-4]
	mov	cl, BYTE PTR [edx-117]
	shl	eax, cl

; 2380 :           inc *= tc->sub_sampling.y;

	imul	eax, DWORD PTR [esi+16]

; 2381 :           if ((r == 0) || (inc < tc->grid_inc.y))

	test	edi, edi
	je	SHORT $LN14@init
	cmp	eax, DWORD PTR [esi+164]
	jge	SHORT $LN5@init
$LN14@init:

; 2382 :             tc->grid_inc.y = inc;

	mov	DWORD PTR [esi+164], eax
$LN5@init:

; 2365 :       for (r=0; r <= tc->dwt_levels; r++)

	inc	edi
	add	edx, 604				; 0000025cH
	cmp	edi, DWORD PTR [esi+56]
	jle	SHORT $LL7@init
$LN6@init:

; 2383 :         }
; 2384 :       tc->grid_min = tile->dims.pos - tile->coding_origin;

	mov	ecx, DWORD PTR [ebx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	edx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR [ecx+160]
	sub	edx, DWORD PTR [ecx+196]
	sub	eax, DWORD PTR [ecx+192]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2385 :       tc->grid_min.x = tc->grid_inc.x *

	mov	ecx, DWORD PTR [esi+168]
	mov	DWORD PTR [esi+156], eax
	mov	DWORD PTR [esi+160], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 199  :   if (num < 0)

	test	edx, edx
	jns	SHORT $LN21@init

; 200  :     return -(1+((-num-1)/den));

	or	eax, -1
	sub	eax, edx
	cdq
	idiv	ecx
	or	edx, -1
	sub	edx, eax
	jmp	SHORT $LN22@init
$LN21@init:

; 201  :   else
; 202  :     return num/den;

	mov	eax, edx
	cdq
	idiv	ecx
	mov	edx, eax
$LN22@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2385 :       tc->grid_min.x = tc->grid_inc.x *

	imul	ecx, edx

; 2387 :       tc->grid_min.y = tc->grid_inc.y *

	mov	edx, DWORD PTR [esi+156]
	mov	DWORD PTR [esi+160], ecx
	mov	ecx, DWORD PTR [esi+164]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 199  :   if (num < 0)

	test	edx, edx
	jns	SHORT $LN25@init

; 200  :     return -(1+((-num-1)/den));

	or	eax, -1
	sub	eax, edx
	cdq
	idiv	ecx
	or	edx, -1
	sub	edx, eax
	jmp	SHORT $LN26@init
$LN25@init:

; 201  :   else
; 202  :     return num/den;

	mov	eax, edx
	cdq
	idiv	ecx
	mov	edx, eax
$LN26@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2387 :       tc->grid_min.y = tc->grid_inc.y *

	imul	ecx, edx
	mov	edx, DWORD PTR _c$1$[ebp]
	inc	edx
	mov	DWORD PTR _c$1$[ebp], edx
	mov	DWORD PTR [esi+156], ecx

; 2388 :         floor_ratio(tc->grid_min.y,tc->grid_inc.y);
; 2389 :       tc->grid_min += tile->coding_origin;

	mov	ecx, DWORD PTR [ebx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	mov	eax, DWORD PTR [ecx+196]
	add	DWORD PTR [esi+160], eax
	mov	eax, DWORD PTR [ecx+192]
	add	DWORD PTR [esi+156], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2358 :   for (c=0; c < tile->num_components; c++)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR tv689[ebp]
	add	ecx, 188				; 000000bcH
	mov	DWORD PTR tv689[ebp], ecx
	cmp	edx, DWORD PTR [eax+128]
	jl	$LL4@init
	pop	edi
	pop	esi
$LN3@init:

; 2390 :     }
; 2391 :   grid_lim = tile->dims.pos + tile->dims.size;

	mov	ecx, DWORD PTR [ebx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	edx, DWORD PTR [ecx+172]
	mov	eax, DWORD PTR [ecx+168]
	add	edx, DWORD PTR [ecx+164]
	add	eax, DWORD PTR [ecx+160]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2395 :   next_progression();

	mov	ecx, ebx
	mov	DWORD PTR [ebx+12], eax
	mov	DWORD PTR [ebx+16], edx
	mov	BYTE PTR [ebx+20], 0
	mov	DWORD PTR [ebx+92], 0
	mov	DWORD PTR [ebx+96], 0
	call	?next_progression@kd_packet_sequencer@@AAE_NXZ ; kd_packet_sequencer::next_progression
	pop	ebx

; 2396 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?init@kd_packet_sequencer@@QAEXXZ ENDP			; kd_packet_sequencer::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Gkd_codestream_comment@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_codestream_comment@@QAEPAXI@Z PROC		; kd_codestream_comment::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1469 :       { if (text_buf != NULL) delete[] text_buf; }

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN5@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN8@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_codestream_comment@@QAEPAXI@Z ENDP		; kd_codestream_comment::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?write_marker@kd_codestream_comment@@QAEHPAVkdu_output@@H@Z
_TEXT	SEGMENT
_pad_chars$1$ = -4					; size = 4
_out$ = 8						; size = 4
_force_length$ = 12					; size = 4
?write_marker@kd_codestream_comment@@QAEHPAVkdu_output@@H@Z PROC ; kd_codestream_comment::write_marker, COMDAT
; _this$ = ecx

; 3174 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3175 :   readonly = true;
; 3176 :   int pad_chars = 0;
; 3177 :   if (force_length != 0)

	mov	edx, DWORD PTR _force_length$[ebp]
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
	xor	edi, edi
	mov	DWORD PTR _pad_chars$1$[ebp], edi
	mov	BYTE PTR [ebx], 1
	test	edx, edx
	je	SHORT $LN8@write_mark

; 3178 :     {
; 3179 :       force_length -= 6;

	sub	edx, 6

; 3180 :       if (force_length < 0)

	mov	eax, edi
	cmovs	edx, eax

; 3181 :         force_length = 0;
; 3182 :       if (force_length < num_chars)

	mov	eax, DWORD PTR [ebx+8]
	cmp	edx, eax
	jge	SHORT $LN7@write_mark

; 3183 :         {
; 3184 :           num_chars = force_length;
; 3185 :           text_buf[num_chars] = '\0';

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebx+8], edx
	mov	BYTE PTR [edx+eax], 0

; 3186 :         }
; 3187 :       else

	jmp	SHORT $LN8@write_mark
$LN7@write_mark:

; 3188 :         pad_chars = force_length - num_chars;

	mov	edi, edx
	sub	edi, eax
	mov	DWORD PTR _pad_chars$1$[ebp], edi
$LN8@write_mark:

; 3189 :     }
; 3190 :   if (out != NULL)

	mov	esi, DWORD PTR _out$[ebp]
	test	esi, esi
	je	SHORT $LN3@write_mark

; 3191 :     {
; 3192 :       out->put(KDU_COM);

	push	65380					; 0000ff64H
	mov	ecx, esi
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 3193 :       out->put((kdu_uint16)(4+num_chars+pad_chars));

	mov	ax, WORD PTR [ebx+8]
	mov	ecx, esi
	add	ax, 4
	add	ax, di
	movzx	eax, ax
	push	eax
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 3194 :       out->put((kdu_uint16) 1); // Latin values

	push	1
	mov	ecx, esi
	call	?put@kdu_output@@QAEHG@Z		; kdu_output::put

; 3195 :       out->write((kdu_byte *) text_buf,num_chars);

	push	DWORD PTR [ebx+8]
	mov	ecx, esi
	push	DWORD PTR [ebx+12]
	call	?write@kdu_output@@QAEXPAEH@Z		; kdu_output::write

; 3196 :       for (int i=0; i < pad_chars; i++)

	test	edi, edi
	jle	SHORT $LN3@write_mark
	npad	3
$LL4@write_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN12@write_mark

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN12@write_mark:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 0
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3196 :       for (int i=0; i < pad_chars; i++)

	sub	edi, 1
	jne	SHORT $LL4@write_mark
$LN3@write_mark:

; 3197 :         out->put((kdu_byte) 0);
; 3198 :     }
; 3199 :   return 6+num_chars+pad_chars;

	mov	ecx, DWORD PTR _pad_chars$1$[ebp]
	mov	eax, DWORD PTR [ebx+8]
	add	ecx, 6
	pop	edi
	pop	esi
	add	eax, ecx
	pop	ebx

; 3200 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?write_marker@kd_codestream_comment@@QAEHPAVkdu_output@@H@Z ENDP ; kd_codestream_comment::write_marker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_text@kd_codestream_comment@@QAEXHPAE@Z
_TEXT	SEGMENT
_length$ = 8						; size = 4
_data$ = 12						; size = 4
?set_text@kd_codestream_comment@@QAEXHPAE@Z PROC	; kd_codestream_comment::set_text, COMDAT
; _this$ = ecx

; 3148 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 3149 :   assert(!readonly);
; 3150 :   readonly = true;
; 3151 :   if (length <= 0)

	mov	edi, DWORD PTR _length$[ebp]
	mov	BYTE PTR [esi], 1
	test	edi, edi
	jle	SHORT $LN6@set_text

; 3152 :     return;
; 3153 :   if (max_chars < length)

	cmp	DWORD PTR [esi+4], edi
	jge	SHORT $LN3@set_text

; 3154 :     {
; 3155 :       max_chars = length;
; 3156 :       if (text_buf != NULL)

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+4], edi
	test	eax, eax
	je	SHORT $LN4@set_text

; 3157 :         { delete[] text_buf; text_buf = NULL; }

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+12], 0
$LN4@set_text:

; 3158 :       text_buf = new char[max_chars+1];

	mov	eax, DWORD PTR [esi+4]
	inc	eax
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+12], eax
$LN3@set_text:

; 3159 :     }
; 3160 :   num_chars = length;
; 3161 :   memcpy(text_buf,data,(size_t) length);

	push	edi
	push	DWORD PTR _data$[ebp]
	mov	DWORD PTR [esi+8], edi
	push	DWORD PTR [esi+12]
	call	_memcpy

; 3162 :   if (text_buf[length-1] != '\0')

	mov	eax, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH
	cmp	BYTE PTR [eax+edi-1], 0
	je	SHORT $LN5@set_text

; 3163 :     text_buf[length] = '\0';

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi

; 3166 : }

	pop	ebp
	ret	8
$LN5@set_text:

; 3164 :   else
; 3165 :     num_chars--;

	dec	DWORD PTR [esi+8]
$LN6@set_text:
	pop	edi
	pop	esi

; 3166 : }

	pop	ebp
	ret	8
?set_text@kd_codestream_comment@@QAEXHPAE@Z ENDP	; kd_codestream_comment::set_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_codestream_comment@@QAE@XZ
_TEXT	SEGMENT
??1kd_codestream_comment@@QAE@XZ PROC			; kd_codestream_comment::~kd_codestream_comment, COMDAT
; _this$ = ecx

; 1469 :       { if (text_buf != NULL) delete[] text_buf; }

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	SHORT $LN2@kd_codestr
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN2@kd_codestr:
	ret	0
??1kd_codestream_comment@@QAE@XZ ENDP			; kd_codestream_comment::~kd_codestream_comment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_codestream_comment@@QAE@XZ
_TEXT	SEGMENT
??0kd_codestream_comment@@QAE@XZ PROC			; kd_codestream_comment::kd_codestream_comment, COMDAT
; _this$ = ecx

; 1467 :       { readonly=false; max_chars=num_chars=0; text_buf=NULL; next=NULL; }

	mov	BYTE PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	ret	0
??0kd_codestream_comment@@QAE@XZ ENDP			; kd_codestream_comment::kd_codestream_comment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_conservative_slope_threshold@kd_compressed_stats@@QAEG_N@Z
_TEXT	SEGMENT
_assume_all_coded$ = 8					; size = 1
?get_conservative_slope_threshold@kd_compressed_stats@@QAEG_N@Z PROC ; kd_compressed_stats::get_conservative_slope_threshold, COMDAT
; _this$ = ecx

; 1397 :       { /* The slope threshold generated by PCRD-opt is unlikely to be

	push	ebp
	mov	ebp, esp

; 1398 :            smaller than that returned here -- remember that smaller thresholds
; 1399 :            mean that more compressed data are included in the code-stream.
; 1400 :            If `assume_all_coded' is true, the slope threshold is based on the
; 1401 :            assumption that no bytes will be generated for any further samples.
; 1402 :            Otherwise, the assumption is that future samples will have the
; 1403 :            same average compressibility as those already coded.  Note that
; 1404 :            since compressors tend to output a higher proportion of high
; 1405 :            frequency subband samples than low frequency subband samples at
; 1406 :            any point up to the end of the image, the actual compressibility
; 1407 :            of future samples can be expected to be lower on average, making
; 1408 :            our estimate more conservative. */
; 1409 :         int val =
; 1410 :           (assume_all_coded)?remaining_slope_threshold:block_slope_threshold;

	cmp	BYTE PTR _assume_all_coded$[ebp], 0
	je	SHORT $LN3@get_conser
	mov	ecx, DWORD PTR [ecx+32820]

; 1411 :         val = (val<<4)-1;
; 1412 :         return (kdu_uint16)((val>0)?val:1);

	mov	eax, 1
	shl	ecx, 4
	dec	ecx
	test	ecx, ecx
	cmovg	eax, ecx

; 1413 :       }

	pop	ebp
	ret	4
$LN3@get_conser:

; 1398 :            smaller than that returned here -- remember that smaller thresholds
; 1399 :            mean that more compressed data are included in the code-stream.
; 1400 :            If `assume_all_coded' is true, the slope threshold is based on the
; 1401 :            assumption that no bytes will be generated for any further samples.
; 1402 :            Otherwise, the assumption is that future samples will have the
; 1403 :            same average compressibility as those already coded.  Note that
; 1404 :            since compressors tend to output a higher proportion of high
; 1405 :            frequency subband samples than low frequency subband samples at
; 1406 :            any point up to the end of the image, the actual compressibility
; 1407 :            of future samples can be expected to be lower on average, making
; 1408 :            our estimate more conservative. */
; 1409 :         int val =
; 1410 :           (assume_all_coded)?remaining_slope_threshold:block_slope_threshold;

	mov	ecx, DWORD PTR [ecx+32816]

; 1411 :         val = (val<<4)-1;
; 1412 :         return (kdu_uint16)((val>0)?val:1);

	mov	eax, 1
	shl	ecx, 4
	dec	ecx
	test	ecx, ecx
	cmovg	eax, ecx

; 1413 :       }

	pop	ebp
	ret	4
?get_conservative_slope_threshold@kd_compressed_stats@@QAEG_N@Z ENDP ; kd_compressed_stats::get_conservative_slope_threshold
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?update_quant_slope_thresholds@kd_compressed_stats@@QAEXXZ
_TEXT	SEGMENT
_cumulative_bytes$ = -16				; size = 8
_max_bytes$3$ = -8					; size = 4
_max_bytes$2$ = -8					; size = 4
_max_bytes$4$ = -4					; size = 4
_max_bytes$1$ = -4					; size = 4
?update_quant_slope_thresholds@kd_compressed_stats@@QAEXXZ PROC ; kd_compressed_stats::update_quant_slope_thresholds, COMDAT
; _this$ = ecx

; 1369 :       { /* This function should be called after `update_stats' to ensure that

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 1370 :            the most up-to-date slope threshold is available for return via
; 1371 :            `get_conservative_slope_threshold'.  If desired, multiple calls
; 1372 :            to `update_stats' may precede the call to this function, which
; 1373 :            may improve efficiency.  The reason for computing the slope
; 1374 :            threshold here, rather than in `get_conservative_slope_threshold'
; 1375 :            is that the latter function may be invoked asynchronously by any
; 1376 :            number of threads of execution, whereas the present function is
; 1377 :            always invoked while holding the `KD_THREADLOCK_STATS' mutex
; 1378 :            (in multi-threaded applications) so that other threads cannot
; 1379 :            modify the statistics while this function is in progress. */
; 1380 :         int n;  kdu_long max_bytes, cumulative_bytes;
; 1381 :         // Adjust `block_slope_threshold'
; 1382 :         max_bytes = num_coded_samples + conservative_extra_samples;

	mov	ecx, DWORD PTR [ebx+32]
	add	ecx, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [ebx+36]
	adc	edx, DWORD PTR [ebx+28]

; 1383 :         max_bytes = 1 + (kdu_long)(max_bytes * target_rate);

	call	__ltod3
	mulsd	xmm0, QWORD PTR [ebx]
	call	__dtol3

; 1384 :         for (cumulative_bytes=0, n=max_quant_slope; n >= min_quant_slope; n--)

	mov	esi, DWORD PTR [ebx+32812]
	add	eax, 1
	mov	edi, DWORD PTR [ebx+32808]
	mov	ecx, edx
	adc	ecx, 0
	mov	DWORD PTR _max_bytes$3$[ebp], eax
	mov	DWORD PTR _max_bytes$1$[ebp], ecx
	xorps	xmm0, xmm0
	mov	ecx, esi
	movlpd	QWORD PTR _cumulative_bytes$[ebp], xmm0
	cmp	ecx, edi
	jl	SHORT $LN13@update_qua

; 1370 :            the most up-to-date slope threshold is available for return via
; 1371 :            `get_conservative_slope_threshold'.  If desired, multiple calls
; 1372 :            to `update_stats' may precede the call to this function, which
; 1373 :            may improve efficiency.  The reason for computing the slope
; 1374 :            threshold here, rather than in `get_conservative_slope_threshold'
; 1375 :            is that the latter function may be invoked asynchronously by any
; 1376 :            number of threads of execution, whereas the present function is
; 1377 :            always invoked while holding the `KD_THREADLOCK_STATS' mutex
; 1378 :            (in multi-threaded applications) so that other threads cannot
; 1379 :            modify the statistics while this function is in progress. */
; 1380 :         int n;  kdu_long max_bytes, cumulative_bytes;
; 1381 :         // Adjust `block_slope_threshold'
; 1382 :         max_bytes = num_coded_samples + conservative_extra_samples;

	mov	edi, DWORD PTR _cumulative_bytes$[ebp+4]
	lea	eax, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR _cumulative_bytes$[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]
	npad	7
$LL4@update_qua:

; 1385 :           if ((cumulative_bytes += quant_slope_rates[n]) >= max_bytes)

	add	edx, DWORD PTR [eax]
	adc	edi, DWORD PTR [eax+4]
	cmp	edi, DWORD PTR _max_bytes$1$[ebp]
	jg	SHORT $LN27@update_qua
	jl	SHORT $LN21@update_qua
	cmp	edx, DWORD PTR _max_bytes$3$[ebp]
	jae	SHORT $LN27@update_qua
$LN21@update_qua:

; 1384 :         for (cumulative_bytes=0, n=max_quant_slope; n >= min_quant_slope; n--)

	dec	ecx
	sub	eax, 8
	cmp	ecx, DWORD PTR [ebx+32808]
	jge	SHORT $LL4@update_qua
$LN27@update_qua:
	mov	edi, DWORD PTR [ebx+32808]
$LN13@update_qua:

; 1388 :         // Adjust `remaining_slope_threshold'
; 1389 :         max_bytes = total_samples;
; 1390 :         max_bytes = 1 + (kdu_long)(max_bytes * target_rate);

	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebx+32816], ecx
	mov	ecx, DWORD PTR [ebx+8]
	call	__ltod3
	mulsd	xmm0, QWORD PTR [ebx]
	call	__dtol3
	add	eax, 1
	mov	ecx, edx
	xorps	xmm0, xmm0
	mov	DWORD PTR _max_bytes$4$[ebp], eax
	adc	ecx, 0

; 1391 :         for (cumulative_bytes=0, n=max_quant_slope; n >= min_quant_slope; n--)

	movlpd	QWORD PTR _cumulative_bytes$[ebp], xmm0
	mov	DWORD PTR _max_bytes$2$[ebp], ecx
	cmp	esi, edi
	jl	SHORT $LN24@update_qua

; 1386 :             break;
; 1387 :         block_slope_threshold = n;

	mov	edx, DWORD PTR _cumulative_bytes$[ebp+4]
	lea	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR _cumulative_bytes$[ebp]
	lea	eax, DWORD PTR [eax+esi*8]
$LL7@update_qua:

; 1392 :           if ((cumulative_bytes += quant_slope_rates[n]) >= max_bytes)

	add	ecx, DWORD PTR [eax]
	adc	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR _max_bytes$2$[ebp]
	jg	SHORT $LN24@update_qua
	jl	SHORT $LN22@update_qua
	cmp	ecx, DWORD PTR _max_bytes$4$[ebp]
	jae	SHORT $LN24@update_qua
$LN22@update_qua:

; 1391 :         for (cumulative_bytes=0, n=max_quant_slope; n >= min_quant_slope; n--)

	dec	esi
	sub	eax, 8
	cmp	esi, edi
	jge	SHORT $LL7@update_qua
$LN24@update_qua:
	pop	edi

; 1393 :             break;
; 1394 :         remaining_slope_threshold = n;

	mov	DWORD PTR [ebx+32820], esi
	pop	esi
	pop	ebx

; 1395 :       }

	mov	esp, ebp
	pop	ebp
	ret	0
?update_quant_slope_thresholds@kd_compressed_stats@@QAEXXZ ENDP ; kd_compressed_stats::update_quant_slope_thresholds
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?update_stats@kd_compressed_stats@@QAE_NAAV1@@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
?update_stats@kd_compressed_stats@@QAE_NAAV1@@Z PROC	; kd_compressed_stats::update_stats, COMDAT
; _this$ = ecx

; 1352 :       { /* Similar to the first version of the `update_stats' function, except

	push	ebp
	mov	ebp, esp
	push	esi

; 1353 :            that the information is copied from the `src' object, returning it
; 1354 :            to the empty state. */
; 1355 :         num_coded_samples += src.num_coded_samples;  src.num_coded_samples = 0;

	mov	esi, DWORD PTR _src$[ebp]
	mov	edx, ecx
	push	edi
	mov	eax, DWORD PTR [esi+32]
	add	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR [esi+36]
	adc	DWORD PTR [edx+36], eax

; 1356 :         if (src.min_quant_slope < this->min_quant_slope)

	mov	eax, DWORD PTR [esi+32808]
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	cmp	eax, DWORD PTR [edx+32808]
	jge	SHORT $LN5@update_sta

; 1357 :           this->min_quant_slope = src.min_quant_slope;

	mov	DWORD PTR [edx+32808], eax
$LN5@update_sta:

; 1358 :         if (src.max_quant_slope > this->max_quant_slope)

	mov	eax, DWORD PTR [esi+32812]
	cmp	eax, DWORD PTR [edx+32812]
	jle	SHORT $LN6@update_sta

; 1359 :           this->max_quant_slope = src.max_quant_slope;

	mov	DWORD PTR [edx+32812], eax
$LN6@update_sta:

; 1360 :         for (int n=src.min_quant_slope; n <= src.max_quant_slope; n++)

	mov	edi, DWORD PTR [esi+32808]
	cmp	edi, DWORD PTR [esi+32812]
	jg	SHORT $LN3@update_sta
	push	ebx
	lea	ecx, DWORD PTR [esi+40]
	mov	ebx, edx
	lea	ecx, DWORD PTR [ecx+edi*8]
	sub	ebx, esi
$LL4@update_sta:

; 1361 :           { quant_slope_rates[n] += src.quant_slope_rates[n];

	mov	eax, DWORD PTR [ecx]
	add	DWORD PTR [ebx+ecx], eax
	mov	eax, DWORD PTR [ecx+4]
	adc	DWORD PTR [ebx+ecx+4], eax
	inc	edi

; 1362 :             src.quant_slope_rates[n] = 0; }

	mov	DWORD PTR [ecx], 0
	lea	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx-4], 0
	cmp	edi, DWORD PTR [esi+32812]
	jle	SHORT $LL4@update_sta
	pop	ebx
$LN3@update_sta:

; 1363 :         src.min_quant_slope = 4095;  src.max_quant_slope = 0;

	mov	DWORD PTR [esi+32808], 4095		; 00000fffH
	mov	DWORD PTR [esi+32812], 0

; 1364 :         if (trimming_enabled && (num_coded_samples > next_trim))

	cmp	BYTE PTR [edx+32824], 0
	je	SHORT $LN7@update_sta
	mov	edi, DWORD PTR [edx+20]
	mov	esi, DWORD PTR [edx+16]
	cmp	DWORD PTR [edx+36], edi
	jl	SHORT $LN7@update_sta
	jg	SHORT $LN13@update_sta
	cmp	DWORD PTR [edx+32], esi
	jbe	SHORT $LN7@update_sta
$LN13@update_sta:

; 1365 :           { next_trim += (total_samples+7)>>4; return true; }

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+12]
	add	ecx, 7
	adc	eax, 0
	shrd	ecx, eax, 4
	sar	eax, 4
	add	ecx, esi
	mov	DWORD PTR [edx+16], ecx
	adc	eax, edi
	pop	edi
	mov	DWORD PTR [edx+20], eax
	mov	al, 1
	pop	esi

; 1367 :       }

	pop	ebp
	ret	4
$LN7@update_sta:
	pop	edi

; 1366 :         return false;

	xor	al, al
	pop	esi

; 1367 :       }

	pop	ebp
	ret	4
?update_stats@kd_compressed_stats@@QAE_NAAV1@@Z ENDP	; kd_compressed_stats::update_stats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?is_empty@kd_compressed_stats@@QAE_NXZ
_TEXT	SEGMENT
?is_empty@kd_compressed_stats@@QAE_NXZ PROC		; kd_compressed_stats::is_empty, COMDAT
; _this$ = ecx

; 1325 :     bool is_empty() { return (num_coded_samples == 0); }

	mov	eax, DWORD PTR [ecx+32]
	or	eax, DWORD PTR [ecx+36]
	jne	SHORT $LN3@is_empty
	mov	al, 1
	ret	0
$LN3@is_empty:
	xor	al, al
	ret	0
?is_empty@kd_compressed_stats@@QAE_NXZ ENDP		; kd_compressed_stats::is_empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?init@kd_compressed_stats@@QAEXXZ
_TEXT	SEGMENT
?init@kd_compressed_stats@@QAEXXZ PROC			; kd_compressed_stats::init, COMDAT
; _this$ = ecx

; 1316 :       {

	mov	eax, ecx
	xorps	xmm0, xmm0
	push	esi
	push	edi

; 1317 :         total_samples=num_coded_samples=conservative_extra_samples=next_trim=0;

	lea	edi, DWORD PTR [eax+40]

; 1318 :         target_rate = 0.0;
; 1319 :         min_quant_slope = 4095; max_quant_slope = 0;
; 1320 :         block_slope_threshold = remaining_slope_threshold = 0;
; 1321 :         for (int n=0; n < 4096; n++)
; 1322 :           quant_slope_rates[n] = 0;

	mov	ecx, 8190				; 00001ffeH
	mov	DWORD PTR [eax+16], 0
	mov	esi, edi
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+24], 0
	mov	DWORD PTR [eax+28], 0
	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+36], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	movsd	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+32808], 4095		; 00000fffH
	mov	DWORD PTR [eax+32812], 0
	mov	DWORD PTR [eax+32820], 0
	mov	DWORD PTR [eax+32816], 0
	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0
	add	edi, 8
	rep movsd
	pop	edi

; 1323 :         trimming_enabled = false;

	mov	BYTE PTR [eax+32824], 0
	pop	esi

; 1324 :       }

	ret	0
?init@kd_compressed_stats@@QAEXXZ ENDP			; kd_compressed_stats::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_compressed_stats@@QAE@_J0_N@Z
_TEXT	SEGMENT
tv84 = 8						; size = 8
_total_samples$ = 8					; size = 8
_target_bytes$ = 16					; size = 8
_enable_trimming$ = 24					; size = 1
??0kd_compressed_stats@@QAE@_J0_N@Z PROC		; kd_compressed_stats::kd_compressed_stats, COMDAT
; _this$ = ecx

; 1304 :     kd_compressed_stats(kdu_long total_samples, kdu_long target_bytes,

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 1305 :                         bool enable_trimming)
; 1306 :       {
; 1307 :         init();

	call	?init@kd_compressed_stats@@QAEXXZ	; kd_compressed_stats::init

; 1308 :         this->total_samples = total_samples;

	mov	edi, DWORD PTR _total_samples$[ebp]

; 1309 :         next_trim = (total_samples+7) >> 3;

	mov	ecx, edi
	mov	ebx, DWORD PTR _total_samples$[ebp+4]
	add	ecx, 7
	mov	eax, ebx
	mov	DWORD PTR [esi+8], edi
	adc	eax, 0
	mov	DWORD PTR [esi+12], ebx
	shrd	ecx, eax, 3
	sar	eax, 3
	mov	DWORD PTR [esi+20], eax

; 1310 :         conservative_extra_samples = 4096 + (total_samples>>4);

	mov	eax, edi
	mov	DWORD PTR [esi+16], ecx
	mov	ecx, ebx
	shrd	eax, ecx, 4
	sar	ecx, 4
	add	eax, 4096				; 00001000H
	mov	DWORD PTR [esi+24], eax

; 1311 :         target_rate =

	mov	eax, edi
	adc	ecx, 0
	or	eax, ebx
	mov	DWORD PTR [esi+28], ecx
	jne	SHORT $LN3@kd_compres
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	jmp	SHORT $LN4@kd_compres
$LN3@kd_compres:
	mov	edx, DWORD PTR _target_bytes$[ebp+4]
	mov	ecx, DWORD PTR _target_bytes$[ebp]
	call	__ltod3
	mov	edx, ebx
	movsd	QWORD PTR tv84[ebp], xmm0
	mov	ecx, edi
	call	__ltod3
	movsd	xmm1, QWORD PTR tv84[ebp]
	divsd	xmm1, xmm0
$LN4@kd_compres:

; 1312 :           (total_samples==0)?1.0:(((double) target_bytes)/total_samples);
; 1313 :         this->trimming_enabled = enable_trimming;

	mov	al, BYTE PTR _enable_trimming$[ebp]
	mov	BYTE PTR [esi+32824], al

; 1314 :       }

	mov	eax, esi
	pop	edi
	movsd	QWORD PTR [esi], xmm1
	pop	esi
	pop	ebx
	pop	ebp
	ret	20					; 00000014H
??0kd_compressed_stats@@QAE@_J0_N@Z ENDP		; kd_compressed_stats::kd_compressed_stats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_compressed_stats@@QAE@XZ
_TEXT	SEGMENT
??0kd_compressed_stats@@QAE@XZ PROC			; kd_compressed_stats::kd_compressed_stats, COMDAT
; _this$ = ecx

; 1303 :     kd_compressed_stats() { init(); }

	push	esi
	mov	esi, ecx
	call	?init@kd_compressed_stats@@QAEXXZ	; kd_compressed_stats::init
	mov	eax, esi
	pop	esi
	ret	0
??0kd_compressed_stats@@QAE@XZ ENDP			; kd_compressed_stats::kd_compressed_stats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?retrieve_byte@kd_precinct_pointer_server@@AAEEXZ
_TEXT	SEGMENT
?retrieve_byte@kd_precinct_pointer_server@@AAEEXZ PROC	; kd_precinct_pointer_server::retrieve_byte, COMDAT
; _this$ = ecx

; 1249 :       { // Call to retrieve a byte of encoded precinct length info.

	push	esi
	mov	esi, ecx

; 1250 :         assert((head != tail) || (head_pos < tail_pos));
; 1251 :         if (head_pos == KD_CODE_BUFFER_LEN)

	cmp	DWORD PTR [esi+12], 58			; 0000003aH
	jne	SHORT $LN2@retrieve_b

; 1252 :           { kd_code_buffer *tmp = head; head=head->next; head_pos = 0;

	mov	edx, DWORD PTR [esi+4]

; 1253 :             buf_server->release(tmp); }

	mov	ecx, DWORD PTR [esi]
	push	edx
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+12], 0
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
$LN2@retrieve_b:

; 1254 :         return head->buf[head_pos++];

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi+4]
	mov	al, BYTE PTR [eax+ecx+6]
	inc	ecx
	mov	DWORD PTR [esi+12], ecx
	pop	esi

; 1255 :       }

	ret	0
?retrieve_byte@kd_precinct_pointer_server@@AAEEXZ ENDP	; kd_precinct_pointer_server::retrieve_byte
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?record_byte@kd_precinct_pointer_server@@AAEXE@Z
_TEXT	SEGMENT
_val$ = 8						; size = 1
?record_byte@kd_precinct_pointer_server@@AAEXE@Z PROC	; kd_precinct_pointer_server::record_byte, COMDAT
; _this$ = ecx

; 1242 :       { // Call to record a byte of encoded precinct length info.

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1243 :         assert(tail != NULL);
; 1244 :         if (tail_pos == KD_CODE_BUFFER_LEN)

	cmp	DWORD PTR [esi+16], 58			; 0000003aH
	jne	SHORT $LN2@record_byt

; 1245 :           { tail=tail->next=buf_server->get(); tail_pos = 0; }

	mov	ecx, DWORD PTR [esi]
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+16], 0
$LN2@record_byt:

; 1246 :         tail->buf[tail_pos++] = val;

	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+8]
	mov	al, BYTE PTR _val$[ebp]
	mov	BYTE PTR [edx+ecx+6], al
	inc	DWORD PTR [esi+16]
	pop	esi

; 1247 :       }

	pop	ebp
	ret	4
?record_byte@kd_precinct_pointer_server@@AAEXE@Z ENDP	; kd_precinct_pointer_server::record_byte
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?initialize_recording@kd_precinct_pointer_server@@AAEXXZ
_TEXT	SEGMENT
?initialize_recording@kd_precinct_pointer_server@@AAEXXZ PROC ; kd_precinct_pointer_server::initialize_recording, COMDAT
; _this$ = ecx

; 1237 :       { // Call before parsing the first PLT marker segment.

	push	esi
	mov	esi, ecx

; 1238 :         assert((buf_server != NULL) && (head == NULL));
; 1239 :         head = tail = buf_server->get();

	mov	ecx, DWORD PTR [esi]
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+4], eax
	pop	esi

; 1240 :       }

	ret	0
?initialize_recording@kd_precinct_pointer_server@@AAEXXZ ENDP ; kd_precinct_pointer_server::initialize_recording
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?disable@kd_precinct_pointer_server@@AAEXXZ
_TEXT	SEGMENT
?disable@kd_precinct_pointer_server@@AAEXXZ PROC	; kd_precinct_pointer_server::disable, COMDAT
; _this$ = ecx

; 1230 :       { // Call to discard contents and cease recording new PLT info.

	push	esi
	mov	esi, ecx

; 1231 :         if (buf_server == NULL) return;

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN1@disable

; 1232 :         while ((tail=head) != NULL)

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], eax
	test	eax, eax
	je	SHORT $LN3@disable
$LL2@disable:

; 1233 :           { head = tail->next; buf_server->release(tail); }

	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+4], eax
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], eax
	test	eax, eax
	jne	SHORT $LL2@disable
$LN3@disable:

; 1234 :         buf_server = NULL;

	mov	DWORD PTR [esi], 0
$LN1@disable:
	pop	esi

; 1235 :       }

	ret	0
?disable@kd_precinct_pointer_server@@AAEXXZ ENDP	; kd_precinct_pointer_server::disable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?pop_address@kd_precinct_pointer_server@@AAE_JXZ
_TEXT	SEGMENT
_e$2 = -64						; size = 20
_e$3 = -44						; size = 20
_new_length$ = -24					; size = 8
_new_length$1$ = -20					; size = 4
_new_length$2$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?pop_address@kd_precinct_pointer_server@@AAE_JXZ PROC	; kd_precinct_pointer_server::pop_address, COMDAT
; _this$ = ecx

; 1764 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?pop_address@kd_precinct_pointer_server@@AAE_JXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1765 :   if (buf_server == NULL)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN5@pop_addres

; 1766 :     return 0;

	xor	eax, eax
	xor	edx, edx

; 1813 :   return result;
; 1814 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@pop_addres:

; 1767 :   if ((available_addresses == 0) &&

	cmp	DWORD PTR [esi+20], 0
	jne	SHORT $LN6@pop_addres
	cmp	BYTE PTR [esi+36], 0
	jne	SHORT $LN7@pop_addres
	cmp	DWORD PTR [esi+32], 0
	je	SHORT $LN27@pop_addres
$LN7@pop_addres:

; 1772 :       KDU_ERROR(e,22); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BBI@KLDFJIGH@Unexpectedly?5ran?5out?5of?5packet?5l@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1772 :       KDU_ERROR(e,22); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1778 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN6@pop_addres:

; 1779 :   if ((tpart_bytes_left == 0) && !final_tpart_with_unknown_length)

	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN8@pop_addres
$LN27@pop_addres:
	cmp	BYTE PTR [esi+36], 0
	jne	SHORT $LN8@pop_addres

; 1780 :     return -1;

	or	eax, -1
	or	edx, eax

; 1813 :   return result;
; 1814 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@pop_addres:
	xorps	xmm0, xmm0

; 1781 : 
; 1782 :   kdu_long new_length = 0;

	movlpd	QWORD PTR _new_length$[ebp], xmm0
	mov	ebx, DWORD PTR _new_length$[ebp+4]
	mov	edi, DWORD PTR _new_length$[ebp]
	mov	DWORD PTR _new_length$2$[ebp], ebx
	npad	4
$LL4@pop_addres:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1251 :         if (head_pos == KD_CODE_BUFFER_LEN)

	cmp	DWORD PTR [esi+12], 58			; 0000003aH
	jne	SHORT $LN17@pop_addres

; 1252 :           { kd_code_buffer *tmp = head; head=head->next; head_pos = 0;

	mov	ecx, DWORD PTR [esi+4]

; 1253 :             buf_server->release(tmp); }

	push	ecx
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+12], 0
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
$LN17@pop_addres:

; 1254 :         return head->buf[head_pos++];

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi+4]
	mov	bl, BYTE PTR [eax+ecx+6]
	lea	eax, DWORD PTR [ecx+1]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1786 :       new_length = (new_length << 7) + (kdu_long)(byte & 0x7F);

	mov	ecx, DWORD PTR _new_length$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1254 :         return head->buf[head_pos++];

	mov	DWORD PTR [esi+12], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1786 :       new_length = (new_length << 7) + (kdu_long)(byte & 0x7F);

	mov	al, bl
	and	al, 127					; 0000007fH
	shld	ecx, edi, 7
	movzx	eax, al
	cdq
	shl	edi, 7
	add	edi, eax
	adc	edx, ecx
	mov	eax, edx
	mov	DWORD PTR _new_length$2$[ebp], eax

; 1787 :     } while (byte & 0x80);

	test	bl, bl
	js	SHORT $LL4@pop_addres

; 1788 :   available_addresses--;

	dec	DWORD PTR [esi+20]

; 1789 :   if (final_tpart_with_unknown_length)

	cmp	BYTE PTR [esi+36], 0
	mov	DWORD PTR _new_length$1$[ebp], edi
	jne	SHORT $LN28@pop_addres

; 1790 :     {
; 1791 :       something_served = true;
; 1792 :       kdu_long result = next_address;
; 1793 :       next_address += new_length;
; 1794 :       return result;
; 1795 :     }
; 1796 : 
; 1797 :   if (new_length > (kdu_long) tpart_bytes_left)

	test	eax, eax
	jl	SHORT $LN10@pop_addres
	jg	SHORT $LN24@pop_addres
	cmp	edi, DWORD PTR [esi+32]
	jbe	SHORT $LN10@pop_addres
$LN24@pop_addres:

; 1798 :     { KDU_ERROR(e,23); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0CCA@PJBKNCFI@Tile?9part?5holds?5some?5but?5not?5all@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1798 :     { KDU_ERROR(e,23); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1808 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN10@pop_addres:

; 1809 :   tpart_bytes_left -= (kdu_uint32) new_length;

	sub	DWORD PTR [esi+32], edi
$LN28@pop_addres:

; 1810 :   something_served = true;
; 1811 :   kdu_long result = next_address;

	mov	eax, DWORD PTR [esi+24]

; 1812 :   next_address += new_length;

	mov	edi, eax
	mov	edx, DWORD PTR [esi+28]
	mov	ecx, edx
	add	edi, DWORD PTR _new_length$1$[ebp]
	mov	DWORD PTR [esi+24], edi
	adc	ecx, DWORD PTR _new_length$2$[ebp]
	mov	DWORD PTR [esi+28], ecx
	mov	BYTE PTR [esi+44], 1

; 1813 :   return result;
; 1814 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?pop_address@kd_precinct_pointer_server@@AAE_JXZ$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?pop_address@kd_precinct_pointer_server@@AAE_JXZ$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?pop_address@kd_precinct_pointer_server@@AAE_JXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?pop_address@kd_precinct_pointer_server@@AAE_JXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?pop_address@kd_precinct_pointer_server@@AAE_JXZ ENDP	; kd_precinct_pointer_server::pop_address
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_precinct_address@kd_precinct_pointer_server@@QAE_JXZ
_TEXT	SEGMENT
tv68 = -8						; size = 8
?get_precinct_address@kd_precinct_pointer_server@@QAE_JXZ PROC ; kd_precinct_pointer_server::get_precinct_address, COMDAT
; _this$ = ecx

; 1210 :       { return ((buf_server==NULL)?((kdu_long) 0):pop_address()); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN3@get_precin
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv68[ebp], xmm0
	mov	eax, DWORD PTR tv68[ebp]
	mov	edx, DWORD PTR tv68[ebp+4]
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@get_precin:
	call	?pop_address@kd_precinct_pointer_server@@AAE_JXZ ; kd_precinct_pointer_server::pop_address
	mov	esp, ebp
	pop	ebp
	ret	0
?get_precinct_address@kd_precinct_pointer_server@@QAE_JXZ ENDP ; kd_precinct_pointer_server::get_precinct_address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z
_TEXT	SEGMENT
_e$2 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_start_address$ = 8					; size = 8
_ival$ = 16						; size = 4
_length$ = 16						; size = 4
_cod$ = 20						; size = 4
_poc$ = 24						; size = 4
_order_val$ = 28					; size = 4
_packed_headers$ = 28					; size = 1
_layer_val$ = 32					; size = 4
_final_tpart_with_unknown_length$ = 32			; size = 1
?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z PROC ; kd_precinct_pointer_server::start_tpart_body, COMDAT
; _this$ = ecx

; 1723 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1724 :   next_znum = 0;
; 1725 :   if ((buf_server == NULL) ||

	cmp	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+45], 0
	je	$LN3@start_tpar
	mov	edi, DWORD PTR _length$[ebp]
	mov	bl, BYTE PTR _final_tpart_with_unknown_length$[ebp]
	test	edi, edi
	jne	SHORT $LN2@start_tpar
	test	bl, bl
	je	$LN3@start_tpar
$LN2@start_tpar:

; 1726 :       ((length == 0) && !final_tpart_with_unknown_length))
; 1727 :     return;
; 1728 :   if ((head == NULL) && !something_served)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN4@start_tpar
	cmp	BYTE PTR [esi+44], 0
	jne	SHORT $LN4@start_tpar

; 1729 :     { // There is no PLT information available and the tile-part is non-empty
; 1730 :       disable();

	call	?disable@kd_precinct_pointer_server@@AAEXXZ ; kd_precinct_pointer_server::disable

; 1756 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN4@start_tpar:

; 1731 :       return;
; 1732 :     }
; 1733 : 
; 1734 :   int ival, layer_val, order_val;
; 1735 :   if (packed_headers ||
; 1736 :       (!cod->get(Clayers,0,0,layer_val)) ||
; 1737 :       (layer_val != num_layers) ||

	cmp	BYTE PTR _packed_headers$[ebp], 0
	jne	SHORT $LN7@start_tpar
	mov	ecx, DWORD PTR _cod$[ebp]
	lea	eax, DWORD PTR _layer_val$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BJCMAMHC@Clayers?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN7@start_tpar
	mov	eax, DWORD PTR [esi+40]
	cmp	DWORD PTR _layer_val$[ebp], eax
	jne	SHORT $LN7@start_tpar
	cmp	eax, 1
	jle	$LN8@start_tpar
	mov	ecx, DWORD PTR _poc$[ebp]
	lea	eax, DWORD PTR _ival$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN7@start_tpar
	mov	ecx, DWORD PTR _cod$[ebp]
	lea	eax, DWORD PTR _order_val$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06IKJBDDKO@Corder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN7@start_tpar
	mov	eax, DWORD PTR _order_val$[ebp]
	test	eax, eax
	je	SHORT $LN7@start_tpar
	cmp	eax, 1
	jne	SHORT $LN8@start_tpar
$LN7@start_tpar:

; 1738 :       ((num_layers > 1) &&
; 1739 :        (poc->get(Porder,0,0,ival) ||
; 1740 :         (!cod->get(Corder,0,0,order_val)) || (order_val == Corder_LRCP) ||
; 1741 :         (order_val == Corder_RLCP))))
; 1742 :     { // Cannot use PLT information
; 1743 :       disable();

	mov	ecx, esi
	call	?disable@kd_precinct_pointer_server@@AAEXXZ ; kd_precinct_pointer_server::disable

; 1744 :       if (something_served)

	cmp	BYTE PTR [esi+44], 0
	je	SHORT $LN8@start_tpar

; 1745 :         { KDU_ERROR(e,21); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BAD@MAAGNDO@Unexpected?5change?5in?5coding?5para@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1745 :         { KDU_ERROR(e,21); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1751 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN8@start_tpar:

; 1752 :     }
; 1753 :   next_address = start_address;

	mov	eax, DWORD PTR _start_address$[ebp]
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR _start_address$[ebp+4]
	mov	DWORD PTR [esi+28], eax

; 1754 :   tpart_bytes_left = length;

	mov	DWORD PTR [esi+32], edi

; 1755 :   this->final_tpart_with_unknown_length = final_tpart_with_unknown_length;

	mov	BYTE PTR [esi+36], bl
$LN3@start_tpar:

; 1756 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z ENDP ; kd_precinct_pointer_server::start_tpart_body
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z
_TEXT	SEGMENT
_e$2 = -80						; size = 20
_e$3 = -60						; size = 20
_e$4 = -60						; size = 20
_e$5 = -60						; size = 20
_packet_length$6 = -40					; size = 8
_ival$ = -32						; size = 4
_this$1$ = -28						; size = 4
_order_val$ = -24					; size = 4
_layer_val$ = -20					; size = 4
_data$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_length$1$ = 8						; size = 4
_marker$ = 8						; size = 4
_cod$ = 12						; size = 4
_poc$ = 16						; size = 4
?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z PROC ; kd_precinct_pointer_server::add_plt_marker, COMDAT
; _this$ = ecx

; 1628 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi

; 1629 :   if (buf_server == NULL)

	cmp	DWORD PTR [esi], 0
	je	$LN22@add_plt_ma
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	eax, DWORD PTR _marker$[ebp]

; 884  :     int get_length() { return length; }

	mov	edi, DWORD PTR [eax+12]

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	ebx, DWORD PTR [eax+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1633 :   if ((length < 1) || (data[0] != next_znum))

	cmp	edi, 1
	jl	SHORT $LN14@add_plt_ma
	mov	al, BYTE PTR [ebx]
	cmp	al, BYTE PTR [esi+45]
	je	SHORT $LN13@add_plt_ma
$LN14@add_plt_ma:

; 1634 :     { KDU_ERROR(e,17); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0BDH@HFCLMIKM@PLT?5marker?5segments?5appear?5out?5o@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1634 :     { KDU_ERROR(e,17); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1641 :     }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN13@add_plt_ma:

; 1642 :   next_znum++; data++; length--;

	inc	BYTE PTR [esi+45]
	inc	ebx
	dec	edi
	mov	DWORD PTR _data$1$[ebp], ebx

; 1643 :   if (tpart_bytes_left > 0)

	cmp	DWORD PTR [esi+32], 0
	mov	DWORD PTR _length$1$[ebp], edi
	jbe	SHORT $LN15@add_plt_ma

; 1644 :     { KDU_ERROR(e,18); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0BFL@CANGKIAI@There?5appears?5to?5be?5a?5problem?5wi@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1644 :     { KDU_ERROR(e,18); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1651 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN15@add_plt_ma:

; 1652 : 
; 1653 :   int ival, layer_val, order_val;
; 1654 :   if (!(cod->get(Clayers,0,0,layer_val) && cod->get(Corder,0,0,order_val)))

	mov	ebx, DWORD PTR _cod$[ebp]
	lea	eax, DWORD PTR _layer_val$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BJCMAMHC@Clayers?$AA@
	mov	ecx, ebx
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN17@add_plt_ma
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _order_val$[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06IKJBDDKO@Corder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN17@add_plt_ma:

; 1655 :     assert(0);
; 1656 :   if (num_layers == 0)

	cmp	DWORD PTR [esi+40], 0
	mov	eax, DWORD PTR _layer_val$[ebp]
	jne	SHORT $LN18@add_plt_ma

; 1657 :     num_layers = layer_val;

	mov	DWORD PTR [esi+40], eax
$LN18@add_plt_ma:

; 1658 :   if ((num_layers != layer_val) ||

	mov	ecx, DWORD PTR [esi+40]
	cmp	ecx, eax
	jne	$LN21@add_plt_ma
	cmp	ecx, 1
	jle	SHORT $LN19@add_plt_ma
	mov	eax, DWORD PTR _order_val$[ebp]
	test	eax, eax
	je	$LN21@add_plt_ma
	cmp	eax, 1
	je	$LN21@add_plt_ma
	mov	ecx, DWORD PTR _poc$[ebp]
	lea	eax, DWORD PTR _ival$[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06NMKHLFPN@Porder?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LN21@add_plt_ma
$LN19@add_plt_ma:

; 1672 :       return;
; 1673 :     }
; 1674 :   if (head == NULL)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN50@add_plt_ma
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1239 :         head = tail = buf_server->get();

	mov	ecx, DWORD PTR [esi]
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+4], eax
$LN50@add_plt_ma:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1677 :   while (length > 0)

	test	edi, edi
	jle	$LN22@add_plt_ma
$LL2@add_plt_ma:

; 1678 :     {
; 1679 :       if (packets_left_in_precinct == 0)

	cmp	DWORD PTR [esi+56], 0
	jne	SHORT $LN24@add_plt_ma

; 1680 :         { packets_left_in_precinct = num_layers; precinct_length = 0; }

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
$LN24@add_plt_ma:

; 1681 :       kdu_long packet_length = 0;

	mov	esi, DWORD PTR _length$1$[ebp]
	xorps	xmm0, xmm0
	movlpd	QWORD PTR _packet_length$6[ebp], xmm0
	mov	ebx, DWORD PTR _packet_length$6[ebp+4]
	mov	edi, DWORD PTR _packet_length$6[ebp]
$LL6@add_plt_ma:

; 1682 :       kdu_byte byte;
; 1683 :       do {
; 1684 :           if (length == 0)

	test	esi, esi
	jne	SHORT $LN25@add_plt_ma

; 1685 :             { KDU_ERROR(e,20); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0JE@NAFKBLL@Malformed?5PLT?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1685 :             { KDU_ERROR(e,20); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1690 :             }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN25@add_plt_ma:

; 1691 :           byte = *(data++); length--;

	mov	eax, DWORD PTR _data$1$[ebp]
	dec	esi

; 1692 :           packet_length = (packet_length<<7) + (kdu_long)(byte & 0x7F);

	shld	ebx, edi, 7
	shl	edi, 7
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR _data$1$[ebp], eax
	mov	al, cl
	and	al, 127					; 0000007fH
	movzx	eax, al
	cdq
	add	edi, eax
	adc	ebx, edx

; 1693 :         } while (byte & 0x80);

	test	cl, cl
	js	SHORT $LL6@add_plt_ma

; 1694 :       precinct_length += packet_length;

	mov	DWORD PTR _length$1$[ebp], esi
	mov	esi, DWORD PTR _this$1$[ebp]
	add	DWORD PTR [esi+48], edi
	adc	DWORD PTR [esi+52], ebx

; 1695 :       packets_left_in_precinct--;

	add	DWORD PTR [esi+56], -1

; 1696 :       if (packets_left_in_precinct == 0)

	jne	$LN26@add_plt_ma

; 1697 :         { // Record new precinct length using the same byte extension code.
; 1698 :           int shift = 0;
; 1699 :           while ((precinct_length >> shift) >= 128)

	mov	ecx, DWORD PTR [esi+52]
	xor	edi, edi
	mov	ebx, DWORD PTR [esi+48]
	test	ecx, ecx
	jl	SHORT $LL64@add_plt_ma
	jg	SHORT $LL7@add_plt_ma
	cmp	ebx, 128				; 00000080H
	jb	SHORT $LL64@add_plt_ma
$LL7@add_plt_ma:

; 1700 :             shift += 7;

	add	edi, 7
	mov	edx, ecx
	mov	eax, ebx
	mov	ecx, edi
	call	__allshr
	mov	ecx, DWORD PTR [esi+52]
	test	edx, edx
	jg	SHORT $LL7@add_plt_ma

; 1697 :         { // Record new precinct length using the same byte extension code.
; 1698 :           int shift = 0;
; 1699 :           while ((precinct_length >> shift) >= 128)

	jl	SHORT $LN67@add_plt_ma
	cmp	eax, 128				; 00000080H
	jae	SHORT $LL7@add_plt_ma
$LN67@add_plt_ma:

; 1701 :           for (; shift >= 0; shift -= 7)

	test	edi, edi
	js	SHORT $LN10@add_plt_ma
$LL64@add_plt_ma:

; 1702 :             {
; 1703 :               byte = (kdu_byte)(precinct_length >> shift);

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, edi
	mov	edx, DWORD PTR [esi+52]
	call	__allshr
	mov	bl, al

; 1704 :               byte &= 0x7F;

	and	bl, 127					; 0000007fH

; 1705 :               if (shift > 0)

	test	edi, edi
	jle	SHORT $LN27@add_plt_ma

; 1706 :                 byte |= 0x80;

	or	bl, 128					; 00000080H
$LN27@add_plt_ma:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1244 :         if (tail_pos == KD_CODE_BUFFER_LEN)

	cmp	DWORD PTR [esi+16], 58			; 0000003aH
	jne	SHORT $LN48@add_plt_ma

; 1245 :           { tail=tail->next=buf_server->get(); tail_pos = 0; }

	mov	ecx, DWORD PTR [esi]
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+16], 0
$LN48@add_plt_ma:

; 1246 :         tail->buf[tail_pos++] = val;

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+8]
	mov	BYTE PTR [ecx+eax+6], bl
	inc	DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1701 :           for (; shift >= 0; shift -= 7)

	sub	edi, 7
	jns	SHORT $LL64@add_plt_ma
$LN10@add_plt_ma:

; 1707 :               record_byte(byte);
; 1708 :             }
; 1709 :           available_addresses++;

	inc	DWORD PTR [esi+20]
$LN26@add_plt_ma:

; 1677 :   while (length > 0)

	mov	edi, DWORD PTR _length$1$[ebp]
	test	edi, edi
	jg	$LL2@add_plt_ma

; 1710 :         }
; 1711 :     }
; 1712 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN21@add_plt_ma:

; 1659 :       ((num_layers > 1) &&
; 1660 :        ((order_val == Corder_LRCP) || (order_val == Corder_RLCP) ||
; 1661 :         poc->get(Porder,0,0,ival))))
; 1662 :     { // PLT information is unusable.
; 1663 :       disable();

	mov	ecx, esi
	call	?disable@kd_precinct_pointer_server@@AAEXXZ ; kd_precinct_pointer_server::disable

; 1664 :       if (something_served)

	cmp	BYTE PTR [esi+44], 0
	je	SHORT $LN22@add_plt_ma

; 1665 :         { KDU_ERROR(e,19); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BAD@EAIFLCLN@Unexpected?5change?5in?5coding?5para@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1665 :         { KDU_ERROR(e,19); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1671 :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN22@add_plt_ma:

; 1710 :         }
; 1711 :     }
; 1712 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z$0:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z$1:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z$3:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z$2:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z ENDP ; kd_precinct_pointer_server::add_plt_marker
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_tpart_pointer_server@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_tpart_pointer_server@@QAEPAXI@Z PROC		; kd_tpart_pointer_server::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_tpart_pointer_server@@QAE@XZ	; kd_tpart_pointer_server::~kd_tpart_pointer_server
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	16					; 00000010H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_tpart_pointer_server@@QAEPAXI@Z ENDP		; kd_tpart_pointer_server::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Gkd_tlm_marker_list@kd_tpart_pointer_server@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_tlm_marker_list@kd_tpart_pointer_server@@QAEPAXI@Z PROC ; kd_tpart_pointer_server::kd_tlm_marker_list::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN8@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN11@scalar
	push	36					; 00000024H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN11@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_tlm_marker_list@kd_tpart_pointer_server@@QAEPAXI@Z ENDP ; kd_tpart_pointer_server::kd_tlm_marker_list::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_tlm_marker_list@kd_tpart_pointer_server@@QAE@XZ
_TEXT	SEGMENT
??1kd_tlm_marker_list@kd_tpart_pointer_server@@QAE@XZ PROC ; kd_tpart_pointer_server::kd_tlm_marker_list::~kd_tlm_marker_list, COMDAT
; _this$ = ecx

; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN4@kd_tlm_mar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN4@kd_tlm_mar:
	ret	0
??1kd_tlm_marker_list@kd_tpart_pointer_server@@QAE@XZ ENDP ; kd_tpart_pointer_server::kd_tlm_marker_list::~kd_tlm_marker_list
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_tlm_marker_list@kd_tpart_pointer_server@@QAE@AAVkd_marker@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_copy_source$ = 8					; size = 4
??0kd_tlm_marker_list@kd_tpart_pointer_server@@QAE@AAVkd_marker@@@Z PROC ; kd_tpart_pointer_server::kd_tlm_marker_list::kd_tlm_marker_list, COMDAT
; _this$ = ecx

; 1119 :             { next = NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 1118 :           kd_tlm_marker_list(kd_marker &copy_source) : kd_marker(copy_source)

	push	DWORD PTR _copy_source$[ebp]

; 1119 :             { next = NULL; }

	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	call	??0kd_marker@@QAE@ABV0@@Z		; kd_marker::kd_marker
	mov	DWORD PTR [esi+28], 0
	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0kd_tlm_marker_list@kd_tpart_pointer_server@@QAE@AAVkd_marker@@@Z ENDP ; kd_tpart_pointer_server::kd_tlm_marker_list::kd_tlm_marker_list
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?add_tpart@kd_tpart_pointer_server@@QAEXPAUkd_tile_ref@@_J@Z
_TEXT	SEGMENT
_tile_ref$ = 8						; size = 4
_sot_address$ = 12					; size = 8
?add_tpart@kd_tpart_pointer_server@@QAEXPAUkd_tile_ref@@_J@Z PROC ; kd_tpart_pointer_server::add_tpart, COMDAT
; _this$ = ecx

; 1504 : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	edi, ecx

; 1505 :   kd_tpart_pointer *elt = free_list;

	mov	edx, DWORD PTR [edi+8]

; 1506 :   if (elt == NULL)

	test	edx, edx
	jne	SHORT $LN5@add_tpart

; 1507 :     { // Allocate new group of pointer structures and put on free list
; 1508 :       kd_pointer_group *grp = new kd_pointer_group;

	push	esi
	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new

; 1509 :       grp->next = groups;

	mov	ecx, DWORD PTR [edi+4]
	mov	edx, eax
	add	esp, 4

; 1510 :       groups = grp;
; 1511 :       elt = grp->elements;
; 1512 :       for (int g=KD_POINTER_GROUP_SIZE-1; g > 0; g--, elt++)

	mov	esi, 31					; 0000001fH
	mov	DWORD PTR [edx+512], ecx
	mov	ecx, edx
	mov	DWORD PTR [edi+4], edx
$LL4@add_tpart:
	lea	eax, DWORD PTR [ecx+16]
	dec	esi

; 1513 :         elt->next = elt+1;

	mov	DWORD PTR [ecx+8], eax
	mov	ecx, eax
	test	esi, esi
	jg	SHORT $LL4@add_tpart

; 1514 :       elt->next = free_list;

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [ecx+8], eax

; 1515 :       free_list = elt = grp->elements;

	mov	DWORD PTR [edi+8], edx
	pop	esi
$LN5@add_tpart:

; 1516 :     }
; 1517 :   free_list = elt->next;

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [edi+8], eax

; 1518 :   elt->next = NULL;
; 1519 :   elt->address = sot_address;

	mov	eax, DWORD PTR _sot_address$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _sot_address$[ebp+4]
	mov	DWORD PTR [edx+4], eax

; 1520 :   if (tile_ref->tpart_head == NULL)

	mov	eax, DWORD PTR _tile_ref$[ebp]
	mov	DWORD PTR [edx+8], 0
	pop	edi
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN6@add_tpart

; 1521 :     tile_ref->tpart_head = tile_ref->tpart_tail = elt;

	mov	DWORD PTR [eax], edx

; 1523 :     tile_ref->tpart_tail = tile_ref->tpart_tail->next = elt;

	mov	DWORD PTR [eax+4], edx

; 1524 :   else
; 1525 :     assert(0);
; 1526 : }

	pop	ebp
	ret	12					; 0000000cH
$LN6@add_tpart:

; 1522 :   else if (tile_ref->tpart_tail != NULL)

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN8@add_tpart

; 1523 :     tile_ref->tpart_tail = tile_ref->tpart_tail->next = elt;

	mov	DWORD PTR [ecx+8], edx
	mov	DWORD PTR [eax+4], edx
$LN8@add_tpart:

; 1524 :   else
; 1525 :     assert(0);
; 1526 : }

	pop	ebp
	ret	12					; 0000000cH
?add_tpart@kd_tpart_pointer_server@@QAEXPAUkd_tile_ref@@_J@Z ENDP ; kd_tpart_pointer_server::add_tpart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z
_TEXT	SEGMENT
_w$2 = -80						; size = 20
_e$3 = -60						; size = 20
_e$4 = -60						; size = 20
_e$5 = -60						; size = 20
_num_bytes$1$ = -40					; size = 4
_tlm$1$ = -36						; size = 4
_this$1$ = -32						; size = 4
_field_bytes$6 = -28					; size = 4
_address$2$ = -24					; size = 4
_address$1$ = -20					; size = 4
_tlm_info_incomplete$1$ = -15				; size = 1
_short_lengths$1$ = -14					; size = 1
_short_tnums$7 = -13					; size = 1
__$EHRec$ = -12						; size = 12
_address$ = 8						; size = 8
_missing_tnums$8 = 15					; size = 1
_num_tiles$ = 16					; size = 4
_tile_refs$ = 20					; size = 4
?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z PROC ; kd_tpart_pointer_server::translate_markers, COMDAT
; _this$ = ecx

; 1535 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 1536 :   assert(groups == NULL); // Illegal to call this function more than once.
; 1537 :   if (tlm_markers == NULL)

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR _tlm$1$[ebp], ecx
	test	ecx, ecx
	je	$LN9@translate_

; 1543 :   while (((tlm=tlm_markers) != NULL) && !tlm_info_incomplete)

	mov	eax, DWORD PTR _address$[ebp+4]
	or	edi, -1
	xor	dl, dl
	mov	DWORD PTR _address$2$[ebp], eax
	mov	eax, DWORD PTR _address$[ebp]
	mov	BYTE PTR _tlm_info_incomplete$1$[ebp], dl
	mov	DWORD PTR _address$1$[ebp], eax
	npad	2
$LL2@translate_:
	test	dl, dl
	jne	$LN3@translate_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	esi, DWORD PTR [ecx+20]

; 844  :     kd_marker *move(kd_input *input, kd_codestream *cs)
; 845  :       { this->source = input; this->codestream = cs; return this; }
; 846  :         /* This function is used when a `kd_marker' object must be moved
; 847  :          to a different codestream, or to work with a different source of
; 848  :          data. */
; 849  :     void print_current_code(kdu_message &out)
; 850  :       { /* Prints a text string identifying the current marker code. */
; 851  :         print_marker_code(this->code,out);
; 852  :       }
; 853  :     bool read(bool exclude_stuff_bytes=false, bool skip_to_marker=false);
; 854  :       /* Reads a new marker (or marker segment) from the `kd_input' object
; 855  :          supplied during construction.
; 856  :              Returns true if successful.  Causes of failure may be: 1) the
; 857  :          code-stream source is exhausted; 2) a valid marker code was not found;
; 858  :          or 3) an SOP or SOT marker code was found, but followed by an invalid
; 859  :          length field.  This third cause of failure is important since it
; 860  :          prevents the function from attempting to consume an invalid SOP or
; 861  :          SOT marker segment, in the process of which it might consume any
; 862  :          number of useful packets, having their own SOP markers.
; 863  :               A valid marker code must commence with an FF.  If
; 864  :          `exclude_stuff_bytes' is true then the second byte of a valid marker
; 865  :          code must be strictly greater than 0x8F.  Otherwise, the second byte
; 866  :          is arbitrary.  If `skip_to_marker' is true, the function consumes
; 867  :          bytes indefinitely, until the source is exhausted or a valid marker
; 868  :          code is found.  In this case, the function returns false only if the
; 869  :          source is exhausted. Otherwise, the function expects to find a valid
; 870  :          marker code immediately.
; 871  :              As a convenience feature, the function automatically skips over
; 872  :          any EOC marker it encounters.  This has two advantages: 1) we can
; 873  :          detect the end of the code-stream without having to explicitly check
; 874  :          for an EOC marker; 2) we should not be overly troubled by EOC
; 875  :          markers which arise due to corruption of the code-stream (this has
; 876  :          quite a high likelihood of occurring if the code-stream is subject
; 877  :          to corruption).
; 878  :              In the event that the source is not exhausted but a valid
; 879  :          marker code is not found, the function puts back any bytes it consumed
; 880  :          before returning false.  This allows the caller to continue reading
; 881  :          from the point where the function was first called. */
; 882  :     kdu_uint16 get_code() { return code; }
; 883  :       /* Returns 0 if no actual marker is available yet. */
; 884  :     int get_length() { return length; }

	mov	ebx, DWORD PTR [ecx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1547 :       kdu_byte style = *(data++); num_bytes--;

	add	ebx, -2					; fffffffeH
	mov	DWORD PTR _num_bytes$1$[ebp], ebx
	mov	cl, BYTE PTR [esi+1]
	add	esi, 2

; 1548 :       bool short_lengths = ((style & (1<<6)) == 0);

	mov	al, cl
	shr	al, 6
	not	al
	and	al, 1
	mov	BYTE PTR _short_lengths$1$[ebp], al

; 1549 :       bool short_tnums, missing_tnums;
; 1550 :       int num_fields, field_bytes;
; 1551 :       switch ((style>>4) & 3) {

	movzx	eax, cl
	shr	eax, 4
	and	eax, 3
	sub	eax, 0
	je	SHORT $LN12@translate_
	sub	eax, 1
	je	SHORT $LN13@translate_
	sub	eax, 1
	je	SHORT $LN14@translate_

; 1555 :         default: { KDU_ERROR(e,14); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0DG@MNLOLHMH@Illegal?5Stlm?5field?5encountered?5i@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1555 :         default: { KDU_ERROR(e,14); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1558 :                  }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _field_bytes$6[ebp]
	jmp	SHORT $LN4@translate_
$LN14@translate_:

; 1554 :         case 2: missing_tnums=false; short_tnums=false; field_bytes=2; break;

	mov	BYTE PTR _missing_tnums$8[ebp], 0
	mov	ecx, 2
	jmp	SHORT $LN69@translate_
$LN13@translate_:

; 1553 :         case 1: missing_tnums=false; short_tnums=true; field_bytes=1; break;

	mov	BYTE PTR _missing_tnums$8[ebp], 0
	mov	ecx, 1
	mov	BYTE PTR _short_tnums$7[ebp], 1
	jmp	SHORT $LN4@translate_
$LN12@translate_:

; 1552 :         case 0: missing_tnums=true; short_tnums=false; field_bytes=0; break;

	mov	BYTE PTR _missing_tnums$8[ebp], 1
	xor	ecx, ecx
$LN69@translate_:
	mov	BYTE PTR _short_tnums$7[ebp], 0
$LN4@translate_:

; 1559 :         }
; 1560 :       field_bytes += (short_lengths)?2:4;

	xor	eax, eax
	cmp	BYTE PTR _short_lengths$1$[ebp], al
	sete	al
	lea	ecx, DWORD PTR [ecx+eax*2]

; 1561 :       num_fields = num_bytes / field_bytes;

	mov	eax, ebx
	add	ecx, 2
	cdq
	idiv	ecx
	mov	DWORD PTR _field_bytes$6[ebp], ecx
	mov	ebx, eax

; 1562 :       if ((num_fields < 1) || (num_bytes != (num_fields*field_bytes)))

	cmp	ebx, 1
	jl	SHORT $LN17@translate_
	mov	ecx, ebx
	imul	ecx, DWORD PTR _field_bytes$6[ebp]
	cmp	DWORD PTR _num_bytes$1$[ebp], ecx
	je	SHORT $LN56@translate_
$LN17@translate_:

; 1563 :         { KDU_ERROR(e,15); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0KF@DLMNKMGF@Malformed?5TLM?5marker?5segment?5enc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1563 :         { KDU_ERROR(e,15); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1568 :         }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN56@translate_:

; 1569 :       while (num_fields--)

	test	ebx, ebx
	je	$LN59@translate_
	npad	7
$LL6@translate_:
	dec	ebx

; 1570 :         {
; 1571 :           if (missing_tnums)

	cmp	BYTE PTR _missing_tnums$8[ebp], 0
	je	SHORT $LN18@translate_

; 1572 :             tnum = last_tnum + 1; // Tiles must be in order with one part

	inc	edi
	jmp	SHORT $LN21@translate_
$LN18@translate_:

; 1573 :           else if (short_tnums)

	cmp	BYTE PTR _short_tnums$7[ebp], 0

; 1574 :             tnum = *(data++);

	movzx	edi, BYTE PTR [esi]
	je	SHORT $LN20@translate_
	inc	esi

; 1575 :           else

	jmp	SHORT $LN21@translate_
$LN20@translate_:

; 1576 :             { tnum = *(data++); tnum<<=8; tnum += *(data++); }

	movzx	eax, BYTE PTR [esi+1]
	shl	edi, 8
	add	edi, eax
	add	esi, 2
$LN21@translate_:

; 1577 :           if (tnum >= num_tiles)

	cmp	edi, DWORD PTR _num_tiles$[ebp]
	jl	SHORT $LN22@translate_

; 1578 :             { KDU_ERROR(e,16); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BAC@JCJFPLLE@Illegal?5TLM?5marker?5segment?5data?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1578 :             { KDU_ERROR(e,16); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1585 :             }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN22@translate_:

; 1586 :           add_tpart(tile_refs+tnum,address);

	push	DWORD PTR _address$2$[ebp]
	mov	ecx, DWORD PTR _tile_refs$[ebp]
	lea	eax, DWORD PTR [edi+edi*2]
	push	DWORD PTR _address$1$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	eax
	call	?add_tpart@kd_tpart_pointer_server@@QAEXPAUkd_tile_ref@@_J@Z ; kd_tpart_pointer_server::add_tpart

; 1587 :           last_tnum = tnum;
; 1588 :           kdu_uint32 length = *(data++); length<<=8; length += *(data++);

	movzx	ecx, BYTE PTR [esi]
	movzx	eax, BYTE PTR [esi+1]
	add	esi, 2
	shl	ecx, 8
	add	ecx, eax

; 1589 :           if (!short_lengths)

	cmp	BYTE PTR _short_lengths$1$[ebp], 0
	jne	SHORT $LN23@translate_

; 1590 :             { length <<= 8; length += *(data++);

	movzx	eax, BYTE PTR [esi]
	shl	ecx, 8
	add	ecx, eax

; 1591 :               length <<= 8; length += *(data++); }

	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax
	add	esi, 2
$LN23@translate_:

; 1592 :           if (length < 14)

	cmp	ecx, 14					; 0000000eH
	jb	SHORT $LN58@translate_

; 1600 :             }
; 1601 :           address += (kdu_long) length;

	add	DWORD PTR _address$1$[ebp], ecx
	adc	DWORD PTR _address$2$[ebp], 0
	test	ebx, ebx
	jne	$LL6@translate_

; 1592 :           if (length < 14)

	jmp	SHORT $LN59@translate_
$LN58@translate_:

; 1595 :               KDU_WARNING(w,5); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$2[ebp]
	mov	BYTE PTR _tlm_info_incomplete$1$[ebp], 1
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$2[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	OFFSET ??_C@_0IA@MHJOOLGJ@TLM?5marker?5segments?5contain?5one?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1595 :               KDU_WARNING(w,5); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1599 :               break;

	lea	ecx, DWORD PTR _w$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN59@translate_:

; 1602 :         }
; 1603 :       tlm_markers = tlm->next;

	mov	esi, DWORD PTR _tlm$1$[ebp]
	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [ebx], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN52@translate_
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN52@translate_:
	push	36					; 00000024H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1543 :   while (((tlm=tlm_markers) != NULL) && !tlm_info_incomplete)

	mov	ecx, DWORD PTR [ebx]
	add	esp, 8
	mov	dl, BYTE PTR _tlm_info_incomplete$1$[ebp]
	mov	DWORD PTR _tlm$1$[ebp], ecx
	test	ecx, ecx
	jne	$LL2@translate_
$LN3@translate_:

; 1608 : 
; 1609 :   // Finally, visit all the tiles, setting their address lists to have a
; 1610 :   // NULL tail so as to assert the fact that all tile-parts have been
; 1611 :   // found.
; 1612 :   for (tnum=0; tnum < num_tiles; tnum++)

	mov	ecx, DWORD PTR _num_tiles$[ebp]
	mov	BYTE PTR [ebx+12], 1
	test	ecx, ecx
	jle	SHORT $LN9@translate_

; 1604 :       delete tlm;
; 1605 :     }
; 1606 : 
; 1607 :   translated_tlm_markers = true;

	mov	eax, DWORD PTR _tile_refs$[ebp]
	add	eax, 4
	npad	5
$LL10@translate_:

; 1613 :     tile_refs[tnum].tpart_tail = NULL;

	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax+12]
	sub	ecx, 1
	jne	SHORT $LL10@translate_
$LN9@translate_:

; 1614 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z$0:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z$1:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z$2:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z$3:
	lea	ecx, DWORD PTR _w$2[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__ehhandler$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?translate_markers@kd_tpart_pointer_server@@QAEX_JHPAUkd_tile_ref@@@Z ENDP ; kd_tpart_pointer_server::translate_markers
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z
_TEXT	SEGMENT
_e$2 = -52						; size = 20
_e$3 = -32						; size = 20
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
_copy_source$ = 8					; size = 4
?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z PROC ; kd_tpart_pointer_server::add_tlm_marker, COMDAT
; _this$ = ecx

; 1466 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 884  :     int get_length() { return length; }

	mov	edi, DWORD PTR _copy_source$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1467 :   translated_tlm_markers = false;

	mov	BYTE PTR [ebx+12], 0

; 1468 :   assert(copy_source.get_code() == KDU_TLM);
; 1469 :   if (copy_source.get_length() < 4)

	cmp	DWORD PTR [edi+12], 4
	jge	SHORT $LN5@add_tlm_ma

; 1470 :     { KDU_ERROR(e,12); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0DD@NPPLBJLB@TLM?5marker?5segments?5must?5be?5at?5l@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1470 :     { KDU_ERROR(e,12); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1472 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN5@add_tlm_ma:

; 1474 :     new kd_tlm_marker_list(copy_source);

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T4[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	esi, esi
	je	SHORT $LN11@add_tlm_ma
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1118 :           kd_tlm_marker_list(kd_marker &copy_source) : kd_marker(copy_source)

	push	edi
	mov	ecx, esi
	call	??0kd_marker@@QAE@ABV0@@Z		; kd_marker::kd_marker

; 1119 :             { next = NULL; }

	mov	DWORD PTR [esi+28], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1474 :     new kd_tlm_marker_list(copy_source);

	jmp	SHORT $LN12@add_tlm_ma
$LN11@add_tlm_ma:
	xor	esi, esi
$LN12@add_tlm_ma:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	eax, DWORD PTR [esi+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1480 :   for (prev=NULL, scan=tlm_markers; scan != NULL; prev=scan, scan=scan->next)

	xor	ecx, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	movzx	edx, BYTE PTR [eax]
	mov	DWORD PTR [esi+32], edx
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN28@add_tlm_ma
	npad	3
$LL4@add_tlm_ma:

; 1481 :     if (scan->znum > elt->znum)

	cmp	DWORD PTR [eax+32], edx
	jg	SHORT $LN28@add_tlm_ma

; 1480 :   for (prev=NULL, scan=tlm_markers; scan != NULL; prev=scan, scan=scan->next)

	mov	ecx, eax
	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	jne	SHORT $LL4@add_tlm_ma
$LN28@add_tlm_ma:

; 1482 :       break;
; 1483 :   elt->next = scan;

	mov	DWORD PTR [esi+28], eax

; 1484 :   if (prev == NULL)

	test	ecx, ecx
	jne	SHORT $LN7@add_tlm_ma

; 1485 :     tlm_markers = elt;

	mov	DWORD PTR [ebx], esi

; 1494 :     }
; 1495 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN7@add_tlm_ma:

; 1486 :   else
; 1487 :     {
; 1488 :       prev->next = elt;
; 1489 :       if (prev->znum == elt->znum)

	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx+28], esi
	cmp	eax, DWORD PTR [esi+32]
	jne	SHORT $LN9@add_tlm_ma

; 1490 :         { KDU_ERROR(e,13); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0FH@FGOHBFDA@Found?5multiple?5TLM?5marker?5segmen@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1490 :         { KDU_ERROR(e,13); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1493 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN9@add_tlm_ma:

; 1494 :     }
; 1495 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z$1:
	push	36					; 00000024H
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?add_tlm_marker@kd_tpart_pointer_server@@QAEXAAVkd_marker@@@Z ENDP ; kd_tpart_pointer_server::add_tlm_marker
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ??1kd_tpart_pointer_server@@QAE@XZ
_TEXT	SEGMENT
??1kd_tpart_pointer_server@@QAE@XZ PROC			; kd_tpart_pointer_server::~kd_tpart_pointer_server, COMDAT
; _this$ = ecx

; 1444 : {

	push	esi
	push	edi
	mov	edi, ecx

; 1446 :   while ((mkr=tlm_markers) != NULL)

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN21@kd_tpart_p
	npad	6
$LL2@kd_tpart_p:

; 1447 :     {
; 1448 :       tlm_markers = mkr->next;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [edi], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN17@kd_tpart_p
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN17@kd_tpart_p:
	push	36					; 00000024H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1446 :   while ((mkr=tlm_markers) != NULL)

	mov	esi, DWORD PTR [edi]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL2@kd_tpart_p
$LN21@kd_tpart_p:

; 1449 :       delete mkr;
; 1450 :     }
; 1451 : 
; 1452 :   kd_pointer_group *grp;
; 1453 :   while ((grp=groups) != NULL)

	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	je	SHORT $LN5@kd_tpart_p
	npad	3
$LL4@kd_tpart_p:

; 1454 :     {
; 1455 :       groups = grp->next;

	mov	eax, DWORD PTR [ecx+512]

; 1456 :       delete grp;

	push	520					; 00000208H
	push	ecx
	mov	DWORD PTR [edi+4], eax
	call	??3@YAXPAXI@Z				; operator delete
	mov	ecx, DWORD PTR [edi+4]
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LL4@kd_tpart_p
$LN5@kd_tpart_p:
	pop	edi
	pop	esi

; 1457 :     }
; 1458 : }

	ret	0
??1kd_tpart_pointer_server@@QAE@XZ ENDP			; kd_tpart_pointer_server::~kd_tpart_pointer_server
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_tpart_pointer_server@@QAE@XZ
_TEXT	SEGMENT
??0kd_tpart_pointer_server@@QAE@XZ PROC			; kd_tpart_pointer_server::kd_tpart_pointer_server, COMDAT
; _this$ = ecx

; 1075 :       {
; 1076 :         groups = NULL; free_list = NULL; tlm_markers = NULL;

	mov	DWORD PTR [ecx+4], 0

; 1077 :         translated_tlm_markers = false;
; 1078 :       }

	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx], 0
	mov	BYTE PTR [ecx+12], 0
	ret	0
??0kd_tpart_pointer_server@@QAE@XZ ENDP			; kd_tpart_pointer_server::kd_tpart_pointer_server
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z
_TEXT	SEGMENT
_e$2 = -596						; size = 20
_marker_body$1$ = -576					; size = 4
_tgt$GSCopy$1$ = -572					; size = 4
_elts_left$2$ = -568					; size = 4
_scan$1$ = -564						; size = 4
_this$GSCopy$1$ = -560					; size = 4
_word$1$ = -556						; size = 4
_word$1$ = -556						; size = 4
_elts_left$1$ = -556					; size = 4
_out$ = -552						; size = 536
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_tgt$ = 8						; size = 4
_prev_tiles_written$ = 12				; size = 4
_prev_tile_bytes_written$ = 16				; size = 8
?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z PROC ; kd_tlm_generator::write_tlms, COMDAT
; _this$ = ecx

; 1366 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 584				; 00000248H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1010 :     bool exists() { return (num_tiles > 0); }

	cmp	DWORD PTR [ebx], 0
	mov	eax, DWORD PTR _tgt$[ebp]
	mov	DWORD PTR _tgt$GSCopy$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1367 :   if (!exists())

	jle	$LN59@write_tlms

; 1368 :     return;
; 1369 : 
; 1370 :   kdu_long backtrack = tile_data_bytes + prev_tile_bytes_written;
; 1371 :   backtrack += tlm_bytes; // This should take us to the start of the TLM data

	mov	eax, DWORD PTR [ebx+8]
	cdq
	mov	ecx, eax
	mov	edi, edx
	add	ecx, DWORD PTR [ebx+24]

; 1372 :   
; 1373 :   // Start by walking over all TLM entries which have already been written
; 1374 :   int z_tlm = 0;
; 1375 :   int tlm_elts_left = 0;
; 1376 :   int elts_left = prev_tiles_written*max_tparts;

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	adc	edi, DWORD PTR [ebx+28]
	add	ecx, DWORD PTR _prev_tile_bytes_written$[ebp]
	adc	edi, DWORD PTR _prev_tile_bytes_written$[ebp+4]
	xor	ebx, ebx
	mov	edx, DWORD PTR [eax+4]
	xor	esi, esi
	imul	edx, DWORD PTR _prev_tiles_written$[ebp]

; 1377 :   int xfer;
; 1378 :   while (elts_left > 0)

	test	edx, edx
	jle	SHORT $LN3@write_tlms
$LL2@write_tlms:

; 1379 :     {
; 1380 :       if (tlm_elts_left == 0)

	test	esi, esi
	jne	SHORT $LN7@write_tlms

; 1381 :         { // Open a new marker segment
; 1382 :           assert(z_tlm <= 255);
; 1383 :           tlm_elts_left = (65535-4) / 6;
; 1384 :           backtrack -= 6; // For the TLM header already written

	add	ecx, -6					; fffffffaH
	mov	esi, 10921				; 00002aa9H
	adc	edi, -1

; 1385 :           z_tlm++;

	inc	ebx
$LN7@write_tlms:

; 1386 :         }
; 1387 :       xfer = (elts_left < tlm_elts_left)?elts_left:tlm_elts_left;

	cmp	edx, esi
	mov	eax, esi
	cmovl	eax, edx

; 1388 :       tlm_elts_left -= xfer;
; 1389 :       elts_left -= xfer;

	sub	edx, eax
	sub	esi, eax
	mov	DWORD PTR _elts_left$1$[ebp], edx

; 1390 :       backtrack -= 6*xfer;

	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	cdq
	sub	ecx, eax
	sbb	edi, edx
	mov	edx, DWORD PTR _elts_left$1$[ebp]
	test	edx, edx
	jg	SHORT $LL2@write_tlms
$LN3@write_tlms:

; 1391 :     }
; 1392 : 
; 1393 :   // Now we are ready to write the new tile-part lengths
; 1394 :   if (!tgt->start_rewrite(backtrack))

	mov	edx, DWORD PTR _tgt$GSCopy$1$[ebp]
	push	edi
	push	ecx
	mov	ecx, edx
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	jne	SHORT $LN8@write_tlms

; 1395 :     { KDU_ERROR_DEV(e,11); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0HO@CCHNKHBP@Attempting?5to?5invoke?5?$GAkd_tlm_gen@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1395 :     { KDU_ERROR_DEV(e,11); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1399 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN8@write_tlms:

; 1400 :   elts_left = num_elts - prev_tiles_written*max_tparts;

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]

; 1404 :   kdu_byte *marker_body = new kdu_byte[65535];

	push	65535					; 0000ffffH
	mov	eax, DWORD PTR [ecx+4]
	imul	eax, DWORD PTR _prev_tiles_written$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+32]
	cmp	esi, edx
	mov	DWORD PTR _elts_left$2$[ebp], edx
	mov	DWORD PTR _scan$1$[ebp], eax
	cmovg	esi, edx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR _marker_body$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 131  :       { next_buf = buffer; end_buf = buffer+KDU_OBUF_SIZE; }

	lea	ecx, DWORD PTR _out$[ebp+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 441  :       { this->target=target; flushed_bytes = 0; }

	mov	eax, DWORD PTR _tgt$GSCopy$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 131  :       { next_buf = buffer; end_buf = buffer+KDU_OBUF_SIZE; }

	lea	edx, DWORD PTR _out$[ebp+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 441  :       { this->target=target; flushed_bytes = 0; }

	mov	edi, OFFSET ??_7kd_compressed_output@@6B@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 131  :       { next_buf = buffer; end_buf = buffer+KDU_OBUF_SIZE; }

	mov	DWORD PTR _out$[ebp+516], ecx
	xorps	xmm0, xmm0
	mov	DWORD PTR _out$[ebp+520], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1404 :   kdu_byte *marker_body = new kdu_byte[65535];

	add	esp, 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 441  :       { this->target=target; flushed_bytes = 0; }

	mov	DWORD PTR _out$[ebp], edi
	mov	DWORD PTR _out$[ebp+524], eax
	movlpd	QWORD PTR _out$[ebp+528], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1406 :   while (elt_ctr > 0)

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR [eax+16], 0
	jle	$LN74@write_tlms
$LL4@write_tlms:

; 1407 :     {
; 1408 :       assert(elts_left > 0);
; 1409 :       if (tlm_elts_left == 0)

	test	esi, esi
	jne	$LN10@write_tlms

; 1410 :         { // Open a new marker segment
; 1411 :           assert(z_tlm <= 255);
; 1412 :           tlm_elts_left = (65535-4) / 6;

	mov	esi, 10921				; 00002aa9H

; 1413 :           if (tlm_elts_left > elts_left)

	cmp	DWORD PTR _elts_left$2$[ebp], esi
	cmovl	esi, DWORD PTR _elts_left$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, edx
	jne	SHORT $LN26@write_tlms

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	lea	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR [edi+4]
	mov	ecx, DWORD PTR _out$[ebp+516]
$LN26@write_tlms:

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [ecx], 255			; 000000ffH
	mov	eax, DWORD PTR _out$[ebp+516]
	inc	eax
	mov	DWORD PTR _out$[ebp+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR _out$[ebp+520]
	jne	SHORT $LN29@write_tlms

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _out$[ebp+516]
$LN29@write_tlms:

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], 85			; 00000055H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1416 :           out.put((kdu_uint16)(4+6*tlm_elts_left));

	lea	eax, DWORD PTR [esi+esi*2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR _out$[ebp+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1416 :           out.put((kdu_uint16)(4+6*tlm_elts_left));

	lea	eax, DWORD PTR [eax*2+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1416 :           out.put((kdu_uint16)(4+6*tlm_elts_left));

	movzx	eax, ax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	DWORD PTR _out$[ebp+516], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1416 :           out.put((kdu_uint16)(4+6*tlm_elts_left));

	mov	DWORD PTR _word$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR _out$[ebp+520]
	jne	SHORT $LN34@write_tlms

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _out$[ebp+516]
	mov	eax, DWORD PTR _word$1$[ebp]
$LN34@write_tlms:

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	eax, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [ecx], al
	mov	eax, DWORD PTR _out$[ebp+516]
	inc	eax
	mov	DWORD PTR _out$[ebp+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR _out$[ebp+520]
	jne	SHORT $LN37@write_tlms

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _out$[ebp+516]
$LN37@write_tlms:

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR _word$1$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR _out$[ebp+516]
	inc	eax
	mov	DWORD PTR _out$[ebp+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR _out$[ebp+520]
	jne	SHORT $LN40@write_tlms

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _out$[ebp+516]
$LN40@write_tlms:

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], bl
	mov	eax, DWORD PTR _out$[ebp+516]
	inc	eax
	mov	DWORD PTR _out$[ebp+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR _out$[ebp+520]
	jne	SHORT $LN43@write_tlms

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _out$[ebp+516]
$LN43@write_tlms:

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], 96			; 00000060H
	mov	ecx, DWORD PTR _out$[ebp+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1419 :           z_tlm++;

	mov	edx, DWORD PTR _out$[ebp+520]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1419 :           z_tlm++;

	mov	edi, DWORD PTR _out$[ebp]
	inc	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	DWORD PTR _out$[ebp+516], ecx
$LN10@write_tlms:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1422 :       out.put(scan->tnum);

	mov	eax, DWORD PTR _scan$1$[ebp]
	movzx	eax, WORD PTR [eax]
	mov	DWORD PTR _word$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, edx
	jne	SHORT $LN48@write_tlms

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	lea	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR [edi+4]
	mov	ecx, DWORD PTR _out$[ebp+516]
	mov	eax, DWORD PTR _word$1$[ebp]
$LN48@write_tlms:

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	eax, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [ecx], al
	mov	eax, DWORD PTR _out$[ebp+516]
	inc	eax
	mov	DWORD PTR _out$[ebp+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR _out$[ebp+520]
	jne	SHORT $LN51@write_tlms

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _out$[ebp+516]
$LN51@write_tlms:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1423 :       out.put(scan->length);

	mov	edi, DWORD PTR _scan$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR _word$1$[ebp]
	mov	BYTE PTR [eax], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1423 :       out.put(scan->length);

	lea	ecx, DWORD PTR _out$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR _out$[ebp+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1423 :       out.put(scan->length);

	push	DWORD PTR [edi+4]
	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put

; 1424 :       scan++;
; 1425 :       elt_ctr--;

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	add	edi, 8

; 1426 :       tlm_elts_left--;
; 1427 :       elts_left--;

	dec	DWORD PTR _elts_left$2$[ebp]
	dec	esi
	mov	DWORD PTR _scan$1$[ebp], edi
	dec	DWORD PTR [eax+16]
	cmp	DWORD PTR [eax+16], 0
	jle	SHORT $LN74@write_tlms

; 1406 :   while (elt_ctr > 0)

	mov	edx, DWORD PTR _out$[ebp+520]
	mov	ecx, DWORD PTR _out$[ebp+516]
	mov	edi, DWORD PTR _out$[ebp]
	jmp	$LL4@write_tlms
$LN74@write_tlms:

; 1429 :   delete[] marker_body;

	push	DWORD PTR _marker_body$1$[ebp]
	call	??_V@YAXPAX@Z				; operator delete[]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 454  :       { flush_buf(); }

	mov	eax, DWORD PTR _out$[ebp]
	lea	ecx, DWORD PTR _out$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1429 :   delete[] marker_body;

	add	esp, 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 454  :       { flush_buf(); }

	call	DWORD PTR [eax+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1431 :   tgt->end_rewrite();

	mov	ecx, DWORD PTR _tgt$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 458  :         if (next_buf > buffer)

	mov	edx, DWORD PTR _out$[ebp+516]
	lea	eax, DWORD PTR _out$[ebp+4]

; 442  :     virtual ~kd_compressed_output()
; 443  :       { flush_buf(); }

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR _out$[ebp], OFFSET ??_7kd_compressed_output@@6B@

; 458  :         if (next_buf > buffer)

	cmp	edx, eax
	jbe	SHORT $LN59@write_tlms

; 459  :           target->write(buffer,(int)(next_buf-buffer));

	mov	ecx, DWORD PTR _out$[ebp+524]
	lea	esi, DWORD PTR _out$[ebp]
	sub	edx, esi
	sub	edx, 4
	push	edx
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _out$[ebp+4]
	push	edx
	call	DWORD PTR [eax+16]
$LN59@write_tlms:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1432 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z$1:
	lea	ecx, DWORD PTR _out$[ebp]
	jmp	??1kd_compressed_output@@UAE@XZ		; kd_compressed_output::~kd_compressed_output
__unwindfunclet$?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z$2:
	call	___std_terminate
	ret	0
__ehhandler$?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-600]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?write_tlms@kd_tlm_generator@@QAEXPAVkdu_compressed_target@@H_J@Z ENDP ; kd_tlm_generator::write_tlms
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z
_TEXT	SEGMENT
_e$2 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_tnum$ = 8						; size = 4
_length$ = 12						; size = 8
?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z PROC	; kd_tlm_generator::add_tpart_length, COMDAT
; _this$ = ecx

; 1309 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1010 :     bool exists() { return (num_tiles > 0); }

	cmp	DWORD PTR [edi], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1310 :   if (!exists())

	jle	SHORT $LN1@add_tpart_

; 1311 :     return;
; 1312 :   assert(elt_ctr < num_elts);
; 1313 :   assert((tnum >= 0) && (tnum < num_tiles));
; 1314 :   elts[elt_ctr].tnum = (kdu_uint16) tnum;

	mov	esi, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+32]
	mov	ax, WORD PTR _tnum$[ebp]

; 1315 :   elts[elt_ctr].length = (kdu_uint32) length;

	mov	ebx, DWORD PTR _length$[ebp]
	mov	WORD PTR [edx+esi*8], ax
	mov	ecx, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [edi+32]

; 1316 :   if (length != (kdu_long) elts[elt_ctr].length)

	mov	esi, DWORD PTR _length$[ebp+4]
	mov	DWORD PTR [eax+ecx*8+4], ebx
	mov	ecx, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [edi+32]
	cmp	ebx, DWORD PTR [eax+ecx*8+4]
	jne	SHORT $LN10@add_tpart_
	test	esi, esi
	je	SHORT $LN3@add_tpart_
$LN10@add_tpart_:

; 1317 :     { KDU_ERROR(e,10); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0IA@FPINHJNP@Attempting?5to?5write?5TLM?5?$CItile?9pa@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1317 :     { KDU_ERROR(e,10); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1321 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN3@add_tpart_:

; 1322 :   elt_ctr++;

	inc	DWORD PTR [edi+16]

; 1323 :   tile_data_bytes += length;

	add	DWORD PTR [edi+24], ebx
	adc	DWORD PTR [edi+28], esi
$LN1@add_tpart_:

; 1324 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z ENDP	; kd_tlm_generator::add_tpart_length
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?write_dummy_tlms@kd_tlm_generator@@QAEXPAVkd_compressed_output@@@Z
_TEXT	SEGMENT
_marker_body$1$ = -8					; size = 4
_z_tlm$1$ = -4						; size = 4
_word$1$ = 8						; size = 4
_out$ = 8						; size = 4
?write_dummy_tlms@kd_tlm_generator@@QAEXPAVkd_compressed_output@@@Z PROC ; kd_tlm_generator::write_dummy_tlms, COMDAT
; _this$ = ecx

; 1332 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1010 :     bool exists() { return (num_tiles > 0); }

	cmp	DWORD PTR [ecx], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1333 :   if (!exists())

	jle	$LN1@write_dumm

; 1334 :     return;
; 1335 :   int z_tlm = 0;
; 1336 :   int elts_left = num_elts;

	push	ebx
	mov	ebx, DWORD PTR [ecx+12]
	push	esi
	push	edi

; 1337 :   int check_tlm_bytes = 0;
; 1338 :   kdu_byte *marker_body = new kdu_byte[65535];

	push	65535					; 0000ffffH
	mov	DWORD PTR _z_tlm$1$[ebp], 0
	call	??_U@YAPAXI@Z				; operator new[]

; 1339 :   memset(marker_body,0,65535);

	push	65535					; 0000ffffH
	push	0
	push	eax
	mov	DWORD PTR _marker_body$1$[ebp], eax
	call	_memset
	mov	esi, DWORD PTR _out$[ebp]
	add	esp, 16					; 00000010H
	npad	4
$LL4@write_dumm:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1342 :       int tlm_elts = (65535-4) / 6;

	mov	edi, 10921				; 00002aa9H

; 1343 :       if (tlm_elts > elts_left)

	cmp	ebx, edi
	cmovl	edi, ebx

; 1344 :         tlm_elts = elts_left;
; 1345 :       elts_left -= tlm_elts;

	sub	ebx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN13@write_dumm

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN13@write_dumm:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN16@write_dumm

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN16@write_dumm:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 85			; 00000055H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1348 :       out->put((kdu_uint16)(4+6*tlm_elts));

	lea	eax, DWORD PTR [edi+edi*2]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1348 :       out->put((kdu_uint16)(4+6*tlm_elts));

	lea	eax, DWORD PTR [eax*2+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1348 :       out->put((kdu_uint16)(4+6*tlm_elts));

	movzx	eax, ax
	mov	DWORD PTR _word$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [esi+520]
	jne	SHORT $LN21@write_dumm

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _word$1$[ebp]
$LN21@write_dumm:

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, eax

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN24@write_dumm

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN24@write_dumm:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR _word$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN27@write_dumm

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN27@write_dumm:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR _z_tlm$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN30@write_dumm

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN30@write_dumm:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1352 :       out->write(marker_body,6*tlm_elts);

	mov	ecx, esi
	inc	DWORD PTR _z_tlm$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], 96			; 00000060H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1352 :       out->write(marker_body,6*tlm_elts);

	lea	eax, DWORD PTR [edi+edi*2]
	mov	edi, DWORD PTR _marker_body$1$[ebp]
	add	eax, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1352 :       out->write(marker_body,6*tlm_elts);

	push	eax
	push	edi
	call	?write@kdu_output@@QAEXPAEH@Z		; kdu_output::write

; 1353 :     } while (elts_left > 0);

	test	ebx, ebx
	jg	$LL4@write_dumm

; 1354 :   assert(check_tlm_bytes == tlm_bytes);
; 1355 :   delete[] marker_body;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
$LN1@write_dumm:

; 1356 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?write_dummy_tlms@kd_tlm_generator@@QAEXPAVkd_compressed_output@@@Z ENDP ; kd_tlm_generator::write_dummy_tlms
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?clear@kd_tlm_generator@@QAEXXZ
_TEXT	SEGMENT
?clear@kd_tlm_generator@@QAEXXZ PROC			; kd_tlm_generator::clear, COMDAT
; _this$ = ecx

; 1013 :       {

	push	esi
	mov	esi, ecx

; 1014 :         num_tiles = max_tparts = num_elts = 0;
; 1015 :         tile_data_bytes = 0;
; 1016 :         if (elts != NULL)

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	test	eax, eax
	je	SHORT $LN2@clear

; 1017 :           { delete[] elts; elts = NULL; }

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+32], 0
$LN2@clear:
	pop	esi

; 1018 :       }

	ret	0
?clear@kd_tlm_generator@@QAEXXZ ENDP			; kd_tlm_generator::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?exists@kd_tlm_generator@@QAE_NXZ
_TEXT	SEGMENT
?exists@kd_tlm_generator@@QAE_NXZ PROC			; kd_tlm_generator::exists, COMDAT
; _this$ = ecx

; 1010 :     bool exists() { return (num_tiles > 0); }

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setg	al
	ret	0
?exists@kd_tlm_generator@@QAE_NXZ ENDP			; kd_tlm_generator::exists
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?init@kd_tlm_generator@@QAE_NHH@Z
_TEXT	SEGMENT
_num_tiles$ = 8						; size = 4
_max_tparts$ = 12					; size = 4
?init@kd_tlm_generator@@QAE_NHH@Z PROC			; kd_tlm_generator::init, COMDAT
; _this$ = ecx

; 1268 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1016 :         if (elts != NULL)

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	test	eax, eax
	je	SHORT $LN13@init

; 1017 :           { delete[] elts; elts = NULL; }

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+32], 0
$LN13@init:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1271 :   if (max_tparts < 0)

	mov	eax, DWORD PTR _max_tparts$[ebp]
	mov	edi, DWORD PTR _num_tiles$[ebp]
	mov	DWORD PTR [esi], edi
	test	eax, eax
	jns	SHORT $LN5@init

; 1272 :     max_tparts = 1;

	mov	eax, 1
	jmp	SHORT $LN7@init
$LN5@init:

; 1273 :   else if (max_tparts > 255)

	mov	ecx, 255				; 000000ffH
	cmp	eax, ecx
	cmovg	eax, ecx
$LN7@init:

; 1274 :     max_tparts = 255;
; 1275 :   this->max_tparts = max_tparts;
; 1276 :   num_elts = max_tparts * num_tiles;

	imul	edi, eax

; 1277 :   elt_ctr = 0;
; 1278 :   tile_data_bytes = 0;
; 1279 : 
; 1280 :   int z_tlm = 0;

	xor	ecx, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+12], edi

; 1281 :   int elts_left = num_elts;

	mov	edx, edi

; 1282 :   tlm_bytes = 0;

	mov	DWORD PTR [esi+8], ecx
$LL4@init:

; 1283 :   do {
; 1284 :       int tlm_elts = (65535-4) / 6;

	mov	eax, 10921				; 00002aa9H

; 1285 :       if (tlm_elts > elts_left)

	cmp	edx, eax
	cmovl	eax, edx

; 1286 :         tlm_elts = elts_left;
; 1287 :       elts_left -= tlm_elts;
; 1288 :       tlm_bytes += 6 + 6*tlm_elts;
; 1289 :       z_tlm++;

	inc	ecx
	sub	edx, eax
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax*2+6]
	add	DWORD PTR [esi+8], eax

; 1290 :     } while ((elts_left > 0) && (z_tlm < 255));

	test	edx, edx
	jle	SHORT $LN10@init
	cmp	ecx, 255				; 000000ffH
	jl	SHORT $LL4@init
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1016 :         if (elts != NULL)

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	test	eax, eax
	je	SHORT $LN16@init

; 1017 :           { delete[] elts; elts = NULL; }

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [esi+32], 0
$LN16@init:
	pop	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1296 :       return false;

	xor	al, al
	pop	esi

; 1301 : }

	pop	ebp
	ret	8
$LN10@init:

; 1297 :     }
; 1298 : 
; 1299 :   elts = new kd_tlm_elt[num_elts];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+32], eax

; 1300 :   return true;

	mov	al, 1
	pop	edi
	pop	esi

; 1301 : }

	pop	ebp
	ret	8
?init@kd_tlm_generator@@QAE_NHH@Z ENDP			; kd_tlm_generator::init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_tlm_generator@@QAE@XZ
_TEXT	SEGMENT
??1kd_tlm_generator@@QAE@XZ PROC			; kd_tlm_generator::~kd_tlm_generator, COMDAT
; _this$ = ecx

; 997  :     ~kd_tlm_generator() { if (elts != NULL) delete[] elts; }

	mov	eax, DWORD PTR [ecx+32]
	test	eax, eax
	je	SHORT $LN2@kd_tlm_gen
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN2@kd_tlm_gen:
	ret	0
??1kd_tlm_generator@@QAE@XZ ENDP			; kd_tlm_generator::~kd_tlm_generator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_tlm_generator@@QAE@XZ
_TEXT	SEGMENT
??0kd_tlm_generator@@QAE@XZ PROC			; kd_tlm_generator::kd_tlm_generator, COMDAT
; _this$ = ecx

; 993  :       {
; 994  :         num_tiles = max_tparts = num_elts = 0; elts = NULL;

	mov	DWORD PTR [ecx+12], 0

; 995  :         tile_data_bytes=0;
; 996  :       }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	ret	0
??0kd_tlm_generator@@QAE@XZ ENDP			; kd_tlm_generator::kd_tlm_generator
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_pp_markers@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_pp_markers@@QAEPAXI@Z PROC			; kd_pp_markers::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_pp_markers@@QAE@XZ		; kd_pp_markers::~kd_pp_markers
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_pp_markers@@QAEPAXI@Z ENDP			; kd_pp_markers::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?advance_list@kd_pp_markers@@AAEXXZ
_TEXT	SEGMENT
?advance_list@kd_pp_markers@@AAEXXZ PROC		; kd_pp_markers::advance_list, COMDAT
; _this$ = ecx

; 1250 : {

	push	esi

; 1251 :   assert((list != NULL) && (list->bytes_read == list->get_length()));
; 1252 :   kd_pp_marker_list *tmp = list;

	mov	esi, DWORD PTR [ecx+4]

; 1253 :   list = tmp->next;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [ecx+4], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN13@advance_li
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN13@advance_li:
	push	40					; 00000028H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1255 : }

	ret	0
?advance_list@kd_pp_markers@@AAEXXZ ENDP		; kd_pp_markers::advance_list
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Gkd_pp_marker_list@kd_pp_markers@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_pp_marker_list@kd_pp_markers@@QAEPAXI@Z PROC	; kd_pp_markers::kd_pp_marker_list::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN8@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN11@scalar
	push	40					; 00000028H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN11@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_pp_marker_list@kd_pp_markers@@QAEPAXI@Z ENDP	; kd_pp_markers::kd_pp_marker_list::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_pp_marker_list@kd_pp_markers@@QAE@XZ
_TEXT	SEGMENT
??1kd_pp_marker_list@kd_pp_markers@@QAE@XZ PROC		; kd_pp_markers::kd_pp_marker_list::~kd_pp_marker_list, COMDAT
; _this$ = ecx

; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN4@kd_pp_mark
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN4@kd_pp_mark:
	ret	0
??1kd_pp_marker_list@kd_pp_markers@@QAE@XZ ENDP		; kd_pp_markers::kd_pp_marker_list::~kd_pp_marker_list
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_pp_marker_list@kd_pp_markers@@QAE@AAVkd_marker@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_copy_source$ = 8					; size = 4
??0kd_pp_marker_list@kd_pp_markers@@QAE@AAVkd_marker@@@Z PROC ; kd_pp_markers::kd_pp_marker_list::kd_pp_marker_list, COMDAT
; _this$ = ecx

; 936  :             { next = NULL; }

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 935  :           kd_pp_marker_list(kd_marker &copy_source) : kd_marker(copy_source)

	push	DWORD PTR _copy_source$[ebp]

; 936  :             { next = NULL; }

	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	call	??0kd_marker@@QAE@ABV0@@Z		; kd_marker::kd_marker
	mov	DWORD PTR [esi+28], 0
	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0kd_pp_marker_list@kd_pp_markers@@QAE@AAVkd_marker@@@Z ENDP ; kd_pp_markers::kd_pp_marker_list::kd_pp_marker_list
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?ignore_tpart@kd_pp_markers@@QAEXXZ
_TEXT	SEGMENT
_e$2 = -56						; size = 20
_e$3 = -36						; size = 20
_len_bytes$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ignore_tpart@kd_pp_markers@@QAEXXZ PROC		; kd_pp_markers::ignore_tpart, COMDAT
; _this$ = ecx

; 1202 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ignore_tpart@kd_pp_markers@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1203 :   int xfer_bytes = INT_MAX;
; 1204 : 
; 1205 :   if (is_ppm)

	cmp	BYTE PTR [esi], 0
	mov	edi, 2147483647				; 7fffffffH
	je	SHORT $LN29@ignore_tpa

; 1206 :     {
; 1207 :       kdu_byte byte;
; 1208 : 
; 1209 :       int len_bytes = 0;

	mov	DWORD PTR _len_bytes$1$[ebp], 0
	npad	5
$LL2@ignore_tpa:

; 1211 :         { // Need to read 4 bytes of length information.
; 1212 :           if (list == NULL)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN7@ignore_tpa

; 1213 :             { KDU_ERROR(e,8); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0DI@CKEFAKFB@Insufficient?5packet?5header?5data?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1213 :             { KDU_ERROR(e,8); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1216 :             }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN7@ignore_tpa:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 884  :     int get_length() { return length; }

	mov	edx, DWORD PTR [esi+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1217 :           if (list->bytes_read == list->get_length())

	mov	ebx, DWORD PTR [edx+36]
	cmp	ebx, DWORD PTR [edx+12]
	jne	SHORT $LN8@ignore_tpa

; 1218 :             {
; 1219 :               advance_list();

	mov	ecx, esi
	call	?advance_list@kd_pp_markers@@AAEXXZ	; kd_pp_markers::advance_list

; 1220 :               continue;

	mov	eax, DWORD PTR _len_bytes$1$[ebp]
	jmp	SHORT $LN30@ignore_tpa
$LN8@ignore_tpa:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	eax, DWORD PTR [edx+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1223 :           xfer_bytes = (xfer_bytes << 8) + byte;

	shl	edi, 8
	mov	cl, BYTE PTR [ebx+eax]
	lea	eax, DWORD PTR [ebx+1]
	mov	DWORD PTR [edx+36], eax
	movzx	eax, cl
	add	edi, eax

; 1224 :           len_bytes++;

	mov	eax, DWORD PTR _len_bytes$1$[ebp]
	inc	eax
	mov	DWORD PTR _len_bytes$1$[ebp], eax
$LN30@ignore_tpa:

; 1210 :       while (len_bytes < 4)

	cmp	eax, 4
	jl	SHORT $LL2@ignore_tpa
$LN29@ignore_tpa:

; 1225 :         }
; 1226 :     }
; 1227 :   while ((list != NULL) && (xfer_bytes > 0))

	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN5@ignore_tpa
$LL4@ignore_tpa:
	test	edi, edi
	jle	SHORT $LN5@ignore_tpa
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 884  :     int get_length() { return length; }

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1229 :       int elt_bytes = list->get_length()-list->bytes_read;

	mov	eax, DWORD PTR [edx+36]
	sub	ecx, eax

; 1230 :       if (elt_bytes > xfer_bytes)

	cmp	ecx, edi
	cmovg	ecx, edi

; 1231 :         elt_bytes = xfer_bytes;
; 1232 :       xfer_bytes -= elt_bytes;
; 1233 :       list->bytes_read += elt_bytes;

	add	eax, ecx
	sub	edi, ecx
	mov	DWORD PTR [edx+36], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 884  :     int get_length() { return length; }

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1234 :       if (list->bytes_read == list->get_length())

	cmp	DWORD PTR [ecx+36], eax
	jne	SHORT $LN10@ignore_tpa

; 1235 :         advance_list();

	mov	ecx, esi
	call	?advance_list@kd_pp_markers@@AAEXXZ	; kd_pp_markers::advance_list
$LN10@ignore_tpa:

; 1225 :         }
; 1226 :     }
; 1227 :   while ((list != NULL) && (xfer_bytes > 0))

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LL4@ignore_tpa
$LN5@ignore_tpa:

; 1236 :     }
; 1237 :   if (is_ppm && (xfer_bytes > 0))

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN11@ignore_tpa
	test	edi, edi
	jle	SHORT $LN11@ignore_tpa

; 1238 :     { KDU_ERROR(e,9); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0FP@BOACKPIA@Insufficient?5packet?5header?5data?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1238 :     { KDU_ERROR(e,9); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1241 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN11@ignore_tpa:

; 1242 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ignore_tpart@kd_pp_markers@@QAEXXZ$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?ignore_tpart@kd_pp_markers@@QAEXXZ$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?ignore_tpart@kd_pp_markers@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ignore_tpart@kd_pp_markers@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ignore_tpart@kd_pp_markers@@QAEXXZ ENDP		; kd_pp_markers::ignore_tpart
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z
_TEXT	SEGMENT
_e$2 = -52						; size = 20
_e$3 = -32						; size = 20
_e$4 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_pph_input$ = 8						; size = 4
?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z PROC ; kd_pp_markers::transfer_tpart, COMDAT
; _this$ = ecx

; 1153 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1154 :   int xfer_bytes = INT_MAX;
; 1155 : 
; 1156 :   if (is_ppm)

	cmp	BYTE PTR [esi], 0
	mov	ebx, 2147483647				; 7fffffffH
	je	$LN35@transfer_t

; 1158 :       while ((list != NULL) && (list->bytes_read == list->get_length()))

	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN45@transfer_t
	npad	2
$LL2@transfer_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 884  :     int get_length() { return length; }

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1158 :       while ((list != NULL) && (list->bytes_read == list->get_length()))

	cmp	DWORD PTR [ecx+36], eax
	jne	SHORT $LN3@transfer_t

; 1159 :         advance_list();

	mov	ecx, esi
	call	?advance_list@kd_pp_markers@@AAEXXZ	; kd_pp_markers::advance_list
	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LL2@transfer_t
$LN3@transfer_t:

; 1160 :       if (list == NULL)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN7@transfer_t
$LN45@transfer_t:

; 1161 :         { KDU_ERROR(e,5); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0DI@CKEFAKFB@Insufficient?5packet?5header?5data?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1161 :         { KDU_ERROR(e,5); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1164 :         }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN7@transfer_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 884  :     int get_length() { return length; }

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1165 :       if ((list->get_length()-list->bytes_read) < 4)

	sub	ecx, DWORD PTR [eax+36]
	cmp	ecx, 4
	jge	SHORT $LN8@transfer_t

; 1166 :         { KDU_ERROR(e,6); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0KG@EMHBDNCD@Encountered?5malformed?5PPM?5marker@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1166 :         { KDU_ERROR(e,6); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1171 :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN8@transfer_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	ecx, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [ecx+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1173 :       xfer_bytes = data[list->bytes_read++];

	mov	eax, DWORD PTR [ecx+36]
	movzx	edx, BYTE PTR [eax+ebx]
	inc	eax
	mov	DWORD PTR [ecx+36], eax

; 1174 :       xfer_bytes = (xfer_bytes << 8) + data[list->bytes_read++];

	mov	ecx, DWORD PTR [esi+4]
	shl	edx, 8
	mov	eax, DWORD PTR [ecx+36]
	movzx	edi, BYTE PTR [eax+ebx]
	inc	eax
	mov	DWORD PTR [ecx+36], eax
	add	edi, edx

; 1175 :       xfer_bytes = (xfer_bytes << 8) + data[list->bytes_read++];

	mov	ecx, DWORD PTR [esi+4]
	shl	edi, 8
	mov	eax, DWORD PTR [ecx+36]
	movzx	edx, BYTE PTR [eax+ebx]
	inc	eax
	mov	DWORD PTR [ecx+36], eax
	add	edx, edi

; 1176 :       xfer_bytes = (xfer_bytes << 8) + data[list->bytes_read++];

	mov	ecx, DWORD PTR [esi+4]
	shl	edx, 8
	mov	eax, DWORD PTR [ecx+36]
	movzx	ebx, BYTE PTR [eax+ebx]
	add	ebx, edx
	inc	eax
	mov	DWORD PTR [ecx+36], eax
$LN35@transfer_t:

; 1177 :     }
; 1178 :   while ((list != NULL) && (xfer_bytes > 0))

	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN5@transfer_t
	npad	2
$LL4@transfer_t:
	test	ebx, ebx
	jle	SHORT $LN5@transfer_t
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 884  :     int get_length() { return length; }

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [eax+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1180 :       int elt_bytes = list->get_length()-list->bytes_read;

	mov	ecx, DWORD PTR [eax+36]
	sub	edi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	eax, DWORD PTR [eax+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1181 :       if (elt_bytes > xfer_bytes)

	cmp	edi, ebx
	cmovg	edi, ebx

; 1182 :         elt_bytes = xfer_bytes;
; 1183 :       pph_input->add_bytes(list->get_bytes()+list->bytes_read,elt_bytes);

	add	eax, ecx
	mov	ecx, DWORD PTR _pph_input$[ebp]
	push	edi
	push	eax
	call	?add_bytes@kd_pph_input@@QAEXPAEH@Z	; kd_pph_input::add_bytes

; 1184 :       xfer_bytes -= elt_bytes;
; 1185 :       list->bytes_read += elt_bytes;

	mov	eax, DWORD PTR [esi+4]
	sub	ebx, edi
	add	DWORD PTR [eax+36], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 884  :     int get_length() { return length; }

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1186 :       if (list->bytes_read == list->get_length())

	cmp	DWORD PTR [ecx+36], eax
	jne	SHORT $LN10@transfer_t

; 1187 :         advance_list();

	mov	ecx, esi
	call	?advance_list@kd_pp_markers@@AAEXXZ	; kd_pp_markers::advance_list
$LN10@transfer_t:

; 1177 :     }
; 1178 :   while ((list != NULL) && (xfer_bytes > 0))

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LL4@transfer_t
$LN5@transfer_t:

; 1188 :     }
; 1189 :   if (is_ppm && (xfer_bytes > 0))

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN11@transfer_t
	test	ebx, ebx
	jle	SHORT $LN11@transfer_t

; 1190 :     { KDU_ERROR(e,7); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0FP@BOACKPIA@Insufficient?5packet?5header?5data?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1190 :     { KDU_ERROR(e,7); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1193 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN11@transfer_t:

; 1194 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z$1:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z ENDP ; kd_pp_markers::transfer_tpart
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z
_TEXT	SEGMENT
_e$2 = -52						; size = 20
_e$3 = -32						; size = 20
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
_copy_source$ = 8					; size = 4
?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z PROC	; kd_pp_markers::add_marker, COMDAT
; _this$ = ecx

; 1105 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 884  :     int get_length() { return length; }

	mov	edi, DWORD PTR _copy_source$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1106 :   if (copy_source.get_length() < 1)

	cmp	DWORD PTR [edi+12], 1
	jge	SHORT $LN5@add_marker

; 1107 :     { KDU_ERROR(e,3); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0DH@CINALLDE@PPM?1PPT?5marker?5segments?5must?5be?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1107 :     { KDU_ERROR(e,3); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1109 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN5@add_marker:

; 1111 :     new kd_pp_marker_list(copy_source);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T4[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	esi, esi
	je	SHORT $LN13@add_marker
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 935  :           kd_pp_marker_list(kd_marker &copy_source) : kd_marker(copy_source)

	push	edi
	mov	ecx, esi
	call	??0kd_marker@@QAE@ABV0@@Z		; kd_marker::kd_marker

; 936  :             { next = NULL; }

	mov	DWORD PTR [esi+28], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1111 :     new kd_pp_marker_list(copy_source);

	jmp	SHORT $LN14@add_marker
$LN13@add_marker:
	xor	esi, esi
$LN14@add_marker:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	eax, DWORD PTR [esi+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1115 :   if (elt->get_code() == KDU_PPM)

	mov	ecx, 65376				; 0000ff60H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	movzx	eax, BYTE PTR [eax]
	mov	DWORD PTR [esi+32], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	movzx	eax, WORD PTR [esi+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1115 :   if (elt->get_code() == KDU_PPM)

	cmp	ax, cx
	mov	DWORD PTR [esi+36], 1
	sete	al

; 1116 :     {
; 1117 :       assert((list == NULL) || is_ppm);
; 1118 :       is_ppm = true;
; 1119 :     }
; 1120 :   else
; 1121 :     {
; 1122 :       assert(elt->get_code() == KDU_PPT);
; 1123 :       assert((list == NULL) || !is_ppm);
; 1124 :       is_ppm = false;
; 1125 :     }
; 1126 : 
; 1127 :   kd_pp_marker_list *scan, *prev;
; 1128 : 
; 1129 :   for (prev=NULL, scan=list; scan != NULL; prev=scan, scan=scan->next)

	xor	ecx, ecx
	mov	BYTE PTR [ebx], al
	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN32@add_marker

; 1130 :     if (scan->znum > elt->znum)

	mov	edx, DWORD PTR [esi+32]
$LL4@add_marker:
	cmp	DWORD PTR [eax+32], edx
	jg	SHORT $LN32@add_marker

; 1116 :     {
; 1117 :       assert((list == NULL) || is_ppm);
; 1118 :       is_ppm = true;
; 1119 :     }
; 1120 :   else
; 1121 :     {
; 1122 :       assert(elt->get_code() == KDU_PPT);
; 1123 :       assert((list == NULL) || !is_ppm);
; 1124 :       is_ppm = false;
; 1125 :     }
; 1126 : 
; 1127 :   kd_pp_marker_list *scan, *prev;
; 1128 : 
; 1129 :   for (prev=NULL, scan=list; scan != NULL; prev=scan, scan=scan->next)

	mov	ecx, eax
	mov	eax, DWORD PTR [eax+28]
	test	eax, eax
	jne	SHORT $LL4@add_marker
$LN32@add_marker:

; 1131 :       break;
; 1132 :   elt->next = scan;

	mov	DWORD PTR [esi+28], eax

; 1133 :   if (prev == NULL)

	test	ecx, ecx
	jne	SHORT $LN9@add_marker

; 1134 :     list = elt;

	mov	DWORD PTR [ebx+4], esi

; 1144 :     }
; 1145 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN9@add_marker:

; 1135 :   else
; 1136 :     {
; 1137 :       prev->next = elt;
; 1138 :       if (prev->znum == elt->znum)

	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [ecx+28], esi
	cmp	eax, DWORD PTR [esi+32]
	jne	SHORT $LN11@add_marker

; 1139 :         { KDU_ERROR(e,4); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0IB@IHNJIGBG@Found?5multiple?5PPM?1PPT?5marker?5se@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1139 :         { KDU_ERROR(e,4); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1143 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN11@add_marker:

; 1144 :     }
; 1145 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z$1:
	push	40					; 00000028H
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z$2:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z ENDP	; kd_pp_markers::add_marker
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ??1kd_pp_markers@@QAE@XZ
_TEXT	SEGMENT
??1kd_pp_markers@@QAE@XZ PROC				; kd_pp_markers::~kd_pp_markers, COMDAT
; _this$ = ecx

; 1090 : {

	push	esi
	push	edi
	mov	edi, ecx

; 1092 :   while ((tmp=list) != NULL)

	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $LN3@kd_pp_mark
	npad	5
$LL2@kd_pp_mark:

; 1093 :     {
; 1094 :       list = tmp->next;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [edi+4], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN15@kd_pp_mark
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN15@kd_pp_mark:
	push	40					; 00000028H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1092 :   while ((tmp=list) != NULL)

	mov	esi, DWORD PTR [edi+4]
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL2@kd_pp_mark
$LN3@kd_pp_mark:
	pop	edi
	pop	esi

; 1095 :       delete tmp;
; 1096 :     }
; 1097 : }

	ret	0
??1kd_pp_markers@@QAE@XZ ENDP				; kd_pp_markers::~kd_pp_markers
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_pp_markers@@QAE@XZ
_TEXT	SEGMENT
??0kd_pp_markers@@QAE@XZ PROC				; kd_pp_markers::kd_pp_markers, COMDAT
; _this$ = ecx

; 912  :       { list = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	ret	0
??0kd_pp_markers@@QAE@XZ ENDP				; kd_pp_markers::kd_pp_markers
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Gkd_marker@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_marker@@QAEPAXI@Z PROC				; kd_marker::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN5@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN8@scalar
	push	28					; 0000001cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_marker@@QAEPAXI@Z ENDP				; kd_marker::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_bytes@kd_marker@@QAEPAEXZ
_TEXT	SEGMENT
?get_bytes@kd_marker@@QAEPAEXZ PROC			; kd_marker::get_bytes, COMDAT
; _this$ = ecx

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	eax, DWORD PTR [ecx+20]
	ret	0
?get_bytes@kd_marker@@QAEPAEXZ ENDP			; kd_marker::get_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_length@kd_marker@@QAEHXZ
_TEXT	SEGMENT
?get_length@kd_marker@@QAEHXZ PROC			; kd_marker::get_length, COMDAT
; _this$ = ecx

; 884  :     int get_length() { return length; }

	mov	eax, DWORD PTR [ecx+12]
	ret	0
?get_length@kd_marker@@QAEHXZ ENDP			; kd_marker::get_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_code@kd_marker@@QAEGXZ
_TEXT	SEGMENT
?get_code@kd_marker@@QAEGXZ PROC			; kd_marker::get_code, COMDAT
; _this$ = ecx

; 882  :     kdu_uint16 get_code() { return code; }

	mov	ax, WORD PTR [ecx+8]
	ret	0
?get_code@kd_marker@@QAEGXZ ENDP			; kd_marker::get_code
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?read@kd_marker@@QAE_N_N0@Z
_TEXT	SEGMENT
_w$2 = -60						; size = 20
_w$3 = -60						; size = 20
_w$4 = -60						; size = 20
_w$5 = -60						; size = 20
_w$6 = -40						; size = 20
_byte$ = -17						; size = 1
_force_skip$1$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_exclude_stuff_bytes$ = 8				; size = 1
_skip_to_marker$ = 12					; size = 1
?read@kd_marker@@QAE_N_N0@Z PROC			; kd_marker::read, COMDAT
; _this$ = ecx

; 934  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read@kd_marker@@QAE_N_N0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 935  :   assert(source != NULL);
; 936  :   kdu_byte byte = 0;
; 937  :   bool valid_code, force_skip;
; 938  : 
; 939  :   source->disable_marker_throwing();

	mov	eax, DWORD PTR [edi]
	xor	bl, bl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 514  :         if (!throw_markers) return true;

	cmp	BYTE PTR [eax+534], bl
	je	SHORT $LL4@read

; 515  :         throw_markers = false; // Must not touch `reject_all' here.

	mov	BYTE PTR [eax+534], bl

; 516  :         if (exhausted) have_FF = false;

	cmp	BYTE PTR [eax+533], bl
	je	SHORT $LL4@read
	mov	BYTE PTR [eax+535], bl
	npad	6
$LL4@read:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 941  :       force_skip = false;

	mov	BYTE PTR _force_skip$1$[ebp], 0

; 942  :       if ((byte != 0xFF) && !source->get(byte))

	cmp	bl, 255					; 000000ffH
	je	SHORT $LN53@read
	mov	esi, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))

	cmp	BYTE PTR [esi+533], 0
	jne	$LN63@read
	mov	eax, DWORD PTR [esi+524]
	cmp	eax, DWORD PTR [esi+528]
	jne	SHORT $LN51@read
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	$LN63@read
$LN51@read:

; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.
; 535  :         byte = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	mov	bl, BYTE PTR [eax]
	inc	eax

; 536  :         if (throw_markers)

	cmp	BYTE PTR [esi+534], 0
	mov	BYTE PTR _byte$[ebp], bl
	mov	DWORD PTR [esi+524], eax
	je	SHORT $LN53@read

; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [esi+535], 0
	je	SHORT $LN54@read
	cmp	bl, 143					; 0000008fH
	jbe	SHORT $LN54@read

; 539  :               process_unexpected_marker(byte);

	push	DWORD PTR _byte$[ebp]
	mov	ecx, esi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
$LN54@read:

; 540  :             have_FF = (byte==0xFF);

	cmp	bl, 255					; 000000ffH
	sete	al
	mov	BYTE PTR [esi+535], al
$LN53@read:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 944  :       if (skip_to_marker)

	cmp	BYTE PTR _skip_to_marker$[ebp], 0
	je	SHORT $LN6@read

; 945  :         while (byte != 0xFF)

	cmp	bl, 255					; 000000ffH
	je	SHORT $LN131@read
$LL5@read:

; 946  :           if (!source->get(byte))

	mov	esi, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))

	cmp	BYTE PTR [esi+533], 0
	jne	$LN63@read
	mov	eax, DWORD PTR [esi+524]
	cmp	eax, DWORD PTR [esi+528]
	jne	SHORT $LN57@read
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	$LN63@read
$LN57@read:

; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.
; 535  :         byte = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	mov	bl, BYTE PTR [eax]
	inc	eax

; 536  :         if (throw_markers)

	cmp	BYTE PTR [esi+534], 0
	mov	BYTE PTR _byte$[ebp], bl
	mov	DWORD PTR [esi+524], eax
	je	SHORT $LN59@read

; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [esi+535], 0
	je	SHORT $LN60@read
	cmp	bl, 143					; 0000008fH
	jbe	SHORT $LN60@read

; 539  :               process_unexpected_marker(byte);

	push	DWORD PTR _byte$[ebp]
	mov	ecx, esi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
$LN60@read:

; 540  :             have_FF = (byte==0xFF);

	cmp	bl, 255					; 000000ffH
	sete	al
	mov	BYTE PTR [esi+535], al
$LN59@read:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 945  :         while (byte != 0xFF)

	cmp	bl, 255					; 000000ffH
	jne	SHORT $LL5@read

; 947  :             { code = 0; length = 0; return false; }
; 948  :       if (byte != 0xFF)

	jmp	SHORT $LN131@read
$LN6@read:
	cmp	bl, 255					; 000000ffH
	jne	$LN118@read
$LN131@read:

; 952  :         }
; 953  :       if (!source->get(byte))

	mov	esi, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))

	cmp	BYTE PTR [esi+533], 0
	jne	$LN63@read
	mov	eax, DWORD PTR [esi+524]
	cmp	eax, DWORD PTR [esi+528]
	jne	SHORT $LN66@read
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	$LN63@read
$LN66@read:

; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.
; 535  :         byte = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	mov	bl, BYTE PTR [eax]
	inc	eax

; 536  :         if (throw_markers)

	cmp	BYTE PTR [esi+534], 0
	mov	BYTE PTR _byte$[ebp], bl
	mov	DWORD PTR [esi+524], eax
	je	SHORT $LN68@read

; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [esi+535], 0
	je	SHORT $LN69@read
	cmp	bl, 143					; 0000008fH
	jbe	SHORT $LN69@read

; 539  :               process_unexpected_marker(byte);

	push	DWORD PTR _byte$[ebp]
	mov	ecx, esi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
$LN69@read:

; 540  :             have_FF = (byte==0xFF);

	cmp	bl, 255					; 000000ffH
	sete	al
	mov	BYTE PTR [esi+535], al
$LN68@read:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 955  :       code = 0xFF00 + byte;

	movzx	eax, bl
	mov	ecx, 256				; 00000100H
	sub	ax, cx

; 956  :       valid_code = true;

	mov	bh, 1

; 957  :       if (exclude_stuff_bytes)

	cmp	BYTE PTR _exclude_stuff_bytes$[ebp], 0
	mov	WORD PTR [edi+8], ax
	je	SHORT $LN12@read

; 958  :         valid_code = (byte > 0x8F);

	cmp	bl, 143					; 0000008fH
	seta	bh
$LN12@read:

; 959  :       if ((code == KDU_SOP) || (code == KDU_SOT))

	mov	ecx, 65425				; 0000ff91H
	cmp	ax, cx
	je	$LN15@read
	mov	esi, 65424				; 0000ff90H
	cmp	ax, si
	je	$LN15@read

; 983  :         }
; 984  :       else if (code == KDU_EOC)

	mov	ecx, 65497				; 0000ffd9H
	cmp	ax, cx
	jne	SHORT $LN21@read

; 985  :         { /* If the input source is about to end, we will simply skip over
; 986  :              the EOC marker so that true EOC termination can be treated in
; 987  :              the same way as premature termination of the code-stream.
; 988  :              Otherwise, the EOC marker would appear to have been generated
; 989  :              by some type of code-stream corruption.  In this case, we will
; 990  :              treat it as an invalid marker code. */
; 991  :           if (source->get(byte))

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR _byte$[ebp]
	push	eax
	call	?get@kd_input@@QAE_NAAE@Z		; kd_input::get
	test	al, al
	je	$LN23@read

; 992  :             {
; 993  :               if (!codestream->resilient)

	mov	eax, DWORD PTR [edi+4]
	cmp	BYTE PTR [eax+332], 0

; 1002 :               source->putback(byte);

	mov	eax, DWORD PTR [edi]
	je	$LN120@read
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 550  :         first_unread--;

	dec	DWORD PTR [eax+524]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1001 :               valid_code = false;

	xor	bh, bh
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 550  :         first_unread--;

	mov	ecx, DWORD PTR [eax+524]

; 551  :         if (!fully_buffered)

	cmp	BYTE PTR [eax+532], bh
	jne	SHORT $LN99@read

; 552  :           {
; 553  :             assert(first_unread >= buffer);
; 554  :             *first_unread = byte;

	mov	al, BYTE PTR _byte$[ebp]
	mov	BYTE PTR [ecx], al
$LN99@read:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1003 :               byte = (kdu_byte) code;

	mov	bl, BYTE PTR [edi+8]

; 1004 :               KDU_WARNING(w,2); w <<

	lea	ecx, DWORD PTR _w$3[ebp]
	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	mov	BYTE PTR _byte$[ebp], bl
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$3[ebp]
	lea	ecx, DWORD PTR _w$3[ebp]
	push	OFFSET ??_C@_0CG@FBIDHMHH@Disregarding?5non?9terminal?5EOC?5ma@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1004 :               KDU_WARNING(w,2); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1006 :             }

	lea	ecx, DWORD PTR _w$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning

; 1007 :           else
; 1008 :             { length = 0; code = 0; return false; }

	jmp	$LN150@read
$LN21@read:

; 1009 :         }
; 1010 :       else if (valid_code && (code >= 0xFF30) && (code <= 0xFF3F))

	test	bh, bh
	je	$LN150@read
	add	eax, 208				; 000000d0H
	cmp	ax, 15					; 0000000fH
	ja	$LN150@read

; 1011 :         { // These codes are all to be skipped.
; 1012 :           valid_code = false;
; 1013 :           byte = 0;

	xor	bl, bl
	xor	bh, bh
	mov	BYTE PTR _byte$[ebp], bl

; 1014 :           if (!encountered_skip_code)

	cmp	BYTE PTR [edi+24], bl
	jne	SHORT $LN27@read

; 1015 :             { KDU_WARNING_DEV(w,3); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$2[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$2[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	OFFSET ??_C@_0FO@JCNPOBGN@Encountered?5one?5or?5more?5marker?5c@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1015 :             { KDU_WARNING_DEV(w,3); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1018 :             }

	lea	ecx, DWORD PTR _w$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN27@read:

; 1019 :           encountered_skip_code = true;

	mov	BYTE PTR [edi+24], 1

; 1020 :           force_skip = true;

	mov	al, 1
	jmp	$LN2@read
$LN15@read:

; 960  :         { // Want to be really sure that this is not a corrupt marker code.
; 961  :           assert(valid_code);
; 962  :           if (!source->get(byte))

	mov	esi, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))

	cmp	BYTE PTR [esi+533], 0
	jne	$LN63@read
	mov	eax, DWORD PTR [esi+524]
	cmp	eax, DWORD PTR [esi+528]
	jne	SHORT $LN72@read
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	$LN63@read
$LN72@read:

; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.
; 535  :         byte = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	mov	bl, BYTE PTR [eax]
	inc	eax

; 536  :         if (throw_markers)

	cmp	BYTE PTR [esi+534], 0
	mov	BYTE PTR _byte$[ebp], bl
	mov	DWORD PTR [esi+524], eax
	je	SHORT $LN74@read

; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [esi+535], 0
	je	SHORT $LN75@read
	cmp	bl, 143					; 0000008fH
	jbe	SHORT $LN75@read

; 539  :               process_unexpected_marker(byte);

	push	DWORD PTR _byte$[ebp]
	mov	ecx, esi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
$LN75@read:

; 540  :             have_FF = (byte==0xFF);

	cmp	bl, 255					; 000000ffH
	sete	al
	mov	BYTE PTR [esi+535], al
$LN74@read:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 965  :           if (!source->get(byte))

	mov	esi, DWORD PTR [edi]
	movzx	eax, bl
	shl	eax, 8
	mov	DWORD PTR [edi+12], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))

	cmp	BYTE PTR [esi+533], 0
	jne	$LN63@read
	mov	eax, DWORD PTR [esi+524]
	cmp	eax, DWORD PTR [esi+528]
	jne	SHORT $LN78@read
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	$LN63@read
$LN78@read:

; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.
; 535  :         byte = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	mov	bl, BYTE PTR [eax]
	inc	eax

; 536  :         if (throw_markers)

	cmp	BYTE PTR [esi+534], 0
	mov	BYTE PTR _byte$[ebp], bl
	mov	DWORD PTR [esi+524], eax
	je	SHORT $LN80@read

; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [esi+535], 0
	je	SHORT $LN81@read
	cmp	bl, 143					; 0000008fH
	jbe	SHORT $LN81@read

; 539  :               process_unexpected_marker(byte);

	push	DWORD PTR _byte$[ebp]
	mov	ecx, esi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
$LN81@read:

; 540  :             have_FF = (byte==0xFF);

	cmp	bl, 255					; 000000ffH
	sete	al
	mov	BYTE PTR [esi+535], al
$LN80@read:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 968  :           if ((code == KDU_SOP) && (length != 4))

	movzx	ecx, WORD PTR [edi+8]
	mov	edx, 65425				; 0000ff91H
	movzx	eax, bl
	add	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+12]
	cmp	cx, dx
	jne	SHORT $LN18@read
	cmp	eax, 4
	je	SHORT $LN18@read

; 969  :             {
; 970  :               valid_code = false;
; 971  :               source->putback((kdu_uint16) length);

	mov	ecx, DWORD PTR [edi]
	xor	bh, bh
	movzx	edx, ax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 563  :         first_unread-=2;

	add	DWORD PTR [ecx+524], -2			; fffffffeH
	mov	esi, DWORD PTR [ecx+524]

; 564  :         if (!fully_buffered)

	cmp	BYTE PTR [ecx+532], bh
	jne	SHORT $LN84@read

; 565  :           {
; 566  :             assert(first_unread >= buffer);
; 567  :             first_unread[0] = (kdu_byte)(code>>8);

	mov	eax, edx
	shr	eax, 8
	mov	BYTE PTR [esi], al

; 568  :             first_unread[1] = (kdu_byte) code;

	mov	eax, DWORD PTR [ecx+524]
	mov	BYTE PTR [eax+1], dl
$LN84@read:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 972  :               KDU_WARNING(w,0); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$5[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0CH@FKDCCKNG@Skipping?5over?5corrupt?5SOP?5marker@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 974  :             }

	jmp	SHORT $LN153@read
$LN18@read:

; 975  :           else if ((code == KDU_SOT) && (length != 10))

	mov	esi, 65424				; 0000ff90H
	cmp	cx, si
	jne	SHORT $LN20@read
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN20@read

; 976  :             {
; 977  :               valid_code = false;
; 978  :               source->putback((kdu_uint16) length);

	mov	ecx, DWORD PTR [edi]
	xor	bh, bh
	movzx	edx, WORD PTR [edi+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 563  :         first_unread-=2;

	add	DWORD PTR [ecx+524], -2			; fffffffeH
	mov	esi, DWORD PTR [ecx+524]

; 564  :         if (!fully_buffered)

	cmp	BYTE PTR [ecx+532], bh
	jne	SHORT $LN89@read

; 565  :           {
; 566  :             assert(first_unread >= buffer);
; 567  :             first_unread[0] = (kdu_byte)(code>>8);

	mov	eax, edx
	shr	eax, 8
	mov	BYTE PTR [esi], al

; 568  :             first_unread[1] = (kdu_byte) code;

	mov	eax, DWORD PTR [ecx+524]
	mov	BYTE PTR [eax+1], dl
$LN89@read:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 979  :               KDU_WARNING(w,1); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$4[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0CH@NAEOEPLF@Skipping?5over?5corrupt?5SOT?5marker@
$LN153@read:
	mov	eax, DWORD PTR _w$4[ebp]
	lea	ecx, DWORD PTR _w$4[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 981  :             }

	lea	ecx, DWORD PTR _w$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
	mov	esi, 65424				; 0000ff90H
$LN20@read:

; 982  :           byte = (kdu_byte) code;

	mov	bl, BYTE PTR [edi+8]
	mov	BYTE PTR _byte$[ebp], bl
$LN150@read:
	mov	al, BYTE PTR _force_skip$1$[ebp]
$LN2@read:

; 1021 :         }
; 1022 :     } while ((skip_to_marker || force_skip) && (!valid_code));

	cmp	BYTE PTR _skip_to_marker$[ebp], 0
	jne	SHORT $LN29@read
	test	al, al
	je	$LN28@read
$LN29@read:
	test	bh, bh
	je	$LL4@read
$LN30@read:

; 1029 :     }
; 1030 : 
; 1031 :   // Now we are committed to processing the marker, returning false only if
; 1032 :   // the source becomes exhausted.
; 1033 : 
; 1034 :   if ((code == KDU_SOC) || (code == KDU_SOD) ||
; 1035 :       (code == KDU_EOC) || (code == KDU_EPH))

	movzx	eax, WORD PTR [edi+8]
	mov	ecx, 65359				; 0000ff4fH
	cmp	ax, cx
	je	$LN32@read
	mov	ecx, 65427				; 0000ff93H
	cmp	ax, cx
	je	$LN32@read
	mov	ecx, 65497				; 0000ffd9H
	cmp	ax, cx
	je	$LN32@read
	mov	ecx, 65426				; 0000ff92H
	cmp	ax, cx
	je	$LN32@read

; 1036 :     return true; // Delimiter found. There is no marker segment.
; 1037 :   if ((code != KDU_SOT) && (code != KDU_SOP) && (code != KDU_SIZ) &&
; 1038 :       (code != KDU_CBD) && (code != KDU_MCT) &&
; 1039 :       (code != KDU_MCC) && (code != KDU_MCO) &&
; 1040 :       (code != KDU_COD) && (code != KDU_COC) &&
; 1041 :       (code != KDU_ADS) && (code != KDU_DFS) && (code != KDU_ATK) &&
; 1042 :       (code != KDU_QCD) && (code != KDU_QCC) &&
; 1043 :       (code != KDU_RGN) && (code != KDU_POC) &&
; 1044 :       (code != KDU_CRG) && (code != KDU_COM) &&
; 1045 :       (code != KDU_TLM) && (code != KDU_PLM) && (code != KDU_PLT) &&
; 1046 :       (code != KDU_PPM) && (code != KDU_PPT))

	lea	ebx, DWORD PTR [ecx-1]
	cmp	ax, si
	je	$LN33@read
	cmp	ax, bx
	je	$LN33@read
	mov	ecx, 65361				; 0000ff51H
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65400				; 0000ff78H
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65396				; 0000ff74H
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65397				; 0000ff75H
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65399				; 0000ff77H
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65362				; 0000ff52H
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65363				; 0000ff53H
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65395				; 0000ff73H
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65394				; 0000ff72H
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65401				; 0000ff79H
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65372				; 0000ff5cH
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65373				; 0000ff5dH
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65374				; 0000ff5eH
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65375				; 0000ff5fH
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65379				; 0000ff63H
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65380				; 0000ff64H
	cmp	ax, cx
	je	$LN33@read
	mov	ecx, 65365				; 0000ff55H
	cmp	ax, cx
	je	SHORT $LN33@read
	mov	ecx, 65367				; 0000ff57H
	cmp	ax, cx
	je	SHORT $LN33@read
	mov	ecx, 65368				; 0000ff58H
	cmp	ax, cx
	je	SHORT $LN33@read
	mov	ecx, 65376				; 0000ff60H
	cmp	ax, cx
	je	SHORT $LN33@read
	mov	ecx, 65377				; 0000ff61H
	cmp	ax, cx
	je	SHORT $LN33@read

; 1048 :       KDU_WARNING_DEV(w,4); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$6[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$6[ebp]
	lea	ecx, DWORD PTR _w$6[ebp]
	push	OFFSET ??_C@_0CJ@GCHDIIBC@Unrecognized?1unimplemented?5marke@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1048 :       KDU_WARNING_DEV(w,4); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 851  :         print_marker_code(this->code,out);

	lea	eax, DWORD PTR _w$6[ebp]
	push	eax
	movzx	eax, WORD PTR [edi+8]
	push	eax
	call	?print_marker_code@@YAXGAAVkdu_message@@@Z ; print_marker_code
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$6[ebp]
	lea	ecx, DWORD PTR _w$6[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 851  :         print_marker_code(this->code,out);

	add	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0BI@PDKABIHP@?0?5found?5in?5code?9stream?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1052 :     }

	lea	ecx, DWORD PTR _w$6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN33@read:

; 1053 :   if ((code != KDU_SOP) && (code != KDU_SOT))

	movzx	eax, WORD PTR [edi+8]
	cmp	ax, bx
	je	SHORT $LN34@read
	cmp	ax, si
	je	SHORT $LN34@read

; 1054 :     { // Otherwise, we already have the length.
; 1055 :       if (!source->get(byte))

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR _byte$[ebp]
	push	eax
	call	?get@kd_input@@QAE_NAAE@Z		; kd_input::get
	test	al, al
	je	$LN155@read

; 1056 :         { code = 0; return false; }
; 1057 :       length = byte; length <<= 8;

	movzx	eax, BYTE PTR _byte$[ebp]

; 1058 :       if (!source->get(byte))

	mov	ecx, DWORD PTR [edi]
	shl	eax, 8
	mov	DWORD PTR [edi+12], eax
	lea	eax, DWORD PTR _byte$[ebp]
	push	eax
	call	?get@kd_input@@QAE_NAAE@Z		; kd_input::get
	test	al, al
	je	$LN63@read

; 1059 :         { code = 0; length = 0; return false; }
; 1060 :       length += byte;

	movzx	eax, BYTE PTR _byte$[ebp]
	add	DWORD PTR [edi+12], eax
$LN34@read:

; 1061 :     }
; 1062 :   length -= 2;

	mov	eax, DWORD PTR [edi+12]
	sub	eax, 2
	mov	DWORD PTR [edi+12], eax

; 1063 :   if (length < 0)

	js	$LN63@read

; 1064 :     { code = 0; length = 0; return false; }
; 1065 :   if (length > max_length)

	cmp	eax, DWORD PTR [edi+16]
	jle	SHORT $LN38@read

; 1066 :     {
; 1067 :       max_length = 2*length; // Don't want to have to re-allocate too often
; 1068 :       delete[] buf;

	push	DWORD PTR [edi+20]
	add	eax, eax
	mov	DWORD PTR [edi+16], eax
	call	??_V@YAXPAX@Z				; operator delete[]

; 1069 :       buf = NULL;
; 1070 :       buf = new kdu_byte[max_length];

	push	DWORD PTR [edi+16]
	mov	DWORD PTR [edi+20], 0
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 8
	mov	DWORD PTR [edi+20], eax
$LN38@read:

; 1071 :     }
; 1072 :   if (source->read(buf,length) < length)

	push	DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi]
	push	DWORD PTR [edi+20]
	call	?read@kd_input@@QAEHPAEH@Z		; kd_input::read
	cmp	eax, DWORD PTR [edi+12]
	jl	$LN63@read
$LN32@read:

; 1073 :     {
; 1074 :       code = 0; length = 0;
; 1075 :       return false;
; 1076 :     }
; 1077 :   return true;

	mov	al, 1

; 1078 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN120@read:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 550  :         first_unread--;

	mov	ecx, DWORD PTR [eax+524]
	dec	ecx

; 551  :         if (!fully_buffered)

	cmp	BYTE PTR [eax+532], 0
	mov	DWORD PTR [eax+524], ecx
	jne	SHORT $LN94@read

; 552  :           {
; 553  :             assert(first_unread >= buffer);
; 554  :             *first_unread = byte;

	mov	al, BYTE PTR _byte$[ebp]
	mov	BYTE PTR [ecx], al
$LN94@read:

; 517  :         return !have_FF;
; 518  :       }
; 519  :     void terminate_prematurely()
; 520  :       { /* This function may be called in non-resilient mode if an EOC marker
; 521  :            is encountered before the stream physically ends. */
; 522  :         exhausted = true;

	mov	eax, DWORD PTR [edi]
	mov	BYTE PTR [eax+533], 1
$LN23@read:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 997  :                   length = 0; code = 0;

	mov	DWORD PTR [edi+12], 0
$LN155@read:
	xor	eax, eax

; 998  :                   return false;

	jmp	SHORT $LN154@read
$LN28@read:

; 1023 : 
; 1024 :   if (!valid_code)

	test	bh, bh
	jne	$LN30@read

; 1025 :     {
; 1026 :       source->putback(code);

	mov	ecx, DWORD PTR [edi]
	movzx	ebx, WORD PTR [edi+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 563  :         first_unread-=2;

	mov	edx, DWORD PTR [ecx+524]
	sub	edx, 2

; 564  :         if (!fully_buffered)

	cmp	BYTE PTR [ecx+532], 0
	mov	DWORD PTR [ecx+524], edx
	jne	SHORT $LN63@read

; 565  :           {
; 566  :             assert(first_unread >= buffer);
; 567  :             first_unread[0] = (kdu_byte)(code>>8);

	mov	eax, ebx
	shr	eax, 8
	mov	BYTE PTR [edx], al

; 568  :             first_unread[1] = (kdu_byte) code;

	mov	eax, DWORD PTR [ecx+524]
	mov	BYTE PTR [eax+1], bl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1028 :       return false;

	jmp	SHORT $LN63@read
$LN118@read:

; 949  :         {
; 950  :           source->putback(byte);

	mov	eax, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 550  :         first_unread--;

	mov	ecx, DWORD PTR [eax+524]
	dec	ecx

; 551  :         if (!fully_buffered)

	cmp	BYTE PTR [eax+532], 0
	mov	DWORD PTR [eax+524], ecx
	jne	SHORT $LN63@read

; 552  :           {
; 553  :             assert(first_unread >= buffer);
; 554  :             *first_unread = byte;

	mov	BYTE PTR [ecx], bl
$LN63@read:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 951  :           code = 0; length = 0; return false;

	xor	eax, eax
	mov	DWORD PTR [edi+12], eax
$LN154@read:
	mov	WORD PTR [edi+8], ax
	xor	al, al

; 1078 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read@kd_marker@@QAE_N_N0@Z$2:
	lea	ecx, DWORD PTR _w$3[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?read@kd_marker@@QAE_N_N0@Z$3:
	lea	ecx, DWORD PTR _w$2[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?read@kd_marker@@QAE_N_N0@Z$0:
	lea	ecx, DWORD PTR _w$5[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?read@kd_marker@@QAE_N_N0@Z$1:
	lea	ecx, DWORD PTR _w$4[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?read@kd_marker@@QAE_N_N0@Z$4:
	lea	ecx, DWORD PTR _w$6[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__ehhandler$?read@kd_marker@@QAE_N_N0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read@kd_marker@@QAE_N_N0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read@kd_marker@@QAE_N_N0@Z ENDP			; kd_marker::read
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?print_current_code@kd_marker@@QAEXAAVkdu_message@@@Z
_TEXT	SEGMENT
_out$ = 8						; size = 4
?print_current_code@kd_marker@@QAEXAAVkdu_message@@@Z PROC ; kd_marker::print_current_code, COMDAT
; _this$ = ecx

; 850  :       { /* Prints a text string identifying the current marker code. */

	push	ebp
	mov	ebp, esp

; 851  :         print_marker_code(this->code,out);

	push	DWORD PTR _out$[ebp]
	movzx	eax, WORD PTR [ecx+8]
	push	eax
	call	?print_marker_code@@YAXGAAVkdu_message@@@Z ; print_marker_code
	add	esp, 8

; 852  :       }

	pop	ebp
	ret	4
?print_current_code@kd_marker@@QAEXAAVkdu_message@@@Z ENDP ; kd_marker::print_current_code
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?move@kd_marker@@QAEPAV1@PAVkd_input@@PAUkd_codestream@@@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
_cs$ = 12						; size = 4
?move@kd_marker@@QAEPAV1@PAVkd_input@@PAUkd_codestream@@@Z PROC ; kd_marker::move, COMDAT
; _this$ = ecx

; 845  :       { this->source = input; this->codestream = cs; return this; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _cs$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebp
	ret	8
?move@kd_marker@@QAEPAV1@PAVkd_input@@PAUkd_codestream@@@Z ENDP ; kd_marker::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_marker@@QAE@XZ
_TEXT	SEGMENT
??1kd_marker@@QAE@XZ PROC				; kd_marker::~kd_marker, COMDAT
; _this$ = ecx

; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN2@kd_marker
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN2@kd_marker:
	ret	0
??1kd_marker@@QAE@XZ ENDP				; kd_marker::~kd_marker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ??0kd_marker@@QAE@ABV0@@Z
_TEXT	SEGMENT
_orig$ = 8						; size = 4
??0kd_marker@@QAE@ABV0@@Z PROC				; kd_marker::kd_marker, COMDAT
; _this$ = ecx

; 914  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 915  :   source = NULL;
; 916  :   codestream = orig.codestream;

	mov	edi, DWORD PTR _orig$[ebp]
	mov	DWORD PTR [esi], 0
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax

; 917  :   code = orig.code;

	mov	ax, WORD PTR [edi+8]
	mov	WORD PTR [esi+8], ax

; 918  :   max_length = length = orig.length;

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 919  :   buf = NULL;

	mov	DWORD PTR [esi+20], 0

; 920  :   if (max_length > 0)

	test	eax, eax
	jle	SHORT $LN4@kd_marker

; 921  :     {
; 922  :       buf = new kdu_byte[max_length];

	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 923  :       memcpy(buf,orig.buf,(size_t) length);

	push	DWORD PTR [esi+12]
	mov	DWORD PTR [esi+20], eax
	push	DWORD PTR [edi+20]
	push	eax
	call	_memcpy
	add	esp, 16					; 00000010H
$LN4@kd_marker:

; 924  :     }
; 925  :   encountered_skip_code = false;
; 926  : }

	pop	edi
	mov	eax, esi
	mov	BYTE PTR [esi+24], 0
	pop	esi
	pop	ebp
	ret	4
??0kd_marker@@QAE@ABV0@@Z ENDP				; kd_marker::kd_marker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_marker@@QAE@PAVkd_input@@PAUkd_codestream@@@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
_cs$ = 12						; size = 4
??0kd_marker@@QAE@PAVkd_input@@PAUkd_codestream@@@Z PROC ; kd_marker::kd_marker, COMDAT
; _this$ = ecx

; 835  :     kd_marker(kd_input *input, kd_codestream *cs)

	push	ebp
	mov	ebp, esp

; 836  :       { this->source = input; this->codestream = cs;

	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _cs$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 837  :         code = 0; length = 0; max_length = 0; buf = NULL;

	xor	eax, eax
	mov	WORD PTR [ecx+8], ax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+20], eax

; 838  :         encountered_skip_code = false; }

	mov	BYTE PTR [ecx+24], al
	mov	eax, ecx
	pop	ebp
	ret	8
??0kd_marker@@QAE@PAVkd_input@@PAUkd_codestream@@@Z ENDP ; kd_marker::kd_marker
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_pph_input@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_pph_input@@UAEPAXI@Z PROC			; kd_pph_input::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_pph_input@@UAE@XZ			; kd_pph_input::~kd_pph_input
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	564					; 00000234H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_pph_input@@UAEPAXI@Z ENDP			; kd_pph_input::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?load_buf@kd_pph_input@@MAE_NXZ
_TEXT	SEGMENT
?load_buf@kd_pph_input@@MAE_NXZ PROC			; kd_pph_input::load_buf, COMDAT
; _this$ = ecx

; 872  :   if (read_buf == NULL)

	cmp	DWORD PTR [ecx+544], 0
	jne	SHORT $LN6@load_buf
$LN24@load_buf:

; 873  :     { exhausted = true; return false; }

	mov	BYTE PTR [ecx+533], 1
	xor	al, al

; 903  : }

	ret	0
$LN6@load_buf:
	push	ebx

; 874  : 
; 875  :   first_unread = first_unwritten = buffer + KD_IBUF_PUTBACK;

	lea	eax, DWORD PTR [ecx+10]

; 876  :   int xfer_bytes = KD_IBUF_SIZE - KD_IBUF_PUTBACK;

	mov	ebx, 506				; 000001faH
	push	esi
	push	edi
	mov	DWORD PTR [ecx+528], eax
	mov	DWORD PTR [ecx+524], eax
	npad	6
$LL2@load_buf:

; 879  :     {
; 880  :       if (read_pos == KD_CODE_BUFFER_LEN)

	cmp	DWORD PTR [ecx+552], 58			; 0000003aH
	jne	SHORT $LN8@load_buf

; 881  :         {
; 882  :           if (read_buf != write_buf)

	mov	eax, DWORD PTR [ecx+544]
	cmp	eax, DWORD PTR [ecx+548]
	je	SHORT $LN8@load_buf

; 883  :             {
; 884  :               read_buf = read_buf->next;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+544], eax

; 885  :               read_pos = 0;

	mov	DWORD PTR [ecx+552], 0
$LN8@load_buf:

; 886  :               assert(read_buf != NULL);
; 887  :             }
; 888  :         }
; 889  :       buf_bytes = (read_buf==write_buf)?write_pos:KD_CODE_BUFFER_LEN;

	mov	eax, DWORD PTR [ecx+544]
	cmp	eax, DWORD PTR [ecx+548]
	jne	SHORT $LN13@load_buf
	mov	edi, DWORD PTR [ecx+556]
	jmp	SHORT $LN14@load_buf
$LN13@load_buf:
	mov	edi, 58					; 0000003aH
$LN14@load_buf:

; 890  :       buf_bytes -= read_pos;

	sub	edi, DWORD PTR [ecx+552]

; 891  :       assert(buf_bytes >= 0);
; 892  :       if (buf_bytes == 0)

	je	SHORT $LN17@load_buf

; 893  :         break;
; 894  :       if (buf_bytes > xfer_bytes)

	cmp	edi, ebx
	cmovg	edi, ebx

; 895  :         buf_bytes = xfer_bytes;
; 896  :       xfer_bytes -= buf_bytes;

	sub	ebx, edi

; 897  :       while (buf_bytes--)

	test	edi, edi
	je	SHORT $LN18@load_buf
	npad	9
$LL4@load_buf:

; 898  :         *(first_unwritten++) = read_buf->buf[read_pos++];

	mov	esi, DWORD PTR [ecx+552]
	mov	eax, DWORD PTR [ecx+544]
	mov	edx, DWORD PTR [ecx+528]
	mov	al, BYTE PTR [esi+eax+6]
	mov	BYTE PTR [edx], al
	inc	DWORD PTR [ecx+528]
	inc	DWORD PTR [ecx+552]
	sub	edi, 1
	jne	SHORT $LL4@load_buf
$LN18@load_buf:

; 877  :   int buf_bytes;
; 878  :   while (xfer_bytes > 0)

	test	ebx, ebx
	jg	$LL2@load_buf
$LN17@load_buf:

; 899  :     }
; 900  :   if (first_unread == first_unwritten)

	mov	eax, DWORD PTR [ecx+524]
	pop	edi
	pop	esi
	pop	ebx
	cmp	eax, DWORD PTR [ecx+528]
	je	$LN24@load_buf

; 901  :     { exhausted = true; return false; }
; 902  :   return true;

	mov	al, 1

; 903  : }

	ret	0
?load_buf@kd_pph_input@@MAE_NXZ ENDP			; kd_pph_input::load_buf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?add_bytes@kd_pph_input@@QAEXPAEH@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_num_bytes$ = 12					; size = 4
?add_bytes@kd_pph_input@@QAEXPAEH@Z PROC		; kd_pph_input::add_bytes, COMDAT
; _this$ = ecx

; 843  : {

	push	ebp
	mov	ebp, esp

; 844  :   while (num_bytes > 0)

	mov	eax, DWORD PTR _num_bytes$[ebp]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	$LN3@add_bytes
	push	ebx
	mov	ebx, DWORD PTR _data$[ebp]
	push	edi
$LL2@add_bytes:

; 845  :     {
; 846  :       if (write_buf == NULL)

	cmp	DWORD PTR [esi+548], 0
	jne	SHORT $LN6@add_bytes

; 847  :         {
; 848  :           write_buf = read_buf = first_buf = buf_server->get();

	mov	ecx, DWORD PTR [esi+560]
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	DWORD PTR [esi+540], eax
	mov	DWORD PTR [esi+544], eax

; 849  :           write_pos = read_pos = 0;

	mov	DWORD PTR [esi+552], 0
	jmp	SHORT $LN19@add_bytes
$LN6@add_bytes:

; 850  :         }
; 851  :       else if (write_pos == KD_CODE_BUFFER_LEN)

	cmp	DWORD PTR [esi+556], 58			; 0000003aH
	jne	SHORT $LN8@add_bytes

; 852  :         {
; 853  :           write_buf = write_buf->next = buf_server->get();

	mov	ecx, DWORD PTR [esi+560]
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	ecx, DWORD PTR [esi+548]
	mov	DWORD PTR [ecx], eax
$LN19@add_bytes:
	mov	DWORD PTR [esi+548], eax
	mov	eax, DWORD PTR _num_bytes$[ebp]

; 854  :           write_pos = 0;

	mov	DWORD PTR [esi+556], 0
$LN8@add_bytes:

; 855  :         }
; 856  :       int xfer_bytes = KD_CODE_BUFFER_LEN-write_pos;

	mov	edi, 58					; 0000003aH
	sub	edi, DWORD PTR [esi+556]

; 857  :       if (xfer_bytes > num_bytes)

	cmp	edi, eax
	cmovg	edi, eax

; 858  :         xfer_bytes = num_bytes;
; 859  :       num_bytes -= xfer_bytes;

	sub	eax, edi
	mov	DWORD PTR _num_bytes$[ebp], eax

; 860  :       while (xfer_bytes--)

	test	edi, edi
	je	SHORT $LN13@add_bytes
	npad	6
$LL4@add_bytes:

; 861  :         write_buf->buf[write_pos++] = *(data++);

	mov	edx, DWORD PTR [esi+556]
	mov	ecx, DWORD PTR [esi+548]
	mov	al, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [edx+ecx+6], al
	inc	DWORD PTR [esi+556]
	sub	edi, 1
	jne	SHORT $LL4@add_bytes
	mov	eax, DWORD PTR _num_bytes$[ebp]
$LN13@add_bytes:

; 844  :   while (num_bytes > 0)

	test	eax, eax
	jg	$LL2@add_bytes
	pop	edi
	pop	ebx
$LN3@add_bytes:
	pop	esi

; 862  :     }
; 863  : }

	pop	ebp
	ret	8
?add_bytes@kd_pph_input@@QAEXPAEH@Z ENDP		; kd_pph_input::add_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ??1kd_pph_input@@UAE@XZ
_TEXT	SEGMENT
??1kd_pph_input@@UAE@XZ PROC				; kd_pph_input::~kd_pph_input, COMDAT
; _this$ = ecx

; 828  : {

	push	esi
	mov	esi, ecx

; 829  :   read_buf = NULL; // Just in case.
; 830  :   while ((write_buf=first_buf) != NULL)

	mov	eax, DWORD PTR [esi+540]
	mov	DWORD PTR [esi], OFFSET ??_7kd_pph_input@@6B@
	mov	DWORD PTR [esi+544], 0
	mov	DWORD PTR [esi+548], eax
	test	eax, eax
	je	SHORT $LN12@kd_pph_inp
$LL2@kd_pph_inp:

; 831  :     {
; 832  :       first_buf = write_buf->next;

	mov	eax, DWORD PTR [esi+548]

; 833  :       buf_server->release(write_buf);

	push	DWORD PTR [esi+548]
	mov	ecx, DWORD PTR [esi+560]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+540], eax
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
	mov	eax, DWORD PTR [esi+540]
	mov	DWORD PTR [esi+548], eax
	test	eax, eax
	jne	SHORT $LL2@kd_pph_inp
$LN12@kd_pph_inp:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 486  :     virtual ~kd_input() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kd_input@@6B@
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 835  : }

	ret	0
??1kd_pph_input@@UAE@XZ ENDP				; kd_pph_input::~kd_pph_input
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Gkd_compressed_input@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_compressed_input@@UAEPAXI@Z PROC			; kd_compressed_input::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 486  :     virtual ~kd_input() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kd_input@@6B@
	je	SHORT $LN10@scalar
	push	600					; 00000258H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_compressed_input@@UAEPAXI@Z ENDP			; kd_compressed_input::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_compressed_input@@UAE@XZ
_TEXT	SEGMENT
??1kd_compressed_input@@UAE@XZ PROC			; kd_compressed_input::~kd_compressed_input, COMDAT
; _this$ = ecx

; 486  :     virtual ~kd_input() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kd_input@@6B@
	ret	0
??1kd_compressed_input@@UAE@XZ ENDP			; kd_compressed_input::~kd_compressed_input
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?load_buf@kd_compressed_input@@MAE_NXZ
_TEXT	SEGMENT
?load_buf@kd_compressed_input@@MAE_NXZ PROC		; kd_compressed_input::load_buf, COMDAT
; _this$ = ecx

; 612  : {

	push	esi
	mov	esi, ecx

; 613  :   assert(first_unwritten == first_unread);
; 614  :   if (fully_buffered)

	cmp	BYTE PTR [esi+532], 0
	je	SHORT $LN2@load_buf

; 615  :     return (exhausted = true);

	mov	BYTE PTR [esi+533], 1
	mov	al, 1
	pop	esi

; 653  : }

	ret	0
$LN2@load_buf:

; 616  : 
; 617  :   first_unread = buffer + KD_IBUF_PUTBACK;
; 618  :   cur_offset += (first_unwritten - first_unread);

	mov	ecx, DWORD PTR [esi+528]
	mov	eax, ecx
	push	edi
	lea	edi, DWORD PTR [esi+10]
	sub	eax, edi
	mov	DWORD PTR [esi+524], edi
	cdq
	add	DWORD PTR [esi+544], eax
	adc	DWORD PTR [esi+548], edx

; 619  :   if (special_scope)

	cmp	BYTE PTR [esi+592], 0
	je	SHORT $LN3@load_buf

; 620  :     {
; 621  :       last_loaded_bytes = source->read(first_unread,KD_IBUF_SIZE);

	mov	ecx, DWORD PTR [esi+540]
	push	512					; 00000200H
	push	edi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]
	cdq
	mov	DWORD PTR [esi+576], eax

; 622  :       first_unwritten = first_unread + last_loaded_bytes;

	mov	eax, DWORD PTR [esi+524]
	mov	DWORD PTR [esi+580], edx
	add	eax, DWORD PTR [esi+576]
	mov	DWORD PTR [esi+528], eax

; 623  :       if (last_loaded_bytes == 0)

	mov	eax, DWORD PTR [esi+576]

; 624  :         exhausted = true;
; 625  :     }

	jmp	$LN17@load_buf
$LN3@load_buf:

; 626  :   else if (suspend_ptr == NULL)

	mov	eax, DWORD PTR [esi+584]

; 630  :       first_unwritten = first_unread;

	mov	DWORD PTR [esi+528], edi
	test	eax, eax
	jne	$LN6@load_buf

; 627  :     { // Not in suspended state; byte limits may apply.
; 628  :       alt_first_unwritten = NULL;
; 629  :       last_loaded_bytes = max_bytes_allowed + suspended_bytes - cur_offset;

	mov	ecx, DWORD PTR [esi+568]
	add	ecx, DWORD PTR [esi+552]
	mov	DWORD PTR [esi+588], eax
	mov	eax, DWORD PTR [esi+572]
	adc	eax, DWORD PTR [esi+556]
	sub	ecx, DWORD PTR [esi+544]
	mov	DWORD PTR [esi+576], ecx
	sbb	eax, DWORD PTR [esi+548]
	mov	DWORD PTR [esi+580], eax

; 631  :       if (last_loaded_bytes <= 0)

	mov	eax, ecx
	mov	ecx, DWORD PTR [esi+580]
	test	ecx, ecx
	jg	SHORT $LN14@load_buf
	jl	SHORT $LN13@load_buf
	test	eax, eax
	jne	SHORT $LN8@load_buf
$LN13@load_buf:
	pop	edi

; 632  :         { exhausted = true; last_loaded_bytes=0; return false; }

	mov	BYTE PTR [esi+533], 1
	xor	al, al
	mov	DWORD PTR [esi+576], 0
	mov	DWORD PTR [esi+580], 0
	pop	esi

; 653  : }

	ret	0
$LN8@load_buf:

; 633  :       if (last_loaded_bytes > KD_IBUF_SIZE)

	test	ecx, ecx
	jl	SHORT $LN9@load_buf
	jg	SHORT $LN14@load_buf
	cmp	eax, 512				; 00000200H
	jbe	SHORT $LN9@load_buf
$LN14@load_buf:

; 634  :         last_loaded_bytes = KD_IBUF_SIZE;

	mov	DWORD PTR [esi+576], 512		; 00000200H
	mov	DWORD PTR [esi+580], 0
$LN9@load_buf:

; 635  :       last_loaded_bytes = source->read(first_unread,(int) last_loaded_bytes);

	push	DWORD PTR [esi+576]

; 636  :       first_unwritten += last_loaded_bytes;
; 637  :       if (last_loaded_bytes == 0)
; 638  :         exhausted = true;
; 639  :     }
; 640  :   else

	jmp	SHORT $LN20@load_buf
$LN6@load_buf:

; 641  :     { // In suspended state; no byte limits apply, but keep track of things
; 642  :       assert(alt_first_unwritten == NULL);
; 643  :       assert((suspend_ptr>=first_unread) && (suspend_ptr<=first_unwritten));
; 644  :       suspended_bytes += first_unwritten - suspend_ptr;

	sub	ecx, eax

; 645  :       first_unwritten = first_unread;
; 646  :       suspend_ptr = first_unread;

	mov	DWORD PTR [esi+584], edi
	mov	eax, ecx
	cdq
	add	DWORD PTR [esi+568], eax

; 647  :       last_loaded_bytes = source->read(first_unread,KD_IBUF_SIZE);

	push	512					; 00000200H
	adc	DWORD PTR [esi+572], edx
$LN20@load_buf:
	mov	ecx, DWORD PTR [esi+540]
	push	edi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]
	cdq

; 648  :       first_unwritten += last_loaded_bytes;

	add	DWORD PTR [esi+528], eax
	mov	DWORD PTR [esi+580], edx
	mov	DWORD PTR [esi+576], eax
$LN17@load_buf:

; 649  :       if (last_loaded_bytes == 0)

	or	eax, edx
	jne	SHORT $LN11@load_buf

; 650  :         exhausted = true;

	mov	BYTE PTR [esi+533], 1
$LN11@load_buf:

; 651  :     }
; 652  :   return !exhausted;

	xor	eax, eax
	cmp	BYTE PTR [esi+533], al
	pop	edi
	sete	al
	pop	esi

; 653  : }

	ret	0
?load_buf@kd_compressed_input@@MAE_NXZ ENDP		; kd_compressed_input::load_buf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_suspended_bytes@kd_compressed_input@@QAE_JXZ
_TEXT	SEGMENT
?get_suspended_bytes@kd_compressed_input@@QAE_JXZ PROC	; kd_compressed_input::get_suspended_bytes, COMDAT
; _this$ = ecx

; 677  : {

	push	esi
	mov	esi, ecx

; 678  :   if (special_scope)

	cmp	BYTE PTR [esi+592], 0
	je	SHORT $LN2@get_suspen

; 679  :     return 0;

	xor	eax, eax
	xor	edx, edx
	pop	esi

; 688  : }

	ret	0
$LN2@get_suspen:

; 680  :   if (suspend_ptr != NULL)

	mov	edx, DWORD PTR [esi+584]
	test	edx, edx
	je	SHORT $LN3@get_suspen

; 681  :     {
; 682  :       assert((suspend_ptr <= first_unread) &&
; 683  :              (suspend_ptr >= (first_unwritten-last_loaded_bytes)));
; 684  :       suspended_bytes += first_unread - suspend_ptr;

	mov	ecx, DWORD PTR [esi+524]
	mov	eax, ecx
	sub	eax, edx

; 685  :       suspend_ptr = first_unread;

	mov	DWORD PTR [esi+584], ecx
	cdq
	add	DWORD PTR [esi+568], eax
	adc	DWORD PTR [esi+572], edx
$LN3@get_suspen:

; 686  :     }
; 687  :   return suspended_bytes;

	mov	eax, DWORD PTR [esi+568]
	mov	edx, DWORD PTR [esi+572]
	pop	esi

; 688  : }

	ret	0
?get_suspended_bytes@kd_compressed_input@@QAE_JXZ ENDP	; kd_compressed_input::get_suspended_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_bytes_read@kd_compressed_input@@QAE_JXZ
_TEXT	SEGMENT
?get_bytes_read@kd_compressed_input@@QAE_JXZ PROC	; kd_compressed_input::get_bytes_read, COMDAT
; _this$ = ecx

; 662  :   if (special_scope)

	cmp	BYTE PTR [ecx+592], 0
	je	SHORT $LN2@get_bytes_

; 663  :     return 0;

	xor	eax, eax
	xor	edx, edx

; 669  : }

	ret	0
$LN2@get_bytes_:

; 664  :   kdu_long last_read =
; 665  :     cur_offset + last_loaded_bytes - (first_unwritten-first_unread) - 1;

	mov	eax, DWORD PTR [ecx+528]
	sub	eax, DWORD PTR [ecx+524]
	push	esi
	mov	esi, DWORD PTR [ecx+576]
	cdq
	sub	esi, eax
	mov	eax, DWORD PTR [ecx+580]
	sbb	eax, edx
	add	esi, DWORD PTR [ecx+544]
	adc	eax, DWORD PTR [ecx+548]
	sub	esi, 1
	sbb	eax, 0

; 666  :   if (last_read > max_address_read)

	cmp	eax, DWORD PTR [ecx+564]
	jl	SHORT $LN3@get_bytes_
	jg	SHORT $LN5@get_bytes_
	cmp	esi, DWORD PTR [ecx+560]
	jbe	SHORT $LN3@get_bytes_
$LN5@get_bytes_:

; 667  :     max_address_read = last_read;

	mov	DWORD PTR [ecx+560], esi
	mov	DWORD PTR [ecx+564], eax
$LN3@get_bytes_:

; 668  :   return max_address_read+1;

	mov	eax, DWORD PTR [ecx+560]
	mov	edx, DWORD PTR [ecx+564]
	add	eax, 1
	pop	esi
	adc	edx, 0

; 669  : }

	ret	0
?get_bytes_read@kd_compressed_input@@QAE_JXZ ENDP	; kd_compressed_input::get_bytes_read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_max_bytes@kd_compressed_input@@QAEX_J@Z
_TEXT	SEGMENT
_limit$ = 8						; size = 8
?set_max_bytes@kd_compressed_input@@QAEX_J@Z PROC	; kd_compressed_input::set_max_bytes, COMDAT
; _this$ = ecx

; 580  : {

	push	ebp
	mov	ebp, esp
	mov	edx, ecx

; 581  :   if (special_scope)

	cmp	BYTE PTR [edx+592], 0
	jne	$LN8@set_max_by

; 582  :     return;
; 583  :   if (limit >= max_bytes_allowed)

	push	edi
	mov	edi, DWORD PTR _limit$[ebp+4]
	cmp	edi, DWORD PTR [edx+556]
	jg	$LN13@set_max_by
	push	esi
	mov	esi, DWORD PTR _limit$[ebp]
	jl	SHORT $LN10@set_max_by
	cmp	esi, DWORD PTR [edx+552]
	jae	$LN14@set_max_by
$LN10@set_max_by:

; 584  :     return; // Only allow tighter restrictions
; 585  :   if (limit > (KDU_LONG_MAX>>1))

	cmp	edi, 1073741823				; 3fffffffH
	jl	SHORT $LN4@set_max_by
	jg	SHORT $LN11@set_max_by
	cmp	esi, -1
	jbe	SHORT $LN4@set_max_by
$LN11@set_max_by:

; 586  :     limit = KDU_LONG_MAX>>1;

	or	esi, -1
	mov	edi, 1073741823				; 3fffffffH
$LN4@set_max_by:

; 587  :   max_bytes_allowed = limit;
; 588  :   if (suspend_ptr != NULL)

	cmp	DWORD PTR [edx+584], 0
	mov	DWORD PTR [edx+552], esi
	mov	DWORD PTR [edx+556], edi
	jne	$LN14@set_max_by

; 589  :     return; // Don't actually apply any limits until suspension is over.
; 590  :   limit = max_bytes_allowed + suspended_bytes - cur_offset;

	mov	ecx, DWORD PTR [edx+568]
	sub	ecx, DWORD PTR [edx+544]
	mov	eax, DWORD PTR [edx+572]
	sbb	eax, DWORD PTR [edx+548]
	add	esi, ecx
	adc	edi, eax

; 591  :   if (limit < last_loaded_bytes)

	cmp	edi, DWORD PTR [edx+580]
	jg	SHORT $LN14@set_max_by
	jl	SHORT $LN12@set_max_by
	cmp	esi, DWORD PTR [edx+576]
	jae	SHORT $LN14@set_max_by
$LN12@set_max_by:

; 592  :     { // We have already loaded the buffer with too many bytes.
; 593  :       if (alt_first_unwritten == NULL)

	cmp	DWORD PTR [edx+588], 0
	jne	SHORT $LN7@set_max_by

; 594  :         alt_first_unwritten = first_unwritten;

	mov	eax, DWORD PTR [edx+528]
	mov	DWORD PTR [edx+588], eax
$LN7@set_max_by:

; 595  :       first_unwritten -= (last_loaded_bytes - limit);

	mov	eax, esi
	sub	eax, DWORD PTR [edx+576]
	add	DWORD PTR [edx+528], eax

; 596  :       last_loaded_bytes = limit;
; 597  :       if (first_unwritten < first_unread)

	mov	eax, DWORD PTR [edx+524]
	mov	DWORD PTR [edx+576], esi
	mov	DWORD PTR [edx+580], edi
	cmp	DWORD PTR [edx+528], eax
	jae	SHORT $LN14@set_max_by

; 598  :         { // We have already read past the end.
; 599  :           exhausted = true;

	mov	BYTE PTR [edx+533], 1

; 600  :           first_unwritten = first_unread;

	mov	DWORD PTR [edx+528], eax

; 601  :           alt_first_unwritten = NULL;

	mov	DWORD PTR [edx+588], 0
$LN14@set_max_by:
	pop	esi
$LN13@set_max_by:
	pop	edi
$LN8@set_max_by:

; 602  :         }
; 603  :     }
; 604  : }

	pop	ebp
	ret	8
?set_max_bytes@kd_compressed_input@@QAEX_J@Z ENDP	; kd_compressed_input::set_max_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?ignore@kd_compressed_input@@UAE_J_J@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_count$ = 8						; size = 8
?ignore@kd_compressed_input@@UAE_J_J@Z PROC		; kd_compressed_input::ignore, COMDAT
; _this$ = ecx

; 807  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi

; 808  :   if (!(source->get_capabilities() & KDU_SOURCE_CAP_SEEKABLE))

	mov	ecx, DWORD PTR [esi+540]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	al, 2
	jne	SHORT $LN2@ignore

; 809  :     return kd_input::ignore(count);

	push	DWORD PTR _count$[ebp+4]
	mov	ecx, esi
	push	DWORD PTR _count$[ebp]
	call	?ignore@kd_input@@UAE_J_J@Z		; kd_input::ignore
	pop	esi

; 816  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@ignore:

; 810  :   kdu_long old_addr, new_addr;
; 811  :   old_addr = cur_offset + last_loaded_bytes - (first_unwritten-first_unread);

	mov	eax, DWORD PTR [esi+528]
	sub	eax, DWORD PTR [esi+524]
	push	ebx
	mov	ebx, DWORD PTR [esi+576]
	cdq
	push	edi
	mov	edi, DWORD PTR [esi+580]
	sub	ebx, eax
	sbb	edi, edx
	add	ebx, DWORD PTR [esi+544]

; 812  :   new_addr = old_addr + count;

	mov	ecx, ebx
	adc	edi, DWORD PTR [esi+548]
	add	ecx, DWORD PTR _count$[ebp]
	mov	eax, edi
	adc	eax, DWORD PTR _count$[ebp+4]

; 813  :   seek(new_addr);

	push	eax
	push	ecx
	mov	ecx, esi
	call	?seek@kd_compressed_input@@QAEX_J@Z	; kd_compressed_input::seek

; 814  :   new_addr = cur_offset + last_loaded_bytes - (first_unwritten-first_unread);

	mov	eax, DWORD PTR [esi+528]
	sub	eax, DWORD PTR [esi+524]

; 815  :   return new_addr-old_addr;

	mov	esi, DWORD PTR [esi+576]
	cdq
	sub	esi, eax
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [eax+580]
	sbb	ecx, edx
	sub	esi, ebx
	sbb	ecx, edi
	add	esi, DWORD PTR [eax+544]
	pop	edi
	adc	ecx, DWORD PTR [eax+548]
	mov	eax, esi
	pop	ebx
	mov	edx, ecx
	pop	esi

; 816  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ignore@kd_compressed_input@@UAE_J_J@Z ENDP		; kd_compressed_input::ignore
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?seek@kd_compressed_input@@QAEX_J@Z
_TEXT	SEGMENT
_e$2 = -68						; size = 20
_e$3 = -48						; size = 20
_cur_size$2$ = -28					; size = 4
_cur_size$1$ = -24					; size = 4
_cur_addr$2$ = -20					; size = 4
_cur_addr$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_address$ = 8						; size = 8
?seek@kd_compressed_input@@QAEX_J@Z PROC		; kd_compressed_input::seek, COMDAT
; _this$ = ecx

; 726  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?seek@kd_compressed_input@@QAEX_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 727  :   assert(!throw_markers); // Marker throwing fragile; no seeking permitted
; 728  : 
; 729  :   if (address < 0)

	mov	esi, DWORD PTR _address$[ebp+4]
	mov	ebx, DWORD PTR _address$[ebp]
	test	esi, esi
	jg	$LN2@seek
	jl	SHORT $LN21@seek
	test	ebx, ebx
	jae	$LN2@seek
$LN21@seek:

; 730  :     { // Only for cacheable source.
; 731  :       special_scope = true;
; 732  :       first_unread = first_unwritten = buffer + KD_IBUF_PUTBACK;
; 733  :       if (!source->set_precinct_scope(-(1+address)))

	mov	ecx, DWORD PTR [edi+540]
	lea	eax, DWORD PTR [edi+10]
	mov	DWORD PTR [edi+528], eax
	or	edx, -1
	mov	DWORD PTR [edi+524], eax
	mov	eax, edx
	sub	eax, ebx
	mov	BYTE PTR [edi+592], 1
	mov	esi, DWORD PTR [ecx]
	sbb	edx, DWORD PTR _address$[ebp+4]
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+32]
	call	eax
	test	al, al
	jne	SHORT $LN3@seek

; 734  :         { KDU_ERROR_DEV(e,1); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0LF@EOEFHEHA@Attempting?5to?5load?5cached?5precin@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 734  :         { KDU_ERROR_DEV(e,1); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 739  :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN3@seek:

; 740  :       int xfer_bytes = source->read(first_unread,KD_IBUF_SIZE);

	mov	ecx, DWORD PTR [edi+540]
	push	512					; 00000200H
	push	DWORD PTR [edi+524]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]

; 741  :       first_unwritten = first_unread + xfer_bytes;

	mov	ecx, DWORD PTR [edi+524]
	add	ecx, eax

; 742  :       exhausted = (xfer_bytes == 0);

	test	eax, eax
	mov	DWORD PTR [edi+528], ecx
	sete	al
	mov	BYTE PTR [edi+533], al

; 799  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@seek:

; 743  :       return;
; 744  :     }
; 745  : 
; 746  :   kdu_long cur_addr =
; 747  :     cur_offset + last_loaded_bytes - (first_unwritten - first_unread);

	mov	eax, DWORD PTR [edi+576]
	mov	ecx, DWORD PTR [edi+524]
	mov	esi, DWORD PTR [edi+544]
	mov	DWORD PTR _cur_size$1$[ebp], eax
	mov	eax, DWORD PTR [edi+580]
	mov	DWORD PTR _cur_size$2$[ebp], eax
	mov	eax, DWORD PTR [edi+528]
	sub	eax, ecx
	mov	DWORD PTR _cur_addr$1$[ebp], esi
	mov	esi, DWORD PTR [edi+548]
	cdq
	sub	DWORD PTR _cur_addr$1$[ebp], eax
	mov	eax, DWORD PTR _cur_addr$1$[ebp]
	sbb	esi, edx
	add	eax, DWORD PTR [edi+576]
	mov	DWORD PTR _cur_addr$1$[ebp], eax
	adc	esi, DWORD PTR [edi+580]
	mov	DWORD PTR _cur_addr$2$[ebp], esi

; 748  :   kdu_long cur_size = last_loaded_bytes;
; 749  :   if (address == cur_addr)

	mov	esi, DWORD PTR _address$[ebp+4]
	mov	edx, DWORD PTR _cur_addr$2$[ebp]
	cmp	ebx, eax
	jne	SHORT $LN22@seek
	cmp	esi, edx
	je	$LN13@seek
$LN22@seek:

; 750  :     return; // Already at exactly the right location.
; 751  : 
; 752  :   // Before changing context, see if `max_address_read' needs updating.
; 753  :   kdu_long last_read = cur_addr-1;

	sub	eax, 1
	sbb	edx, 0

; 754  :   if (last_read > max_address_read)

	cmp	edx, DWORD PTR [edi+564]
	jl	SHORT $LN5@seek
	jg	SHORT $LN23@seek
	cmp	eax, DWORD PTR [edi+560]
	jbe	SHORT $LN5@seek
$LN23@seek:

; 755  :     max_address_read = last_read;

	mov	DWORD PTR [edi+560], eax
	mov	DWORD PTR [edi+564], edx
$LN5@seek:

; 756  : 
; 757  :   // Now for the seeking code.
; 758  :   alt_first_unwritten = NULL; // Just in case
; 759  :   if (address >= max_bytes_allowed)

	mov	edx, DWORD PTR [edi+556]
	mov	eax, DWORD PTR [edi+552]
	mov	DWORD PTR [edi+588], 0
	cmp	esi, edx
	jl	SHORT $LN6@seek
	jg	SHORT $LN24@seek
	cmp	ebx, eax
	jb	SHORT $LN6@seek
$LN24@seek:

; 760  :     {
; 761  :       exhausted = true;
; 762  :       if (!fully_buffered)

	cmp	BYTE PTR [edi+532], 0
	mov	BYTE PTR [edi+533], 1
	jne	SHORT $LN7@seek

; 763  :         {
; 764  :           cur_offset = max_bytes_allowed;

	mov	DWORD PTR [edi+544], eax

; 765  :           first_unwritten = buffer + KD_IBUF_PUTBACK;

	lea	eax, DWORD PTR [edi+10]
	mov	DWORD PTR [edi+548], edx
	mov	DWORD PTR [edi+528], eax
$LN7@seek:

; 766  :         }
; 767  :       first_unread = first_unwritten;

	mov	eax, DWORD PTR [edi+528]
	mov	DWORD PTR [edi+524], eax

; 799  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN6@seek:

; 768  :       return;
; 769  :     }
; 770  :   exhausted = false;
; 771  :   if ((address >= cur_offset) && (address < (cur_offset+cur_size)))

	mov	edx, DWORD PTR [edi+548]
	mov	BYTE PTR [edi+533], 0
	cmp	esi, edx
	jl	SHORT $LN8@seek
	mov	eax, DWORD PTR [edi+544]
	jg	SHORT $LN25@seek
	cmp	ebx, eax
	jb	SHORT $LN8@seek
$LN25@seek:
	add	eax, DWORD PTR _cur_size$1$[ebp]
	adc	edx, DWORD PTR _cur_size$2$[ebp]
	cmp	esi, edx
	jg	SHORT $LN8@seek
	jl	SHORT $LN26@seek
	cmp	ebx, eax
	jae	SHORT $LN8@seek
$LN26@seek:

; 772  :     { // No need to read any new data into the internal buffer.
; 773  :       first_unread += address - cur_addr;

	sub	ecx, DWORD PTR _cur_addr$1$[ebp]
	add	ecx, ebx
	mov	DWORD PTR [edi+524], ecx

; 799  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN8@seek:

; 774  :       return;
; 775  :     }
; 776  :   assert(!fully_buffered);
; 777  :   if (suspend_ptr != NULL)

	mov	eax, DWORD PTR [edi+584]
	test	eax, eax
	je	SHORT $LN10@seek

; 778  :     {
; 779  :       kdu_long extra_sus = (first_unread - suspend_ptr) + (address-cur_addr);

	sub	ecx, eax
	mov	eax, ecx

; 780  :       suspend_ptr = buffer + KD_IBUF_PUTBACK;

	lea	ecx, DWORD PTR [edi+10]
	cdq
	sub	eax, DWORD PTR _cur_addr$1$[ebp]
	mov	DWORD PTR [edi+584], ecx
	sbb	edx, DWORD PTR _cur_addr$2$[ebp]
	add	eax, ebx
	adc	edx, esi

; 781  :       if (extra_sus > 0)

	js	SHORT $LN10@seek
	jg	SHORT $LN27@seek
	test	eax, eax
	je	SHORT $LN10@seek
$LN27@seek:

; 782  :         suspended_bytes += extra_sus;

	add	DWORD PTR [edi+568], eax
	adc	DWORD PTR [edi+572], edx
$LN10@seek:

; 783  :     }
; 784  :   cur_offset = address;
; 785  :   first_unread = first_unwritten = buffer + KD_IBUF_PUTBACK;
; 786  :   if (!source->seek(address))

	mov	ecx, DWORD PTR [edi+540]
	lea	eax, DWORD PTR [edi+10]
	mov	DWORD PTR [edi+528], eax
	mov	DWORD PTR [edi+524], eax
	mov	DWORD PTR [edi+544], ebx
	mov	DWORD PTR [edi+548], esi
	mov	eax, DWORD PTR [ecx]
	push	esi
	push	ebx
	mov	eax, DWORD PTR [eax+16]
	call	eax
	test	al, al
	jne	SHORT $LN11@seek

; 787  :     { KDU_ERROR_DEV(e,2); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0JA@OOKKCCPN@Attempting?5to?5seek?5inside?5a?5comp@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 787  :     { KDU_ERROR_DEV(e,2); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 791  :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN11@seek:

; 792  :   last_loaded_bytes = max_bytes_allowed - cur_offset;

	mov	ecx, DWORD PTR [edi+552]
	sub	ecx, DWORD PTR [edi+544]
	mov	eax, DWORD PTR [edi+556]
	sbb	eax, DWORD PTR [edi+548]
	mov	DWORD PTR [edi+576], ecx
	mov	DWORD PTR [edi+580], eax

; 793  :   if (last_loaded_bytes > KD_IBUF_SIZE)

	test	eax, eax
	jl	SHORT $LN12@seek
	jg	SHORT $LN28@seek
	cmp	ecx, 512				; 00000200H
	jbe	SHORT $LN12@seek
$LN28@seek:

; 794  :     last_loaded_bytes = KD_IBUF_SIZE;

	mov	DWORD PTR [edi+576], 512		; 00000200H
	mov	DWORD PTR [edi+580], 0
$LN12@seek:

; 795  :   last_loaded_bytes = source->read(first_unread,(int) last_loaded_bytes);

	mov	ecx, DWORD PTR [edi+540]
	push	DWORD PTR [edi+576]
	push	DWORD PTR [edi+524]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+12]
	cdq
	mov	DWORD PTR [edi+576], eax

; 796  :   first_unwritten = first_unread + last_loaded_bytes;

	mov	eax, DWORD PTR [edi+524]
	mov	DWORD PTR [edi+580], edx
	add	eax, DWORD PTR [edi+576]
	mov	DWORD PTR [edi+528], eax

; 797  :   if (last_loaded_bytes == 0)

	mov	eax, DWORD PTR [edi+576]
	or	eax, edx
	jne	SHORT $LN13@seek

; 798  :     exhausted = true;

	mov	BYTE PTR [edi+533], 1
$LN13@seek:

; 799  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?seek@kd_compressed_input@@QAEX_J@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?seek@kd_compressed_input@@QAEX_J@Z$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?seek@kd_compressed_input@@QAEX_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?seek@kd_compressed_input@@QAEX_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?seek@kd_compressed_input@@QAEX_J@Z ENDP		; kd_compressed_input::seek
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z
_TEXT	SEGMENT
_e$2 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_tnum$ = 8						; size = 4
_num_tiles$ = 12					; size = 4
?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z PROC ; kd_compressed_input::set_tileheader_scope, COMDAT
; _this$ = ecx

; 696  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 697  :   special_scope = true;
; 698  :   first_unread = buffer + KD_IBUF_PUTBACK;
; 699  :   if (!source->set_tileheader_scope(tnum,num_tiles))

	mov	ecx, DWORD PTR [esi+540]
	lea	eax, DWORD PTR [esi+10]
	push	DWORD PTR _num_tiles$[ebp]
	mov	DWORD PTR [esi+524], eax
	push	DWORD PTR _tnum$[ebp]
	mov	BYTE PTR [esi+592], 1
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+28]
	call	eax

; 700  :     {
; 701  :       if ((source->get_capabilities() & KDU_SOURCE_CAP_CACHED) == 0)

	mov	ecx, DWORD PTR [esi+540]
	test	al, al
	mov	eax, DWORD PTR [ecx]
	jne	SHORT $LN2@set_tilehe
	call	DWORD PTR [eax+8]
	test	al, 4
	jne	SHORT $LN3@set_tilehe

; 703  :           KDU_ERROR_DEV(e,0); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0LF@DMBAEAHP@Attempting?5to?5load?5cached?5tile?5h@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 703  :           KDU_ERROR_DEV(e,0); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 708  :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN3@set_tilehe:

; 709  :       first_unwritten = first_unread;

	mov	eax, DWORD PTR [esi+524]
	mov	DWORD PTR [esi+528], eax

; 710  :       exhausted = true;
; 711  :       return false;

	xor	al, al
	mov	BYTE PTR [esi+533], 1

; 718  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@set_tilehe:

; 712  :     }
; 713  :   int xfer_bytes = source->read(first_unread,KD_IBUF_SIZE);

	push	512					; 00000200H
	push	DWORD PTR [esi+524]
	call	DWORD PTR [eax+12]

; 714  :   first_unwritten = first_unread + xfer_bytes;

	mov	ecx, DWORD PTR [esi+524]
	add	ecx, eax

; 715  :   assert(xfer_bytes >= 0);
; 716  :   exhausted = (xfer_bytes == 0);

	test	eax, eax
	mov	DWORD PTR [esi+528], ecx
	sete	al
	mov	BYTE PTR [esi+533], al

; 717  :   return true;

	mov	al, 1

; 718  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z ENDP ; kd_compressed_input::set_tileheader_scope
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_capabilities@kd_compressed_input@@QAEHXZ
_TEXT	SEGMENT
?get_capabilities@kd_compressed_input@@QAEHXZ PROC	; kd_compressed_input::get_capabilities, COMDAT
; _this$ = ecx

; 656  :       { return source->get_capabilities(); }

	mov	ecx, DWORD PTR [ecx+540]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+8]
?get_capabilities@kd_compressed_input@@QAEHXZ ENDP	; kd_compressed_input::get_capabilities
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z
_TEXT	SEGMENT
_mem_pos$2 = -24					; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_mem_lim$3 = 8						; size = 4
_source$ = 8						; size = 4
??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z PROC ; kd_compressed_input::kd_compressed_input, COMDAT
; _this$ = ecx

; 551  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 484  :       { first_unread = first_unwritten = buffer+KD_IBUF_PUTBACK;

	lea	eax, DWORD PTR [esi+10]

; 485  :         exhausted = fully_buffered = throw_markers = false; }

	mov	WORD PTR [esi+533], 0
	mov	DWORD PTR [esi+528], eax
	mov	DWORD PTR [esi+524], eax
	mov	BYTE PTR [esi+532], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 552  :   this->source = source;

	mov	edi, DWORD PTR _source$[ebp]

; 553  :   cur_offset = 0;
; 554  :   max_bytes_allowed = (KDU_LONG_MAX>>1);
; 555  :   max_address_read = 0;
; 556  :   suspend_ptr = alt_first_unwritten = NULL;
; 557  :   suspended_bytes = last_loaded_bytes = 0;
; 558  :   special_scope = false;
; 559  :   if (source->get_capabilities() & KDU_SOURCE_CAP_IN_MEMORY)

	mov	ecx, edi
	mov	DWORD PTR [esi], OFFSET ??_7kd_compressed_input@@6B@
	mov	DWORD PTR [esi+540], edi
	mov	DWORD PTR [esi+544], 0
	mov	DWORD PTR [esi+548], 0
	mov	DWORD PTR [esi+552], -1
	mov	DWORD PTR [esi+556], 1073741823		; 3fffffffH
	mov	DWORD PTR [esi+560], 0
	mov	DWORD PTR [esi+564], 0
	mov	DWORD PTR [esi+588], 0
	mov	DWORD PTR [esi+584], 0
	mov	DWORD PTR [esi+576], 0
	mov	DWORD PTR [esi+580], 0
	mov	DWORD PTR [esi+568], 0
	mov	DWORD PTR [esi+572], 0
	mov	BYTE PTR [esi+592], 0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	DWORD PTR [eax+8]
	test	al, 8
	je	SHORT $LN8@kd_compres

; 560  :     {
; 561  :       kdu_long mem_pos;
; 562  :       kdu_byte *mem, *mem_lim;
; 563  :       if ((mem = source->access_memory(mem_pos,mem_lim)) == NULL)

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR _mem_lim$3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _mem_pos$2[ebp]
	push	ecx
	mov	ecx, edi
	call	DWORD PTR [eax+24]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN8@kd_compres

; 564  :         return;
; 565  :       fully_buffered = true;
; 566  :       first_unread = mem;
; 567  :       first_unwritten = mem_lim;

	mov	eax, DWORD PTR _mem_lim$3[ebp]
	mov	DWORD PTR [esi+528], eax

; 568  :       assert(mem_pos == 0);
; 569  :       cur_offset = 0;
; 570  :       last_loaded_bytes = first_unwritten - first_unread;

	sub	eax, ecx
	cdq
	mov	BYTE PTR [esi+532], 1
	mov	DWORD PTR [esi+524], ecx
	mov	DWORD PTR [esi+544], 0
	mov	DWORD PTR [esi+548], 0
	mov	DWORD PTR [esi+576], eax
	mov	DWORD PTR [esi+580], edx
$LN8@kd_compres:

; 571  :     }
; 572  : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kd_input@@UAE@XZ			; kd_input::~kd_input
__ehhandler$??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z ENDP ; kd_compressed_input::kd_compressed_input
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Gkd_input@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_input@@UAEPAXI@Z PROC				; kd_input::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 486  :     virtual ~kd_input() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kd_input@@6B@
	je	SHORT $LN7@scalar
	push	540					; 0000021cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_input@@UAEPAXI@Z ENDP				; kd_input::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?process_unexpected_marker@kd_input@@AAEXE@Z
_TEXT	SEGMENT
_length$1$ = -8						; size = 4
_byte$1 = -1						; size = 1
$T2 = 8							; size = 2
_last_byte$ = 8						; size = 1
?process_unexpected_marker@kd_input@@AAEXE@Z PROC	; kd_input::process_unexpected_marker, COMDAT
; _this$ = ecx

; 317  : {

	push	ebp
	mov	ebp, esp

; 318  :   assert(throw_markers);
; 319  :   kdu_uint16 code = 0xFF00; code += last_byte;

	mov	al, BYTE PTR _last_byte$[ebp]
	sub	esp, 8
	movzx	eax, al
	push	ebx
	push	esi
	mov	esi, ecx
	mov	ecx, 256				; 00000100H
	sub	ax, cx
	push	edi
	movzx	ebx, ax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 514  :         if (!throw_markers) return true;

	cmp	BYTE PTR [esi+534], 0
	je	SHORT $LN15@process_un

; 515  :         throw_markers = false; // Must not touch `reject_all' here.
; 516  :         if (exhausted) have_FF = false;

	cmp	BYTE PTR [esi+533], 0
	mov	BYTE PTR [esi+534], 0
	je	SHORT $LN15@process_un
	mov	BYTE PTR [esi+535], 0
$LN15@process_un:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 321  :   if (!reject_all)

	cmp	BYTE PTR [esi+536], 0
	jne	$LN11@process_un

; 322  :     {
; 323  :       bool bona_fide = false;
; 324  :       if ((code == KDU_SOP) || (code == KDU_SOT))

	mov	edi, 65425				; 0000ff91H
	cmp	bx, di
	je	SHORT $LN4@process_un
	mov	eax, 65424				; 0000ff90H
	cmp	bx, ax
	jne	$LN28@process_un
$LN4@process_un:

; 325  :         {
; 326  :           kdu_byte byte;
; 327  :           kdu_uint16 length;
; 328  :           if (!get(byte))

	lea	eax, DWORD PTR _byte$1[ebp]
	mov	ecx, esi
	push	eax
	call	?get@kd_input@@QAE_NAAE@Z		; kd_input::get
	test	al, al
	jne	SHORT $LN5@process_un

; 329  :             exhausted = false;

	mov	BYTE PTR [esi+533], al

; 330  :           else

	jmp	$LN28@process_un
$LN5@process_un:

; 331  :             {
; 332  :               length = byte;

	movzx	eax, BYTE PTR _byte$1[ebp]

; 333  :               if (!get(byte))

	mov	ecx, esi
	mov	DWORD PTR _length$1$[ebp], eax
	lea	eax, DWORD PTR _byte$1[ebp]
	push	eax
	call	?get@kd_input@@QAE_NAAE@Z		; kd_input::get
	test	al, al
	jne	SHORT $LN7@process_un
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 550  :         first_unread--;

	dec	DWORD PTR [esi+524]
	mov	ecx, DWORD PTR [esi+524]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 335  :                   exhausted = false;

	mov	BYTE PTR [esi+533], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 551  :         if (!fully_buffered)

	cmp	BYTE PTR [esi+532], al
	jne	SHORT $LN28@process_un

; 552  :           {
; 553  :             assert(first_unread >= buffer);
; 554  :             *first_unread = byte;

	mov	eax, DWORD PTR _length$1$[ebp]
	mov	BYTE PTR [ecx], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 338  :               else

	jmp	SHORT $LN28@process_un
$LN7@process_un:

; 339  :                 {
; 340  :                   length = (length<<8) + byte;

	mov	ecx, DWORD PTR _length$1$[ebp]
	movzx	eax, BYTE PTR _byte$1[ebp]
	shl	ecx, 8
	add	cx, ax
	movzx	ecx, cx

; 341  :                   if (code == KDU_SOP)

	cmp	bx, di
	jne	SHORT $LN9@process_un

; 342  :                     bona_fide = (length == 4);

	cmp	ecx, 4

; 343  :                   else

	jmp	SHORT $LN30@process_un
$LN9@process_un:

; 344  :                     bona_fide = (length == 10);

	cmp	ecx, 10					; 0000000aH
$LN30@process_un:
	sete	dl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 563  :         first_unread-=2;

	add	DWORD PTR [esi+524], -2			; fffffffeH

; 564  :         if (!fully_buffered)

	cmp	BYTE PTR [esi+532], 0
	mov	edi, DWORD PTR [esi+524]
	jne	SHORT $LN21@process_un

; 565  :           {
; 566  :             assert(first_unread >= buffer);
; 567  :             first_unread[0] = (kdu_byte)(code>>8);

	mov	eax, ecx
	shr	eax, 8
	mov	BYTE PTR [edi], al

; 568  :             first_unread[1] = (kdu_byte) code;

	mov	eax, DWORD PTR [esi+524]
	mov	BYTE PTR [eax+1], cl
$LN21@process_un:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 349  :       if (!bona_fide)

	test	dl, dl
	jne	SHORT $LN11@process_un
$LN28@process_un:

; 352  :           have_FF = (last_byte==0xFF);

	cmp	BYTE PTR _last_byte$[ebp], 255		; 000000ffH
	pop	edi
	sete	al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 505  :         this->reject_all = reject_all; throw_markers = true; have_FF = false;

	mov	BYTE PTR [esi+534], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 352  :           have_FF = (last_byte==0xFF);

	mov	BYTE PTR [esi+535], al
	pop	esi
	pop	ebx

; 359  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN11@process_un:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 563  :         first_unread-=2;

	add	DWORD PTR [esi+524], -2			; fffffffeH

; 564  :         if (!fully_buffered)

	cmp	BYTE PTR [esi+532], 0
	mov	ecx, DWORD PTR [esi+524]
	jne	SHORT $LN26@process_un

; 565  :           {
; 566  :             assert(first_unread >= buffer);
; 567  :             first_unread[0] = (kdu_byte)(code>>8);

	mov	eax, ebx
	shr	eax, 8
	mov	BYTE PTR [ecx], al

; 568  :             first_unread[1] = (kdu_byte) code;

	mov	eax, DWORD PTR [esi+524]
	mov	BYTE PTR [eax+1], bl
$LN26@process_un:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 358  :   throw code;

	mov	eax, ebx
	mov	DWORD PTR $T2[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	OFFSET __TI1G
	push	eax
	call	__CxxThrowException@8
$LN33@process_un:
$LN29@process_un:
	int	3
?process_unexpected_marker@kd_input@@AAEXE@Z ENDP	; kd_input::process_unexpected_marker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?ignore@kd_input@@UAE_J_J@Z
_TEXT	SEGMENT
_nbytes$ = -20						; size = 8
_count$1$ = -16						; size = 4
_byte$1 = -12						; size = 1
_nbytes$2$ = -8						; size = 4
_count$2$ = -4						; size = 4
_count$ = 8						; size = 8
_nbytes$1$ = 12						; size = 4
?ignore@kd_input@@UAE_J_J@Z PROC			; kd_input::ignore, COMDAT
; _this$ = ecx

; 505  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 506  :   int xfer_bytes;
; 507  :   kdu_long nbytes = 0;

	movlpd	QWORD PTR _nbytes$[ebp], xmm0

; 508  : 
; 509  :   if (exhausted)

	cmp	BYTE PTR [esi+533], 0
	je	SHORT $LN14@ignore

; 510  :     return 0;

	xor	eax, eax
	xor	edx, edx
	pop	esi

; 540  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN14@ignore:

; 511  : 
; 512  :   while (count > 0)

	mov	eax, DWORD PTR _count$[ebp+4]
	mov	DWORD PTR _count$2$[ebp], eax
	push	ebx
	test	eax, eax
	jl	$LN26@ignore
	mov	ebx, DWORD PTR _count$[ebp]
	jg	SHORT $LN23@ignore
	test	ebx, ebx
	je	$LN26@ignore
$LN23@ignore:
	mov	eax, DWORD PTR _nbytes$[ebp+4]
	mov	DWORD PTR _nbytes$2$[ebp], eax
	mov	eax, DWORD PTR _nbytes$[ebp]
	mov	DWORD PTR _nbytes$1$[ebp], eax
	push	edi
	npad	2
$LL2@ignore:

; 513  :     {
; 514  :       if ((xfer_bytes = (int)(first_unwritten-first_unread)) == 0)

	mov	edi, DWORD PTR [esi+528]
	mov	ecx, DWORD PTR [esi+524]
	sub	edi, ecx
	jne	SHORT $LN7@ignore

; 515  :         {
; 516  :           if (!load_buf())

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	$LN28@ignore

; 517  :             break;
; 518  :           xfer_bytes = (int)(first_unwritten-first_unread);

	mov	edi, DWORD PTR [esi+528]
	mov	ecx, DWORD PTR [esi+524]
	sub	edi, ecx
$LN7@ignore:

; 519  :           assert(xfer_bytes > 0);
; 520  :         }
; 521  :       if (count < (kdu_long) xfer_bytes)

	mov	eax, edi
	cdq
	cmp	DWORD PTR _count$2$[ebp], edx
	jg	SHORT $LN9@ignore
	jl	SHORT $LN24@ignore
	cmp	ebx, eax
	jae	SHORT $LN9@ignore
$LN24@ignore:

; 522  :         xfer_bytes = (int) count;

	mov	edi, ebx
$LN9@ignore:

; 523  :       nbytes += xfer_bytes;

	mov	eax, edi
	cdq
	add	DWORD PTR _nbytes$1$[ebp], eax
	adc	DWORD PTR _nbytes$2$[ebp], edx

; 524  :       count -= xfer_bytes;

	sub	ebx, eax
	mov	eax, DWORD PTR _count$2$[ebp]
	sbb	eax, edx
	mov	DWORD PTR _count$1$[ebp], ebx

; 525  :       if (throw_markers)

	cmp	BYTE PTR [esi+534], 0
	mov	DWORD PTR _count$2$[ebp], eax
	je	SHORT $LN10@ignore

; 526  :         { // Slower loop has to look for marker codes.
; 527  :           kdu_byte byte;
; 528  :           while (xfer_bytes--)

	test	edi, edi
	je	SHORT $LN11@ignore
$LL4@ignore:

; 529  :             {
; 530  :               byte = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	dec	edi
	mov	bl, BYTE PTR [eax]
	inc	eax

; 531  :               if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [esi+535], 0
	mov	BYTE PTR _byte$1[ebp], bl
	mov	DWORD PTR [esi+524], eax
	je	SHORT $LN12@ignore
	cmp	bl, 143					; 0000008fH
	jbe	SHORT $LN12@ignore

; 532  :                 process_unexpected_marker(byte);

	push	DWORD PTR _byte$1[ebp]
	mov	ecx, esi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
$LN12@ignore:

; 533  :               have_FF = (byte==0xFF);

	cmp	bl, 255					; 000000ffH
	sete	al
	mov	BYTE PTR [esi+535], al
	test	edi, edi
	jne	SHORT $LL4@ignore

; 534  :             }
; 535  :         }
; 536  :       else

	mov	ebx, DWORD PTR _count$1$[ebp]
	jmp	SHORT $LN30@ignore
$LN10@ignore:

; 537  :         first_unread += xfer_bytes;

	lea	eax, DWORD PTR [ecx+edi]
	mov	DWORD PTR [esi+524], eax
$LN30@ignore:
	mov	eax, DWORD PTR _count$2$[ebp]
$LN11@ignore:

; 511  : 
; 512  :   while (count > 0)

	test	eax, eax
	jg	$LL2@ignore
	jl	SHORT $LN28@ignore
	test	ebx, ebx
	jne	$LL2@ignore
$LN28@ignore:
	mov	eax, DWORD PTR _nbytes$1$[ebp]

; 538  :     }
; 539  :   return nbytes;

	mov	edx, DWORD PTR _nbytes$2$[ebp]
	pop	edi
	pop	ebx
	pop	esi

; 540  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN26@ignore:

; 511  : 
; 512  :   while (count > 0)

	mov	eax, DWORD PTR _nbytes$[ebp+4]
	mov	DWORD PTR _nbytes$2$[ebp], eax
	mov	eax, DWORD PTR _nbytes$[ebp]

; 538  :     }
; 539  :   return nbytes;

	mov	edx, DWORD PTR _nbytes$2$[ebp]
	pop	ebx
	pop	esi

; 540  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ignore@kd_input@@UAE_J_J@Z ENDP			; kd_input::ignore
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?read@kd_input@@QAEHAAPAUkd_code_buffer@@AAEPAVkd_buf_server@@H@Z
_TEXT	SEGMENT
_xfer_bytes$2$ = -24					; size = 4
_nbytes$1$ = -20					; size = 4
_byte$1 = -16						; size = 1
_cbp$1$ = -12						; size = 4
_cbuf_remains$1$ = -8					; size = 4
_byte$2$ = -1						; size = 1
_cbuf$ = 8						; size = 4
_cbuf_pos$ = 12						; size = 4
_buf_server$ = 16					; size = 4
_count$ = 20						; size = 4
?read@kd_input@@QAEHAAPAUkd_code_buffer@@AAEPAVkd_buf_server@@H@Z PROC ; kd_input::read, COMDAT
; _this$ = ecx

; 412  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	mov	esi, ecx

; 413  :   int xfer_bytes;
; 414  :   int nbytes = 0;

	xor	ebx, ebx
	mov	DWORD PTR _nbytes$1$[ebp], ebx

; 415  : 
; 416  :   if (exhausted)

	cmp	BYTE PTR [esi+533], bl
	je	SHORT $LN13@read

; 417  :     return 0;

	pop	esi
	xor	eax, eax
	pop	ebx

; 497  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN13@read:

; 418  : 
; 419  :   // Create local working variables in place of `cbuf' and `cbpos' to
; 420  :   // maximize access efficiency in the loop.  Copy modified results back
; 421  :   // once we are done.
; 422  :   kd_code_buffer *cbp = cbuf;

	mov	edx, DWORD PTR _cbuf$[ebp]

; 423  :   kdu_byte *cbuf_dest = cbp->buf + cbuf_pos;
; 424  :   int cbuf_remains = KD_CODE_BUFFER_LEN - cbuf_pos;

	mov	ecx, 58					; 0000003aH
	mov	eax, DWORD PTR _cbuf_pos$[ebp]
	push	edi
	mov	edx, DWORD PTR [edx]
	movzx	eax, BYTE PTR [eax]
	sub	ecx, eax
	mov	DWORD PTR _cbp$1$[ebp], edx
	mov	DWORD PTR _cbuf_remains$1$[ebp], ecx
	lea	edi, DWORD PTR [edx+6]
	add	edi, eax

; 425  :   while (count > 0)

	cmp	DWORD PTR _count$[ebp], ebx
	jle	$LN33@read
	mov	edx, DWORD PTR _count$[ebp]
	npad	5
$LL2@read:

; 426  :     {
; 427  :       if ((xfer_bytes = (int)(first_unwritten-first_unread)) == 0)

	mov	eax, DWORD PTR [esi+528]
	sub	eax, DWORD PTR [esi+524]
	jne	SHORT $LN14@read

; 428  :         {
; 429  :           if (!load_buf())

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	$LN47@read

; 430  :             break;
; 431  :           xfer_bytes = (int)(first_unwritten-first_unread);

	mov	eax, DWORD PTR [esi+528]
	sub	eax, DWORD PTR [esi+524]
	mov	ecx, DWORD PTR _cbuf_remains$1$[ebp]
	mov	edx, DWORD PTR _count$[ebp]
$LN14@read:

; 432  :           assert(xfer_bytes > 0);
; 433  :         }
; 434  :       xfer_bytes = (xfer_bytes < count)?xfer_bytes:count;

	cmp	eax, edx
	mov	ebx, edx
	cmovl	ebx, eax

; 435  :       nbytes += xfer_bytes;

	add	DWORD PTR _nbytes$1$[ebp], ebx

; 436  :       count -= xfer_bytes;

	sub	edx, ebx

; 437  :       if (!throw_markers)

	cmp	BYTE PTR [esi+534], 0
	mov	DWORD PTR _count$[ebp], edx
	jne	SHORT $LN27@read

; 438  :         while (1)
; 439  :           {
; 440  :             if (xfer_bytes <= cbuf_remains)

	cmp	ebx, ecx
	jle	SHORT $LN31@read
	npad	3
$LL4@read:

; 446  :                 break;
; 447  :               }
; 448  :             else
; 449  :               {
; 450  :                 memcpy(cbuf_dest,first_unread,(size_t) cbuf_remains);

	push	ecx
	push	DWORD PTR [esi+524]
	push	edi
	call	_memcpy

; 451  :                 xfer_bytes -= cbuf_remains;

	mov	eax, DWORD PTR _cbuf_remains$1$[ebp]
	add	esp, 12					; 0000000cH

; 452  :                 cbuf_dest += cbuf_remains;
; 453  :                 first_unread += cbuf_remains;
; 454  :                 cbp = cbp->next = buf_server->get();

	mov	ecx, DWORD PTR _buf_server$[ebp]
	sub	ebx, eax
	add	DWORD PTR [esi+524], eax
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	ecx, DWORD PTR _cbp$1$[ebp]
	mov	DWORD PTR _cbp$1$[ebp], eax

; 455  :                 cbuf_remains = KD_CODE_BUFFER_LEN;
; 456  :                 cbuf_dest = cbp->buf;

	lea	edi, DWORD PTR [eax+6]
	mov	DWORD PTR [ecx], eax
	mov	ecx, 58					; 0000003aH
	mov	DWORD PTR _cbuf_remains$1$[ebp], ecx
	cmp	ebx, ecx
	jg	SHORT $LL4@read
$LN31@read:

; 441  :               {
; 442  :                 memcpy(cbuf_dest,first_unread,(size_t) xfer_bytes);

	push	ebx
	push	DWORD PTR [esi+524]
	push	edi
	call	_memcpy

; 443  :                 cbuf_remains -= xfer_bytes;

	mov	ecx, DWORD PTR _cbuf_remains$1$[ebp]
	add	esp, 12					; 0000000cH
	sub	ecx, ebx

; 444  :                 cbuf_dest += xfer_bytes;

	add	edi, ebx

; 445  :                 first_unread += xfer_bytes;

	add	DWORD PTR [esi+524], ebx
	mov	DWORD PTR _cbuf_remains$1$[ebp], ecx

; 457  :               }
; 458  :           }
; 459  :       else

	jmp	$LN48@read
$LN27@read:

; 460  :         { // Slower loop has to look for marker codes.
; 461  :           kdu_byte byte;
; 462  :           while (1)
; 463  :             {
; 464  :               if (xfer_bytes <= cbuf_remains)

	cmp	ebx, ecx
	jle	$LN32@read
$LL6@read:

; 473  :                     }
; 474  :                   break;
; 475  :                 }
; 476  :               else
; 477  :                 {
; 478  :                   xfer_bytes -= cbuf_remains;

	sub	ebx, ecx
	mov	DWORD PTR _xfer_bytes$2$[ebp], ebx

; 479  :                   for (; cbuf_remains > 0; cbuf_remains--)

	test	ecx, ecx
	jle	SHORT $LN11@read
$LL12@read:

; 480  :                     {
; 481  :                       *(cbuf_dest++) = byte = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	lea	edi, DWORD PTR [edi+1]
	mov	bl, BYTE PTR [eax]
	mov	BYTE PTR [edi-1], bl
	inc	DWORD PTR [esi+524]

; 482  :                       if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [esi+535], 0
	mov	BYTE PTR _byte$1[ebp], bl
	je	SHORT $LN23@read
	cmp	bl, 143					; 0000008fH
	jbe	SHORT $LN23@read

; 483  :                         process_unexpected_marker(byte);

	push	DWORD PTR _byte$1[ebp]
	mov	ecx, esi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
	mov	ecx, DWORD PTR _cbuf_remains$1$[ebp]
$LN23@read:

; 484  :                       have_FF = (byte==0xFF);

	cmp	bl, 255					; 000000ffH
	sete	al
	dec	ecx
	mov	BYTE PTR [esi+535], al
	mov	DWORD PTR _cbuf_remains$1$[ebp], ecx
	test	ecx, ecx
	jg	SHORT $LL12@read
	mov	ebx, DWORD PTR _xfer_bytes$2$[ebp]
$LN11@read:

; 485  :                     }
; 486  :                   cbp = cbp->next = buf_server->get();

	mov	ecx, DWORD PTR _buf_server$[ebp]
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	ecx, DWORD PTR _cbp$1$[ebp]
	mov	edx, eax
	mov	DWORD PTR _cbp$1$[ebp], edx
	mov	DWORD PTR [ecx], eax

; 487  :                   cbuf_remains = KD_CODE_BUFFER_LEN;
; 488  :                   cbuf_dest = cbp->buf;

	lea	edi, DWORD PTR [edx+6]
	mov	ecx, 58					; 0000003aH
	mov	DWORD PTR _cbuf_remains$1$[ebp], ecx
	cmp	ebx, ecx
	jg	SHORT $LL6@read
	mov	edx, DWORD PTR _count$[ebp]
$LN32@read:

; 465  :                 {
; 466  :                   cbuf_remains -= xfer_bytes;

	sub	ecx, ebx
	mov	DWORD PTR _cbuf_remains$1$[ebp], ecx

; 467  :                   while (xfer_bytes--)

	test	ebx, ebx
	je	SHORT $LN35@read
$LL8@read:

; 468  :                     {
; 469  :                       *(cbuf_dest++) = byte = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	dec	ebx
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edi], al
	inc	edi
	inc	DWORD PTR [esi+524]

; 470  :                       if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [esi+535], 0
	mov	BYTE PTR _byte$2$[ebp], al
	mov	BYTE PTR _byte$1[ebp], al
	je	SHORT $LN22@read
	cmp	al, 143					; 0000008fH
	jbe	SHORT $LN22@read

; 471  :                         process_unexpected_marker(byte);

	push	DWORD PTR _byte$1[ebp]
	mov	ecx, esi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
	mov	al, BYTE PTR _byte$2$[ebp]
$LN22@read:

; 472  :                       have_FF = (byte==0xFF);

	cmp	al, 255					; 000000ffH
	sete	al
	mov	BYTE PTR [esi+535], al
	test	ebx, ebx
	jne	SHORT $LL8@read
	mov	ecx, DWORD PTR _cbuf_remains$1$[ebp]
$LN48@read:
	mov	edx, DWORD PTR _count$[ebp]
$LN35@read:

; 425  :   while (count > 0)

	test	edx, edx
	jg	$LL2@read
$LN47@read:
	mov	edx, DWORD PTR _cbp$1$[ebp]
	mov	ebx, DWORD PTR _nbytes$1$[ebp]
$LN33@read:

; 489  :                 }
; 490  :             }
; 491  :         }
; 492  :     }
; 493  : 
; 494  :   cbuf = cbp;

	mov	eax, DWORD PTR _cbuf$[ebp]

; 495  :   cbuf_pos = (kdu_byte)(KD_CODE_BUFFER_LEN-cbuf_remains);

	mov	cl, 58					; 0000003aH
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _cbuf_remains$1$[ebp]
	sub	cl, al
	mov	eax, DWORD PTR _cbuf_pos$[ebp]
	mov	BYTE PTR [eax], cl

; 496  :   return nbytes;

	mov	eax, ebx
	pop	ebx

; 497  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?read@kd_input@@QAEHAAPAUkd_code_buffer@@AAEPAVkd_buf_server@@H@Z ENDP ; kd_input::read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?read@kd_input@@QAEHPAEH@Z
_TEXT	SEGMENT
_nbytes$1$ = -4						; size = 4
_byte$1 = 8						; size = 1
_buf$ = 8						; size = 4
_count$ = 12						; size = 4
?read@kd_input@@QAEHPAEH@Z PROC				; kd_input::read, COMDAT
; _this$ = ecx

; 367  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 368  :   int xfer_bytes;
; 369  :   int nbytes = 0;

	xor	edx, edx
	mov	DWORD PTR _nbytes$1$[ebp], edx

; 370  : 
; 371  :   if (exhausted)

	cmp	BYTE PTR [esi+533], dl
	je	SHORT $LN15@read

; 372  :     return 0;

	xor	eax, eax
	pop	esi

; 403  : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN15@read:

; 373  :   while (count > 0)

	mov	ecx, DWORD PTR _count$[ebp]
	test	ecx, ecx
	jle	$LN18@read
	push	ebx
	mov	ebx, DWORD PTR _buf$[ebp]
	push	edi
	npad	3
$LL2@read:

; 374  :     {
; 375  :       if ((xfer_bytes = (int)(first_unwritten-first_unread)) == 0)

	mov	eax, DWORD PTR [esi+528]
	sub	eax, DWORD PTR [esi+524]
	jne	SHORT $LN9@read

; 376  :         {
; 377  :           if (!load_buf())

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	$LN29@read

; 378  :             break;
; 379  :           xfer_bytes = (int)(first_unwritten-first_unread);

	mov	eax, DWORD PTR [esi+528]
	sub	eax, DWORD PTR [esi+524]
	mov	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _nbytes$1$[ebp]
$LN9@read:

; 380  :           assert(xfer_bytes > 0);
; 381  :         }
; 382  :       xfer_bytes = (xfer_bytes < count)?xfer_bytes:count;

	cmp	eax, ecx
	mov	edi, ecx
	cmovl	edi, eax

; 383  :       nbytes += xfer_bytes;

	add	edx, edi

; 384  :       count -= xfer_bytes;

	sub	ecx, edi

; 385  :       if (throw_markers)

	cmp	BYTE PTR [esi+534], 0
	mov	DWORD PTR _nbytes$1$[ebp], edx
	mov	DWORD PTR _count$[ebp], ecx
	je	SHORT $LN17@read

; 386  :         { // Slower loop has to look for marker codes.
; 387  :           kdu_byte byte;
; 388  :           while (xfer_bytes--)

	test	edi, edi
	je	SHORT $LN21@read
	npad	1
$LL4@read:

; 389  :             {
; 390  :               *(buf++) = byte = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	dec	edi
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ebx], al
	inc	ebx
	inc	DWORD PTR [esi+524]

; 391  :               if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [esi+535], 0
	mov	BYTE PTR _byte$1[ebp], al
	je	SHORT $LN13@read
	cmp	al, 143					; 0000008fH
	jbe	SHORT $LN13@read

; 392  :                 process_unexpected_marker(byte);

	push	DWORD PTR _byte$1[ebp]
	mov	ecx, esi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
	mov	al, BYTE PTR _byte$1[ebp]
$LN13@read:

; 393  :               have_FF = (byte==0xFF);

	cmp	al, 255					; 000000ffH
	sete	al
	mov	BYTE PTR [esi+535], al
	test	edi, edi
	jne	SHORT $LL4@read

; 394  :             }
; 395  :         }
; 396  :       else

	mov	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _nbytes$1$[ebp]
	jmp	SHORT $LN21@read
$LN17@read:

; 397  :         { // Fastest loop. Probably not beneficial to use `memcpy'.
; 398  :           while (xfer_bytes--)

	test	edi, edi
	je	SHORT $LN21@read
	npad	6
$LL6@read:

; 399  :             *(buf++) = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ebx], al
	inc	ebx
	inc	DWORD PTR [esi+524]
	sub	edi, 1
	jne	SHORT $LL6@read
$LN21@read:

; 373  :   while (count > 0)

	test	ecx, ecx
	jg	$LL2@read
$LN29@read:
	mov	edx, DWORD PTR _nbytes$1$[ebp]
	pop	edi
	pop	ebx
$LN18@read:

; 400  :         }
; 401  :     }
; 402  :   return nbytes;

	mov	eax, edx
	pop	esi

; 403  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?read@kd_input@@QAEHPAEH@Z ENDP				; kd_input::read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?putback@kd_input@@QAEXG@Z
_TEXT	SEGMENT
_code$ = 8						; size = 2
?putback@kd_input@@QAEXG@Z PROC				; kd_input::putback, COMDAT
; _this$ = ecx

; 558  :       { /* This function is designed to improve the readability of code

	push	ebp
	mov	ebp, esp

; 559  :            which puts marker codes back to the input object from which they
; 560  :            were read. */
; 561  :         assert(!exhausted);
; 562  :         assert(!throw_markers);
; 563  :         first_unread-=2;

	add	DWORD PTR [ecx+524], -2			; fffffffeH

; 564  :         if (!fully_buffered)

	cmp	BYTE PTR [ecx+532], 0
	push	esi
	mov	esi, DWORD PTR [ecx+524]
	jne	SHORT $LN2@putback

; 565  :           {
; 566  :             assert(first_unread >= buffer);
; 567  :             first_unread[0] = (kdu_byte)(code>>8);

	mov	edx, DWORD PTR _code$[ebp]
	mov	eax, edx
	shr	eax, 8
	mov	BYTE PTR [esi], al

; 568  :             first_unread[1] = (kdu_byte) code;

	mov	eax, DWORD PTR [ecx+524]
	mov	BYTE PTR [eax+1], dl
$LN2@putback:
	pop	esi

; 569  :           }
; 570  :       }

	pop	ebp
	ret	4
?putback@kd_input@@QAEXG@Z ENDP				; kd_input::putback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?putback@kd_input@@QAEXE@Z
_TEXT	SEGMENT
_byte$ = 8						; size = 1
?putback@kd_input@@QAEXE@Z PROC				; kd_input::putback, COMDAT
; _this$ = ecx

; 545  :       { /* You may put back more than 1 byte, but you may not call this

	push	ebp
	mov	ebp, esp

; 546  :            function if a previous read has ever failed.  It is also illegal
; 547  :            to call this function while marker throwing is enabled. */
; 548  :         assert(!exhausted);
; 549  :         assert(!throw_markers);
; 550  :         first_unread--;

	dec	DWORD PTR [ecx+524]

; 551  :         if (!fully_buffered)

	cmp	BYTE PTR [ecx+532], 0
	mov	edx, DWORD PTR [ecx+524]
	jne	SHORT $LN2@putback

; 552  :           {
; 553  :             assert(first_unread >= buffer);
; 554  :             *first_unread = byte;

	mov	al, BYTE PTR _byte$[ebp]
	mov	BYTE PTR [edx], al
$LN2@putback:

; 555  :           }
; 556  :       }

	pop	ebp
	ret	4
?putback@kd_input@@QAEXE@Z ENDP				; kd_input::putback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get@kd_input@@QAE_NAAE@Z
_TEXT	SEGMENT
_byte$ = 8						; size = 4
?get@kd_input@@QAE_NAAE@Z PROC				; kd_input::get, COMDAT
; _this$ = ecx

; 531  :       { /* Access a single byte, returning false if and only if the source is

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 532  :            exhausted, in which case future calls to `failed' return true. */
; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))

	cmp	BYTE PTR [esi+533], 0
	jne	SHORT $LN3@get
	mov	eax, DWORD PTR [esi+524]
	cmp	eax, DWORD PTR [esi+528]
	jne	SHORT $LN2@get
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	SHORT $LN3@get
$LN2@get:

; 535  :         byte = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	push	edi
	mov	edi, DWORD PTR _byte$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edi], al
	inc	DWORD PTR [esi+524]

; 536  :         if (throw_markers)

	cmp	BYTE PTR [esi+534], 0
	je	SHORT $LN4@get

; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [esi+535], 0
	je	SHORT $LN5@get
	mov	al, BYTE PTR [edi]
	cmp	al, 143					; 0000008fH
	jbe	SHORT $LN5@get

; 539  :               process_unexpected_marker(byte);

	push	eax
	mov	ecx, esi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
$LN5@get:

; 540  :             have_FF = (byte==0xFF);

	cmp	BYTE PTR [edi], 255			; 000000ffH
	sete	al
	mov	BYTE PTR [esi+535], al
$LN4@get:

; 541  :           }
; 542  :         return true;

	pop	edi
	mov	al, 1
	pop	esi

; 543  :       }

	pop	ebp
	ret	4
$LN3@get:

; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.

	xor	al, al
	pop	esi

; 543  :       }

	pop	ebp
	ret	4
?get@kd_input@@QAE_NAAE@Z ENDP				; kd_input::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?failed@kd_input@@QAE_NXZ
_TEXT	SEGMENT
?failed@kd_input@@QAE_NXZ PROC				; kd_input::failed, COMDAT
; _this$ = ecx

; 526  :            `ignore' failed to completely fulfill its objective due to
; 527  :            exhaustion of the relevant source. */
; 528  :         return exhausted;

	mov	al, BYTE PTR [ecx+533]

; 529  :       }

	ret	0
?failed@kd_input@@QAE_NXZ ENDP				; kd_input::failed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?terminate_prematurely@kd_input@@QAEXXZ
_TEXT	SEGMENT
?terminate_prematurely@kd_input@@QAEXXZ PROC		; kd_input::terminate_prematurely, COMDAT
; _this$ = ecx

; 521  :            is encountered before the stream physically ends. */
; 522  :         exhausted = true;

	mov	BYTE PTR [ecx+533], 1

; 523  :       }

	ret	0
?terminate_prematurely@kd_input@@QAEXXZ ENDP		; kd_input::terminate_prematurely
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?disable_marker_throwing@kd_input@@QAE_NXZ
_TEXT	SEGMENT
?disable_marker_throwing@kd_input@@QAE_NXZ PROC		; kd_input::disable_marker_throwing, COMDAT
; _this$ = ecx

; 509  :            last byte which was read was an FF, in which case the function
; 510  :            returns false.  This allows the caller to catch markers which
; 511  :            were partially read.  Any code-stream segment which is not
; 512  :            permitted to contain a marker code in the range FF90 through FFFF
; 513  :            is also not permitted to terminate with an FF. */
; 514  :         if (!throw_markers) return true;

	cmp	BYTE PTR [ecx+534], 0
	jne	SHORT $LN2@disable_ma
	mov	al, 1

; 518  :       }

	ret	0
$LN2@disable_ma:

; 515  :         throw_markers = false; // Must not touch `reject_all' here.
; 516  :         if (exhausted) have_FF = false;

	cmp	BYTE PTR [ecx+533], 0
	mov	BYTE PTR [ecx+534], 0
	je	SHORT $LN3@disable_ma
	mov	BYTE PTR [ecx+535], 0
$LN3@disable_ma:

; 517  :         return !have_FF;

	xor	eax, eax
	cmp	BYTE PTR [ecx+535], al
	sete	al

; 518  :       }

	ret	0
?disable_marker_throwing@kd_input@@QAE_NXZ ENDP		; kd_input::disable_marker_throwing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?enable_marker_throwing@kd_input@@QAEX_N@Z
_TEXT	SEGMENT
_reject_all$ = 8					; size = 1
?enable_marker_throwing@kd_input@@QAEX_N@Z PROC		; kd_input::enable_marker_throwing, COMDAT
; _this$ = ecx

; 489  :       { /* If `reject_all' is false, subsequent reads will throw an exception

	push	ebp
	mov	ebp, esp

; 490  :            if a bona fide SOP or SOT marker is found. In this case, the
; 491  :            function will check to make sure that the length field is correct,
; 492  :            putting the length field and marker code bytes back to the source
; 493  :            before throwing the exception, so that the catch statement can read
; 494  :            them again.
; 495  :               If `reject_all' is true, subsequent reads will throw an
; 496  :            exception if any marker code in the range FF90 to FFFF is found.
; 497  :            Again, the marker code itself is put back onto the stream before
; 498  :            throwing the exception.
; 499  :               Marker throwing is disabled before throwing an exception for
; 500  :            either of the above reasons.
; 501  :               Note that code-stream reading may be slowed down
; 502  :            when this marker throwing is enabled.  For this reason, the
; 503  :            capability is best used only when error resilience or error
; 504  :            detection capabilities are required. */
; 505  :         this->reject_all = reject_all; throw_markers = true; have_FF = false;

	mov	al, BYTE PTR _reject_all$[ebp]
	mov	BYTE PTR [ecx+536], al
	mov	WORD PTR [ecx+534], 1

; 506  :       }

	pop	ebp
	ret	4
?enable_marker_throwing@kd_input@@QAEX_N@Z ENDP		; kd_input::enable_marker_throwing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?is_fully_buffered@kd_input@@QAE_NXZ
_TEXT	SEGMENT
?is_fully_buffered@kd_input@@QAE_NXZ PROC		; kd_input::is_fully_buffered, COMDAT
; _this$ = ecx

; 487  :     bool is_fully_buffered() { return fully_buffered; }

	mov	al, BYTE PTR [ecx+532]
	ret	0
?is_fully_buffered@kd_input@@QAE_NXZ ENDP		; kd_input::is_fully_buffered
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_input@@UAE@XZ
_TEXT	SEGMENT
??1kd_input@@UAE@XZ PROC				; kd_input::~kd_input, COMDAT
; _this$ = ecx

; 486  :     virtual ~kd_input() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kd_input@@6B@
	ret	0
??1kd_input@@UAE@XZ ENDP				; kd_input::~kd_input
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_input@@QAE@XZ
_TEXT	SEGMENT
??0kd_input@@QAE@XZ PROC				; kd_input::kd_input, COMDAT
; _this$ = ecx

; 484  :       { first_unread = first_unwritten = buffer+KD_IBUF_PUTBACK;

	lea	eax, DWORD PTR [ecx+10]
	mov	DWORD PTR [ecx], OFFSET ??_7kd_input@@6B@
	mov	DWORD PTR [ecx+528], eax
	mov	DWORD PTR [ecx+524], eax

; 485  :         exhausted = fully_buffered = throw_markers = false; }

	mov	eax, ecx
	mov	WORD PTR [ecx+533], 0
	mov	BYTE PTR [ecx+532], 0
	ret	0
??0kd_input@@QAE@XZ ENDP				; kd_input::kd_input
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Gkd_compressed_output@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gkd_compressed_output@@UAEPAXI@Z PROC		; kd_compressed_output::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Gkd_compressed_output@@UAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 458  :         if (next_buf > buffer)

	mov	edx, DWORD PTR [esi+516]
	lea	edi, DWORD PTR [esi+4]

; 443  :       { flush_buf(); }

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7kd_compressed_output@@6B@

; 458  :         if (next_buf > buffer)

	cmp	edx, edi
	jbe	SHORT $LN8@scalar

; 459  :           target->write(buffer,(int)(next_buf-buffer));

	mov	ecx, DWORD PTR [esi+524]
	sub	edx, esi
	sub	edx, 4
	push	edx
	push	edi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]
$LN8@scalar:

; 460  :         flushed_bytes += next_buf - buffer;

	mov	eax, DWORD PTR [esi+516]
	sub	eax, esi

; 461  :         next_buf = buffer;

	mov	DWORD PTR [esi+516], edi
	sub	eax, 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 132  :     virtual ~kdu_output() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_output@@6B@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 460  :         flushed_bytes += next_buf - buffer;

	cdq
	add	DWORD PTR [esi+528], eax
	adc	DWORD PTR [esi+532], edx
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN13@scalar
	push	536					; 00000218H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@scalar:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gkd_compressed_output@@UAEPAXI@Z$0:
	call	___std_terminate
	ret	0
__ehhandler$??_Gkd_compressed_output@@UAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Gkd_compressed_output@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Gkd_compressed_output@@UAEPAXI@Z ENDP		; kd_compressed_output::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?flush_buf@kd_compressed_output@@MAEXXZ
_TEXT	SEGMENT
?flush_buf@kd_compressed_output@@MAEXXZ PROC		; kd_compressed_output::flush_buf, COMDAT
; _this$ = ecx

; 457  :       {

	push	esi
	mov	esi, ecx
	push	edi

; 458  :         if (next_buf > buffer)

	mov	edx, DWORD PTR [esi+516]
	lea	edi, DWORD PTR [esi+4]
	cmp	edx, edi
	jbe	SHORT $LN2@flush_buf

; 459  :           target->write(buffer,(int)(next_buf-buffer));

	mov	ecx, DWORD PTR [esi+524]
	sub	edx, esi
	sub	edx, 4
	push	edx
	push	edi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]
$LN2@flush_buf:

; 460  :         flushed_bytes += next_buf - buffer;

	mov	eax, DWORD PTR [esi+516]
	sub	eax, esi

; 461  :         next_buf = buffer;

	mov	DWORD PTR [esi+516], edi
	sub	eax, 4
	cdq
	add	DWORD PTR [esi+528], eax
	pop	edi
	adc	DWORD PTR [esi+532], edx
	pop	esi

; 462  :       }

	ret	0
?flush_buf@kd_compressed_output@@MAEXXZ ENDP		; kd_compressed_output::flush_buf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?flush@kd_compressed_output@@QAEXXZ
_TEXT	SEGMENT
?flush@kd_compressed_output@@QAEXXZ PROC		; kd_compressed_output::flush, COMDAT
; _this$ = ecx

; 454  :       { flush_buf(); }

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+4]
?flush@kd_compressed_output@@QAEXXZ ENDP		; kd_compressed_output::flush
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_bytes_written@kd_compressed_output@@QAE_JXZ
_TEXT	SEGMENT
?get_bytes_written@kd_compressed_output@@QAE_JXZ PROC	; kd_compressed_output::get_bytes_written, COMDAT
; _this$ = ecx

; 452  :       { return (flushed_bytes + (next_buf-buffer)); }

	mov	eax, DWORD PTR [ecx+516]
	sub	eax, ecx
	sub	eax, 4
	cdq
	add	eax, DWORD PTR [ecx+528]
	adc	edx, DWORD PTR [ecx+532]
	ret	0
?get_bytes_written@kd_compressed_output@@QAE_JXZ ENDP	; kd_compressed_output::get_bytes_written
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?access_tgt@kd_compressed_output@@QAEPAVkdu_compressed_target@@XZ
_TEXT	SEGMENT
?access_tgt@kd_compressed_output@@QAEPAVkdu_compressed_target@@XZ PROC ; kd_compressed_output::access_tgt, COMDAT
; _this$ = ecx

; 445  :       { /* You may call this function to access the underlying `target'

	push	esi
	mov	esi, ecx

; 446  :            object, but you should never manipulate that object if you
; 447  :            have written anything to the present object, without re-accessing
; 448  :            it. */
; 449  :            flush_buf();  return target;

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi+524]
	pop	esi

; 450  :       }

	ret	0
?access_tgt@kd_compressed_output@@QAEPAVkdu_compressed_target@@XZ ENDP ; kd_compressed_output::access_tgt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_compressed_output@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_compressed_output@@UAE@XZ PROC			; kd_compressed_output::~kd_compressed_output, COMDAT
; _this$ = ecx

; 443  :       { flush_buf(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_compressed_output@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 444  :     kdu_compressed_target *access_tgt()
; 445  :       { /* You may call this function to access the underlying `target'
; 446  :            object, but you should never manipulate that object if you
; 447  :            have written anything to the present object, without re-accessing
; 448  :            it. */
; 449  :            flush_buf();  return target;
; 450  :       }
; 451  :     kdu_long get_bytes_written()
; 452  :       { return (flushed_bytes + (next_buf-buffer)); }
; 453  :     void flush()
; 454  :       { flush_buf(); }
; 455  :   protected: // Virtual functions which implement required services.
; 456  :     virtual void flush_buf()
; 457  :       {
; 458  :         if (next_buf > buffer)

	mov	edx, DWORD PTR [esi+516]
	lea	edi, DWORD PTR [esi+4]

; 443  :       { flush_buf(); }

	mov	DWORD PTR [esi], OFFSET ??_7kd_compressed_output@@6B@

; 444  :     kdu_compressed_target *access_tgt()
; 445  :       { /* You may call this function to access the underlying `target'
; 446  :            object, but you should never manipulate that object if you
; 447  :            have written anything to the present object, without re-accessing
; 448  :            it. */
; 449  :            flush_buf();  return target;
; 450  :       }
; 451  :     kdu_long get_bytes_written()
; 452  :       { return (flushed_bytes + (next_buf-buffer)); }
; 453  :     void flush()
; 454  :       { flush_buf(); }
; 455  :   protected: // Virtual functions which implement required services.
; 456  :     virtual void flush_buf()
; 457  :       {
; 458  :         if (next_buf > buffer)

	cmp	edx, edi
	jbe	SHORT $LN4@kd_compres

; 459  :           target->write(buffer,(int)(next_buf-buffer));

	mov	ecx, DWORD PTR [esi+524]
	sub	edx, esi
	sub	edx, 4
	push	edx
	push	edi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+16]
$LN4@kd_compres:

; 460  :         flushed_bytes += next_buf - buffer;

	mov	eax, DWORD PTR [esi+516]
	sub	eax, esi

; 461  :         next_buf = buffer;

	mov	DWORD PTR [esi+516], edi
	sub	eax, 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 132  :     virtual ~kdu_output() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_output@@6B@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 460  :         flushed_bytes += next_buf - buffer;

	cdq
	add	DWORD PTR [esi+528], eax
	adc	DWORD PTR [esi+532], edx

; 443  :       { flush_buf(); }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kd_compressed_output@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_compressed_output@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_compressed_output@@UAE@XZ ENDP			; kd_compressed_output::~kd_compressed_output
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_compressed_output@@QAE@PAVkdu_compressed_target@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_target$ = 8						; size = 4
??0kd_compressed_output@@QAE@PAVkdu_compressed_target@@@Z PROC ; kd_compressed_output::kd_compressed_output, COMDAT
; _this$ = ecx

; 440  :     kd_compressed_output(kdu_compressed_target *target)

	push	ebp
	mov	ebp, esp
	push	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 131  :       { next_buf = buffer; end_buf = buffer+KDU_OBUF_SIZE; }

	lea	edx, DWORD PTR [ecx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 440  :     kd_compressed_output(kdu_compressed_target *target)

	mov	DWORD PTR _this$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 131  :       { next_buf = buffer; end_buf = buffer+KDU_OBUF_SIZE; }

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+520], edx
	mov	DWORD PTR [edx], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 441  :       { this->target=target; flushed_bytes = 0; }

	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR [ecx+524], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kd_compressed_output@@6B@
	mov	DWORD PTR [ecx+528], 0
	mov	DWORD PTR [ecx+532], 0
	mov	esp, ebp
	pop	ebp
	ret	4
??0kd_compressed_output@@QAE@PAVkdu_compressed_target@@@Z ENDP ; kd_compressed_output::kd_compressed_output
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?reset@kd_thread_buf_server@@AAEXXZ
_TEXT	SEGMENT
?reset@kd_thread_buf_server@@AAEXXZ PROC		; kd_thread_buf_server::reset, COMDAT
; _this$ = ecx

; 410  :         // us from its attached thread buffer list.  This function is also
; 411  :         // used to do most of the work of our own constructor.
; 412  :         ultimate_buf_server = NULL;

	mov	DWORD PTR [ecx+24], 0

; 413  :         next_attached = prev_attached = NULL;

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+28], 0

; 414  :         ref_available_buffers = 0;

	mov	DWORD PTR [ecx+12], 0

; 415  :         peak_buffers = 0;

	mov	DWORD PTR [ecx+4], 0

; 416  :         num_available_buffers = 0;

	mov	DWORD PTR [ecx+8], 0

; 417  :         head = tail = NULL;

	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+16], 0

; 418  :       }

	ret	0
?reset@kd_thread_buf_server@@AAEXXZ ENDP		; kd_thread_buf_server::reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?augment_local_store@kd_thread_buf_server@@QAEX_N@Z
_TEXT	SEGMENT
_lock$1$ = -8						; size = 4
_new_tail$ = -4						; size = 4
$T1 = 8							; size = 4
_general_lock_held$ = 8					; size = 1
?augment_local_store@kd_thread_buf_server@@QAEX_N@Z PROC ; kd_thread_buf_server::augment_local_store, COMDAT
; _this$ = ecx

; 2105 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx

; 2106 :   int new_buffers = peak_buffers - num_available_buffers;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, eax
	sub	ecx, DWORD PTR [esi+8]

; 2107 :   if (peak_buffers == 0)

	test	eax, eax
	jne	SHORT $LN3@augment_lo

; 2108 :     {
; 2109 :       new_buffers = ref_available_buffers + 1;
; 2110 :       new_buffers *= KD_THREAD_PEAK_STORE_FAC;

	mov	eax, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [eax*4+4]

; 2111 :       if (new_buffers < 32)

	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN3@augment_lo

; 2112 :         new_buffers = 32;

	mov	ecx, 32					; 00000020H

; 2113 :     }
; 2114 :   if (new_buffers <= 0)

	jmp	SHORT $LN24@augment_lo
$LN3@augment_lo:
	test	ecx, ecx
	jle	$LN1@augment_lo
$LN24@augment_lo:

; 2115 :     return;
; 2116 :   int new_pages = 1 + ((new_buffers-1) / KDU_CODE_BUFFERS_PER_PAGE);

	lea	eax, DWORD PTR [ecx-1]

; 2117 :   new_buffers = new_pages*KDU_CODE_BUFFERS_PER_PAGE;
; 2118 :   kd_code_buffer *new_head=NULL, *new_tail=NULL;

	mov	DWORD PTR _new_tail$[ebp], 0
	cdq
	and	edx, 3
	push	ebx
	push	edi
	lea	ebx, DWORD PTR [edx+eax]
	sar	ebx, 2
	inc	ebx

; 2119 :   if (!general_lock_held)

	cmp	BYTE PTR _general_lock_held$[ebp], 0
	jne	SHORT $LN12@augment_lo

; 2120 :     env->owner->acquire_lock(KD_THREADLOCK_GENERAL);

	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR [eax+128]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [edi+28]
	mov	DWORD PTR _lock$1$[ebp], ecx
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN26@augment_lo
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN15@augment_lo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	ecx, DWORD PTR _lock$1$[ebp]
$LN15@augment_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [ecx+4], edi
$LN12@augment_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2122 :   new_head = ultimate_buf_server->get_page_block(new_pages,new_tail);

	mov	ecx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR _new_tail$[ebp]
	push	eax
	push	ebx
	call	?get_page_block@kd_buf_server@@QAEPAUkd_code_buffer@@HAAPAU2@@Z ; kd_buf_server::get_page_block

; 2123 :   if (!general_lock_held)

	cmp	BYTE PTR _general_lock_held$[ebp], 0
	mov	edi, eax
	jne	SHORT $LN22@augment_lo
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+128]
	mov	ecx, DWORD PTR [ecx+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [ecx+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN22@augment_lo
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
$LN22@augment_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2125 :   if (tail != NULL)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN7@augment_lo

; 2126 :     tail->next = new_head;

	mov	DWORD PTR [eax], edi

; 2127 :   else

	jmp	SHORT $LN8@augment_lo
$LN7@augment_lo:

; 2128 :     head = new_head;

	mov	DWORD PTR [esi+16], edi
$LN8@augment_lo:

; 2129 :   tail = new_tail;

	mov	eax, DWORD PTR _new_tail$[ebp]
	mov	DWORD PTR [esi+20], eax

; 2130 :   num_available_buffers += new_buffers;

	lea	eax, DWORD PTR [ebx*4]
	add	DWORD PTR [esi+8], eax

; 2131 :   ref_available_buffers += new_buffers;

	add	DWORD PTR [esi+12], eax
	pop	edi
	pop	ebx
$LN1@augment_lo:
	pop	esi

; 2132 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN26@augment_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN28@augment_lo:
$LN25@augment_lo:
	int	3
?augment_local_store@kd_thread_buf_server@@QAEX_N@Z ENDP ; kd_thread_buf_server::augment_local_store
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?adjust_peak_buffers@kd_thread_buf_server@@QAEXXZ
_TEXT	SEGMENT
?adjust_peak_buffers@kd_thread_buf_server@@QAEXXZ PROC	; kd_thread_buf_server::adjust_peak_buffers, COMDAT
; _this$ = ecx

; 2092 :   int num_allocated = ref_available_buffers - num_available_buffers;
; 2093 :   int potential_new_peak = num_allocated * KD_THREAD_PEAK_STORE_FAC;

	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+8]
	sub	eax, edx
	shl	eax, 2

; 2096 :   ref_available_buffers = num_available_buffers;

	mov	DWORD PTR [ecx+12], edx
	cmp	eax, DWORD PTR [ecx+4]
	jle	SHORT $LN2@adjust_pea

; 2094 :   if (potential_new_peak > peak_buffers)
; 2095 :     peak_buffers = potential_new_peak;

	mov	DWORD PTR [ecx+4], eax
$LN2@adjust_pea:

; 2097 : }

	ret	0
?adjust_peak_buffers@kd_thread_buf_server@@QAEXXZ ENDP	; kd_thread_buf_server::adjust_peak_buffers
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?detach_while_holding_general_lock@kd_thread_buf_server@@QAEXXZ
_TEXT	SEGMENT
?detach_while_holding_general_lock@kd_thread_buf_server@@QAEXXZ PROC ; kd_thread_buf_server::detach_while_holding_general_lock, COMDAT
; _this$ = ecx

; 358  :            relock the `KD_THREADLOCK_GENERAL' mutex. */
; 359  :         if (ultimate_buf_server != NULL)

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	je	SHORT $LN2@detach_whi

; 360  :           ultimate_buf_server->detach_thread_buf_server(this);

	push	ecx
	mov	ecx, eax
	call	?detach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z ; kd_buf_server::detach_thread_buf_server
$LN2@detach_whi:

; 361  :       }

	ret	0
?detach_while_holding_general_lock@kd_thread_buf_server@@QAEXXZ ENDP ; kd_thread_buf_server::detach_while_holding_general_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?is_attached@kd_thread_buf_server@@QAE_NXZ
_TEXT	SEGMENT
?is_attached@kd_thread_buf_server@@QAE_NXZ PROC		; kd_thread_buf_server::is_attached, COMDAT
; _this$ = ecx

; 353  :     bool is_attached() { return (ultimate_buf_server != NULL); }

	xor	eax, eax
	cmp	DWORD PTR [ecx+24], eax
	setne	al
	ret	0
?is_attached@kd_thread_buf_server@@QAE_NXZ ENDP		; kd_thread_buf_server::is_attached
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?set_codestream_buf_server@kd_thread_buf_server@@QAEXPAVkd_buf_server@@@Z
_TEXT	SEGMENT
_lock$1$ = 8						; size = 4
$T1 = 8							; size = 4
_buf_server$ = 8					; size = 4
?set_codestream_buf_server@kd_thread_buf_server@@QAEXPAVkd_buf_server@@@Z PROC ; kd_thread_buf_server::set_codestream_buf_server, COMDAT
; _this$ = ecx

; 4645 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 4646 :   if (buf_server != this->ultimate_buf_server)

	mov	edi, DWORD PTR _buf_server$[ebp]
	cmp	edi, DWORD PTR [esi+24]
	je	SHORT $LN18@set_codest

; 4647 :     {
; 4648 :       env->owner->acquire_lock(KD_THREADLOCK_GENERAL);

	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR [eax+128]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [ebx+28]
	mov	DWORD PTR _lock$1$[ebp], ecx
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN22@set_codest
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN11@set_codest
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	ecx, DWORD PTR _lock$1$[ebp]
$LN11@set_codest:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [ecx+4], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4649 :       if (ultimate_buf_server != NULL)

	mov	ecx, DWORD PTR [esi+24]
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN3@set_codest

; 4650 :         ultimate_buf_server->detach_thread_buf_server(this);

	push	esi
	call	?detach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z ; kd_buf_server::detach_thread_buf_server
$LN3@set_codest:

; 4651 :       if (buf_server != NULL)

	test	edi, edi
	je	SHORT $LN4@set_codest

; 4652 :         buf_server->attach_thread_buf_server(this);

	push	esi
	mov	ecx, edi
	call	?attach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z ; kd_buf_server::attach_thread_buf_server
$LN4@set_codest:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+128]
	mov	eax, DWORD PTR [eax+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN18@set_codest
	pop	edi
	pop	esi
	mov	DWORD PTR _buf_server$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4656 : }

	pop	ebp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	jmp	DWORD PTR __imp__ReleaseMutex@4
$LN18@set_codest:
	pop	edi
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4656 : }

	pop	ebp
	ret	4
$LN22@set_codest:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN24@set_codest:
$LN21@set_codest:
	int	3
?set_codestream_buf_server@kd_thread_buf_server@@QAEXPAVkd_buf_server@@@Z ENDP ; kd_thread_buf_server::set_codestream_buf_server
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?init@kd_thread_buf_server@@QAEXPAVkd_thread_env@@@Z
_TEXT	SEGMENT
_env$ = 8						; size = 4
?init@kd_thread_buf_server@@QAEXPAVkd_thread_env@@@Z PROC ; kd_thread_buf_server::init, COMDAT
; _this$ = ecx

; 340  :     void init(kd_thread_env *env) { this->env=env; reset(); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _env$[ebp]
	mov	DWORD PTR [ecx], eax

; 341  :     void set_codestream_buf_server(kd_buf_server *buf_server);
; 342  :       /* This function is used to nominate a particular codestream's
; 343  :          `kd_buf_server' object as the ultimate source of all future
; 344  :          buffers served by the present object.  If we are already
; 345  :          attached to a different codestream `buf_server', we must
; 346  :          first detach, releasing any buffers in our local store to
; 347  :          the codestream `buf_server' from which they came.  These
; 348  :          operations are all guarded by the KD_THREADLOCK_GENERAL mutex,
; 349  :          but the present function is always invoked from a context in
; 350  :          which the mutex is not locked.  If `buf_server' is NULL, the
; 351  :          function simply detaches us from any codestream `buf_server'
; 352  :          to which we might presently be attached. */
; 353  :     bool is_attached() { return (ultimate_buf_server != NULL); }
; 354  :       /* Returns true if the last call to `set_codestream_buf_server'
; 355  :          specified a non-NULL codestream `buf_server'. */
; 356  :     void detach_while_holding_general_lock()
; 357  :       { /* Called by `discard_all', so we don't have to unlock and then
; 358  :            relock the `KD_THREADLOCK_GENERAL' mutex. */
; 359  :         if (ultimate_buf_server != NULL)
; 360  :           ultimate_buf_server->detach_thread_buf_server(this);
; 361  :       }
; 362  :     kd_code_buffer *get()
; 363  :       { /* Behaves like `kd_buf_server::get', but allocates initially
; 364  :            from the thread's local buffer store, getting extra data from the
; 365  :            codestream specified in the most recent call to
; 366  :            `set_codestream_buf_server' where required.  This function must
; 367  :            not be called while holding any lock, since it may need to
; 368  :            temporarily instantiate a lock to get extra storage from the
; 369  :            underlying codestream. */
; 370  :         if (head == NULL) augment_local_store(false);
; 371  :         kd_code_buffer *result = head;
; 372  :         if ((head = result->next) == NULL)
; 373  :           tail = NULL;
; 374  :         result->next = NULL;
; 375  :         num_available_buffers--;
; 376  :         return result;
; 377  :       }
; 378  :     void adjust_peak_buffers();
; 379  :       /* This function is called from within `kd_thread_env::flush' to
; 380  :          adjust the value of `peak_buffers', which records the maximum
; 381  :          number of buffers we would like to make available locally
; 382  :          in this thread buffer server.  The calculation uses the fact that
; 383  :          `ref_available_buffers'-`num_available_buffers' equals the number
; 384  :          of buffers which have been obtained via `get', since the last call
; 385  :          to this function.  This quantity is multiplied by a factor
; 386  :          `KD_THREAD_PEAK_STORE_FAC' to obtain a reasonable value for
; 387  :          `peak_buffer', the value of which is adjusted only ever upwards. */
; 388  :     void augment_local_store(bool general_lock_held);
; 389  :       /* This function is used to allocate new buffers from the underlying
; 390  :          codestream, specified in the last call to `set_codestream'.
; 391  :          If `adjust_peak_buffers' has never been called, the
; 392  :          function allocates `KD_THREAD_PEAK_STORE_FAC' times the number of
; 393  :          buffers which have already been served via `get'.  Otherwise, it
; 394  :          allocates exactly `peak_buffers' new buffers.
; 395  :             If `general_lock_held' is false, the `KD_THREADLOCK_GENERAL'
; 396  :          lock is not currently held and must be acquired prior to actually
; 397  :          allocating any new buffers (and released again before returning,
; 398  :          of course).  The function is called in this way only when a call
; 399  :          to `get' finds that the local store of buffers has been
; 400  :          completely exhausted.
; 401  :             The function is called with `general_lock_held' equal to true
; 402  :          from within `kd_thread_env::flush' to take advantage of the fact
; 403  :          that the general lock is already held for other reasons -- i.e.,
; 404  :          to piggy-back the activity of refilling the local buffer store
; 405  :          onto other activities which required the lock. */
; 406  :   private: // Helper functions
; 407  :     friend class kd_buf_server;
; 408  :     void reset()
; 409  :       { // Called by `kd_buf_server::detach_thread_buf_server' after removing
; 410  :         // us from its attached thread buffer list.  This function is also
; 411  :         // used to do most of the work of our own constructor.
; 412  :         ultimate_buf_server = NULL;

	mov	DWORD PTR [ecx+24], 0

; 413  :         next_attached = prev_attached = NULL;

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+28], 0

; 414  :         ref_available_buffers = 0;

	mov	DWORD PTR [ecx+12], 0

; 415  :         peak_buffers = 0;

	mov	DWORD PTR [ecx+4], 0

; 416  :         num_available_buffers = 0;

	mov	DWORD PTR [ecx+8], 0

; 417  :         head = tail = NULL;

	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+16], 0

; 340  :     void init(kd_thread_env *env) { this->env=env; reset(); }

	pop	ebp
	ret	4
?init@kd_thread_buf_server@@QAEXPAVkd_thread_env@@@Z ENDP ; kd_thread_buf_server::init
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_buf_server@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_buf_server@@QAEPAXI@Z PROC			; kd_buf_server::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_buf_server@@QAE@XZ		; kd_buf_server::~kd_buf_server
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	64					; 00000040H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_buf_server@@QAEPAXI@Z ENDP			; kd_buf_server::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?alloc_pages@kd_buf_server@@AAEXXZ
_TEXT	SEGMENT
?alloc_pages@kd_buf_server@@AAEXXZ PROC			; kd_buf_server::alloc_pages, COMDAT
; _this$ = ecx

; 1884 : {

	push	esi
	push	edi

; 1885 :   int page_size = sizeof(kd_code_buffer)*KDU_CODE_BUFFERS_PER_PAGE;
; 1886 :   assert(page_size == (KDU_CODE_BUFFER_ALIGN*KDU_CODE_BUFFERS_PER_PAGE));
; 1887 :   assert((page_size & (page_size-1)) == 0); // Must be power of 2!
; 1888 :   kd_code_alloc *new_alloc = (kd_code_alloc *)
; 1889 :     malloc(sizeof(kd_code_alloc *) + (size_t)(65*page_size));

	push	16644					; 00004104H
	mov	esi, ecx
	call	DWORD PTR __imp__malloc

; 1890 :   new_alloc->next = alloc;

	mov	edx, DWORD PTR [esi]

; 1891 :   alloc = new_alloc;
; 1892 :   kdu_byte *block = new_alloc->block;
; 1893 :   int block_length = page_size*65;
; 1894 :   int page_offset = (- _addr_to_kdu_int32(block)) & (page_size-1);
; 1895 :   block += page_offset;
; 1896 :   block_length -= page_offset;

	mov	edi, 16640				; 00004100H
	add	esp, 4
	mov	DWORD PTR [eax], edx
	lea	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi], eax
	mov	eax, edx
	neg	eax
	movzx	eax, al
	sub	edi, eax
	add	edx, eax

; 1897 :   kd_code_buffer *page = (kd_code_buffer *) block;
; 1898 :   for (; block_length >= page_size; block_length-=page_size,

	cmp	edi, 256				; 00000100H
	jl	SHORT $LN3@alloc_page

; 1885 :   int page_size = sizeof(kd_code_buffer)*KDU_CODE_BUFFERS_PER_PAGE;
; 1886 :   assert(page_size == (KDU_CODE_BUFFER_ALIGN*KDU_CODE_BUFFERS_PER_PAGE));
; 1887 :   assert((page_size & (page_size-1)) == 0); // Must be power of 2!
; 1888 :   kd_code_alloc *new_alloc = (kd_code_alloc *)
; 1889 :     malloc(sizeof(kd_code_alloc *) + (size_t)(65*page_size));

	shr	edi, 8
$LL4@alloc_page:

; 1899 :        page+=KDU_CODE_BUFFERS_PER_PAGE)
; 1900 :     {
; 1901 :       int n;
; 1902 :       for (n=0; n < KDU_CODE_BUFFERS_PER_PAGE; n++)

	xor	ecx, ecx
	mov	eax, edx
	npad	6
$LL7@alloc_page:

; 1903 :         {
; 1904 :           assert(n < 64);
; 1905 :           page[n].next = NULL;
; 1906 :           page[n].state = (kdu_int16) n;

	mov	WORD PTR [eax+4], cx
	inc	ecx
	mov	DWORD PTR [eax], 0
	add	eax, 64					; 00000040H
	cmp	ecx, 4
	jl	SHORT $LL7@alloc_page

; 1907 :         }
; 1908 :       page->next = free_head;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edx], ecx

; 1909 :       free_head = page;
; 1910 :       total_pages++;

	add	DWORD PTR [esi+8], 1
	mov	DWORD PTR [esi+4], edx
	mov	edx, eax
	adc	DWORD PTR [esi+12], 0
	sub	edi, 1
	jne	SHORT $LL4@alloc_page
$LN3@alloc_page:
	pop	edi
	pop	esi

; 1911 :     }
; 1912 : }

	ret	0
?alloc_pages@kd_buf_server@@AAEXXZ ENDP			; kd_buf_server::alloc_pages
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?detach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z
_TEXT	SEGMENT
_tbs$ = 8						; size = 4
?detach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z PROC ; kd_buf_server::detach_thread_buf_server, COMDAT
; _this$ = ecx

; 2038 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 2039 :   if (tbs->ultimate_buf_server == NULL)

	mov	esi, DWORD PTR _tbs$[ebp]
	push	edi
	mov	edi, ecx
	cmp	DWORD PTR [esi+24], 0
	je	$LN1@detach_thr

; 2040 :     {
; 2041 :       assert(tbs->head == NULL);
; 2042 :       return;
; 2043 :     }
; 2044 :   while ((tbs->tail = tbs->head) != NULL)

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+20], eax
	test	eax, eax
	je	SHORT $LN3@detach_thr
	npad	2
$LL2@detach_thr:

; 2045 :     {
; 2046 :       tbs->head = tbs->tail->next;

	mov	eax, DWORD PTR [esi+20]

; 2047 :       release(tbs->tail);

	mov	ecx, edi
	push	DWORD PTR [esi+20]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+16], eax
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release

; 2048 :       tbs->num_available_buffers--;

	dec	DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+20], eax
	test	eax, eax
	jne	SHORT $LL2@detach_thr
$LN3@detach_thr:

; 2049 :     }
; 2050 :   if (tbs->prev_attached == NULL)

	mov	ecx, DWORD PTR [esi+32]

; 2051 :     {
; 2052 :       assert(tbs == attached_thread_buf_servers);
; 2053 :       attached_thread_buf_servers = tbs->next_attached;

	mov	eax, DWORD PTR [esi+28]
	test	ecx, ecx
	jne	SHORT $LN5@detach_thr
	mov	DWORD PTR [edi+60], eax

; 2054 :     }
; 2055 :   else

	jmp	SHORT $LN6@detach_thr
$LN5@detach_thr:

; 2056 :     {
; 2057 :       assert(tbs->prev_attached->next_attached == tbs);
; 2058 :       tbs->prev_attached->next_attached = tbs->next_attached;

	mov	DWORD PTR [ecx+28], eax
$LN6@detach_thr:

; 2059 :     }
; 2060 :   if (tbs->next_attached != NULL)

	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
	je	SHORT $LN7@detach_thr

; 2061 :     tbs->next_attached->prev_attached = tbs->prev_attached;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [ecx+32], eax
$LN7@detach_thr:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 412  :         ultimate_buf_server = NULL;

	mov	DWORD PTR [esi+24], 0

; 413  :         next_attached = prev_attached = NULL;

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+28], 0

; 414  :         ref_available_buffers = 0;

	mov	DWORD PTR [esi+12], 0

; 415  :         peak_buffers = 0;

	mov	DWORD PTR [esi+4], 0

; 416  :         num_available_buffers = 0;

	mov	DWORD PTR [esi+8], 0

; 417  :         head = tail = NULL;

	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+16], 0
$LN1@detach_thr:
	pop	edi
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2063 : }

	pop	ebp
	ret	4
?detach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z ENDP ; kd_buf_server::detach_thread_buf_server
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?attach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z
_TEXT	SEGMENT
_tbs$ = 8						; size = 4
?attach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z PROC ; kd_buf_server::attach_thread_buf_server, COMDAT
; _this$ = ecx

; 2071 : {

	push	ebp
	mov	ebp, esp

; 2072 :   assert(tbs->ultimate_buf_server == NULL);
; 2073 :   tbs->ultimate_buf_server = this;

	mov	eax, DWORD PTR _tbs$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2074 :   if ((tbs->next_attached = attached_thread_buf_servers) != NULL)

	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+28], edx
	test	edx, edx
	je	SHORT $LN4@attach_thr

; 2075 :     tbs->next_attached->prev_attached = tbs;

	mov	DWORD PTR [edx+32], eax
$LN4@attach_thr:

; 2076 :   attached_thread_buf_servers = tbs;

	mov	DWORD PTR [ecx+60], eax

; 2077 :   tbs->prev_attached = NULL;

	mov	DWORD PTR [eax+32], 0

; 2078 : }

	pop	ebp
	ret	4
?attach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z ENDP ; kd_buf_server::attach_thread_buf_server
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?cache_threshold_exceeded@kd_buf_server@@QAE_NXZ
_TEXT	SEGMENT
?cache_threshold_exceeded@kd_buf_server@@QAE_NXZ PROC	; kd_buf_server::cache_threshold_exceeded, COMDAT
; _this$ = ecx

; 289  :       { return (cache_threshold_bytes <

	push	esi
	mov	esi, ecx
	push	0
	push	232					; 000000e8H
	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+16]
	call	__allmul
	add	eax, DWORD PTR [esi+32]
	adc	edx, DWORD PTR [esi+36]
	cmp	DWORD PTR [esi+52], edx
	jg	SHORT $LN3@cache_thre
	jl	SHORT $LN5@cache_thre
	cmp	DWORD PTR [esi+48], eax
	jae	SHORT $LN3@cache_thre
$LN5@cache_thre:
	mov	al, 1
	pop	esi

; 290  :                 (structure_bytes + num_allocated_pages *
; 291  :                  (KD_CODE_BUFFER_LEN*KDU_CODE_BUFFERS_PER_PAGE))); }

	ret	0
$LN3@cache_thre:

; 289  :       { return (cache_threshold_bytes <

	xor	al, al
	pop	esi

; 290  :                 (structure_bytes + num_allocated_pages *
; 291  :                  (KD_CODE_BUFFER_LEN*KDU_CODE_BUFFERS_PER_PAGE))); }

	ret	0
?cache_threshold_exceeded@kd_buf_server@@QAE_NXZ ENDP	; kd_buf_server::cache_threshold_exceeded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?augment_cache_threshold@kd_buf_server@@QAE_J_J@Z
_TEXT	SEGMENT
_increment$ = 8						; size = 8
?augment_cache_threshold@kd_buf_server@@QAE_J_J@Z PROC	; kd_buf_server::augment_cache_threshold, COMDAT
; _this$ = ecx

; 285  :       { // Use to adjust the cache threshold either up or down

	push	ebp
	mov	ebp, esp

; 286  :         return (cache_threshold_bytes += increment);

	mov	eax, DWORD PTR _increment$[ebp]
	add	eax, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _increment$[ebp+4]
	adc	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [ecx+48], eax
	mov	DWORD PTR [ecx+52], edx

; 287  :       }

	pop	ebp
	ret	8
?augment_cache_threshold@kd_buf_server@@QAE_J_J@Z ENDP	; kd_buf_server::augment_cache_threshold
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_peak_structure_bytes@kd_buf_server@@QAE_JXZ
_TEXT	SEGMENT
?get_peak_structure_bytes@kd_buf_server@@QAE_JXZ PROC	; kd_buf_server::get_peak_structure_bytes, COMDAT
; _this$ = ecx

; 277  :       { return peak_structure_bytes; }

	mov	eax, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR [ecx+44]
	ret	0
?get_peak_structure_bytes@kd_buf_server@@QAE_JXZ ENDP	; kd_buf_server::get_peak_structure_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_current_structure_bytes@kd_buf_server@@QAE_JXZ
_TEXT	SEGMENT
?get_current_structure_bytes@kd_buf_server@@QAE_JXZ PROC ; kd_buf_server::get_current_structure_bytes, COMDAT
; _this$ = ecx

; 275  :       { return structure_bytes; }

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]
	ret	0
?get_current_structure_bytes@kd_buf_server@@QAE_JXZ ENDP ; kd_buf_server::get_current_structure_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_peak_buf_bytes@kd_buf_server@@QAE_JXZ
_TEXT	SEGMENT
?get_peak_buf_bytes@kd_buf_server@@QAE_JXZ PROC		; kd_buf_server::get_peak_buf_bytes, COMDAT
; _this$ = ecx

; 270  :            the server for bit-stream buffers  */
; 271  :         return (kdu_long)(peak_allocated_pages * KD_CODE_BUFFER_LEN *

	push	0
	push	232					; 000000e8H
	push	DWORD PTR [ecx+28]
	push	DWORD PTR [ecx+24]
	call	__allmul

; 272  :                           KDU_CODE_BUFFERS_PER_PAGE);
; 273  :       }

	ret	0
?get_peak_buf_bytes@kd_buf_server@@QAE_JXZ ENDP		; kd_buf_server::get_peak_buf_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_current_buf_bytes@kd_buf_server@@QAE_JXZ
_TEXT	SEGMENT
?get_current_buf_bytes@kd_buf_server@@QAE_JXZ PROC	; kd_buf_server::get_current_buf_bytes, COMDAT
; _this$ = ecx

; 264  :            bit-stream buffers. */
; 265  :         return (kdu_long)(num_allocated_pages * KD_CODE_BUFFER_LEN *

	push	0
	push	232					; 000000e8H
	push	DWORD PTR [ecx+20]
	push	DWORD PTR [ecx+16]
	call	__allmul

; 266  :                           KDU_CODE_BUFFERS_PER_PAGE);
; 267  :       }

	ret	0
?get_current_buf_bytes@kd_buf_server@@QAE_JXZ ENDP	; kd_buf_server::get_current_buf_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_page_block@kd_buf_server@@QAEPAUkd_code_buffer@@HAAPAU2@@Z
_TEXT	SEGMENT
_next$1$ = -8						; size = 4
_prev$1$ = -4						; size = 4
_num_pages_needed$ = 8					; size = 4
_scan$1$ = 12						; size = 4
_result_tail$ = 12					; size = 4
?get_page_block@kd_buf_server@@QAEPAUkd_code_buffer@@HAAPAU2@@Z PROC ; kd_buf_server::get_page_block, COMDAT
; _this$ = ecx

; 1986 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi

; 1987 :   kd_code_buffer *scan, *prev, *next, *result_head;
; 1988 :   result_head = result_tail = NULL;

	mov	esi, DWORD PTR _result_tail$[ebp]
	xor	ebx, ebx
	push	edi
	mov	edi, ecx

; 1989 :   for (prev=NULL, scan=free_head; num_pages_needed > 0; prev=scan, scan=next)

	xor	ecx, ecx
	mov	DWORD PTR _prev$1$[ebp], ecx
	mov	DWORD PTR [esi], 0
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _scan$1$[ebp], eax
	cmp	DWORD PTR _num_pages_needed$[ebp], ecx
	jle	$LN3@get_page_b
	npad	6
$LL4@get_page_b:

; 1990 :     {
; 1991 :       if (scan == NULL)

	test	eax, eax
	jne	SHORT $LN11@get_page_b

; 1992 :         { // Need to allocate some more pages
; 1993 :           alloc_pages();

	mov	ecx, edi
	call	?alloc_pages@kd_buf_server@@AAEXXZ	; kd_buf_server::alloc_pages

; 1994 :           scan = free_head; // Start again from beginning of new buffers

	mov	eax, DWORD PTR [edi+4]

; 1995 :           prev = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _scan$1$[ebp], eax
	mov	DWORD PTR _prev$1$[ebp], ecx
$LN11@get_page_b:

; 1996 :         }
; 1997 : 
; 1998 :       next = scan->next;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _next$1$[ebp], ecx

; 1999 :       int n, pos = scan->state & 0x7F;
; 2000 :       kd_code_buffer *page = scan - pos;

	movsx	ecx, WORD PTR [eax+4]
	and	ecx, 127				; 0000007fH
	shl	ecx, 6
	sub	eax, ecx

; 2001 :       for (n=0; n < KDU_CODE_BUFFERS_PER_PAGE; n++)

	xor	edx, edx
	lea	ecx, DWORD PTR [eax+4]
	npad	4
$LL7@get_page_b:

; 2002 :         if (page[n].state < 0)

	cmp	WORD PTR [ecx], 0
	jl	$LN2@get_page_b

; 2001 :       for (n=0; n < KDU_CODE_BUFFERS_PER_PAGE; n++)

	inc	edx
	add	ecx, 64					; 00000040H
	cmp	edx, 4
	jl	SHORT $LL7@get_page_b

; 2003 :           {
; 2004 :             page = NULL; // This page is not complete
; 2005 :             break;
; 2006 :           }
; 2007 :       if (page != NULL)

	test	eax, eax
	je	$LN2@get_page_b

; 2008 :         { // Found a complete page; unlink and use it.
; 2009 :           if (prev == NULL)

	mov	ecx, DWORD PTR _prev$1$[ebp]

; 2010 :             free_head = next;

	mov	edx, DWORD PTR _next$1$[ebp]
	test	ecx, ecx
	jne	SHORT $LN14@get_page_b
	mov	DWORD PTR [edi+4], edx

; 2011 :           else

	jmp	SHORT $LN15@get_page_b
$LN14@get_page_b:

; 2012 :             prev->next = next;

	mov	DWORD PTR [ecx], edx
$LN15@get_page_b:

; 2013 :           scan = prev; // Ensures that `prev' is the same on the next iteration
; 2014 :           num_allocated_pages++;

	add	DWORD PTR [edi+16], 1

; 2015 :           num_pages_needed--;
; 2016 :           for (n=0; n < KDU_CODE_BUFFERS_PER_PAGE; n++)
; 2017 :             {
; 2018 :               page[n].state |= 0x8000;

	mov	edx, -32768				; ffff8000H
	mov	DWORD PTR _scan$1$[ebp], ecx
	adc	DWORD PTR [edi+20], 0
	or	WORD PTR [eax+4], dx
	dec	DWORD PTR _num_pages_needed$[ebp]

; 2019 :               if (result_tail == NULL)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	jne	SHORT $LN16@get_page_b

; 2020 :                 result_head = result_tail = page + n;

	mov	ebx, eax

; 2021 :               else

	jmp	SHORT $LN48@get_page_b
$LN16@get_page_b:

; 2022 :                 result_tail = result_tail->next = page + n;

	mov	DWORD PTR [ecx], eax
$LN48@get_page_b:
	mov	DWORD PTR [esi], eax
	or	WORD PTR [eax+68], dx
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN35@get_page_b

; 2020 :                 result_head = result_tail = page + n;

	lea	ebx, DWORD PTR [eax+64]
	mov	DWORD PTR [esi], ebx

; 2021 :               else

	jmp	SHORT $LN36@get_page_b
$LN35@get_page_b:

; 2022 :                 result_tail = result_tail->next = page + n;

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [eax+64]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [esi], edx
	mov	edx, -32768				; ffff8000H
$LN36@get_page_b:

; 2019 :               if (result_tail == NULL)

	or	WORD PTR [eax+132], dx
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN38@get_page_b

; 2020 :                 result_head = result_tail = page + n;

	lea	ebx, DWORD PTR [eax+128]
	mov	DWORD PTR [esi], ebx

; 2021 :               else

	jmp	SHORT $LN39@get_page_b
$LN38@get_page_b:

; 2022 :                 result_tail = result_tail->next = page + n;

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [eax+128]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [esi], edx
	mov	edx, -32768				; ffff8000H
$LN39@get_page_b:

; 2020 :                 result_head = result_tail = page + n;

	or	WORD PTR [eax+196], dx
	lea	ecx, DWORD PTR [eax+192]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN41@get_page_b
	mov	ebx, ecx

; 2021 :               else

	jmp	SHORT $LN49@get_page_b
$LN41@get_page_b:

; 2022 :                 result_tail = result_tail->next = page + n;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
$LN49@get_page_b:
	mov	DWORD PTR [esi], ecx

; 2023 :             }
; 2024 :           result_tail->next = NULL;

	mov	DWORD PTR [ecx], 0
$LN2@get_page_b:

; 1989 :   for (prev=NULL, scan=free_head; num_pages_needed > 0; prev=scan, scan=next)

	cmp	DWORD PTR _num_pages_needed$[ebp], 0
	mov	ecx, DWORD PTR _scan$1$[ebp]
	mov	eax, DWORD PTR _next$1$[ebp]
	mov	DWORD PTR _prev$1$[ebp], ecx
	mov	DWORD PTR _scan$1$[ebp], eax
	jg	$LL4@get_page_b
$LN3@get_page_b:

; 2025 :         }
; 2026 :     }
; 2027 :   if (num_allocated_pages > peak_allocated_pages)

	mov	ecx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [edi+16]
	cmp	ecx, DWORD PTR [edi+28]
	jl	SHORT $LN47@get_page_b
	jg	SHORT $LN45@get_page_b
	cmp	eax, DWORD PTR [edi+24]
	jbe	SHORT $LN47@get_page_b
$LN45@get_page_b:

; 2028 :     peak_allocated_pages = num_allocated_pages;

	mov	DWORD PTR [edi+24], eax
	mov	DWORD PTR [edi+28], ecx
$LN47@get_page_b:

; 2029 :   return result_head;

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 2030 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?get_page_block@kd_buf_server@@QAEPAUkd_code_buffer@@HAAPAU2@@Z ENDP ; kd_buf_server::get_page_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z PROC	; kd_buf_server::release, COMDAT
; _this$ = ecx

; 1961 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 1962 :   int n, pos = buf->state & 0x3F;

	mov	edi, DWORD PTR _buf$[ebp]
	mov	ebx, ecx

; 1963 :   kd_code_buffer *page = buf - pos;

	mov	edx, edi
	movzx	esi, WORD PTR [edi+4]
	mov	eax, esi
	and	eax, 63					; 0000003fH
	shl	eax, 6
	sub	edx, eax

; 1964 :   for (n=0; n < KDU_CODE_BUFFERS_PER_PAGE; n++)

	xor	ecx, ecx
	lea	eax, DWORD PTR [edx+4]
$LL4@release:

; 1965 :     if (page[n].state >= 0)

	cmp	WORD PTR [eax], 0
	jge	SHORT $LN8@release

; 1964 :   for (n=0; n < KDU_CODE_BUFFERS_PER_PAGE; n++)

	inc	ecx
	add	eax, 64					; 00000040H
	cmp	ecx, 4
	jl	SHORT $LL4@release

; 1970 :         return;
; 1971 :       }
; 1972 :   assert(num_allocated_pages > 0);
; 1973 :   buf->next = free_head;

	mov	eax, DWORD PTR [ebx+4]

; 1974 :   buf->state &= 0x7F;

	and	esi, 127				; 0000007fH
	mov	WORD PTR [edi+4], si
	mov	DWORD PTR [edi], eax

; 1975 :   free_head = buf;
; 1976 :   num_allocated_pages--;

	add	DWORD PTR [ebx+16], -1
	mov	DWORD PTR [ebx+4], edi
	adc	DWORD PTR [ebx+20], -1
	pop	edi
	pop	esi
	pop	ebx

; 1977 : }

	pop	ebp
	ret	4
$LN8@release:

; 1966 :       { // At least one buffer in the page is already on the free list
; 1967 :         assert(n != pos);
; 1968 :         buf->next = NULL;
; 1969 :         buf->state &= 0x7F;

	and	esi, 127				; 0000007fH
	mov	DWORD PTR [edi], 0
	mov	WORD PTR [edi+4], si
	pop	edi
	pop	esi
	pop	ebx

; 1977 : }

	pop	ebp
	ret	4
?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ENDP	; kd_buf_server::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ
_TEXT	SEGMENT
tv259 = -4						; size = 4
?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ PROC	; kd_buf_server::get, COMDAT
; _this$ = ecx

; 1920 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 1921 :   if (free_head == NULL)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN8@get

; 1922 :     {
; 1923 :       assert(num_allocated_pages == total_pages);
; 1924 :       alloc_pages();

	call	?alloc_pages@kd_buf_server@@AAEXXZ	; kd_buf_server::alloc_pages
$LN8@get:

; 1925 :     }
; 1926 : 
; 1927 :   kd_code_buffer *result = free_head;

	mov	edi, DWORD PTR [esi+4]

; 1928 :   int n, pos = result->state & 0x3F;
; 1929 :   kd_code_buffer *page = result - pos;

	mov	ebx, edi
	movzx	ecx, WORD PTR [edi+4]
	mov	edx, ecx
	mov	DWORD PTR tv259[ebp], ecx
	and	edx, 63					; 0000003fH
	mov	eax, edx
	shl	eax, 6
	sub	ebx, eax

; 1930 :   for (n=0; n < pos; n++)

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN3@get

; 1925 :     }
; 1926 : 
; 1927 :   kd_code_buffer *result = free_head;

	lea	ecx, DWORD PTR [ebx+4]
$LL4@get:

; 1931 :     if (page[n].state >= 0)

	cmp	WORD PTR [ecx], 0
	jge	SHORT $LN15@get

; 1930 :   for (n=0; n < pos; n++)

	inc	eax
	add	ecx, 64					; 00000040H
	cmp	eax, edx
	jl	SHORT $LL4@get

; 1938 :     if (page[n].state >= 0)

	mov	ecx, DWORD PTR tv259[ebp]
$LN3@get:

; 1934 :         return page+n;
; 1935 :       }
; 1936 :   result->state |= 0x8000;

	or	ecx, -32768				; ffff8000H

; 1937 :   for (n=KDU_CODE_BUFFERS_PER_PAGE-1; n > pos; n--)

	mov	eax, 3
	mov	WORD PTR [edi+4], cx
	cmp	edx, eax
	jge	SHORT $LN6@get

; 1934 :         return page+n;
; 1935 :       }
; 1936 :   result->state |= 0x8000;

	lea	ecx, DWORD PTR [ebx+196]
	npad	1
$LL7@get:

; 1938 :     if (page[n].state >= 0)

	cmp	WORD PTR [ecx], 0
	jge	SHORT $LN16@get

; 1937 :   for (n=KDU_CODE_BUFFERS_PER_PAGE-1; n > pos; n--)

	dec	eax
	sub	ecx, 64					; 00000040H
	cmp	eax, edx
	jg	SHORT $LL7@get
$LN6@get:

; 1941 :         page[n].next = result->next;  result->next = NULL;
; 1942 :         return result;
; 1943 :       }
; 1944 : 
; 1945 :   free_head = result->next;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax

; 1946 :   result->next = NULL;

	mov	DWORD PTR [edi], 0

; 1947 : 
; 1948 :   num_allocated_pages++;

	add	DWORD PTR [esi+16], 1

; 1949 :   if (num_allocated_pages > peak_allocated_pages)

	mov	ecx, DWORD PTR [esi+28]
	adc	DWORD PTR [esi+20], 0
	mov	eax, DWORD PTR [esi+24]
	cmp	DWORD PTR [esi+20], ecx
	jl	SHORT $LN11@get
	jg	SHORT $LN23@get
	cmp	DWORD PTR [esi+16], eax
	jbe	SHORT $LN11@get
$LN23@get:

; 1950 :     peak_allocated_pages++;

	add	eax, 1
	mov	DWORD PTR [esi+24], eax
	adc	ecx, 0
	mov	DWORD PTR [esi+28], ecx
$LN11@get:

; 1951 : 
; 1952 :   return result;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1953 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@get:

; 1932 :       { // Previous buffer in page is free; allocate this directly
; 1933 :         page[n].state |= 0x8000;

	shl	eax, 6
	mov	ecx, -32768				; ffff8000H
	add	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	or	WORD PTR [eax+4], cx

; 1953 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@get:

; 1939 :       { // Make this the new head of the free list
; 1940 :         free_head = page + n;

	shl	eax, 6
	lea	edx, DWORD PTR [eax+ebx]

; 1951 : 
; 1952 :   return result;

	mov	eax, edi
	mov	DWORD PTR [esi+4], edx
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi
	pop	ebx

; 1953 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ENDP	; kd_buf_server::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?detach@kd_buf_server@@QAEXXZ
_TEXT	SEGMENT
?detach@kd_buf_server@@QAEXXZ PROC			; kd_buf_server::detach, COMDAT
; _this$ = ecx

; 243  :       { assert(num_users > 0); num_users--; }

	dec	DWORD PTR [ecx+56]
	ret	0
?detach@kd_buf_server@@QAEXXZ ENDP			; kd_buf_server::detach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?attach@kd_buf_server@@QAEXXZ
_TEXT	SEGMENT
?attach@kd_buf_server@@QAEXXZ PROC			; kd_buf_server::attach, COMDAT
; _this$ = ecx

; 241  :       { num_users++; }

	inc	DWORD PTR [ecx+56]
	ret	0
?attach@kd_buf_server@@QAEXXZ ENDP			; kd_buf_server::attach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?can_destroy@kd_buf_server@@QAE_NXZ
_TEXT	SEGMENT
?can_destroy@kd_buf_server@@QAE_NXZ PROC		; kd_buf_server::can_destroy, COMDAT
; _this$ = ecx

; 239  :       { return (num_users == 0); }

	xor	eax, eax
	cmp	DWORD PTR [ecx+56], eax
	sete	al
	ret	0
?can_destroy@kd_buf_server@@QAE_NXZ ENDP		; kd_buf_server::can_destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ??1kd_buf_server@@QAE@XZ
_TEXT	SEGMENT
_w$2 = -56						; size = 20
_w$3 = -36						; size = 20
_e$4 = -36						; size = 20
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1kd_buf_server@@QAE@XZ PROC				; kd_buf_server::~kd_buf_server, COMDAT
; _this$ = ecx

; 1826 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_buf_server@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1827 :   kd_thread_buf_server *attached = attached_thread_buf_servers;

	mov	eax, DWORD PTR [esi+60]

; 1828 :   if (attached != NULL)

	test	eax, eax
	je	$LN27@kd_buf_ser

; 1830 :       kdu_thread_env *env = attached->env->owner->get_current_thread_env();

	mov	eax, DWORD PTR [eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 6552 :       { return (kdu_thread_env *) get_current_thread_entity(); }

	mov	ecx, DWORD PTR [eax+128]
	call	?get_current_thread_entity@kdu_thread_entity@@QAEPAV1@XZ ; kdu_thread_entity::get_current_thread_entity
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1830 :       kdu_thread_env *env = attached->env->owner->get_current_thread_env();

	mov	edi, eax

; 1831 :           // Retrieve our own `kdu_thread_env' via that of the first thread
; 1832 :           // whose `thread_buf_server' is attached to us.  It is OK if that
; 1833 :           // thread detaches from us while we are doing this, so that
; 1834 :           // `attached' may cease to reside on our list, so long as the thread
; 1835 :           // itself is not destroyed while we are gaining access to our
; 1836 :           // `env' reference.
; 1837 :       if (env == NULL)

	test	edi, edi
	jne	SHORT $LN7@kd_buf_ser

; 1838 :         { KDU_ERROR_DEV(e,0x12070700); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	edx, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0CFK@EADCMAPD@You?5have?5invoked?5?$GAkdu_codestream@
	call	DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1849 :             "cooperating multi-threaded processing systems."); }

	lea	ecx, DWORD PTR _e$4[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN7@kd_buf_ser:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [edi+20]
	mov	ebx, DWORD PTR [edi+28]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN16@kd_buf_ser
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T5[ebp], eax
	lea	eax, DWORD PTR $T5[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN43@kd_buf_ser:
$LN16@kd_buf_ser:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN20@kd_buf_ser
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN20@kd_buf_ser:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [ebx+4], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1851 :       while (attached_thread_buf_servers != NULL)

	cmp	DWORD PTR [esi+60], 0
	je	SHORT $LN3@kd_buf_ser
$LL2@kd_buf_ser:

; 1852 :         detach_thread_buf_server(attached_thread_buf_servers);

	push	DWORD PTR [esi+60]
	mov	ecx, esi
	call	?detach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z ; kd_buf_server::detach_thread_buf_server
	cmp	DWORD PTR [esi+60], 0
	jne	SHORT $LL2@kd_buf_ser
$LN3@kd_buf_ser:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [edi+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN27@kd_buf_ser
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN27@kd_buf_ser:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1857 :   if (num_allocated_pages != 0)

	mov	eax, DWORD PTR [esi+16]
	or	eax, DWORD PTR [esi+20]
	je	SHORT $LN8@kd_buf_ser

; 1858 :     { KDU_WARNING_DEV(w,6);  w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$3[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$3[ebp]
	lea	ecx, DWORD PTR _w$3[ebp]
	push	OFFSET ??_C@_0LL@CAMCHDPO@The?5compressed?5data?5buffer?5serve@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1862 :         "destruction code."); }

	lea	ecx, DWORD PTR _w$3[ebp]
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN8@kd_buf_ser:

; 1863 :   if (structure_bytes != 0)

	mov	eax, DWORD PTR [esi+32]
	or	eax, DWORD PTR [esi+36]
	je	SHORT $LN34@kd_buf_ser

; 1864 :     { KDU_WARNING_DEV(w,7);  w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$2[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$2[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	OFFSET ??_C@_0OO@EOPDAIEN@The?5compressed?5data?5buffer?5serve@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 1869 :     }

	lea	ecx, DWORD PTR _w$2[ebp]
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN34@kd_buf_ser:

; 1870 :   kd_code_alloc *tmp;
; 1871 :   while ((tmp=alloc) != NULL)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@kd_buf_ser
	mov	edi, DWORD PTR __imp__free
	npad	5
$LL4@kd_buf_ser:

; 1872 :     {
; 1873 :       alloc = tmp->next;

	mov	eax, DWORD PTR [ecx]

; 1874 :       free(tmp);

	push	ecx
	mov	DWORD PTR [esi], eax
	call	edi
	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	test	ecx, ecx
	jne	SHORT $LL4@kd_buf_ser
$LN5@kd_buf_ser:

; 1875 :     }
; 1876 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@kd_buf_ser:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kd_buf_server@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_buf_server@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_buf_server@@QAE@XZ ENDP				; kd_buf_server::~kd_buf_server
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_buf_server@@QAE@XZ
_TEXT	SEGMENT
??0kd_buf_server@@QAE@XZ PROC				; kd_buf_server::kd_buf_server, COMDAT
; _this$ = ecx

; 228  :       {
; 229  :         alloc = NULL; free_head = NULL;

	mov	DWORD PTR [ecx], 0

; 230  :         total_pages = num_allocated_pages = peak_allocated_pages = 0;
; 231  :         structure_bytes = peak_structure_bytes = 0;
; 232  :         cache_threshold_bytes = 0; num_users=0;
; 233  :         attached_thread_buf_servers = NULL;
; 234  :       }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 0
	ret	0
??0kd_buf_server@@QAE@XZ ENDP				; kd_buf_server::kd_buf_server
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?print_marker_code@@YAXGAAVkdu_message@@@Z
_TEXT	SEGMENT
_text$1 = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_code$ = 8						; size = 2
_out$ = 12						; size = 4
?print_marker_code@@YAXGAAVkdu_message@@@Z PROC		; print_marker_code, COMDAT

; 237  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 238  :   const char *name=NULL;
; 239  : 
; 240  :   if (code == KDU_SOC)

	mov	si, WORD PTR _code$[ebp]
	mov	eax, 65359				; 0000ff4fH
	push	edi
	mov	edi, DWORD PTR _out$[ebp]
	cmp	si, ax
	jne	SHORT $LN2@print_mark

; 241  :     name = "SOC";

	mov	esi, OFFSET ??_C@_03KHJBFGJE@SOC?$AA@
	jmp	$LN55@print_mark
$LN2@print_mark:

; 242  :   else if (code == KDU_SOT)

	mov	eax, 65424				; 0000ff90H
	cmp	si, ax
	jne	SHORT $LN4@print_mark

; 243  :     name = "SOT";

	mov	esi, OFFSET ??_C@_03KCBCNCAC@SOT?$AA@
	jmp	$LN55@print_mark
$LN4@print_mark:

; 244  :   else if (code == KDU_SOD)

	mov	eax, 65427				; 0000ff93H
	cmp	si, ax
	jne	SHORT $LN6@print_mark

; 245  :     name = "SOD";

	mov	esi, OFFSET ??_C@_03OINAMAFD@SOD?$AA@
	jmp	$LN55@print_mark
$LN6@print_mark:

; 246  :   else if (code == KDU_SOP)

	mov	eax, 65425				; 0000ff91H
	cmp	si, ax
	jne	SHORT $LN8@print_mark

; 247  :     name = "SOP";

	mov	esi, OFFSET ??_C@_03MGHOBHAG@SOP?$AA@
	jmp	$LN55@print_mark
$LN8@print_mark:

; 248  :   else if (code == KDU_EPH)

	mov	eax, 65426				; 0000ff92H
	cmp	si, ax
	jne	SHORT $LN10@print_mark

; 249  :     name = "EPH";

	mov	esi, OFFSET ??_C@_03CGGNGDFB@EPH?$AA@
	jmp	$LN55@print_mark
$LN10@print_mark:

; 250  :   else if (code == KDU_EOC)

	mov	eax, 65497				; 0000ffd9H
	cmp	si, ax
	jne	SHORT $LN12@print_mark

; 251  :     name = "EOC";

	mov	esi, OFFSET ??_C@_03NCODFONH@EOC?$AA@
	jmp	$LN55@print_mark
$LN12@print_mark:

; 252  :   else if (code == KDU_SIZ)

	mov	eax, 65361				; 0000ff51H
	cmp	si, ax
	jne	SHORT $LN14@print_mark

; 253  :     name = "SIZ";

	mov	esi, OFFSET ??_C@_03DIBMIDDO@SIZ?$AA@
	jmp	$LN55@print_mark
$LN14@print_mark:

; 254  :   else if (code == KDU_CBD)

	mov	eax, 65400				; 0000ff78H
	cmp	si, ax
	jne	SHORT $LN16@print_mark

; 255  :     name = "CBD";

	mov	esi, OFFSET ??_C@_03LABBAEJP@CBD?$AA@
	jmp	$LN55@print_mark
$LN16@print_mark:

; 256  :   else if (code == KDU_MCT)

	mov	eax, 65396				; 0000ff74H
	cmp	si, ax
	jne	SHORT $LN18@print_mark

; 257  :     name = "MCT";

	mov	esi, OFFSET ??_C@_03BLMOALMK@MCT?$AA@
	jmp	$LN55@print_mark
$LN18@print_mark:

; 258  :   else if (code == KDU_MCC)

	mov	eax, 65397				; 0000ff75H
	cmp	si, ax
	jne	SHORT $LN20@print_mark

; 259  :     name = "MCC";

	mov	esi, OFFSET ??_C@_03BOENIPFM@MCC?$AA@
	jmp	$LN55@print_mark
$LN20@print_mark:

; 260  :   else if (code == KDU_MCO)

	mov	eax, 65399				; 0000ff77H
	cmp	si, ax
	jne	SHORT $LN22@print_mark

; 261  :     name = "MCO";

	mov	esi, OFFSET ??_C@_03LCPIMAFA@MCO?$AA@
	jmp	$LN55@print_mark
$LN22@print_mark:

; 262  :   else if (code == KDU_COD)

	mov	eax, 65362				; 0000ff52H
	cmp	si, ax
	jne	SHORT $LN24@print_mark

; 263  :     name = "COD";

	mov	esi, OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	jmp	$LN55@print_mark
$LN24@print_mark:

; 264  :   else if (code == KDU_COC)

	mov	eax, 65363				; 0000ff53H
	cmp	si, ax
	jne	SHORT $LN26@print_mark

; 265  :     name = "COC";

	mov	esi, OFFSET ??_C@_03PHIIABAL@COC?$AA@
	jmp	$LN55@print_mark
$LN26@print_mark:

; 266  :   else if (code == KDU_ADS)

	mov	eax, 65395				; 0000ff73H
	cmp	si, ax
	jne	SHORT $LN28@print_mark

; 267  :     name = "ADS";

	mov	esi, OFFSET ??_C@_03BLBGDEDA@ADS?$AA@
	jmp	$LN55@print_mark
$LN28@print_mark:

; 268  :   else if (code == KDU_DFS)

	mov	eax, 65394				; 0000ff72H
	cmp	si, ax
	jne	SHORT $LN30@print_mark

; 269  :     name = "DFS";

	mov	esi, OFFSET ??_C@_03CPEMBAGM@DFS?$AA@
	jmp	$LN55@print_mark
$LN30@print_mark:

; 270  :   else if (code == KDU_ATK)

	mov	eax, 65401				; 0000ff79H
	cmp	si, ax
	jne	SHORT $LN32@print_mark

; 271  :     name = "ATK";

	mov	esi, OFFSET ??_C@_03IFCLAPBJ@ATK?$AA@
	jmp	$LN55@print_mark
$LN32@print_mark:

; 272  :   else if (code == KDU_QCD)

	mov	eax, 65372				; 0000ff5cH
	cmp	si, ax
	jne	SHORT $LN34@print_mark

; 273  :     name = "QCD";

	mov	esi, OFFSET ??_C@_03ELMDPBLM@QCD?$AA@
	jmp	$LN55@print_mark
$LN34@print_mark:

; 274  :   else if (code == KDU_QCC)

	mov	eax, 65373				; 0000ff5dH
	cmp	si, ax
	jne	SHORT $LN36@print_mark

; 275  :     name = "QCC";

	mov	esi, OFFSET ??_C@_03EICGHHL@QCC?$AA@
	jmp	$LN55@print_mark
$LN36@print_mark:

; 276  :   else if (code == KDU_RGN)

	mov	eax, 65374				; 0000ff5eH
	cmp	si, ax
	jne	SHORT $LN38@print_mark

; 277  :     name = "RGN";

	mov	esi, OFFSET ??_C@_03KEJABOAE@RGN?$AA@
	jmp	$LN55@print_mark
$LN38@print_mark:

; 278  :   else if (code == KDU_POC)

	mov	eax, 65375				; 0000ff5fH
	cmp	si, ax
	jne	SHORT $LN40@print_mark

; 279  :     name = "POC";

	mov	esi, OFFSET ??_C@_03LFCEPJHK@POC?$AA@
	jmp	SHORT $LN55@print_mark
$LN40@print_mark:

; 280  :   else if (code == KDU_CRG)

	mov	eax, 65379				; 0000ff63H
	cmp	si, ax
	jne	SHORT $LN42@print_mark

; 281  :     name = "CRG";

	mov	esi, OFFSET ??_C@_03IHBKPECM@CRG?$AA@
	jmp	SHORT $LN55@print_mark
$LN42@print_mark:

; 282  :   else if (code == KDU_COM)

	mov	eax, 65380				; 0000ff64H
	cmp	si, ax
	jne	SHORT $LN44@print_mark

; 283  :     name = "COM";

	mov	esi, OFFSET ??_C@_03GJALCMIF@COM?$AA@
	jmp	SHORT $LN55@print_mark
$LN44@print_mark:

; 284  :   else if (code == KDU_TLM)

	mov	eax, 65365				; 0000ff55H
	cmp	si, ax
	jne	SHORT $LN46@print_mark

; 285  :     name = "TLM";

	mov	esi, OFFSET ??_C@_03KGIDPNPK@TLM?$AA@
	jmp	SHORT $LN55@print_mark
$LN46@print_mark:

; 286  :   else if (code == KDU_PLM)

	mov	eax, 65367				; 0000ff57H
	cmp	si, ax
	jne	SHORT $LN48@print_mark

; 287  :     name = "PLM";

	mov	esi, OFFSET ??_C@_03CJOBGKKN@PLM?$AA@
	jmp	SHORT $LN55@print_mark
$LN48@print_mark:

; 288  :   else if (code == KDU_PLT)

	mov	eax, 65368				; 0000ff58H
	cmp	si, ax
	jne	SHORT $LN50@print_mark

; 289  :     name = "PLT";

	mov	esi, OFFSET ??_C@_03LCOBMDLF@PLT?$AA@
	jmp	SHORT $LN55@print_mark
$LN50@print_mark:

; 290  :   else if (code == KDU_PPM)

	mov	eax, 65376				; 0000ff60H
	cmp	si, ax
	jne	SHORT $LN52@print_mark

; 291  :     name = "PPM";

	mov	esi, OFFSET ??_C@_03DMNNDALJ@PPM?$AA@
	jmp	SHORT $LN55@print_mark
$LN52@print_mark:

; 292  :   else if (code == KDU_PPT)

	mov	eax, 65377				; 0000ff61H
	cmp	si, ax
	jne	SHORT $LN74@print_mark

; 293  :     name = "PPT";

	mov	esi, OFFSET ??_C@_03KHNNJJKB@PPT?$AA@
$LN55@print_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	OFFSET ??_C@_01MNNFJEPP@?$DM?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	esi
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	OFFSET ??_C@_01PPODPGHN@?$DO?$AA@
	call	DWORD PTR [eax+8]
	pop	edi
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 304  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@print_mark:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	ebx

; 247  :       { bool old_mode = mode_hex; mode_hex = new_mode; return old_mode; }

	mov	bl, BYTE PTR [edi+4]

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_02MDDDDAID@0x?$AA@

; 247  :       { bool old_mode = mode_hex; mode_hex = new_mode; return old_mode; }

	mov	BYTE PTR [edi+4], 1

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);
; 263  :         put_text(text); return *this; }
; 264  :     kdu_message &operator<<(unsigned int val)
; 265  :       { char text[80];
; 266  :         sprintf(text,(mode_hex)?"%x":"%u",val);

	cmp	BYTE PTR [edi+4], 0
	mov	ecx, OFFSET ??_C@_02GMHACPFF@?$CFu?$AA@

; 268  :     kdu_message &operator<<(long val)
; 269  :       { return (*this)<<(int) val; }
; 270  :     kdu_message &operator<<(unsigned long val)
; 271  :       { return (*this)<<(unsigned int) val; }
; 272  :     kdu_message &operator<<(short int val)
; 273  :       { return (*this)<<(int) val; }
; 274  :     kdu_message &operator<<(unsigned short int val)
; 275  :       { return (*this)<<(unsigned int) val; }

	movzx	eax, si

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);
; 263  :         put_text(text); return *this; }
; 264  :     kdu_message &operator<<(unsigned int val)
; 265  :       { char text[80];
; 266  :         sprintf(text,(mode_hex)?"%x":"%u",val);

	push	eax
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$1[ebp]
	push	eax
	call	_sprintf

; 267  :         put_text(text); return *this; }

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR _text$1[ebp]
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, edi
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 304  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 247  :       { bool old_mode = mode_hex; mode_hex = new_mode; return old_mode; }

	mov	BYTE PTR [edi+4], bl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 304  : }

	xor	ecx, ebp
	pop	ebx
	pop	edi
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?print_marker_code@@YAXGAAVkdu_message@@@Z ENDP		; print_marker_code
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Ekdu_thread_env@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekdu_thread_env@@UAEPAXI@Z PROC			; kdu_thread_env::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekdu_thread_env@@UAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kdu_thread_env@@UAE@XZ	; kdu_thread_env::~kdu_thread_env
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	48					; 00000030H
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	mov	ecx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	shl	ecx, 4
	add	ecx, 4
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:
	call	??1kdu_thread_env@@UAE@XZ		; kdu_thread_env::~kdu_thread_env
	test	bl, 1
	je	SHORT $LN6@vector
	test	bl, 4
	jne	SHORT $LN5@vector
	push	esi
	call	??3kdu_thread_entity@@SAXPAX@Z		; kdu_thread_entity::operator delete
	add	esp, 4
	jmp	SHORT $LN6@vector
$LN5@vector:
	push	48					; 00000030H
	push	esi
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN6@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Ekdu_thread_env@@UAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekdu_thread_env@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekdu_thread_env@@UAEPAXI@Z ENDP			; kdu_thread_env::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?on_finished@kdu_thread_env@@MAEX_N@Z
_TEXT	SEGMENT
_exception_handled$ = 8					; size = 1
?on_finished@kdu_thread_env@@MAEX_N@Z PROC		; kdu_thread_env::on_finished, COMDAT
; _this$ = ecx

; 2328 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 2329 :   if (state == NULL)

	mov	ecx, DWORD PTR [esi+40]
	test	ecx, ecx
	je	SHORT $LN1@on_finishe

; 2330 :     return;
; 2331 :   if (exception_handled)

	cmp	BYTE PTR _exception_handled$[ebp], 0
	je	SHORT $LN3@on_finishe

; 2332 :     state->discard_all();

	call	?discard_all@kd_thread_env@@QAEXXZ	; kd_thread_env::discard_all

; 2333 :   else if (state->buf_server.is_attached())

	jmp	SHORT $LN5@on_finishe
$LN3@on_finishe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 353  :     bool is_attached() { return (ultimate_buf_server != NULL); }

	cmp	DWORD PTR [ecx+33156], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2333 :   else if (state->buf_server.is_attached())

	je	SHORT $LN5@on_finishe

; 2334 :     state->buf_server.set_codestream_buf_server(NULL);

	push	0
	add	ecx, 33132				; 0000816cH
	call	?set_codestream_buf_server@kd_thread_buf_server@@QAEXPAVkd_buf_server@@@Z ; kd_thread_buf_server::set_codestream_buf_server
$LN5@on_finishe:

; 2335 :   state->stats_codestream = NULL;

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [eax+33128], 0

; 2336 :   state->stats.init();

	mov	ecx, DWORD PTR [esi+40]
	add	ecx, 296				; 00000128H
	call	?init@kd_compressed_stats@@QAEXXZ	; kd_compressed_stats::init
$LN1@on_finishe:
	pop	esi

; 2337 : }

	pop	ebp
	ret	4
?on_finished@kdu_thread_env@@MAEX_N@Z ENDP		; kdu_thread_env::on_finished
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?do_sync@kdu_thread_env@@MAEX_N@Z
_TEXT	SEGMENT
_exception_handled$ = 8					; size = 1
?do_sync@kdu_thread_env@@MAEX_N@Z PROC			; kdu_thread_env::do_sync, COMDAT
; _this$ = ecx

; 2314 : {

	push	ebp
	mov	ebp, esp

; 2315 :   if (exception_handled)

	cmp	BYTE PTR _exception_handled$[ebp], 0
	je	SHORT $LN2@do_sync

; 2316 :     state->discard_all();

	mov	ecx, DWORD PTR [ecx+40]
	call	?discard_all@kd_thread_env@@QAEXXZ	; kd_thread_env::discard_all

; 2319 :   assert(!have_outstanding_blocks);
; 2320 : }

	pop	ebp
	ret	4
$LN2@do_sync:

; 2317 :   else
; 2318 :     state->flush(true);

	mov	DWORD PTR _exception_handled$[ebp], 1
	mov	ecx, DWORD PTR [ecx+40]

; 2319 :   assert(!have_outstanding_blocks);
; 2320 : }

	pop	ebp

; 2317 :   else
; 2318 :     state->flush(true);

	jmp	?flush@kd_thread_env@@QAEX_N@Z		; kd_thread_env::flush
?do_sync@kdu_thread_env@@MAEX_N@Z ENDP			; kdu_thread_env::do_sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?need_sync@kdu_thread_env@@MAE_NXZ
_TEXT	SEGMENT
?need_sync@kdu_thread_env@@MAE_NXZ PROC			; kdu_thread_env::need_sync, COMDAT
; _this$ = ecx

; 6565 :       need_sync() { return have_outstanding_blocks; }

	mov	al, BYTE PTR [ecx+44]
	ret	0
?need_sync@kdu_thread_env@@MAE_NXZ ENDP			; kdu_thread_env::need_sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?get_current_thread_env@kdu_thread_env@@QAEPAV1@XZ
_TEXT	SEGMENT
?get_current_thread_env@kdu_thread_env@@QAEPAV1@XZ PROC	; kdu_thread_env::get_current_thread_env, COMDAT
; _this$ = ecx

; 6552 :       { return (kdu_thread_env *) get_current_thread_entity(); }

	jmp	?get_current_thread_entity@kdu_thread_entity@@QAEPAV1@XZ ; kdu_thread_entity::get_current_thread_entity
?get_current_thread_env@kdu_thread_env@@QAEPAV1@XZ ENDP	; kdu_thread_env::get_current_thread_env
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?get_num_locks@kdu_thread_env@@UAEHXZ
_TEXT	SEGMENT
?get_num_locks@kdu_thread_env@@UAEHXZ PROC		; kdu_thread_env::get_num_locks, COMDAT
; _this$ = ecx

; 6522 :     virtual int get_num_locks() { return KD_THREADLOCK_COUNT; }

	mov	eax, 10					; 0000000aH
	ret	0
?get_num_locks@kdu_thread_env@@UAEHXZ ENDP		; kdu_thread_env::get_num_locks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?new_instance@kdu_thread_env@@UAEPAVkdu_thread_entity@@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_instance@kdu_thread_env@@UAEPAVkdu_thread_entity@@XZ PROC ; kdu_thread_env::new_instance, COMDAT
; _this$ = ecx

; 6516 :     virtual kdu_thread_entity *new_instance() { return new kdu_thread_env; }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_instance@kdu_thread_env@@UAEPAVkdu_thread_entity@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	48					; 00000030H
	call	??2kdu_thread_entity@@SAPAXI@Z		; kdu_thread_entity::operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_instan
	mov	ecx, eax
	call	??0kdu_thread_env@@QAE@XZ		; kdu_thread_env::kdu_thread_env
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_instan:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_instance@kdu_thread_env@@UAEPAVkdu_thread_entity@@XZ$0:
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3kdu_thread_entity@@SAXPAX@Z		; kdu_thread_entity::operator delete
	pop	ecx
	ret	0
__ehhandler$?new_instance@kdu_thread_env@@UAEPAVkdu_thread_entity@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_instance@kdu_thread_env@@UAEPAVkdu_thread_entity@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_instance@kdu_thread_env@@UAEPAVkdu_thread_entity@@XZ ENDP ; kdu_thread_env::new_instance
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ??1kdu_thread_env@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kdu_thread_env@@UAE@XZ PROC				; kdu_thread_env::~kdu_thread_env, COMDAT
; _this$ = ecx

; 2301 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kdu_thread_env@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	cmp	DWORD PTR [esi+16], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2301 : {

	mov	DWORD PTR [esi], OFFSET ??_7kdu_thread_env@@6B@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	je	SHORT $LN2@kdu_thread
	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN2@kdu_thread
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2303 :     destroy();

	call	?destroy@kdu_thread_entity@@QAE_NXZ	; kdu_thread_entity::destroy
$LN2@kdu_thread:

; 2304 :   if (state != NULL)

	mov	edi, DWORD PTR [esi+40]
	test	edi, edi
	je	SHORT $LN12@kdu_thread
	lea	ecx, DWORD PTR [edi+136]
	call	??1kdu_block@@AAE@XZ			; kdu_block::~kdu_block
	push	33560					; 00008318H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@kdu_thread:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	cmp	DWORD PTR [esi+16], 0

; 188  :       { if (is_group_owner()) destroy();

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7kdu_thread_entity@@6B@

; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	je	SHORT $LN19@kdu_thread
	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN19@kdu_thread

; 188  :       { if (is_group_owner()) destroy();

	mov	ecx, esi
	call	?destroy@kdu_thread_entity@@QAE_NXZ	; kdu_thread_entity::destroy
$LN19@kdu_thread:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 2306 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1kdu_thread_env@@UAE@XZ$2:
	call	___std_terminate
	ret	0
__ehhandler$??1kdu_thread_env@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kdu_thread_env@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kdu_thread_env@@UAE@XZ ENDP				; kdu_thread_env::~kdu_thread_env
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ??0kdu_thread_env@@QAE@XZ
_TEXT	SEGMENT
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0kdu_thread_env@@QAE@XZ PROC				; kdu_thread_env::kdu_thread_env, COMDAT
; _this$ = ecx

; 2290 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0kdu_thread_env@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	call	??0kdu_thread_entity@@QAE@XZ		; kdu_thread_entity::kdu_thread_entity

; 2291 :   state = NULL; // Just in case
; 2292 :   state = new kd_thread_env(this);

	push	33560					; 00008318H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7kdu_thread_env@@6B@
	mov	DWORD PTR [esi+40], 0
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN3@kdu_thread
	push	esi
	mov	ecx, eax
	call	??0kd_thread_env@@QAE@PAVkdu_thread_env@@@Z ; kd_thread_env::kd_thread_env
	jmp	SHORT $LN4@kdu_thread
$LN3@kdu_thread:
	xor	eax, eax
$LN4@kdu_thread:
	mov	DWORD PTR [esi+40], eax

; 2293 :   have_outstanding_blocks = false;
; 2294 : }

	mov	eax, esi
	mov	BYTE PTR [esi+44], 0
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0kdu_thread_env@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1kdu_thread_entity@@UAE@XZ		; kdu_thread_entity::~kdu_thread_entity
__unwindfunclet$??0kdu_thread_env@@QAE@XZ$1:
	push	33560					; 00008318H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0kdu_thread_env@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0kdu_thread_env@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0kdu_thread_env@@QAE@XZ ENDP				; kdu_thread_env::kdu_thread_env
; Function compile flags: /Ogtp
;	COMDAT ??_Gkdu_block@@AAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkdu_block@@AAEPAXI@Z PROC				; kdu_block::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kdu_block@@AAE@XZ			; kdu_block::~kdu_block
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	160					; 000000a0H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkdu_block@@AAEPAXI@Z ENDP				; kdu_block::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?get_timing_stats@kdu_block@@QAENAA_JAAN@Z
_TEXT	SEGMENT
_once_time$ = -8					; size = 8
_unique_samples$ = 8					; size = 4
_time_wasted$ = 12					; size = 4
?get_timing_stats@kdu_block@@QAENAA_JAAN@Z PROC		; kdu_block::get_timing_stats, COMDAT
; _this$ = ecx

; 6361 :       {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6362 :       /* [SYNOPSIS]
; 6363 :            The return value is the calculated number of seconds required to
; 6364 :            process `unique_samples' once.  The `time_wasted' argument returns
; 6365 :            the number of CPU seconds wasted by iterating over a timing loop
; 6366 :            so as to reduce the impact of the calls to `clock' on the final
; 6367 :            time.
; 6368 :       */
; 6369 :         unique_samples = cpu_unique_samples;

	mov	edx, DWORD PTR _unique_samples$[ebp]
	mov	eax, DWORD PTR [ecx+136]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+140]
	mov	DWORD PTR [edx+4], eax
	movd	xmm2, DWORD PTR [ecx+148]

; 6370 :         double total_time = ((double) cpu_time) / CLOCKS_PER_SEC;

	cvtdq2pd xmm2, xmm2

; 6371 :         double once_time = total_time;
; 6372 :         if (cpu_iterations > 1) once_time /= cpu_iterations;

	mov	eax, DWORD PTR [ecx+132]
	divsd	xmm2, QWORD PTR __real@408f400000000000
	movaps	xmm1, xmm2
	movsd	QWORD PTR _once_time$[ebp], xmm1
	cmp	eax, 1
	jle	SHORT $LN2@get_timing
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	divsd	xmm1, xmm0
	movsd	QWORD PTR _once_time$[ebp], xmm1
$LN2@get_timing:

; 6373 :         time_wasted = total_time - once_time;

	mov	eax, DWORD PTR _time_wasted$[ebp]
	subsd	xmm2, xmm1

; 6374 :         return once_time;

	fld	QWORD PTR _once_time$[ebp]
	movsd	QWORD PTR [eax], xmm2

; 6375 :       }

	mov	esp, ebp
	pop	ebp
	ret	8
?get_timing_stats@kdu_block@@QAENAA_JAAN@Z ENDP		; kdu_block::get_timing_stats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?initialize_timing@kdu_block@@QAEXH@Z
_TEXT	SEGMENT
_iterations$ = 8					; size = 4
?initialize_timing@kdu_block@@QAEXH@Z PROC		; kdu_block::initialize_timing, COMDAT
; _this$ = ecx

; 6350 :       {

	push	ebp
	mov	ebp, esp

; 6351 :       /* [SYNOPSIS]
; 6352 :            Used to configure the gathering of timing stats.  A value of 0
; 6353 :            for the `iterations' argument means nothing will be timed and
; 6354 :            the block encoder or decoder should execute only once.  For
; 6355 :            more information see `kdu_codestream::set_timing_stats'.
; 6356 :       */
; 6357 :         assert(iterations >= 0);
; 6358 :         this->cpu_iterations = iterations;

	mov	eax, DWORD PTR _iterations$[ebp]
	mov	DWORD PTR [ecx+132], eax

; 6359 :       }

	pop	ebp
	ret	4
?initialize_timing@kdu_block@@QAEXH@Z ENDP		; kdu_block::initialize_timing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_tile@@QAE@PAUkd_tile@@@Z
_TEXT	SEGMENT
_state$ = 8						; size = 4
??0kdu_tile@@QAE@PAUkd_tile@@@Z PROC			; kdu_tile::kdu_tile, COMDAT
; _this$ = ecx

; 3456 :     kdu_tile(kd_tile *state) { this->state = state; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0kdu_tile@@QAE@PAUkd_tile@@@Z ENDP			; kdu_tile::kdu_tile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_compressed_state_memory@kdu_codestream@@QAE_J_N@Z
_TEXT	SEGMENT
_get_peak_allocation$ = 8				; size = 1
?get_compressed_state_memory@kdu_codestream@@QAE_J_N@Z PROC ; kdu_codestream::get_compressed_state_memory, COMDAT
; _this$ = ecx

; 7392 : {

	push	ebp
	mov	ebp, esp

; 7393 :   if (get_peak_allocation)

	cmp	BYTE PTR _get_peak_allocation$[ebp], 0

; 7394 :     return state->buf_server->get_peak_structure_bytes();

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+24]
	je	SHORT $LN2@get_compre
	mov	eax, DWORD PTR [edx+40]
	mov	edx, DWORD PTR [edx+44]

; 7397 : }

	pop	ebp
	ret	4
$LN2@get_compre:

; 7395 :   else
; 7396 :     return state->buf_server->get_current_structure_bytes();

	mov	eax, DWORD PTR [edx+32]
	mov	edx, DWORD PTR [edx+36]

; 7397 : }

	pop	ebp
	ret	4
?get_compressed_state_memory@kdu_codestream@@QAE_J_N@Z ENDP ; kdu_codestream::get_compressed_state_memory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_compressed_data_memory@kdu_codestream@@QAE_J_N@Z
_TEXT	SEGMENT
_get_peak_allocation$ = 8				; size = 1
?get_compressed_data_memory@kdu_codestream@@QAE_J_N@Z PROC ; kdu_codestream::get_compressed_data_memory, COMDAT
; _this$ = ecx

; 7379 : {

	push	ebp
	mov	ebp, esp

; 7380 :   if (get_peak_allocation)

	cmp	BYTE PTR _get_peak_allocation$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 271  :         return (kdu_long)(peak_allocated_pages * KD_CODE_BUFFER_LEN *

	mov	eax, DWORD PTR [ecx]
	push	0
	push	232					; 000000e8H
	mov	eax, DWORD PTR [eax+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7380 :   if (get_peak_allocation)

	je	SHORT $LN2@get_compre
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 271  :         return (kdu_long)(peak_allocated_pages * KD_CODE_BUFFER_LEN *

	push	DWORD PTR [eax+28]
	push	DWORD PTR [eax+24]

; 265  :         return (kdu_long)(num_allocated_pages * KD_CODE_BUFFER_LEN *

	call	__allmul
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7384 : }

	pop	ebp
	ret	4
$LN2@get_compre:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 265  :         return (kdu_long)(num_allocated_pages * KD_CODE_BUFFER_LEN *

	push	DWORD PTR [eax+20]
	push	DWORD PTR [eax+16]
	call	__allmul
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7384 : }

	pop	ebp
	ret	4
?get_compressed_data_memory@kdu_codestream@@QAE_J_N@Z ENDP ; kdu_codestream::get_compressed_data_memory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_timing_stats@kdu_codestream@@QAENPA_J_N@Z
_TEXT	SEGMENT
_system_time$1$ = -28					; size = 8
_system_time$ = -28					; size = 8
_region$1 = -20						; size = 16
_once_time$2 = -12					; size = 8
_system_samples$ = -12					; size = 8
_this$1$ = -4						; size = 4
_num_samples$ = 8					; size = 4
_coder_only$ = 12					; size = 1
?get_timing_stats@kdu_codestream@@QAENPA_J_N@Z PROC	; kdu_codestream::get_timing_stats, COMDAT
; _this$ = ecx

; 7346 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, ecx
	push	ebx
	push	esi
	push	edi

; 7347 :   double system_time = clock() - state->start_time;

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR _this$1$[ebp], eax
	call	DWORD PTR __imp__clock
	sub	eax, DWORD PTR [esi+388]
	xorps	xmm0, xmm0

; 7348 :   system_time /= CLOCKS_PER_SEC;
; 7349 :   kdu_long system_samples = 0;
; 7350 :   for (int c=0; c < state->num_apparent_components; c++)

	xor	edi, edi
	movlpd	QWORD PTR _system_samples$[ebp], xmm0
	cmp	DWORD PTR [esi+116], edi
	mov	ebx, DWORD PTR _system_samples$[ebp]
	movd	xmm3, eax
	cvtdq2pd xmm3, xmm3
	mov	esi, DWORD PTR _system_samples$[ebp+4]
	divsd	xmm3, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR _system_time$1$[ebp], xmm3
	jle	SHORT $LN3@get_timing
$LL4@get_timing:

; 7351 :     {
; 7352 :       kdu_dims region; get_dims(c,region);

	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR _region$1[ebp]
	push	0
	push	eax
	xorps	xmm0, xmm0
	push	edi
	movups	XMMWORD PTR _region$1[ebp], xmm0
	call	?get_dims@kdu_codestream@@QAEXHAAUkdu_dims@@_N@Z ; kdu_codestream::get_dims
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR _region$1[ebp+12]
	imul	DWORD PTR _region$1[ebp+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7353 :       system_samples += region.area();

	add	ebx, eax
	mov	eax, DWORD PTR _this$1$[ebp]
	adc	esi, edx
	inc	edi
	mov	eax, DWORD PTR [eax]
	cmp	edi, DWORD PTR [eax+116]
	jl	SHORT $LL4@get_timing
	movsd	xmm3, QWORD PTR _system_time$1$[ebp]
$LN3@get_timing:

; 7354 :     }
; 7355 : 
; 7356 :   kdu_long coder_samples;
; 7357 :   double wasted_time;
; 7358 :   double coder_time =
; 7359 :     state->block->get_timing_stats(coder_samples,wasted_time);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+28]
	movd	xmm1, DWORD PTR [eax+148]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 6370 :         double total_time = ((double) cpu_time) / CLOCKS_PER_SEC;

	cvtdq2pd xmm1, xmm1
	mov	ecx, DWORD PTR [eax+136]
	mov	edx, DWORD PTR [eax+140]

; 6371 :         double once_time = total_time;
; 6372 :         if (cpu_iterations > 1) once_time /= cpu_iterations;

	mov	eax, DWORD PTR [eax+132]
	divsd	xmm1, QWORD PTR __real@408f400000000000
	movaps	xmm2, xmm1
	movsd	QWORD PTR _once_time$2[ebp], xmm2
	cmp	eax, 1
	jle	SHORT $LN18@get_timing
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	divsd	xmm2, xmm0
	movsd	QWORD PTR _once_time$2[ebp], xmm2
$LN18@get_timing:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7362 :   if (coder_only)

	cmp	BYTE PTR _coder_only$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 6373 :         time_wasted = total_time - once_time;

	subsd	xmm1, xmm2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7364 :       if (num_samples != NULL)

	mov	eax, DWORD PTR _num_samples$[ebp]
	subsd	xmm3, xmm1
	movsd	QWORD PTR _system_time$[ebp], xmm3
	je	SHORT $LN5@get_timing
	test	eax, eax
	je	SHORT $LN6@get_timing

; 7365 :         *num_samples = coder_samples;

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
$LN6@get_timing:

; 7366 :       return coder_time;

	fld	QWORD PTR _once_time$2[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 7371 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN5@get_timing:

; 7367 :     }
; 7368 :   if (num_samples != NULL)

	test	eax, eax
	je	SHORT $LN7@get_timing

; 7369 :     *num_samples = system_samples;

	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], esi
$LN7@get_timing:

; 7370 :   return system_time;

	fld	QWORD PTR _system_time$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 7371 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?get_timing_stats@kdu_codestream@@QAENPA_J_N@Z ENDP	; kdu_codestream::get_timing_stats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?collect_timing_stats@kdu_codestream@@QAEXH@Z
_TEXT	SEGMENT
_num_coder_iterations$ = 8				; size = 4
?collect_timing_stats@kdu_codestream@@QAEXH@Z PROC	; kdu_codestream::collect_timing_stats, COMDAT
; _this$ = ecx

; 7333 : {

	push	ebp
	mov	ebp, esp

; 7334 :   if (num_coder_iterations < 0)

	mov	edx, DWORD PTR _num_coder_iterations$[ebp]
	xor	eax, eax
	push	esi
	mov	esi, ecx
	test	edx, edx
	cmovs	edx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 6358 :         this->cpu_iterations = iterations;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR [eax+132], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7337 :   state->start_time = clock();

	call	DWORD PTR __imp__clock
	mov	ecx, DWORD PTR [esi]
	pop	esi
	mov	DWORD PTR [ecx+388], eax

; 7338 : }

	pop	ebp
	ret	4
?collect_timing_stats@kdu_codestream@@QAEXH@Z ENDP	; kdu_codestream::collect_timing_stats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_num_tparts@kdu_codestream@@QAEHXZ
_TEXT	SEGMENT
?get_num_tparts@kdu_codestream@@QAEHXZ PROC		; kdu_codestream::get_num_tparts, COMDAT
; _this$ = ecx

; 7324 :   return state->num_completed_tparts;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+380]

; 7325 : }

	ret	0
?get_num_tparts@kdu_codestream@@QAEHXZ ENDP		; kdu_codestream::get_num_tparts
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_total_bytes@kdu_codestream@@QAE_J_N@Z
_TEXT	SEGMENT
_excluded$ = -8						; size = 8
_excluded$2$ = 8					; size = 4
_exclude_main_header$ = 8				; size = 1
?get_total_bytes@kdu_codestream@@QAE_J_N@Z PROC		; kdu_codestream::get_total_bytes, COMDAT
; _this$ = ecx

; 7304 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 7305 :   kdu_long excluded = 0;
; 7306 :   if (exclude_main_header)

	cmp	BYTE PTR _exclude_main_header$[ebp], 0
	xorps	xmm0, xmm0
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx
	movlpd	QWORD PTR _excluded$[ebp], xmm0
	je	SHORT $LN10@get_total_

; 7307 :     excluded = state->header_length;

	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR [eax+352]
	mov	edi, DWORD PTR [eax+356]
	jmp	SHORT $LN11@get_total_
$LN10@get_total_:
	mov	edi, DWORD PTR _excluded$[ebp+4]
	mov	esi, DWORD PTR _excluded$[ebp]
$LN11@get_total_:

; 7308 :   if (state->in != NULL)

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR _excluded$2$[ebp], edi
	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN3@get_total_

; 7309 :     return (state->in->get_bytes_read() -

	mov	ecx, eax
	call	?get_bytes_read@kd_compressed_input@@QAE_JXZ ; kd_compressed_input::get_bytes_read
	mov	ecx, DWORD PTR [ebx]
	mov	edi, eax
	sub	edi, esi
	mov	esi, edx
	sbb	esi, DWORD PTR _excluded$2$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?get_suspended_bytes@kd_compressed_input@@QAE_JXZ ; kd_compressed_input::get_suspended_bytes
	sub	edi, eax
	mov	eax, edi
	sbb	esi, edx
	pop	edi
	mov	edx, esi
	pop	esi
	pop	ebx

; 7315 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN3@get_total_:

; 7310 :             state->in->get_suspended_bytes() - excluded);
; 7311 :   else if (state->out != NULL)

	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN5@get_total_

; 7312 :     return (state->out->get_bytes_written() - excluded);

	mov	eax, DWORD PTR [ecx+516]
	sub	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 452  :       { return (flushed_bytes + (next_buf-buffer)); }

	sub	eax, 4
	cdq
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7312 :     return (state->out->get_bytes_written() - excluded);

	add	eax, DWORD PTR [ecx+528]
	adc	edx, DWORD PTR [ecx+532]
	sub	eax, esi
	sbb	edx, edi
	pop	edi
	pop	esi
	pop	ebx

; 7315 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN5@get_total_:
	pop	edi
	pop	esi

; 7313 :   else
; 7314 :     return 0;

	xor	eax, eax
	xor	edx, edx
	pop	ebx

; 7315 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?get_total_bytes@kdu_codestream@@QAE_J_N@Z ENDP		; kdu_codestream::get_total_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?ready_for_flush@kdu_codestream@@QAE_NPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_p_idx$1 = -8						; size = 8
$T2 = 8							; size = 4
_p_res$3 = 8						; size = 4
_env$ = 8						; size = 4
?ready_for_flush@kdu_codestream@@QAE_NPAVkdu_thread_env@@@Z PROC ; kdu_codestream::ready_for_flush, COMDAT
; _this$ = ecx

; 7267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	edi
	mov	edi, ecx

; 7268 :   if ((state == NULL) || (state->out == NULL))

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	$LN6@ready_for_
	cmp	DWORD PTR [eax+8], 0
	je	$LN6@ready_for_

; 7270 : 
; 7271 :   if (env != NULL)

	push	ebx
	mov	ebx, DWORD PTR _env$[ebp]
	push	esi
	test	ebx, ebx
	je	SHORT $LN15@ready_for_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	esi, DWORD PTR [ebx+28]
	cmp	BYTE PTR [eax], 0
	jne	$LN52@ready_for_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN18@ready_for_
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN18@ready_for_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [esi+4], ebx
$LN15@ready_for_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7273 :   for (kd_tile *tile = state->tiles_in_progress_head;

	mov	eax, DWORD PTR [edi]
	mov	edi, DWORD PTR [eax+268]

; 7274 :        tile != NULL; tile=tile->in_progress_next)

	test	edi, edi
	je	$LN48@ready_for_
$LL4@ready_for_:

; 7280 :       p_ref = tile->sequencer->next_in_sequence(p_res,p_idx);

	mov	ecx, DWORD PTR [edi+52]
	lea	eax, DWORD PTR _p_idx$1[ebp]
	push	eax
	lea	eax, DWORD PTR _p_res$3[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _p_idx$1[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7280 :       p_ref = tile->sequencer->next_in_sequence(p_res,p_idx);

	push	eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _p_idx$1[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7280 :       p_ref = tile->sequencer->next_in_sequence(p_res,p_idx);

	call	?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_sequence
	mov	edx, eax

; 7281 :       if (p_ref != NULL)

	test	edx, edx
	je	SHORT $LN2@ready_for_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4722 :   if (state == 3)

	mov	ecx, DWORD PTR [edx]
	mov	esi, DWORD PTR [edx+4]
	cmp	ecx, 3
	jne	SHORT $LN24@ready_for_
	test	esi, esi
	je	SHORT $LN23@ready_for_
$LN24@ready_for_:

; 4723 :     return NULL; // Precinct is not currently loaded
; 4724 :   if ((state == 0) || (state & 1))

	mov	eax, ecx
	or	eax, esi
	je	SHORT $LN26@ready_for_
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN26@ready_for_

; 4726 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state);

	mov	esi, DWORD PTR [edx]

; 4727 :   if (result->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [esi+8]
	test	al, 32					; 00000020H
	je	SHORT $LN27@ready_for_

; 4728 :     { // Must be on the inactive list
; 4729 :       result->size_class->withdraw_from_inactive_list(result);

	mov	ecx, DWORD PTR [esi+52]
	push	esi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list

; 4730 :       result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate
	jmp	SHORT $LN23@ready_for_
$LN27@ready_for_:

; 4731 :     }
; 4732 :   else if (need_activate && (result->flags & KD_PFLAG_RELEASED))

	test	al, 16					; 00000010H
	je	SHORT $LN23@ready_for_

; 4733 :     result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate

; 4734 :   return result;

	jmp	SHORT $LN23@ready_for_
$LN26@ready_for_:

; 4725 :     return instantiate_precinct(res,pos_idx);

	push	DWORD PTR _p_idx$1[ebp+4]
	mov	ecx, edx
	push	DWORD PTR _p_idx$1[ebp]
	push	DWORD PTR _p_res$3[ebp]
	call	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
	mov	esi, eax
$LN23@ready_for_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7285 :           if (precinct->num_outstanding_blocks == 0)

	cmp	DWORD PTR [esi+24], 0
	je	SHORT $LN44@ready_for_
$LN2@ready_for_:

; 7274 :        tile != NULL; tile=tile->in_progress_next)

	mov	edi, DWORD PTR [edi+24]
	test	edi, edi
	jne	$LL4@ready_for_
$LN48@ready_for_:

; 7290 :             }
; 7291 :         }
; 7292 :     }
; 7293 :   if (env != NULL)

	test	ebx, ebx
	je	SHORT $LN41@ready_for_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [ebx+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN41@ready_for_
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN41@ready_for_:
	pop	esi
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7295 :   return false;

	xor	al, al
	pop	edi

; 7296 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN44@ready_for_:

; 7286 :             {
; 7287 :               if (env != NULL)

	test	ebx, ebx
	je	SHORT $LN35@ready_for_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [ebx+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN35@ready_for_
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN35@ready_for_:
	pop	esi
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7289 :               return true; // We have something which can be flushed.

	mov	al, 1
	pop	edi

; 7296 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@ready_for_:

; 7269 :     return false;

	xor	al, al
	pop	edi

; 7296 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN52@ready_for_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN54@ready_for_:
$LN51@ready_for_:
	int	3
?ready_for_flush@kdu_codestream@@QAE_NPAVkdu_thread_env@@@Z ENDP ; kdu_codestream::ready_for_flush
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_e$2 = -88						; size = 20
_w$3 = -88						; size = 20
_sloppy_bytes$4 = -68					; size = 8
_header_bytes$ = -60					; size = 8
_save_max_bytes$2$ = -52				; size = 4
_save_max_bytes$1$ = -48				; size = 4
_this$1$ = -44						; size = 4
_total_bytes$ = -40					; size = 8
_threshold$1$ = -36					; size = 4
tv803 = -32						; size = 4
_total_bytes$1$ = -28					; size = 4
_num_layers$1$ = -28					; size = 4
_n$3$ = -24						; size = 4
_last_layer$ = -24					; size = 1
_total_bytes$4$ = -20					; size = 4
_total_bytes$3$ = -20					; size = 4
_max_bytes$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_generated_bytes$5 = 8					; size = 8
_max_bytes$ = 8						; size = 8
_max_bytes$2$ = 12					; size = 4
_layer_bytes$ = 16					; size = 4
_layer_bytes_entries$ = 20				; size = 4
_generated_bytes$1$ = 24				; size = 4
_total_bytes$2$ = 24					; size = 4
$T6 = 24						; size = 4
_record_in_comseg$ = 24					; size = 1
_last_layer$1$ = 27					; size = 1
_env$ = 28						; size = 4
?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z PROC ; kdu_codestream::trans_out, COMDAT
; _this$ = ecx

; 7122 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 7123 :   int n;
; 7124 : 
; 7125 :   if (env != NULL)

	mov	ebx, DWORD PTR _env$[ebp]
	test	ebx, ebx
	je	SHORT $LN49@trans_out
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	esi, DWORD PTR [ebx+28]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN48@trans_out
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T6[ebp], eax
	lea	eax, DWORD PTR $T6[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN99@trans_out:
$LN48@trans_out:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN52@trans_out
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN52@trans_out:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [esi+4], ebx
$LN49@trans_out:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7129 :   if (!state->construction_finalized)

	mov	ecx, DWORD PTR [edi]
	cmp	BYTE PTR [ecx+341], 0
	jne	SHORT $LN24@trans_out

; 7130 :     state->finalize_construction();

	call	?finalize_construction@kd_codestream@@QAEXXZ ; kd_codestream::finalize_construction
$LN24@trans_out:

; 7131 :   if (state->reslength_constraints_used && !state->reslength_warning_issued)

	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+320], 0
	je	SHORT $LN25@trans_out
	cmp	BYTE PTR [eax+322], 0
	jne	SHORT $LN25@trans_out

; 7132 :     { KDU_WARNING_DEV(w,0x10110801); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$3[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$3[ebp]
	lea	ecx, DWORD PTR _w$3[ebp]
	push	OFFSET ??_C@_0BAM@PBALKCJD@You?5cannot?5currently?5use?5the?5?$GACr@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7132 :     { KDU_WARNING_DEV(w,0x10110801); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7138 :       state->reslength_warning_issued = true;

	mov	eax, DWORD PTR [edi]

; 7139 :     }

	lea	ecx, DWORD PTR _w$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	BYTE PTR [eax+322], 1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN25@trans_out:

; 7140 :   if (max_bytes == 0)

	mov	esi, DWORD PTR _max_bytes$[ebp]
	mov	eax, esi
	mov	ecx, DWORD PTR _max_bytes$[ebp+4]
	or	eax, ecx
	mov	DWORD PTR _max_bytes$1$[ebp], esi
	mov	DWORD PTR _max_bytes$2$[ebp], ecx
	jne	SHORT $LN26@trans_out

; 7141 :     max_bytes = KDU_LONG_HUGE;

	xor	esi, esi
	mov	DWORD PTR _max_bytes$2$[ebp], 1048576	; 00100000H
	mov	DWORD PTR _max_bytes$1$[ebp], esi
$LN26@trans_out:

; 7142 :   if (state->layer_targets == NULL)

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+292]
	test	ecx, ecx
	jne	$LN27@trans_out

; 7143 :     { // Set up `num_sized_layers' and internal arrays on this first call
; 7144 :       state->num_sized_layers=1;

	mov	DWORD PTR [eax+284], 1

; 7145 :       for (kd_tile *tile=state->tiles_in_progress_head;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+268]

; 7146 :            tile != NULL; tile=tile->in_progress_next)

	test	eax, eax
	je	SHORT $LN3@trans_out
	npad	9
$LL4@trans_out:

; 7147 :         if (tile->num_layers > state->num_sized_layers)

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+132]
	cmp	edx, DWORD PTR [ecx+284]
	jle	SHORT $LN2@trans_out

; 7148 :           state->num_sized_layers = tile->num_layers;

	mov	DWORD PTR [ecx+284], edx
$LN2@trans_out:

; 7146 :            tile != NULL; tile=tile->in_progress_next)

	mov	eax, DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $LL4@trans_out
$LN3@trans_out:

; 7149 :       state->layer_sizes = new kdu_long[state->num_sized_layers];

	mov	eax, DWORD PTR [edi]
	xor	ecx, ecx
	mov	ebx, 8
	mov	eax, DWORD PTR [eax+284]
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ecx+288], eax

; 7150 :       state->layer_targets = new kdu_long[state->num_sized_layers];

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+284]
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR [edi]

; 7151 :       state->layer_thresholds = new kdu_uint16[state->num_sized_layers];

	mov	edx, 2
	mov	DWORD PTR [ecx+292], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+284]
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR [edi]

; 7152 :       for (n=0; n < state->num_sized_layers; n++)

	xor	edx, edx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+296], eax
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax+284], edx
	jle	SHORT $LN6@trans_out
	npad	7
$LL7@trans_out:

; 7153 :         {
; 7154 :           state->layer_sizes[n] = 0;

	mov	eax, DWORD PTR [edi]

; 7155 :           state->layer_targets[n] = 0;
; 7156 :           state->layer_thresholds[n] = 0xFFFF - n - 1;

	mov	ecx, 65534				; 0000fffeH
	sub	ecx, edx
	mov	eax, DWORD PTR [eax+288]
	mov	DWORD PTR [eax+edx*8], 0
	mov	DWORD PTR [eax+edx*8+4], 0
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+292]
	mov	DWORD PTR [eax+edx*8], 0
	mov	DWORD PTR [eax+edx*8+4], 0
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+296]
	mov	WORD PTR [eax+edx*2], cx
	inc	edx
	mov	eax, DWORD PTR [edi]
	cmp	edx, DWORD PTR [eax+284]
	jl	SHORT $LL7@trans_out
$LN6@trans_out:

; 7157 :         }
; 7158 :       state->layer_targets[n-1] = max_bytes;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _max_bytes$2$[ebp]
	mov	eax, DWORD PTR [eax+292]
	mov	DWORD PTR [eax+edx*8-8], esi
	mov	DWORD PTR [eax+edx*8-4], ecx

; 7159 :     }
; 7160 :   else

	jmp	SHORT $LN28@trans_out
$LN27@trans_out:

; 7161 :     {
; 7162 :       assert(state->num_sized_layers > 0);
; 7163 :       max_bytes = state->layer_targets[state->num_sized_layers-1];

	mov	eax, DWORD PTR [eax+284]
	mov	esi, DWORD PTR [ecx+eax*8-8]
	mov	ecx, DWORD PTR [ecx+eax*8-4]
	mov	DWORD PTR _max_bytes$1$[ebp], esi
	mov	DWORD PTR _max_bytes$2$[ebp], ecx
$LN28@trans_out:

; 7164 :     }
; 7165 : 
; 7166 :   kdu_long save_max_bytes = max_bytes;
; 7167 : 
; 7168 :   state->reserved_layer_info_bytes = 0;
; 7169 :   if (record_in_comseg && state->initial_fragment &&

	cmp	BYTE PTR _record_in_comseg$[ebp], 0
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _save_max_bytes$1$[ebp], esi
	mov	DWORD PTR _save_max_bytes$2$[ebp], ecx
	mov	DWORD PTR [eax+360], 0
	je	SHORT $LN30@trans_out
	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+225], 0
	je	SHORT $LN30@trans_out
	cmp	BYTE PTR [eax+343], 0
	jne	SHORT $LN30@trans_out

; 7170 :       !state->header_generated)
; 7171 :     state->set_reserved_layer_info_bytes(state->num_sized_layers);

	push	DWORD PTR [eax+284]
	mov	ecx, eax
	call	?set_reserved_layer_info_bytes@kd_codestream@@QAEXH@Z ; kd_codestream::set_reserved_layer_info_bytes
	mov	ecx, DWORD PTR _max_bytes$2$[ebp]
$LN30@trans_out:

; 7172 : 
; 7173 :   // Run simulations until we find a suitable number of non-empty layers
; 7174 :   if (state->final_fragment)

	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+226], 0
	je	SHORT $LN31@trans_out

; 7175 :     max_bytes -= 2; // Allow room for the EOC marker.

	add	esi, -2					; fffffffeH
	mov	DWORD PTR _max_bytes$1$[ebp], esi
	adc	ecx, -1
	mov	DWORD PTR _max_bytes$2$[ebp], ecx
$LN31@trans_out:

; 7176 :   for (n=0; n < state->num_sized_layers; n++)

	mov	ebx, DWORD PTR [eax+284]
	mov	DWORD PTR _num_layers$1$[ebp], ebx
	test	ebx, ebx
	jle	SHORT $LN9@trans_out

; 7177 :     max_bytes -= state->layer_sizes[n];

	mov	eax, DWORD PTR [eax+288]
	mov	edx, ebx
	npad	3
$LL10@trans_out:
	sub	esi, DWORD PTR [eax]
	sbb	ecx, DWORD PTR [eax+4]
	add	eax, 8
	sub	edx, 1
	jne	SHORT $LL10@trans_out
	mov	DWORD PTR _max_bytes$2$[ebp], ecx
	mov	DWORD PTR _max_bytes$1$[ebp], esi
$LN9@trans_out:

; 7178 :   kdu_long total_bytes, header_bytes;
; 7179 :   int num_layers = state->num_sized_layers;

	mov	al, BYTE PTR _last_layer$[ebp]
	mov	BYTE PTR _last_layer$1$[ebp], al
	npad	7
$LL13@trans_out:

; 7180 :   bool last_layer;
; 7181 :   do {
; 7182 :       total_bytes = 0;
; 7183 :       for (n=0; n < num_layers; n++)

	xorps	xmm0, xmm0
	xor	esi, esi
	movlpd	QWORD PTR _total_bytes$[ebp], xmm0
	test	ebx, ebx
	jle	$LN97@trans_out
	mov	eax, DWORD PTR _total_bytes$[ebp+4]
	mov	DWORD PTR _total_bytes$3$[ebp], eax
	mov	eax, DWORD PTR _total_bytes$[ebp]
	mov	DWORD PTR _total_bytes$1$[ebp], eax
	npad	2
$LL16@trans_out:

; 7184 :         {
; 7185 :           last_layer = (n == (num_layers-1));
; 7186 :           kdu_uint16 threshold = state->layer_thresholds[n];

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx-1]
	cmp	esi, eax

; 7187 :           if (last_layer)
; 7188 :             threshold = 0xFFFF; // This way we will just count the header cost
; 7189 :           total_bytes +=

	push	0
	push	1048576					; 00100000H
	mov	eax, DWORD PTR [ecx+296]
	sete	dl
	push	0
	mov	BYTE PTR _last_layer$[ebp], dl
	test	dl, dl
	push	DWORD PTR _last_layer$[ebp]
	movzx	eax, WORD PTR [eax+esi*2]
	mov	BYTE PTR _last_layer$1$[ebp], dl
	mov	edx, 65535				; 0000ffffH
	push	1
	cmovne	eax, edx
	push	eax
	push	esi
	lea	eax, DWORD PTR _header_bytes$[ebp]
	push	eax
	call	?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z ; kd_codestream::simulate_output
	mov	ecx, DWORD PTR _total_bytes$1$[ebp]
	add	ecx, eax
	mov	eax, DWORD PTR _total_bytes$3$[ebp]
	mov	DWORD PTR _total_bytes$1$[ebp], ecx
	adc	eax, edx
	mov	DWORD PTR _total_bytes$3$[ebp], eax

; 7190 :             state->simulate_output(header_bytes,n,threshold,true,last_layer);
; 7191 :           if (total_bytes >= max_bytes)

	cmp	eax, DWORD PTR _max_bytes$2$[ebp]
	jl	SHORT $LN94@trans_out
	jg	SHORT $LN92@trans_out
	cmp	ecx, DWORD PTR _max_bytes$1$[ebp]
	jb	SHORT $LN94@trans_out
$LN92@trans_out:

; 7192 :             {
; 7193 :               if (last_layer)

	mov	al, BYTE PTR _last_layer$1$[ebp]
	test	al, al
	je	SHORT $LN34@trans_out

; 7194 :                 {
; 7195 :                   num_layers = n; // Could not even afford the header cost.
; 7196 :                   last_layer = false; // Make sure we iterate.

	xor	al, al
	mov	ebx, esi
	mov	BYTE PTR _last_layer$1$[ebp], al

; 7197 :                 }
; 7198 :               else

	jmp	SHORT $LN14@trans_out
$LN34@trans_out:

; 7199 :                 num_layers = n+1; // Try running current layer as the last one,

	lea	ebx, DWORD PTR [esi+1]
	jmp	SHORT $LN14@trans_out
$LN94@trans_out:
	mov	al, BYTE PTR _last_layer$1$[ebp]
$LN14@trans_out:

; 7180 :   bool last_layer;
; 7181 :   do {
; 7182 :       total_bytes = 0;
; 7183 :       for (n=0; n < num_layers; n++)

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL16@trans_out

; 7200 :                                   // where we count only the cost of headers
; 7201 :             }
; 7202 :         }
; 7203 :       if (num_layers == 0)

	mov	DWORD PTR _num_layers$1$[ebp], ebx
	test	ebx, ebx
$LN97@trans_out:
	jne	SHORT $LN11@trans_out

; 7204 :         { KDU_ERROR(e,60); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0IB@LAIBJLIH@You?5have?5set?5the?5byte?5limit?5too?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7204 :         { KDU_ERROR(e,60); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7208 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	al, BYTE PTR _last_layer$1$[ebp]
$LN11@trans_out:

; 7209 :     } while (!last_layer);

	test	al, al
	je	$LL13@trans_out

; 7210 : 
; 7211 :   // Now go back through all the layers, finalizing the allocation.
; 7212 :   total_bytes = 0;
; 7213 :   for (n=0; n < num_layers; n++)

	xor	edx, edx
	xorps	xmm0, xmm0
	movlpd	QWORD PTR _total_bytes$[ebp], xmm0
	mov	DWORD PTR _n$3$[ebp], edx
	test	ebx, ebx
	jle	$LN18@trans_out
	mov	esi, DWORD PTR _total_bytes$[ebp+4]
	lea	ecx, DWORD PTR [ebx-1]
	mov	eax, DWORD PTR _total_bytes$[ebp]
	mov	DWORD PTR _total_bytes$4$[ebp], esi
	mov	DWORD PTR _total_bytes$2$[ebp], eax
	npad	3
$LL19@trans_out:

; 7214 :     {
; 7215 :       last_layer = (n == (num_layers-1));
; 7216 :       kdu_uint16 threshold = state->layer_thresholds[n];

	mov	eax, DWORD PTR [edi]
	cmp	edx, ecx
	mov	DWORD PTR tv803[ebp], eax

; 7217 :       if (!last_layer)
; 7218 :         {
; 7219 :           total_bytes +=

	push	0
	sete	cl
	mov	eax, DWORD PTR [eax+296]
	push	1048576					; 00100000H
	push	0
	movzx	eax, WORD PTR [eax+edx*2]
	mov	DWORD PTR _threshold$1$[ebp], eax
	test	cl, cl
	jne	SHORT $LN37@trans_out
	mov	ecx, DWORD PTR [edi]
	push	0
	push	1
	push	eax
	push	edx
	lea	eax, DWORD PTR _header_bytes$[ebp]
	push	eax
	call	?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z ; kd_codestream::simulate_output

; 7220 :             state->simulate_output(header_bytes,n,threshold,true,last_layer);
; 7221 :           assert(total_bytes < max_bytes);
; 7222 :         }
; 7223 :       else

	jmp	SHORT $LN98@trans_out
$LN37@trans_out:

; 7224 :         { // Last layer is a sloppy one
; 7225 :           kdu_long trial_bytes = total_bytes +
; 7226 :             state->simulate_output(header_bytes,n,threshold+1,false,true);
; 7227 :           assert(trial_bytes <= max_bytes); // Header cost only.
; 7228 :           kdu_long sloppy_bytes = max_bytes - trial_bytes;

	mov	edi, DWORD PTR _max_bytes$1$[ebp]
	sub	edi, DWORD PTR _total_bytes$2$[ebp]
	mov	esi, DWORD PTR _max_bytes$2$[ebp]
	sbb	esi, DWORD PTR _total_bytes$4$[ebp]
	inc	eax
	mov	ecx, DWORD PTR tv803[ebp]
	push	1
	push	0
	push	eax
	push	edx
	lea	eax, DWORD PTR _header_bytes$[ebp]
	push	eax
	call	?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z ; kd_codestream::simulate_output
	mov	ecx, edi
	sub	ecx, eax
	mov	eax, esi
	mov	DWORD PTR _sloppy_bytes$4[ebp], ecx
	sbb	eax, edx
	mov	DWORD PTR _sloppy_bytes$4[ebp+4], eax

; 7229 :           total_bytes +=

	lea	eax, DWORD PTR _sloppy_bytes$4[ebp]
	push	eax
	push	esi
	push	edi
	mov	edi, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR _header_bytes$[ebp]
	push	1
	push	1
	push	DWORD PTR _threshold$1$[ebp]
	mov	ecx, DWORD PTR [edi]
	push	DWORD PTR _n$3$[ebp]
	push	eax
	call	?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z ; kd_codestream::simulate_output
	mov	esi, DWORD PTR _total_bytes$4$[ebp]
$LN98@trans_out:
	mov	ecx, DWORD PTR _total_bytes$2$[ebp]
	add	ecx, eax

; 7230 :             state->simulate_output(header_bytes,n,threshold,true,true,
; 7231 :                                    max_bytes-total_bytes,&sloppy_bytes);
; 7232 :           assert(total_bytes <= max_bytes);
; 7233 :         }
; 7234 :       state->layer_targets[n] = total_bytes;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _total_bytes$2$[ebp], ecx
	adc	esi, edx
	mov	edx, DWORD PTR _n$3$[ebp]
	mov	DWORD PTR _total_bytes$4$[ebp], esi
	mov	eax, DWORD PTR [eax+292]
	mov	DWORD PTR [eax+edx*8], ecx
	lea	ecx, DWORD PTR [ebx-1]
	mov	DWORD PTR [eax+edx*8+4], esi
	inc	edx
	mov	DWORD PTR _n$3$[ebp], edx
	cmp	edx, ebx
	jl	$LL19@trans_out
$LN18@trans_out:

; 7235 :     }
; 7236 : 
; 7237 :   if (state->reserved_layer_info_bytes && state->initial_fragment &&

	mov	ecx, DWORD PTR [edi]
	cmp	DWORD PTR [ecx+360], 0
	je	SHORT $LN39@trans_out
	cmp	BYTE PTR [ecx+225], 0
	je	SHORT $LN39@trans_out
	cmp	BYTE PTR [ecx+343], 0
	jne	SHORT $LN39@trans_out

; 7238 :       !state->header_generated)
; 7239 :     state->gen_layer_info_comment(num_layers,state->layer_targets,

	push	DWORD PTR [ecx+296]
	push	DWORD PTR [ecx+292]
	push	ebx
	call	?gen_layer_info_comment@kd_codestream@@QAEXHPA_JPAG@Z ; kd_codestream::gen_layer_info_comment
$LN39@trans_out:

; 7240 :                                   state->layer_thresholds);
; 7241 : 
; 7242 :   // Generate the code-stream.
; 7243 :   state->generate_codestream(num_layers);

	mov	ecx, DWORD PTR [edi]
	push	ebx
	call	?generate_codestream@kd_codestream@@QAE_NH@Z ; kd_codestream::generate_codestream

; 7244 :   state->layer_targets[state->num_sized_layers-1] = save_max_bytes;

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR _save_max_bytes$1$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	mov	eax, DWORD PTR [eax+284]
	mov	DWORD PTR [ecx+eax*8-8], edx
	mov	edx, DWORD PTR _save_max_bytes$2$[ebp]
	mov	DWORD PTR [ecx+eax*8-4], edx

; 7245 : 
; 7246 :   if (layer_bytes != NULL)

	mov	edx, DWORD PTR _layer_bytes$[ebp]
	test	edx, edx
	je	SHORT $LN21@trans_out

; 7247 :     {
; 7248 :       kdu_long generated_bytes = 0;
; 7249 :       for (n=0; n < layer_bytes_entries; n++)

	xor	ecx, ecx
	xorps	xmm0, xmm0
	movlpd	QWORD PTR _generated_bytes$5[ebp], xmm0
	cmp	DWORD PTR _layer_bytes_entries$[ebp], ecx
	jle	SHORT $LN21@trans_out
	mov	eax, DWORD PTR _generated_bytes$5[ebp]
	mov	esi, DWORD PTR _generated_bytes$5[ebp+4]
	mov	DWORD PTR _generated_bytes$1$[ebp], eax
$LL22@trans_out:

; 7250 :         if (n < state->num_sized_layers)

	mov	ebx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [ebx+284]
	jge	SHORT $LN41@trans_out

; 7251 :           layer_bytes[n] = (generated_bytes += state->layer_sizes[n]);

	mov	eax, DWORD PTR [ebx+288]
	mov	ebx, DWORD PTR _generated_bytes$1$[ebp]
	add	ebx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _generated_bytes$1$[ebp], ebx
	adc	esi, DWORD PTR [eax+ecx*8+4]
	mov	eax, ebx
$LN41@trans_out:

; 7252 :         else
; 7253 :           layer_bytes[n] = generated_bytes;

	mov	DWORD PTR [edx+ecx*8+4], esi
	mov	DWORD PTR [edx+ecx*8], eax
	inc	ecx
	cmp	ecx, DWORD PTR _layer_bytes_entries$[ebp]
	jl	SHORT $LL22@trans_out
	mov	ebx, DWORD PTR _num_layers$1$[ebp]
$LN21@trans_out:

; 7254 :     }
; 7255 : 
; 7256 :   if (env != NULL)

	mov	ecx, DWORD PTR _env$[ebp]
	test	ecx, ecx
	je	SHORT $LN63@trans_out
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	ecx, DWORD PTR [ecx+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [ecx+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN63@trans_out
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN63@trans_out:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7258 :   return num_layers;

	mov	eax, ebx

; 7259 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN96@trans_out:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z$0:
	lea	ecx, DWORD PTR _w$3[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?trans_out@kdu_codestream@@QAEH_JPA_JH_NPAVkdu_thread_env@@@Z ENDP ; kdu_codestream::trans_out
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_w$2 = -84						; size = 20
_w$3 = -64						; size = 20
_e$4 = -64						; size = 20
_header_bytes$5 = -44					; size = 8
tv164 = -36						; size = 8
_total_bytes$6 = -36					; size = 8
_last_layer$7 = -32					; size = 1
_best_threshold$1$ = -28				; size = 4
_min_threshold$1$ = -24					; size = 4
_total_bytes$1$ = -20					; size = 4
_last_layer_takes_all$1$ = -14				; size = 1
_using_slopes$1$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_layer_bytes$ = 8					; size = 4
_num_layer_specs$ = 12					; size = 4
_thresholds$ = 16					; size = 4
_n$3$ = 20						; size = 4
_trim_to_rate$ = 20					; size = 1
tv1172 = 24						; size = 4
$T8 = 24						; size = 4
_record_in_comseg$ = 24					; size = 1
_have_constraints$1$ = 27				; size = 1
_generated_bytes$9 = 28					; size = 8
_tolerance$ = 28					; size = 8
_total_bytes$2$ = 32					; size = 4
_env$ = 36						; size = 4
?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z PROC ; kdu_codestream::flush, COMDAT
; _this$ = ecx

; 6962 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 6963 :   int n;
; 6964 : 
; 6965 :   if (env != NULL)

	mov	ebx, DWORD PTR _env$[ebp]
	test	ebx, ebx
	je	SHORT $LN65@flush
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [ebx+28]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN64@flush
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T8[ebp], eax
	lea	eax, DWORD PTR $T8[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN194@flush:
$LN64@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN68@flush
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN68@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+4], ebx
$LN65@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6969 :   if (!state->construction_finalized)

	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx+341], 0
	jne	SHORT $LN27@flush

; 6970 :     state->finalize_construction();

	call	?finalize_construction@kd_codestream@@QAEXXZ ; kd_codestream::finalize_construction
$LN27@flush:

; 6971 : 
; 6972 :   // Start by maintaining the internal record of slope or size thresholds to
; 6973 :   // ensure consistency between multiple calls to this function.
; 6974 :   if (state->layer_targets == NULL)

	mov	eax, DWORD PTR [esi]

; 6975 :     { // First call to `flush'
; 6976 :       assert((state->layer_thresholds==NULL) && (state->layer_sizes==NULL));
; 6977 :       state->num_sized_layers = num_layer_specs;

	mov	edi, DWORD PTR _num_layer_specs$[ebp]
	cmp	DWORD PTR [eax+292], 0
	jne	$LN28@flush
	mov	DWORD PTR [eax+284], edi

; 6978 :       state->layer_sizes = new kdu_long[num_layer_specs];

	xor	ecx, ecx
	mov	eax, edi
	mov	ebx, 8
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+288], eax

; 6979 :       state->layer_targets = new kdu_long[num_layer_specs];

	xor	ecx, ecx
	mov	eax, edi
	mul	ebx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR [esi]

; 6980 :       state->layer_thresholds = new kdu_uint16[num_layer_specs];

	mov	edx, 2
	mov	DWORD PTR [ecx+292], eax
	xor	ecx, ecx
	mov	eax, edi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+296], eax

; 6981 :       for (n=0; n < num_layer_specs; n++)

	xor	ecx, ecx
	test	edi, edi
	jle	$LN189@flush
	npad	14
$LL4@flush:

; 6982 :         {
; 6983 :           state->layer_sizes[n] = 0;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+288]
	mov	DWORD PTR [eax+ecx*8], 0
	mov	DWORD PTR [eax+ecx*8+4], 0

; 6984 :           state->layer_targets[n] = (layer_bytes==NULL)?0:(layer_bytes[n]);

	mov	eax, DWORD PTR _layer_bytes$[ebp]
	test	eax, eax
	jne	SHORT $LN52@flush
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv164[ebp], xmm0
	mov	ebx, DWORD PTR tv164[ebp+4]
	mov	edx, DWORD PTR tv164[ebp]
	jmp	SHORT $LN53@flush
$LN52@flush:
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	ebx, DWORD PTR [eax+ecx*8+4]
$LN53@flush:
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+292]
	mov	DWORD PTR [eax+ecx*8], edx
	mov	DWORD PTR [eax+ecx*8+4], ebx

; 6985 :           state->layer_thresholds[n] = (thresholds==NULL)?0:(thresholds[n]);

	mov	ebx, DWORD PTR _thresholds$[ebp]
	test	ebx, ebx
	jne	SHORT $LN54@flush
	xor	edx, edx
	jmp	SHORT $LN55@flush
$LN54@flush:
	movzx	edx, WORD PTR [ebx+ecx*2]
$LN55@flush:
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+296]
	mov	WORD PTR [eax+ecx*2], dx
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LL4@flush

; 6986 :         }
; 6987 :     }
; 6988 :   else

	jmp	$LN31@flush
$LN28@flush:

; 6989 :     {
; 6990 :       assert((state->layer_thresholds!=NULL) && (state->layer_sizes!=NULL));
; 6991 :       if (num_layer_specs != state->num_sized_layers)

	cmp	edi, DWORD PTR [eax+284]
	je	SHORT $LN30@flush

; 6992 :         { KDU_ERROR_DEV(e,59); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0JF@GPFDNPBI@When?5generating?5code?9stream?5outp@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6992 :         { KDU_ERROR_DEV(e,59); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6996 :         }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN30@flush:

; 6997 :       if (state->reslength_constraints_used &&

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+320], 0
	je	SHORT $LN189@flush
	cmp	BYTE PTR [eax+322], 0
	jne	SHORT $LN189@flush

; 6999 :         { KDU_WARNING_DEV(w,0x10110800); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$3[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$3[ebp]
	lea	ecx, DWORD PTR _w$3[ebp]
	push	OFFSET ??_C@_0KC@BHKKEAHA@You?5cannot?5currently?5use?5the?5?$GACr@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6999 :         { KDU_WARNING_DEV(w,0x10110800); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7004 :           state->reslength_warning_issued = true;

	mov	eax, DWORD PTR [esi]

; 7005 :         }

	lea	ecx, DWORD PTR _w$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	BYTE PTR [eax+322], 1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN189@flush:
	mov	ebx, DWORD PTR _thresholds$[ebp]
$LN31@flush:

; 7006 :     }
; 7007 :   bool using_slopes = (state->layer_thresholds[0] != 0);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+296]

; 7008 :   bool last_layer_takes_all = // If last layer is to hold all generated data
; 7009 :     (state->layer_targets[num_layer_specs-1] == 0) && !using_slopes;

	mov	ecx, DWORD PTR [ecx+292]
	cmp	WORD PTR [eax], 0
	mov	eax, DWORD PTR [ecx+edi*8-8]
	setne	dl
	or	eax, DWORD PTR [ecx+edi*8-4]
	mov	BYTE PTR _using_slopes$1$[ebp], dl
	jne	SHORT $LN56@flush
	test	dl, dl
	jne	SHORT $LN56@flush
	mov	BYTE PTR _last_layer_takes_all$1$[ebp], 1
	jmp	SHORT $LN6@flush
$LN56@flush:
	mov	BYTE PTR _last_layer_takes_all$1$[ebp], 0

; 7010 :   if (using_slopes && (thresholds != NULL) && (thresholds[0] != 0))

	test	dl, dl
	je	SHORT $LN6@flush
	test	ebx, ebx
	je	SHORT $LN6@flush
	cmp	WORD PTR [ebx], 0
	je	SHORT $LN6@flush

; 7011 :     { // Update slopes with the new ones supplied by the caller
; 7012 :       // It is safe to update slope thresholds between incremental flushing
; 7013 :       // operations, but not to update layer size targets.
; 7014 :       for (n=0; n < num_layer_specs; n++)

	xor	edx, edx
	test	edi, edi
	jle	SHORT $LN6@flush
	npad	9
$LL108@flush:

; 7015 :         state->layer_thresholds[n] = thresholds[n];

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+296]
	mov	ax, WORD PTR [ebx+edx*2]
	mov	WORD PTR [ecx+edx*2], ax
	inc	edx
	cmp	edx, edi
	jl	SHORT $LL108@flush
$LN6@flush:

; 7016 :     }
; 7017 : 
; 7018 :   // Now for the simulation phase.
; 7019 :   state->reserved_layer_info_bytes = 0;
; 7020 :   if (record_in_comseg &&

	cmp	BYTE PTR _record_in_comseg$[ebp], 0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+360], 0
	je	SHORT $LN33@flush
	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx+343], 0
	jne	SHORT $LN33@flush
	cmp	BYTE PTR [ecx+225], 0
	je	SHORT $LN33@flush

; 7021 :       !(state->header_generated || !state->initial_fragment))
; 7022 :     state->set_reserved_layer_info_bytes(num_layer_specs);

	push	edi
	call	?set_reserved_layer_info_bytes@kd_codestream@@QAEXH@Z ; kd_codestream::set_reserved_layer_info_bytes
$LN33@flush:

; 7023 :   if (using_slopes)

	cmp	BYTE PTR _using_slopes$1$[ebp], 0
	je	$LN34@flush

; 7024 :     { // Use slope thresholds to generate the layers directly.
; 7025 :       bool have_constraints = (state->reslength_constraints_used &&

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+320], 0
	je	SHORT $LN58@flush
	cmp	BYTE PTR [eax+322], 0
	jne	SHORT $LN58@flush
	mov	al, 1
	jmp	SHORT $LN193@flush
$LN58@flush:
	xor	al, al
$LN193@flush:

; 7026 :                                !state->reslength_warning_issued);
; 7027 :       kdu_long header_bytes, total_bytes = 0;
; 7028 :       for (n=0; n < num_layer_specs; n++)

	xor	ecx, ecx
	mov	BYTE PTR _have_constraints$1$[ebp], al
	mov	DWORD PTR _n$3$[ebp], ecx
	xorps	xmm0, xmm0
	movlpd	QWORD PTR _total_bytes$6[ebp], xmm0
	test	edi, edi
	jle	$LN35@flush
	mov	ebx, DWORD PTR _total_bytes$6[ebp+4]
	mov	edx, DWORD PTR _total_bytes$6[ebp]
	mov	DWORD PTR _total_bytes$2$[ebp], ebx
	mov	DWORD PTR _total_bytes$1$[ebp], edx
	npad	7
$LL10@flush:

; 7029 :         {
; 7030 :           bool last_layer = (n == (num_layer_specs-1));

	lea	edx, DWORD PTR [edi-1]
	cmp	ecx, edx
	sete	BYTE PTR _last_layer$7[ebp]

; 7031 :           if (have_constraints)

	test	al, al
	je	$LN186@flush

; 7032 :             { // Use a simple bisection search for the slope threshold
; 7033 :               int best_threshold = -1;
; 7034 :               int min_threshold = state->layer_thresholds[n];

	mov	edx, DWORD PTR [esi]
	or	edi, -1
	mov	DWORD PTR _best_threshold$1$[ebp], edi

; 7035 :               int lim_threshold = (1<<16);

	mov	ebx, 65536				; 00010000H
	mov	edi, DWORD PTR [edx+296]
	movzx	eax, WORD PTR [edi+ecx*2]
	mov	DWORD PTR _min_threshold$1$[ebp], eax

; 7036 :               if (n > 0)

	test	ecx, ecx
	jle	SHORT $LL13@flush

; 7037 :                 lim_threshold = state->layer_thresholds[n-1]+1;

	movzx	ebx, WORD PTR [edi+ecx*2-2]
	inc	ebx
$LL13@flush:

; 7038 :               do {
; 7039 :                   int threshold = (min_threshold+lim_threshold)>>1;
; 7040 :                   assert(threshold < (1<<16));
; 7041 :                   state->reslength_constraints_violated = false;
; 7042 :                   state->simulate_output(header_bytes,n,(kdu_uint16)threshold,

	push	0
	push	1048576					; 00100000H
	push	0
	push	DWORD PTR _last_layer$7[ebp]
	lea	edi, DWORD PTR [ebx+eax]
	mov	BYTE PTR [edx+321], 0
	push	0
	sar	edi, 1
	lea	eax, DWORD PTR _header_bytes$5[ebp]
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	eax
	call	?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z ; kd_codestream::simulate_output

; 7043 :                                          false,last_layer);
; 7044 :                   if (state->reslength_constraints_violated)

	mov	edx, DWORD PTR [esi]
	cmp	BYTE PTR [edx+321], 0
	je	SHORT $LN38@flush

; 7045 :                     min_threshold = threshold+1;

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR _min_threshold$1$[ebp], eax

; 7046 :                   else

	jmp	SHORT $LN11@flush
$LN38@flush:
	mov	eax, DWORD PTR _min_threshold$1$[ebp]

; 7047 :                     {
; 7048 :                       best_threshold = threshold; // Best so far
; 7049 :                       lim_threshold = threshold;

	mov	ebx, edi
	mov	DWORD PTR _best_threshold$1$[ebp], edi
$LN11@flush:

; 7050 :                     }
; 7051 :                 } while (lim_threshold > min_threshold);

	mov	ecx, DWORD PTR _n$3$[ebp]
	cmp	ebx, eax
	jg	SHORT $LL13@flush

; 7052 :               if (best_threshold < 0)

	mov	edi, DWORD PTR _best_threshold$1$[ebp]
	test	edi, edi
	jns	$LN40@flush

; 7053 :                 { KDU_WARNING_DEV(w,0x11110800); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$2[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$2[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	OFFSET ??_C@_0KM@DJNDCKID@Unable?5to?5find?5modified?5distorti@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7053 :                 { KDU_WARNING_DEV(w,0x11110800); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7058 :                   state->reslength_warning_issued = true;

	mov	eax, DWORD PTR [esi]

; 7059 :                 }

	lea	ecx, DWORD PTR _w$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	BYTE PTR [eax+322], 1
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning

; 7060 :               else

	mov	edi, DWORD PTR _num_layer_specs$[ebp]
	mov	ebx, DWORD PTR _total_bytes$2$[ebp]
$LN186@flush:
	mov	edx, DWORD PTR _n$3$[ebp]
$LN41@flush:

; 7062 :             }
; 7063 :           kdu_uint16 thresh = state->layer_thresholds[n];

	mov	ecx, DWORD PTR [esi]

; 7064 :           total_bytes +=

	push	0
	push	1048576					; 00100000H
	push	0
	push	DWORD PTR _last_layer$7[ebp]
	mov	eax, DWORD PTR [ecx+296]
	push	1
	movzx	eax, WORD PTR [eax+edx*2]
	push	eax
	push	edx
	lea	eax, DWORD PTR _header_bytes$5[ebp]
	push	eax
	call	?simulate_output@kd_codestream@@QAE_JAA_JHG_N1_JPA_J@Z ; kd_codestream::simulate_output
	add	DWORD PTR _total_bytes$1$[ebp], eax

; 7065 :             state->simulate_output(header_bytes,n,thresh,true,last_layer);
; 7066 :           state->layer_targets[n] = total_bytes;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _n$3$[ebp]
	adc	ebx, edx
	mov	edx, DWORD PTR _total_bytes$1$[ebp]
	mov	DWORD PTR _total_bytes$2$[ebp], ebx
	mov	eax, DWORD PTR [eax+292]
	mov	DWORD PTR [eax+ecx*8], edx
	mov	DWORD PTR [eax+ecx*8+4], ebx
	inc	ecx
	mov	al, BYTE PTR _have_constraints$1$[ebp]
	mov	DWORD PTR _n$3$[ebp], ecx
	cmp	ecx, edi
	jl	$LL10@flush

; 7067 :         }
; 7068 :     }
; 7069 :   else

	jmp	SHORT $LN35@flush
$LN40@flush:

; 7061 :                 state->layer_thresholds[n] = (kdu_uint16) best_threshold;

	mov	eax, DWORD PTR [edx+296]
	mov	edx, DWORD PTR _n$3$[ebp]
	mov	ebx, DWORD PTR _total_bytes$2$[ebp]
	mov	WORD PTR [eax+edx*2], di
	mov	edi, DWORD PTR _num_layer_specs$[ebp]
	jmp	SHORT $LN41@flush
$LN34@flush:

; 7070 :     { // Use layer targets.
; 7071 :       if (trim_to_rate)

	mov	cl, BYTE PTR _trim_to_rate$[ebp]
	test	cl, cl
	je	SHORT $LN185@flush

; 7072 :         { // First check to see if we are allowed to trim to the exact rate yet
; 7073 :           if (state->reslength_constraints_used)

	mov	eax, DWORD PTR [esi]
	movzx	ebx, cl
	xor	ecx, ecx
	cmp	BYTE PTR [eax+320], cl
	cmovne	ebx, ecx

; 7074 :             trim_to_rate = false;
; 7075 :           kd_global_rescomp *rc = state->global_rescomps;

	mov	ecx, DWORD PTR [eax+276]

; 7076 :           for (n=state->num_components*33; (n > 0) && trim_to_rate; n--, rc++)

	mov	eax, DWORD PTR [eax+112]
	mov	edx, eax
	shl	edx, 5
	add	edx, eax
	mov	BYTE PTR _trim_to_rate$[ebp], bl
	test	edx, edx
	jle	SHORT $LN185@flush

; 7074 :             trim_to_rate = false;
; 7075 :           kd_global_rescomp *rc = state->global_rescomps;

	add	ecx, 40					; 00000028H
$LL16@flush:

; 7076 :           for (n=state->num_components*33; (n > 0) && trim_to_rate; n--, rc++)

	test	bl, bl
	je	SHORT $LN185@flush

; 7077 :             if (rc->ready_area < rc->remaining_area)

	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR [ecx+4]
	jg	SHORT $LN14@flush
	jl	SHORT $LN166@flush
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [ecx]
	jae	SHORT $LN14@flush
$LN166@flush:

; 7078 :               trim_to_rate = false;

	xor	bl, bl
	mov	BYTE PTR _trim_to_rate$[ebp], bl
$LN14@flush:

; 7076 :           for (n=state->num_components*33; (n > 0) && trim_to_rate; n--, rc++)

	dec	edx
	add	ecx, 80					; 00000050H
	test	edx, edx
	jg	SHORT $LL16@flush
$LN185@flush:

; 7079 :         }
; 7080 :       state->pcrd_opt(trim_to_rate,tolerance);

	movsd	xmm0, QWORD PTR _tolerance$[ebp]
	sub	esp, 8
	mov	ecx, DWORD PTR [esi]
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR _trim_to_rate$[ebp]
	call	?pcrd_opt@kd_codestream@@QAEX_NN@Z	; kd_codestream::pcrd_opt
$LN35@flush:

; 7081 :     }
; 7082 : 
; 7083 :   // Generate the code-stream
; 7084 :   if (state->reserved_layer_info_bytes && state->initial_fragment &&

	mov	ecx, DWORD PTR [esi]
	cmp	DWORD PTR [ecx+360], 0
	je	SHORT $LN45@flush
	cmp	BYTE PTR [ecx+225], 0
	je	SHORT $LN45@flush
	cmp	BYTE PTR [ecx+343], 0
	jne	SHORT $LN45@flush

; 7085 :       !state->header_generated)
; 7086 :     state->gen_layer_info_comment(num_layer_specs,state->layer_targets,

	push	DWORD PTR [ecx+296]
	push	DWORD PTR [ecx+292]
	push	edi
	call	?gen_layer_info_comment@kd_codestream@@QAEXHPA_JPAG@Z ; kd_codestream::gen_layer_info_comment
$LN45@flush:

; 7087 :                                   state->layer_thresholds);
; 7088 :   state->generate_codestream(num_layer_specs);

	mov	ecx, DWORD PTR [esi]
	push	edi
	call	?generate_codestream@kd_codestream@@QAE_NH@Z ; kd_codestream::generate_codestream

; 7089 : 
; 7090 :   // Write results back to user-supplied arrays if available
; 7091 :   if (thresholds != NULL)

	mov	edx, DWORD PTR _thresholds$[ebp]
	test	edx, edx
	je	SHORT $LN18@flush

; 7092 :     for (n=0; n < num_layer_specs; n++)

	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN18@flush
$LL110@flush:

; 7093 :       thresholds[n] = state->layer_thresholds[n];

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+296]
	mov	ax, WORD PTR [eax+ecx*2]
	mov	WORD PTR [edx+ecx*2], ax
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LL110@flush
$LN18@flush:

; 7094 :   if (layer_bytes != NULL)

	cmp	DWORD PTR _layer_bytes$[ebp], 0
	je	SHORT $LN21@flush

; 7095 :     {
; 7096 :       kdu_long generated_bytes=0;
; 7097 :       for (n=0; n < num_layer_specs; n++)

	xorps	xmm0, xmm0
	xor	ecx, ecx
	movlpd	QWORD PTR _generated_bytes$9[ebp], xmm0
	test	edi, edi
	jle	SHORT $LN21@flush
	mov	edx, DWORD PTR _generated_bytes$9[ebp+4]
	mov	ebx, DWORD PTR _generated_bytes$9[ebp]
$LL112@flush:

; 7098 :         layer_bytes[n] = (generated_bytes += state->layer_sizes[n]);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+288]
	add	ebx, DWORD PTR [eax+ecx*8]
	adc	edx, DWORD PTR [eax+ecx*8+4]
	mov	eax, DWORD PTR _layer_bytes$[ebp]
	mov	DWORD PTR [eax+ecx*8], ebx
	mov	DWORD PTR [eax+ecx*8+4], edx
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LL112@flush
$LN21@flush:

; 7099 :     }
; 7100 : 
; 7101 :   // Update arrays
; 7102 :   if (!using_slopes)

	cmp	BYTE PTR _using_slopes$1$[ebp], 0
	jne	$LN24@flush

; 7103 :     for (n=0; n < num_layer_specs; n++)

	xor	ebx, ebx
	test	edi, edi
	jle	SHORT $LN24@flush
	cmp	edi, 8
	jb	SHORT $LN115@flush

; 7104 :       state->layer_thresholds[n] = 0;

	mov	eax, DWORD PTR [esi]
	add	eax, 296				; 00000128H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv1172[ebp], ecx
	lea	edx, DWORD PTR [ecx-2]
	lea	edx, DWORD PTR [edx+edi*2]
	cmp	ecx, esi
	ja	SHORT $LN116@flush
	cmp	edx, esi
	jae	SHORT $LN115@flush
$LN116@flush:
	cmp	ecx, eax
	ja	SHORT $LN117@flush
	cmp	edx, eax
	jae	SHORT $LN115@flush
$LN117@flush:
	mov	eax, edi
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN191@flush
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN191@flush:
	sub	edi, eax
$LL25@flush:

; 7103 :     for (n=0; n < num_layer_specs; n++)

	add	ebx, 8
	cmp	ebx, edi
	jl	SHORT $LL25@flush

; 7104 :       state->layer_thresholds[n] = 0;

	lea	eax, DWORD PTR [edi+7]
	mov	edi, DWORD PTR tv1172[ebp]
	cdq
	and	edx, 7
	lea	ecx, DWORD PTR [edx+eax]
	xor	eax, eax
	sar	ecx, 3
	shl	ecx, 4
	shr	ecx, 1
	shr	ecx, 1
	rep stosd
	adc	ecx, ecx
	rep stosw
	mov	edi, DWORD PTR _num_layer_specs$[ebp]
$LN115@flush:

; 7103 :     for (n=0; n < num_layer_specs; n++)

	cmp	ebx, edi
	jge	SHORT $LN24@flush
$LL114@flush:

; 7104 :       state->layer_thresholds[n] = 0;

	mov	eax, DWORD PTR [esi]
	xor	ecx, ecx
	mov	eax, DWORD PTR [eax+296]
	mov	WORD PTR [eax+ebx*2], cx
	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LL114@flush
$LN24@flush:

; 7105 :   if (last_layer_takes_all)

	cmp	BYTE PTR _last_layer_takes_all$1$[ebp], 0
	je	SHORT $LN49@flush

; 7106 :     { // Make sure next incremental call to flush not limited by current size
; 7107 :       state->layer_targets[num_layer_specs-1] = 0;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+292]
	mov	DWORD PTR [eax+edi*8-8], 0
	mov	DWORD PTR [eax+edi*8-4], 0
$LN49@flush:

; 7108 :     }
; 7109 : 
; 7110 :   if (env != NULL)

	mov	eax, DWORD PTR _env$[ebp]
	test	eax, eax
	je	SHORT $LN81@flush
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [eax+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN81@flush
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN81@flush:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 7112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN192@flush:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z$0:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z$1:
	lea	ecx, DWORD PTR _w$3[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z$2:
	lea	ecx, DWORD PTR _w$2[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__ehhandler$?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?flush@kdu_codestream@@QAEXPA_JHPAG_N2NPAVkdu_thread_env@@@Z ENDP ; kdu_codestream::flush
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?add_comment@kdu_codestream@@QAE?AVkdu_codestream_comment@@XZ
_TEXT	SEGMENT
$T1 = 8							; size = 4
___$ReturnUdt$ = 8					; size = 4
?add_comment@kdu_codestream@@QAE?AVkdu_codestream_comment@@XZ PROC ; kdu_codestream::add_comment, COMDAT
; _this$ = ecx

; 6939 : {

	push	ebp
	mov	ebp, esp
	push	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 465  :     kdu_codestream_comment() { state = NULL; }

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6939 : {

	mov	edi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 465  :     kdu_codestream_comment() { state = NULL; }

	mov	DWORD PTR [esi], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6941 :   if (state != NULL)

	cmp	DWORD PTR [edi], 0
	je	SHORT $LN13@add_commen

; 6943 :       result.state = new kd_codestream_comment;

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], edx
	test	edx, edx
	je	SHORT $LN6@add_commen
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1467 :       { readonly=false; max_chars=num_chars=0; text_buf=NULL; next=NULL; }

	mov	BYTE PTR [edx], 0
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+4], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6943 :       result.state = new kd_codestream_comment;

	jmp	SHORT $LN7@add_commen
$LN6@add_commen:
	xor	edx, edx
$LN7@add_commen:

; 6944 :       if (state->comtail == NULL)

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], edx
	mov	ecx, DWORD PTR [eax+48]
	test	ecx, ecx
	jne	SHORT $LN3@add_commen

; 6945 :         state->comhead = state->comtail = result.state;

	mov	DWORD PTR [eax+48], edx
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+44], edx

; 6949 :     }
; 6950 :   return result;

	mov	eax, esi
	mov	ecx, DWORD PTR [edi]
	pop	edi
	mov	ecx, DWORD PTR [ecx+48]
	mov	DWORD PTR [esi], ecx
	pop	esi

; 6951 : }

	pop	ebp
	ret	4
$LN3@add_commen:

; 6946 :       else
; 6947 :         state->comtail = state->comtail->next = result.state;

	mov	DWORD PTR [ecx+16], edx
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ecx+48], edx

; 6948 :       result.state = state->comtail;

	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+48]
	mov	DWORD PTR [esi], ecx
$LN13@add_commen:

; 6949 :     }
; 6950 :   return result;

	pop	edi
	mov	eax, esi
	pop	esi

; 6951 : }

	pop	ebp
	ret	4
?add_comment@kdu_codestream@@QAE?AVkdu_codestream_comment@@XZ ENDP ; kdu_codestream::add_comment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_comment@kdu_codestream@@QAE?AVkdu_codestream_comment@@V2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_prev$ = 12						; size = 4
?get_comment@kdu_codestream@@QAE?AVkdu_codestream_comment@@V2@@Z PROC ; kdu_codestream::get_comment, COMDAT
; _this$ = ecx

; 6922 : {

	push	ebp
	mov	ebp, esp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 465  :     kdu_codestream_comment() { state = NULL; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6924 :   if (state != NULL)

	mov	ecx, DWORD PTR [ecx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 465  :     kdu_codestream_comment() { state = NULL; }

	mov	DWORD PTR [eax], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6924 :   if (state != NULL)

	test	ecx, ecx
	je	SHORT $LN3@get_commen

; 6925 :     {
; 6926 :       result.state = state->comhead;

	mov	ecx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax], ecx

; 6927 :       if (prev.state != NULL)

	mov	ecx, DWORD PTR _prev$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@get_commen

; 6928 :         result.state = prev.state->next;

	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax], ecx
$LN3@get_commen:

; 6929 :     }
; 6930 :   return result;
; 6931 : }

	pop	ebp
	ret	8
?get_comment@kdu_codestream@@QAE?AVkdu_codestream_comment@@V2@@Z ENDP ; kdu_codestream::get_comment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?open_tile@kdu_codestream@@QAE?AVkdu_tile@@Ukdu_coords@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_e$2 = -36						; size = 20
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_tile_idx$ = 12						; size = 8
$T3 = 20						; size = 4
_env$ = 20						; size = 4
?open_tile@kdu_codestream@@QAE?AVkdu_tile@@Ukdu_coords@@PAVkdu_thread_env@@@Z PROC ; kdu_codestream::open_tile, COMDAT
; _this$ = ecx

; 6879 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?open_tile@kdu_codestream@@QAE?AVkdu_tile@@Ukdu_coords@@PAVkdu_thread_env@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi

; 6880 :   if (env != NULL)

	mov	ebx, DWORD PTR _env$[ebp]
	test	ebx, ebx
	je	SHORT $LN14@open_tile
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [ebx+28]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN13@open_tile
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T3[ebp], eax
	lea	eax, DWORD PTR $T3[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN47@open_tile:
$LN13@open_tile:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN17@open_tile
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN17@open_tile:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+4], ebx
$LN14@open_tile:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6882 :   state->tiles_accessed = true;

	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+340], 1

; 6883 :   if (!state->construction_finalized)

	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx+341], 0
	jne	SHORT $LN3@open_tile

; 6884 :     state->finalize_construction();

	call	?finalize_construction@kd_codestream@@QAEXXZ ; kd_codestream::finalize_construction
$LN3@open_tile:

; 6886 :   tile_idx.from_apparent(state->transpose,state->vflip,state->hflip);

	mov	esi, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	mov	ebx, DWORD PTR _tile_idx$[ebp+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6886 :   tile_idx.from_apparent(state->transpose,state->vflip,state->hflip);

	mov	al, BYTE PTR [esi+331]
	mov	cl, BYTE PTR [esi+330]
	mov	dl, BYTE PTR [esi+329]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	test	al, al
	je	SHORT $LN23@open_tile
	neg	ebx
	mov	DWORD PTR _tile_idx$[ebp+4], ebx
$LN23@open_tile:

; 267  :         y=(vflip)?(-y):y;

	mov	edi, DWORD PTR _tile_idx$[ebp]
	test	cl, cl
	je	SHORT $LN25@open_tile
	neg	edi
	mov	DWORD PTR _tile_idx$[ebp], edi
$LN25@open_tile:

; 268  :         if (transp) transpose();

	test	dl, dl
	je	SHORT $LN21@open_tile

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, edi
	mov	edi, ebx
	mov	ebx, eax
	mov	DWORD PTR _tile_idx$[ebp], edi
	mov	DWORD PTR _tile_idx$[ebp+4], ebx
$LN21@open_tile:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6894 :     rel_idx.x + rel_idx.y*state->tile_indices.size.x;

	mov	ecx, DWORD PTR [esi+184]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	eax, edi
	sub	eax, DWORD PTR [esi+172]
	mov	edx, ebx
	sub	edx, DWORD PTR [esi+176]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6894 :     rel_idx.x + rel_idx.y*state->tile_indices.size.x;

	imul	ecx, eax
	mov	eax, DWORD PTR [esi+264]
	add	ecx, edx
	lea	ecx, DWORD PTR [ecx+ecx*2]

; 6895 :   kd_tile *tp = tref->tile;

	mov	esi, DWORD PTR [eax+ecx*4+8]

; 6896 : 
; 6897 :   if (tp == NULL)

	test	esi, esi
	jne	SHORT $LN4@open_tile

; 6898 :     tp = state->create_tile(tile_idx);

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	ebx
	push	edi
	mov	ecx, DWORD PTR [ecx]
	call	?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z ; kd_codestream::create_tile
	mov	esi, eax
	jmp	SHORT $LN6@open_tile
$LN4@open_tile:

; 6899 :   else if ((tp != KD_EXPIRED_TILE) && tp->needs_reinit)

	cmp	esi, -1
	je	SHORT $LN8@open_tile
	cmp	BYTE PTR [esi+234], 0
	je	SHORT $LN6@open_tile

; 6900 :     { // We must have restarted the code-stream, since the tile was created
; 6901 :       assert(state->allow_restart && (tref->tpart_head == NULL));
; 6902 :       tp->reinitialize();

	mov	ecx, esi
	call	?reinitialize@kd_tile@@QAEXXZ		; kd_tile::reinitialize
$LN6@open_tile:

; 6903 :     }
; 6904 :   if ((tp == KD_EXPIRED_TILE) || tp->closed)

	cmp	esi, -1
	je	SHORT $LN8@open_tile
	cmp	BYTE PTR [esi+232], 0
	je	SHORT $LN7@open_tile
$LN8@open_tile:

; 6905 :     { KDU_ERROR_DEV(e,58); e << 

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EI@FINBMEOC@Attempting?5to?5access?5a?5tile?5whic@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6905 :     { KDU_ERROR_DEV(e,58); e << 

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6908 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN7@open_tile:

; 6909 :   assert(tp->tile_ref == tref);
; 6910 :   tp->open();

	mov	ecx, esi
	call	?open@kd_tile@@QAEXXZ			; kd_tile::open

; 6911 :   if (env != NULL)

	mov	eax, DWORD PTR _env$[ebp]
	test	eax, eax
	je	SHORT $LN39@open_tile
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [eax+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN39@open_tile
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN39@open_tile:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 3456 :     kdu_tile(kd_tile *state) { this->state = state; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6914 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN46@open_tile:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open_tile@kdu_codestream@@QAE?AVkdu_tile@@Ukdu_coords@@PAVkdu_thread_env@@@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?open_tile@kdu_codestream@@QAE?AVkdu_tile@@Ukdu_coords@@PAVkdu_thread_env@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?open_tile@kdu_codestream@@QAE?AVkdu_tile@@Ukdu_coords@@PAVkdu_thread_env@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?open_tile@kdu_codestream@@QAE?AVkdu_tile@@Ukdu_coords@@PAVkdu_thread_env@@@Z ENDP ; kdu_codestream::open_tile
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_block_truncation@kdu_codestream@@QAEXH@Z
_TEXT	SEGMENT
_factor$ = 8						; size = 4
?set_block_truncation@kdu_codestream@@QAEXH@Z PROC	; kdu_codestream::set_block_truncation, COMDAT
; _this$ = ecx

; 6458 : {

	push	ebp
	mov	ebp, esp

; 6459 :   if (factor < 0)

	mov	eax, DWORD PTR _factor$[ebp]
	xor	edx, edx

; 6460 :     factor = 0;
; 6461 :   if (state != NULL)

	mov	ecx, DWORD PTR [ecx]
	test	eax, eax
	cmovs	eax, edx
	test	ecx, ecx
	je	SHORT $LN3@set_block_

; 6462 :     state->block_truncation_factor = factor;

	mov	DWORD PTR [ecx+344], eax
$LN3@set_block_:

; 6463 : }

	pop	ebp
	ret	4
?set_block_truncation@kdu_codestream@@QAEXH@Z ENDP	; kdu_codestream::set_block_truncation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?change_appearance@kdu_codestream@@QAEX_N00@Z
_TEXT	SEGMENT
_e$2 = -52						; size = 20
_e$3 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_transpose$ = 8						; size = 1
_vflip$ = 12						; size = 1
_hflip$ = 16						; size = 1
?change_appearance@kdu_codestream@@QAEX_N00@Z PROC	; kdu_codestream::change_appearance, COMDAT
; _this$ = ecx

; 6432 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?change_appearance@kdu_codestream@@QAEX_N00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 6433 :   if (state->tiles_accessed)

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+340], 0
	je	SHORT $LN4@change_app

; 6434 :     {
; 6435 :       if (state->num_open_tiles != 0)

	cmp	DWORD PTR [eax+204], 0
	je	SHORT $LN3@change_app

; 6436 :         { KDU_ERROR_DEV(e,56); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0FL@KCCGCDMA@You?5may?5change?5the?5apparent?5geom@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6436 :         { KDU_ERROR_DEV(e,56); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6439 :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN3@change_app:

; 6440 :       if (state->tiles_accessed && !state->persistent)

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+340], 0
	je	SHORT $LN4@change_app
	cmp	BYTE PTR [eax+337], 0
	jne	SHORT $LN4@change_app

; 6441 :         { KDU_ERROR_DEV(e,57); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0JC@LBCJLKIB@You?5may?5not?5change?5the?5apparent?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6441 :         { KDU_ERROR_DEV(e,57); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6445 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN4@change_app:

; 6446 :     }
; 6447 :   state->transpose = transpose;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR _transpose$[ebp]
	mov	BYTE PTR [ecx+329], al

; 6448 :   state->vflip = vflip;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR _vflip$[ebp]
	mov	BYTE PTR [ecx+330], al

; 6449 :   state->hflip = hflip;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR _hflip$[ebp]
	mov	BYTE PTR [ecx+331], al

; 6450 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?change_appearance@kdu_codestream@@QAEX_N00@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?change_appearance@kdu_codestream@@QAEX_N00@Z$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?change_appearance@kdu_codestream@@QAEX_N00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?change_appearance@kdu_codestream@@QAEX_N00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?change_appearance@kdu_codestream@@QAEX_N00@Z ENDP	; kdu_codestream::change_appearance
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?apply_input_restrictions@kdu_codestream@@QAEXHPAHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z
_TEXT	SEGMENT
_num_components$ = 8					; size = 4
_component_indices$ = 12				; size = 4
_discard_levels$ = 16					; size = 4
_max_layers$ = 20					; size = 4
tv461 = 24						; size = 4
tv459 = 24						; size = 4
_region_of_interest$ = 24				; size = 4
_apparent_idx$2$ = 28					; size = 4
_apparent_idx$1$ = 28					; size = 4
_access_mode$ = 28					; size = 4
?apply_input_restrictions@kdu_codestream@@QAEXHPAHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z PROC ; kdu_codestream::apply_input_restrictions, COMDAT
; _this$ = ecx

; 6372 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 6373 :   int c, apparent_idx;
; 6374 : 
; 6375 :   // Start by setting up everything except components, by calling the
; 6376 :   // first form of the function
; 6377 :   apply_input_restrictions(0,0,discard_levels,max_layers,region_of_interest,

	mov	edi, DWORD PTR _access_mode$[ebp]
	mov	esi, ecx
	push	edi
	push	DWORD PTR _region_of_interest$[ebp]
	push	DWORD PTR _max_layers$[ebp]
	push	DWORD PTR _discard_levels$[ebp]
	push	0
	push	0
	call	?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z ; kdu_codestream::apply_input_restrictions

; 6378 :                            access_mode);
; 6379 :   if (access_mode == KDU_WANT_CODESTREAM_COMPONENTS)

	cmp	edi, 1
	jne	$LN14@apply_inpu

; 6380 :     { // In this case, we have only to configure any special restrictions on
; 6381 :       // the codestream image components.  Everything else has already been
; 6382 :       // done for us by the first form of the function.
; 6383 :       for (c=0; c < state->num_components; c++)

	mov	eax, DWORD PTR [esi]
	xor	edx, edx
	cmp	DWORD PTR [eax+112], edx
	jle	SHORT $LN3@apply_inpu
	xor	ecx, ecx
$LL4@apply_inpu:

; 6384 :         {
; 6385 :           state->comp_info[c].from_apparent = NULL;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+96]
	inc	edx
	mov	eax, DWORD PTR [eax+256]
	mov	DWORD PTR [eax+ecx-4], 0

; 6386 :           state->comp_info[c].apparent_idx = -1;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+256]
	mov	DWORD PTR [eax+ecx-8], -1
	mov	eax, DWORD PTR [esi]
	cmp	edx, DWORD PTR [eax+112]
	jl	SHORT $LL4@apply_inpu
$LN3@apply_inpu:

; 6387 :         }
; 6388 :       state->num_apparent_components = num_components;

	mov	eax, DWORD PTR [esi]

; 6389 :       for (c=apparent_idx=0; c < num_components; c++)

	xor	edx, edx
	mov	ecx, DWORD PTR _num_components$[ebp]
	mov	DWORD PTR _apparent_idx$1$[ebp], 0
	mov	DWORD PTR [eax+116], ecx
	test	ecx, ecx
	jle	$LN12@apply_inpu

; 6387 :         }
; 6388 :       state->num_apparent_components = num_components;

	mov	DWORD PTR tv461[ebp], edx
	npad	7
$LL7@apply_inpu:

; 6390 :         {
; 6391 :           int idx = component_indices[c];

	mov	eax, DWORD PTR _component_indices$[ebp]

; 6392 :           if ((idx >= state->num_components) || (c >= state->num_components) ||

	mov	ebx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ebx+112]
	cmp	ecx, eax
	jge	SHORT $LN5@apply_inpu
	cmp	edx, eax
	jge	SHORT $LN5@apply_inpu
	mov	eax, DWORD PTR [ebx+256]
	lea	edi, DWORD PTR [ecx+ecx*2]
	shl	edi, 5
	cmp	DWORD PTR [eax+edi+88], 0
	jge	SHORT $LN5@apply_inpu

; 6393 :               (state->comp_info[idx].apparent_idx >= 0))
; 6394 :             continue;
; 6395 :           state->comp_info[idx].apparent_idx = apparent_idx;

	mov	ebx, DWORD PTR _apparent_idx$1$[ebp]
	mov	DWORD PTR [eax+edi+88], ebx

; 6396 :           state->comp_info[apparent_idx].from_apparent = state->comp_info+idx;
; 6397 :           apparent_idx++;

	inc	ebx
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _apparent_idx$1$[ebp], ebx
	mov	ecx, DWORD PTR [eax+256]
	lea	eax, DWORD PTR [ecx+edi]
	mov	edi, DWORD PTR tv461[ebp]
	mov	DWORD PTR [edi+ecx+92], eax
	add	edi, 96					; 00000060H
	mov	DWORD PTR tv461[ebp], edi
$LN5@apply_inpu:

; 6389 :       for (c=apparent_idx=0; c < num_components; c++)

	inc	edx
	cmp	edx, DWORD PTR _num_components$[ebp]
	jl	SHORT $LL7@apply_inpu
	pop	edi
	pop	esi
	pop	ebx

; 6420 :         }
; 6421 :     }
; 6422 :   else
; 6423 :     assert(0);
; 6424 : }

	pop	ebp
	ret	24					; 00000018H
$LN14@apply_inpu:

; 6398 :         }
; 6399 :     }
; 6400 :   else if (access_mode == KDU_WANT_OUTPUT_COMPONENTS)

	test	edi, edi
	jne	$LN12@apply_inpu

; 6401 :     { // Restrictions have already been removed on codestream image
; 6402 :       // components, so all we have to do here is apply/remove restrictions
; 6403 :       // on the output image components.
; 6404 :       for (c=0; c < state->num_output_components; c++)

	mov	eax, DWORD PTR [esi]
	xor	edx, edx
	cmp	DWORD PTR [eax+120], edx
	jle	SHORT $LN9@apply_inpu
	xor	ecx, ecx
	npad	7
$LL10@apply_inpu:

; 6405 :         {
; 6406 :           state->output_comp_info[c].from_apparent = 0;

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+40]
	inc	edx
	mov	eax, DWORD PTR [eax+260]
	mov	DWORD PTR [eax+ecx-24], 0

; 6407 :           state->output_comp_info[c].apparent_idx = -1;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+260]
	mov	DWORD PTR [eax+ecx-28], -1
	mov	eax, DWORD PTR [esi]
	cmp	edx, DWORD PTR [eax+120]
	jl	SHORT $LL10@apply_inpu
$LN9@apply_inpu:

; 6408 :         }
; 6409 :       state->num_apparent_output_components = num_components;

	mov	eax, DWORD PTR [esi]

; 6410 :       for (c=apparent_idx=0; c < num_components; c++)

	xor	edx, edx
	mov	ebx, DWORD PTR _num_components$[ebp]
	mov	DWORD PTR _apparent_idx$2$[ebp], 0
	mov	DWORD PTR [eax+124], ebx
	test	ebx, ebx
	jle	SHORT $LN12@apply_inpu

; 6408 :         }
; 6409 :       state->num_apparent_output_components = num_components;

	mov	DWORD PTR tv459[ebp], edx
$LL13@apply_inpu:

; 6411 :         {
; 6412 :           int idx = component_indices[c];

	mov	eax, DWORD PTR _component_indices$[ebp]

; 6413 :           if ((idx >= state->num_output_components) ||
; 6414 :               (c >= state->num_output_components) ||

	mov	ebx, DWORD PTR [esi]
	mov	edi, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ebx+120]
	cmp	edi, eax
	jge	SHORT $LN11@apply_inpu
	cmp	edx, eax
	jge	SHORT $LN11@apply_inpu
	mov	eax, DWORD PTR [ebx+260]
	lea	ecx, DWORD PTR [edi+edi*4]
	cmp	DWORD PTR [eax+ecx*8+12], 0
	lea	eax, DWORD PTR [eax+ecx*8]
	jge	SHORT $LN11@apply_inpu

; 6415 :               (state->output_comp_info[idx].apparent_idx >= 0))
; 6416 :             continue;
; 6417 :           state->output_comp_info[idx].apparent_idx = apparent_idx;

	mov	ecx, DWORD PTR _apparent_idx$2$[ebp]

; 6418 :           state->output_comp_info[apparent_idx].from_apparent = idx;

	mov	ebx, DWORD PTR tv459[ebp]
	mov	DWORD PTR [eax+12], ecx

; 6419 :           apparent_idx++;

	inc	ecx
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _apparent_idx$2$[ebp], ecx
	mov	eax, DWORD PTR [eax+260]
	mov	DWORD PTR [eax+ebx+16], edi
	add	ebx, 40					; 00000028H
	mov	DWORD PTR tv459[ebp], ebx
$LN11@apply_inpu:

; 6410 :       for (c=apparent_idx=0; c < num_components; c++)

	inc	edx
	cmp	edx, DWORD PTR _num_components$[ebp]
	jl	SHORT $LL13@apply_inpu
$LN12@apply_inpu:
	pop	edi
	pop	esi
	pop	ebx

; 6420 :         }
; 6421 :     }
; 6422 :   else
; 6423 :     assert(0);
; 6424 : }

	pop	ebp
	ret	24					; 00000018H
?apply_input_restrictions@kdu_codestream@@QAEXHPAHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z ENDP ; kdu_codestream::apply_input_restrictions
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z
_TEXT	SEGMENT
_e$2 = -52						; size = 20
_e$3 = -32						; size = 20
_e$4 = -32						; size = 20
_e$5 = -32						; size = 20
_e$6 = -32						; size = 20
$T7 = -28						; size = 16
__$EHRec$ = -12						; size = 12
tv614 = 8						; size = 4
_first_component$ = 8					; size = 4
_max_components$ = 12					; size = 4
_discard_levels$ = 16					; size = 4
_max_layers$ = 20					; size = 4
_region_of_interest$ = 24				; size = 4
_access_mode$ = 28					; size = 4
?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z PROC ; kdu_codestream::apply_input_restrictions, COMDAT
; _this$ = ecx

; 6263 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 6264 :   if (state->out != NULL)

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN11@apply_inpu

; 6265 :     { KDU_ERROR_DEV(e,52); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$6[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	OFFSET ??_C@_0IL@NFJOEHBJ@The?5?$GAkdu_codestream?3?3apply_input@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6265 :     { KDU_ERROR_DEV(e,52); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6269 :     }

	lea	ecx, DWORD PTR _e$6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN11@apply_inpu:

; 6270 :   if (state->tiles_accessed)

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+340], 0
	je	SHORT $LN14@apply_inpu

; 6271 :     {
; 6272 :       if (state->num_open_tiles != 0)

	cmp	DWORD PTR [eax+204], 0
	je	SHORT $LN13@apply_inpu

; 6273 :         { KDU_ERROR_DEV(e,53); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0GO@DAONBPDM@You?5may?5apply?5restrictions?5to?5th@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6273 :         { KDU_ERROR_DEV(e,53); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6277 :         }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN13@apply_inpu:

; 6278 :       if (state->tiles_accessed && !state->persistent)

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+340], 0
	je	SHORT $LN14@apply_inpu
	cmp	BYTE PTR [eax+337], 0
	jne	SHORT $LN14@apply_inpu

; 6279 :         { KDU_ERROR_DEV(e,54); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0KF@HPOIMBFL@You?5may?5not?5apply?5restrictions?5t@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6279 :         { KDU_ERROR_DEV(e,54); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6283 :         }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN14@apply_inpu:

; 6284 :     }
; 6285 : 
; 6286 :   state->discard_levels = discard_levels;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR _discard_levels$[ebp]
	mov	DWORD PTR [ecx+188], eax

; 6287 :   if (max_layers <= 0)

	mov	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _max_layers$[ebp]
	test	ecx, ecx
	cmovle	ecx, eax

; 6288 :     max_layers = 0xFFFF;
; 6289 :   state->max_apparent_layers = max_layers;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+196], ecx

; 6290 :   state->region = state->canvas;

	mov	eax, DWORD PTR [esi]
	movups	xmm0, XMMWORD PTR [eax+132]
	movups	XMMWORD PTR [eax+208], xmm0

; 6291 :   if (region_of_interest != NULL)

	mov	eax, DWORD PTR _region_of_interest$[ebp]
	test	eax, eax
	je	SHORT $LN16@apply_inpu

; 6292 :     state->region &= *region_of_interest;

	mov	ecx, DWORD PTR [esi]
	push	eax
	lea	eax, DWORD PTR $T7[ebp]
	add	ecx, 208				; 000000d0H
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=
$LN16@apply_inpu:

; 6293 :   state->unloadable_tile_scan = state->unloadable_tiles_head;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+392]
	mov	DWORD PTR [ecx+400], eax

; 6294 : 
; 6295 :   // Now process component restrictions.
; 6296 :   int c, from_idx;
; 6297 :   state->component_access_mode = access_mode;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _access_mode$[ebp]
	mov	DWORD PTR [eax+128], ecx

; 6298 :   if (access_mode == KDU_WANT_CODESTREAM_COMPONENTS)

	cmp	ecx, 1
	jne	$LN17@apply_inpu

; 6299 :     {
; 6300 :       if ((first_component < 0) || (first_component >= state->num_components))

	mov	edi, DWORD PTR _first_component$[ebp]
	test	edi, edi
	js	SHORT $LN20@apply_inpu
	mov	eax, DWORD PTR [esi]
	cmp	edi, DWORD PTR [eax+112]
	jl	SHORT $LN19@apply_inpu
$LN20@apply_inpu:

; 6301 :         { KDU_ERROR_DEV(e,55); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0HD@FCIAAPLI@The?5range?5of?5apparent?5image?5comp@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6301 :         { KDU_ERROR_DEV(e,55); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6304 :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN19@apply_inpu:

; 6305 :       state->num_apparent_output_components = 0;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+124], 0

; 6306 :            // Output components are inaccessible in codestream access mode
; 6307 :       state->num_apparent_components =

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+112]
	sub	eax, edi
	mov	DWORD PTR [ecx+116], eax

; 6308 :         state->num_components - first_component;
; 6309 :       if ((max_components > 0) &&

	mov	eax, DWORD PTR _max_components$[ebp]
	test	eax, eax
	jle	SHORT $LN21@apply_inpu
	mov	ecx, DWORD PTR [esi]
	cmp	eax, DWORD PTR [ecx+116]
	jge	SHORT $LN21@apply_inpu

; 6310 :           (max_components < state->num_apparent_components))
; 6311 :         state->num_apparent_components = max_components;

	mov	DWORD PTR [ecx+116], eax
$LN21@apply_inpu:

; 6312 :       for (c=from_idx=0; c < state->num_components; c++)

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+112], 0
	jle	$LN9@apply_inpu
	mov	edx, edi
	xor	ebx, ebx
	neg	edx
	xor	edi, edi
	npad	8
$LL4@apply_inpu:

; 6313 :         {
; 6314 :           kd_comp_info *ci = state->comp_info + c;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+256]
	add	ecx, edi

; 6315 :           ci->apparent_idx = c - first_component;

	mov	DWORD PTR [ecx+88], edx

; 6316 :           if (ci->apparent_idx >= state->num_apparent_components)

	mov	eax, DWORD PTR [esi]
	cmp	edx, DWORD PTR [eax+116]
	jl	SHORT $LN22@apply_inpu

; 6317 :             ci->apparent_idx = -1;

	mov	DWORD PTR [ecx+88], -1
$LN22@apply_inpu:

; 6318 :           ci->from_apparent = NULL;
; 6319 :           if (ci->apparent_idx >= 0)

	cmp	DWORD PTR [ecx+88], 0
	mov	DWORD PTR [ecx+92], 0
	jl	SHORT $LN2@apply_inpu

; 6320 :             state->comp_info[from_idx++].from_apparent = ci;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+256]
	mov	DWORD PTR [eax+ebx+92], ecx
	add	ebx, 96					; 00000060H
$LN2@apply_inpu:

; 6312 :       for (c=from_idx=0; c < state->num_components; c++)

	mov	eax, DWORD PTR [esi]
	inc	edx
	mov	ecx, DWORD PTR _first_component$[ebp]
	add	edi, 96					; 00000060H
	add	ecx, edx
	cmp	ecx, DWORD PTR [eax+112]
	jl	SHORT $LL4@apply_inpu

; 6357 :         }
; 6358 :     }
; 6359 :   else
; 6360 :     assert(0);
; 6361 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN17@apply_inpu:

; 6321 :         }
; 6322 :     }
; 6323 :   else if (access_mode == KDU_WANT_OUTPUT_COMPONENTS)

	test	ecx, ecx
	jne	$LN9@apply_inpu

; 6324 :     {
; 6325 :       // Start by removing any restrictions on the codestream components
; 6326 :       state->num_apparent_components = state->num_components;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+112]
	mov	DWORD PTR [ecx+116], eax

; 6327 :       for (c=0; c < state->num_components; c++)

	xor	ecx, ecx
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+112], ecx
	jle	SHORT $LN6@apply_inpu

; 6324 :     {
; 6325 :       // Start by removing any restrictions on the codestream components
; 6326 :       state->num_apparent_components = state->num_components;

	xor	edx, edx
	npad	10
$LL7@apply_inpu:

; 6328 :         {
; 6329 :           kd_comp_info *ci = state->comp_info + c;

	mov	eax, DWORD PTR [eax+256]
	add	eax, edx
	add	edx, 96					; 00000060H

; 6330 :           ci->apparent_idx = c;

	mov	DWORD PTR [eax+88], ecx
	inc	ecx

; 6331 :           ci->from_apparent = ci;

	mov	DWORD PTR [eax+92], eax
	mov	eax, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax+112]
	jl	SHORT $LL7@apply_inpu
$LN6@apply_inpu:

; 6332 :         }
; 6333 : 
; 6334 :       // Now is to apply/remove restrictions on the output image components.
; 6335 :       if ((first_component < 0) ||

	mov	edi, DWORD PTR _first_component$[ebp]
	test	edi, edi
	js	SHORT $LN27@apply_inpu
	mov	eax, DWORD PTR [esi]
	cmp	edi, DWORD PTR [eax+120]
	jl	SHORT $LN26@apply_inpu
$LN27@apply_inpu:

; 6337 :         { KDU_ERROR_DEV(e,0x05090500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0HK@LCIPMOP@The?5range?5of?5apparent?5output?5ima@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6337 :         { KDU_ERROR_DEV(e,0x05090500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6341 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN26@apply_inpu:

; 6342 : 
; 6343 :       state->num_apparent_output_components =

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+120]
	sub	eax, edi
	mov	DWORD PTR [ecx+124], eax

; 6344 :         state->num_output_components - first_component;
; 6345 :       if ((max_components > 0) &&

	mov	eax, DWORD PTR _max_components$[ebp]
	test	eax, eax
	jle	SHORT $LN28@apply_inpu
	mov	ecx, DWORD PTR [esi]
	cmp	eax, DWORD PTR [ecx+124]
	jge	SHORT $LN28@apply_inpu

; 6346 :           (max_components < state->num_apparent_output_components))
; 6347 :         state->num_apparent_output_components = max_components;

	mov	DWORD PTR [ecx+124], eax
$LN28@apply_inpu:

; 6348 :       for (c=from_idx=0; c < state->num_output_components; c++)

	mov	eax, DWORD PTR [esi]
	xor	edx, edx
	cmp	DWORD PTR [eax+120], edx
	jle	SHORT $LN9@apply_inpu
	neg	edi
	mov	DWORD PTR tv614[ebp], edx
	xor	ebx, ebx
	npad	4
$LL10@apply_inpu:

; 6349 :         {
; 6350 :           kd_output_comp_info *oci = state->output_comp_info + c;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+260]
	add	ecx, ebx

; 6351 :           oci->apparent_idx = c - first_component;

	mov	DWORD PTR [ecx+12], edi

; 6352 :           if (oci->apparent_idx >= state->num_apparent_output_components)

	mov	eax, DWORD PTR [esi]
	cmp	edi, DWORD PTR [eax+124]
	jl	SHORT $LN29@apply_inpu

; 6353 :             oci->apparent_idx = -1;

	mov	DWORD PTR [ecx+12], -1
$LN29@apply_inpu:

; 6354 :           oci->from_apparent = 0;
; 6355 :           if (oci->apparent_idx >= 0)

	cmp	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	jl	SHORT $LN8@apply_inpu

; 6356 :             state->output_comp_info[from_idx++].from_apparent = c;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR tv614[ebp]
	mov	eax, DWORD PTR [eax+260]
	mov	DWORD PTR [eax+ecx+16], edx
	add	ecx, 40					; 00000028H
	mov	DWORD PTR tv614[ebp], ecx
$LN8@apply_inpu:

; 6348 :       for (c=from_idx=0; c < state->num_output_components; c++)

	mov	eax, DWORD PTR [esi]
	inc	edx
	add	ebx, 40					; 00000028H
	inc	edi
	cmp	edx, DWORD PTR [eax+120]
	jl	SHORT $LL10@apply_inpu
$LN9@apply_inpu:

; 6357 :         }
; 6358 :     }
; 6359 :   else
; 6360 :     assert(0);
; 6361 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z$0:
	lea	ecx, DWORD PTR _e$6[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z$1:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z$2:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z$3:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z$4:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?apply_input_restrictions@kdu_codestream@@QAEXHHHHPAUkdu_dims@@W4kdu_component_access_mode@@@Z ENDP ; kdu_codestream::apply_input_restrictions
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_fast@kdu_codestream@@QAEXXZ
_TEXT	SEGMENT
?set_fast@kdu_codestream@@QAEXXZ PROC			; kdu_codestream::set_fast, COMDAT
; _this$ = ecx

; 6250 :   state->resilient = false;

	mov	eax, DWORD PTR [ecx]
	mov	BYTE PTR [eax+332], 0

; 6251 :   state->fussy = false;

	mov	eax, DWORD PTR [ecx]
	mov	BYTE PTR [eax+334], 0

; 6252 : }

	ret	0
?set_fast@kdu_codestream@@QAEXXZ ENDP			; kdu_codestream::set_fast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_fussy@kdu_codestream@@QAEXXZ
_TEXT	SEGMENT
?set_fussy@kdu_codestream@@QAEXXZ PROC			; kdu_codestream::set_fussy, COMDAT
; _this$ = ecx

; 6239 :   state->resilient = false;

	mov	eax, DWORD PTR [ecx]
	mov	BYTE PTR [eax+332], 0

; 6240 :   state->fussy = true;

	mov	eax, DWORD PTR [ecx]
	mov	BYTE PTR [eax+334], 1

; 6241 : }

	ret	0
?set_fussy@kdu_codestream@@QAEXXZ ENDP			; kdu_codestream::set_fussy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_resilient@kdu_codestream@@QAEX_N@Z
_TEXT	SEGMENT
_expect_ubiquitous_sops$ = 8				; size = 1
?set_resilient@kdu_codestream@@QAEX_N@Z PROC		; kdu_codestream::set_resilient, COMDAT
; _this$ = ecx

; 6226 : {

	push	ebp
	mov	ebp, esp

; 6227 :   state->resilient = true;

	mov	eax, DWORD PTR [ecx]
	mov	BYTE PTR [eax+332], 1

; 6228 :   state->expect_ubiquitous_sops = expect_ubiquitous_sops;

	mov	edx, DWORD PTR [ecx]
	mov	al, BYTE PTR _expect_ubiquitous_sops$[ebp]
	mov	BYTE PTR [edx+333], al

; 6229 :   state->fussy = false;

	mov	eax, DWORD PTR [ecx]
	mov	BYTE PTR [eax+334], 0

; 6230 : }

	pop	ebp
	ret	4
?set_resilient@kdu_codestream@@QAEX_N@Z ENDP		; kdu_codestream::set_resilient
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_min_slope_threshold@kdu_codestream@@QAEXG@Z
_TEXT	SEGMENT
_threshold$ = 8						; size = 2
?set_min_slope_threshold@kdu_codestream@@QAEXG@Z PROC	; kdu_codestream::set_min_slope_threshold, COMDAT
; _this$ = ecx

; 6216 : {

	push	ebp
	mov	ebp, esp

; 6217 :   state->min_slope_threshold = threshold;

	mov	ecx, DWORD PTR [ecx]
	mov	ax, WORD PTR _threshold$[ebp]
	mov	WORD PTR [ecx+384], ax

; 6218 : }

	pop	ebp
	ret	4
?set_min_slope_threshold@kdu_codestream@@QAEXG@Z ENDP	; kdu_codestream::set_min_slope_threshold
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z
_TEXT	SEGMENT
_max_bytes$GSCopy$1$ = -132				; size = 4
_max_bytes$GSCopy$2$ = -128				; size = 4
_e$2 = -124						; size = 20
_e$3 = -124						; size = 20
_comp_dims$4 = -120					; size = 16
_total_samples$5 = -104					; size = 8
_total_samples$1$ = -100				; size = 4
$T6 = -100						; size = 4
_text$7 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_max_bytes$ = 8						; size = 8
_simulate_parsing$ = 16					; size = 1
_enable_periodic_trimming$ = 20				; size = 1
?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z PROC		; kdu_codestream::set_max_bytes, COMDAT
; _this$ = ecx

; 6178 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 6179 :   assert(!state->tiles_accessed);
; 6180 : 
; 6181 :   if (state->in != NULL)

	mov	ecx, DWORD PTR [esi]
	mov	ebx, DWORD PTR _max_bytes$[ebp]
	mov	edx, DWORD PTR _max_bytes$[ebp+4]
	mov	DWORD PTR _max_bytes$GSCopy$1$[ebp], ebx
	cmp	DWORD PTR [ecx+4], 0
	mov	DWORD PTR _max_bytes$GSCopy$2$[ebp], edx
	je	$LN5@set_max_by

; 6182 :     {
; 6183 :       state->simulate_parsing_while_counting_bytes = simulate_parsing;

	mov	al, BYTE PTR _simulate_parsing$[ebp]
	mov	BYTE PTR [ecx+336], al

; 6184 :       state->in->set_max_bytes(max_bytes);

	mov	ecx, DWORD PTR [esi]
	push	edx
	push	ebx
	mov	ecx, DWORD PTR [ecx+4]
	call	?set_max_bytes@kd_compressed_input@@QAEX_J@Z ; kd_compressed_input::set_max_bytes
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 528  :         return exhausted;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	al, BYTE PTR [eax+533]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6185 :       if (state->in->failed())

	test	al, al
	je	$LN8@set_max_by

; 6186 :         { KDU_ERROR(e,50); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0EM@OGOFBDKF@Attempting?5to?5impose?5too?5small?5a@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6186 :         { KDU_ERROR(e,50); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$3[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	ebx
	push	eax
	lea	eax, DWORD PTR _text$7[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$7[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	eax
	mov	eax, DWORD PTR _e$3[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0DL@OBAGKPCA@?5bytes?5is?5insufficient?5to?5accomo@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6190 :         }

	lea	ecx, DWORD PTR _e$3[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error

; 6191 :     }

	jmp	$LN8@set_max_by
$LN5@set_max_by:

; 6192 :   else if (state->out != NULL)

	cmp	DWORD PTR [ecx+8], 0
	je	$LN8@set_max_by

; 6193 :     {
; 6194 :       if (state->stats != NULL)

	cmp	DWORD PTR [ecx+32], 0
	je	SHORT $LN9@set_max_by

; 6195 :         { KDU_ERROR_DEV(e,51); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0EC@IHLMBNEM@?$CCkdu_codestream?3?3set_max_bytes?$CC?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6195 :         { KDU_ERROR_DEV(e,51); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6198 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN9@set_max_by:

; 6199 :       kdu_long total_samples = 0;
; 6200 :       for (int c=0; c < state->num_components; c++)

	mov	eax, DWORD PTR [esi]
	xorps	xmm0, xmm0
	xor	edi, edi
	movlpd	QWORD PTR _total_samples$5[ebp], xmm0
	mov	ebx, DWORD PTR _total_samples$5[ebp+4]
	cmp	DWORD PTR [eax+112], edi
	jle	SHORT $LN38@set_max_by
	mov	eax, DWORD PTR _total_samples$5[ebp]
	mov	DWORD PTR _total_samples$1$[ebp], eax
$LL4@set_max_by:

; 6201 :         {
; 6202 :           kdu_dims comp_dims; get_dims(c,comp_dims);

	push	0
	lea	eax, DWORD PTR _comp_dims$4[ebp]
	xorps	xmm0, xmm0
	push	eax
	push	edi
	mov	ecx, esi
	movups	XMMWORD PTR _comp_dims$4[ebp], xmm0
	call	?get_dims@kdu_codestream@@QAEXHAAUkdu_dims@@_N@Z ; kdu_codestream::get_dims
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR _comp_dims$4[ebp+12]
	imul	DWORD PTR _comp_dims$4[ebp+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6203 :           total_samples += comp_dims.area();

	add	DWORD PTR _total_samples$1$[ebp], eax
	mov	eax, DWORD PTR [esi]
	adc	ebx, edx
	inc	edi
	cmp	edi, DWORD PTR [eax+112]
	jl	SHORT $LL4@set_max_by
	mov	edi, DWORD PTR _total_samples$1$[ebp]
	jmp	SHORT $LN3@set_max_by
$LN38@set_max_by:

; 6199 :       kdu_long total_samples = 0;
; 6200 :       for (int c=0; c < state->num_components; c++)

	mov	edi, DWORD PTR _total_samples$5[ebp]
$LN3@set_max_by:

; 6204 :         }
; 6205 :       state->stats = new kd_compressed_stats(total_samples,max_bytes,

	push	32832					; 00008040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	test	eax, eax
	je	SHORT $LN11@set_max_by
	push	DWORD PTR _enable_periodic_trimming$[ebp]
	mov	ecx, eax
	push	DWORD PTR _max_bytes$GSCopy$2$[ebp]
	push	DWORD PTR _max_bytes$GSCopy$1$[ebp]
	push	ebx
	push	edi
	call	??0kd_compressed_stats@@QAE@_J0_N@Z	; kd_compressed_stats::kd_compressed_stats
	mov	ecx, eax
	jmp	SHORT $LN12@set_max_by
$LN11@set_max_by:
	xor	ecx, ecx
$LN12@set_max_by:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+32], ecx
$LN8@set_max_by:

; 6206 :                                              enable_periodic_trimming);
; 6207 :     }
; 6208 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-136]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?set_max_bytes@kdu_codestream@@QAEX_J_N1@Z ENDP		; kdu_codestream::set_max_bytes
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_textualization@kdu_codestream@@QAEXPAVkdu_message@@@Z
_TEXT	SEGMENT
_output$ = 8						; size = 4
?set_textualization@kdu_codestream@@QAEXPAVkdu_message@@@Z PROC ; kdu_codestream::set_textualization, COMDAT
; _this$ = ecx

; 6161 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 6162 :   assert(!state->tiles_accessed);
; 6163 :   if (output != NULL)

	mov	esi, DWORD PTR _output$[ebp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	je	SHORT $LN4@set_textua

; 6164 :     {
; 6165 :       state->siz->textualize_attributes(*output,-1,-1);

	mov	ecx, DWORD PTR [edi]
	push	1
	push	-1
	push	-1
	mov	ecx, DWORD PTR [ecx+12]
	push	esi
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@HH_N@Z ; kdu_params::textualize_attributes

; 6166 :       output->flush();

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	0
	call	DWORD PTR [eax+12]
$LN4@set_textua:

; 6167 :     }
; 6168 :   state->textualize_out = output;

	mov	eax, DWORD PTR [edi]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 6169 : }

	pop	ebp
	ret	4
?set_textualization@kdu_codestream@@QAEXPAVkdu_message@@@Z ENDP ; kdu_codestream::set_textualization
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?map_region@kdu_codestream@@QAEXHUkdu_dims@@AAU2@_N@Z
_TEXT	SEGMENT
$T1 = -28						; size = 16
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_this$1$ = -4						; size = 4
_ci$1$ = 8						; size = 4
_comp_idx$ = 8						; size = 4
_comp_region$ = 12					; size = 16
_canvas_region$ = 28					; size = 4
_min$1$ = 32						; size = 4
_want_output_comps$ = 32				; size = 1
?map_region@kdu_codestream@@QAEXHUkdu_dims@@AAU2@_N@Z PROC ; kdu_codestream::map_region, COMDAT
; _this$ = ecx

; 6771 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, ecx
	push	ebx
	push	esi
	mov	DWORD PTR _this$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 416  :         if (hflip) pos.x = -(pos.x+size.x-1);

	mov	ebx, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6772 :   comp_region.from_apparent(state->transpose,state->vflip,state->hflip);

	mov	ecx, DWORD PTR [eax]
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 416  :         if (hflip) pos.x = -(pos.x+size.x-1);

	mov	edi, DWORD PTR _comp_region$[ebp+12]
	cmp	BYTE PTR [ecx+331], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6772 :   comp_region.from_apparent(state->transpose,state->vflip,state->hflip);

	mov	al, BYTE PTR [ecx+330]
	mov	ah, BYTE PTR [ecx+329]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 416  :         if (hflip) pos.x = -(pos.x+size.x-1);

	je	SHORT $LN28@map_region
	mov	esi, ebx
	sub	esi, DWORD PTR _comp_region$[ebp+4]
	sub	esi, edi
	mov	DWORD PTR _comp_region$[ebp+4], esi
	jmp	SHORT $LN10@map_region
$LN28@map_region:
	mov	esi, DWORD PTR _comp_region$[ebp+4]
$LN10@map_region:

; 417  :         if (vflip) pos.y = -(pos.y+size.y-1);

	mov	edx, DWORD PTR _comp_region$[ebp+8]
	test	al, al
	je	SHORT $LN29@map_region
	sub	ebx, DWORD PTR _comp_region$[ebp]
	sub	ebx, edx
	mov	DWORD PTR _comp_region$[ebp], ebx
	jmp	SHORT $LN11@map_region
$LN29@map_region:
	mov	ebx, DWORD PTR _comp_region$[ebp]
$LN11@map_region:

; 418  :         if (transp) transpose();

	test	ah, ah
	je	SHORT $LN12@map_region

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, edx
	mov	edx, edi
	mov	edi, eax
	mov	DWORD PTR _comp_region$[ebp+8], edx
	mov	eax, ebx
	mov	DWORD PTR _comp_region$[ebp+12], edi
	mov	ebx, esi
	mov	esi, eax
	mov	DWORD PTR _comp_region$[ebp], ebx
	mov	DWORD PTR _comp_region$[ebp+4], esi
$LN12@map_region:

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	lea	eax, DWORD PTR [esi+edi]
	add	edx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6775 :   if (comp_idx >= 0)

	mov	edi, DWORD PTR _comp_idx$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR $T2[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6775 :   if (comp_idx >= 0)

	test	edi, edi
	js	$LN2@map_region

; 6776 :     {
; 6777 :       if (!state->construction_finalized)

	cmp	BYTE PTR [ecx+341], 0
	jne	SHORT $LN3@map_region

; 6778 :         state->finalize_construction();

	call	?finalize_construction@kd_codestream@@QAEXXZ ; kd_codestream::finalize_construction
$LN3@map_region:

; 6779 :       kd_comp_info *ci = NULL;
; 6780 :       if (want_output_comps &&

	mov	eax, DWORD PTR _this$1$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _ci$1$[ebp], ecx
	cmp	BYTE PTR _want_output_comps$[ebp], cl
	je	SHORT $LN4@map_region
	mov	edx, DWORD PTR [eax]
	cmp	DWORD PTR [edx+128], ecx
	jne	SHORT $LN4@map_region

; 6781 :           (state->component_access_mode == KDU_WANT_OUTPUT_COMPONENTS))
; 6782 :         {
; 6783 :           if (comp_idx < state->num_apparent_output_components)

	cmp	edi, DWORD PTR [edx+124]
	jge	SHORT $LN7@map_region

; 6784 :             {
; 6785 :               kd_output_comp_info *oci = state->output_comp_info +

	mov	ecx, DWORD PTR [edx+260]
	lea	eax, DWORD PTR [edi+edi*4]
	mov	eax, DWORD PTR [ecx+eax*8+16]
	lea	eax, DWORD PTR [eax+eax*4]

; 6786 :                 state->output_comp_info[comp_idx].from_apparent;
; 6787 :               ci = oci->subsampling_ref;

	mov	ecx, DWORD PTR [ecx+eax*8+8]

; 6788 :             }
; 6789 :         }
; 6790 :       else

	jmp	SHORT $LN31@map_region
$LN4@map_region:

; 6791 :         {
; 6792 :           if (comp_idx < state->num_apparent_components)

	mov	edx, DWORD PTR [eax]
	cmp	edi, DWORD PTR [edx+116]
	jge	SHORT $LN7@map_region

; 6793 :             ci = state->comp_info[comp_idx].from_apparent;

	mov	eax, DWORD PTR [edx+256]
	lea	ecx, DWORD PTR [edi+edi*2]
	shl	ecx, 5
	mov	ecx, DWORD PTR [eax+ecx+92]
$LN31@map_region:
	mov	DWORD PTR _ci$1$[ebp], ecx
$LN7@map_region:

; 6794 :         }
; 6795 : 
; 6796 :       min.x *= ci->sub_sampling.x << ci->hor_depth[state->discard_levels];

	mov	edx, DWORD PTR [edx+188]
	mov	edi, DWORD PTR [ecx+4]
	add	edx, ecx
	movzx	ecx, BYTE PTR [edx+21]
	shl	edi, cl

; 6797 :       min.y *= ci->sub_sampling.y << ci->vert_depth[state->discard_levels];

	movzx	ecx, BYTE PTR [edx+54]
	mov	eax, edi

; 6798 :       lim.x *= ci->sub_sampling.x << ci->hor_depth[state->discard_levels];

	imul	edi, DWORD PTR $T3[ebp]
	imul	eax, esi
	mov	esi, DWORD PTR _ci$1$[ebp]
	mov	esi, DWORD PTR [esi]
	shl	esi, cl
	imul	ebx, esi

; 6799 :       lim.y *= ci->sub_sampling.y << ci->vert_depth[state->discard_levels];

	imul	esi, DWORD PTR $T2[ebp]
	mov	DWORD PTR _min$1$[ebp], eax
	mov	eax, edi
	mov	edx, esi
	mov	esi, DWORD PTR _min$1$[ebp]
$LN2@map_region:

; 6800 :     }
; 6801 :   canvas_region.pos = min;

	mov	ecx, DWORD PTR _canvas_region$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, esi
	sub	edx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6802 :   canvas_region.size = lim-min;

	mov	DWORD PTR [ecx+12], eax

; 6803 :   canvas_region &= state->canvas;

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax]
	add	eax, 132				; 00000084H
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=
	pop	edi
	pop	esi
	pop	ebx

; 6804 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?map_region@kdu_codestream@@QAEXHUkdu_dims@@AAU2@_N@Z ENDP ; kdu_codestream::map_region
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?can_flip@kdu_codestream@@QAE_N_N@Z
_TEXT	SEGMENT
_check_current_appearance_only$ = 8			; size = 1
?can_flip@kdu_codestream@@QAE_N_N@Z PROC		; kdu_codestream::can_flip, COMDAT
; _this$ = ecx

; 6761 :   return !(state->cannot_flip && (state->hflip || state->vflip));

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+224], 0
	je	SHORT $LN4@can_flip
	cmp	BYTE PTR [eax+331], 0
	jne	SHORT $LN3@can_flip
	cmp	BYTE PTR [eax+330], 0
	je	SHORT $LN4@can_flip
$LN3@can_flip:
	xor	al, al

; 6762 : }

	ret	4
$LN4@can_flip:

; 6761 :   return !(state->cannot_flip && (state->hflip || state->vflip));

	mov	al, 1

; 6762 : }

	ret	4
?can_flip@kdu_codestream@@QAE_N_N@Z ENDP		; kdu_codestream::can_flip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_min_dwt_levels@kdu_codestream@@QAEHXZ
_TEXT	SEGMENT
_levels$1 = -4						; size = 4
?get_min_dwt_levels@kdu_codestream@@QAEHXZ PROC		; kdu_codestream::get_min_dwt_levels, COMDAT
; _this$ = ecx

; 6741 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 6742 :   if (state->min_dwt_levels > 32)

	mov	ecx, DWORD PTR [esi]
	cmp	DWORD PTR [ecx+192], 32			; 00000020H
	jle	SHORT $LN7@get_min_dw

; 6743 :     { // Check main header COD marker segment
; 6744 :       int levels;
; 6745 :       kdu_params *cod = state->siz->access_cluster(COD_params);

	mov	ecx, DWORD PTR [ecx+12]
	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 6746 :       if (cod->get(Clevels,0,0,levels) && (levels < state->min_dwt_levels))

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR _levels$1[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN3@get_min_dw
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _levels$1[ebp]
	cmp	ecx, DWORD PTR [eax+192]
	jge	SHORT $LN3@get_min_dw

; 6747 :         state->min_dwt_levels = levels;

	mov	DWORD PTR [eax+192], ecx
$LN3@get_min_dw:

; 6748 :       if (state->min_dwt_levels > 32)

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+192], 32			; 00000020H
	jle	SHORT $LN6@get_min_dw

; 6749 :         state->min_dwt_levels = 32;

	mov	DWORD PTR [eax+192], 32			; 00000020H

; 6750 :     }
; 6751 :   return state->min_dwt_levels;

	mov	eax, DWORD PTR [esi]
$LN6@get_min_dw:
	mov	eax, DWORD PTR [eax+192]
	pop	esi

; 6752 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@get_min_dw:

; 6750 :     }
; 6751 :   return state->min_dwt_levels;

	mov	eax, DWORD PTR [ecx+192]
	pop	esi

; 6752 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?get_min_dwt_levels@kdu_codestream@@QAEHXZ ENDP		; kdu_codestream::get_min_dwt_levels
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_max_tile_layers@kdu_codestream@@QAEHXZ
_TEXT	SEGMENT
?get_max_tile_layers@kdu_codestream@@QAEHXZ PROC	; kdu_codestream::get_max_tile_layers, COMDAT
; _this$ = ecx

; 6732 :   return state->max_tile_layers;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+200]

; 6733 : }

	ret	0
?get_max_tile_layers@kdu_codestream@@QAEHXZ ENDP	; kdu_codestream::get_max_tile_layers
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_tile_dims@kdu_codestream@@QAEXUkdu_coords@@HAAUkdu_dims@@_N@Z
_TEXT	SEGMENT
$T1 = -32						; size = 16
$T2 = -32						; size = 16
_lim$2$ = -16						; size = 4
_lim$1$ = -12						; size = 4
_min$3$ = -8						; size = 4
_min$1$ = -4						; size = 4
_tile_idx$ = 8						; size = 8
_comp_idx$ = 16						; size = 4
_min$2$ = 20						; size = 4
_ci$1$ = 20						; size = 4
_dims$ = 20						; size = 4
_min$4$ = 24						; size = 4
_subs$2$ = 24						; size = 4
_want_output_comps$ = 24				; size = 1
?get_tile_dims@kdu_codestream@@QAEXUkdu_coords@@HAAUkdu_dims@@_N@Z PROC ; kdu_codestream::get_tile_dims, COMDAT
; _this$ = ecx

; 6473 : {

	push	ebp
	mov	ebp, esp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	mov	edx, DWORD PTR _tile_idx$[ebp+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6473 : {

	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	esi

; 6474 :   tile_idx.from_apparent(state->transpose,state->vflip,state->hflip);

	mov	esi, DWORD PTR [ebx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	cmp	BYTE PTR [esi+331], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6474 :   tile_idx.from_apparent(state->transpose,state->vflip,state->hflip);

	mov	al, BYTE PTR [esi+330]
	mov	ah, BYTE PTR [esi+329]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	je	SHORT $LN13@get_tile_d
	neg	edx
	mov	DWORD PTR _tile_idx$[ebp+4], edx
$LN13@get_tile_d:

; 267  :         y=(vflip)?(-y):y;

	mov	ecx, DWORD PTR _tile_idx$[ebp]
	test	al, al
	je	SHORT $LN15@get_tile_d
	neg	ecx
	mov	DWORD PTR _tile_idx$[ebp], ecx
$LN15@get_tile_d:

; 268  :         if (transp) transpose();

	test	ah, ah
	je	SHORT $LN11@get_tile_d

; 211  :     void assign(const kdu_coords &src) { *this = src; }
; 212  :       /* [SYNOPSIS] Copies the contents of `src' to the present object.
; 213  :          This function is useful only when using a language binding
; 214  :          which does not support data member access or direct copying
; 215  :          of contents. */
; 216  :     int get_x() { return x; }
; 217  :     int get_y() { return y; }
; 218  :     void set_x(int x) { this->x = x; }
; 219  :     void set_y(int y) { this->y = y; }
; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, ecx
	mov	ecx, edx
	mov	edx, eax
	mov	DWORD PTR _tile_idx$[ebp], ecx
	mov	DWORD PTR _tile_idx$[ebp+4], edx
$LN11@get_tile_d:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6477 :   dims = state->tile_partition;

	movups	xmm0, XMMWORD PTR [esi+148]
	mov	esi, DWORD PTR _dims$[ebp]
	movups	XMMWORD PTR [esi], xmm0

; 6478 :   dims.pos.x += tile_idx.x * dims.size.x;

	mov	eax, DWORD PTR [esi+12]
	imul	eax, edx
	add	DWORD PTR [esi+4], eax

; 6479 :   dims.pos.y += tile_idx.y * dims.size.y;

	mov	eax, DWORD PTR [esi+8]
	imul	eax, ecx

; 6480 :   dims &= state->canvas;

	mov	ecx, esi
	add	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [ebx]
	add	eax, 132				; 00000084H
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=

; 6481 :   if (state->out == NULL)

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@get_tile_d

; 6482 :     dims &= state->region;

	add	eax, 208				; 000000d0H
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=
$LN2@get_tile_d:

; 6483 :   kdu_coords min = dims.pos;

	mov	eax, DWORD PTR [esi+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	edx, DWORD PTR [esi+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6483 :   kdu_coords min = dims.pos;

	mov	ecx, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	edx, eax
	mov	DWORD PTR _lim$1$[ebp], edx
	mov	edx, DWORD PTR [esi+8]
	add	edx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6483 :   kdu_coords min = dims.pos;

	mov	DWORD PTR _min$3$[ebp], ecx
	push	edi

; 6486 :   if (comp_idx >= 0)

	mov	edi, DWORD PTR _comp_idx$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 210  :     kdu_coords(int x, int y) {this->x=x; this->y=y; }

	mov	ecx, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6483 :   kdu_coords min = dims.pos;

	mov	DWORD PTR _min$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	DWORD PTR _lim$2$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6486 :   if (comp_idx >= 0)

	test	edi, edi
	js	$LN58@get_tile_d

; 6487 :     {
; 6488 :       if (!state->construction_finalized)

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+341], 0
	jne	SHORT $LN4@get_tile_d

; 6489 :         state->finalize_construction();

	call	?finalize_construction@kd_codestream@@QAEXXZ ; kd_codestream::finalize_construction
$LN4@get_tile_d:

; 6490 :       kd_comp_info *ci = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _ci$1$[ebp], ecx

; 6491 :       if (want_output_comps &&

	cmp	BYTE PTR _want_output_comps$[ebp], cl
	je	SHORT $LN5@get_tile_d
	mov	edx, DWORD PTR [ebx]
	cmp	DWORD PTR [edx+128], ecx
	jne	SHORT $LN5@get_tile_d

; 6492 :           (state->component_access_mode == KDU_WANT_OUTPUT_COMPONENTS))
; 6493 :         {
; 6494 :           if (comp_idx < state->num_apparent_output_components)

	cmp	edi, DWORD PTR [edx+124]
	jge	SHORT $LN8@get_tile_d

; 6495 :             {
; 6496 :               kd_output_comp_info *oci = state->output_comp_info +

	mov	ecx, DWORD PTR [edx+260]
	lea	eax, DWORD PTR [edi+edi*4]
	mov	eax, DWORD PTR [ecx+eax*8+16]
	lea	eax, DWORD PTR [eax+eax*4]

; 6497 :                 state->output_comp_info[comp_idx].from_apparent;
; 6498 :               ci = oci->subsampling_ref;

	mov	ecx, DWORD PTR [ecx+eax*8+8]

; 6499 :             }
; 6500 :         }
; 6501 :       else

	jmp	SHORT $LN59@get_tile_d
$LN5@get_tile_d:

; 6502 :         {
; 6503 :           if (comp_idx < state->num_apparent_components)

	mov	edx, DWORD PTR [ebx]
	cmp	edi, DWORD PTR [edx+116]
	jge	SHORT $LN8@get_tile_d

; 6504 :             ci = state->comp_info[comp_idx].from_apparent;

	mov	eax, DWORD PTR [edx+256]
	lea	ecx, DWORD PTR [edi+edi*2]
	shl	ecx, 5
	mov	ecx, DWORD PTR [eax+ecx+92]
$LN59@get_tile_d:
	mov	DWORD PTR _ci$1$[ebp], ecx
$LN8@get_tile_d:

; 6505 :         }
; 6506 : 
; 6507 :       subs = ci->sub_sampling;

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR _subs$2$[ebp], eax

; 6508 :       subs.x <<= ci->hor_depth[state->discard_levels];

	mov	eax, DWORD PTR [edx+188]
	movzx	ecx, BYTE PTR [eax+ecx+21]
	shl	edi, cl

; 6509 :       subs.y <<= ci->vert_depth[state->discard_levels];

	mov	ecx, DWORD PTR _ci$1$[ebp]
	movzx	ecx, BYTE PTR [eax+ecx+54]
	shl	DWORD PTR _subs$2$[ebp], cl
	mov	ecx, DWORD PTR _subs$2$[ebp]
	mov	eax, DWORD PTR _min$1$[ebp]
	jmp	SHORT $LN3@get_tile_d
$LN58@get_tile_d:
	mov	edi, ecx
$LN3@get_tile_d:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN26@get_tile_d

; 180  :     return -((-num)/den);

	cdq
	idiv	edi
	mov	DWORD PTR _min$2$[ebp], eax
	jmp	SHORT $LN27@get_tile_d
$LN26@get_tile_d:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	edi
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR _min$2$[ebp], edx
$LN27@get_tile_d:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _min$3$[ebp]
	test	eax, eax
	jg	SHORT $LN30@get_tile_d

; 180  :     return -((-num)/den);

	cdq
	idiv	ecx
	mov	DWORD PTR _min$4$[ebp], eax
	jmp	SHORT $LN31@get_tile_d
$LN30@get_tile_d:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ecx
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR _min$4$[ebp], edx
$LN31@get_tile_d:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _lim$1$[ebp]
	test	eax, eax
	jg	SHORT $LN34@get_tile_d

; 180  :     return -((-num)/den);

	cdq
	idiv	edi
	mov	edi, eax
	jmp	SHORT $LN35@get_tile_d
$LN34@get_tile_d:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	edi
	lea	edi, DWORD PTR [eax+1]
$LN35@get_tile_d:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _lim$2$[ebp]
	test	eax, eax
	jg	SHORT $LN38@get_tile_d

; 180  :     return -((-num)/den);

	cdq
	idiv	ecx
	jmp	SHORT $LN39@get_tile_d
$LN38@get_tile_d:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ecx
	inc	eax
$LN39@get_tile_d:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6515 :   dims.pos = min;

	mov	edx, DWORD PTR _min$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	edi, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6515 :   dims.pos = min;

	mov	ecx, DWORD PTR _min$4$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6516 :   dims.size = lim-min;

	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], eax

; 6517 :   dims.to_apparent(state->transpose,state->vflip,state->hflip);

	mov	eax, DWORD PTR [ebx]
	pop	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	cmp	BYTE PTR [eax+329], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6517 :   dims.to_apparent(state->transpose,state->vflip,state->hflip);

	mov	bl, BYTE PTR [eax+331]
	mov	dl, BYTE PTR [eax+330]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	je	SHORT $LN46@get_tile_d

; 211  :     void assign(const kdu_coords &src) { *this = src; }
; 212  :       /* [SYNOPSIS] Copies the contents of `src' to the present object.
; 213  :          This function is useful only when using a language binding
; 214  :          which does not support data member access or direct copying
; 215  :          of contents. */
; 216  :     int get_x() { return x; }
; 217  :     int get_y() { return y; }
; 218  :     void set_x(int x) { this->x = x; }
; 219  :     void set_y(int y) { this->y = y; }
; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ecx
$LN46@get_tile_d:

; 426  :       if (hflip) pos.x = -(pos.x+size.x-1);

	mov	ecx, 1
	test	bl, bl
	je	SHORT $LN47@get_tile_d
	mov	eax, ecx
	sub	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+4], eax
$LN47@get_tile_d:

; 427  :       if (vflip) pos.y = -(pos.y+size.y-1);

	test	dl, dl
	je	SHORT $LN48@get_tile_d
	sub	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi], ecx
$LN48@get_tile_d:
	pop	esi
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6518 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?get_tile_dims@kdu_codestream@@QAEXUkdu_coords@@HAAUkdu_dims@@_N@Z ENDP ; kdu_codestream::get_tile_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?find_tile@kdu_codestream@@QAE_NHUkdu_coords@@AAU2@_N@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_comp_idx$ = 8						; size = 4
_loc$ = 12						; size = 8
_tile_idx$ = 20						; size = 4
_ci$1$ = 24						; size = 4
_want_output_comps$ = 24				; size = 1
?find_tile@kdu_codestream@@QAE_NHUkdu_coords@@AAU2@_N@Z PROC ; kdu_codestream::find_tile, COMDAT
; _this$ = ecx

; 6836 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 6837 :   if (!state->construction_finalized)

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _this$1$[ebp], ecx
	cmp	BYTE PTR [eax+341], 0
	jne	SHORT $LN2@find_tile

; 6838 :     state->finalize_construction();

	mov	ecx, eax
	call	?finalize_construction@kd_codestream@@QAEXXZ ; kd_codestream::finalize_construction
	mov	ecx, DWORD PTR _this$1$[ebp]
$LN2@find_tile:

; 6839 :   if (comp_idx < 0)

	mov	eax, DWORD PTR _comp_idx$[ebp]
	test	eax, eax
	jns	SHORT $LN3@find_tile
$LN32@find_tile:

; 6840 :     return false;

	xor	al, al

; 6871 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN3@find_tile:

; 6841 :   kd_comp_info *ci = NULL;
; 6842 :   if (want_output_comps &&

	cmp	BYTE PTR _want_output_comps$[ebp], 0
	je	SHORT $LN4@find_tile
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+128], 0
	jne	SHORT $LN4@find_tile

; 6843 :       (state->component_access_mode == KDU_WANT_OUTPUT_COMPONENTS))
; 6844 :     {
; 6845 :       if (comp_idx >= state->num_apparent_output_components)

	cmp	eax, DWORD PTR [edx+124]
	jge	SHORT $LN32@find_tile

; 6846 :         return false;
; 6847 :       kd_output_comp_info *oci = state->output_comp_info +

	mov	ecx, DWORD PTR [edx+260]
	lea	eax, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+eax*8+16]
	lea	eax, DWORD PTR [eax+eax*4]

; 6848 :         state->output_comp_info[comp_idx].from_apparent;
; 6849 :       ci = oci->subsampling_ref;

	mov	ecx, DWORD PTR [ecx+eax*8+8]

; 6850 :     }
; 6851 :   else

	jmp	SHORT $LN31@find_tile
$LN4@find_tile:

; 6852 :     {
; 6853 :       if (comp_idx >= state->num_apparent_components)

	mov	edx, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+116]
	jge	SHORT $LN32@find_tile

; 6855 :       ci = state->comp_info[comp_idx].from_apparent;

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edx+256]
	shl	ecx, 5
	mov	ecx, DWORD PTR [eax+ecx+92]
$LN31@find_tile:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	cmp	BYTE PTR [edx+331], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6858 :   loc.from_apparent(state->transpose,state->vflip,state->hflip);

	mov	al, BYTE PTR [edx+330]
	push	ebx
	mov	bl, BYTE PTR [edx+329]
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	mov	edi, DWORD PTR _loc$[ebp+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6855 :       ci = state->comp_info[comp_idx].from_apparent;

	mov	DWORD PTR _ci$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	je	SHORT $LN14@find_tile
	neg	edi
	mov	DWORD PTR _loc$[ebp+4], edi
$LN14@find_tile:
	push	esi

; 267  :         y=(vflip)?(-y):y;

	mov	esi, DWORD PTR _loc$[ebp]
	test	al, al
	je	SHORT $LN16@find_tile
	neg	esi
	mov	DWORD PTR _loc$[ebp], esi
$LN16@find_tile:

; 268  :         if (transp) transpose();

	test	bl, bl
	je	SHORT $LN12@find_tile

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, esi
	mov	esi, edi
	mov	edi, eax
	mov	DWORD PTR _loc$[ebp], esi
	mov	DWORD PTR _loc$[ebp+4], edi
$LN12@find_tile:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6859 :   loc.x *= ci->sub_sampling.x << ci->hor_depth[state->discard_levels];

	mov	eax, DWORD PTR [edx+188]
	mov	ebx, DWORD PTR [ecx+4]
	movzx	ecx, BYTE PTR [eax+ecx+21]
	shl	ebx, cl

; 6860 :   loc.y *= ci->sub_sampling.y << ci->vert_depth[state->discard_levels];

	mov	ecx, DWORD PTR _ci$1$[ebp]
	imul	ebx, edi
	mov	DWORD PTR _loc$[ebp+4], ebx
	mov	eax, DWORD PTR [edx+188]
	mov	edi, DWORD PTR [ecx]
	movzx	ecx, BYTE PTR [eax+ecx+54]
	shl	edi, cl
	imul	edi, esi
	mov	DWORD PTR _loc$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	sub	ebx, DWORD PTR [edx+212]
	mov	DWORD PTR _loc$[ebp+4], ebx
	sub	edi, DWORD PTR [edx+208]
	mov	DWORD PTR _loc$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6863 :       (loc.x >= state->region.size.x) || (loc.y >= state->region.size.y))

	test	ebx, ebx
	js	$LN9@find_tile
	test	edi, edi
	js	$LN9@find_tile
	cmp	ebx, DWORD PTR [edx+220]
	jge	$LN9@find_tile
	cmp	edi, DWORD PTR [edx+216]
	jge	SHORT $LN9@find_tile
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	add	ebx, DWORD PTR [edx+212]
	mov	DWORD PTR _loc$[ebp+4], ebx
	add	edi, DWORD PTR [edx+208]
	mov	DWORD PTR _loc$[ebp], edi

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	sub	ebx, DWORD PTR [edx+152]
	mov	DWORD PTR _loc$[ebp+4], ebx
	sub	edi, DWORD PTR [edx+148]
	mov	DWORD PTR _loc$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6867 :   tile_idx.x = floor_ratio(loc.x,state->tile_partition.size.x);

	push	DWORD PTR [edx+160]
	push	ebx
	call	?floor_ratio@@YAHHH@Z			; floor_ratio
	mov	esi, DWORD PTR _tile_idx$[ebp]

; 6868 :   tile_idx.y = floor_ratio(loc.y,state->tile_partition.size.y);

	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR [eax+156]
	push	edi
	call	?floor_ratio@@YAHHH@Z			; floor_ratio
	mov	DWORD PTR [esi], eax
	add	esp, 16					; 00000010H

; 6869 :   tile_idx.to_apparent(state->transpose,state->vflip,state->hflip);

	mov	edx, DWORD PTR [ebx]
	mov	ecx, esi
	movzx	eax, BYTE PTR [edx+331]
	push	eax
	movzx	eax, BYTE PTR [edx+330]
	push	eax
	movzx	eax, BYTE PTR [edx+329]
	push	eax
	call	?to_apparent@kdu_coords@@QAEX_N00@Z	; kdu_coords::to_apparent
	pop	esi
	pop	edi

; 6870 :   return true;

	mov	al, 1
	pop	ebx

; 6871 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN9@find_tile:
	pop	esi
	pop	edi

; 6864 :     return false;

	xor	al, al
	pop	ebx

; 6871 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?find_tile@kdu_codestream@@QAE_NHUkdu_coords@@AAU2@_N@Z ENDP ; kdu_codestream::find_tile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_valid_tiles@kdu_codestream@@QAEXAAUkdu_dims@@@Z
_TEXT	SEGMENT
_lim$2$ = -20						; size = 4
_min$2$ = -16						; size = 4
_min$1$ = -12						; size = 4
_lim$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
_den$1$ = 8						; size = 4
_den$1$ = 8						; size = 4
_den$1$ = 8						; size = 4
_indices$ = 8						; size = 4
?get_valid_tiles@kdu_codestream@@QAEXAAUkdu_dims@@@Z PROC ; kdu_codestream::get_valid_tiles, COMDAT
; _this$ = ecx

; 6812 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, ecx
	mov	DWORD PTR _this$1$[ebp], eax
	push	ebx
	push	esi

; 6813 :   kdu_coords min = state->region.pos - state->tile_partition.pos;

	mov	eax, DWORD PTR [eax]
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 199  :   if (num < 0)

	or	edi, -1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	edx, DWORD PTR [eax+212]
	sub	edx, DWORD PTR [eax+152]

; 221  :       /* [SYNOPSIS] Swaps the vertical and horizontal coordinates. */
; 222  :     kdu_coords operator+(const kdu_coords &rhs)
; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	ecx, DWORD PTR [eax+220]

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	ebx, DWORD PTR [eax+208]

; 221  :       /* [SYNOPSIS] Swaps the vertical and horizontal coordinates. */
; 222  :     kdu_coords operator+(const kdu_coords &rhs)
; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	ecx, edx

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ebx, DWORD PTR [eax+148]

; 221  :       /* [SYNOPSIS] Swaps the vertical and horizontal coordinates. */
; 222  :     kdu_coords operator+(const kdu_coords &rhs)
; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	DWORD PTR _lim$1$[ebp], ecx
	mov	ecx, DWORD PTR [eax+216]
	add	ecx, ebx

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	DWORD PTR _min$1$[ebp], edx

; 221  :       /* [SYNOPSIS] Swaps the vertical and horizontal coordinates. */
; 222  :     kdu_coords operator+(const kdu_coords &rhs)
; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	DWORD PTR _lim$2$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6816 :   indices.pos.x = floor_ratio(min.x,state->tile_partition.size.x);

	mov	ecx, DWORD PTR [eax+160]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	DWORD PTR _min$2$[ebp], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 199  :   if (num < 0)

	test	edx, edx
	jns	SHORT $LN14@get_valid_

; 200  :     return -(1+((-num-1)/den));

	mov	eax, edi
	mov	ebx, edi
	sub	eax, edx
	cdq
	idiv	ecx
	sub	ebx, eax
	jmp	SHORT $LN15@get_valid_
$LN14@get_valid_:

; 201  :   else
; 202  :     return num/den;

	mov	eax, edx
	cdq
	idiv	ecx
	mov	ebx, eax
$LN15@get_valid_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6816 :   indices.pos.x = floor_ratio(min.x,state->tile_partition.size.x);

	mov	esi, DWORD PTR _indices$[ebp]

; 6817 :   indices.size.x =

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [esi+4], ebx
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+160]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	mov	ecx, DWORD PTR _lim$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6817 :   indices.size.x =

	mov	DWORD PTR _den$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	ecx, ecx
	jg	SHORT $LN18@get_valid_

; 180  :     return -((-num)/den);

	mov	eax, ecx
	cdq
	idiv	DWORD PTR _den$1$[ebp]
	jmp	SHORT $LN19@get_valid_
$LN18@get_valid_:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ecx-1]
	cdq
	idiv	DWORD PTR _den$1$[ebp]
	inc	eax
$LN19@get_valid_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6817 :   indices.size.x =

	sub	eax, ebx

; 6819 :   if (lim.x <= min.x)

	xor	edx, edx
	cmp	ecx, DWORD PTR _min$1$[ebp]

; 6821 :   indices.pos.y = floor_ratio(min.y,state->tile_partition.size.y);

	mov	ecx, DWORD PTR _this$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 199  :   if (num < 0)

	mov	ebx, DWORD PTR _min$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6819 :   if (lim.x <= min.x)

	cmovle	eax, edx
	mov	DWORD PTR [esi+12], eax

; 6821 :   indices.pos.y = floor_ratio(min.y,state->tile_partition.size.y);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+156]
	mov	DWORD PTR _den$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 199  :   if (num < 0)

	test	ebx, ebx
	jns	SHORT $LN22@get_valid_

; 200  :     return -(1+((-num-1)/den));

	mov	eax, edi
	sub	eax, ebx
	cdq
	idiv	DWORD PTR _den$1$[ebp]
	sub	edi, eax
	jmp	SHORT $LN23@get_valid_
$LN22@get_valid_:

; 201  :   else
; 202  :     return num/den;

	mov	eax, ebx
	cdq
	idiv	DWORD PTR _den$1$[ebp]
	mov	edi, eax
$LN23@get_valid_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6821 :   indices.pos.y = floor_ratio(min.y,state->tile_partition.size.y);

	mov	DWORD PTR [esi], edi

; 6822 :   indices.size.y =

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+156]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	mov	ecx, DWORD PTR _lim$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6822 :   indices.size.y =

	mov	DWORD PTR _den$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	ecx, ecx
	jg	SHORT $LN26@get_valid_

; 180  :     return -((-num)/den);

	mov	eax, ecx
	cdq
	idiv	DWORD PTR _den$1$[ebp]
	jmp	SHORT $LN27@get_valid_
$LN26@get_valid_:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ecx-1]
	cdq
	idiv	DWORD PTR _den$1$[ebp]
	inc	eax
$LN27@get_valid_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6822 :   indices.size.y =

	sub	eax, edi

; 6823 :     ceil_ratio(lim.y,state->tile_partition.size.y) - indices.pos.y;
; 6824 :   if (lim.y <= min.y)

	xor	edx, edx
	cmp	ecx, ebx
	cmovle	eax, edx
	mov	DWORD PTR [esi+8], eax

; 6826 :   indices.to_apparent(state->transpose,state->vflip,state->hflip);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	cmp	BYTE PTR [eax+329], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6826 :   indices.to_apparent(state->transpose,state->vflip,state->hflip);

	mov	bl, BYTE PTR [eax+331]
	mov	dl, BYTE PTR [eax+330]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	je	SHORT $LN30@get_valid_

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, edi
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ecx
$LN30@get_valid_:

; 426  :       if (hflip) pos.x = -(pos.x+size.x-1);

	mov	ecx, 1
	test	bl, bl
	je	SHORT $LN31@get_valid_
	mov	eax, ecx
	sub	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+4], eax
$LN31@get_valid_:

; 427  :       if (vflip) pos.y = -(pos.y+size.y-1);

	test	dl, dl
	je	SHORT $LN32@get_valid_
	sub	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi], ecx
$LN32@get_valid_:
	pop	edi
	pop	esi
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6827 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?get_valid_tiles@kdu_codestream@@QAEXAAUkdu_dims@@@Z ENDP ; kdu_codestream::get_valid_tiles
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_tile_partition@kdu_codestream@@QAEXAAUkdu_dims@@@Z
_TEXT	SEGMENT
_partition$ = 8						; size = 4
?get_tile_partition@kdu_codestream@@QAEXAAUkdu_dims@@@Z PROC ; kdu_codestream::get_tile_partition, COMDAT
; _this$ = ecx

; 6712 : {

	push	ebp
	mov	ebp, esp

; 6713 :   partition = state->tile_partition;

	mov	edx, DWORD PTR _partition$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	movups	xmm0, XMMWORD PTR [eax+148]
	movups	XMMWORD PTR [edx], xmm0

; 6714 : 
; 6715 :   // Convert dimensions to those of the entire partition so geometric
; 6716 :   // transformations produce correct `pos' member
; 6717 :   partition.size.x *= state->tile_span.x;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+168]
	imul	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+12], eax

; 6718 :   partition.size.y *= state->tile_span.y;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+164]
	imul	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [edx+8], eax

; 6719 :   partition.to_apparent(state->transpose,state->vflip,state->hflip);

	mov	eax, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	cmp	BYTE PTR [eax+329], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6719 :   partition.to_apparent(state->transpose,state->vflip,state->hflip);

	mov	bh, BYTE PTR [eax+331]
	mov	bl, BYTE PTR [eax+330]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	je	SHORT $LN5@get_tile_p

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
$LN5@get_tile_p:

; 426  :       if (hflip) pos.x = -(pos.x+size.x-1);

	mov	ecx, 1
	test	bh, bh
	je	SHORT $LN6@get_tile_p
	mov	eax, ecx
	sub	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+4], eax
$LN6@get_tile_p:

; 427  :       if (vflip) pos.y = -(pos.y+size.y-1);

	test	bl, bl
	je	SHORT $LN7@get_tile_p
	sub	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx], ecx
$LN7@get_tile_p:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6720 :   partition.size = state->tile_partition.size; // Put back the element size

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+156]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+160]
	mov	DWORD PTR [edx+12], eax

; 6721 :   if (state->transpose)

	mov	eax, DWORD PTR [esi]
	pop	esi
	pop	ebx
	cmp	BYTE PTR [eax+329], 0
	je	SHORT $LN2@get_tile_p
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [edx+12], ecx
$LN2@get_tile_p:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6723 : }

	pop	ebp
	ret	4
?get_tile_partition@kdu_codestream@@QAEXAAUkdu_dims@@@Z ENDP ; kdu_codestream::get_tile_partition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_dims@kdu_codestream@@QAEXHAAUkdu_dims@@_N@Z
_TEXT	SEGMENT
_lim$2$ = -12						; size = 4
_min$3$ = -8						; size = 4
_lim$1$ = -4						; size = 4
_min$1$ = 8						; size = 4
_comp_idx$ = 8						; size = 4
_dims$ = 12						; size = 4
_y_fact$1$ = 16						; size = 4
_want_output_comps$ = 16				; size = 1
?get_dims@kdu_codestream@@QAEXHAAUkdu_dims@@_N@Z PROC	; kdu_codestream::get_dims, COMDAT
; _this$ = ecx

; 6665 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 6666 :   if (comp_idx < 0)

	mov	esi, DWORD PTR _comp_idx$[ebp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jns	SHORT $LN2@get_dims

; 6667 :     dims = state->region;

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR _dims$[ebp]
	movups	xmm0, XMMWORD PTR [eax+208]
	movups	XMMWORD PTR [edx], xmm0

; 6668 :   else

	jmp	$LN3@get_dims
$LN2@get_dims:

; 6669 :     {
; 6670 :       if (!state->construction_finalized)

	mov	ecx, DWORD PTR [edi]
	cmp	BYTE PTR [ecx+341], 0
	jne	SHORT $LN4@get_dims

; 6671 :         state->finalize_construction();

	call	?finalize_construction@kd_codestream@@QAEXXZ ; kd_codestream::finalize_construction
$LN4@get_dims:

; 6672 :       kd_comp_info *ci = NULL;

	xor	ebx, ebx

; 6673 :       if (want_output_comps &&

	cmp	BYTE PTR _want_output_comps$[ebp], bl
	je	SHORT $LN5@get_dims
	mov	edx, DWORD PTR [edi]
	cmp	DWORD PTR [edx+128], ebx
	jne	SHORT $LN5@get_dims

; 6674 :           (state->component_access_mode == KDU_WANT_OUTPUT_COMPONENTS))
; 6675 :         {
; 6676 :           if (comp_idx < state->num_apparent_output_components)

	cmp	esi, DWORD PTR [edx+124]
	jge	SHORT $LN8@get_dims

; 6677 :             {
; 6678 :               kd_output_comp_info *oci = state->output_comp_info +

	mov	ecx, DWORD PTR [edx+260]
	lea	eax, DWORD PTR [esi+esi*4]
	mov	eax, DWORD PTR [ecx+eax*8+16]
	lea	eax, DWORD PTR [eax+eax*4]

; 6679 :                 state->output_comp_info[comp_idx].from_apparent;
; 6680 :               ci = oci->subsampling_ref;

	mov	ebx, DWORD PTR [ecx+eax*8+8]

; 6681 :             }
; 6682 :         }
; 6683 :       else

	jmp	SHORT $LN8@get_dims
$LN5@get_dims:

; 6684 :         {
; 6685 :           if (comp_idx < state->num_apparent_components)

	mov	edx, DWORD PTR [edi]
	cmp	esi, DWORD PTR [edx+116]
	jge	SHORT $LN8@get_dims

; 6686 :             ci = state->comp_info[comp_idx].from_apparent;

	mov	eax, DWORD PTR [edx+256]
	lea	ecx, DWORD PTR [esi+esi*2]
	shl	ecx, 5
	mov	ebx, DWORD PTR [eax+ecx+92]
$LN8@get_dims:

; 6687 :         }
; 6688 : 
; 6689 :       kdu_coords min = state->region.pos;

	mov	eax, DWORD PTR [edx+208]

; 6694 :         ci->sub_sampling.x << ci->hor_depth[state->discard_levels];

	mov	esi, DWORD PTR [ebx+4]
	mov	DWORD PTR _min$3$[ebp], eax
	mov	eax, DWORD PTR [edx+212]
	mov	DWORD PTR _min$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	eax, DWORD PTR [edx+220]
	add	eax, DWORD PTR [edx+212]
	mov	DWORD PTR _lim$1$[ebp], eax
	mov	eax, DWORD PTR [edx+216]
	add	eax, DWORD PTR [edx+208]
	mov	DWORD PTR _lim$2$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6692 :         ci->sub_sampling.y << ci->vert_depth[state->discard_levels];

	mov	eax, DWORD PTR [edx+188]
	mov	edx, DWORD PTR [ebx]
	movzx	ecx, BYTE PTR [eax+ebx+54]
	shl	edx, cl

; 6694 :         ci->sub_sampling.x << ci->hor_depth[state->discard_levels];

	movzx	ecx, BYTE PTR [eax+ebx+21]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _min$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6694 :         ci->sub_sampling.x << ci->hor_depth[state->discard_levels];

	shl	esi, cl
	mov	DWORD PTR _y_fact$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN15@get_dims

; 180  :     return -((-num)/den);

	cdq
	idiv	esi
	mov	ebx, eax
	jmp	SHORT $LN16@get_dims
$LN15@get_dims:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	esi
	lea	ebx, DWORD PTR [eax+1]
$LN16@get_dims:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _lim$1$[ebp]
	test	eax, eax
	jg	SHORT $LN19@get_dims

; 180  :     return -((-num)/den);

	cdq
	idiv	esi
	mov	ecx, eax
	jmp	SHORT $LN20@get_dims
$LN19@get_dims:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	esi
	lea	ecx, DWORD PTR [eax+1]
$LN20@get_dims:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _min$3$[ebp]
	test	eax, eax
	jg	SHORT $LN23@get_dims

; 180  :     return -((-num)/den);

	cdq
	idiv	DWORD PTR _y_fact$1$[ebp]
	mov	esi, eax
	jmp	SHORT $LN24@get_dims
$LN23@get_dims:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	DWORD PTR _y_fact$1$[ebp]
	lea	esi, DWORD PTR [eax+1]
$LN24@get_dims:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _lim$2$[ebp]
	test	eax, eax
	jg	SHORT $LN27@get_dims

; 180  :     return -((-num)/den);

	cdq
	idiv	DWORD PTR _y_fact$1$[ebp]
	jmp	SHORT $LN28@get_dims
$LN27@get_dims:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	DWORD PTR _y_fact$1$[ebp]
	inc	eax
$LN28@get_dims:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6700 :       dims.pos = min;

	mov	edx, DWORD PTR _dims$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ecx, ebx
	sub	eax, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6700 :       dims.pos = min;

	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], ebx

; 6701 :       dims.size = lim-min;

	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [edx+12], ecx
$LN3@get_dims:

; 6703 :   dims.to_apparent(state->transpose,state->vflip,state->hflip);

	mov	eax, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	cmp	BYTE PTR [eax+329], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6703 :   dims.to_apparent(state->transpose,state->vflip,state->hflip);

	mov	bl, BYTE PTR [eax+331]
	mov	bh, BYTE PTR [eax+330]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	je	SHORT $LN35@get_dims

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
$LN35@get_dims:

; 426  :       if (hflip) pos.x = -(pos.x+size.x-1);

	mov	ecx, 1
	test	bl, bl
	je	SHORT $LN36@get_dims
	mov	eax, ecx
	sub	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx+4], eax
$LN36@get_dims:
	pop	edi
	pop	esi

; 427  :       if (vflip) pos.y = -(pos.y+size.y-1);

	test	bh, bh
	pop	ebx
	je	SHORT $LN37@get_dims
	sub	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx], ecx
$LN37@get_dims:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6704 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get_dims@kdu_codestream@@QAEXHAAUkdu_dims@@_N@Z ENDP	; kdu_codestream::get_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_registration@kdu_codestream@@QAEXHUkdu_coords@@AAU2@_N@Z
_TEXT	SEGMENT
tv293 = -16						; size = 8
tv287 = -16						; size = 8
tv302 = -8						; size = 8
tv296 = -8						; size = 8
_comp_idx$ = 8						; size = 4
_scale$ = 12						; size = 8
_reg$ = 20						; size = 4
_ci$1$ = 24						; size = 4
_want_output_comps$ = 24				; size = 1
?get_registration@kdu_codestream@@QAEXHUkdu_coords@@AAU2@_N@Z PROC ; kdu_codestream::get_registration, COMDAT
; _this$ = ecx

; 6630 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	edi
	mov	edi, ecx

; 6631 :   if (!state->construction_finalized)

	mov	ecx, DWORD PTR [edi]
	cmp	BYTE PTR [ecx+341], 0
	jne	SHORT $LN2@get_regist

; 6632 :     state->finalize_construction();

	call	?finalize_construction@kd_codestream@@QAEXXZ ; kd_codestream::finalize_construction
$LN2@get_regist:

; 6633 :   if (comp_idx < 0)

	mov	eax, DWORD PTR _comp_idx$[ebp]
	test	eax, eax
	jns	SHORT $LN3@get_regist
$LN29@get_regist:

; 6634 :     { reg = kdu_coords(0,0); return; }

	mov	eax, DWORD PTR _reg$[ebp]
	pop	edi
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 6656 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN3@get_regist:

; 6635 :   kd_comp_info *ci;
; 6636 :   if (want_output_comps &&

	cmp	BYTE PTR _want_output_comps$[ebp], 0
	je	SHORT $LN4@get_regist
	mov	edx, DWORD PTR [edi]
	cmp	DWORD PTR [edx+128], 0
	jne	SHORT $LN4@get_regist

; 6637 :       (state->component_access_mode == KDU_WANT_OUTPUT_COMPONENTS))
; 6638 :     {
; 6639 :       if (comp_idx >= state->num_apparent_output_components)

	cmp	eax, DWORD PTR [edx+124]
	jge	SHORT $LN29@get_regist

; 6640 :         { reg = kdu_coords(0,0); return; }
; 6641 :       kd_output_comp_info *oci = state->output_comp_info +

	mov	ecx, DWORD PTR [edx+260]
	lea	eax, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+eax*8+16]
	lea	eax, DWORD PTR [eax+eax*4]

; 6642 :         state->output_comp_info[comp_idx].from_apparent;
; 6643 :       ci = oci->subsampling_ref;

	mov	ecx, DWORD PTR [ecx+eax*8+8]

; 6644 :     }
; 6645 :   else

	jmp	SHORT $LN28@get_regist
$LN4@get_regist:

; 6646 :     {
; 6647 :       if (comp_idx >= state->num_apparent_components)

	mov	edx, DWORD PTR [edi]
	cmp	eax, DWORD PTR [edx+116]
	jge	SHORT $LN29@get_regist

; 6648 :         { reg = kdu_coords(0,0); return; }
; 6649 :       ci = state->comp_info[comp_idx].from_apparent;

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edx+256]
	shl	ecx, 5
	mov	ecx, DWORD PTR [eax+ecx+92]
$LN28@get_regist:

; 6650 :     }
; 6651 :   if (state->transpose)

	cmp	BYTE PTR [edx+329], 0
	push	ebx
	mov	DWORD PTR _ci$1$[ebp], ecx
	push	esi
	je	SHORT $LN27@get_regist
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, DWORD PTR _scale$[ebp]
	mov	ebx, DWORD PTR _scale$[ebp+4]
	mov	DWORD PTR _scale$[ebp], ebx
	mov	DWORD PTR _scale$[ebp+4], eax
	jmp	SHORT $LN8@get_regist
$LN27@get_regist:
	mov	eax, DWORD PTR _scale$[ebp+4]
	mov	ebx, DWORD PTR _scale$[ebp]
$LN8@get_regist:
	movd	xmm0, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6653 :   reg.x = (int) floor(ci->crg_x*scale.x+0.5);

	sub	esp, 8
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR [ecx+8]
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv302[ebp], xmm0
	fld	QWORD PTR tv302[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	mov	esi, DWORD PTR _reg$[ebp]
	fstp	QWORD PTR tv296[ebp]
	cvttsd2si eax, QWORD PTR tv296[ebp]
	movd	xmm0, ebx

; 6654 :   reg.y = (int) floor(ci->crg_y*scale.y+0.5);

	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR _ci$1$[ebp]
	mulss	xmm0, DWORD PTR [eax+12]
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv293[ebp], xmm0
	fld	QWORD PTR tv293[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	fstp	QWORD PTR tv287[ebp]
	cvttsd2si ecx, QWORD PTR tv287[ebp]
	add	esp, 8
	mov	DWORD PTR [esi], ecx

; 6655 :   reg.to_apparent(state->transpose,state->vflip,state->hflip);

	mov	eax, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 275  :         if (transp) transpose();

	cmp	BYTE PTR [eax+329], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6655 :   reg.to_apparent(state->transpose,state->vflip,state->hflip);

	mov	dl, BYTE PTR [eax+331]
	mov	bl, BYTE PTR [eax+330]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 275  :         if (transp) transpose();

	je	SHORT $LN19@get_regist

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	cvttsd2si eax, QWORD PTR tv296[ebp]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi], eax
$LN19@get_regist:

; 276  :         x = (hflip)?(-x):x;

	mov	eax, DWORD PTR [esi+4]
	test	dl, dl
	je	SHORT $LN22@get_regist
	neg	eax
$LN22@get_regist:
	mov	DWORD PTR [esi+4], eax

; 277  :         y = (vflip)?(-y):y;

	mov	eax, DWORD PTR [esi]
	test	bl, bl
	je	SHORT $LN24@get_regist
	neg	eax
$LN24@get_regist:
	mov	DWORD PTR [esi], eax
	pop	esi
	pop	ebx
	pop	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6656 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?get_registration@kdu_codestream@@QAEXHUkdu_coords@@AAU2@_N@Z ENDP ; kdu_codestream::get_registration
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_subsampling@kdu_codestream@@QAEXHAAUkdu_coords@@_N@Z
_TEXT	SEGMENT
_comp_idx$ = 8						; size = 4
_subs$ = 12						; size = 4
tv271 = 16						; size = 4
_want_output_comps$ = 16				; size = 1
?get_subsampling@kdu_codestream@@QAEXHAAUkdu_coords@@_N@Z PROC ; kdu_codestream::get_subsampling, COMDAT
; _this$ = ecx

; 6595 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 6596 :   if (!state->construction_finalized)

	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx+341], 0
	jne	SHORT $LN2@get_subsam

; 6597 :     state->finalize_construction();

	call	?finalize_construction@kd_codestream@@QAEXXZ ; kd_codestream::finalize_construction
$LN2@get_subsam:

; 6598 :   if (comp_idx < 0)

	mov	eax, DWORD PTR _comp_idx$[ebp]
	test	eax, eax
	jns	SHORT $LN3@get_subsam

; 6599 :     { subs = kdu_coords(0,0); return; }

	mov	eax, DWORD PTR _subs$[ebp]
	pop	esi
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 6621 : }

	pop	ebp
	ret	12					; 0000000cH
$LN3@get_subsam:

; 6600 :   kd_comp_info *ci;
; 6601 :   if (want_output_comps &&

	cmp	BYTE PTR _want_output_comps$[ebp], 0
	push	edi
	je	SHORT $LN4@get_subsam
	mov	ecx, DWORD PTR [esi]
	cmp	DWORD PTR [ecx+128], 0
	jne	SHORT $LN4@get_subsam

; 6602 :       (state->component_access_mode == KDU_WANT_OUTPUT_COMPONENTS))
; 6603 :     {
; 6604 :       if (comp_idx >= state->num_apparent_output_components)

	cmp	eax, DWORD PTR [ecx+124]
	jge	SHORT $LN20@get_subsam

; 6605 :         { subs = kdu_coords(0,0); return; }
; 6606 :       kd_output_comp_info *oci = state->output_comp_info +

	mov	ecx, DWORD PTR [ecx+260]
	lea	eax, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+eax*8+16]
	lea	eax, DWORD PTR [eax+eax*4]

; 6607 :         state->output_comp_info[comp_idx].from_apparent;
; 6608 :       ci = oci->subsampling_ref;

	mov	edi, DWORD PTR [ecx+eax*8+8]

; 6609 :     }
; 6610 :   else

	jmp	SHORT $LN5@get_subsam
$LN4@get_subsam:

; 6611 :     {
; 6612 :       if (comp_idx >= state->num_apparent_components)

	mov	edx, DWORD PTR [esi]
	cmp	eax, DWORD PTR [edx+116]
	jl	SHORT $LN7@get_subsam
$LN20@get_subsam:

; 6613 :         { subs = kdu_coords(0,0); return; }

	mov	eax, DWORD PTR _subs$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 6621 : }

	pop	ebp
	ret	12					; 0000000cH
$LN7@get_subsam:

; 6614 :       ci = state->comp_info[comp_idx].from_apparent;

	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edx+256]
	shl	ecx, 5
	mov	edi, DWORD PTR [eax+ecx+92]
$LN5@get_subsam:

; 6615 :     }
; 6616 :   subs = ci->sub_sampling;

	mov	edx, DWORD PTR _subs$[ebp]
	mov	eax, DWORD PTR [edi]
	push	ebx
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edx+4], eax

; 6617 :   subs.x <<= ci->hor_depth[state->discard_levels];

	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax+188]
	movzx	ecx, BYTE PTR [eax+edi+21]
	shl	ebx, cl
	mov	DWORD PTR [edx+4], ebx

; 6618 :   subs.y <<= ci->vert_depth[state->discard_levels];

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+188]
	movzx	ecx, BYTE PTR [eax+edi+54]
	mov	edi, DWORD PTR [edx]
	shl	edi, cl
	mov	DWORD PTR [edx], edi

; 6619 :   if (state->transpose)

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+329], 0
	je	SHORT $LN19@get_subsam
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	DWORD PTR [edx], ebx
	mov	DWORD PTR [edx+4], edi
$LN19@get_subsam:
	pop	ebx
	pop	edi
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6621 : }

	pop	ebp
	ret	12					; 0000000cH
?get_subsampling@kdu_codestream@@QAEXHAAUkdu_coords@@_N@Z ENDP ; kdu_codestream::get_subsampling
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_signed@kdu_codestream@@QAE_NH_N@Z
_TEXT	SEGMENT
_comp_idx$ = 8						; size = 4
_want_output_comps$ = 12				; size = 1
?get_signed@kdu_codestream@@QAE_NH_N@Z PROC		; kdu_codestream::get_signed, COMDAT
; _this$ = ecx

; 6567 : {

	push	ebp
	mov	ebp, esp

; 6568 :   if (comp_idx < 0)

	mov	eax, DWORD PTR _comp_idx$[ebp]
	test	eax, eax
	jns	SHORT $LN2@get_signed
$LN8@get_signed:

; 6569 :     return false; // Invalid component

	xor	al, al

; 6585 :     }
; 6586 : }

	pop	ebp
	ret	8
$LN2@get_signed:

; 6570 :   if (want_output_comps &&

	cmp	BYTE PTR _want_output_comps$[ebp], 0
	je	SHORT $LN3@get_signed
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+128], 0
	jne	SHORT $LN3@get_signed

; 6571 :       (state->component_access_mode == KDU_WANT_OUTPUT_COMPONENTS))
; 6572 :     {
; 6573 :       if (comp_idx >= state->num_apparent_output_components)

	cmp	eax, DWORD PTR [edx+124]
	jge	SHORT $LN8@get_signed

; 6574 :         return false;
; 6575 :       kd_output_comp_info *ci = state->output_comp_info +

	mov	edx, DWORD PTR [edx+260]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	ecx, DWORD PTR [edx+ecx*8+16]
	lea	eax, DWORD PTR [ecx+ecx*4]

; 6576 :         state->output_comp_info[comp_idx].from_apparent;
; 6577 :       return ci->is_signed;

	mov	al, BYTE PTR [edx+eax*8+4]

; 6585 :     }
; 6586 : }

	pop	ebp
	ret	8
$LN3@get_signed:

; 6578 :     }
; 6579 :   else
; 6580 :     {
; 6581 :       if (comp_idx >= state->num_apparent_components)

	mov	edx, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+116]
	jge	SHORT $LN8@get_signed

; 6582 :         return false;
; 6583 :       kd_comp_info *ci = state->comp_info[comp_idx].from_apparent;

	lea	ecx, DWORD PTR [eax+eax*2]

; 6584 :       return ci->is_signed;

	mov	eax, DWORD PTR [edx+256]
	shl	ecx, 5
	mov	eax, DWORD PTR [eax+ecx+92]
	mov	al, BYTE PTR [eax+20]

; 6585 :     }
; 6586 : }

	pop	ebp
	ret	8
?get_signed@kdu_codestream@@QAE_NH_N@Z ENDP		; kdu_codestream::get_signed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_bit_depth@kdu_codestream@@QAEHH_N@Z
_TEXT	SEGMENT
_comp_idx$ = 8						; size = 4
_want_output_comps$ = 12				; size = 1
?get_bit_depth@kdu_codestream@@QAEHH_N@Z PROC		; kdu_codestream::get_bit_depth, COMDAT
; _this$ = ecx

; 6540 : {

	push	ebp
	mov	ebp, esp

; 6541 :   if (comp_idx < 0)

	mov	eax, DWORD PTR _comp_idx$[ebp]
	test	eax, eax
	jns	SHORT $LN2@get_bit_de
$LN8@get_bit_de:

; 6542 :     return 0; // Invalid component

	xor	eax, eax

; 6558 :     }
; 6559 : }

	pop	ebp
	ret	8
$LN2@get_bit_de:

; 6543 :   if (want_output_comps &&

	cmp	BYTE PTR _want_output_comps$[ebp], 0
	je	SHORT $LN3@get_bit_de
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+128], 0
	jne	SHORT $LN3@get_bit_de

; 6544 :       (state->component_access_mode == KDU_WANT_OUTPUT_COMPONENTS))
; 6545 :     {
; 6546 :       if (comp_idx >= state->num_apparent_output_components)

	cmp	eax, DWORD PTR [edx+124]
	jge	SHORT $LN8@get_bit_de

; 6547 :         return 0;
; 6548 :       kd_output_comp_info *ci = state->output_comp_info +

	mov	edx, DWORD PTR [edx+260]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	ecx, DWORD PTR [edx+ecx*8+16]
	lea	eax, DWORD PTR [ecx+ecx*4]

; 6549 :         state->output_comp_info[comp_idx].from_apparent;
; 6550 :       return ci->precision;

	mov	eax, DWORD PTR [edx+eax*8]

; 6558 :     }
; 6559 : }

	pop	ebp
	ret	8
$LN3@get_bit_de:

; 6551 :     }
; 6552 :   else
; 6553 :     {
; 6554 :       if (comp_idx >= state->num_apparent_components)

	mov	edx, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+116]
	jge	SHORT $LN8@get_bit_de

; 6555 :         return 0;
; 6556 :       kd_comp_info *ci = state->comp_info[comp_idx].from_apparent;

	lea	ecx, DWORD PTR [eax+eax*2]

; 6557 :       return ci->precision;

	mov	eax, DWORD PTR [edx+256]
	shl	ecx, 5
	mov	eax, DWORD PTR [eax+ecx+92]
	mov	eax, DWORD PTR [eax+16]

; 6558 :     }
; 6559 : }

	pop	ebp
	ret	8
?get_bit_depth@kdu_codestream@@QAEHH_N@Z ENDP		; kdu_codestream::get_bit_depth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_num_components@kdu_codestream@@QAEH_N@Z
_TEXT	SEGMENT
_want_output_comps$ = 8					; size = 1
?get_num_components@kdu_codestream@@QAEH_N@Z PROC	; kdu_codestream::get_num_components, COMDAT
; _this$ = ecx

; 6526 : {

	push	ebp
	mov	ebp, esp

; 6527 :   if (want_output_comps &&

	cmp	BYTE PTR _want_output_comps$[ebp], 0
	je	SHORT $LN2@get_num_co
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax+128], 0
	jne	SHORT $LN2@get_num_co

; 6528 :       (state->component_access_mode == KDU_WANT_OUTPUT_COMPONENTS))
; 6529 :     return state->num_apparent_output_components;

	mov	eax, DWORD PTR [eax+124]

; 6532 : }

	pop	ebp
	ret	4
$LN2@get_num_co:

; 6530 :   else
; 6531 :     return state->num_apparent_components;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+116]

; 6532 : }

	pop	ebp
	ret	4
?get_num_components@kdu_codestream@@QAEH_N@Z ENDP	; kdu_codestream::get_num_components
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?access_siz@kdu_codestream@@QAEPAVsiz_params@@XZ
_TEXT	SEGMENT
?access_siz@kdu_codestream@@QAEPAVsiz_params@@XZ PROC	; kdu_codestream::access_siz, COMDAT
; _this$ = ecx

; 6152 :   return state->siz;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]

; 6153 : }

	ret	0
?access_siz@kdu_codestream@@QAEPAVsiz_params@@XZ ENDP	; kdu_codestream::access_siz
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?is_last_fragment@kdu_codestream@@QAE_NXZ
_TEXT	SEGMENT
?is_last_fragment@kdu_codestream@@QAE_NXZ PROC		; kdu_codestream::is_last_fragment, COMDAT
; _this$ = ecx

; 6142 :   return (state!=NULL) && (state->out!=NULL) && state->final_fragment;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@is_last_fr
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@is_last_fr
	cmp	BYTE PTR [eax+226], 0
	je	SHORT $LN3@is_last_fr
	mov	al, 1

; 6143 : }

	ret	0
$LN3@is_last_fr:

; 6142 :   return (state!=NULL) && (state->out!=NULL) && state->final_fragment;

	xor	al, al

; 6143 : }

	ret	0
?is_last_fragment@kdu_codestream@@QAE_NXZ ENDP		; kdu_codestream::is_last_fragment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_tile_unloading_threshold@kdu_codestream@@QAEHH@Z
_TEXT	SEGMENT
_max_tiles_on_list$ = 8					; size = 4
?set_tile_unloading_threshold@kdu_codestream@@QAEHH@Z PROC ; kdu_codestream::set_tile_unloading_threshold, COMDAT
; _this$ = ecx

; 6091 : {

	push	ebp
	mov	ebp, esp

; 6092 :   if (max_tiles_on_list < 0)

	mov	eax, DWORD PTR _max_tiles_on_list$[ebp]
	xor	edx, edx
	test	eax, eax
	push	esi
	cmovs	eax, edx

; 6093 :     max_tiles_on_list = 0;
; 6094 :   int prev_value = state->max_unloadable_tiles;

	mov	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [edx+408]

; 6095 :   state->max_unloadable_tiles = max_tiles_on_list;

	mov	DWORD PTR [edx+408], eax

; 6096 :   state->unload_tiles_to_cache_threshold();

	mov	ecx, DWORD PTR [ecx]
	call	?unload_tiles_to_cache_threshold@kd_codestream@@QAEXXZ ; kd_codestream::unload_tiles_to_cache_threshold

; 6097 :   return prev_value;

	mov	eax, esi
	pop	esi

; 6098 : }

	pop	ebp
	ret	4
?set_tile_unloading_threshold@kdu_codestream@@QAEHH@Z ENDP ; kdu_codestream::set_tile_unloading_threshold
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?augment_cache_threshold@kdu_codestream@@QAE_JH@Z
_TEXT	SEGMENT
_extra_bytes$ = 8					; size = 4
?augment_cache_threshold@kdu_codestream@@QAE_JH@Z PROC	; kdu_codestream::augment_cache_threshold, COMDAT
; _this$ = ecx

; 6081 : {

	push	ebp
	mov	ebp, esp

; 6082 :   return state->buf_server->augment_cache_threshold(extra_bytes);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR _extra_bytes$[ebp]
	cdq
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 286  :         return (cache_threshold_bytes += increment);

	add	eax, DWORD PTR [ecx+48]
	mov	DWORD PTR [ecx+48], eax
	adc	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [ecx+52], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6083 : }

	pop	ebp
	ret	4
?augment_cache_threshold@kdu_codestream@@QAE_JH@Z ENDP	; kdu_codestream::augment_cache_threshold
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?set_persistent@kdu_codestream@@QAEXXZ
_TEXT	SEGMENT
_e$2 = -32						; size = 20
__$EHRec$ = -12						; size = 12
?set_persistent@kdu_codestream@@QAEXXZ PROC		; kdu_codestream::set_persistent, COMDAT
; _this$ = ecx

; 6124 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?set_persistent@kdu_codestream@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 6125 :   if (state->in == NULL)

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@set_persis

; 6126 :     return;
; 6127 :   if (state->tiles_accessed)

	cmp	BYTE PTR [eax+340], 0
	je	SHORT $LN3@set_persis

; 6128 :     { KDU_ERROR_DEV(e,49); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0GD@FICOODEH@You?5may?5only?5set?5the?5codestream?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6128 :     { KDU_ERROR_DEV(e,49); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6131 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN3@set_persis:

; 6132 :   state->persistent = true;

	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+337], 1
$LN1@set_persis:

; 6133 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?set_persistent@kdu_codestream@@QAEXXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?set_persistent@kdu_codestream@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?set_persistent@kdu_codestream@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?set_persistent@kdu_codestream@@QAEXXZ ENDP		; kdu_codestream::set_persistent
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?enable_restart@kdu_codestream@@QAEXXZ
_TEXT	SEGMENT
_e$2 = -32						; size = 20
__$EHRec$ = -12						; size = 12
?enable_restart@kdu_codestream@@QAEXXZ PROC		; kdu_codestream::enable_restart, COMDAT
; _this$ = ecx

; 6107 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?enable_restart@kdu_codestream@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 6108 :   if (state->allow_restart)

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+328], 0
	jne	SHORT $LN1@enable_res

; 6109 :     return;
; 6110 :   if (state->tiles_accessed)

	cmp	BYTE PTR [eax+340], 0
	je	SHORT $LN3@enable_res

; 6111 :     { KDU_ERROR_DEV(e,48); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0FA@JIHDPBJH@You?5may?5not?5call?5?$GAkdu_codestream@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6111 :     { KDU_ERROR_DEV(e,48); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6114 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN3@enable_res:

; 6115 :   state->allow_restart = true;

	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+328], 1
$LN1@enable_res:

; 6116 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?enable_restart@kdu_codestream@@QAEXXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?enable_restart@kdu_codestream@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?enable_restart@kdu_codestream@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?enable_restart@kdu_codestream@@QAEXXZ ENDP		; kdu_codestream::enable_restart
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?destroy@kdu_codestream@@QAEXXZ
_TEXT	SEGMENT
?destroy@kdu_codestream@@QAEXXZ PROC			; kdu_codestream::destroy, COMDAT
; _this$ = ecx

; 6041 : {

	push	esi
	mov	esi, ecx
	push	edi

; 6042 :   assert(state != NULL);
; 6043 :   delete state;

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN9@destroy
	mov	ecx, edi
	call	??1kd_codestream@@QAE@XZ		; kd_codestream::~kd_codestream
	push	416					; 000001a0H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@destroy:
	pop	edi

; 6044 :   state = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 6045 : }

	ret	0
?destroy@kdu_codestream@@QAEXXZ ENDP			; kdu_codestream::destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?share_buffering@kdu_codestream@@QAEXV1@@Z
_TEXT	SEGMENT
_e$2 = -36						; size = 20
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_existing$ = 8						; size = 4
?share_buffering@kdu_codestream@@QAEXV1@@Z PROC		; kdu_codestream::share_buffering, COMDAT
; _this$ = ecx

; 6053 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?share_buffering@kdu_codestream@@QAEXV1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 277  :       { return peak_structure_bytes; }

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6055 :   if ((state->buf_server->get_peak_structure_bytes() > 0) ||

	cmp	DWORD PTR [eax+44], 0
	jg	SHORT $LN35@share_buff
	jl	SHORT $LN34@share_buff
	cmp	DWORD PTR [eax+40], 0
	ja	SHORT $LN35@share_buff
$LN34@share_buff:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 271  :         return (kdu_long)(peak_allocated_pages * KD_CODE_BUFFER_LEN *

	push	0
	push	232					; 000000e8H
	push	DWORD PTR [eax+28]
	push	DWORD PTR [eax+24]
	call	__allmul
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6055 :   if ((state->buf_server->get_peak_structure_bytes() > 0) ||

	test	edx, edx
	jl	SHORT $LN2@share_buff
	jg	SHORT $LN35@share_buff
	test	eax, eax
	je	SHORT $LN2@share_buff
$LN35@share_buff:

; 6057 :     { KDU_ERROR_DEV(e,47); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0LL@KPFADBNA@You?5cannot?5use?5the?5?$GAkdu_codestre@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6057 :     { KDU_ERROR_DEV(e,47); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6062 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@share_buff:

; 6063 :   state->buf_server->detach();

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 243  :       { assert(num_users > 0); num_users--; }

	dec	DWORD PTR [eax+56]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6064 :   delete state->buf_server;

	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR [eax+24]
	test	edi, edi
	je	SHORT $LN23@share_buff
	mov	ecx, edi
	call	??1kd_buf_server@@QAE@XZ		; kd_buf_server::~kd_buf_server
	push	64					; 00000040H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN23@share_buff:

; 6065 :   if (state->precinct_server != NULL)

	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR [eax+40]
	test	edi, edi
	je	SHORT $LN4@share_buff

; 6066 :     {
; 6067 :       delete state->precinct_server;
; 6068 :       state->precinct_server = NULL;

	mov	ecx, edi
	call	??1kd_precinct_server@@QAE@XZ		; kd_precinct_server::~kd_precinct_server
	push	32					; 00000020H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	mov	eax, DWORD PTR [esi]
	add	esp, 8
	mov	DWORD PTR [eax+40], 0
$LN4@share_buff:

; 6069 :     }
; 6070 :   state->buf_server = existing.state->buf_server;

	mov	eax, DWORD PTR _existing$[ebp]
	mov	ecx, DWORD PTR [esi]

; 6072 :   state->precinct_server = new kd_precinct_server(state->buf_server);

	push	32					; 00000020H
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 241  :       { num_users++; }

	inc	DWORD PTR [eax+56]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6072 :   state->precinct_server = new kd_precinct_server(state->buf_server);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T3[ebp], edx
	test	edx, edx
	je	SHORT $LN10@share_buff
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4470 :       { size_classes = NULL; total_allocated_bytes = 0;

	mov	DWORD PTR [edx], 0
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0

; 4471 :         inactive_head = inactive_tail = NULL; this->buf_server = buf_server; }

	mov	DWORD PTR [edx+20], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+24], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6072 :   state->precinct_server = new kd_precinct_server(state->buf_server);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+40], edx

; 6073 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN10@share_buff:

; 6072 :   state->precinct_server = new kd_precinct_server(state->buf_server);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+40], 0

; 6073 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?share_buffering@kdu_codestream@@QAEXV1@@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?share_buffering@kdu_codestream@@QAEXV1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?share_buffering@kdu_codestream@@QAEXV1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?share_buffering@kdu_codestream@@QAEXV1@@Z ENDP		; kdu_codestream::share_buffering
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_siz$ = -144						; size = 88
_e$2 = -56						; size = 20
_e$3 = -36						; size = 20
_e$4 = -36						; size = 20
_e$5 = -36						; size = 20
_c$1$ = -16						; size = 4
$T6 = -16						; size = 4
$T7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_c$1$ = 8						; size = 4
tv1000 = 8						; size = 4
$T8 = 8							; size = 4
$T9 = 8							; size = 4
$T10 = 8						; size = 4
_source$ = 8						; size = 4
_env$ = 12						; size = 4
?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z PROC ; kdu_codestream::restart, COMDAT
; _this$ = ecx

; 5931 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 5932 :   if (!state->allow_restart)

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+328], 0
	jne	SHORT $LN8@restart

; 5933 :     { KDU_ERROR_DEV(e,43); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0KI@GFLIIJEF@You?5may?5not?5use?5the?5?$GAkdu_codestr@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5933 :     { KDU_ERROR_DEV(e,43); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5937 :     }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN8@restart:

; 5938 :   if (state->in == NULL)

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@restart

; 5939 :     { KDU_ERROR_DEV(e,44); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0MB@GNICMEAH@You?5may?5not?5use?5the?5input?5form?5o@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5939 :     { KDU_ERROR_DEV(e,44); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5944 :     }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN9@restart:

; 5945 : 
; 5946 :   if (env != NULL)

	mov	ebx, DWORD PTR _env$[ebp]
	test	ebx, ebx
	je	SHORT $LN50@restart
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [ebx+28]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN49@restart
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T8[ebp], eax
	lea	eax, DWORD PTR $T8[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN105@restart:
$LN49@restart:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN53@restart
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN53@restart:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+4], ebx
$LN50@restart:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5948 :   delete state->in;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN21@restart
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN21@restart:

; 5949 :   state->in = new kd_compressed_input(source);

	push	600					; 00000258H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN23@restart
	push	DWORD PTR _source$[ebp]
	mov	ecx, eax
	call	??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z ; kd_compressed_input::kd_compressed_input
	mov	ecx, eax
	jmp	SHORT $LN24@restart
$LN23@restart:
	xor	ecx, ecx
$LN24@restart:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [eax+4], ecx

; 5950 :   delete state->marker;

	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR [eax+16]
	test	edi, edi
	je	SHORT $LN57@restart
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN61@restart
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN61@restart:
	push	28					; 0000001cH
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN57@restart:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5951 :   state->marker = new kd_marker(state->in,state);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T6[ebp], edi
	test	edi, edi
	je	SHORT $LN27@restart
	mov	edx, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 837  :         code = 0; length = 0; max_length = 0; buf = NULL;

	xor	eax, eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [edi], ecx
	mov	DWORD PTR [edi+4], edx
	mov	WORD PTR [edi+8], ax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], eax

; 838  :         encountered_skip_code = false; }

	mov	BYTE PTR [edi+24], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5951 :   state->marker = new kd_marker(state->in,state);

	jmp	SHORT $LN28@restart
$LN27@restart:
	xor	edi, edi
$LN28@restart:
	mov	eax, DWORD PTR [esi]

; 5952 :   state->cached = (source->get_capabilities() & KDU_SOURCE_CAP_CACHED) != 0;

	mov	ecx, DWORD PTR _source$[ebp]
	mov	DWORD PTR [eax+16], edi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [esi]
	shr	eax, 2
	and	al, 1

; 5955 :   if ((!state->marker->read()) ||

	push	0
	mov	BYTE PTR [ecx+338], al
	mov	ecx, DWORD PTR [esi]
	push	0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 487  :     bool is_fully_buffered() { return fully_buffered; }

	mov	eax, DWORD PTR [ecx+4]
	mov	al, BYTE PTR [eax+532]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5953 :   state->in_memory_source = state->in->is_fully_buffered();

	mov	BYTE PTR [ecx+339], al

; 5954 :   state->block_truncation_factor = 0;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+344], 0

; 5955 :   if ((!state->marker->read()) ||

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+16]
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
	test	al, al
	je	SHORT $LN12@restart
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	eax, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5955 :   if ((!state->marker->read()) ||

	mov	ecx, 65359				; 0000ff4fH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	eax, DWORD PTR [eax+16]
	movzx	eax, WORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5955 :   if ((!state->marker->read()) ||

	cmp	ax, cx
	je	SHORT $LN11@restart
$LN12@restart:

; 5957 :     { KDU_ERROR(e,45); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0CL@KMFCLNLD@Code?9stream?5must?5start?5with?5an?5S@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5957 :     { KDU_ERROR(e,45); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5959 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN11@restart:

; 5960 : 
; 5961 :   // Read the SIZ marker segment and determine whether or not the high
; 5962 :   // level structure has changed; if so, we might as well create the internal
; 5963 :   // machinery again from scratch.
; 5964 :   siz_params siz;

	lea	ecx, DWORD PTR _siz$[ebp]
	call	??0siz_params@@QAE@XZ			; siz_params::siz_params

; 5965 :   siz.copy_from(state->siz,-1,-1);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _siz$[ebp]
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	DWORD PTR [eax+12]
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	call	?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z ; kdu_params::copy_from

; 5966 :   siz.clear_marks(); // So we will be able to tell if anything changed

	lea	ecx, DWORD PTR _siz$[ebp]
	call	?clear_marks@kdu_params@@QAEXXZ		; kdu_params::clear_marks

; 5967 :   if (!(state->marker->read() &&

	mov	ecx, DWORD PTR [esi]
	push	0
	push	0
	mov	ecx, DWORD PTR [ecx+16]
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
	test	al, al
	je	SHORT $LN14@restart
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	eax, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5967 :   if (!(state->marker->read() &&

	push	0
	push	-1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	eax, DWORD PTR [eax+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5967 :   if (!(state->marker->read() &&

	push	DWORD PTR [eax+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	movzx	ecx, WORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5967 :   if (!(state->marker->read() &&

	push	DWORD PTR [eax+12]
	push	ecx
	lea	ecx, DWORD PTR _siz$[ebp]
	call	?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z ; kdu_params::translate_marker_segment
	test	al, al
	jne	SHORT $LN13@restart
$LN14@restart:

; 5971 :     { KDU_ERROR(e,46); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0FH@CKLGEIAA@Code?9stream?5must?5contain?5a?5valid@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5971 :     { KDU_ERROR(e,46); e <<

	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5974 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN13@restart:

; 5975 :   if (siz.any_changes())

	lea	ecx, DWORD PTR _siz$[ebp]
	call	?any_changes@kdu_params@@QAE_NXZ	; kdu_params::any_changes
	test	al, al
	je	$LN15@restart

; 5976 :     { // Rebuild the code-stream management machinery from scratch
; 5977 :       kd_codestream *old_state = state;

	mov	ebx, DWORD PTR [esi]

; 5978 :       state = new kd_codestream;

	push	416					; 000001a0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	test	eax, eax
	je	SHORT $LN29@restart
	mov	ecx, eax
	call	??0kd_codestream@@QAE@XZ		; kd_codestream::kd_codestream
	mov	ecx, eax
	jmp	SHORT $LN30@restart
$LN29@restart:
	xor	ecx, ecx
$LN30@restart:
	mov	DWORD PTR [esi], ecx

; 5979 :       state->in = old_state->in; old_state->in = NULL;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ecx+4], eax

; 5980 :       state->marker = old_state->marker->move(state->in,state);

	mov	ecx, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+4], 0
	mov	edx, DWORD PTR [esi]

; 5982 :       state->siz = new siz_params;

	push	88					; 00000058H
	mov	eax, DWORD PTR [edx+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 845  :       { this->source = input; this->codestream = cs; return this; }

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5980 :       state->marker = old_state->marker->move(state->in,state);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+16], ecx

; 5981 :       old_state->marker = NULL;

	mov	DWORD PTR [ebx+16], 0

; 5982 :       state->siz = new siz_params;

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	test	eax, eax
	je	SHORT $LN31@restart
	mov	ecx, eax
	call	??0siz_params@@QAE@XZ			; siz_params::siz_params
	mov	ecx, eax
	jmp	SHORT $LN32@restart
$LN31@restart:
	xor	ecx, ecx
$LN32@restart:
	mov	eax, DWORD PTR [esi]

; 5983 :       state->siz->copy_from(&siz,-1,-1);

	push	0
	push	0
	push	0
	push	0
	push	0
	mov	DWORD PTR [eax+12], ecx
	lea	eax, DWORD PTR _siz$[ebp]
	mov	ecx, DWORD PTR [esi]
	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR [ecx+12]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	call	?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z ; kdu_params::copy_from

; 5984 :       state->construct_common();

	mov	ecx, DWORD PTR [esi]
	call	?construct_common@kd_codestream@@QAEXXZ	; kd_codestream::construct_common

; 5985 : 
; 5986 :       state->discard_levels = old_state->discard_levels;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebx+188]
	mov	DWORD PTR [ecx+188], eax

; 5987 :       state->max_apparent_layers = old_state->max_apparent_layers;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebx+196]
	mov	DWORD PTR [ecx+196], eax

; 5988 :       if (state->num_components == old_state->num_components)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+112]
	cmp	eax, DWORD PTR [ebx+112]
	jne	$LN3@restart

; 5989 :         {
; 5990 :           state->num_apparent_components = old_state->num_apparent_components;

	mov	eax, DWORD PTR [ebx+116]
	mov	DWORD PTR [ecx+116], eax

; 5991 :           for (int c=0; c < state->num_components; c++)

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _c$1$[ebp], 0
	cmp	DWORD PTR [eax+112], 0
	jle	SHORT $LN3@restart

; 5989 :         {
; 5990 :           state->num_apparent_components = old_state->num_apparent_components;

	xor	edi, edi
	mov	DWORD PTR tv1000[ebp], edi
	npad	10
$LL4@restart:

; 5992 :             {
; 5993 :               state->comp_info[c].apparent_idx =

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [ebx+256]
	mov	ecx, DWORD PTR [eax+256]
	mov	eax, DWORD PTR [edx+edi+88]
	mov	DWORD PTR [ecx+edi+88], eax

; 5994 :                 old_state->comp_info[c].apparent_idx;
; 5995 :               state->comp_info[c].from_apparent = state->comp_info +

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ebx+256]
	mov	edi, DWORD PTR [eax+256]
	mov	eax, DWORD PTR tv1000[ebp]
	mov	edx, DWORD PTR [ecx+eax+92]
	mov	eax, 715827883				; 2aaaaaabH
	sub	edx, ecx
	mov	ecx, DWORD PTR tv1000[ebp]
	imul	edx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 5
	add	eax, edi
	mov	DWORD PTR [edi+ecx+92], eax
	mov	ecx, DWORD PTR _c$1$[ebp]
	mov	eax, DWORD PTR [esi]
	inc	ecx
	mov	edi, DWORD PTR tv1000[ebp]
	add	edi, 96					; 00000060H
	mov	DWORD PTR _c$1$[ebp], ecx
	mov	DWORD PTR tv1000[ebp], edi
	cmp	ecx, DWORD PTR [eax+112]
	jl	SHORT $LL4@restart
$LN3@restart:

; 5996 :                 (old_state->comp_info[c].from_apparent - old_state->comp_info);
; 5997 :             }
; 5998 :         }
; 5999 :       if (state->num_output_components == old_state->num_output_components)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+120]
	cmp	eax, DWORD PTR [ebx+120]
	jne	SHORT $LN6@restart

; 6000 :         {
; 6001 :           state->num_apparent_output_components =

	mov	eax, DWORD PTR [ebx+124]
	mov	DWORD PTR [ecx+124], eax

; 6002 :             old_state->num_apparent_output_components;
; 6003 :           for (int c=0; c < state->num_output_components; c++)

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _c$1$[ebp], 0
	cmp	DWORD PTR [eax+120], 0
	jle	SHORT $LN6@restart

; 6000 :         {
; 6001 :           state->num_apparent_output_components =

	xor	edi, edi
$LL7@restart:

; 6004 :             {
; 6005 :               state->output_comp_info[c].apparent_idx =

	mov	eax, DWORD PTR [esi]
	lea	edi, DWORD PTR [edi+40]
	mov	edx, DWORD PTR [ebx+260]
	mov	ecx, DWORD PTR [eax+260]
	mov	eax, DWORD PTR [edx+edi-28]
	mov	DWORD PTR [ecx+edi-28], eax

; 6006 :                 old_state->output_comp_info[c].apparent_idx;
; 6007 :               state->output_comp_info[c].from_apparent =

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [ebx+260]
	mov	ecx, DWORD PTR [eax+260]
	mov	eax, DWORD PTR [edx+edi-24]
	mov	DWORD PTR [ecx+edi-24], eax
	mov	ecx, DWORD PTR _c$1$[ebp]
	mov	eax, DWORD PTR [esi]
	inc	ecx
	mov	DWORD PTR _c$1$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+120]
	jl	SHORT $LL7@restart
$LN6@restart:

; 6008 :                 old_state->output_comp_info[c].from_apparent;
; 6009 :             }
; 6010 :         }
; 6011 :       state->component_access_mode = old_state->component_access_mode;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebx+128]
	mov	DWORD PTR [ecx+128], eax

; 6012 : 
; 6013 :       state->allow_restart = old_state->allow_restart;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ebx+328]
	mov	BYTE PTR [ecx+328], al

; 6014 :       state->transpose = old_state->transpose;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ebx+329]
	mov	BYTE PTR [ecx+329], al

; 6015 :       state->vflip = old_state->vflip;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ebx+330]
	mov	BYTE PTR [ecx+330], al

; 6016 :       state->hflip = old_state->hflip;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ebx+331]
	mov	BYTE PTR [ecx+331], al

; 6017 :       state->resilient = old_state->resilient;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ebx+332]
	mov	BYTE PTR [ecx+332], al

; 6018 :       state->expect_ubiquitous_sops = old_state->expect_ubiquitous_sops;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ebx+333]
	mov	BYTE PTR [ecx+333], al

; 6019 :       state->fussy = old_state->fussy;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ebx+334]
	mov	BYTE PTR [ecx+334], al

; 6020 :       state->persistent = old_state->persistent;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ebx+337]
	mov	BYTE PTR [ecx+337], al

; 6021 :       state->cached = old_state->cached;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ebx+338]
	mov	BYTE PTR [ecx+338], al

; 6022 :       state->in_memory_source = old_state->in_memory_source;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ebx+339]
	mov	BYTE PTR [ecx+339], al

; 6023 :       state->min_slope_threshold = old_state->min_slope_threshold;

	mov	ecx, DWORD PTR [esi]
	mov	ax, WORD PTR [ebx+384]
	mov	WORD PTR [ecx+384], ax
	mov	ecx, ebx
	call	??1kd_codestream@@QAE@XZ		; kd_codestream::~kd_codestream
	push	416					; 000001a0H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete

; 6024 : 
; 6025 :       delete old_state;
; 6026 :     }
; 6027 :   else

	mov	ebx, DWORD PTR _env$[ebp]
	add	esp, 8
	jmp	SHORT $LN16@restart
$LN15@restart:

; 6028 :     state->restart();

	mov	ecx, DWORD PTR [esi]
	call	?restart@kd_codestream@@QAEXXZ		; kd_codestream::restart
$LN16@restart:

; 6029 :   state->comments_frozen = true;

	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+342], 1

; 6030 :   state->unloadable_tile_scan = state->unloadable_tiles_head;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+392]
	mov	DWORD PTR [ecx+400], eax

; 6031 :   if (env != NULL)

	test	ebx, ebx
	je	SHORT $LN90@restart
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [ebx+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN90@restart
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN90@restart:
	lea	ecx, DWORD PTR _siz$[ebp]
	call	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 6033 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN104@restart:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$0:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$1:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$2:
	push	600					; 00000258H
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$4:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$5:
	lea	ecx, DWORD PTR _siz$[ebp]
	jmp	??1siz_params@@UAE@XZ
__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$6:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$8:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-148]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?restart@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z ENDP ; kdu_codestream::restart
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z
_TEXT	SEGMENT
_e$2 = -56						; size = 20
_e$3 = -36						; size = 20
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_target$ = 8						; size = 4
?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z PROC ; kdu_codestream::restart, COMDAT
; _this$ = ecx

; 5905 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 5906 :   if (!state->allow_restart)

	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+328], 0
	jne	SHORT $LN2@restart

; 5907 :     { KDU_ERROR_DEV(e,41); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0KI@GFLIIJEF@You?5may?5not?5use?5the?5?$GAkdu_codestr@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5907 :     { KDU_ERROR_DEV(e,41); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5911 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@restart:

; 5912 :   if (state->out == NULL)

	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN3@restart

; 5913 :     { KDU_ERROR_DEV(e,42); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0MD@MOKJCILO@You?5may?5not?5use?5the?5output?5form?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5913 :     { KDU_ERROR_DEV(e,42); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5918 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN3@restart:

; 5919 :   delete state->out;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN5@restart
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN5@restart:

; 5920 :   state->out = new kd_compressed_output(target);

	push	536					; 00000218H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T4[ebp], esi
	test	esi, esi
	je	SHORT $LN7@restart
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 441  :       { this->target=target; flushed_bytes = 0; }

	mov	eax, DWORD PTR _target$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 131  :       { next_buf = buffer; end_buf = buffer+KDU_OBUF_SIZE; }

	lea	edx, DWORD PTR [esi+516]
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+520], edx
	mov	DWORD PTR [edx], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 441  :       { this->target=target; flushed_bytes = 0; }

	mov	DWORD PTR [esi], OFFSET ??_7kd_compressed_output@@6B@
	mov	DWORD PTR [esi+524], eax
	mov	DWORD PTR [esi+528], 0
	mov	DWORD PTR [esi+532], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5920 :   state->out = new kd_compressed_output(target);

	jmp	SHORT $LN8@restart
$LN7@restart:
	xor	esi, esi
$LN8@restart:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], esi

; 5921 :   state->restart();

	mov	ecx, DWORD PTR [edi]
	call	?restart@kd_codestream@@QAEXXZ		; kd_codestream::restart

; 5922 :   state->num_incomplete_tiles = (int) state->tile_indices.area();

	mov	ecx, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [ecx+184]
	imul	eax, DWORD PTR [ecx+180]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5922 :   state->num_incomplete_tiles = (int) state->tile_indices.area();

	mov	DWORD PTR [ecx+280], eax

; 5923 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?restart@kdu_codestream@@QAEXPAVkdu_compressed_target@@@Z ENDP ; kdu_codestream::restart
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?create@kdu_codestream@@QAEXPAVsiz_params@@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_siz_in$ = 8						; size = 4
?create@kdu_codestream@@QAEXPAVsiz_params@@@Z PROC	; kdu_codestream::create, COMDAT
; _this$ = ecx

; 5888 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?create@kdu_codestream@@QAEXPAVsiz_params@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 5889 :   assert(state == NULL);
; 5890 :   state = new kd_codestream;

	push	416					; 000001a0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	test	eax, eax
	je	SHORT $LN3@create
	mov	ecx, eax
	call	??0kd_codestream@@QAE@XZ		; kd_codestream::kd_codestream
	jmp	SHORT $LN4@create
$LN3@create:
	xor	eax, eax
$LN4@create:

; 5891 :   state->siz = new siz_params;

	push	88					; 00000058H
	mov	DWORD PTR [esi], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN5@create
	mov	ecx, eax
	call	??0siz_params@@QAE@XZ			; siz_params::siz_params
	mov	ecx, eax
	jmp	SHORT $LN6@create
$LN5@create:
	xor	ecx, ecx
$LN6@create:
	mov	eax, DWORD PTR [esi]

; 5892 :   state->siz->copy_from(siz_in,-1,-1);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [esi]
	push	-1
	push	-1
	push	DWORD PTR _siz_in$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z ; kdu_params::copy_from

; 5893 :   state->construct_common();

	mov	ecx, DWORD PTR [esi]
	call	?construct_common@kd_codestream@@QAEXXZ	; kd_codestream::construct_common

; 5894 :   state->interchange = true;

	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+335], 1

; 5895 :   state->persistent = true; // Structures persist after tile is closed, but

	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+337], 1

; 5896 :                             // compressed data does not.
; 5897 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?create@kdu_codestream@@QAEXPAVsiz_params@@@Z$1:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?create@kdu_codestream@@QAEXPAVsiz_params@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?create@kdu_codestream@@QAEXPAVsiz_params@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?create@kdu_codestream@@QAEXPAVsiz_params@@@Z ENDP	; kdu_codestream::create
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_e$2 = -52						; size = 20
_e$3 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_source$ = 8						; size = 4
$T4 = 12						; size = 4
$T5 = 12						; size = 4
$T6 = 12						; size = 4
$T7 = 12						; size = 4
$T8 = 12						; size = 4
_env$ = 12						; size = 4
?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z PROC ; kdu_codestream::create, COMDAT
; _this$ = ecx

; 5853 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 5854 :   assert(state == NULL);
; 5855 :   if (env != NULL)

	mov	ebx, DWORD PTR _env$[ebp]
	test	ebx, ebx
	je	SHORT $LN25@create
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	edi, DWORD PTR [ebx+28]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN24@create
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T4[ebp], eax
	lea	eax, DWORD PTR $T4[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN55@create:
$LN24@create:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN28@create
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN28@create:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+4], ebx
$LN25@create:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5857 :   state = new kd_codestream;

	push	416					; 000001a0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	test	eax, eax
	je	SHORT $LN9@create
	mov	ecx, eax
	call	??0kd_codestream@@QAE@XZ		; kd_codestream::kd_codestream
	jmp	SHORT $LN10@create
$LN9@create:
	xor	eax, eax
$LN10@create:

; 5858 :   state->in = new kd_compressed_input(source);

	push	600					; 00000258H
	mov	DWORD PTR [esi], eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	edi, DWORD PTR _source$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN11@create
	push	edi
	mov	ecx, eax
	call	??0kd_compressed_input@@QAE@PAVkdu_compressed_source@@@Z ; kd_compressed_input::kd_compressed_input
	mov	ecx, eax
	jmp	SHORT $LN12@create
$LN11@create:
	xor	ecx, ecx
$LN12@create:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [eax+4], ecx

; 5859 :   state->cached = (source->get_capabilities() & KDU_SOURCE_CAP_CACHED) != 0;

	mov	ecx, edi
	mov	eax, DWORD PTR [edi]
	call	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [esi]
	shr	eax, 2
	and	al, 1

; 5861 :   state->marker = new kd_marker(state->in,state);

	push	28					; 0000001cH
	mov	BYTE PTR [ecx+338], al
	mov	ecx, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 487  :     bool is_fully_buffered() { return fully_buffered; }

	mov	eax, DWORD PTR [ecx+4]
	mov	al, BYTE PTR [eax+532]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5860 :   state->in_memory_source = state->in->is_fully_buffered();

	mov	BYTE PTR [ecx+339], al

; 5861 :   state->marker = new kd_marker(state->in,state);

	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T6[ebp], edi
	test	edi, edi
	je	SHORT $LN13@create
	mov	edx, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 837  :         code = 0; length = 0; max_length = 0; buf = NULL;

	xor	eax, eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [edi], ecx
	mov	DWORD PTR [edi+4], edx
	mov	WORD PTR [edi+8], ax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], eax

; 838  :         encountered_skip_code = false; }

	mov	BYTE PTR [edi+24], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5861 :   state->marker = new kd_marker(state->in,state);

	jmp	SHORT $LN14@create
$LN13@create:
	xor	edi, edi
$LN14@create:
	mov	eax, DWORD PTR [esi]

; 5862 :   if ((!state->marker->read()) ||

	push	0
	push	0
	mov	DWORD PTR [eax+16], edi
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+16]
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
	test	al, al
	je	SHORT $LN4@create
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	eax, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5862 :   if ((!state->marker->read()) ||

	mov	ecx, 65359				; 0000ff4fH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	eax, DWORD PTR [eax+16]
	movzx	eax, WORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5862 :   if ((!state->marker->read()) ||

	cmp	ax, cx
	je	SHORT $LN3@create
$LN4@create:

; 5864 :     { KDU_ERROR(e,39); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0CL@KMFCLNLD@Code?9stream?5must?5start?5with?5an?5S@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5864 :     { KDU_ERROR(e,39); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5866 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN3@create:

; 5867 :   state->siz = new siz_params;

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN15@create
	mov	ecx, eax
	call	??0siz_params@@QAE@XZ			; siz_params::siz_params
	mov	ecx, eax
	jmp	SHORT $LN16@create
$LN15@create:
	xor	ecx, ecx
$LN16@create:
	mov	eax, DWORD PTR [esi]

; 5868 :   if (!(state->marker->read() &&

	push	0
	push	0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+16]
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
	test	al, al
	je	SHORT $LN6@create
	mov	ecx, DWORD PTR [esi]
	push	0
	push	-1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	eax, DWORD PTR [ecx+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5868 :   if (!(state->marker->read() &&

	mov	ecx, DWORD PTR [ecx+12]
	push	DWORD PTR [eax+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	movzx	edx, WORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5868 :   if (!(state->marker->read() &&

	push	DWORD PTR [eax+12]
	push	edx
	call	?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z ; kdu_params::translate_marker_segment
	test	al, al
	jne	SHORT $LN5@create
$LN6@create:

; 5872 :     { KDU_ERROR(e,40); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0FH@CKLGEIAA@Code?9stream?5must?5contain?5a?5valid@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5872 :     { KDU_ERROR(e,40); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5875 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN5@create:

; 5876 :   state->construct_common();

	mov	ecx, DWORD PTR [esi]
	call	?construct_common@kd_codestream@@QAEXXZ	; kd_codestream::construct_common

; 5877 :   state->comments_frozen = true;

	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+342], 1

; 5878 :   if (env != NULL)

	test	ebx, ebx
	je	SHORT $LN51@create
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [ebx+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN51@create
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN51@create:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5880 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN54@create:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$1:
	push	600					; 00000258H
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$3:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$4:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z$5:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?create@kdu_codestream@@QAEXPAVkdu_compressed_source@@PAVkdu_thread_env@@@Z ENDP ; kdu_codestream::create
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?create@kdu_codestream@@QAEXPAVsiz_params@@PAVkdu_compressed_target@@PAUkdu_dims@@H_J@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_siz_in$ = 8						; size = 4
$T4 = 12						; size = 4
_target$ = 12						; size = 4
_fragment_region$ = 16					; size = 4
_fragment_tiles_generated$ = 20				; size = 4
_fragment_tile_bytes_generated$ = 24			; size = 8
?create@kdu_codestream@@QAEXPAVsiz_params@@PAVkdu_compressed_target@@PAUkdu_dims@@H_J@Z PROC ; kdu_codestream::create, COMDAT
; _this$ = ecx

; 5834 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?create@kdu_codestream@@QAEXPAVsiz_params@@PAVkdu_compressed_target@@PAUkdu_dims@@H_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 5835 :   assert((state == NULL) && (target != NULL));
; 5836 :   state = new kd_codestream;

	push	416					; 000001a0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	test	eax, eax
	je	SHORT $LN4@create
	mov	ecx, eax
	call	??0kd_codestream@@QAE@XZ		; kd_codestream::kd_codestream
	jmp	SHORT $LN5@create
$LN4@create:
	xor	eax, eax
$LN5@create:

; 5837 :   state->out = new kd_compressed_output(target);

	push	536					; 00000218H
	mov	DWORD PTR [edi], eax
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], esi
	test	esi, esi
	je	SHORT $LN6@create
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 441  :       { this->target=target; flushed_bytes = 0; }

	mov	eax, DWORD PTR _target$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 131  :       { next_buf = buffer; end_buf = buffer+KDU_OBUF_SIZE; }

	lea	edx, DWORD PTR [esi+516]
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+520], edx
	mov	DWORD PTR [edx], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 441  :       { this->target=target; flushed_bytes = 0; }

	mov	DWORD PTR [esi], OFFSET ??_7kd_compressed_output@@6B@
	mov	DWORD PTR [esi+524], eax
	mov	DWORD PTR [esi+528], 0
	mov	DWORD PTR [esi+532], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5837 :   state->out = new kd_compressed_output(target);

	jmp	SHORT $LN7@create
$LN6@create:
	xor	esi, esi
$LN7@create:
	mov	eax, DWORD PTR [edi]

; 5838 :   state->siz = new siz_params;

	push	88					; 00000058H
	mov	DWORD PTR [eax+8], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN8@create
	mov	ecx, eax
	call	??0siz_params@@QAE@XZ			; siz_params::siz_params
	mov	ecx, eax
	jmp	SHORT $LN9@create
$LN8@create:
	xor	ecx, ecx
$LN9@create:
	mov	eax, DWORD PTR [edi]

; 5839 :   state->siz->copy_from(siz_in,-1,-1);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edi]
	push	-1
	push	-1
	push	DWORD PTR _siz_in$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	?copy_from@kdu_params@@QAEXPAV1@HHHHH_N11@Z ; kdu_params::copy_from

; 5840 :   state->construct_common();

	mov	ecx, DWORD PTR [edi]
	call	?construct_common@kd_codestream@@QAEXXZ	; kd_codestream::construct_common

; 5841 :   if (fragment_region != NULL)

	mov	ecx, DWORD PTR _fragment_region$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@create

; 5842 :     state->restrict_to_fragment(*fragment_region,fragment_tiles_generated,

	push	DWORD PTR _fragment_tile_bytes_generated$[ebp+4]
	movups	xmm0, XMMWORD PTR [ecx]
	mov	ecx, DWORD PTR [edi]
	push	DWORD PTR _fragment_tile_bytes_generated$[ebp]
	push	DWORD PTR _fragment_tiles_generated$[ebp]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	movups	XMMWORD PTR [eax], xmm0
	call	?restrict_to_fragment@kd_codestream@@QAEXUkdu_dims@@H_J@Z ; kd_codestream::restrict_to_fragment
$LN2@create:

; 5844 :   state->num_incomplete_tiles = (int) state->tile_indices.area();

	mov	ecx, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [ecx+184]
	imul	eax, DWORD PTR [ecx+180]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 5844 :   state->num_incomplete_tiles = (int) state->tile_indices.area();

	mov	DWORD PTR [ecx+280], eax

; 5845 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?create@kdu_codestream@@QAEXPAVsiz_params@@PAVkdu_compressed_target@@PAUkdu_dims@@H_J@Z$2:
	push	88					; 00000058H
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?create@kdu_codestream@@QAEXPAVsiz_params@@PAVkdu_compressed_target@@PAUkdu_dims@@H_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?create@kdu_codestream@@QAEXPAVsiz_params@@PAVkdu_compressed_target@@PAUkdu_dims@@H_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?create@kdu_codestream@@QAEXPAVsiz_params@@PAVkdu_compressed_target@@PAUkdu_dims@@H_J@Z ENDP ; kdu_codestream::create
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??6kdu_codestream_comment@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
??6kdu_codestream_comment@@QAEAAV0@PBD@Z PROC		; kdu_codestream_comment::operator<<, COMDAT
; _this$ = ecx

; 500  :       { put_text(string); return *this; }

	push	ebp
	mov	ebp, esp
	push	esi
	push	DWORD PTR _string$[ebp]
	mov	esi, ecx
	call	?put_text@kdu_codestream_comment@@QAE_NPBD@Z ; kdu_codestream_comment::put_text
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??6kdu_codestream_comment@@QAEAAV0@PBD@Z ENDP		; kdu_codestream_comment::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?put_text@kdu_codestream_comment@@QAE_NPBD@Z
_TEXT	SEGMENT
_w$2 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_string$ = 8						; size = 4
?put_text@kdu_codestream_comment@@QAE_NPBD@Z PROC	; kdu_codestream_comment::put_text, COMDAT
; _this$ = ecx

; 3241 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put_text@kdu_codestream_comment@@QAE_NPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 3242 :   if ((state == NULL) || state->readonly)

	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	$LN3@put_text
	cmp	BYTE PTR [esi], 0
	jne	$LN3@put_text

; 3244 :   int len = state->num_chars + (int) strlen(string);

	mov	ebx, DWORD PTR _string$[ebp]
	mov	ecx, ebx
	lea	edx, DWORD PTR [ecx+1]
$LL17@put_text:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL17@put_text
	mov	esi, DWORD PTR [esi+8]
	sub	ecx, edx
	add	esi, ecx

; 3245 :   if (len > 65531)

	cmp	esi, 65531				; 0000fffbH
	jle	SHORT $LN4@put_text

; 3246 :     { KDU_WARNING(w,0x06110801); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$2[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$2[ebp]
	lea	ecx, DWORD PTR _w$2[ebp]
	push	OFFSET ??_C@_0OO@PCLKLFBK@Call?5to?5?$GAkdu_codestream_comment?3@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3246 :     { KDU_WARNING(w,0x06110801); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp

; 3253 :     }  

	lea	ecx, DWORD PTR _w$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, 65531				; 0000fffbH
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN4@put_text:

; 3254 :   if (len > state->max_chars)

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+4]
	cmp	esi, eax
	jle	SHORT $LN7@put_text

; 3255 :     {
; 3256 :       state->max_chars = len + state->max_chars + 80;

	add	eax, 80					; 00000050H
	add	eax, esi
	mov	DWORD PTR [ecx+4], eax

; 3257 :       char *old_buf = state->text_buf;

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+12]

; 3258 :       state->text_buf = new char[state->max_chars+1];

	mov	eax, DWORD PTR [eax+4]
	inc	eax
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR [edi]
	add	esp, 4
	mov	DWORD PTR [ecx+12], eax

; 3259 :       if (old_buf == NULL)
; 3260 :         state->text_buf[0] = '\0';

	mov	eax, DWORD PTR [edi]
	test	ebx, ebx
	jne	SHORT $LN6@put_text
	mov	eax, DWORD PTR [eax+12]
	mov	BYTE PTR [eax], bl

; 3261 :       else

	jmp	SHORT $LN19@put_text
$LN6@put_text:

; 3262 :         {
; 3263 :           strcpy(state->text_buf,old_buf);

	mov	edx, DWORD PTR [eax+12]
	mov	ecx, ebx
	npad	5
$LL10@put_text:
	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]
	mov	BYTE PTR [edx], al
	lea	edx, DWORD PTR [edx+1]
	test	al, al
	jne	SHORT $LL10@put_text

; 3264 :           delete[] old_buf;

	push	ebx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN19@put_text:
	mov	ebx, DWORD PTR _string$[ebp]
$LN7@put_text:

; 3265 :         }
; 3266 :     }
; 3267 :   if (len > state->num_chars)

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+8]
	cmp	esi, edx
	jle	SHORT $LN8@put_text

; 3268 :     strncat(state->text_buf,string,(size_t)(len-state->num_chars));

	mov	eax, esi
	sub	eax, edx
	push	eax
	push	ebx
	push	DWORD PTR [ecx+12]
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH
$LN8@put_text:

; 3269 :   state->num_chars = len;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], esi

; 3270 :   return true;

	mov	al, 1

; 3271 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN3@put_text:

; 3243 :     return false;

	xor	al, al

; 3271 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?put_text@kdu_codestream_comment@@QAE_NPBD@Z$0:
	lea	ecx, DWORD PTR _w$2[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__ehhandler$?put_text@kdu_codestream_comment@@QAE_NPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?put_text@kdu_codestream_comment@@QAE_NPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?put_text@kdu_codestream_comment@@QAE_NPBD@Z ENDP	; kdu_codestream_comment::put_text
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?check_readonly@kdu_codestream_comment@@QAE_NXZ
_TEXT	SEGMENT
?check_readonly@kdu_codestream_comment@@QAE_NXZ PROC	; kdu_codestream_comment::check_readonly, COMDAT
; _this$ = ecx

; 3229 :   if (state == NULL)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN2@check_read

; 3230 :     return true;

	mov	al, 1

; 3233 : }

	ret	0
$LN2@check_read:

; 3231 :   else
; 3232 :     return state->readonly;

	mov	al, BYTE PTR [eax]

; 3233 : }

	ret	0
?check_readonly@kdu_codestream_comment@@QAE_NXZ ENDP	; kdu_codestream_comment::check_readonly
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?get_text@kdu_codestream_comment@@QAEPBDXZ
_TEXT	SEGMENT
?get_text@kdu_codestream_comment@@QAEPBDXZ PROC		; kdu_codestream_comment::get_text, COMDAT
; _this$ = ecx

; 3214 :   if (state == NULL)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LN2@get_text

; 3215 :     return NULL;

	xor	eax, eax

; 3217 :     return "";
; 3218 :   else
; 3219 :     return state->text_buf;
; 3220 : }

	ret	0
$LN2@get_text:

; 3216 :   else if (state->text_buf == NULL)

	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	ecx, ecx
	cmovne	eax, ecx

; 3217 :     return "";
; 3218 :   else
; 3219 :     return state->text_buf;
; 3220 : }

	ret	0
?get_text@kdu_codestream_comment@@QAEPBDXZ ENDP		; kdu_codestream_comment::get_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_codestream_comment@@QAE@PAVkd_codestream_comment@@@Z
_TEXT	SEGMENT
_state$ = 8						; size = 4
??0kdu_codestream_comment@@QAE@PAVkd_codestream_comment@@@Z PROC ; kdu_codestream_comment::kdu_codestream_comment, COMDAT
; _this$ = ecx

; 471  :     kdu_codestream_comment(kd_codestream_comment *state) { this->state=state; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0kdu_codestream_comment@@QAE@PAVkd_codestream_comment@@@Z ENDP ; kdu_codestream_comment::kdu_codestream_comment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_codestream_comment@@QAE@XZ
_TEXT	SEGMENT
??0kdu_codestream_comment@@QAE@XZ PROC			; kdu_codestream_comment::kdu_codestream_comment, COMDAT
; _this$ = ecx

; 465  :     kdu_codestream_comment() { state = NULL; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0kdu_codestream_comment@@QAE@XZ ENDP			; kdu_codestream_comment::kdu_codestream_comment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?to_apparent@kdu_dims@@QAEX_N00@Z
_TEXT	SEGMENT
_transp$ = 8						; size = 1
_vflip$ = 12						; size = 1
_hflip$ = 16						; size = 1
?to_apparent@kdu_dims@@QAEX_N00@Z PROC			; kdu_dims::to_apparent, COMDAT
; _this$ = ecx

; 421  :     { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 422  :            Does the reverse of `kdu_from_apparent', assuming the same
; 423  :            values for `transp', `vflip' and `hflip' are supplied.
; 424  :       */
; 425  :       if (transp) transpose();

	cmp	BYTE PTR _transp$[ebp], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN2@to_apparen

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ecx
$LN2@to_apparen:

; 426  :       if (hflip) pos.x = -(pos.x+size.x-1);

	cmp	BYTE PTR _hflip$[ebp], 0
	mov	ecx, 1
	je	SHORT $LN3@to_apparen
	mov	eax, ecx
	sub	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+4], eax
$LN3@to_apparen:

; 427  :       if (vflip) pos.y = -(pos.y+size.y-1);

	cmp	BYTE PTR _vflip$[ebp], 0
	je	SHORT $LN4@to_apparen
	sub	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi], ecx
$LN4@to_apparen:
	pop	esi

; 428  :     }

	pop	ebp
	ret	12					; 0000000cH
?to_apparent@kdu_dims@@QAEX_N00@Z ENDP			; kdu_dims::to_apparent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?from_apparent@kdu_dims@@QAEX_N00@Z
_TEXT	SEGMENT
_transp$ = 8						; size = 1
_vflip$ = 12						; size = 1
_hflip$ = 16						; size = 1
?from_apparent@kdu_dims@@QAEX_N00@Z PROC		; kdu_dims::from_apparent, COMDAT
; _this$ = ecx

; 409  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 410  :              Converts the region from the apparent coordinate system
; 411  :              established by `kdu_codestream::change_appearance' to the real
; 412  :              coordinates.  The `transp', `vflip' and `hflip' parameters
; 413  :              are identical to those supplied to
; 414  :              `kdu_codestream::change_appearance'.
; 415  :         */
; 416  :         if (hflip) pos.x = -(pos.x+size.x-1);

	cmp	BYTE PTR _hflip$[ebp], 0
	mov	edx, ecx
	mov	ecx, 1
	je	SHORT $LN2@from_appar
	mov	eax, ecx
	sub	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx+4], eax
$LN2@from_appar:

; 417  :         if (vflip) pos.y = -(pos.y+size.y-1);

	cmp	BYTE PTR _vflip$[ebp], 0
	je	SHORT $LN3@from_appar
	sub	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx], ecx
$LN3@from_appar:

; 418  :         if (transp) transpose();

	cmp	BYTE PTR _transp$[ebp], 0
	je	SHORT $LN4@from_appar

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
$LN4@from_appar:

; 419  :       }

	pop	ebp
	ret	12					; 0000000cH
?from_apparent@kdu_dims@@QAEX_N00@Z ENDP		; kdu_dims::from_apparent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?intersects@kdu_dims@@QAE_NAAU1@@Z
_TEXT	SEGMENT
tv192 = 8						; size = 4
_rhs$ = 8						; size = 4
?intersects@kdu_dims@@QAE_NAAU1@@Z PROC			; kdu_dims::intersects, COMDAT
; _this$ = ecx

; 362  :       {

	push	ebp
	mov	ebp, esp

; 363  :       /* [SYNOPSIS]
; 364  :            Checks whether or not the region represented by `rhs' has
; 365  :            a non-empty intersection with that represented by the current
; 366  :            object.
; 367  :          [RETURNS]
; 368  :            True if the intersection is non-empty.
; 369  :       */
; 370  :         if ((pos.x+size.x) <= rhs.pos.x) return false;

	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+12]
	add	eax, esi
	cmp	eax, DWORD PTR [edx+4]
	jg	SHORT $LN2@intersects
	pop	esi
	xor	al, al
	pop	ebx

; 378  :       }

	pop	ebp
	ret	4
$LN2@intersects:

; 371  :         if ((pos.y+size.y) <= rhs.pos.y) return false;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv192[ebp], eax
	add	eax, ebx
	push	edi
	cmp	eax, DWORD PTR [edx]
	jle	SHORT $LN7@intersects

; 372  :         if (pos.x >= (rhs.pos.x+rhs.size.x)) return false;

	mov	eax, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx+12]
	add	eax, edi
	cmp	DWORD PTR [ecx+4], eax
	jge	SHORT $LN7@intersects

; 373  :         if (pos.y >= (rhs.pos.y+rhs.size.y)) return false;

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+8]
	add	eax, ecx
	cmp	DWORD PTR tv192[ebp], eax
	jge	SHORT $LN7@intersects

; 374  :         if ((size.x <= 0) || (size.y <= 0) ||
; 375  :             (rhs.size.x <= 0) || (rhs.size.y <= 0))

	test	esi, esi
	jle	SHORT $LN7@intersects
	test	ebx, ebx
	jle	SHORT $LN7@intersects
	test	edi, edi
	jle	SHORT $LN7@intersects
	test	ecx, ecx
	jle	SHORT $LN7@intersects

; 377  :         return true;

	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx

; 378  :       }

	pop	ebp
	ret	4
$LN7@intersects:
	pop	edi
	pop	esi

; 376  :           return false;

	xor	al, al
	pop	ebx

; 378  :       }

	pop	ebp
	ret	4
?intersects@kdu_dims@@QAE_NAAU1@@Z ENDP			; kdu_dims::intersects
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??_4kdu_dims@@QAE?AU0@AAU0@@Z
_TEXT	SEGMENT
tv336 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??_4kdu_dims@@QAE?AU0@AAU0@@Z PROC			; kdu_dims::operator&=, COMDAT
; _this$ = ecx

; 344  :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	ecx, DWORD PTR _rhs$[ebp]
	push	edi
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+12]
	mov	edi, DWORD PTR [esi+12]
	add	eax, edx
	add	edi, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [esi+8]
	add	ebx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv336[ebp], edx
	mov	edx, DWORD PTR _rhs$[ebp]
	add	ecx, DWORD PTR [edx]

; 345  :       /* [SYNOPSIS]
; 346  :            Intersects the region represented by `rhs' with that  represented
; 347  :            by the current object.
; 348  :       */
; 349  :         kdu_coords lim = pos+size;
; 350  :         kdu_coords rhs_lim = rhs.pos + rhs.size;
; 351  :         if (lim.x > rhs_lim.x) lim.x = rhs_lim.x;

	cmp	edi, eax
	cmovg	edi, eax

; 352  :         if (lim.y > rhs_lim.y) lim.y  = rhs_lim.y;
; 353  :         if (pos.x < rhs.pos.x) pos.x = rhs.pos.x;

	mov	eax, DWORD PTR tv336[ebp]
	cmp	ebx, ecx
	cmovg	ebx, ecx
	cmp	DWORD PTR [esi+4], eax
	jge	SHORT $LN4@operator
	mov	DWORD PTR [esi+4], eax
$LN4@operator:

; 354  :         if (pos.y < rhs.pos.y) pos.y = rhs.pos.y;

	mov	eax, edx
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [esi], eax
	jge	SHORT $LN5@operator
	mov	DWORD PTR [esi], eax
$LN5@operator:

; 224  :     kdu_coords plus(const kdu_coords &rhs)
; 225  :       { /* [SYNOPSIS] Same as `operator+', but more suitable for
; 226  :                       some language bindings. */
; 227  :            return (*this)+rhs;
; 228  :       }
; 229  :     kdu_coords operator-(const kdu_coords &rhs)
; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	edi, DWORD PTR [esi+4]
	sub	ebx, DWORD PTR [esi]

; 355  :         size = lim-pos;

	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], edi

; 356  :         if (size.x < 0) size.x = 0;

	test	edi, edi
	jge	SHORT $LN6@operator
	mov	DWORD PTR [esi+12], 0
$LN6@operator:

; 357  :         if (size.y < 0) size.y = 0;

	test	ebx, ebx
	jge	SHORT $LN7@operator
	mov	DWORD PTR [esi+8], 0
$LN7@operator:

; 358  :         return *this;

	movups	xmm0, XMMWORD PTR [esi]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	movups	XMMWORD PTR [eax], xmm0

; 359  :       }

	mov	esp, ebp
	pop	ebp
	ret	8
??_4kdu_dims@@QAE?AU0@AAU0@@Z ENDP			; kdu_dims::operator&=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?transpose@kdu_dims@@QAEXXZ
_TEXT	SEGMENT
?transpose@kdu_dims@@QAEXXZ PROC			; kdu_dims::transpose, COMDAT
; _this$ = ecx

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 329  :       { size.transpose(); pos.transpose(); }

	ret	0
?transpose@kdu_dims@@QAEXXZ ENDP			; kdu_dims::transpose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?area@kdu_dims@@QAE_JXZ
_TEXT	SEGMENT
?area@kdu_dims@@QAE_JXZ PROC				; kdu_dims::area, COMDAT
; _this$ = ecx

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [ecx+12]
	imul	DWORD PTR [ecx+8]
	ret	0
?area@kdu_dims@@QAE_JXZ ENDP				; kdu_dims::area
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_dims@@QAE@XZ
_TEXT	SEGMENT
??0kdu_dims@@QAE@XZ PROC				; kdu_dims::kdu_dims, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0

; 304  :     kdu_dims() {};

	mov	eax, ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0

; 304  :     kdu_dims() {};

	ret	0
??0kdu_dims@@QAE@XZ ENDP				; kdu_dims::kdu_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?to_apparent@kdu_coords@@QAEX_N00@Z
_TEXT	SEGMENT
_transp$ = 8						; size = 1
_vflip$ = 12						; size = 1
_hflip$ = 16						; size = 1
?to_apparent@kdu_coords@@QAEX_N00@Z PROC		; kdu_coords::to_apparent, COMDAT
; _this$ = ecx

; 271  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 272  :              Does the reverse of `from_apparent', assuming the same values
; 273  :              for `transp', `vflip' and `hflip' are supplied.
; 274  :         */
; 275  :         if (transp) transpose();

	cmp	BYTE PTR _transp$[ebp], 0
	je	SHORT $LN2@to_apparen

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
$LN2@to_apparen:

; 276  :         x = (hflip)?(-x):x;

	cmp	BYTE PTR _hflip$[ebp], 0
	mov	eax, DWORD PTR [ecx+4]
	je	SHORT $LN5@to_apparen
	neg	eax
$LN5@to_apparen:

; 277  :         y = (vflip)?(-y):y;

	cmp	BYTE PTR _vflip$[ebp], 0
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [ecx]
	je	SHORT $LN6@to_apparen
	neg	eax
$LN6@to_apparen:
	mov	DWORD PTR [ecx], eax

; 278  :       }

	pop	ebp
	ret	12					; 0000000cH
?to_apparent@kdu_coords@@QAEX_N00@Z ENDP		; kdu_coords::to_apparent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?from_apparent@kdu_coords@@QAEX_N00@Z
_TEXT	SEGMENT
_transp$ = 8						; size = 1
_vflip$ = 12						; size = 1
_hflip$ = 16						; size = 1
?from_apparent@kdu_coords@@QAEX_N00@Z PROC		; kdu_coords::from_apparent, COMDAT
; _this$ = ecx

; 260  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 261  :              Converts a point from the apparent coordinate system established
; 262  :              by `kdu_codestream::change_appearance' to the real coordinates.
; 263  :              The `transp', `vflip' and `hflip' parameters are identical to
; 264  :              those supplied to `kdu_codestream::change_appearance'.
; 265  :         */
; 266  :         x=(hflip)?(-x):x;

	cmp	BYTE PTR _hflip$[ebp], 0
	mov	eax, DWORD PTR [ecx+4]
	je	SHORT $LN5@from_appar
	neg	eax
$LN5@from_appar:

; 267  :         y=(vflip)?(-y):y;

	cmp	BYTE PTR _vflip$[ebp], 0
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	je	SHORT $LN7@from_appar
	neg	edx
$LN7@from_appar:

; 268  :         if (transp) transpose();

	cmp	BYTE PTR _transp$[ebp], 0
	mov	DWORD PTR [ecx], edx
	je	SHORT $LN2@from_appar

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
$LN2@from_appar:

; 269  :       }

	pop	ebp
	ret	12					; 0000000cH
?from_apparent@kdu_coords@@QAEX_N00@Z ENDP		; kdu_coords::from_apparent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??8kdu_coords@@QAE_NABU0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??8kdu_coords@@QAE_NABU0@@Z PROC			; kdu_coords::operator==, COMDAT
; _this$ = ecx

; 251  :       { return (x==rhs.x) && (y==rhs.y); }

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@operator
	mov	al, 1
	pop	ebp
	ret	4
$LN3@operator:
	xor	al, al
	pop	ebp
	ret	4
??8kdu_coords@@QAE_NABU0@@Z ENDP			; kdu_coords::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??Zkdu_coords@@QAE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??Zkdu_coords@@QAE?AU0@ABU0@@Z PROC			; kdu_coords::operator-=, COMDAT
; _this$ = ecx

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx]
	sub	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebp
	ret	8
??Zkdu_coords@@QAE?AU0@ABU0@@Z ENDP			; kdu_coords::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??Ykdu_coords@@QAE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??Ykdu_coords@@QAE?AU0@ABU0@@Z PROC			; kdu_coords::operator+=, COMDAT
; _this$ = ecx

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx]
	add	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebp
	ret	8
??Ykdu_coords@@QAE?AU0@ABU0@@Z ENDP			; kdu_coords::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??Gkdu_coords@@QAE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??Gkdu_coords@@QAE?AU0@ABU0@@Z PROC			; kdu_coords::operator-, COMDAT
; _this$ = ecx

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR _rhs$[ebp]
	sub	edx, DWORD PTR [esi+4]
	sub	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx
	pop	esi
	pop	ebp
	ret	8
??Gkdu_coords@@QAE?AU0@ABU0@@Z ENDP			; kdu_coords::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??Hkdu_coords@@QAE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??Hkdu_coords@@QAE?AU0@ABU0@@Z PROC			; kdu_coords::operator+, COMDAT
; _this$ = ecx

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	esi
	mov	esi, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [esi+4]
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	pop	esi
	pop	ebp
	ret	8
??Hkdu_coords@@QAE?AU0@ABU0@@Z ENDP			; kdu_coords::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?transpose@kdu_coords@@QAEXXZ
_TEXT	SEGMENT
?transpose@kdu_coords@@QAEXXZ PROC			; kdu_coords::transpose, COMDAT
; _this$ = ecx

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
	ret	0
?transpose@kdu_coords@@QAEXXZ ENDP			; kdu_coords::transpose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_coords@@QAE@HH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
??0kdu_coords@@QAE@HH@Z PROC				; kdu_coords::kdu_coords, COMDAT
; _this$ = ecx

; 210  :     kdu_coords(int x, int y) {this->x=x; this->y=y; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??0kdu_coords@@QAE@HH@Z ENDP				; kdu_coords::kdu_coords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_coords@@QAE@XZ
_TEXT	SEGMENT
??0kdu_coords@@QAE@XZ PROC				; kdu_coords::kdu_coords, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kdu_coords@@QAE@XZ ENDP				; kdu_coords::kdu_coords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?kdu_get_core_version@@YAPBDXZ
_TEXT	SEGMENT
?kdu_get_core_version@@YAPBDXZ PROC			; kdu_get_core_version, COMDAT

; 109  :   return KDU_CORE_VERSION;

	mov	eax, OFFSET ??_C@_04GOIBNGKI@v6?41?$AA@

; 110  : }

	ret	0
?kdu_get_core_version@@YAPBDXZ ENDP			; kdu_get_core_version
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ??_Gkdu_thread_entity@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gkdu_thread_entity@@UAEPAXI@Z PROC			; kdu_thread_entity::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Gkdu_thread_entity@@UAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	cmp	DWORD PTR [esi+16], 0

; 188  :       { if (is_group_owner()) destroy();

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi], OFFSET ??_7kdu_thread_entity@@6B@

; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	je	SHORT $LN8@scalar
	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN8@scalar

; 188  :       { if (is_group_owner()) destroy();

	call	?destroy@kdu_thread_entity@@QAE_NXZ	; kdu_thread_entity::destroy
$LN8@scalar:
	mov	eax, DWORD PTR ___flags$[ebp]
	test	al, 1
	je	SHORT $LN16@scalar
	test	al, 4
	jne	SHORT $LN3@scalar
	push	esi
	call	??3kdu_thread_entity@@SAXPAX@Z		; kdu_thread_entity::operator delete
	add	esp, 4
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN3@scalar:
	push	40					; 00000028H
	push	esi
	call	?__global_delete@@YAXPAXI@Z		; __global_delete
	add	esp, 8
$LN16@scalar:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gkdu_thread_entity@@UAEPAXI@Z$1:
	call	___std_terminate
	ret	0
__ehhandler$??_Gkdu_thread_entity@@UAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Gkdu_thread_entity@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Gkdu_thread_entity@@UAEPAXI@Z ENDP			; kdu_thread_entity::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?on_finished@kdu_thread_entity@@MAEX_N@Z
_TEXT	SEGMENT
_exception_handled$ = 8					; size = 1
?on_finished@kdu_thread_entity@@MAEX_N@Z PROC		; kdu_thread_entity::on_finished, COMDAT
; _this$ = ecx

; 1119 :       on_finished(bool exception_handled) { return; }

	ret	4
?on_finished@kdu_thread_entity@@MAEX_N@Z ENDP		; kdu_thread_entity::on_finished
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?need_sync@kdu_thread_entity@@MAE_NXZ
_TEXT	SEGMENT
?need_sync@kdu_thread_entity@@MAE_NXZ PROC		; kdu_thread_entity::need_sync, COMDAT
; _this$ = ecx

; 1097 :     virtual bool need_sync() { return true; }

	mov	al, 1
	ret	0
?need_sync@kdu_thread_entity@@MAE_NXZ ENDP		; kdu_thread_entity::need_sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?do_sync@kdu_thread_entity@@MAEX_N@Z
_TEXT	SEGMENT
_exception_handled$ = 8					; size = 1
?do_sync@kdu_thread_entity@@MAEX_N@Z PROC		; kdu_thread_entity::do_sync, COMDAT
; _this$ = ecx

; 1073 :       do_sync(bool exception_handled) { return; }

	ret	4
?do_sync@kdu_thread_entity@@MAEX_N@Z ENDP		; kdu_thread_entity::do_sync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?release_lock@kdu_thread_entity@@QAEXH@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
?release_lock@kdu_thread_entity@@QAEXH@Z PROC		; kdu_thread_entity::release_lock, COMDAT
; _this$ = ecx

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _lock_id$[ebp]

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [ecx+eax*8+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN5@release_lo
	mov	DWORD PTR _lock_id$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	jmp	DWORD PTR __imp__ReleaseMutex@4
$LN5@release_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
	ret	4
?release_lock@kdu_thread_entity@@QAEXH@Z ENDP		; kdu_thread_entity::release_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?try_lock@kdu_thread_entity@@QAE_NH_N@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
$T1 = 12						; size = 4
_allow_exceptions$ = 12					; size = 1
?try_lock@kdu_thread_entity@@QAE_NH_N@Z PROC		; kdu_thread_entity::try_lock, COMDAT
; _this$ = ecx

; 1052 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp

; 1053 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1054 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	cmp	BYTE PTR _allow_exceptions$[ebp], 0
	mov	eax, DWORD PTR _lock_id$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edx, DWORD PTR [esi+28]
	lea	edi, DWORD PTR [edx+eax*8]
	je	SHORT $LN2@try_lock
	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN11@try_lock
$LN2@try_lock:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 551  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN7@try_lock
	push	0
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	SHORT $LN7@try_lock
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1056 :         lock->holder = this;  return true; }

	mov	DWORD PTR [edi+4], esi
	mov	al, 1
	pop	edi
	pop	esi
	pop	ebp
	ret	8
$LN7@try_lock:
	pop	edi

; 1055 :         if (!lock->mutex.try_lock()) return false;

	xor	al, al
	pop	esi

; 1056 :         lock->holder = this;  return true; }

	pop	ebp
	ret	8
$LN11@try_lock:

; 1053 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1054 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN13@try_lock:
$LN10@try_lock:
	int	3
?try_lock@kdu_thread_entity@@QAE_NH_N@Z ENDP		; kdu_thread_entity::try_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?acquire_lock@kdu_thread_entity@@QAEXH_N@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
$T1 = 12						; size = 4
_allow_exceptions$ = 12					; size = 1
?acquire_lock@kdu_thread_entity@@QAEXH_N@Z PROC		; kdu_thread_entity::acquire_lock, COMDAT
; _this$ = ecx

; 1024 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp

; 1025 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	cmp	BYTE PTR _allow_exceptions$[ebp], 0
	mov	eax, DWORD PTR _lock_id$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edx, DWORD PTR [esi+28]
	lea	edi, DWORD PTR [edx+eax*8]
	je	SHORT $LN2@acquire_lo
	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN9@acquire_lo
$LN2@acquire_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@acquire_lo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN6@acquire_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+4], esi
	pop	edi
	pop	esi
	pop	ebp
	ret	8
$LN9@acquire_lo:

; 1025 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN11@acquire_lo:
$LN8@acquire_lo:
	int	3
?acquire_lock@kdu_thread_entity@@QAEXH_N@Z ENDP		; kdu_thread_entity::acquire_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?get_num_locks@kdu_thread_entity@@UAEHXZ
_TEXT	SEGMENT
?get_num_locks@kdu_thread_entity@@UAEHXZ PROC		; kdu_thread_entity::get_num_locks, COMDAT
; _this$ = ecx

; 244  :     virtual int get_num_locks() { return (group==NULL)?1:this->num_locks; }

	cmp	DWORD PTR [ecx+16], 0
	mov	eax, 1
	je	SHORT $LN4@get_num_lo
	mov	eax, DWORD PTR [ecx+24]
$LN4@get_num_lo:
	ret	0
?get_num_locks@kdu_thread_entity@@UAEHXZ ENDP		; kdu_thread_entity::get_num_locks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?is_group_owner@kdu_thread_entity@@QAE_NXZ
_TEXT	SEGMENT
?is_group_owner@kdu_thread_entity@@QAE_NXZ PROC		; kdu_thread_entity::is_group_owner, COMDAT
; _this$ = ecx

; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN3@is_group_o
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN3@is_group_o
	mov	al, 1
	ret	0
$LN3@is_group_o:
	xor	al, al
	ret	0
?is_group_owner@kdu_thread_entity@@QAE_NXZ ENDP		; kdu_thread_entity::is_group_owner
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?new_instance@kdu_thread_entity@@UAEPAV1@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?new_instance@kdu_thread_entity@@UAEPAV1@XZ PROC	; kdu_thread_entity::new_instance, COMDAT
; _this$ = ecx

; 205  :     virtual kdu_thread_entity *new_instance() { return new kdu_thread_entity; }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?new_instance@kdu_thread_entity@@UAEPAV1@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	40					; 00000028H
	call	??2kdu_thread_entity@@SAPAXI@Z		; kdu_thread_entity::operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@new_instan
	mov	ecx, eax
	call	??0kdu_thread_entity@@QAE@XZ		; kdu_thread_entity::kdu_thread_entity
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@new_instan:
	xor	eax, eax
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?new_instance@kdu_thread_entity@@UAEPAV1@XZ$0:
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3kdu_thread_entity@@SAXPAX@Z		; kdu_thread_entity::operator delete
	pop	ecx
	ret	0
__ehhandler$?new_instance@kdu_thread_entity@@UAEPAV1@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?new_instance@kdu_thread_entity@@UAEPAV1@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?new_instance@kdu_thread_entity@@UAEPAV1@XZ ENDP	; kdu_thread_entity::new_instance
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ??1kdu_thread_entity@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kdu_thread_entity@@UAE@XZ PROC			; kdu_thread_entity::~kdu_thread_entity, COMDAT
; _this$ = ecx

; 188  :       { if (is_group_owner()) destroy();

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kdu_thread_entity@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 190  :       /* [SYNOPSIS]
; 191  :            While the destructor will perform all required cleanup, the
; 192  :            caller may be suspended for some time while waiting for worker
; 193  :            threads to complete.  For this reason, you are encouraged to
; 194  :            explicitly call the `destroy' function first.  This also provides
; 195  :            you with information on whether all threads terminated normally
; 196  :            or a failure was caught.
; 197  :       */
; 198  :     KDU_EXPORT void *operator new(size_t size);
; 199  :       /* This function allocates the thread object in such a way that it
; 200  :          occupies a whole number of L2 cache lines, thereby maximizing
; 201  :          cache utilization efficiency. */
; 202  :     KDU_EXPORT void operator delete(void *ptr);
; 203  :       /* This function deletes the memory allocated using the custom new
; 204  :          operator defined above. */
; 205  :     virtual kdu_thread_entity *new_instance() { return new kdu_thread_entity; }
; 206  :       /* [SYNOPSIS]
; 207  :            The `add_thread' function uses this function to create new
; 208  :            `kdu_thread_entity' objects for each new worker thread.  You
; 209  :            can override this virtual function to create objects of your own
; 210  :            derived class, thereby ensuring that all worker threads will
; 211  :            also use the derived class.  This is particularly convenient if
; 212  :            you want each thread in a group to manage additional
; 213  :            thread-specific data.  By careful implementation of the function
; 214  :            override, you can also arrange to inherit parameters from the
; 215  :            thread which creates new workers.
; 216  :       */
; 217  :     bool exists() { return (group != NULL); }
; 218  :       /* [SYNOPSIS]
; 219  :            Returns true only between calls to `create' and `destroy'.
; 220  :            You should not use a `kdu_thread_entity' object until it has
; 221  :            been created.
; 222  :       */
; 223  :     bool operator!() { return !exists(); }
; 224  :       /* [SYNOPSIS]
; 225  :            Opposite of `exists'.
; 226  :       */
; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	cmp	DWORD PTR [ecx+16], 0

; 188  :       { if (is_group_owner()) destroy();

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_thread_entity@@6B@

; 190  :       /* [SYNOPSIS]
; 191  :            While the destructor will perform all required cleanup, the
; 192  :            caller may be suspended for some time while waiting for worker
; 193  :            threads to complete.  For this reason, you are encouraged to
; 194  :            explicitly call the `destroy' function first.  This also provides
; 195  :            you with information on whether all threads terminated normally
; 196  :            or a failure was caught.
; 197  :       */
; 198  :     KDU_EXPORT void *operator new(size_t size);
; 199  :       /* This function allocates the thread object in such a way that it
; 200  :          occupies a whole number of L2 cache lines, thereby maximizing
; 201  :          cache utilization efficiency. */
; 202  :     KDU_EXPORT void operator delete(void *ptr);
; 203  :       /* This function deletes the memory allocated using the custom new
; 204  :          operator defined above. */
; 205  :     virtual kdu_thread_entity *new_instance() { return new kdu_thread_entity; }
; 206  :       /* [SYNOPSIS]
; 207  :            The `add_thread' function uses this function to create new
; 208  :            `kdu_thread_entity' objects for each new worker thread.  You
; 209  :            can override this virtual function to create objects of your own
; 210  :            derived class, thereby ensuring that all worker threads will
; 211  :            also use the derived class.  This is particularly convenient if
; 212  :            you want each thread in a group to manage additional
; 213  :            thread-specific data.  By careful implementation of the function
; 214  :            override, you can also arrange to inherit parameters from the
; 215  :            thread which creates new workers.
; 216  :       */
; 217  :     bool exists() { return (group != NULL); }
; 218  :       /* [SYNOPSIS]
; 219  :            Returns true only between calls to `create' and `destroy'.
; 220  :            You should not use a `kdu_thread_entity' object until it has
; 221  :            been created.
; 222  :       */
; 223  :     bool operator!() { return !exists(); }
; 224  :       /* [SYNOPSIS]
; 225  :            Opposite of `exists'.
; 226  :       */
; 227  :     bool is_group_owner() { return (group != NULL) && (thread_idx == 0); }

	je	SHORT $LN2@kdu_thread
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN2@kdu_thread

; 188  :       { if (is_group_owner()) destroy();

	call	?destroy@kdu_thread_entity@@QAE_NXZ	; kdu_thread_entity::destroy
$LN2@kdu_thread:

; 189  :         assert(group == NULL); }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kdu_thread_entity@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kdu_thread_entity@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kdu_thread_entity@@UAE@XZ ENDP			; kdu_thread_entity::~kdu_thread_entity
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ?get_lifting_factors@kdu_kernels@@QAEPBMAAHAAM1@Z
_TEXT	SEGMENT
_num_steps$ = 8						; size = 4
_dc_scale$ = 12						; size = 4
_nyq_scale$ = 16					; size = 4
?get_lifting_factors@kdu_kernels@@QAEPBMAAHAAM1@Z PROC	; kdu_kernels::get_lifting_factors, COMDAT
; _this$ = ecx

; 246  :         {

	push	ebp
	mov	ebp, esp

; 247  :           num_steps = this->num_steps; dc_scale = this->low_scale;

	mov	eax, DWORD PTR _num_steps$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _dc_scale$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 248  :           nyq_scale = this->high_scale; return lifting_factors;

	mov	eax, DWORD PTR _nyq_scale$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR [ecx+20]

; 249  :         }

	pop	ebp
	ret	12					; 0000000cH
?get_lifting_factors@kdu_kernels@@QAEPBMAAHAAM1@Z ENDP	; kdu_kernels::get_lifting_factors
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ??1kdu_kernels@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kdu_kernels@@QAE@XZ PROC				; kdu_kernels::~kdu_kernels, COMDAT
; _this$ = ecx

; 147  :     ~kdu_kernels() { reset(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kdu_kernels@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	call	?reset@kdu_kernels@@AAEXXZ		; kdu_kernels::reset
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kdu_kernels@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kdu_kernels@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kdu_kernels@@QAE@XZ ENDP				; kdu_kernels::~kdu_kernels
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ??0kdu_kernels@@QAE@XZ
_TEXT	SEGMENT
??0kdu_kernels@@QAE@XZ PROC				; kdu_kernels::kdu_kernels, COMDAT
; _this$ = ecx

; 135  :     kdu_kernels() { clear(); }

	push	esi
	mov	esi, ecx
	call	?clear@kdu_kernels@@AAEXXZ		; kdu_kernels::clear
	mov	eax, esi
	pop	esi
	ret	0
??0kdu_kernels@@QAE@XZ ENDP				; kdu_kernels::kdu_kernels
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ??0kdu_kernel_step_info@@QAE@XZ
_TEXT	SEGMENT
??0kdu_kernel_step_info@@QAE@XZ PROC			; kdu_kernel_step_info::kdu_kernel_step_info, COMDAT
; _this$ = ecx

; 101  :       { support_length = support_min = 0;  downshift = rounding_offset = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0kdu_kernel_step_info@@QAE@XZ ENDP			; kdu_kernel_step_info::kdu_kernel_step_info
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1siz_params@@UAE@XZ
_TEXT	SEGMENT
??1siz_params@@UAE@XZ PROC				; siz_params::~siz_params, COMDAT
; _this$ = ecx
	jmp	??1kdu_params@@UAE@XZ			; kdu_params::~kdu_params
??1siz_params@@UAE@XZ ENDP				; siz_params::~siz_params
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?get_instance@kdu_params@@QAEHXZ
_TEXT	SEGMENT
?get_instance@kdu_params@@QAEHXZ PROC			; kdu_params::get_instance, COMDAT
; _this$ = ecx

; 725  :     int get_instance() { return inst_idx; }

	mov	eax, DWORD PTR [ecx+16]
	ret	0
?get_instance@kdu_params@@QAEHXZ ENDP			; kdu_params::get_instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ??_Gkdu_output@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkdu_output@@UAEPAXI@Z PROC				; kdu_output::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 132  :     virtual ~kdu_output() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_output@@6B@
	je	SHORT $LN7@scalar
	push	524					; 0000020cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkdu_output@@UAEPAXI@Z ENDP				; kdu_output::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?write@kdu_output@@QAEXPAEH@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_count$ = 12						; size = 4
?write@kdu_output@@QAEXPAEH@Z PROC			; kdu_output::write, COMDAT
; _this$ = ecx

; 175  :       {

	push	ebp
	mov	ebp, esp
	push	ebx

; 176  :       /* [SYNOPSIS] Writes zero or more bytes from the supplied buffer.
; 177  :          [ARG: buf] Points to the source byte buffer.
; 178  :          [ARG: count] The number of bytes to write from the buffer. */
; 179  :         while (count > 0)

	mov	ebx, DWORD PTR _count$[ebp]
	push	esi
	mov	esi, ecx
	test	ebx, ebx
	jle	SHORT $LN3@write
	push	edi
	mov	edi, DWORD PTR _buf$[ebp]
$LL2@write:

; 180  :           {
; 181  :             int xfer_bytes = (int)(end_buf - next_buf);

	mov	eax, DWORD PTR [esi+520]
	sub	eax, DWORD PTR [esi+516]

; 182  :             if (xfer_bytes == 0)

	jne	SHORT $LN6@write

; 183  :               { flush_buf(); xfer_bytes = (int)(end_buf - next_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi+520]
	sub	eax, DWORD PTR [esi+516]
$LN6@write:

; 184  :             xfer_bytes = (count < xfer_bytes)?count:xfer_bytes;

	cmp	ebx, eax
	cmovl	eax, ebx

; 185  :             count -= xfer_bytes;

	sub	ebx, eax

; 186  :             while (xfer_bytes--)

	test	eax, eax
	je	SHORT $LN10@write
	npad	2
$LL4@write:

; 187  :               *(next_buf++) = *(buf++);

	mov	edx, DWORD PTR [esi+516]
	mov	cl, BYTE PTR [edi]
	inc	edi
	mov	BYTE PTR [edx], cl
	inc	DWORD PTR [esi+516]
	sub	eax, 1
	jne	SHORT $LL4@write
$LN10@write:

; 176  :       /* [SYNOPSIS] Writes zero or more bytes from the supplied buffer.
; 177  :          [ARG: buf] Points to the source byte buffer.
; 178  :          [ARG: count] The number of bytes to write from the buffer. */
; 179  :         while (count > 0)

	test	ebx, ebx
	jg	SHORT $LL2@write
	pop	edi
$LN3@write:
	pop	esi
	pop	ebx

; 188  :           }
; 189  :       }

	pop	ebp
	ret	8
?write@kdu_output@@QAEXPAEH@Z ENDP			; kdu_output::write
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?put@kdu_output@@QAEHI@Z
_TEXT	SEGMENT
_word$ = 8						; size = 4
?put@kdu_output@@QAEHI@Z PROC				; kdu_output::put, COMDAT
; _this$ = ecx

; 155  :       {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN4@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
$LN4@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 156  :       /* [SYNOPSIS] Writes a 4-byte word in big-endian order.
; 157  :          [RETURNS] Always returns 4. */
; 158  :         put((kdu_byte)(word>>24));

	mov	ebx, DWORD PTR _word$[ebp]
	mov	ecx, ebx
	shr	ecx, 24					; 00000018H

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN7@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN7@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 159  :         put((kdu_byte)(word>>16));

	mov	ecx, ebx
	shr	ecx, 16					; 00000010H

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN10@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN10@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 160  :         put((kdu_byte)(word>>8));

	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN13@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN13@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl

; 161  :         put((kdu_byte)(word>>0));
; 162  :         return 4;

	mov	eax, 4

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
	pop	esi
	pop	ebx

; 163  :       }

	pop	ebp
	ret	4
?put@kdu_output@@QAEHI@Z ENDP				; kdu_output::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?put@kdu_output@@QAEHG@Z
_TEXT	SEGMENT
_word$ = 8						; size = 2
?put@kdu_output@@QAEHG@Z PROC				; kdu_output::put, COMDAT
; _this$ = ecx

; 147  :       {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN4@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
$LN4@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ebx, DWORD PTR _word$[ebp]
	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN7@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN7@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl

; 151  :         put((kdu_byte)(word>>0));
; 152  :         return 2;

	mov	eax, 2

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
	pop	esi
	pop	ebx

; 153  :       }

	pop	ebp
	ret	4
?put@kdu_output@@QAEHG@Z ENDP				; kdu_output::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?put@kdu_output@@QAEHE@Z
_TEXT	SEGMENT
_byte$ = 8						; size = 1
?put@kdu_output@@QAEHE@Z PROC				; kdu_output::put, COMDAT
; _this$ = ecx

; 138  :       {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 139  :       /* [SYNOPSIS] Writes a single byte.
; 140  :          [RETURNS] Always returns 1. */
; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN2@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
$LN2@put:

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
	mov	al, BYTE PTR _byte$[ebp]
	mov	BYTE PTR [ecx], al

; 144  :         return 1;

	mov	eax, 1
	inc	DWORD PTR [esi+516]
	pop	esi

; 145  :       }

	pop	ebp
	ret	4
?put@kdu_output@@QAEHE@Z ENDP				; kdu_output::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ??1kdu_output@@UAE@XZ
_TEXT	SEGMENT
??1kdu_output@@UAE@XZ PROC				; kdu_output::~kdu_output, COMDAT
; _this$ = ecx

; 132  :     virtual ~kdu_output() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_output@@6B@
	ret	0
??1kdu_output@@UAE@XZ ENDP				; kdu_output::~kdu_output
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ??0kdu_output@@QAE@XZ
_TEXT	SEGMENT
??0kdu_output@@QAE@XZ PROC				; kdu_output::kdu_output, COMDAT
; _this$ = ecx

; 131  :       { next_buf = buffer; end_buf = buffer+KDU_OBUF_SIZE; }

	lea	edx, DWORD PTR [ecx+516]
	mov	DWORD PTR [ecx], OFFSET ??_7kdu_output@@6B@
	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+520], edx
	mov	DWORD PTR [edx], eax
	mov	eax, ecx
	ret	0
??0kdu_output@@QAE@XZ ENDP				; kdu_output::kdu_output
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@G@Z
_TEXT	SEGMENT
_text$1 = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_val$ = 8						; size = 2
??6kdu_message@@QAEAAV0@G@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 275  :       { return (*this)<<(unsigned int) val; }

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	movzx	eax, WORD PTR _val$[ebp]
	push	esi
	mov	esi, ecx

; 266  :         sprintf(text,(mode_hex)?"%x":"%u",val);

	mov	ecx, OFFSET ??_C@_02GMHACPFF@?$CFu?$AA@
	push	eax
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmp	BYTE PTR [esi+4], 0
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$1[ebp]
	push	eax
	call	_sprintf

; 267  :         put_text(text); return *this; }

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _text$1[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, esi
	push	eax
	call	DWORD PTR [edx+8]

; 275  :       { return (*this)<<(unsigned int) val; }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@G@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@I@Z
_TEXT	SEGMENT
_text$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_val$ = 8						; size = 4
??6kdu_message@@QAEAAV0@I@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 265  :       { char text[80];

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 266  :         sprintf(text,(mode_hex)?"%x":"%u",val);

	push	DWORD PTR _val$[ebp]
	mov	esi, ecx
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	ecx, OFFSET ??_C@_02GMHACPFF@?$CFu?$AA@
	cmp	BYTE PTR [esi+4], 0
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_sprintf

; 267  :         put_text(text); return *this; }

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _text$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, esi
	push	eax
	call	DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@I@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@H@Z
_TEXT	SEGMENT
_text$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_val$ = 8						; size = 4
??6kdu_message@@QAEAAV0@H@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 261  :       { char text[80];

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	push	DWORD PTR _val$[ebp]
	mov	esi, ecx
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	BYTE PTR [esi+4], 0
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_sprintf

; 263  :         put_text(text); return *this; }

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _text$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, esi
	push	eax
	call	DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@H@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
??6kdu_message@@QAEAAV0@PBD@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 257  :       { put_text(string); return *this; }

	push	ebp
	mov	ebp, esp
	push	esi
	push	DWORD PTR _string$[ebp]
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@PBD@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?set_hex_mode@kdu_message@@QAE_N_N@Z
_TEXT	SEGMENT
_new_mode$ = 8						; size = 1
?set_hex_mode@kdu_message@@QAE_N_N@Z PROC		; kdu_message::set_hex_mode, COMDAT
; _this$ = ecx

; 247  :       { bool old_mode = mode_hex; mode_hex = new_mode; return old_mode; }

	push	ebp
	mov	ebp, esp
	mov	dl, BYTE PTR _new_mode$[ebp]
	mov	al, BYTE PTR [ecx+4]
	mov	BYTE PTR [ecx+4], dl
	pop	ebp
	ret	4
?set_hex_mode@kdu_message@@QAE_N_N@Z ENDP		; kdu_message::set_hex_mode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1391 : }

	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\visual studio\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
;	COMDAT ?floor_ratio@@YAHHH@Z
_TEXT	SEGMENT
_num$ = 8						; size = 4
_den$ = 12						; size = 4
?floor_ratio@@YAHHH@Z PROC				; floor_ratio, COMDAT

; 191  : { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 192  :        Returns the floor function of the ratio `num' / `den', where
; 193  :        the denominator is required to be strictly positive.
; 194  :      [RETURNS] Non-negative ratio.
; 195  :      [ARG: num] Non-negative numerator.
; 196  :      [ARG: den] Non-negative denomenator.
; 197  :   */
; 198  :   assert(den > 0);
; 199  :   if (num < 0)

	mov	edx, DWORD PTR _num$[ebp]
	test	edx, edx
	jns	SHORT $LN2@floor_rati

; 200  :     return -(1+((-num-1)/den));

	or	ecx, -1
	mov	eax, ecx
	sub	eax, edx
	cdq
	idiv	DWORD PTR _den$[ebp]
	sub	ecx, eax
	mov	eax, ecx

; 203  : }

	pop	ebp
	ret	0
$LN2@floor_rati:

; 201  :   else
; 202  :     return num/den;

	mov	eax, edx
	cdq
	idiv	DWORD PTR _den$[ebp]

; 203  : }

	pop	ebp
	ret	0
?floor_ratio@@YAHHH@Z ENDP				; floor_ratio
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
;	COMDAT ?ceil_ratio@@YAHHH@Z
_TEXT	SEGMENT
_num$ = 8						; size = 4
_den$ = 12						; size = 4
?ceil_ratio@@YAHHH@Z PROC				; ceil_ratio, COMDAT

; 171  : { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 172  :        Returns the ceiling function of the ratio `num' / `den', where
; 173  :        the denominator is required to be strictly positive.
; 174  :      [RETURNS] Non-negative ratio.
; 175  :      [ARG: num] Non-negative numerator.
; 176  :      [ARG: den] Non-negative denomenator.
; 177  :   */
; 178  :   assert(den > 0);
; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _num$[ebp]
	test	eax, eax
	jg	SHORT $LN2@ceil_ratio

; 180  :     return -((-num)/den);

	cdq
	idiv	DWORD PTR _den$[ebp]

; 183  : }

	pop	ebp
	ret	0
$LN2@ceil_ratio:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	DWORD PTR _den$[ebp]
	inc	eax

; 183  : }

	pop	ebp
	ret	0
?ceil_ratio@@YAHHH@Z ENDP				; ceil_ratio
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?unlock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?unlock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::unlock, COMDAT
; _this$ = ecx

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@unlock
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	cmp	eax, 1
	jne	SHORT $LN3@unlock
	mov	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
$LN3@unlock:

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	xor	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
?unlock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?try_lock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?try_lock@kdu_mutex@@QAE_NXZ PROC			; kdu_mutex::try_lock, COMDAT
; _this$ = ecx

; 544  :              Same as `lock', except that the call is non-blocking.  If the
; 545  :              mutex is already locked by another thread, the function returns
; 546  :              false immediately.
; 547  :            [RETURNS]
; 548  :              False if the mutex is currently locked by another thread, or
; 549  :              has not been successfully created. */
; 550  : #       if defined KDU_WIN_THREADS
; 551  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@try_lock
	push	0
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	SHORT $LN3@try_lock
	mov	al, 1

; 552  :                   (WaitForSingleObject(mutex,0) == WAIT_OBJECT_0));
; 553  : #       elif defined KDU_PTHREADS
; 554  :           return (mutex_valid && (pthread_mutex_trylock(&mutex)==0));
; 555  : #       else
; 556  :           return false;
; 557  : #       endif
; 558  :       }

	ret	0
$LN3@try_lock:

; 544  :              Same as `lock', except that the call is non-blocking.  If the
; 545  :              mutex is already locked by another thread, the function returns
; 546  :              false immediately.
; 547  :            [RETURNS]
; 548  :              False if the mutex is currently locked by another thread, or
; 549  :              has not been successfully created. */
; 550  : #       if defined KDU_WIN_THREADS
; 551  :           return ((mutex != NULL) &&

	xor	al, al

; 552  :                   (WaitForSingleObject(mutex,0) == WAIT_OBJECT_0));
; 553  : #       elif defined KDU_PTHREADS
; 554  :           return (mutex_valid && (pthread_mutex_trylock(&mutex)==0));
; 555  : #       else
; 556  :           return false;
; 557  : #       endif
; 558  :       }

	ret	0
?try_lock@kdu_mutex@@QAE_NXZ ENDP			; kdu_mutex::try_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?lock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?lock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::lock, COMDAT
; _this$ = ecx

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@lock
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	SHORT $LN3@lock
	mov	al, 1

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
$LN3@lock:

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	xor	al, al

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
?lock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\codestream.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
